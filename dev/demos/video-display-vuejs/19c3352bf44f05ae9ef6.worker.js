!function(Q){var B={};function I(F){if(B[F])return B[F].exports;var U=B[F]={i:F,l:!1,exports:{}};return Q[F].call(U.exports,U,U.exports,I),U.l=!0,U.exports}I.m=Q,I.c=B,I.d=function(Q,B,F){I.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:F})},I.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},I.t=function(Q,B){if(1&B&&(Q=I(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var F=Object.create(null);if(I.r(F),Object.defineProperty(F,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var U in Q)I.d(F,U,function(B){return Q[B]}.bind(null,U));return F},I.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return I.d(B,"a",B),B},I.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},I.p="",I(I.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/Constants.js\nconst DATA_SYNCHRONIZER_TOPIC = 'data-synchronizer-';\nconst TIME_SYNCHRONIZER_TOPIC = 'data-synchronizer-time-';\nconst DATASOURCE_DATA_TOPIC = 'datasource-data-';\nconst DATASOURCE_TIME_TOPIC = 'datasource-time-';\nconst FFMPEG_VIEW_DECODE_TOPIC = 'ffmpeg-decode-';\nconst MAGIC_END_PACKET = 'magic-packet';\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/event/EventType.js\nconst EventType = {\n  DATA: 'data',\n  LAST_TIME: 'last-time',\n  MASTER_TIME: 'master-time',\n  STATUS: 'status',\n  TIME_CHANGED: 'time-changed',\n  CLOSED: 'closed'\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/utils/Utils.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n/** * @module Utils */\n\n/** Maximum value of a long */\nconst MAX_LONG = Math.pow(2, 53) + 1;\n/**\n * Global helper method to test if a letiable or object attribute is defined\n */\n\nfunction isDefined(v) {\n  return typeof v !== 'undefined' && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute has a value,\n that is it is defined and non null\n */\n\nfunction hasValue(v) {\n  return isDefined(v) && v !== null;\n}\n/**\n Global helper method to transform hex color into RGBA\n */\n\nfunction hex2rgb(hex) {\n  const [r, g, b] = hex.match(/\\w\\w/g).map(x => parseInt(x, 16));\n  return [r, g, b];\n}\n/**\n Global helper method to test if a letiable or object attribute is of a particular type\n */\n\nfunction hasType(v, expectedType) {\n  let hasVal = hasValue(v);\n  return hasVal && typeof v === expectedType;\n}\n/**\n Global helper method to test if a letiable or object attribute is an object\n */\n\nfunction isObject(v, letName) {\n  return hasType(v, 'object', letName);\n}\n/**\n Global helper method to test if a letiable or object attribute is an array\n */\n\nfunction isArray(v) {\n  return isDefined(v) && Array.isArray(v);\n}\n/**\n Global helper method to test if a letiable or object attribute is a function\n */\n\nfunction isFunction(v, letName) {\n  return hasType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined\n **/\n\nfunction assertDefined(v, letName = 'letiable') {\n  if (!isDefined(v)) {\n    throw letName + \" must be defined\";\n  }\n\n  return v;\n}\nfunction assertTrue(v, letName = 'letiable') {\n  if (!isDefined(v) || !v) {\n    throw letName;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertType(v, expectedType, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (typeof v !== expectedType) {\n    throw letName + \" must be of type \" + expectedType;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertBoolean(v, letName) {\n  return assertType(v, 'boolean', letName);\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertString(v, letName) {\n  return assertType(v, 'string', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertNumber(v, letName) {\n  return assertType(v, 'number', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertPositive(v, letName) {\n  assertNumber(v, letName);\n\n  if (v <= 0) {\n    throw letName + \" must be a positive number\";\n  }\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertObject(v, letName) {\n  return assertType(v, 'object', letName);\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertArray(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!Array.isArray(v)) {\n    throw letName + \" must be an array\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a function\n **/\n\nfunction assertFunction(v, letName) {\n  return assertType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertHasValue(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!hasValue(v)) {\n    throw letName + \" must not be null\";\n  }\n\n  return v;\n}\n/**\n *\n * @return {String}\n */\n\nfunction randomUUID() {\n  return 'xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * This function stamps/embeds a UUID into an object and returns the UUID generated for it\n * @return {String}\n */\n\nfunction stampUUID(obj) {\n  obj._osh_id = obj._osh_id || randomUUID();\n  return obj._osh_id;\n} //buffer is an ArrayBuffer object, the offset if specified in bytes, and the type is a string\n//corresponding to an OGC data type.\n//See http://def.seegrid.csiro.au/sissvoc/ogc-def/resource?uri=http://www.opengis.net/def/dataType/OGC/0/\n\n/**\n *\n * @param buffer\n * @param offset\n * @param type\n * @return {*}\n */\n\nfunction ParseBytes(buffer, offset, type) {\n  let view = new DataView(buffer); //Note: There exist types not listed in the map below that have OGC definitions, but no appropriate\n  //methods or corresponding types available for parsing in javascript. They are float128, float16, signedLong,\n  //and unsignedLong\n\n  let typeMap = {\n    double: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float64: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float32: function (offset) {\n      return {\n        val: view.getFloat32(offset),\n        bytes: 4\n      };\n    },\n    signedByte: function (offset) {\n      return {\n        val: view.getInt8(offset),\n        bytes: 1\n      };\n    },\n    signedInt: function (offset) {\n      return {\n        val: view.getInt32(offset),\n        bytes: 4\n      };\n    },\n    signedShort: function (offset) {\n      return {\n        val: view.getInt16(offset),\n        bytes: 2\n      };\n    },\n    unsignedByte: function (offset) {\n      return {\n        val: view.getUint8(offset),\n        bytes: 1\n      };\n    },\n    unsignedInt: function (offset) {\n      return {\n        val: view.getUint32(offset),\n        bytes: 4\n      };\n    },\n    unsignedShort: function (offset) {\n      return {\n        val: view.getUint16(offset),\n        bytes: 2\n      };\n    } //TODO: string-utf-8:\n\n  };\n  return typeMap[type](offset);\n} //This function recursivley iterates over the resultStructure to fill in\n//values read from data which should be an ArrayBuffer containing the payload from a websocket\n\n/**\n *\n * @param struct\n * @param data\n * @param offsetBytes\n * @return {*}\n */\n\nfunction ReadData(struct, data, offsetBytes) {\n  let offset = offsetBytes;\n\n  for (let i = 0; i < struct.fields.length; i++) {\n    let currFieldStruct = struct.fields[i];\n\n    if (isDefined(currFieldStruct.type) && currFieldStruct.type !== null) {\n      let ret = ParseBytes(data, offset, currFieldStruct.type);\n      currFieldStruct.val = ret.val;\n      offset += ret.bytes;\n    } else if (isDefined(currFieldStruct.count) && currFieldStruct.count !== null) {\n      //check if count is a reference to another letiable\n      if (isNaN(currFieldStruct.count)) {\n        let id = currFieldStruct.count;\n        let fieldName = struct.id2FieldMap[id];\n        currFieldStruct.count = struct.findFieldByName(fieldName).val;\n      }\n\n      for (let c = 0; c < currFieldStruct.count; c++) {\n        for (let j = 0; j < currFieldStruct.fields.length; j++) {\n          let field = JSON.parse(JSON.stringify(currFieldStruct.fields[j]));\n          offset = ReadData(field, data, offset);\n          currFieldStruct.val.push(field);\n        }\n      }\n    }\n  }\n\n  return offset;\n}\n/**\n *\n * @param resultStructure\n * @return {{}}\n */\n\nfunction GetResultObject(resultStructure) {\n  //TODO: handle cases for nested arrays / matrix data types\n  let result = {};\n\n  for (let i = 0; i < resultStructure.fields.length; i++) {\n    if (isDefined(resultStructure.fields[i].count)) {\n      result[resultStructure.fields[i].name] = [];\n\n      for (let c = 0; c < resultStructure.fields[i].count; c++) {\n        let item = {};\n\n        for (let k = 0; k < resultStructure.fields[i].val[c].fields.length; k++) {\n          item[resultStructure.fields[i].val[c].fields[k].name] = resultStructure.fields[i].val[c].fields[k].val;\n        }\n\n        result[resultStructure.fields[i].name].push(item);\n      }\n    } else {\n      result[resultStructure.fields[i].name] = resultStructure.fields[i].val;\n    }\n  }\n\n  return result;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isOpera() {\n  return !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isFirefox() {\n  return typeof InstallTrigger !== 'undefined';\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isSafari() {\n  return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isChrome() {\n  return !!window.chrome && !!window.chrome.webstore;\n}\n/**\n *\n * @return {*|boolean}\n */\n\nfunction isBlink() {\n  return (isChrome || isOpera) && !!window.CSS;\n}\n/**\n *\n * @param a\n * @param b\n * @return {boolean}\n */\n\nfunction isArrayIntersect(a, b) {\n  return a.filter(function (element) {\n    return b.indexOf(element) > -1;\n  }).length > 0;\n}\n/**\n *\n * @param o\n * @return {boolean}\n */\n\nfunction isElement(o) {\n  return typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n  o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n}\n/**\n *\n * @return {*}\n */\n\nfunction isWebWorker() {\n  return isDefined(Worker);\n}\n/**\n *\n * @param div\n */\n\nfunction takeScreenShot(div) {}\n/**\n * Remove a css class from a the div given as argument.\n * @param div the div to remove the class from\n * @param css the css class to remove\n */\n\nfunction removeCss(div, css) {\n  let divCss = div.className;\n  css = divCss.replace(css, \"\");\n  div.className = css;\n}\n/**\n * Add a css class to a the div given as argument.\n * @param div the div to add the class to\n * @param css the css class to add\n */\n\nfunction addCss(div, css) {\n  div.setAttribute(\"class\", div.className + \" \" + css);\n}\n/**\n * Removes the last character of a {string} object.\n * @param {string} value - The input {string}\n * @return {string} The value without the last character\n */\n\nfunction removeLastCharIfExist(value) {\n  if (!isDefined(undefined) || value === null || value.length === 0 || !value.endsWith(\"/\")) {\n    return value;\n  }\n\n  return value.substring(0, value.length - 1);\n}\n/**\n * Capitalize the first letter of a given string\n * @param {String} str - the input string\n * @returns {String} the result\n */\n\nfunction capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n/**\n * Round off number to nearest 0.5\n * @param {Number} num - The number to round off\n * @return {number} The rounded number\n */\n\nfunction roundHalf(num) {\n  return Math.round(num * 2) / 2;\n}\n/**\n * Returns a function that, as long as it continues to be invoked,\n * will not be executed. The function will only be executed when\n * it will stop being called for more than N milliseconds.\n * If the `immediate` parameter is true, then the function\n * will be executed at the first call instead of the last.\n * Parameters :\n * - func: the function to `debouncer`.\n * - wait: the number of milliseconds (N) to wait before\n * call func()\n * - immediate (optional): Call func() at the first invocation\n * instead of the last one (Default false)\n * - context (optional): the context in which to call func()\n * (this by default)\n */\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n\nfunction debounce(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n\n  var later = function () {\n    var now = new Date().getTime(),\n        last = now - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = new Date().getTime();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n}\n;\nfunction throttle(func, wait, leading, trailing, context) {\n  var ctx, args, result;\n  var timeout = null;\n  var previous = 0;\n\n  var later = function () {\n    previous = new Date();\n    timeout = null;\n    result = func.apply(ctx, args);\n  };\n\n  return function () {\n    var now = new Date();\n    if (!previous && !leading) previous = now;\n    var remaining = wait - (now - previous);\n    ctx = context || this;\n    args = arguments;\n\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(ctx, args);\n    } else if (!timeout && trailing) {\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n;\nfunction merge(target, source) {\n  // Iterate through `source` properties and if an `Object` set property to merge of `target` and `source` properties\n  for (const key of Object.keys(source)) {\n    if (source[key] instanceof Object && key in target) Object.assign(source[key], merge(target[key], source[key]));\n  } // Join `target` and modified `source`\n\n\n  Object.assign(target || {}, source);\n  return target;\n}\n;\nfunction rgbaToArray(str) {\n  let startIdxValue = str.indexOf('(') + 1;\n  let endIdxValue = str.indexOf(')');\n  let values = str.substr(startIdxValue, endIdxValue - startIdxValue);\n  return values.split(',').map(Number);\n}\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/connector/Status.js\n/**\n * Enum for connection status.\n * @readonly\n * @enum {{name: string}}\n */\nconst Status = {\n  CONNECTING: \"connecting\",\n  CONNECTED: \"connected\",\n  DISCONNECTED: \"disconnected\",\n  FETCH_STARTED: 'fetch-start',\n  FETCH_ENDED: 'fetch-end',\n  CLOSED: \"closed\",\n  CLOSED_ERROR: \"closed-error\"\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/DataSynchronizerAlgo.js\n\n\n\nclass DataSynchronizerAlgo_DataSynchronizerAlgo {\n  constructor(dataSources, timerResolution = 5) {\n    this.dataSourceMap = {};\n    this.tsRun = undefined;\n    this.timerResolution = timerResolution;\n    this.interval = null;\n    this.datasources = [];\n\n    for (let ds of dataSources) {\n      this.addDataSource(ds);\n    }\n  }\n\n  removeDataSource(dataSourceId) {\n    this.datasources = this.datasources.filter(elt => elt.id !== dataSourceId);\n    delete this.dataSourceMap[dataSourceId];\n  }\n\n  push(dataSourceId, dataBlocks) {}\n\n  getCurrentTimestamp() {\n    return this.tsRun;\n  }\n\n  processData() {\n    let tsRef = -1;\n    let clockTimeRef = performance.now(); // get reference start timestamp\n    // the reference start timestamp should the oldest one\n\n    let currentDs;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.dataBuffer.length > 0) {\n        tsRef = tsRef === -1 || currentDs.dataBuffer[0].data.timestamp < tsRef ? currentDs.dataBuffer[0].data.timestamp : tsRef;\n      }\n    }\n\n    this.interval = setInterval(() => {\n      // 1) return the oldest data if any\n      while (this.computeNextData(tsRef, clockTimeRef));\n    }, this.timerResolution);\n    console.warn(`Started Algorithm ${this.constructor.name} with  tsRef=${new Date(tsRef).toISOString()}`);\n  }\n  /**\n   * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,\n   * we return only the oldest one.\n   * @param tsRef - the timestamp of the first data\n   * @param refClockTime - the absolute diff time really spent\n   */\n\n\n  computeNextData(tsRef, refClockTime) {\n    throw Error('Should be overridden');\n  }\n  /**\n   * Add dataSource to be synchronized\n   * @param {Datasource} dataSource - the dataSource to synchronize\n   */\n\n\n  addDataSource(dataSource) {\n    throw Error('Should be overridden');\n  }\n\n  checkVersion(datasource, dataBlock) {\n    throw Error('Should be overridden');\n  }\n\n  onData(dataSourceId, dataBlock) {}\n\n  checkStart() {}\n  /**\n   * Change the dataSource status\n   * @param {Status} status - the new status\n   * @param {String} dataSourceId - the corresponding dataSource id\n   */\n\n\n  setStatus(dataSourceId, status) {\n    throw Error('Should be overridden');\n  }\n\n  close() {\n    if (isDefined(this.interval)) {\n      clearInterval(this.interval);\n      this.interval = undefined;\n    }\n\n    console.log(\"Data synchronizer terminated successfully\");\n    this.onClose();\n  }\n\n  onStart() {}\n\n  onClose() {}\n\n}\n\n/* harmony default export */ var timesync_DataSynchronizerAlgo = (DataSynchronizerAlgo_DataSynchronizerAlgo);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/replay/DataSynchronizerAlgo.replay.js\n\n\n\n\nclass DataSynchronizerAlgo_replay_DataSynchronizerAlgoReplay extends timesync_DataSynchronizerAlgo {\n  constructor(dataSources, replaySpeed = 1, startTimestamp, endTimestamp, timerResolution = 5, version) {\n    super(dataSources, replaySpeed, timerResolution);\n    this.replaySpeed = replaySpeed;\n    this.startTimestamp = startTimestamp;\n    this.endTimestamp = endTimestamp;\n    this.version = version;\n  }\n\n  push(dataSourceId, dataBlocks) {\n    if (dataBlocks.length === 0) {\n      return;\n    }\n\n    if (dataSourceId in this.dataSourceMap) {\n      const ds = this.dataSourceMap[dataSourceId];\n      const lastData = dataBlocks[dataBlocks.length - 1];\n\n      if (!this.checkVersion(lastData)) {\n        console.warn(`[DataSynchronizer] incompatible version ${lastData.version} ~ ${this.version}, skipping data`);\n        return;\n      }\n\n      ds.dataBuffer.push(...dataBlocks);\n    }\n  }\n\n  processData() {\n    this.clockTimeRef = performance.now();\n    this.interval = setInterval(() => {\n      // 1) return the oldest data if any\n      while (this.computeNextData(this.startTimestamp, this.clockTimeRef)) {\n        this.checkEnd();\n      }\n\n      this.checkEnd();\n    }, this.timerResolution);\n    console.warn(`Started Replay Algorithm with tsRef=${new Date(this.startTimestamp).toISOString()}`);\n  }\n  /**\n   * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,\n   * we return only the oldest one.\n   * @param tsRef - the timestamp of the first data\n   * @param refClockTime - the absolute diff time really spent\n   */\n\n\n  computeNextData(tsRef, refClockTime) {\n    try {\n      let currentDs;\n      let currentDsToShift = null;\n      const dClock = (performance.now() - refClockTime) * this.replaySpeed;\n      let tsRun = tsRef + dClock;\n      let computeNext = false; // compute next data to return\n\n      for (let currentDsId in this.dataSourceMap) {\n        currentDs = this.dataSourceMap[currentDsId];\n\n        if (currentDs.skip) {\n          // if datasource is in current range\n          if (tsRun > currentDs.minTimestamp && tsRun < currentDs.maxTimestamp) {\n            currentDs.skip = false;\n          }\n        } // skip DatSource if out of time range\n\n\n        if (currentDs.skip) continue;\n\n        if (currentDs.dataBuffer.length > 0) {\n          const dTs = currentDs.dataBuffer[0].data.timestamp - tsRef; // we use an intermediate object to store the data to shift because we want to return the oldest one\n          // only\n\n          if (dTs <= dClock) {\n            // no other one to compare\n            if (currentDsToShift === null) {\n              currentDsToShift = currentDs;\n            } else {\n              // take the oldest data\n              currentDsToShift = currentDsToShift.dataBuffer[0].data.timestamp < currentDs.dataBuffer[0].data.timestamp ? currentDsToShift : currentDs;\n            }\n          }\n        }\n      } // finally pop the data from DS queue\n\n\n      if (currentDsToShift !== null) {\n        if (currentDsToShift.id in this.dataSourceMap) {\n          this.onData(currentDsToShift.id, currentDsToShift.dataBuffer.shift());\n        }\n\n        computeNext = true;\n      }\n\n      this.tsRun = tsRun;\n      return computeNext;\n    } catch (ex) {\n      console.log(ex);\n      return false;\n    }\n  }\n  /**\n   * Add dataSource to be synchronized\n   * @param {Datasource} dataSource - the dataSource to synchronize\n   */\n\n\n  addDataSource(dataSource) {\n    this.dataSourceMap[dataSource.id] = {\n      dataBuffer: [],\n      id: dataSource.id,\n      name: dataSource.name || dataSource.id,\n      status: Status.DISCONNECTED,\n      //MEANING Enabled, 0 = Disabled\n      minTimestamp: dataSource.minTimestamp,\n      maxTimestamp: dataSource.maxTimestamp,\n      skip: false\n    };\n\n    if (dataSource.maxTimestamp < this.getCurrentTimestamp() || dataSource.minTimestamp > this.getCurrentTimestamp()) {\n      this.dataSourceMap[dataSource.id].skip = true;\n      console.warn(`Skipping new added dataSource ${dataSource.id} because timeRange of the dataSource is not intersecting the synchronizer one`);\n    }\n\n    this.datasources.push(dataSource);\n  }\n\n  checkVersion(dataBlock) {\n    return dataBlock.version === this.version;\n  }\n  /**\n   * Change the dataSource status\n   * @param {Status} status - the new status\n   * @param {String} dataSourceId - the corresponding dataSource id\n   */\n\n\n  setStatus(dataSourceId, status) {\n    if (dataSourceId in this.dataSourceMap) {\n      this.dataSourceMap[dataSourceId].status = status;\n      console.warn(status + ' DataSource ' + dataSourceId + ' from the synchronizer ');\n    }\n\n    this.checkStart();\n  }\n\n  checkStart() {\n    if (!isDefined(this.interval)) {\n      let nbSkip = 0;\n      let nbFetch = 0;\n      let totalDataSources = Object.keys(this.dataSourceMap).length;\n\n      if (totalDataSources === 0) {\n        return;\n      }\n\n      let dataSource;\n\n      for (let dataSourceID in this.dataSourceMap) {\n        dataSource = this.dataSourceMap[dataSourceID];\n        dataSource.skip = this.startTimestamp < dataSource.minTimestamp || this.startTimestamp > dataSource.maxTimestamp;\n\n        if (dataSource.status === Status.FETCH_STARTED) {\n          nbFetch++;\n        } else if (dataSource.skip) {\n          nbSkip++;\n        }\n      }\n\n      console.warn(`[Synchronizer] Fetched ${nbFetch}/${totalDataSources} datasources`);\n      console.warn(`[Synchronizer] Skipped ${nbSkip}/${totalDataSources} datasources`);\n\n      if (nbFetch + nbSkip === totalDataSources) {\n        console.warn('Starting Replay Algorithm...');\n        this.processData();\n        this.onStart();\n      }\n    }\n  }\n\n  checkEnd() {\n    if (this.getCurrentTimestamp() > this.endTimestamp) {\n      this.onEnd();\n      this.reset();\n    }\n  }\n\n  reset() {\n    console.log('reset synchronizer algo');\n    this.close();\n\n    for (let currentDsId in this.dataSourceMap) {\n      this.resetDataSource(currentDsId);\n    }\n\n    this.tsRun = undefined;\n  }\n\n  resetDataSource(datasourceId) {\n    const currentDs = this.dataSourceMap[datasourceId];\n    currentDs.dataBuffer = [];\n    currentDs.status = Status.DISCONNECTED;\n    currentDs.version = undefined;\n    currentDs.skip = false;\n  }\n\n  removeDataSource(dataSourceId) {\n    super.removeDataSource(dataSourceId); // looking for next start Timestamp\n\n    let currentTimestamp = this.getCurrentTimestamp();\n    let min, ds;\n\n    for (let dsKey in this.dataSourceMap) {\n      ds = this.dataSourceMap[dsKey];\n\n      if (currentTimestamp >= ds.minTimestamp && currentTimestamp <= ds.maxTimestamp) {\n        // continue because this datasource is in the current range\n        return;\n      } else {\n        // otherwise\n        // looking for next range and reset algo\n        if (!min) {\n          min = ds.minTimestamp;\n        } else if (ds.minTimestamp < min) {\n          min = ds.minTimestamp;\n        }\n      }\n    }\n  }\n\n  setEndTimestamp(maxTimestamp) {\n    this.endTimestamp = maxTimestamp;\n  }\n\n  setTimeRange(startTimestamp, endTimestamp, replaySped) {\n    this.replaySpeed = replaySped;\n    this.startTimestamp = startTimestamp;\n    this.endTimestamp = endTimestamp;\n    this.clockTimeRef = performance.now();\n    this.reset();\n    this.checkStart();\n  }\n\n  onEnd() {}\n\n  onStart() {}\n\n}\n\n/* harmony default export */ var DataSynchronizerAlgo_replay = (DataSynchronizerAlgo_replay_DataSynchronizerAlgoReplay);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/replay/DataSynchronizer.replay.worker.js\n\n\n\n\n\nconst bcChannels = {};\nlet dataSynchronizerAlgo;\n\nlet init = false;\nlet dataSourceBroadCastChannel = null;\nlet lastData = undefined;\nconst dataSources = {};\nlet timeBroadcastChannel = null;\nlet topicTime;\nlet topicData;\nlet DataSynchronizer_replay_worker_replaySpeed;\nlet masterTimeInterval = undefined;\nlet cTime;\nlet cId;\nlet lastTime = -1;\nlet version = -1;\nlet promise;\nlet DataSynchronizer_replay_worker_masterTimeRefreshRate;\nlet DataSynchronizer_replay_worker_startTimestamp;\nlet DataSynchronizer_replay_worker_endTimestamp;\nlet timerResolution;\n\nself.onmessage = async (event) => {\n    if(isDefined(promise)) {\n        await promise;\n    }\n    promise = handleMessage(event);\n}\n\nasync function handleMessage(event) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            let sendResponse = true;\n            let data = undefined;\n            if (event.data.message === 'init') {\n                DataSynchronizer_replay_worker_replaySpeed = event.data.replaySpeed;\n                DataSynchronizer_replay_worker_startTimestamp = event.data.startTimestamp;\n                DataSynchronizer_replay_worker_endTimestamp = event.data.endTimestamp;\n                version = event.data.version;\n                timerResolution = event.data.timerResolution;\n\n                dataSynchronizerAlgo = new DataSynchronizerAlgo_replay(\n                    event.data.dataSources,\n                    DataSynchronizer_replay_worker_replaySpeed,\n                    DataSynchronizer_replay_worker_startTimestamp,\n                    DataSynchronizer_replay_worker_endTimestamp,\n                    event.data.timerResolution,\n                    version\n                );\n                dataSynchronizerAlgo.onClose = onClose;\n                dataSynchronizerAlgo.onData = onData;\n                init = true;\n                addDataSources(event.data.dataSources);\n                topicData = event.data.topics.data;\n                topicTime = event.data.topics.time;\n                initBroadcastChannel(topicData, topicTime);\n                DataSynchronizer_replay_worker_masterTimeRefreshRate = event.data.masterTimeRefreshRate;\n            } else if (event.data.message === 'add' && event.data.dataSources) {\n                console.log('Add datasource to synchronizer..')\n                addDataSources(event.data.dataSources);\n            } else if (event.data.message === 'connect') {\n                startMasterTimeInterval(DataSynchronizer_replay_worker_masterTimeRefreshRate);\n                dataSynchronizerAlgo.checkStart();\n                version = event.data.version;\n            } else if(event.data.message === 'is-connected') {\n                data = {\n                    message: 'is-connected',\n                    data: isDefined(masterTimeInterval) && isDefined(dataSynchronizerAlgo) && isDefined(dataSynchronizerAlgo.interval)\n                };\n            } else if (event.data.message === 'remove' && event.data.dataSourceIds) {\n                console.log('Remove datasource from synchronizer..')\n                await removeDataSources(event.data.dataSourceIds);\n                if(dataSynchronizerAlgo instanceof DataSynchronizerAlgo_replay) {\n                    dataSynchronizerAlgo.endTimestamp = event.data.endTimestamp;\n                }\n            } else if (event.data.message === 'current-time') {\n                data = {\n                    message: 'current-time',\n                    data: dataSynchronizerAlgo.getCurrentTimestamp()\n                };\n            } else if (event.data.message === 'reset') {\n                DataSynchronizer_replay_worker_reset();\n            } else if (event.data.message === 'replay-speed') {\n                if (dataSynchronizerAlgo !== null) {\n                    DataSynchronizer_replay_worker_reset();\n                    dataSynchronizerAlgo.replaySpeed = event.data.replaySpeed;\n                }\n            }  else if (event.data.message === 'set-max-time') {\n                dataSynchronizerAlgo.setEndTimestamp(event.data.maxTimestamp);\n            } else if (event.data.message === 'time-range') {\n                setTimeRange(\n                    event.data.startTimestamp,\n                    event.data.endTimestamp,\n                    event.data.mode,\n                    event.data.replaySpeed,\n                    event.data.version,\n                    event.data.dataSources\n                )\n            } else if (event.data.message === 'data') {\n                checkMasterTime();\n                if (dataSynchronizerAlgo !== null) {\n                    dataSynchronizerAlgo.push(event.data.dataSourceId, event.data.data);\n                }\n            } else {\n                // skip response\n                sendResponse = false;\n            }\n            if (sendResponse) {\n                self.postMessage({\n                    message: event.data.message,\n                    data: data,\n                    messageId: event.data.messageId\n                });\n            }\n            resolve();\n        } catch (ex) {\n            reject(ex);\n        }\n    });\n}\nfunction setTimeRange(startTimestamp, endTimestamp, mode, replaySpeed, newVersion, dsArray) {\n    DataSynchronizer_replay_worker_reset();\n    version = newVersion;\n\n    dataSynchronizerAlgo = new DataSynchronizerAlgo_replay(\n        dsArray,\n        replaySpeed,\n        startTimestamp,\n        endTimestamp,\n        timerResolution,\n        version\n    );\n    dataSynchronizerAlgo.onEnd = onEnd;\n    dataSynchronizerAlgo.onStart = onStart;\n    dataSynchronizerAlgo.onClose = onClose;\n    dataSynchronizerAlgo.onData = onData;\n}\nfunction DataSynchronizer_replay_worker_reset() {\n    clearInterval(masterTimeInterval);\n    masterTimeInterval = undefined;\n    if(dataSynchronizerAlgo !== null) {\n        dataSynchronizerAlgo.reset();\n    }\n    timeBroadcastChannel.postMessage({\n        type: EventType.TIME_CHANGED\n    });\n    timeBroadcastChannel.postMessage({\n        type: EventType.CLOSED\n    });\n}\nfunction initBroadcastChannel(dataTopic, timeTopic) {\n    console.log('listen on topic ',dataTopic)\n\n    dataSourceBroadCastChannel = new BroadcastChannel(dataTopic);\n    dataSourceBroadCastChannel.onmessage = async (event) => {\n        checkMasterTime();\n        if(event.data.type === EventType.DATA) {\n            // console.log(new Date(event.data.values[0].data.timestamp).toISOString(), event.data.values[0].version);\n            dataSynchronizerAlgo.push(event.data.dataSourceId,event.data.values);\n        } else if(event.data.type === EventType.STATUS) {\n            const dataSourceId = event.data.dataSourceId;\n            dataSynchronizerAlgo.setStatus(dataSourceId, event.data.status);\n            // bubble the message\n            if(dataSourceId in bcChannels) {\n                console.log(dataSources[dataSourceId].name + \": status=\" + event.data.status);\n                bcChannels[dataSourceId].postMessage(event.data);\n            }\n        }\n    }\n\n    timeBroadcastChannel = new BroadcastChannel(timeTopic);\n\n}\n\n/**\n *\n * @param dataSources\n */\nfunction addDataSources(dataSources) {\n    for(let dataSource of dataSources) {\n        addDataSource(dataSource);\n    }\n}\n\nfunction addDataSource(dataSource) {\n    dataSynchronizerAlgo.addDataSource(dataSource);\n    // create a BC to push back the synchronized data into the DATA Stream.\n    bcChannels[dataSource.id] = new BroadcastChannel(DATASOURCE_DATA_TOPIC + dataSource.id);\n\n    if(!(dataSource.id in dataSources)) {\n        dataSources[dataSource.id] = dataSource;\n    }\n}\n\n/**\n *\n * @param dataSourceIds\n */\nasync function removeDataSources(dataSourceIds) {\n    for(let dataSourceId of dataSourceIds) {\n        await removeDataSource(dataSourceId);\n    }\n}\n\nasync function removeDataSource(dataSourceId) {\n    await dataSynchronizerAlgo.removeDataSource(dataSourceId);\n    // create a BC to push back the synchronized data into the DATA Stream.\n    console.log('deleting BC for datasource '+dataSourceId);\n    delete bcChannels[dataSourceId];\n    delete dataSources[dataSourceId];\n}\n\nfunction checkMasterTime() {\n    if(!isDefined(masterTimeInterval)) {\n        startMasterTimeInterval(DataSynchronizer_replay_worker_masterTimeRefreshRate);\n    }\n}\nasync function onEnd() {\n    const masterTime = dataSynchronizerAlgo.getCurrentTimestamp();\n    clearInterval(masterTimeInterval);\n    masterTimeInterval = undefined;\n    // end at this time\n    timeBroadcastChannel.postMessage({\n        timestamp: masterTime,\n        type: EventType.MASTER_TIME\n    });\n}\n\nasync function onStart() {\n    checkMasterTime();\n}\n\nfunction onClose() {\n    timeBroadcastChannel.postMessage({\n        type: EventType.CLOSED\n    });\n}\n\nasync function onData(dataSourceId, dataBlock) {\n    if(dataBlock.version !== version) {\n        console.error('version are different:',dataBlock.version,version);\n        return;\n    }\n    lastData = {\n        dataSourceId: dataSourceId,\n        dataBlock: dataBlock,\n    };\n    bcChannels[dataSourceId].postMessage({\n            values: [dataBlock],\n            dataSourceId:dataSourceId,\n            type: EventType.DATA\n        }\n    );\n}\nself.onclose = function() {\n    dataSynchronizerAlgo.close();\n    console.log(\"Data Synchronizer has been terminated successfully\");\n}\n\nlet DataSynchronizer_replay_worker_masterTime;\nfunction startMasterTimeInterval(masterTimeRefreshRate) {\n    if (!isDefined(masterTimeInterval)) {\n        masterTimeInterval = setInterval(() => {\n            DataSynchronizer_replay_worker_masterTime = dataSynchronizerAlgo.getCurrentTimestamp();\n            if (isDefined(DataSynchronizer_replay_worker_masterTime)) {\n                timeBroadcastChannel.postMessage({\n                    timestamp: DataSynchronizer_replay_worker_masterTime,\n                    type: EventType.MASTER_TIME\n                });\n            }\n\n            if(isDefined(lastData)) {\n                cTime = lastData.dataBlock.data.timestamp;\n                cId = lastData.dataSourceId;\n\n                if ((cTime !== -1 && lastTime === -1) || (lastTime !== -1 && cTime !== lastTime)) { // does not send the same data twice\n                    timeBroadcastChannel.postMessage({\n                        timestamp: cTime,\n                        dataSourceId: cId,\n                        type: EventType.LAST_TIME\n                    });\n                }\n                lastTime = cTime;\n            }\n        }, masterTimeRefreshRate);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS9Db25zdGFudHMuanM/YjliMSIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS9ldmVudC9FdmVudFR5cGUuanM/OWUzMCIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS91dGlscy9VdGlscy5qcz9mODdlIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL2Nvbm5lY3Rvci9TdGF0dXMuanM/YTU4NyIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS90aW1lc3luYy9EYXRhU3luY2hyb25pemVyQWxnby5qcz9hZGNhIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL3RpbWVzeW5jL3JlcGxheS9EYXRhU3luY2hyb25pemVyQWxnby5yZXBsYXkuanM/YTllNSIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS90aW1lc3luYy9yZXBsYXkvRGF0YVN5bmNocm9uaXplci5yZXBsYXkud29ya2VyLmpzPzI2ZmQiXSwibmFtZXMiOlsiREFUQV9TWU5DSFJPTklaRVJfVE9QSUMiLCJUSU1FX1NZTkNIUk9OSVpFUl9UT1BJQyIsIkRBVEFTT1VSQ0VfREFUQV9UT1BJQyIsIkRBVEFTT1VSQ0VfVElNRV9UT1BJQyIsIkZGTVBFR19WSUVXX0RFQ09ERV9UT1BJQyIsIk1BR0lDX0VORF9QQUNLRVQiLCJFdmVudFR5cGUiLCJEQVRBIiwiTEFTVF9USU1FIiwiTUFTVEVSX1RJTUUiLCJTVEFUVVMiLCJUSU1FX0NIQU5HRUQiLCJDTE9TRUQiLCJNQVhfTE9ORyIsIk1hdGgiLCJwb3ciLCJpc0RlZmluZWQiLCJ2IiwiaGFzVmFsdWUiLCJoZXgycmdiIiwiaGV4IiwiciIsImciLCJiIiwibWF0Y2giLCJtYXAiLCJ4IiwicGFyc2VJbnQiLCJoYXNUeXBlIiwiZXhwZWN0ZWRUeXBlIiwiaGFzVmFsIiwiaXNPYmplY3QiLCJsZXROYW1lIiwiaXNBcnJheSIsIkFycmF5IiwiaXNGdW5jdGlvbiIsImFzc2VydERlZmluZWQiLCJhc3NlcnRUcnVlIiwiYXNzZXJ0VHlwZSIsImFzc2VydEJvb2xlYW4iLCJhc3NlcnRTdHJpbmciLCJhc3NlcnROdW1iZXIiLCJhc3NlcnRQb3NpdGl2ZSIsImFzc2VydE9iamVjdCIsImFzc2VydEFycmF5IiwiYXNzZXJ0RnVuY3Rpb24iLCJhc3NlcnRIYXNWYWx1ZSIsInJhbmRvbVVVSUQiLCJyZXBsYWNlIiwiYyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3RhbXBVVUlEIiwib2JqIiwiX29zaF9pZCIsIlBhcnNlQnl0ZXMiLCJidWZmZXIiLCJvZmZzZXQiLCJ0eXBlIiwidmlldyIsIkRhdGFWaWV3IiwidHlwZU1hcCIsImRvdWJsZSIsInZhbCIsImdldEZsb2F0NjQiLCJieXRlcyIsImZsb2F0NjQiLCJmbG9hdDMyIiwiZ2V0RmxvYXQzMiIsInNpZ25lZEJ5dGUiLCJnZXRJbnQ4Iiwic2lnbmVkSW50IiwiZ2V0SW50MzIiLCJzaWduZWRTaG9ydCIsImdldEludDE2IiwidW5zaWduZWRCeXRlIiwiZ2V0VWludDgiLCJ1bnNpZ25lZEludCIsImdldFVpbnQzMiIsInVuc2lnbmVkU2hvcnQiLCJnZXRVaW50MTYiLCJSZWFkRGF0YSIsInN0cnVjdCIsImRhdGEiLCJvZmZzZXRCeXRlcyIsImkiLCJmaWVsZHMiLCJsZW5ndGgiLCJjdXJyRmllbGRTdHJ1Y3QiLCJyZXQiLCJjb3VudCIsImlzTmFOIiwiaWQiLCJmaWVsZE5hbWUiLCJpZDJGaWVsZE1hcCIsImZpbmRGaWVsZEJ5TmFtZSIsImoiLCJmaWVsZCIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInB1c2giLCJHZXRSZXN1bHRPYmplY3QiLCJyZXN1bHRTdHJ1Y3R1cmUiLCJyZXN1bHQiLCJuYW1lIiwiaXRlbSIsImsiLCJpc09wZXJhIiwid2luZG93Iiwib3ByIiwiYWRkb25zIiwib3BlcmEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmRleE9mIiwiaXNGaXJlZm94IiwiSW5zdGFsbFRyaWdnZXIiLCJpc1NhZmFyaSIsIk9iamVjdCIsInByb3RvdHlwZSIsImNhbGwiLCJIVE1MRWxlbWVudCIsImlzQ2hyb21lIiwiY2hyb21lIiwid2Vic3RvcmUiLCJpc0JsaW5rIiwiQ1NTIiwiaXNBcnJheUludGVyc2VjdCIsImEiLCJmaWx0ZXIiLCJlbGVtZW50IiwiaXNFbGVtZW50IiwibyIsIm5vZGVUeXBlIiwibm9kZU5hbWUiLCJpc1dlYldvcmtlciIsIldvcmtlciIsInRha2VTY3JlZW5TaG90IiwiZGl2IiwicmVtb3ZlQ3NzIiwiY3NzIiwiZGl2Q3NzIiwiY2xhc3NOYW1lIiwiYWRkQ3NzIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlTGFzdENoYXJJZkV4aXN0IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJlbmRzV2l0aCIsInN1YnN0cmluZyIsImNhcGl0YWxpemVGaXJzdExldHRlciIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJyb3VuZEhhbGYiLCJudW0iLCJyb3VuZCIsImRlYm91bmNlIiwiZnVuYyIsIndhaXQiLCJpbW1lZGlhdGUiLCJ0aW1lb3V0IiwiYXJncyIsImNvbnRleHQiLCJ0aW1lc3RhbXAiLCJsYXRlciIsIm5vdyIsIkRhdGUiLCJnZXRUaW1lIiwibGFzdCIsInNldFRpbWVvdXQiLCJhcHBseSIsImFyZ3VtZW50cyIsImNhbGxOb3ciLCJ0aHJvdHRsZSIsImxlYWRpbmciLCJ0cmFpbGluZyIsImN0eCIsInByZXZpb3VzIiwicmVtYWluaW5nIiwiY2xlYXJUaW1lb3V0IiwibWVyZ2UiLCJ0YXJnZXQiLCJzb3VyY2UiLCJrZXkiLCJrZXlzIiwiYXNzaWduIiwicmdiYVRvQXJyYXkiLCJzdGFydElkeFZhbHVlIiwiZW5kSWR4VmFsdWUiLCJ2YWx1ZXMiLCJzdWJzdHIiLCJzcGxpdCIsIk51bWJlciIsIlN0YXR1cyIsIkNPTk5FQ1RJTkciLCJDT05ORUNURUQiLCJESVNDT05ORUNURUQiLCJGRVRDSF9TVEFSVEVEIiwiRkVUQ0hfRU5ERUQiLCJDTE9TRURfRVJST1IiLCJEYXRhU3luY2hyb25pemVyQWxnbyIsImNvbnN0cnVjdG9yIiwiZGF0YVNvdXJjZXMiLCJ0aW1lclJlc29sdXRpb24iLCJkYXRhU291cmNlTWFwIiwidHNSdW4iLCJpbnRlcnZhbCIsImRhdGFzb3VyY2VzIiwiZHMiLCJhZGREYXRhU291cmNlIiwicmVtb3ZlRGF0YVNvdXJjZSIsImRhdGFTb3VyY2VJZCIsImVsdCIsImRhdGFCbG9ja3MiLCJnZXRDdXJyZW50VGltZXN0YW1wIiwicHJvY2Vzc0RhdGEiLCJ0c1JlZiIsImNsb2NrVGltZVJlZiIsInBlcmZvcm1hbmNlIiwiY3VycmVudERzIiwiY3VycmVudERzSWQiLCJkYXRhQnVmZmVyIiwic2V0SW50ZXJ2YWwiLCJjb21wdXRlTmV4dERhdGEiLCJjb25zb2xlIiwid2FybiIsInRvSVNPU3RyaW5nIiwicmVmQ2xvY2tUaW1lIiwiRXJyb3IiLCJkYXRhU291cmNlIiwiY2hlY2tWZXJzaW9uIiwiZGF0YXNvdXJjZSIsImRhdGFCbG9jayIsIm9uRGF0YSIsImNoZWNrU3RhcnQiLCJzZXRTdGF0dXMiLCJzdGF0dXMiLCJjbG9zZSIsImNsZWFySW50ZXJ2YWwiLCJsb2ciLCJvbkNsb3NlIiwib25TdGFydCIsIkRhdGFTeW5jaHJvbml6ZXJBbGdvUmVwbGF5IiwicmVwbGF5U3BlZWQiLCJzdGFydFRpbWVzdGFtcCIsImVuZFRpbWVzdGFtcCIsInZlcnNpb24iLCJsYXN0RGF0YSIsImNoZWNrRW5kIiwiY3VycmVudERzVG9TaGlmdCIsImRDbG9jayIsImNvbXB1dGVOZXh0Iiwic2tpcCIsIm1pblRpbWVzdGFtcCIsIm1heFRpbWVzdGFtcCIsImRUcyIsInNoaWZ0IiwiZXgiLCJuYlNraXAiLCJuYkZldGNoIiwidG90YWxEYXRhU291cmNlcyIsImRhdGFTb3VyY2VJRCIsIm9uRW5kIiwicmVzZXQiLCJyZXNldERhdGFTb3VyY2UiLCJkYXRhc291cmNlSWQiLCJjdXJyZW50VGltZXN0YW1wIiwibWluIiwiZHNLZXkiLCJzZXRFbmRUaW1lc3RhbXAiLCJzZXRUaW1lUmFuZ2UiLCJyZXBsYXlTcGVkIl0sIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsdUJBQXVCLEdBQUcsb0JBQWhDO0FBQ0EsTUFBTUMsdUJBQXVCLEdBQUcseUJBQWhDO0FBRUEsTUFBTUMscUJBQXFCLEdBQUcsa0JBQTlCO0FBQ0EsTUFBTUMscUJBQXFCLEdBQUcsa0JBQTlCO0FBRUEsTUFBTUMsd0JBQXdCLEdBQUcsZ0JBQWpDO0FBRUEsTUFBTUMsZ0JBQWdCLEdBQUcsY0FBekIsQzs7QUNSQSxNQUFNQyxTQUFTLEdBQUc7RUFDckJDLElBQUksRUFBRSxNQURlO0VBRXJCQyxTQUFTLEVBQUUsV0FGVTtFQUdyQkMsV0FBVyxFQUFFLGFBSFE7RUFJckJDLE1BQU0sRUFBRSxRQUphO0VBS3JCQyxZQUFZLEVBQUUsY0FMTztFQU1yQkMsTUFBTSxFQUFFO0FBTmEsQ0FBbEIsQzs7QUNBUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDTyxNQUFNQyxRQUFRLEdBQUdDLElBQUksQ0FBQ0MsR0FBTCxDQUFTLENBQVQsRUFBWSxFQUFaLElBQWtCLENBQW5DO0FBRVA7QUFDQTtBQUNBOztBQUNPLFNBQVNDLFNBQVQsQ0FBbUJDLENBQW5CLEVBQXNCO0VBQ3pCLE9B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cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IERBVEFfU1lOQ0hST05JWkVSX1RPUElDID0gJ2RhdGEtc3luY2hyb25pemVyLSc7XG5leHBvcnQgY29uc3QgVElNRV9TWU5DSFJPTklaRVJfVE9QSUMgPSAnZGF0YS1zeW5jaHJvbml6ZXItdGltZS0nO1xuXG5leHBvcnQgY29uc3QgREFUQVNPVVJDRV9EQVRBX1RPUElDID0gJ2RhdGFzb3VyY2UtZGF0YS0nO1xuZXhwb3J0IGNvbnN0IERBVEFTT1VSQ0VfVElNRV9UT1BJQyA9ICdkYXRhc291cmNlLXRpbWUtJztcblxuZXhwb3J0IGNvbnN0IEZGTVBFR19WSUVXX0RFQ09ERV9UT1BJQyA9ICdmZm1wZWctZGVjb2RlLSc7XG5cbmV4cG9ydCBjb25zdCBNQUdJQ19FTkRfUEFDS0VUID0gJ21hZ2ljLXBhY2tldCc7XG4iLCJleHBvcnQgY29uc3QgRXZlbnRUeXBlID0ge1xuICAgIERBVEE6ICdkYXRhJyxcbiAgICBMQVNUX1RJTUU6ICdsYXN0LXRpbWUnLFxuICAgIE1BU1RFUl9USU1FOiAnbWFzdGVyLXRpbWUnLFxuICAgIFNUQVRVUzogJ3N0YXR1cycsXG4gICAgVElNRV9DSEFOR0VEOiAndGltZS1jaGFuZ2VkJyxcbiAgICBDTE9TRUQ6ICdjbG9zZWQnXG59O1xuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiBUaGUgY29udGVudHMgb2YgdGhpcyBmaWxlIGFyZSBzdWJqZWN0IHRvIHRoZSBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlLCB2LiAyLjAuXG4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lXG4gYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXG4gU29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLFxuIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZVxuIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHJpZ2h0cyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiBDb3B5cmlnaHQgKEMpIDIwMTUtMjAyMCBNYXRoaWV1IERoYWluYXV0LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG4gQXV0aG9yOiBNYXRoaWV1IERoYWluYXV0IDxtYXRoaWV1LmRoYWluYXV0QGdtYWlsLmNvbT5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiogKiBAbW9kdWxlIFV0aWxzICovXG5cbi8qKiBNYXhpbXVtIHZhbHVlIG9mIGEgbG9uZyAqL1xuZXhwb3J0IGNvbnN0IE1BWF9MT05HID0gTWF0aC5wb3coMiwgNTMpICsgMTtcblxuLyoqXG4gKiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmluZWQodikge1xuICAgIHJldHVybiB0eXBlb2YgKHYpICE9PSAndW5kZWZpbmVkJyAmJiB2ICE9PSBudWxsO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBoYXMgYSB2YWx1ZSxcbiB0aGF0IGlzIGl0IGlzIGRlZmluZWQgYW5kIG5vbiBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNWYWx1ZSh2KSB7XG4gICAgcmV0dXJuIGlzRGVmaW5lZCh2KSAmJiB2ICE9PSBudWxsO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0cmFuc2Zvcm0gaGV4IGNvbG9yIGludG8gUkdCQVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4MnJnYihoZXgpe1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IGhleC5tYXRjaCgvXFx3XFx3L2cpLm1hcCh4ID0+IHBhcnNlSW50KHgsIDE2KSk7XG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbn1cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIG9mIGEgcGFydGljdWxhciB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNUeXBlKHYsIGV4cGVjdGVkVHlwZSkge1xuICAgIGxldCBoYXNWYWwgPSBoYXNWYWx1ZSh2KTtcbiAgICByZXR1cm4gaGFzVmFsICYmIHR5cGVvZiAodikgPT09IGV4cGVjdGVkVHlwZTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGhhc1R5cGUodiwgJ29iamVjdCcsIGxldE5hbWUpO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBhcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheSh2KSB7XG4gICAgcmV0dXJuIGlzRGVmaW5lZCh2KSAmJiBBcnJheS5pc0FycmF5KHYpO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gaGFzVHlwZSh2LCAnZnVuY3Rpb24nLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGRlZmluZWRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgaWYgKCFpc0RlZmluZWQodikpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgZGVmaW5lZFwiO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFRydWUodiwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh2KSB8fCAhdikge1xuICAgICAgICB0aHJvdyBsZXROYW1lO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkIGFuZCBub24tbnVsbFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFR5cGUodiwgZXhwZWN0ZWRUeXBlLCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKHR5cGVvZiAodikgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBiZSBvZiB0eXBlIFwiICsgZXhwZWN0ZWRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgc3RyaW5nXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Qm9vbGVhbih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ2Jvb2xlYW4nLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgc3RyaW5nXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U3RyaW5nKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnc3RyaW5nJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIG51bWJlclxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE51bWJlcih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ251bWJlcicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBudW1iZXJcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRQb3NpdGl2ZSh2LCBsZXROYW1lKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHYsIGxldE5hbWUpO1xuICAgIGlmICh2IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIjtcbiAgICB9XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBvYmplY3RcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRPYmplY3QodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdvYmplY3QnLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIG9iamVjdFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFycmF5KHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgYW4gYXJyYXlcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIGZ1bmN0aW9uXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb24odiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdmdW5jdGlvbicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBhbmQgbm9uLW51bGxcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRIYXNWYWx1ZSh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKCFoYXNWYWx1ZSh2KSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBub3QgYmUgbnVsbFwiO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tVVVJRCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgteHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICBsZXQgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBzdGFtcHMvZW1iZWRzIGEgVVVJRCBpbnRvIGFuIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgVVVJRCBnZW5lcmF0ZWQgZm9yIGl0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFtcFVVSUQob2JqKSB7XG4gICAgb2JqLl9vc2hfaWQgPSBvYmouX29zaF9pZCB8fCByYW5kb21VVUlEKCk7XG4gICAgcmV0dXJuIG9iai5fb3NoX2lkO1xufVxuXG4vL2J1ZmZlciBpcyBhbiBBcnJheUJ1ZmZlciBvYmplY3QsIHRoZSBvZmZzZXQgaWYgc3BlY2lmaWVkIGluIGJ5dGVzLCBhbmQgdGhlIHR5cGUgaXMgYSBzdHJpbmdcbi8vY29ycmVzcG9uZGluZyB0byBhbiBPR0MgZGF0YSB0eXBlLlxuLy9TZWUgaHR0cDovL2RlZi5zZWVncmlkLmNzaXJvLmF1L3Npc3N2b2Mvb2djLWRlZi9yZXNvdXJjZT91cmk9aHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9kZWYvZGF0YVR5cGUvT0dDLzAvXG4vKipcbiAqXG4gKiBAcGFyYW0gYnVmZmVyXG4gKiBAcGFyYW0gb2Zmc2V0XG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFBhcnNlQnl0ZXMoYnVmZmVyLCBvZmZzZXQsIHR5cGUpIHtcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuXG4gICAgLy9Ob3RlOiBUaGVyZSBleGlzdCB0eXBlcyBub3QgbGlzdGVkIGluIHRoZSBtYXAgYmVsb3cgdGhhdCBoYXZlIE9HQyBkZWZpbml0aW9ucywgYnV0IG5vIGFwcHJvcHJpYXRlXG4gICAgLy9tZXRob2RzIG9yIGNvcnJlc3BvbmRpbmcgdHlwZXMgYXZhaWxhYmxlIGZvciBwYXJzaW5nIGluIGphdmFzY3JpcHQuIFRoZXkgYXJlIGZsb2F0MTI4LCBmbG9hdDE2LCBzaWduZWRMb25nLFxuICAgIC8vYW5kIHVuc2lnbmVkTG9uZ1xuICAgIGxldCB0eXBlTWFwID0ge1xuICAgICAgICBkb3VibGU6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEZsb2F0NjQob2Zmc2V0KSwgYnl0ZXM6IDh9O1xuICAgICAgICB9LFxuICAgICAgICBmbG9hdDY0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRGbG9hdDY0KG9mZnNldCksIGJ5dGVzOiA4fTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXQzMjogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0RmxvYXQzMihvZmZzZXQpLCBieXRlczogNH07XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25lZEJ5dGU6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDgob2Zmc2V0KSwgYnl0ZXM6IDF9O1xuICAgICAgICB9LFxuICAgICAgICBzaWduZWRJbnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDMyKG9mZnNldCksIGJ5dGVzOiA0fTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmVkU2hvcnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDE2KG9mZnNldCksIGJ5dGVzOiAyfTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaWduZWRCeXRlOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50OChvZmZzZXQpLCBieXRlczogMX07XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2lnbmVkSW50OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50MzIob2Zmc2V0KSwgYnl0ZXM6IDR9O1xuICAgICAgICB9LFxuICAgICAgICB1bnNpZ25lZFNob3J0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50MTYob2Zmc2V0KSwgYnl0ZXM6IDJ9O1xuICAgICAgICB9LFxuICAgICAgICAvL1RPRE86IHN0cmluZy11dGYtODpcbiAgICB9O1xuICAgIHJldHVybiB0eXBlTWFwW3R5cGVdKG9mZnNldCk7XG59XG5cbi8vVGhpcyBmdW5jdGlvbiByZWN1cnNpdmxleSBpdGVyYXRlcyBvdmVyIHRoZSByZXN1bHRTdHJ1Y3R1cmUgdG8gZmlsbCBpblxuLy92YWx1ZXMgcmVhZCBmcm9tIGRhdGEgd2hpY2ggc2hvdWxkIGJlIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgdGhlIHBheWxvYWQgZnJvbSBhIHdlYnNvY2tldFxuLyoqXG4gKlxuICogQHBhcmFtIHN0cnVjdFxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBvZmZzZXRCeXRlc1xuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlYWREYXRhKHN0cnVjdCwgZGF0YSwgb2Zmc2V0Qnl0ZXMpIHtcbiAgICBsZXQgb2Zmc2V0ID0gb2Zmc2V0Qnl0ZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJ1Y3QuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjdXJyRmllbGRTdHJ1Y3QgPSBzdHJ1Y3QuZmllbGRzW2ldO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKGN1cnJGaWVsZFN0cnVjdC50eXBlKSAmJiBjdXJyRmllbGRTdHJ1Y3QudHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJldCA9IFBhcnNlQnl0ZXMoZGF0YSwgb2Zmc2V0LCBjdXJyRmllbGRTdHJ1Y3QudHlwZSk7XG4gICAgICAgICAgICBjdXJyRmllbGRTdHJ1Y3QudmFsID0gcmV0LnZhbDtcbiAgICAgICAgICAgIG9mZnNldCArPSByZXQuYnl0ZXM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWZpbmVkKGN1cnJGaWVsZFN0cnVjdC5jb3VudCkgJiYgY3VyckZpZWxkU3RydWN0LmNvdW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvL2NoZWNrIGlmIGNvdW50IGlzIGEgcmVmZXJlbmNlIHRvIGFub3RoZXIgbGV0aWFibGVcbiAgICAgICAgICAgIGlmIChpc05hTihjdXJyRmllbGRTdHJ1Y3QuY291bnQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gY3VyckZpZWxkU3RydWN0LmNvdW50O1xuICAgICAgICAgICAgICAgIGxldCBmaWVsZE5hbWUgPSBzdHJ1Y3QuaWQyRmllbGRNYXBbaWRdO1xuICAgICAgICAgICAgICAgIGN1cnJGaWVsZFN0cnVjdC5jb3VudCA9IHN0cnVjdC5maW5kRmllbGRCeU5hbWUoZmllbGROYW1lKS52YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGN1cnJGaWVsZFN0cnVjdC5jb3VudDsgYysrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjdXJyRmllbGRTdHJ1Y3QuZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY3VyckZpZWxkU3RydWN0LmZpZWxkc1tqXSkpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBSZWFkRGF0YShmaWVsZCwgZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY3VyckZpZWxkU3RydWN0LnZhbC5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHJlc3VsdFN0cnVjdHVyZVxuICogQHJldHVybiB7e319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBHZXRSZXN1bHRPYmplY3QocmVzdWx0U3RydWN0dXJlKSB7XG4gICAgLy9UT0RPOiBoYW5kbGUgY2FzZXMgZm9yIG5lc3RlZCBhcnJheXMgLyBtYXRyaXggZGF0YSB0eXBlc1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLmNvdW50KSkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0ubmFtZV0gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5jb3VudDsgYysrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtW3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkc1trXS5uYW1lXSA9IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkc1trXS52YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLm5hbWVdLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5uYW1lXSA9IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09wZXJhKCkge1xuICAgIHJldHVybiAoISF3aW5kb3cub3ByICYmICEhb3ByLmFkZG9ucykgfHwgISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDA7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpcmVmb3goKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdy5IVE1MRWxlbWVudCkuaW5kZXhPZignQ29uc3RydWN0b3InKSA+IDA7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Nocm9tZSgpIHtcbiAgICByZXR1cm4gISF3aW5kb3cuY2hyb21lICYmICEhd2luZG93LmNocm9tZS53ZWJzdG9yZTtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Knxib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCbGluaygpIHtcbiAgICByZXR1cm4gKGlzQ2hyb21lIHx8IGlzT3BlcmEpICYmICEhd2luZG93LkNTUztcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGFcbiAqIEBwYXJhbSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUludGVyc2VjdChhLCBiKSB7XG4gICAgcmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBiLmluZGV4T2YoZWxlbWVudCkgPiAtMTtcbiAgICB9KS5sZW5ndGggPiAwO1xufVxuXG5cbi8qKlxuICpcbiAqIEBwYXJhbSBvXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50KG8pIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIEhUTUxFbGVtZW50ID09PSBcIm9iamVjdFwiID8gbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogLy9ET00yXG4gICAgICAgIG8gJiYgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgbyAhPT0gbnVsbCAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSBcInN0cmluZ1wiXG4gICAgKTtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzV2ViV29ya2VyKCkge1xuICAgIHJldHVybiBpc0RlZmluZWQoV29ya2VyKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGRpdlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFrZVNjcmVlblNob3QoZGl2KSB7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY3NzIGNsYXNzIGZyb20gYSB0aGUgZGl2IGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIGRpdiB0aGUgZGl2IHRvIHJlbW92ZSB0aGUgY2xhc3MgZnJvbVxuICogQHBhcmFtIGNzcyB0aGUgY3NzIGNsYXNzIHRvIHJlbW92ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ3NzKGRpdiwgY3NzKSB7XG4gICAgbGV0IGRpdkNzcyA9IGRpdi5jbGFzc05hbWU7XG4gICAgY3NzID0gZGl2Q3NzLnJlcGxhY2UoY3NzLCBcIlwiKTtcbiAgICBkaXYuY2xhc3NOYW1lID0gY3NzO1xufVxuXG5cbi8qKlxuICogQWRkIGEgY3NzIGNsYXNzIHRvIGEgdGhlIGRpdiBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSBkaXYgdGhlIGRpdiB0byBhZGQgdGhlIGNsYXNzIHRvXG4gKiBAcGFyYW0gY3NzIHRoZSBjc3MgY2xhc3MgdG8gYWRkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDc3MoZGl2LCBjc3MpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGl2LmNsYXNzTmFtZSArIFwiIFwiICsgY3NzKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBsYXN0IGNoYXJhY3RlciBvZiBhIHtzdHJpbmd9IG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBpbnB1dCB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUgd2l0aG91dCB0aGUgbGFzdCBjaGFyYWN0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUxhc3RDaGFySWZFeGlzdCh2YWx1ZSkge1xuICAgIGlmICghaXNEZWZpbmVkKHVuZGVmaW5lZCkgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwIHx8ICF2YWx1ZS5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG59XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSB0aGUgZmlyc3QgbGV0dGVyIG9mIGEgZ2l2ZW4gc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gdGhlIGlucHV0IHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gdGhlIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gIGNhcGl0YWxpemVGaXJzdExldHRlcihzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59XG5cbi8qKlxuICogUm91bmQgb2ZmIG51bWJlciB0byBuZWFyZXN0IDAuNVxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSAtIFRoZSBudW1iZXIgdG8gcm91bmQgb2ZmXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByb3VuZGVkIG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmRIYWxmKG51bSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSoyKS8yO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLFxuICogd2lsbCBub3QgYmUgZXhlY3V0ZWQuIFRoZSBmdW5jdGlvbiB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgd2hlblxuICogaXQgd2lsbCBzdG9wIGJlaW5nIGNhbGxlZCBmb3IgbW9yZSB0aGFuIE4gbWlsbGlzZWNvbmRzLlxuICogSWYgdGhlIGBpbW1lZGlhdGVgIHBhcmFtZXRlciBpcyB0cnVlLCB0aGVuIHRoZSBmdW5jdGlvblxuICogd2lsbCBiZSBleGVjdXRlZCBhdCB0aGUgZmlyc3QgY2FsbCBpbnN0ZWFkIG9mIHRoZSBsYXN0LlxuICogUGFyYW1ldGVycyA6XG4gKiAtIGZ1bmM6IHRoZSBmdW5jdGlvbiB0byBgZGVib3VuY2VyYC5cbiAqIC0gd2FpdDogdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgKE4pIHRvIHdhaXQgYmVmb3JlXG4gKiBjYWxsIGZ1bmMoKVxuICogLSBpbW1lZGlhdGUgKG9wdGlvbmFsKTogQ2FsbCBmdW5jKCkgYXQgdGhlIGZpcnN0IGludm9jYXRpb25cbiAqIGluc3RlYWQgb2YgdGhlIGxhc3Qgb25lIChEZWZhdWx0IGZhbHNlKVxuICogLSBjb250ZXh0IChvcHRpb25hbCk6IHRoZSBjb250ZXh0IGluIHdoaWNoIHRvIGNhbGwgZnVuYygpXG4gKiAodGhpcyBieSBkZWZhdWx0KVxuICovXG5cbi8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3Rcbi8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3Jcbi8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbGFzdCA9IG5vdyAtIHRpbWVzdGFtcDtcblxuICAgICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgbGVhZGluZywgdHJhaWxpbmcsIGNvbnRleHQpIHtcbiAgICB2YXIgY3R4LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByZXZpb3VzID0gbmV3IERhdGU7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZTtcbiAgICAgICAgaWYgKCFwcmV2aW91cyAmJiAhbGVhZGluZykgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgICAgY3R4ID0gY29udGV4dCB8fCB0aGlzO1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgdHJhaWxpbmcpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZSAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggYHNvdXJjZWAgcHJvcGVydGllcyBhbmQgaWYgYW4gYE9iamVjdGAgc2V0IHByb3BlcnR5IHRvIG1lcmdlIG9mIGB0YXJnZXRgIGFuZCBgc291cmNlYCBwcm9wZXJ0aWVzXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc291cmNlKSkge1xuICAgICAgICBpZiAoc291cmNlW2tleV0gaW5zdGFuY2VvZiBPYmplY3QgJiYga2V5IGluIHRhcmdldCkgT2JqZWN0LmFzc2lnbihzb3VyY2Vba2V5XSwgbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKSlcbiAgICB9XG5cbiAgICAvLyBKb2luIGB0YXJnZXRgIGFuZCBtb2RpZmllZCBgc291cmNlYFxuICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0IHx8IHt9LCBzb3VyY2UpXG4gICAgcmV0dXJuIHRhcmdldFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJnYmFUb0FycmF5KHN0cikge1xuICAgIGxldCBzdGFydElkeFZhbHVlID0gc3RyLmluZGV4T2YoJygnKSArIDE7XG4gICAgbGV0IGVuZElkeFZhbHVlID0gc3RyLmluZGV4T2YoJyknKTtcbiAgICBsZXQgdmFsdWVzID0gc3RyLnN1YnN0cihzdGFydElkeFZhbHVlLCBlbmRJZHhWYWx1ZS1zdGFydElkeFZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWVzLnNwbGl0KCcsJykubWFwKE51bWJlcik7XG59XG4iLCIvKipcbiAqIEVudW0gZm9yIGNvbm5lY3Rpb24gc3RhdHVzLlxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7e25hbWU6IHN0cmluZ319XG4gKi9cbmV4cG9ydCBjb25zdCBTdGF0dXMgPSB7XG4gICAgQ09OTkVDVElORzogXCJjb25uZWN0aW5nXCIsXG4gICAgQ09OTkVDVEVEOiAgXCJjb25uZWN0ZWRcIixcbiAgICBESVNDT05ORUNURUQ6IFwiZGlzY29ubmVjdGVkXCIsXG4gICAgRkVUQ0hfU1RBUlRFRDogJ2ZldGNoLXN0YXJ0JyxcbiAgICBGRVRDSF9FTkRFRDogJ2ZldGNoLWVuZCcsXG4gICAgQ0xPU0VEOiBcImNsb3NlZFwiLFxuICAgIENMT1NFRF9FUlJPUjogXCJjbG9zZWQtZXJyb3JcIlxufTtcbiIsImltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vdXRpbHMvVXRpbHMuanNcIjtcbmltcG9ydCB7U3RhdHVzfSBmcm9tIFwiLi4vY29ubmVjdG9yL1N0YXR1cy5qc1wiO1xuXG5jbGFzcyBEYXRhU3luY2hyb25pemVyQWxnbyB7XG4gICAgY29uc3RydWN0b3IoZGF0YVNvdXJjZXMsIHRpbWVyUmVzb2x1dGlvbiA9IDUpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlTWFwID0ge307XG4gICAgICAgIHRoaXMudHNSdW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudGltZXJSZXNvbHV0aW9uID0gdGltZXJSZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmludGVydmFsID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhc291cmNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBkcyBvZiBkYXRhU291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhU291cmNlKGRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZURhdGFTb3VyY2UoZGF0YVNvdXJjZUlkKSB7XG4gICAgICAgIHRoaXMuZGF0YXNvdXJjZXMgPSB0aGlzLmRhdGFzb3VyY2VzLmZpbHRlciggZWx0ID0+IGVsdC5pZCAhPT0gZGF0YVNvdXJjZUlkKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlSWRdO1xuICAgIH1cblxuICAgIHB1c2goZGF0YVNvdXJjZUlkLCBkYXRhQmxvY2tzKSB7XG4gICAgfVxuXG4gICAgZ2V0Q3VycmVudFRpbWVzdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHNSdW47XG4gICAgfVxuXG4gICAgcHJvY2Vzc0RhdGEoKSB7XG4gICAgICAgIGxldCB0c1JlZiA9IC0xO1xuICAgICAgICBsZXQgY2xvY2tUaW1lUmVmID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgICAgLy8gZ2V0IHJlZmVyZW5jZSBzdGFydCB0aW1lc3RhbXBcbiAgICAgICAgLy8gdGhlIHJlZmVyZW5jZSBzdGFydCB0aW1lc3RhbXAgc2hvdWxkIHRoZSBvbGRlc3Qgb25lXG4gICAgICAgIGxldCBjdXJyZW50RHM7XG4gICAgICAgIGZvciAobGV0IGN1cnJlbnREc0lkIGluIHRoaXMuZGF0YVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgY3VycmVudERzID0gdGhpcy5kYXRhU291cmNlTWFwW2N1cnJlbnREc0lkXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RHMuZGF0YUJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdHNSZWYgPSAodHNSZWYgPT09IC0xIHx8IGN1cnJlbnREcy5kYXRhQnVmZmVyWzBdLmRhdGEudGltZXN0YW1wIDwgdHNSZWYpID8gY3VycmVudERzLmRhdGFCdWZmZXJbMF0uZGF0YS50aW1lc3RhbXAgOlxuICAgICAgICAgICAgICAgICAgICB0c1JlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAvLyAxKSByZXR1cm4gdGhlIG9sZGVzdCBkYXRhIGlmIGFueVxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuY29tcHV0ZU5leHREYXRhKHRzUmVmLCBjbG9ja1RpbWVSZWYpKSA7XG5cbiAgICAgICAgfSwgdGhpcy50aW1lclJlc29sdXRpb24pO1xuICAgICAgICBjb25zb2xlLndhcm4oYFN0YXJ0ZWQgQWxnb3JpdGhtICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSB3aXRoICB0c1JlZj0ke25ldyBEYXRlKHRzUmVmKS50b0lTT1N0cmluZygpfWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIG5leHQgZGF0YSBpZiBhbnkuIFdlIHJldHVybiBvbmx5IDEgdmFsdWUgZm9yIHRoaXMgaXRlcmF0aW9uLiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgdmFsdWVzIHRvIHJldHVybixcbiAgICAgKiB3ZSByZXR1cm4gb25seSB0aGUgb2xkZXN0IG9uZS5cbiAgICAgKiBAcGFyYW0gdHNSZWYgLSB0aGUgdGltZXN0YW1wIG9mIHRoZSBmaXJzdCBkYXRhXG4gICAgICogQHBhcmFtIHJlZkNsb2NrVGltZSAtIHRoZSBhYnNvbHV0ZSBkaWZmIHRpbWUgcmVhbGx5IHNwZW50XG4gICAgICovXG4gICAgY29tcHV0ZU5leHREYXRhKHRzUmVmLCByZWZDbG9ja1RpbWUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Nob3VsZCBiZSBvdmVycmlkZGVuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGFTb3VyY2UgdG8gYmUgc3luY2hyb25pemVkXG4gICAgICogQHBhcmFtIHtEYXRhc291cmNlfSBkYXRhU291cmNlIC0gdGhlIGRhdGFTb3VyY2UgdG8gc3luY2hyb25pemVcbiAgICAgKi9cbiAgICBhZGREYXRhU291cmNlKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Nob3VsZCBiZSBvdmVycmlkZGVuJyk7XG4gICAgfVxuXG4gICAgY2hlY2tWZXJzaW9uKGRhdGFzb3VyY2UsIGRhdGFCbG9jaykge1xuICAgICAgICB0aHJvdyBFcnJvcignU2hvdWxkIGJlIG92ZXJyaWRkZW4nKTtcbiAgICB9XG5cbiAgICBvbkRhdGEoZGF0YVNvdXJjZUlkLCBkYXRhQmxvY2spIHtcbiAgICB9XG5cbiAgICBjaGVja1N0YXJ0KCkge31cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgZGF0YVNvdXJjZSBzdGF0dXNcbiAgICAgKiBAcGFyYW0ge1N0YXR1c30gc3RhdHVzIC0gdGhlIG5ldyBzdGF0dXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVNvdXJjZUlkIC0gdGhlIGNvcnJlc3BvbmRpbmcgZGF0YVNvdXJjZSBpZFxuICAgICAqL1xuICAgIHNldFN0YXR1cyhkYXRhU291cmNlSWQsIHN0YXR1cykge1xuICAgICAgICB0aHJvdyBFcnJvcignU2hvdWxkIGJlIG92ZXJyaWRkZW4nKTtcbiAgICB9XG5cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh0aGlzLmludGVydmFsKSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCJEYXRhIHN5bmNocm9uaXplciB0ZXJtaW5hdGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgfVxuXG4gICAgb25TdGFydCgpICB7fVxuICAgIG9uQ2xvc2UoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhU3luY2hyb25pemVyQWxnbztcbiIsImltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vLi4vdXRpbHMvVXRpbHMuanNcIjtcbmltcG9ydCB7U3RhdHVzfSBmcm9tIFwiLi4vLi4vY29ubmVjdG9yL1N0YXR1cy5qc1wiO1xuaW1wb3J0IERhdGFTeW5jaHJvbml6ZXJBbGdvIGZyb20gXCIuLi9EYXRhU3luY2hyb25pemVyQWxnb1wiO1xuXG5jbGFzcyBEYXRhU3luY2hyb25pemVyQWxnb1JlcGxheSBleHRlbmRzIERhdGFTeW5jaHJvbml6ZXJBbGdvIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhU291cmNlcywgcmVwbGF5U3BlZWQgPSAxLCBzdGFydFRpbWVzdGFtcCwgZW5kVGltZXN0YW1wLCB0aW1lclJlc29sdXRpb24gPSA1LCB2ZXJzaW9uKSB7XG4gICAgICAgIHN1cGVyKGRhdGFTb3VyY2VzLHJlcGxheVNwZWVkLHRpbWVyUmVzb2x1dGlvbik7XG4gICAgICAgIHRoaXMucmVwbGF5U3BlZWQgPSByZXBsYXlTcGVlZDtcbiAgICAgICAgdGhpcy5zdGFydFRpbWVzdGFtcCA9IHN0YXJ0VGltZXN0YW1wO1xuICAgICAgICB0aGlzLmVuZFRpbWVzdGFtcCA9IGVuZFRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB9XG5cbiAgICBwdXNoKGRhdGFTb3VyY2VJZCwgZGF0YUJsb2Nrcykge1xuICAgICAgICBpZihkYXRhQmxvY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmKGRhdGFTb3VyY2VJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGNvbnN0IGRzID0gdGhpcy5kYXRhU291cmNlTWFwW2RhdGFTb3VyY2VJZF07XG4gICAgICAgICAgICBjb25zdCBsYXN0RGF0YSA9IGRhdGFCbG9ja3NbZGF0YUJsb2Nrcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1ZlcnNpb24obGFzdERhdGEpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbRGF0YVN5bmNocm9uaXplcl0gaW5jb21wYXRpYmxlIHZlcnNpb24gJHtsYXN0RGF0YS52ZXJzaW9ufSB+ICR7dGhpcy52ZXJzaW9ufSwgc2tpcHBpbmcgZGF0YWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRzLmRhdGFCdWZmZXIucHVzaCguLi5kYXRhQmxvY2tzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb2Nlc3NEYXRhKCkge1xuICAgICAgICB0aGlzLmNsb2NrVGltZVJlZiA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAvLyAxKSByZXR1cm4gdGhlIG9sZGVzdCBkYXRhIGlmIGFueVxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuY29tcHV0ZU5leHREYXRhKHRoaXMuc3RhcnRUaW1lc3RhbXAsIHRoaXMuY2xvY2tUaW1lUmVmICkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoZWNrRW5kKCk7XG4gICAgICAgIH0sIHRoaXMudGltZXJSZXNvbHV0aW9uKTtcbiAgICAgICAgY29uc29sZS53YXJuKGBTdGFydGVkIFJlcGxheSBBbGdvcml0aG0gd2l0aCB0c1JlZj0ke25ldyBEYXRlKHRoaXMuc3RhcnRUaW1lc3RhbXApLnRvSVNPU3RyaW5nKCl9YCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgbmV4dCBkYXRhIGlmIGFueS4gV2UgcmV0dXJuIG9ubHkgMSB2YWx1ZSBmb3IgdGhpcyBpdGVyYXRpb24uIElmIHRoZXJlIGFyZSBtdWx0aXBsZSB2YWx1ZXMgdG8gcmV0dXJuLFxuICAgICAqIHdlIHJldHVybiBvbmx5IHRoZSBvbGRlc3Qgb25lLlxuICAgICAqIEBwYXJhbSB0c1JlZiAtIHRoZSB0aW1lc3RhbXAgb2YgdGhlIGZpcnN0IGRhdGFcbiAgICAgKiBAcGFyYW0gcmVmQ2xvY2tUaW1lIC0gdGhlIGFic29sdXRlIGRpZmYgdGltZSByZWFsbHkgc3BlbnRcbiAgICAgKi9cbiAgICBjb21wdXRlTmV4dERhdGEodHNSZWYsIHJlZkNsb2NrVGltZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnREcztcbiAgICAgICAgICAgIGxldCBjdXJyZW50RHNUb1NoaWZ0ID0gbnVsbDtcblxuICAgICAgICAgICAgY29uc3QgZENsb2NrID0gKHBlcmZvcm1hbmNlLm5vdygpIC0gcmVmQ2xvY2tUaW1lKSAqIHRoaXMucmVwbGF5U3BlZWQ7XG4gICAgICAgICAgICBsZXQgdHNSdW4gPSB0c1JlZiArIGRDbG9jaztcblxuICAgICAgICAgICAgbGV0IGNvbXB1dGVOZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBjb21wdXRlIG5leHQgZGF0YSB0byByZXR1cm5cbiAgICAgICAgICAgIGZvciAobGV0IGN1cnJlbnREc0lkIGluIHRoaXMuZGF0YVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtjdXJyZW50RHNJZF07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5za2lwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGRhdGFzb3VyY2UgaXMgaW4gY3VycmVudCByYW5nZVxuICAgICAgICAgICAgICAgICAgICBpZiAodHNSdW4gPiBjdXJyZW50RHMubWluVGltZXN0YW1wICYmIHRzUnVuIDwgY3VycmVudERzLm1heFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERzLnNraXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBza2lwIERhdFNvdXJjZSBpZiBvdXQgb2YgdGltZSByYW5nZVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RHMuc2tpcCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5kYXRhQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZFRzID0gKGN1cnJlbnREcy5kYXRhQnVmZmVyWzBdLmRhdGEudGltZXN0YW1wIC0gdHNSZWYpO1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSB1c2UgYW4gaW50ZXJtZWRpYXRlIG9iamVjdCB0byBzdG9yZSB0aGUgZGF0YSB0byBzaGlmdCBiZWNhdXNlIHdlIHdhbnQgdG8gcmV0dXJuIHRoZSBvbGRlc3Qgb25lXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRUcyA8PSBkQ2xvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIG90aGVyIG9uZSB0byBjb21wYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudERzVG9TaGlmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREc1RvU2hpZnQgPSBjdXJyZW50RHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRha2UgdGhlIG9sZGVzdCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERzVG9TaGlmdCA9IChjdXJyZW50RHNUb1NoaWZ0LmRhdGFCdWZmZXJbMF0uZGF0YS50aW1lc3RhbXAgPCBjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS5kYXRhLnRpbWVzdGFtcCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHNUb1NoaWZ0IDogY3VycmVudERzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaW5hbGx5IHBvcCB0aGUgZGF0YSBmcm9tIERTIHF1ZXVlXG4gICAgICAgICAgICBpZiAoY3VycmVudERzVG9TaGlmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RHNUb1NoaWZ0LmlkIGluIHRoaXMuZGF0YVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YShjdXJyZW50RHNUb1NoaWZ0LmlkLCBjdXJyZW50RHNUb1NoaWZ0LmRhdGFCdWZmZXIuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXB1dGVOZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHNSdW4gPSB0c1J1bjtcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlTmV4dDtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhU291cmNlIHRvIGJlIHN5bmNocm9uaXplZFxuICAgICAqIEBwYXJhbSB7RGF0YXNvdXJjZX0gZGF0YVNvdXJjZSAtIHRoZSBkYXRhU291cmNlIHRvIHN5bmNocm9uaXplXG4gICAgICovXG4gICAgYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlLmlkXSA9IHtcbiAgICAgICAgICAgIGRhdGFCdWZmZXI6IFtdLFxuICAgICAgICAgICAgaWQ6IGRhdGFTb3VyY2UuaWQsXG4gICAgICAgICAgICBuYW1lOiBkYXRhU291cmNlLm5hbWUgfHwgZGF0YVNvdXJjZS5pZCxcbiAgICAgICAgICAgIHN0YXR1czogU3RhdHVzLkRJU0NPTk5FQ1RFRCwgLy9NRUFOSU5HIEVuYWJsZWQsIDAgPSBEaXNhYmxlZFxuICAgICAgICAgICAgbWluVGltZXN0YW1wOiBkYXRhU291cmNlLm1pblRpbWVzdGFtcCxcbiAgICAgICAgICAgIG1heFRpbWVzdGFtcDogZGF0YVNvdXJjZS5tYXhUaW1lc3RhbXAsXG4gICAgICAgICAgICBza2lwOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBpZihkYXRhU291cmNlLm1heFRpbWVzdGFtcCA8IHRoaXMuZ2V0Q3VycmVudFRpbWVzdGFtcCgpIHx8IGRhdGFTb3VyY2UubWluVGltZXN0YW1wID4gdGhpcy5nZXRDdXJyZW50VGltZXN0YW1wKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlLmlkXS5za2lwID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2tpcHBpbmcgbmV3IGFkZGVkIGRhdGFTb3VyY2UgJHtkYXRhU291cmNlLmlkfSBiZWNhdXNlIHRpbWVSYW5nZSBvZiB0aGUgZGF0YVNvdXJjZSBpcyBub3QgaW50ZXJzZWN0aW5nIHRoZSBzeW5jaHJvbml6ZXIgb25lYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhc291cmNlcy5wdXNoKGRhdGFTb3VyY2UpO1xuICAgIH1cblxuICAgIGNoZWNrVmVyc2lvbihkYXRhQmxvY2spIHtcbiAgICAgICAgcmV0dXJuIChkYXRhQmxvY2sudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGRhdGFTb3VyY2Ugc3RhdHVzXG4gICAgICogQHBhcmFtIHtTdGF0dXN9IHN0YXR1cyAtIHRoZSBuZXcgc3RhdHVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFTb3VyY2VJZCAtIHRoZSBjb3JyZXNwb25kaW5nIGRhdGFTb3VyY2UgaWRcbiAgICAgKi9cbiAgICBzZXRTdGF0dXMoZGF0YVNvdXJjZUlkLCBzdGF0dXMpIHtcbiAgICAgICAgaWYgKGRhdGFTb3VyY2VJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlSWRdLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihzdGF0dXMrJyBEYXRhU291cmNlICcgKyBkYXRhU291cmNlSWQgKyAnIGZyb20gdGhlIHN5bmNocm9uaXplciAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrU3RhcnQoKTtcbiAgICB9XG5cbiAgICBjaGVja1N0YXJ0KCkge1xuICAgICAgICBpZighaXNEZWZpbmVkKHRoaXMuaW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICBsZXQgbmJTa2lwID0gMDtcbiAgICAgICAgICAgIGxldCBuYkZldGNoID0gMFxuICAgICAgICAgICAgbGV0IHRvdGFsRGF0YVNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRhdGFTb3VyY2VNYXApLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYodG90YWxEYXRhU291cmNlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXRhU291cmNlO1xuICAgICAgICAgICAgZm9yKGxldCBkYXRhU291cmNlSUQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICAgICAgZGF0YVNvdXJjZSA9IHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlSURdO1xuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2Uuc2tpcCA9ICh0aGlzLnN0YXJ0VGltZXN0YW1wIDwgZGF0YVNvdXJjZS5taW5UaW1lc3RhbXApIHx8ICh0aGlzLnN0YXJ0VGltZXN0YW1wID4gZGF0YVNvdXJjZS5tYXhUaW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIGlmKGRhdGFTb3VyY2Uuc3RhdHVzID09PSBTdGF0dXMuRkVUQ0hfU1RBUlRFRCl7XG4gICAgICAgICAgICAgICAgICAgIG5iRmV0Y2grKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoZGF0YVNvdXJjZS5za2lwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5iU2tpcCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbU3luY2hyb25pemVyXSBGZXRjaGVkICR7bmJGZXRjaH0vJHt0b3RhbERhdGFTb3VyY2VzfSBkYXRhc291cmNlc2ApO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbU3luY2hyb25pemVyXSBTa2lwcGVkICR7bmJTa2lwfS8ke3RvdGFsRGF0YVNvdXJjZXN9IGRhdGFzb3VyY2VzYCk7XG4gICAgICAgICAgICBpZigobmJGZXRjaCArIG5iU2tpcCkgPT09IHRvdGFsRGF0YVNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1N0YXJ0aW5nIFJlcGxheSBBbGdvcml0aG0uLi4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NEYXRhKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVja0VuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0Q3VycmVudFRpbWVzdGFtcCgpID4gdGhpcy5lbmRUaW1lc3RhbXApIHtcbiAgICAgICAgICAgIHRoaXMub25FbmQoKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICBjb25zb2xlLmxvZygncmVzZXQgc3luY2hyb25pemVyIGFsZ28nKVxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIGZvciAobGV0IGN1cnJlbnREc0lkIGluIHRoaXMuZGF0YVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldERhdGFTb3VyY2UoY3VycmVudERzSWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHNSdW4gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmVzZXREYXRhU291cmNlKGRhdGFzb3VyY2VJZCkge1xuICAgICAgICBjb25zdCBjdXJyZW50RHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YXNvdXJjZUlkXTtcbiAgICAgICAgY3VycmVudERzLmRhdGFCdWZmZXIgPSBbXTtcbiAgICAgICAgY3VycmVudERzLnN0YXR1cz0gU3RhdHVzLkRJU0NPTk5FQ1RFRDtcbiAgICAgICAgY3VycmVudERzLnZlcnNpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGN1cnJlbnREcy5za2lwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmVtb3ZlRGF0YVNvdXJjZShkYXRhU291cmNlSWQpIHtcbiAgICAgICAgc3VwZXIucmVtb3ZlRGF0YVNvdXJjZShkYXRhU291cmNlSWQpO1xuICAgICAgICAvLyBsb29raW5nIGZvciBuZXh0IHN0YXJ0IFRpbWVzdGFtcFxuICAgICAgICBsZXQgY3VycmVudFRpbWVzdGFtcCA9IHRoaXMuZ2V0Q3VycmVudFRpbWVzdGFtcCgpO1xuICAgICAgICBsZXQgbWluLCBkcztcbiAgICAgICAgZm9yKGxldCBkc0tleSBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGRzID0gdGhpcy5kYXRhU291cmNlTWFwW2RzS2V5XTtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRUaW1lc3RhbXAgPj0gZHMubWluVGltZXN0YW1wICYmIGN1cnJlbnRUaW1lc3RhbXAgPD0gZHMubWF4VGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgLy8gY29udGludWUgYmVjYXVzZSB0aGlzIGRhdGFzb3VyY2UgaXMgaW4gdGhlIGN1cnJlbnQgcmFuZ2VcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgIC8vIGxvb2tpbmcgZm9yIG5leHQgcmFuZ2UgYW5kIHJlc2V0IGFsZ29cbiAgICAgICAgICAgICAgICBpZighbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGRzLm1pblRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoZHMubWluVGltZXN0YW1wIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGRzLm1pblRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRFbmRUaW1lc3RhbXAobWF4VGltZXN0YW1wKSB7XG4gICAgICAgIHRoaXMuZW5kVGltZXN0YW1wID0gbWF4VGltZXN0YW1wO1xuICAgIH1cbiAgICBzZXRUaW1lUmFuZ2Uoc3RhcnRUaW1lc3RhbXAsIGVuZFRpbWVzdGFtcCwgcmVwbGF5U3BlZCkge1xuICAgICAgICB0aGlzLnJlcGxheVNwZWVkID0gcmVwbGF5U3BlZDtcbiAgICAgICAgdGhpcy5zdGFydFRpbWVzdGFtcCA9IHN0YXJ0VGltZXN0YW1wO1xuICAgICAgICB0aGlzLmVuZFRpbWVzdGFtcCA9IGVuZFRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5jbG9ja1RpbWVSZWYgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLmNoZWNrU3RhcnQoKTtcbiAgICB9XG5cbiAgICBvbkVuZCgpIHt9XG4gICAgb25TdGFydCgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERhdGFTeW5jaHJvbml6ZXJBbGdvUmVwbGF5O1xuIiwiaW1wb3J0IHtEQVRBU09VUkNFX0RBVEFfVE9QSUN9IGZyb20gXCIuLi8uLi9Db25zdGFudHMuanNcIjtcbmltcG9ydCB7RXZlbnRUeXBlfSBmcm9tIFwiLi4vLi4vZXZlbnQvRXZlbnRUeXBlLmpzXCI7XG5pbXBvcnQge2lzRGVmaW5lZH0gZnJvbSBcIi4uLy4uL3V0aWxzL1V0aWxzXCI7XG5pbXBvcnQgRGF0YVN5bmNocm9uaXplckFsZ29SZXBsYXkgZnJvbSBcIi4vRGF0YVN5bmNocm9uaXplckFsZ28ucmVwbGF5XCI7XG5cbmNvbnN0IGJjQ2hhbm5lbHMgPSB7fTtcbmxldCBkYXRhU3luY2hyb25pemVyQWxnbztcblxubGV0IGluaXQgPSBmYWxzZTtcbmxldCBkYXRhU291cmNlQnJvYWRDYXN0Q2hhbm5lbCA9IG51bGw7XG5sZXQgbGFzdERhdGEgPSB1bmRlZmluZWQ7XG5jb25zdCBkYXRhU291cmNlcyA9IHt9O1xubGV0IHRpbWVCcm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbmxldCB0b3BpY1RpbWU7XG5sZXQgdG9waWNEYXRhO1xubGV0IHJlcGxheVNwZWVkO1xubGV0IG1hc3RlclRpbWVJbnRlcnZhbCA9IHVuZGVmaW5lZDtcbmxldCBjVGltZTtcbmxldCBjSWQ7XG5sZXQgbGFzdFRpbWUgPSAtMTtcbmxldCB2ZXJzaW9uID0gLTE7XG5sZXQgcHJvbWlzZTtcbmxldCBtYXN0ZXJUaW1lUmVmcmVzaFJhdGU7XG5sZXQgc3RhcnRUaW1lc3RhbXA7XG5sZXQgZW5kVGltZXN0YW1wO1xubGV0IHRpbWVyUmVzb2x1dGlvbjtcblxuc2VsZi5vbm1lc3NhZ2UgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICBpZihpc0RlZmluZWQocHJvbWlzZSkpIHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZSA9IGhhbmRsZU1lc3NhZ2UoZXZlbnQpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBzZW5kUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnaW5pdCcpIHtcbiAgICAgICAgICAgICAgICByZXBsYXlTcGVlZCA9IGV2ZW50LmRhdGEucmVwbGF5U3BlZWQ7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXAgPSBldmVudC5kYXRhLnN0YXJ0VGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIGVuZFRpbWVzdGFtcCA9IGV2ZW50LmRhdGEuZW5kVGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIHZlcnNpb24gPSBldmVudC5kYXRhLnZlcnNpb247XG4gICAgICAgICAgICAgICAgdGltZXJSZXNvbHV0aW9uID0gZXZlbnQuZGF0YS50aW1lclJlc29sdXRpb247XG5cbiAgICAgICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnbyA9IG5ldyBEYXRhU3luY2hyb25pemVyQWxnb1JlcGxheShcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5kYXRhU291cmNlcyxcbiAgICAgICAgICAgICAgICAgICAgcmVwbGF5U3BlZWQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICBlbmRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEudGltZXJSZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5vbkNsb3NlID0gb25DbG9zZTtcbiAgICAgICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5vbkRhdGEgPSBvbkRhdGE7XG4gICAgICAgICAgICAgICAgaW5pdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWRkRGF0YVNvdXJjZXMoZXZlbnQuZGF0YS5kYXRhU291cmNlcyk7XG4gICAgICAgICAgICAgICAgdG9waWNEYXRhID0gZXZlbnQuZGF0YS50b3BpY3MuZGF0YTtcbiAgICAgICAgICAgICAgICB0b3BpY1RpbWUgPSBldmVudC5kYXRhLnRvcGljcy50aW1lO1xuICAgICAgICAgICAgICAgIGluaXRCcm9hZGNhc3RDaGFubmVsKHRvcGljRGF0YSwgdG9waWNUaW1lKTtcbiAgICAgICAgICAgICAgICBtYXN0ZXJUaW1lUmVmcmVzaFJhdGUgPSBldmVudC5kYXRhLm1hc3RlclRpbWVSZWZyZXNoUmF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnYWRkJyAmJiBldmVudC5kYXRhLmRhdGFTb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FkZCBkYXRhc291cmNlIHRvIHN5bmNocm9uaXplci4uJylcbiAgICAgICAgICAgICAgICBhZGREYXRhU291cmNlcyhldmVudC5kYXRhLmRhdGFTb3VyY2VzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICBzdGFydE1hc3RlclRpbWVJbnRlcnZhbChtYXN0ZXJUaW1lUmVmcmVzaFJhdGUpO1xuICAgICAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLmNoZWNrU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uID0gZXZlbnQuZGF0YS52ZXJzaW9uO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGV2ZW50LmRhdGEubWVzc2FnZSA9PT0gJ2lzLWNvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaXMtY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaXNEZWZpbmVkKG1hc3RlclRpbWVJbnRlcnZhbCkgJiYgaXNEZWZpbmVkKGRhdGFTeW5jaHJvbml6ZXJBbGdvKSAmJiBpc0RlZmluZWQoZGF0YVN5bmNocm9uaXplckFsZ28uaW50ZXJ2YWwpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAncmVtb3ZlJyAmJiBldmVudC5kYXRhLmRhdGFTb3VyY2VJZHMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVtb3ZlIGRhdGFzb3VyY2UgZnJvbSBzeW5jaHJvbml6ZXIuLicpXG4gICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlRGF0YVNvdXJjZXMoZXZlbnQuZGF0YS5kYXRhU291cmNlSWRzKTtcbiAgICAgICAgICAgICAgICBpZihkYXRhU3luY2hyb25pemVyQWxnbyBpbnN0YW5jZW9mIERhdGFTeW5jaHJvbml6ZXJBbGdvUmVwbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLmVuZFRpbWVzdGFtcCA9IGV2ZW50LmRhdGEuZW5kVGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnY3VycmVudC10aW1lJykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdjdXJyZW50LXRpbWUnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhU3luY2hyb25pemVyQWxnby5nZXRDdXJyZW50VGltZXN0YW1wKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdyZXNldCcpIHtcbiAgICAgICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdyZXBsYXktc3BlZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFTeW5jaHJvbml6ZXJBbGdvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnJlcGxheVNwZWVkID0gZXZlbnQuZGF0YS5yZXBsYXlTcGVlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICBlbHNlIGlmIChldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdzZXQtbWF4LXRpbWUnKSB7XG4gICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28uc2V0RW5kVGltZXN0YW1wKGV2ZW50LmRhdGEubWF4VGltZXN0YW1wKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAndGltZS1yYW5nZScpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lUmFuZ2UoXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuc3RhcnRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuZW5kVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEucmVwbGF5U3BlZWQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEudmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5kYXRhU291cmNlc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgICAgICBjaGVja01hc3RlclRpbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVN5bmNocm9uaXplckFsZ28gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ucHVzaChldmVudC5kYXRhLmRhdGFTb3VyY2VJZCwgZXZlbnQuZGF0YS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZW5kUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXZlbnQuZGF0YS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWQ6IGV2ZW50LmRhdGEubWVzc2FnZUlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICByZWplY3QoZXgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRUaW1lUmFuZ2Uoc3RhcnRUaW1lc3RhbXAsIGVuZFRpbWVzdGFtcCwgbW9kZSwgcmVwbGF5U3BlZWQsIG5ld1ZlcnNpb24sIGRzQXJyYXkpIHtcbiAgICByZXNldCgpO1xuICAgIHZlcnNpb24gPSBuZXdWZXJzaW9uO1xuXG4gICAgZGF0YVN5bmNocm9uaXplckFsZ28gPSBuZXcgRGF0YVN5bmNocm9uaXplckFsZ29SZXBsYXkoXG4gICAgICAgIGRzQXJyYXksXG4gICAgICAgIHJlcGxheVNwZWVkLFxuICAgICAgICBzdGFydFRpbWVzdGFtcCxcbiAgICAgICAgZW5kVGltZXN0YW1wLFxuICAgICAgICB0aW1lclJlc29sdXRpb24sXG4gICAgICAgIHZlcnNpb25cbiAgICApO1xuICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLm9uRW5kID0gb25FbmQ7XG4gICAgZGF0YVN5bmNocm9uaXplckFsZ28ub25TdGFydCA9IG9uU3RhcnQ7XG4gICAgZGF0YVN5bmNocm9uaXplckFsZ28ub25DbG9zZSA9IG9uQ2xvc2U7XG4gICAgZGF0YVN5bmNocm9uaXplckFsZ28ub25EYXRhID0gb25EYXRhO1xufVxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY2xlYXJJbnRlcnZhbChtYXN0ZXJUaW1lSW50ZXJ2YWwpO1xuICAgIG1hc3RlclRpbWVJbnRlcnZhbCA9IHVuZGVmaW5lZDtcbiAgICBpZihkYXRhU3luY2hyb25pemVyQWxnbyAhPT0gbnVsbCkge1xuICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5yZXNldCgpO1xuICAgIH1cbiAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5USU1FX0NIQU5HRURcbiAgICB9KTtcbiAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5DTE9TRURcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRCcm9hZGNhc3RDaGFubmVsKGRhdGFUb3BpYywgdGltZVRvcGljKSB7XG4gICAgY29uc29sZS5sb2coJ2xpc3RlbiBvbiB0b3BpYyAnLGRhdGFUb3BpYylcblxuICAgIGRhdGFTb3VyY2VCcm9hZENhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoZGF0YVRvcGljKTtcbiAgICBkYXRhU291cmNlQnJvYWRDYXN0Q2hhbm5lbC5vbm1lc3NhZ2UgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgY2hlY2tNYXN0ZXJUaW1lKCk7XG4gICAgICAgIGlmKGV2ZW50LmRhdGEudHlwZSA9PT0gRXZlbnRUeXBlLkRBVEEpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG5ldyBEYXRlKGV2ZW50LmRhdGEudmFsdWVzWzBdLmRhdGEudGltZXN0YW1wKS50b0lTT1N0cmluZygpLCBldmVudC5kYXRhLnZhbHVlc1swXS52ZXJzaW9uKTtcbiAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnB1c2goZXZlbnQuZGF0YS5kYXRhU291cmNlSWQsZXZlbnQuZGF0YS52YWx1ZXMpO1xuICAgICAgICB9IGVsc2UgaWYoZXZlbnQuZGF0YS50eXBlID09PSBFdmVudFR5cGUuU1RBVFVTKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhU291cmNlSWQgPSBldmVudC5kYXRhLmRhdGFTb3VyY2VJZDtcbiAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnNldFN0YXR1cyhkYXRhU291cmNlSWQsIGV2ZW50LmRhdGEuc3RhdHVzKTtcbiAgICAgICAgICAgIC8vIGJ1YmJsZSB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgaWYoZGF0YVNvdXJjZUlkIGluIGJjQ2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhU291cmNlc1tkYXRhU291cmNlSWRdLm5hbWUgKyBcIjogc3RhdHVzPVwiICsgZXZlbnQuZGF0YS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgIGJjQ2hhbm5lbHNbZGF0YVNvdXJjZUlkXS5wb3N0TWVzc2FnZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVCcm9hZGNhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwodGltZVRvcGljKTtcblxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gZGF0YVNvdXJjZXNcbiAqL1xuZnVuY3Rpb24gYWRkRGF0YVNvdXJjZXMoZGF0YVNvdXJjZXMpIHtcbiAgICBmb3IobGV0IGRhdGFTb3VyY2Ugb2YgZGF0YVNvdXJjZXMpIHtcbiAgICAgICAgYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZERhdGFTb3VyY2UoZGF0YVNvdXJjZSkge1xuICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLmFkZERhdGFTb3VyY2UoZGF0YVNvdXJjZSk7XG4gICAgLy8gY3JlYXRlIGEgQkMgdG8gcHVzaCBiYWNrIHRoZSBzeW5jaHJvbml6ZWQgZGF0YSBpbnRvIHRoZSBEQVRBIFN0cmVhbS5cbiAgICBiY0NoYW5uZWxzW2RhdGFTb3VyY2UuaWRdID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoREFUQVNPVVJDRV9EQVRBX1RPUElDICsgZGF0YVNvdXJjZS5pZCk7XG5cbiAgICBpZighKGRhdGFTb3VyY2UuaWQgaW4gZGF0YVNvdXJjZXMpKSB7XG4gICAgICAgIGRhdGFTb3VyY2VzW2RhdGFTb3VyY2UuaWRdID0gZGF0YVNvdXJjZTtcbiAgICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBkYXRhU291cmNlSWRzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZURhdGFTb3VyY2VzKGRhdGFTb3VyY2VJZHMpIHtcbiAgICBmb3IobGV0IGRhdGFTb3VyY2VJZCBvZiBkYXRhU291cmNlSWRzKSB7XG4gICAgICAgIGF3YWl0IHJlbW92ZURhdGFTb3VyY2UoZGF0YVNvdXJjZUlkKTtcbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZURhdGFTb3VyY2UoZGF0YVNvdXJjZUlkKSB7XG4gICAgYXdhaXQgZGF0YVN5bmNocm9uaXplckFsZ28ucmVtb3ZlRGF0YVNvdXJjZShkYXRhU291cmNlSWQpO1xuICAgIC8vIGNyZWF0ZSBhIEJDIHRvIHB1c2ggYmFjayB0aGUgc3luY2hyb25pemVkIGRhdGEgaW50byB0aGUgREFUQSBTdHJlYW0uXG4gICAgY29uc29sZS5sb2coJ2RlbGV0aW5nIEJDIGZvciBkYXRhc291cmNlICcrZGF0YVNvdXJjZUlkKTtcbiAgICBkZWxldGUgYmNDaGFubmVsc1tkYXRhU291cmNlSWRdO1xuICAgIGRlbGV0ZSBkYXRhU291cmNlc1tkYXRhU291cmNlSWRdO1xufVxuXG5mdW5jdGlvbiBjaGVja01hc3RlclRpbWUoKSB7XG4gICAgaWYoIWlzRGVmaW5lZChtYXN0ZXJUaW1lSW50ZXJ2YWwpKSB7XG4gICAgICAgIHN0YXJ0TWFzdGVyVGltZUludGVydmFsKG1hc3RlclRpbWVSZWZyZXNoUmF0ZSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgY29uc3QgbWFzdGVyVGltZSA9IGRhdGFTeW5jaHJvbml6ZXJBbGdvLmdldEN1cnJlbnRUaW1lc3RhbXAoKTtcbiAgICBjbGVhckludGVydmFsKG1hc3RlclRpbWVJbnRlcnZhbCk7XG4gICAgbWFzdGVyVGltZUludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIC8vIGVuZCBhdCB0aGlzIHRpbWVcbiAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHRpbWVzdGFtcDogbWFzdGVyVGltZSxcbiAgICAgICAgdHlwZTogRXZlbnRUeXBlLk1BU1RFUl9USU1FXG4gICAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgY2hlY2tNYXN0ZXJUaW1lKCk7XG59XG5cbmZ1bmN0aW9uIG9uQ2xvc2UoKSB7XG4gICAgdGltZUJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBFdmVudFR5cGUuQ0xPU0VEXG4gICAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uRGF0YShkYXRhU291cmNlSWQsIGRhdGFCbG9jaykge1xuICAgIGlmKGRhdGFCbG9jay52ZXJzaW9uICE9PSB2ZXJzaW9uKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3ZlcnNpb24gYXJlIGRpZmZlcmVudDonLGRhdGFCbG9jay52ZXJzaW9uLHZlcnNpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3REYXRhID0ge1xuICAgICAgICBkYXRhU291cmNlSWQ6IGRhdGFTb3VyY2VJZCxcbiAgICAgICAgZGF0YUJsb2NrOiBkYXRhQmxvY2ssXG4gICAgfTtcbiAgICBiY0NoYW5uZWxzW2RhdGFTb3VyY2VJZF0ucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdmFsdWVzOiBbZGF0YUJsb2NrXSxcbiAgICAgICAgICAgIGRhdGFTb3VyY2VJZDpkYXRhU291cmNlSWQsXG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuREFUQVxuICAgICAgICB9XG4gICAgKTtcbn1cbnNlbGYub25jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLmNsb3NlKCk7XG4gICAgY29uc29sZS5sb2coXCJEYXRhIFN5bmNocm9uaXplciBoYXMgYmVlbiB0ZXJtaW5hdGVkIHN1Y2Nlc3NmdWxseVwiKTtcbn1cblxubGV0IG1hc3RlclRpbWU7XG5mdW5jdGlvbiBzdGFydE1hc3RlclRpbWVJbnRlcnZhbChtYXN0ZXJUaW1lUmVmcmVzaFJhdGUpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChtYXN0ZXJUaW1lSW50ZXJ2YWwpKSB7XG4gICAgICAgIG1hc3RlclRpbWVJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIG1hc3RlclRpbWUgPSBkYXRhU3luY2hyb25pemVyQWxnby5nZXRDdXJyZW50VGltZXN0YW1wKCk7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKG1hc3RlclRpbWUpKSB7XG4gICAgICAgICAgICAgICAgdGltZUJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG1hc3RlclRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5NQVNURVJfVElNRVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihpc0RlZmluZWQobGFzdERhdGEpKSB7XG4gICAgICAgICAgICAgICAgY1RpbWUgPSBsYXN0RGF0YS5kYXRhQmxvY2suZGF0YS50aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgY0lkID0gbGFzdERhdGEuZGF0YVNvdXJjZUlkO1xuXG4gICAgICAgICAgICAgICAgaWYgKChjVGltZSAhPT0gLTEgJiYgbGFzdFRpbWUgPT09IC0xKSB8fCAobGFzdFRpbWUgIT09IC0xICYmIGNUaW1lICE9PSBsYXN0VGltZSkpIHsgLy8gZG9lcyBub3Qgc2VuZCB0aGUgc2FtZSBkYXRhIHR3aWNlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVCcm9hZGNhc3RDaGFubmVsLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogY1RpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhU291cmNlSWQ6IGNJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5MQVNUX1RJTUVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RUaW1lID0gY1RpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG1hc3RlclRpbWVSZWZyZXNoUmF0ZSk7XG4gICAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")}]);