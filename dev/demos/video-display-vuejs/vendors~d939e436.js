(window.webpackJsonp=window.webpackJsonp||[]).push([[3],[,function(module,exports,__webpack_require__){eval("/* @preserve\n * Leaflet 1.6.0, a JS library for interactive maps. http://leafletjs.com\n * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */\n(function (global, factory) {\n   true ? factory(exports) : undefined;\n})(this, function (exports) {\n  'use strict';\n\n  var version = \"1.6.0\";\n  /*\r\n   * @namespace Util\r\n   *\r\n   * Various utility functions, used by Leaflet internally.\r\n   */\n\n  var freeze = Object.freeze;\n\n  Object.freeze = function (obj) {\n    return obj;\n  }; // @function extend(dest: Object, src?: Object): Object\n  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.\n\n\n  function extend(dest) {\n    var i, j, len, src;\n\n    for (j = 1, len = arguments.length; j < len; j++) {\n      src = arguments[j];\n\n      for (i in src) {\n        dest[i] = src[i];\n      }\n    }\n\n    return dest;\n  } // @function create(proto: Object, properties?: Object): Object\n  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n\n\n  var create = Object.create || function () {\n    function F() {}\n\n    return function (proto) {\n      F.prototype = proto;\n      return new F();\n    };\n  }(); // @function bind(fn: Function, …): Function\n  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n  // Has a `L.bind()` shortcut.\n\n\n  function bind(fn, obj) {\n    var slice = Array.prototype.slice;\n\n    if (fn.bind) {\n      return fn.bind.apply(fn, slice.call(arguments, 1));\n    }\n\n    var args = slice.call(arguments, 2);\n    return function () {\n      return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\n    };\n  } // @property lastId: Number\n  // Last unique ID used by [`stamp()`](#util-stamp)\n\n\n  var lastId = 0; // @function stamp(obj: Object): Number\n  // Returns the unique ID of an object, assigning it one if it doesn't have it.\n\n  function stamp(obj) {\n    /*eslint-disable */\n    obj._leaflet_id = obj._leaflet_id || ++lastId;\n    return obj._leaflet_id;\n    /* eslint-enable */\n  } // @function throttle(fn: Function, time: Number, context: Object): Function\n  // Returns a function which executes function `fn` with the given scope `context`\n  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function\n  // `fn` will be called no more than one time per given amount of `time`. The arguments\n  // received by the bound function will be any arguments passed when binding the\n  // function, followed by any arguments passed when invoking the bound function.\n  // Has an `L.throttle` shortcut.\n\n\n  function throttle(fn, time, context) {\n    var lock, args, wrapperFn, later;\n\n    later = function () {\n      // reset lock and call if queued\n      lock = false;\n\n      if (args) {\n        wrapperFn.apply(context, args);\n        args = false;\n      }\n    };\n\n    wrapperFn = function () {\n      if (lock) {\n        // called too soon, queue to call later\n        args = arguments;\n      } else {\n        // call and lock until later\n        fn.apply(context, arguments);\n        setTimeout(later, time);\n        lock = true;\n      }\n    };\n\n    return wrapperFn;\n  } // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number\n  // Returns the number `num` modulo `range` in such a way so it lies within\n  // `range[0]` and `range[1]`. The returned value will be always smaller than\n  // `range[1]` unless `includeMax` is set to `true`.\n\n\n  function wrapNum(x, range, includeMax) {\n    var max = range[1],\n        min = range[0],\n        d = max - min;\n    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;\n  } // @function falseFn(): Function\n  // Returns a function which always returns `false`.\n\n\n  function falseFn() {\n    return false;\n  } // @function formatNum(num: Number, digits?: Number): Number\n  // Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.\n\n\n  function formatNum(num, digits) {\n    var pow = Math.pow(10, digits === undefined ? 6 : digits);\n    return Math.round(num * pow) / pow;\n  } // @function trim(str: String): String\n  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)\n\n\n  function trim(str) {\n    return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n  } // @function splitWords(str: String): String[]\n  // Trims and splits the string on whitespace and returns the array of parts.\n\n\n  function splitWords(str) {\n    return trim(str).split(/\\s+/);\n  } // @function setOptions(obj: Object, options: Object): Object\n  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.\n\n\n  function setOptions(obj, options) {\n    if (!obj.hasOwnProperty('options')) {\n      obj.options = obj.options ? create(obj.options) : {};\n    }\n\n    for (var i in options) {\n      obj.options[i] = options[i];\n    }\n\n    return obj.options;\n  } // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String\n  // Converts an object into a parameter URL string, e.g. `{a: \"foo\", b: \"bar\"}`\n  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will\n  // be appended at the end. If `uppercase` is `true`, the parameter names will\n  // be uppercased (e.g. `'?A=foo&B=bar'`)\n\n\n  function getParamString(obj, existingUrl, uppercase) {\n    var params = [];\n\n    for (var i in obj) {\n      params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\n    }\n\n    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');\n  }\n\n  var templateRe = /\\{ *([\\w_-]+) *\\}/g; // @function template(str: String, data: Object): String\n  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\n  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\n  // `('Hello foo, bar')`. You can also specify functions instead of strings for\n  // data values — they will be evaluated passing `data` as an argument.\n\n  function template(str, data) {\n    return str.replace(templateRe, function (str, key) {\n      var value = data[key];\n\n      if (value === undefined) {\n        throw new Error('No value provided for variable ' + str);\n      } else if (typeof value === 'function') {\n        value = value(data);\n      }\n\n      return value;\n    });\n  } // @function isArray(obj): Boolean\n  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\n\n\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  }; // @function indexOf(array: Array, el: Object): Number\n  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\n\n\n  function indexOf(array, el) {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === el) {\n        return i;\n      }\n    }\n\n    return -1;\n  } // @property emptyImageUrl: String\n  // Data URI string containing a base64-encoded empty GIF image.\n  // Used as a hack to free memory from unused images on WebKit-powered\n  // mobile devices (by setting image `src` to this string).\n\n\n  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\n  function getPrefixed(name) {\n    return window['webkit' + name] || window['moz' + name] || window['ms' + name];\n  }\n\n  var lastTime = 0; // fallback for IE 7-8\n\n  function timeoutDefer(fn) {\n    var time = +new Date(),\n        timeToCall = Math.max(0, 16 - (time - lastTime));\n    lastTime = time + timeToCall;\n    return window.setTimeout(fn, timeToCall);\n  }\n\n  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;\n\n  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {\n    window.clearTimeout(id);\n  }; // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number\n  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to\n  // `context` if given. When `immediate` is set, `fn` is called immediately if\n  // the browser doesn't have native support for\n  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),\n  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.\n\n\n  function requestAnimFrame(fn, context, immediate) {\n    if (immediate && requestFn === timeoutDefer) {\n      fn.call(context);\n    } else {\n      return requestFn.call(window, bind(fn, context));\n    }\n  } // @function cancelAnimFrame(id: Number): undefined\n  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).\n\n\n  function cancelAnimFrame(id) {\n    if (id) {\n      cancelFn.call(window, id);\n    }\n  }\n\n  var Util = (Object.freeze || Object)({\n    freeze: freeze,\n    extend: extend,\n    create: create,\n    bind: bind,\n    lastId: lastId,\n    stamp: stamp,\n    throttle: throttle,\n    wrapNum: wrapNum,\n    falseFn: falseFn,\n    formatNum: formatNum,\n    trim: trim,\n    splitWords: splitWords,\n    setOptions: setOptions,\n    getParamString: getParamString,\n    template: template,\n    isArray: isArray,\n    indexOf: indexOf,\n    emptyImageUrl: emptyImageUrl,\n    requestFn: requestFn,\n    cancelFn: cancelFn,\n    requestAnimFrame: requestAnimFrame,\n    cancelAnimFrame: cancelAnimFrame\n  }); // @class Class\n  // @aka L.Class\n  // @section\n  // @uninheritable\n  // Thanks to John Resig and Dean Edwards for inspiration!\n\n  function Class() {}\n\n  Class.extend = function (props) {\n    // @function extend(props: Object): Function\n    // [Extends the current class](#class-inheritance) given the properties to be included.\n    // Returns a Javascript function that is a class constructor (to be called with `new`).\n    var NewClass = function () {\n      // call the constructor\n      if (this.initialize) {\n        this.initialize.apply(this, arguments);\n      } // call all constructor hooks\n\n\n      this.callInitHooks();\n    };\n\n    var parentProto = NewClass.__super__ = this.prototype;\n    var proto = create(parentProto);\n    proto.constructor = NewClass;\n    NewClass.prototype = proto; // inherit parent's statics\n\n    for (var i in this) {\n      if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {\n        NewClass[i] = this[i];\n      }\n    } // mix static properties into the class\n\n\n    if (props.statics) {\n      extend(NewClass, props.statics);\n      delete props.statics;\n    } // mix includes into the prototype\n\n\n    if (props.includes) {\n      checkDeprecatedMixinEvents(props.includes);\n      extend.apply(null, [proto].concat(props.includes));\n      delete props.includes;\n    } // merge options\n\n\n    if (proto.options) {\n      props.options = extend(create(proto.options), props.options);\n    } // mix given properties into the prototype\n\n\n    extend(proto, props);\n    proto._initHooks = []; // add method for calling all hooks\n\n    proto.callInitHooks = function () {\n      if (this._initHooksCalled) {\n        return;\n      }\n\n      if (parentProto.callInitHooks) {\n        parentProto.callInitHooks.call(this);\n      }\n\n      this._initHooksCalled = true;\n\n      for (var i = 0, len = proto._initHooks.length; i < len; i++) {\n        proto._initHooks[i].call(this);\n      }\n    };\n\n    return NewClass;\n  }; // @function include(properties: Object): this\n  // [Includes a mixin](#class-includes) into the current class.\n\n\n  Class.include = function (props) {\n    extend(this.prototype, props);\n    return this;\n  }; // @function mergeOptions(options: Object): this\n  // [Merges `options`](#class-options) into the defaults of the class.\n\n\n  Class.mergeOptions = function (options) {\n    extend(this.prototype.options, options);\n    return this;\n  }; // @function addInitHook(fn: Function): this\n  // Adds a [constructor hook](#class-constructor-hooks) to the class.\n\n\n  Class.addInitHook = function (fn) {\n    // (Function) || (String, args...)\n    var args = Array.prototype.slice.call(arguments, 1);\n    var init = typeof fn === 'function' ? fn : function () {\n      this[fn].apply(this, args);\n    };\n    this.prototype._initHooks = this.prototype._initHooks || [];\n\n    this.prototype._initHooks.push(init);\n\n    return this;\n  };\n\n  function checkDeprecatedMixinEvents(includes) {\n    if (typeof L === 'undefined' || !L || !L.Mixin) {\n      return;\n    }\n\n    includes = isArray(includes) ? includes : [includes];\n\n    for (var i = 0; i < includes.length; i++) {\n      if (includes[i] === L.Mixin.Events) {\n        console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);\n      }\n    }\n  }\n  /*\r\n   * @class Evented\r\n   * @aka L.Evented\r\n   * @inherits Class\r\n   *\r\n   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * map.on('click', function(e) {\r\n   * \talert(e.latlng);\r\n   * } );\r\n   * ```\r\n   *\r\n   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n   *\r\n   * ```js\r\n   * function onClick(e) { ... }\r\n   *\r\n   * map.on('click', onClick);\r\n   * map.off('click', onClick);\r\n   * ```\r\n   */\n\n\n  var Events = {\n    /* @method on(type: String, fn: Function, context?: Object): this\r\n     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n     *\r\n     * @alternative\r\n     * @method on(eventMap: Object): this\r\n     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n     */\n    on: function (types, fn, context) {\n      // types can be a map of types/handlers\n      if (typeof types === 'object') {\n        for (var type in types) {\n          // we don't process space-separated events here for performance;\n          // it's a hot path since Layer uses the on(obj) syntax\n          this._on(type, types[type], fn);\n        }\n      } else {\n        // types can be a string of space-separated words\n        types = splitWords(types);\n\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._on(types[i], fn, context);\n        }\n      }\n\n      return this;\n    },\n\n    /* @method off(type: String, fn?: Function, context?: Object): this\r\n     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n     *\r\n     * @alternative\r\n     * @method off(eventMap: Object): this\r\n     * Removes a set of type/listener pairs.\r\n     *\r\n     * @alternative\r\n     * @method off: this\r\n     * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n     */\n    off: function (types, fn, context) {\n      if (!types) {\n        // clear all listeners if called without arguments\n        delete this._events;\n      } else if (typeof types === 'object') {\n        for (var type in types) {\n          this._off(type, types[type], fn);\n        }\n      } else {\n        types = splitWords(types);\n\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._off(types[i], fn, context);\n        }\n      }\n\n      return this;\n    },\n    // attach listener (without syntactic sugar now)\n    _on: function (type, fn, context) {\n      this._events = this._events || {};\n      /* get/init listeners for type */\n\n      var typeListeners = this._events[type];\n\n      if (!typeListeners) {\n        typeListeners = [];\n        this._events[type] = typeListeners;\n      }\n\n      if (context === this) {\n        // Less memory footprint.\n        context = undefined;\n      }\n\n      var newListener = {\n        fn: fn,\n        ctx: context\n      },\n          listeners = typeListeners; // check if fn already there\n\n      for (var i = 0, len = listeners.length; i < len; i++) {\n        if (listeners[i].fn === fn && listeners[i].ctx === context) {\n          return;\n        }\n      }\n\n      listeners.push(newListener);\n    },\n    _off: function (type, fn, context) {\n      var listeners, i, len;\n\n      if (!this._events) {\n        return;\n      }\n\n      listeners = this._events[type];\n\n      if (!listeners) {\n        return;\n      }\n\n      if (!fn) {\n        // Set all removed listeners to noop so they are not called if remove happens in fire\n        for (i = 0, len = listeners.length; i < len; i++) {\n          listeners[i].fn = falseFn;\n        } // clear all listeners for a type if function isn't specified\n\n\n        delete this._events[type];\n        return;\n      }\n\n      if (context === this) {\n        context = undefined;\n      }\n\n      if (listeners) {\n        // find fn and remove it\n        for (i = 0, len = listeners.length; i < len; i++) {\n          var l = listeners[i];\n\n          if (l.ctx !== context) {\n            continue;\n          }\n\n          if (l.fn === fn) {\n            // set the removed listener to noop so that's not called if remove happens in fire\n            l.fn = falseFn;\n\n            if (this._firingCount) {\n              /* copy array in case events are being fired */\n              this._events[type] = listeners = listeners.slice();\n            }\n\n            listeners.splice(i, 1);\n            return;\n          }\n        }\n      }\n    },\n    // @method fire(type: String, data?: Object, propagate?: Boolean): this\n    // Fires an event of the specified type. You can optionally provide an data\n    // object — the first argument of the listener function will contain its\n    // properties. The event can optionally be propagated to event parents.\n    fire: function (type, data, propagate) {\n      if (!this.listens(type, propagate)) {\n        return this;\n      }\n\n      var event = extend({}, data, {\n        type: type,\n        target: this,\n        sourceTarget: data && data.sourceTarget || this\n      });\n\n      if (this._events) {\n        var listeners = this._events[type];\n\n        if (listeners) {\n          this._firingCount = this._firingCount + 1 || 1;\n\n          for (var i = 0, len = listeners.length; i < len; i++) {\n            var l = listeners[i];\n            l.fn.call(l.ctx || this, event);\n          }\n\n          this._firingCount--;\n        }\n      }\n\n      if (propagate) {\n        // propagate the event to parents (set with addEventParent)\n        this._propagateEvent(event);\n      }\n\n      return this;\n    },\n    // @method listens(type: String): Boolean\n    // Returns `true` if a particular event type has any listeners attached to it.\n    listens: function (type, propagate) {\n      var listeners = this._events && this._events[type];\n\n      if (listeners && listeners.length) {\n        return true;\n      }\n\n      if (propagate) {\n        // also check parents for listeners if event propagates\n        for (var id in this._eventParents) {\n          if (this._eventParents[id].listens(type, propagate)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    // @method once(…): this\n    // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.\n    once: function (types, fn, context) {\n      if (typeof types === 'object') {\n        for (var type in types) {\n          this.once(type, types[type], fn);\n        }\n\n        return this;\n      }\n\n      var handler = bind(function () {\n        this.off(types, fn, context).off(types, handler, context);\n      }, this); // add a listener that's executed once and removed after that\n\n      return this.on(types, fn, context).on(types, handler, context);\n    },\n    // @method addEventParent(obj: Evented): this\n    // Adds an event parent - an `Evented` that will receive propagated events\n    addEventParent: function (obj) {\n      this._eventParents = this._eventParents || {};\n      this._eventParents[stamp(obj)] = obj;\n      return this;\n    },\n    // @method removeEventParent(obj: Evented): this\n    // Removes an event parent, so it will stop receiving propagated events\n    removeEventParent: function (obj) {\n      if (this._eventParents) {\n        delete this._eventParents[stamp(obj)];\n      }\n\n      return this;\n    },\n    _propagateEvent: function (e) {\n      for (var id in this._eventParents) {\n        this._eventParents[id].fire(e.type, extend({\n          layer: e.target,\n          propagatedFrom: e.target\n        }, e), true);\n      }\n    }\n  }; // aliases; we should ditch those eventually\n  // @method addEventListener(…): this\n  // Alias to [`on(…)`](#evented-on)\n\n  Events.addEventListener = Events.on; // @method removeEventListener(…): this\n  // Alias to [`off(…)`](#evented-off)\n  // @method clearAllEventListeners(…): this\n  // Alias to [`off()`](#evented-off)\n\n  Events.removeEventListener = Events.clearAllEventListeners = Events.off; // @method addOneTimeEventListener(…): this\n  // Alias to [`once(…)`](#evented-once)\n\n  Events.addOneTimeEventListener = Events.once; // @method fireEvent(…): this\n  // Alias to [`fire(…)`](#evented-fire)\n\n  Events.fireEvent = Events.fire; // @method hasEventListeners(…): Boolean\n  // Alias to [`listens(…)`](#evented-listens)\n\n  Events.hasEventListeners = Events.listens;\n  var Evented = Class.extend(Events);\n  /*\r\n   * @class Point\r\n   * @aka L.Point\r\n   *\r\n   * Represents a point with `x` and `y` coordinates in pixels.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var point = L.point(200, 300);\r\n   * ```\r\n   *\r\n   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```js\r\n   * map.panBy([200, 300]);\r\n   * map.panBy(L.point(200, 300));\r\n   * ```\r\n   *\r\n   * Note that `Point` does not inherit from Leafet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function Point(x, y, round) {\n    // @property x: Number; The `x` coordinate of the point\n    this.x = round ? Math.round(x) : x; // @property y: Number; The `y` coordinate of the point\n\n    this.y = round ? Math.round(y) : y;\n  }\n\n  var trunc = Math.trunc || function (v) {\n    return v > 0 ? Math.floor(v) : Math.ceil(v);\n  };\n\n  Point.prototype = {\n    // @method clone(): Point\n    // Returns a copy of the current point.\n    clone: function () {\n      return new Point(this.x, this.y);\n    },\n    // @method add(otherPoint: Point): Point\n    // Returns the result of addition of the current and the given points.\n    add: function (point) {\n      // non-destructive, returns a new point\n      return this.clone()._add(toPoint(point));\n    },\n    _add: function (point) {\n      // destructive, used directly for performance in situations where it's safe to modify existing point\n      this.x += point.x;\n      this.y += point.y;\n      return this;\n    },\n    // @method subtract(otherPoint: Point): Point\n    // Returns the result of subtraction of the given point from the current.\n    subtract: function (point) {\n      return this.clone()._subtract(toPoint(point));\n    },\n    _subtract: function (point) {\n      this.x -= point.x;\n      this.y -= point.y;\n      return this;\n    },\n    // @method divideBy(num: Number): Point\n    // Returns the result of division of the current point by the given number.\n    divideBy: function (num) {\n      return this.clone()._divideBy(num);\n    },\n    _divideBy: function (num) {\n      this.x /= num;\n      this.y /= num;\n      return this;\n    },\n    // @method multiplyBy(num: Number): Point\n    // Returns the result of multiplication of the current point by the given number.\n    multiplyBy: function (num) {\n      return this.clone()._multiplyBy(num);\n    },\n    _multiplyBy: function (num) {\n      this.x *= num;\n      this.y *= num;\n      return this;\n    },\n    // @method scaleBy(scale: Point): Point\n    // Multiply each coordinate of the current point by each coordinate of\n    // `scale`. In linear algebra terms, multiply the point by the\n    // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\n    // defined by `scale`.\n    scaleBy: function (point) {\n      return new Point(this.x * point.x, this.y * point.y);\n    },\n    // @method unscaleBy(scale: Point): Point\n    // Inverse of `scaleBy`. Divide each coordinate of the current point by\n    // each coordinate of `scale`.\n    unscaleBy: function (point) {\n      return new Point(this.x / point.x, this.y / point.y);\n    },\n    // @method round(): Point\n    // Returns a copy of the current point with rounded coordinates.\n    round: function () {\n      return this.clone()._round();\n    },\n    _round: function () {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    },\n    // @method floor(): Point\n    // Returns a copy of the current point with floored coordinates (rounded down).\n    floor: function () {\n      return this.clone()._floor();\n    },\n    _floor: function () {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    },\n    // @method ceil(): Point\n    // Returns a copy of the current point with ceiled coordinates (rounded up).\n    ceil: function () {\n      return this.clone()._ceil();\n    },\n    _ceil: function () {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    },\n    // @method trunc(): Point\n    // Returns a copy of the current point with truncated coordinates (rounded towards zero).\n    trunc: function () {\n      return this.clone()._trunc();\n    },\n    _trunc: function () {\n      this.x = trunc(this.x);\n      this.y = trunc(this.y);\n      return this;\n    },\n    // @method distanceTo(otherPoint: Point): Number\n    // Returns the cartesian distance between the current and the given points.\n    distanceTo: function (point) {\n      point = toPoint(point);\n      var x = point.x - this.x,\n          y = point.y - this.y;\n      return Math.sqrt(x * x + y * y);\n    },\n    // @method equals(otherPoint: Point): Boolean\n    // Returns `true` if the given point has the same coordinates.\n    equals: function (point) {\n      point = toPoint(point);\n      return point.x === this.x && point.y === this.y;\n    },\n    // @method contains(otherPoint: Point): Boolean\n    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\n    contains: function (point) {\n      point = toPoint(point);\n      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point for debugging purposes.\n    toString: function () {\n      return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';\n    }\n  }; // @factory L.point(x: Number, y: Number, round?: Boolean)\n  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\n  // @alternative\n  // @factory L.point(coords: Number[])\n  // Expects an array of the form `[x, y]` instead.\n  // @alternative\n  // @factory L.point(coords: Object)\n  // Expects a plain object of the form `{x: Number, y: Number}` instead.\n\n  function toPoint(x, y, round) {\n    if (x instanceof Point) {\n      return x;\n    }\n\n    if (isArray(x)) {\n      return new Point(x[0], x[1]);\n    }\n\n    if (x === undefined || x === null) {\n      return x;\n    }\n\n    if (typeof x === 'object' && 'x' in x && 'y' in x) {\n      return new Point(x.x, x.y);\n    }\n\n    return new Point(x, y, round);\n  }\n  /*\r\n   * @class Bounds\r\n   * @aka L.Bounds\r\n   *\r\n   * Represents a rectangular area in pixel coordinates.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var p1 = L.point(10, 10),\r\n   * p2 = L.point(40, 60),\r\n   * bounds = L.bounds(p1, p2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * otherBounds.intersects([[10, 10], [40, 60]]);\r\n   * ```\r\n   *\r\n   * Note that `Bounds` does not inherit from Leafet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n\n  function Bounds(a, b) {\n    if (!a) {\n      return;\n    }\n\n    var points = b ? [a, b] : a;\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      this.extend(points[i]);\n    }\n  }\n\n  Bounds.prototype = {\n    // @method extend(point: Point): this\n    // Extends the bounds to contain the given point.\n    extend: function (point) {\n      // (Point)\n      point = toPoint(point); // @property min: Point\n      // The top left corner of the rectangle.\n      // @property max: Point\n      // The bottom right corner of the rectangle.\n\n      if (!this.min && !this.max) {\n        this.min = point.clone();\n        this.max = point.clone();\n      } else {\n        this.min.x = Math.min(point.x, this.min.x);\n        this.max.x = Math.max(point.x, this.max.x);\n        this.min.y = Math.min(point.y, this.min.y);\n        this.max.y = Math.max(point.y, this.max.y);\n      }\n\n      return this;\n    },\n    // @method getCenter(round?: Boolean): Point\n    // Returns the center point of the bounds.\n    getCenter: function (round) {\n      return new Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);\n    },\n    // @method getBottomLeft(): Point\n    // Returns the bottom-left point of the bounds.\n    getBottomLeft: function () {\n      return new Point(this.min.x, this.max.y);\n    },\n    // @method getTopRight(): Point\n    // Returns the top-right point of the bounds.\n    getTopRight: function () {\n      // -> Point\n      return new Point(this.max.x, this.min.y);\n    },\n    // @method getTopLeft(): Point\n    // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).\n    getTopLeft: function () {\n      return this.min; // left, top\n    },\n    // @method getBottomRight(): Point\n    // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).\n    getBottomRight: function () {\n      return this.max; // right, bottom\n    },\n    // @method getSize(): Point\n    // Returns the size of the given bounds\n    getSize: function () {\n      return this.max.subtract(this.min);\n    },\n    // @method contains(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n    // @alternative\n    // @method contains(point: Point): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function (obj) {\n      var min, max;\n\n      if (typeof obj[0] === 'number' || obj instanceof Point) {\n        obj = toPoint(obj);\n      } else {\n        obj = toBounds(obj);\n      }\n\n      if (obj instanceof Bounds) {\n        min = obj.min;\n        max = obj.max;\n      } else {\n        min = max = obj;\n      }\n\n      return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;\n    },\n    // @method intersects(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds\n    // intersect if they have at least one point in common.\n    intersects: function (bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n          max = this.max,\n          min2 = bounds.min,\n          max2 = bounds.max,\n          xIntersects = max2.x >= min.x && min2.x <= max.x,\n          yIntersects = max2.y >= min.y && min2.y <= max.y;\n      return xIntersects && yIntersects;\n    },\n    // @method overlaps(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds\n    // overlap if their intersection is an area.\n    overlaps: function (bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n          max = this.max,\n          min2 = bounds.min,\n          max2 = bounds.max,\n          xOverlaps = max2.x > min.x && min2.x < max.x,\n          yOverlaps = max2.y > min.y && min2.y < max.y;\n      return xOverlaps && yOverlaps;\n    },\n    isValid: function () {\n      return !!(this.min && this.max);\n    }\n  }; // @factory L.bounds(corner1: Point, corner2: Point)\n  // Creates a Bounds object from two corners coordinate pairs.\n  // @alternative\n  // @factory L.bounds(points: Point[])\n  // Creates a Bounds object from the given array of points.\n\n  function toBounds(a, b) {\n    if (!a || a instanceof Bounds) {\n      return a;\n    }\n\n    return new Bounds(a, b);\n  }\n  /*\r\n   * @class LatLngBounds\r\n   * @aka L.LatLngBounds\r\n   *\r\n   * Represents a rectangular geographical area on a map.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var corner1 = L.latLng(40.712, -74.227),\r\n   * corner2 = L.latLng(40.774, -74.125),\r\n   * bounds = L.latLngBounds(corner1, corner2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * map.fitBounds([\r\n   * \t[40.712, -74.227],\r\n   * \t[40.774, -74.125]\r\n   * ]);\r\n   * ```\r\n   *\r\n   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.\r\n   *\r\n   * Note that `LatLngBounds` does not inherit from Leafet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n\n  function LatLngBounds(corner1, corner2) {\n    // (LatLng, LatLng) or (LatLng[])\n    if (!corner1) {\n      return;\n    }\n\n    var latlngs = corner2 ? [corner1, corner2] : corner1;\n\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      this.extend(latlngs[i]);\n    }\n  }\n\n  LatLngBounds.prototype = {\n    // @method extend(latlng: LatLng): this\n    // Extend the bounds to contain the given point\n    // @alternative\n    // @method extend(otherBounds: LatLngBounds): this\n    // Extend the bounds to contain the given bounds\n    extend: function (obj) {\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2,\n          ne2;\n\n      if (obj instanceof LatLng) {\n        sw2 = obj;\n        ne2 = obj;\n      } else if (obj instanceof LatLngBounds) {\n        sw2 = obj._southWest;\n        ne2 = obj._northEast;\n\n        if (!sw2 || !ne2) {\n          return this;\n        }\n      } else {\n        return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;\n      }\n\n      if (!sw && !ne) {\n        this._southWest = new LatLng(sw2.lat, sw2.lng);\n        this._northEast = new LatLng(ne2.lat, ne2.lng);\n      } else {\n        sw.lat = Math.min(sw2.lat, sw.lat);\n        sw.lng = Math.min(sw2.lng, sw.lng);\n        ne.lat = Math.max(ne2.lat, ne.lat);\n        ne.lng = Math.max(ne2.lng, ne.lng);\n      }\n\n      return this;\n    },\n    // @method pad(bufferRatio: Number): LatLngBounds\n    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n    // Negative values will retract the bounds.\n    pad: function (bufferRatio) {\n      var sw = this._southWest,\n          ne = this._northEast,\n          heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\n          widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\n      return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\n    },\n    // @method getCenter(): LatLng\n    // Returns the center point of the bounds.\n    getCenter: function () {\n      return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);\n    },\n    // @method getSouthWest(): LatLng\n    // Returns the south-west point of the bounds.\n    getSouthWest: function () {\n      return this._southWest;\n    },\n    // @method getNorthEast(): LatLng\n    // Returns the north-east point of the bounds.\n    getNorthEast: function () {\n      return this._northEast;\n    },\n    // @method getNorthWest(): LatLng\n    // Returns the north-west point of the bounds.\n    getNorthWest: function () {\n      return new LatLng(this.getNorth(), this.getWest());\n    },\n    // @method getSouthEast(): LatLng\n    // Returns the south-east point of the bounds.\n    getSouthEast: function () {\n      return new LatLng(this.getSouth(), this.getEast());\n    },\n    // @method getWest(): Number\n    // Returns the west longitude of the bounds\n    getWest: function () {\n      return this._southWest.lng;\n    },\n    // @method getSouth(): Number\n    // Returns the south latitude of the bounds\n    getSouth: function () {\n      return this._southWest.lat;\n    },\n    // @method getEast(): Number\n    // Returns the east longitude of the bounds\n    getEast: function () {\n      return this._northEast.lng;\n    },\n    // @method getNorth(): Number\n    // Returns the north latitude of the bounds\n    getNorth: function () {\n      return this._northEast.lat;\n    },\n    // @method contains(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n    // @alternative\n    // @method contains (latlng: LatLng): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function (obj) {\n      // (LatLngBounds) or (LatLng) -> Boolean\n      if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {\n        obj = toLatLng(obj);\n      } else {\n        obj = toLatLngBounds(obj);\n      }\n\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2,\n          ne2;\n\n      if (obj instanceof LatLngBounds) {\n        sw2 = obj.getSouthWest();\n        ne2 = obj.getNorthEast();\n      } else {\n        sw2 = ne2 = obj;\n      }\n\n      return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;\n    },\n    // @method intersects(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.\n    intersects: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2 = bounds.getSouthWest(),\n          ne2 = bounds.getNorthEast(),\n          latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,\n          lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;\n      return latIntersects && lngIntersects;\n    },\n    // @method overlaps(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.\n    overlaps: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2 = bounds.getSouthWest(),\n          ne2 = bounds.getNorthEast(),\n          latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,\n          lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;\n      return latOverlaps && lngOverlaps;\n    },\n    // @method toBBoxString(): String\n    // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.\n    toBBoxString: function () {\n      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\n    },\n    // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean\n    // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function (bounds, maxMargin) {\n      if (!bounds) {\n        return false;\n      }\n\n      bounds = toLatLngBounds(bounds);\n      return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);\n    },\n    // @method isValid(): Boolean\n    // Returns `true` if the bounds are properly initialized.\n    isValid: function () {\n      return !!(this._southWest && this._northEast);\n    }\n  }; // TODO International date line?\n  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)\n  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.\n  // @alternative\n  // @factory L.latLngBounds(latlngs: LatLng[])\n  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).\n\n  function toLatLngBounds(a, b) {\n    if (a instanceof LatLngBounds) {\n      return a;\n    }\n\n    return new LatLngBounds(a, b);\n  }\n  /* @class LatLng\r\n   * @aka L.LatLng\r\n   *\r\n   * Represents a geographical point with a certain latitude and longitude.\r\n   *\r\n   * @example\r\n   *\r\n   * ```\r\n   * var latlng = L.latLng(50.5, 30.5);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```\r\n   * map.panTo([50, 30]);\r\n   * map.panTo({lon: 30, lat: 50});\r\n   * map.panTo({lat: 50, lng: 30});\r\n   * map.panTo(L.latLng(50, 30));\r\n   * ```\r\n   *\r\n   * Note that `LatLng` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n\n  function LatLng(lat, lng, alt) {\n    if (isNaN(lat) || isNaN(lng)) {\n      throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\n    } // @property lat: Number\n    // Latitude in degrees\n\n\n    this.lat = +lat; // @property lng: Number\n    // Longitude in degrees\n\n    this.lng = +lng; // @property alt: Number\n    // Altitude in meters (optional)\n\n    if (alt !== undefined) {\n      this.alt = +alt;\n    }\n  }\n\n  LatLng.prototype = {\n    // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean\n    // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function (obj, maxMargin) {\n      if (!obj) {\n        return false;\n      }\n\n      obj = toLatLng(obj);\n      var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));\n      return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point (for debugging purposes).\n    toString: function (precision) {\n      return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')';\n    },\n    // @method distanceTo(otherLatLng: LatLng): Number\n    // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).\n    distanceTo: function (other) {\n      return Earth.distance(this, toLatLng(other));\n    },\n    // @method wrap(): LatLng\n    // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.\n    wrap: function () {\n      return Earth.wrapLatLng(this);\n    },\n    // @method toBounds(sizeInMeters: Number): LatLngBounds\n    // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.\n    toBounds: function (sizeInMeters) {\n      var latAccuracy = 180 * sizeInMeters / 40075017,\n          lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);\n      return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);\n    },\n    clone: function () {\n      return new LatLng(this.lat, this.lng, this.alt);\n    }\n  }; // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng\n  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).\n  // @alternative\n  // @factory L.latLng(coords: Array): LatLng\n  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.\n  // @alternative\n  // @factory L.latLng(coords: Object): LatLng\n  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.\n\n  function toLatLng(a, b, c) {\n    if (a instanceof LatLng) {\n      return a;\n    }\n\n    if (isArray(a) && typeof a[0] !== 'object') {\n      if (a.length === 3) {\n        return new LatLng(a[0], a[1], a[2]);\n      }\n\n      if (a.length === 2) {\n        return new LatLng(a[0], a[1]);\n      }\n\n      return null;\n    }\n\n    if (a === undefined || a === null) {\n      return a;\n    }\n\n    if (typeof a === 'object' && 'lat' in a) {\n      return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);\n    }\n\n    if (b === undefined) {\n      return null;\n    }\n\n    return new LatLng(a, b, c);\n  }\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.Base\r\n   * Object that defines coordinate reference systems for projecting\r\n   * geographical points into pixel (screen) coordinates and back (and to\r\n   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n   * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).\r\n   *\r\n   * Leaflet defines the most usual CRSs by default. If you want to use a\r\n   * CRS not defined by default, take a look at the\r\n   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n   *\r\n   * Note that the CRS instances do not inherit from Leafet's `Class` object,\r\n   * and can't be instantiated. Also, new classes can't inherit from them,\r\n   * and methods can't be added to them with the `include` function.\r\n   */\n\n\n  var CRS = {\n    // @method latLngToPoint(latlng: LatLng, zoom: Number): Point\n    // Projects geographical coordinates into pixel coordinates for a given zoom.\n    latLngToPoint: function (latlng, zoom) {\n      var projectedPoint = this.projection.project(latlng),\n          scale = this.scale(zoom);\n      return this.transformation._transform(projectedPoint, scale);\n    },\n    // @method pointToLatLng(point: Point, zoom: Number): LatLng\n    // The inverse of `latLngToPoint`. Projects pixel coordinates on a given\n    // zoom into geographical coordinates.\n    pointToLatLng: function (point, zoom) {\n      var scale = this.scale(zoom),\n          untransformedPoint = this.transformation.untransform(point, scale);\n      return this.projection.unproject(untransformedPoint);\n    },\n    // @method project(latlng: LatLng): Point\n    // Projects geographical coordinates into coordinates in units accepted for\n    // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\n    project: function (latlng) {\n      return this.projection.project(latlng);\n    },\n    // @method unproject(point: Point): LatLng\n    // Given a projected coordinate returns the corresponding LatLng.\n    // The inverse of `project`.\n    unproject: function (point) {\n      return this.projection.unproject(point);\n    },\n    // @method scale(zoom: Number): Number\n    // Returns the scale used when transforming projected coordinates into\n    // pixel coordinates for a particular zoom. For example, it returns\n    // `256 * 2^zoom` for Mercator-based CRS.\n    scale: function (zoom) {\n      return 256 * Math.pow(2, zoom);\n    },\n    // @method zoom(scale: Number): Number\n    // Inverse of `scale()`, returns the zoom level corresponding to a scale\n    // factor of `scale`.\n    zoom: function (scale) {\n      return Math.log(scale / 256) / Math.LN2;\n    },\n    // @method getProjectedBounds(zoom: Number): Bounds\n    // Returns the projection's bounds scaled and transformed for the provided `zoom`.\n    getProjectedBounds: function (zoom) {\n      if (this.infinite) {\n        return null;\n      }\n\n      var b = this.projection.bounds,\n          s = this.scale(zoom),\n          min = this.transformation.transform(b.min, s),\n          max = this.transformation.transform(b.max, s);\n      return new Bounds(min, max);\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates.\n    // @property code: String\n    // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\n    //\n    // @property wrapLng: Number[]\n    // An array of two numbers defining whether the longitude (horizontal) coordinate\n    // axis wraps around a given range and how. Defaults to `[-180, 180]` in most\n    // geographical CRSs. If `undefined`, the longitude axis does not wrap around.\n    //\n    // @property wrapLat: Number[]\n    // Like `wrapLng`, but for the latitude (vertical) axis.\n    // wrapLng: [min, max],\n    // wrapLat: [min, max],\n    // @property infinite: Boolean\n    // If true, the coordinate space will be unbounded (infinite in both axes)\n    infinite: false,\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where lat and lng has been wrapped according to the\n    // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\n    wrapLatLng: function (latlng) {\n      var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\n          lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\n          alt = latlng.alt;\n      return new LatLng(lat, lng, alt);\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring\n    // that its center is within the CRS's bounds.\n    // Only accepts actual `L.LatLngBounds` instances, not arrays.\n    wrapLatLngBounds: function (bounds) {\n      var center = bounds.getCenter(),\n          newCenter = this.wrapLatLng(center),\n          latShift = center.lat - newCenter.lat,\n          lngShift = center.lng - newCenter.lng;\n\n      if (latShift === 0 && lngShift === 0) {\n        return bounds;\n      }\n\n      var sw = bounds.getSouthWest(),\n          ne = bounds.getNorthEast(),\n          newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),\n          newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\n      return new LatLngBounds(newSw, newNe);\n    }\n  };\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Earth\n   *\n   * Serves as the base for CRS that are global such that they cover the earth.\n   * Can only be used as the base for other CRS and cannot be used directly,\n   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns\n   * meters.\n   */\n\n  var Earth = extend({}, CRS, {\n    wrapLng: [-180, 180],\n    // Mean Earth Radius, as recommended for use by\n    // the International Union of Geodesy and Geophysics,\n    // see http://rosettacode.org/wiki/Haversine_formula\n    R: 6371000,\n    // distance between two geographical points using spherical law of cosines approximation\n    distance: function (latlng1, latlng2) {\n      var rad = Math.PI / 180,\n          lat1 = latlng1.lat * rad,\n          lat2 = latlng2.lat * rad,\n          sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),\n          sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),\n          a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n          c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      return this.R * c;\n    }\n  });\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.SphericalMercator\r\n   *\r\n   * Spherical Mercator projection — the most common projection for online maps,\r\n   * used by almost all free and commercial tile providers. Assumes that Earth is\r\n   * a sphere. Used by the `EPSG:3857` CRS.\r\n   */\n\n  var earthRadius = 6378137;\n  var SphericalMercator = {\n    R: earthRadius,\n    MAX_LATITUDE: 85.0511287798,\n    project: function (latlng) {\n      var d = Math.PI / 180,\n          max = this.MAX_LATITUDE,\n          lat = Math.max(Math.min(max, latlng.lat), -max),\n          sin = Math.sin(lat * d);\n      return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);\n    },\n    unproject: function (point) {\n      var d = 180 / Math.PI;\n      return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);\n    },\n    bounds: function () {\n      var d = earthRadius * Math.PI;\n      return new Bounds([-d, -d], [d, d]);\n    }()\n  };\n  /*\r\n   * @class Transformation\r\n   * @aka L.Transformation\r\n   *\r\n   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n   * the reverse. Used by Leaflet in its projections code.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var transformation = L.transformation(2, 5, -1, 10),\r\n   * \tp = L.point(1, 2),\r\n   * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n   * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n   * ```\r\n   */\n  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\n  // Creates a `Transformation` object with the given coefficients.\n\n  function Transformation(a, b, c, d) {\n    if (isArray(a)) {\n      // use array properties\n      this._a = a[0];\n      this._b = a[1];\n      this._c = a[2];\n      this._d = a[3];\n      return;\n    }\n\n    this._a = a;\n    this._b = b;\n    this._c = c;\n    this._d = d;\n  }\n\n  Transformation.prototype = {\n    // @method transform(point: Point, scale?: Number): Point\n    // Returns a transformed point, optionally multiplied by the given scale.\n    // Only accepts actual `L.Point` instances, not arrays.\n    transform: function (point, scale) {\n      // (Point, Number) -> Point\n      return this._transform(point.clone(), scale);\n    },\n    // destructive transform (faster)\n    _transform: function (point, scale) {\n      scale = scale || 1;\n      point.x = scale * (this._a * point.x + this._b);\n      point.y = scale * (this._c * point.y + this._d);\n      return point;\n    },\n    // @method untransform(point: Point, scale?: Number): Point\n    // Returns the reverse transformation of the given point, optionally divided\n    // by the given scale. Only accepts actual `L.Point` instances, not arrays.\n    untransform: function (point, scale) {\n      scale = scale || 1;\n      return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);\n    }\n  }; // factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n  // Instantiates a Transformation object with the given coefficients.\n  // @alternative\n  // @factory L.transformation(coefficients: Array): Transformation\n  // Expects an coefficients array of the form\n  // `[a: Number, b: Number, c: Number, d: Number]`.\n\n  function toTransformation(a, b, c, d) {\n    return new Transformation(a, b, c, d);\n  }\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3857\r\n   *\r\n   * The most common CRS for online maps, used by almost all free and commercial\r\n   * tile providers. Uses Spherical Mercator projection. Set in by default in\r\n   * Map's `crs` option.\r\n   */\n\n\n  var EPSG3857 = extend({}, Earth, {\n    code: 'EPSG:3857',\n    projection: SphericalMercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * SphericalMercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n  var EPSG900913 = extend({}, EPSG3857, {\n    code: 'EPSG:900913'\n  }); // @namespace SVG; @section\n  // There are several static functions which can be called without instantiating L.SVG:\n  // @function create(name: String): SVGElement\n  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),\n  // corresponding to the class name passed. For example, using 'line' will return\n  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).\n\n  function svgCreate(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  } // @function pointsToPath(rings: Point[], closed: Boolean): String\n  // Generates a SVG path string for multiple rings, with each ring turning\n  // into \"M..L..L..\" instructions\n\n\n  function pointsToPath(rings, closed) {\n    var str = '',\n        i,\n        j,\n        len,\n        len2,\n        points,\n        p;\n\n    for (i = 0, len = rings.length; i < len; i++) {\n      points = rings[i];\n\n      for (j = 0, len2 = points.length; j < len2; j++) {\n        p = points[j];\n        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n      } // closes the ring for polygons; \"x\" is VML syntax\n\n\n      str += closed ? svg ? 'z' : 'x' : '';\n    } // SVG complains about empty path strings\n\n\n    return str || 'M0 0';\n  }\n  /*\r\n   * @namespace Browser\r\n   * @aka L.Browser\r\n   *\r\n   * A namespace with static properties for browser/feature detection used by Leaflet internally.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * if (L.Browser.ielt9) {\r\n   *   alert('Upgrade your browser, dude!');\r\n   * }\r\n   * ```\r\n   */\n\n\n  var style$1 = document.documentElement.style; // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).\n\n  var ie = ('ActiveXObject' in window); // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.\n\n  var ielt9 = ie && !document.addEventListener; // @property edge: Boolean; `true` for the Edge web browser.\n\n  var edge = 'msLaunchUri' in navigator && !('documentMode' in document); // @property webkit: Boolean;\n  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).\n\n  var webkit = userAgentContains('webkit'); // @property android: Boolean\n  // `true` for any browser running on an Android platform.\n\n  var android = userAgentContains('android'); // @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.\n\n  var android23 = userAgentContains('android 2') || userAgentContains('android 3');\n  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */\n\n  var webkitVer = parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit\n  // @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)\n\n  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window); // @property opera: Boolean; `true` for the Opera browser\n\n  var opera = !!window.opera; // @property chrome: Boolean; `true` for the Chrome browser.\n\n  var chrome = userAgentContains('chrome'); // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.\n\n  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie; // @property safari: Boolean; `true` for the Safari browser.\n\n  var safari = !chrome && userAgentContains('safari');\n  var phantom = userAgentContains('phantom'); // @property opera12: Boolean\n  // `true` for the Opera browser supporting CSS transforms (version 12 or later).\n\n  var opera12 = ('OTransition' in style$1); // @property win: Boolean; `true` when the browser is running in a Windows platform\n\n  var win = navigator.platform.indexOf('Win') === 0; // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.\n\n  var ie3d = ie && 'transition' in style$1; // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.\n\n  var webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23; // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.\n\n  var gecko3d = ('MozPerspective' in style$1); // @property any3d: Boolean\n  // `true` for all browsers supporting CSS transforms.\n\n  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom; // @property mobile: Boolean; `true` for all browsers running in a mobile device.\n\n  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile'); // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.\n\n  var mobileWebkit = mobile && webkit; // @property mobileWebkit3d: Boolean\n  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.\n\n  var mobileWebkit3d = mobile && webkit3d; // @property msPointer: Boolean\n  // `true` for browsers implementing the Microsoft touch events model (notably IE10).\n\n  var msPointer = !window.PointerEvent && window.MSPointerEvent; // @property pointer: Boolean\n  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).\n\n  var pointer = !webkit && !!(window.PointerEvent || msPointer); // @property touch: Boolean\n  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).\n  // This does not necessarily mean that the browser is running in a computer with\n  // a touchscreen, it only means that the browser is capable of understanding\n  // touch events.\n\n  var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch); // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.\n\n  var mobileOpera = mobile && opera; // @property mobileGecko: Boolean\n  // `true` for gecko-based browsers running in a mobile device.\n\n  var mobileGecko = mobile && gecko; // @property retina: Boolean\n  // `true` for browsers on a high-resolution \"retina\" screen or on any screen when browser's display zoom is more than 100%.\n\n  var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1; // @property passiveEvents: Boolean\n  // `true` for browsers that support passive events.\n\n  var passiveEvents = function () {\n    var supportsPassiveOption = false;\n\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function () {\n          supportsPassiveOption = true;\n        }\n      });\n      window.addEventListener('testPassiveEventSupport', falseFn, opts);\n      window.removeEventListener('testPassiveEventSupport', falseFn, opts);\n    } catch (e) {// Errors can safely be ignored since this is only a browser support test.\n    }\n\n    return supportsPassiveOption;\n  }; // @property canvas: Boolean\n  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n\n\n  var canvas = function () {\n    return !!document.createElement('canvas').getContext;\n  }(); // @property svg: Boolean\n  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).\n\n\n  var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect); // @property vml: Boolean\n  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).\n\n  var vml = !svg && function () {\n    try {\n      var div = document.createElement('div');\n      div.innerHTML = '<v:shape adj=\"1\"/>';\n      var shape = div.firstChild;\n      shape.style.behavior = 'url(#default#VML)';\n      return shape && typeof shape.adj === 'object';\n    } catch (e) {\n      return false;\n    }\n  }();\n\n  function userAgentContains(str) {\n    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;\n  }\n\n  var Browser = (Object.freeze || Object)({\n    ie: ie,\n    ielt9: ielt9,\n    edge: edge,\n    webkit: webkit,\n    android: android,\n    android23: android23,\n    androidStock: androidStock,\n    opera: opera,\n    chrome: chrome,\n    gecko: gecko,\n    safari: safari,\n    phantom: phantom,\n    opera12: opera12,\n    win: win,\n    ie3d: ie3d,\n    webkit3d: webkit3d,\n    gecko3d: gecko3d,\n    any3d: any3d,\n    mobile: mobile,\n    mobileWebkit: mobileWebkit,\n    mobileWebkit3d: mobileWebkit3d,\n    msPointer: msPointer,\n    pointer: pointer,\n    touch: touch,\n    mobileOpera: mobileOpera,\n    mobileGecko: mobileGecko,\n    retina: retina,\n    passiveEvents: passiveEvents,\n    canvas: canvas,\n    svg: svg,\n    vml: vml\n  });\n  /*\n   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n   */\n\n  var POINTER_DOWN = msPointer ? 'MSPointerDown' : 'pointerdown';\n  var POINTER_MOVE = msPointer ? 'MSPointerMove' : 'pointermove';\n  var POINTER_UP = msPointer ? 'MSPointerUp' : 'pointerup';\n  var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';\n  var TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'];\n  var _pointers = {};\n  var _pointerDocListener = false; // DomEvent.DoubleTap needs to know about this\n\n  var _pointersCount = 0; // Provides a touch events wrapper for (ms)pointer events.\n  // ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n  function addPointerListener(obj, type, handler, id) {\n    if (type === 'touchstart') {\n      _addPointerStart(obj, handler, id);\n    } else if (type === 'touchmove') {\n      _addPointerMove(obj, handler, id);\n    } else if (type === 'touchend') {\n      _addPointerEnd(obj, handler, id);\n    }\n\n    return this;\n  }\n\n  function removePointerListener(obj, type, id) {\n    var handler = obj['_leaflet_' + type + id];\n\n    if (type === 'touchstart') {\n      obj.removeEventListener(POINTER_DOWN, handler, false);\n    } else if (type === 'touchmove') {\n      obj.removeEventListener(POINTER_MOVE, handler, false);\n    } else if (type === 'touchend') {\n      obj.removeEventListener(POINTER_UP, handler, false);\n      obj.removeEventListener(POINTER_CANCEL, handler, false);\n    }\n\n    return this;\n  }\n\n  function _addPointerStart(obj, handler, id) {\n    var onDown = bind(function (e) {\n      if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {\n        // In IE11, some touch events needs to fire for form controls, or\n        // the controls will stop working. We keep a whitelist of tag names that\n        // need these events. For other target tags, we prevent default on the event.\n        if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {\n          preventDefault(e);\n        } else {\n          return;\n        }\n      }\n\n      _handlePointer(e, handler);\n    });\n    obj['_leaflet_touchstart' + id] = onDown;\n    obj.addEventListener(POINTER_DOWN, onDown, false); // need to keep track of what pointers and how many are active to provide e.touches emulation\n\n    if (!_pointerDocListener) {\n      // we listen documentElement as any drags that end by moving the touch off the screen get fired there\n      document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);\n      document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);\n      document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);\n      document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);\n      _pointerDocListener = true;\n    }\n  }\n\n  function _globalPointerDown(e) {\n    _pointers[e.pointerId] = e;\n    _pointersCount++;\n  }\n\n  function _globalPointerMove(e) {\n    if (_pointers[e.pointerId]) {\n      _pointers[e.pointerId] = e;\n    }\n  }\n\n  function _globalPointerUp(e) {\n    delete _pointers[e.pointerId];\n    _pointersCount--;\n  }\n\n  function _handlePointer(e, handler) {\n    e.touches = [];\n\n    for (var i in _pointers) {\n      e.touches.push(_pointers[i]);\n    }\n\n    e.changedTouches = [e];\n    handler(e);\n  }\n\n  function _addPointerMove(obj, handler, id) {\n    var onMove = function (e) {\n      // don't fire touch moves when mouse isn't down\n      if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) {\n        return;\n      }\n\n      _handlePointer(e, handler);\n    };\n\n    obj['_leaflet_touchmove' + id] = onMove;\n    obj.addEventListener(POINTER_MOVE, onMove, false);\n  }\n\n  function _addPointerEnd(obj, handler, id) {\n    var onUp = function (e) {\n      _handlePointer(e, handler);\n    };\n\n    obj['_leaflet_touchend' + id] = onUp;\n    obj.addEventListener(POINTER_UP, onUp, false);\n    obj.addEventListener(POINTER_CANCEL, onUp, false);\n  }\n  /*\r\n   * Extends the event handling code with double tap support for mobile browsers.\r\n   */\n\n\n  var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';\n\n  var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';\n\n  var _pre = '_leaflet_'; // inspired by Zepto touch code by Thomas Fuchs\n\n  function addDoubleTapListener(obj, handler, id) {\n    var last,\n        touch$$1,\n        doubleTap = false,\n        delay = 250;\n\n    function onTouchStart(e) {\n      var count;\n\n      if (pointer) {\n        if (!edge || e.pointerType === 'mouse') {\n          return;\n        }\n\n        count = _pointersCount;\n      } else {\n        count = e.touches.length;\n      }\n\n      if (count > 1) {\n        return;\n      }\n\n      var now = Date.now(),\n          delta = now - (last || now);\n      touch$$1 = e.touches ? e.touches[0] : e;\n      doubleTap = delta > 0 && delta <= delay;\n      last = now;\n    }\n\n    function onTouchEnd(e) {\n      if (doubleTap && !touch$$1.cancelBubble) {\n        if (pointer) {\n          if (!edge || e.pointerType === 'mouse') {\n            return;\n          } // work around .type being readonly with MSPointer* events\n\n\n          var newTouch = {},\n              prop,\n              i;\n\n          for (i in touch$$1) {\n            prop = touch$$1[i];\n            newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;\n          }\n\n          touch$$1 = newTouch;\n        }\n\n        touch$$1.type = 'dblclick';\n        touch$$1.button = 0;\n        handler(touch$$1);\n        last = null;\n      }\n    }\n\n    obj[_pre + _touchstart + id] = onTouchStart;\n    obj[_pre + _touchend + id] = onTouchEnd;\n    obj[_pre + 'dblclick' + id] = handler;\n    obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? {\n      passive: false\n    } : false);\n    obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? {\n      passive: false\n    } : false); // On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),\n    // the browser doesn't fire touchend/pointerup events but does fire\n    // native dblclicks. See #4127.\n    // Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.\n\n    obj.addEventListener('dblclick', handler, false);\n    return this;\n  }\n\n  function removeDoubleTapListener(obj, id) {\n    var touchstart = obj[_pre + _touchstart + id],\n        touchend = obj[_pre + _touchend + id],\n        dblclick = obj[_pre + 'dblclick' + id];\n    obj.removeEventListener(_touchstart, touchstart, passiveEvents ? {\n      passive: false\n    } : false);\n    obj.removeEventListener(_touchend, touchend, passiveEvents ? {\n      passive: false\n    } : false);\n\n    if (!edge) {\n      obj.removeEventListener('dblclick', dblclick, false);\n    }\n\n    return this;\n  }\n  /*\r\n   * @namespace DomUtil\r\n   *\r\n   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)\r\n   * tree, used by Leaflet internally.\r\n   *\r\n   * Most functions expecting or returning a `HTMLElement` also work for\r\n   * SVG elements. The only difference is that classes refer to CSS classes\r\n   * in HTML and SVG classes in SVG.\r\n   */\n  // @property TRANSFORM: String\n  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).\n\n\n  var TRANSFORM = testProp(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']); // webkitTransition comes first because some browser versions that drop vendor prefix don't do\n  // the same for the transitionend event, in particular the Android 4.1 stock browser\n  // @property TRANSITION: String\n  // Vendor-prefixed transition style name.\n\n  var TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']); // @property TRANSITION_END: String\n  // Vendor-prefixed transitionend event name.\n\n  var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend'; // @function get(id: String|HTMLElement): HTMLElement\n  // Returns an element given its DOM id, or returns the element itself\n  // if it was passed directly.\n\n  function get(id) {\n    return typeof id === 'string' ? document.getElementById(id) : id;\n  } // @function getStyle(el: HTMLElement, styleAttrib: String): String\n  // Returns the value for a certain style attribute on an element,\n  // including computed values or values set through CSS.\n\n\n  function getStyle(el, style) {\n    var value = el.style[style] || el.currentStyle && el.currentStyle[style];\n\n    if ((!value || value === 'auto') && document.defaultView) {\n      var css = document.defaultView.getComputedStyle(el, null);\n      value = css ? css[style] : null;\n    }\n\n    return value === 'auto' ? null : value;\n  } // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement\n  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.\n\n\n  function create$1(tagName, className, container) {\n    var el = document.createElement(tagName);\n    el.className = className || '';\n\n    if (container) {\n      container.appendChild(el);\n    }\n\n    return el;\n  } // @function remove(el: HTMLElement)\n  // Removes `el` from its parent element\n\n\n  function remove(el) {\n    var parent = el.parentNode;\n\n    if (parent) {\n      parent.removeChild(el);\n    }\n  } // @function empty(el: HTMLElement)\n  // Removes all of `el`'s children elements from `el`\n\n\n  function empty(el) {\n    while (el.firstChild) {\n      el.removeChild(el.firstChild);\n    }\n  } // @function toFront(el: HTMLElement)\n  // Makes `el` the last child of its parent, so it renders in front of the other children.\n\n\n  function toFront(el) {\n    var parent = el.parentNode;\n\n    if (parent && parent.lastChild !== el) {\n      parent.appendChild(el);\n    }\n  } // @function toBack(el: HTMLElement)\n  // Makes `el` the first child of its parent, so it renders behind the other children.\n\n\n  function toBack(el) {\n    var parent = el.parentNode;\n\n    if (parent && parent.firstChild !== el) {\n      parent.insertBefore(el, parent.firstChild);\n    }\n  } // @function hasClass(el: HTMLElement, name: String): Boolean\n  // Returns `true` if the element's class attribute contains `name`.\n\n\n  function hasClass(el, name) {\n    if (el.classList !== undefined) {\n      return el.classList.contains(name);\n    }\n\n    var className = getClass(el);\n    return className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\n  } // @function addClass(el: HTMLElement, name: String)\n  // Adds `name` to the element's class attribute.\n\n\n  function addClass(el, name) {\n    if (el.classList !== undefined) {\n      var classes = splitWords(name);\n\n      for (var i = 0, len = classes.length; i < len; i++) {\n        el.classList.add(classes[i]);\n      }\n    } else if (!hasClass(el, name)) {\n      var className = getClass(el);\n      setClass(el, (className ? className + ' ' : '') + name);\n    }\n  } // @function removeClass(el: HTMLElement, name: String)\n  // Removes `name` from the element's class attribute.\n\n\n  function removeClass(el, name) {\n    if (el.classList !== undefined) {\n      el.classList.remove(name);\n    } else {\n      setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\n    }\n  } // @function setClass(el: HTMLElement, name: String)\n  // Sets the element's class.\n\n\n  function setClass(el, name) {\n    if (el.className.baseVal === undefined) {\n      el.className = name;\n    } else {\n      // in case of SVG element\n      el.className.baseVal = name;\n    }\n  } // @function getClass(el: HTMLElement): String\n  // Returns the element's class.\n\n\n  function getClass(el) {\n    // Check if the element is an SVGElementInstance and use the correspondingElement instead\n    // (Required for linked SVG elements in IE11.)\n    if (el.correspondingElement) {\n      el = el.correspondingElement;\n    }\n\n    return el.className.baseVal === undefined ? el.className : el.className.baseVal;\n  } // @function setOpacity(el: HTMLElement, opacity: Number)\n  // Set the opacity of an element (including old IE support).\n  // `opacity` must be a number from `0` to `1`.\n\n\n  function setOpacity(el, value) {\n    if ('opacity' in el.style) {\n      el.style.opacity = value;\n    } else if ('filter' in el.style) {\n      _setOpacityIE(el, value);\n    }\n  }\n\n  function _setOpacityIE(el, value) {\n    var filter = false,\n        filterName = 'DXImageTransform.Microsoft.Alpha'; // filters collection throws an error if we try to retrieve a filter that doesn't exist\n\n    try {\n      filter = el.filters.item(filterName);\n    } catch (e) {\n      // don't set opacity to 1 if we haven't already set an opacity,\n      // it isn't needed and breaks transparent pngs.\n      if (value === 1) {\n        return;\n      }\n    }\n\n    value = Math.round(value * 100);\n\n    if (filter) {\n      filter.Enabled = value !== 100;\n      filter.Opacity = value;\n    } else {\n      el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\n    }\n  } // @function testProp(props: String[]): String|false\n  // Goes through the array of style names and returns the first name\n  // that is a valid style name for an element. If no such name is found,\n  // it returns false. Useful for vendor-prefixed styles like `transform`.\n\n\n  function testProp(props) {\n    var style = document.documentElement.style;\n\n    for (var i = 0; i < props.length; i++) {\n      if (props[i] in style) {\n        return props[i];\n      }\n    }\n\n    return false;\n  } // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)\n  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\n  // and optionally scaled by `scale`. Does not have an effect if the\n  // browser doesn't support 3D CSS transforms.\n\n\n  function setTransform(el, offset, scale) {\n    var pos = offset || new Point(0, 0);\n    el.style[TRANSFORM] = (ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');\n  } // @function setPosition(el: HTMLElement, position: Point)\n  // Sets the position of `el` to coordinates specified by `position`,\n  // using CSS translate or top/left positioning depending on the browser\n  // (used by Leaflet internally to position its layers).\n\n\n  function setPosition(el, point) {\n    /*eslint-disable */\n    el._leaflet_pos = point;\n    /* eslint-enable */\n\n    if (any3d) {\n      setTransform(el, point);\n    } else {\n      el.style.left = point.x + 'px';\n      el.style.top = point.y + 'px';\n    }\n  } // @function getPosition(el: HTMLElement): Point\n  // Returns the coordinates of an element previously positioned with setPosition.\n\n\n  function getPosition(el) {\n    // this method is only used for elements previously positioned using setPosition,\n    // so it's safe to cache the position for performance\n    return el._leaflet_pos || new Point(0, 0);\n  } // @function disableTextSelection()\n  // Prevents the user from generating `selectstart` DOM events, usually generated\n  // when the user drags the mouse through a page with text. Used internally\n  // by Leaflet to override the behaviour of any click-and-drag interaction on\n  // the map. Affects drag interactions on the whole document.\n  // @function enableTextSelection()\n  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).\n\n\n  var disableTextSelection;\n  var enableTextSelection;\n\n  var _userSelect;\n\n  if ('onselectstart' in document) {\n    disableTextSelection = function () {\n      on(window, 'selectstart', preventDefault);\n    };\n\n    enableTextSelection = function () {\n      off(window, 'selectstart', preventDefault);\n    };\n  } else {\n    var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\n\n    disableTextSelection = function () {\n      if (userSelectProperty) {\n        var style = document.documentElement.style;\n        _userSelect = style[userSelectProperty];\n        style[userSelectProperty] = 'none';\n      }\n    };\n\n    enableTextSelection = function () {\n      if (userSelectProperty) {\n        document.documentElement.style[userSelectProperty] = _userSelect;\n        _userSelect = undefined;\n      }\n    };\n  } // @function disableImageDrag()\n  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but\n  // for `dragstart` DOM events, usually generated when the user drags an image.\n\n\n  function disableImageDrag() {\n    on(window, 'dragstart', preventDefault);\n  } // @function enableImageDrag()\n  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).\n\n\n  function enableImageDrag() {\n    off(window, 'dragstart', preventDefault);\n  }\n\n  var _outlineElement;\n\n  var _outlineStyle; // @function preventOutline(el: HTMLElement)\n  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)\n  // of the element `el` invisible. Used internally by Leaflet to prevent\n  // focusable elements from displaying an outline when the user performs a\n  // drag interaction on them.\n\n\n  function preventOutline(element) {\n    while (element.tabIndex === -1) {\n      element = element.parentNode;\n    }\n\n    if (!element.style) {\n      return;\n    }\n\n    restoreOutline();\n    _outlineElement = element;\n    _outlineStyle = element.style.outline;\n    element.style.outline = 'none';\n    on(window, 'keydown', restoreOutline);\n  } // @function restoreOutline()\n  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().\n\n\n  function restoreOutline() {\n    if (!_outlineElement) {\n      return;\n    }\n\n    _outlineElement.style.outline = _outlineStyle;\n    _outlineElement = undefined;\n    _outlineStyle = undefined;\n    off(window, 'keydown', restoreOutline);\n  } // @function getSizedParentNode(el: HTMLElement): HTMLElement\n  // Finds the closest parent node which size (width and height) is not null.\n\n\n  function getSizedParentNode(element) {\n    do {\n      element = element.parentNode;\n    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);\n\n    return element;\n  } // @function getScale(el: HTMLElement): Object\n  // Computes the CSS scale currently applied on the element.\n  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,\n  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\n\n\n  function getScale(element) {\n    var rect = element.getBoundingClientRect(); // Read-only in old browsers.\n\n    return {\n      x: rect.width / element.offsetWidth || 1,\n      y: rect.height / element.offsetHeight || 1,\n      boundingClientRect: rect\n    };\n  }\n\n  var DomUtil = (Object.freeze || Object)({\n    TRANSFORM: TRANSFORM,\n    TRANSITION: TRANSITION,\n    TRANSITION_END: TRANSITION_END,\n    get: get,\n    getStyle: getStyle,\n    create: create$1,\n    remove: remove,\n    empty: empty,\n    toFront: toFront,\n    toBack: toBack,\n    hasClass: hasClass,\n    addClass: addClass,\n    removeClass: removeClass,\n    setClass: setClass,\n    getClass: getClass,\n    setOpacity: setOpacity,\n    testProp: testProp,\n    setTransform: setTransform,\n    setPosition: setPosition,\n    getPosition: getPosition,\n    disableTextSelection: disableTextSelection,\n    enableTextSelection: enableTextSelection,\n    disableImageDrag: disableImageDrag,\n    enableImageDrag: enableImageDrag,\n    preventOutline: preventOutline,\n    restoreOutline: restoreOutline,\n    getSizedParentNode: getSizedParentNode,\n    getScale: getScale\n  });\n  /*\r\n   * @namespace DomEvent\r\n   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.\r\n   */\n  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\n  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Adds a listener function (`fn`) to a particular DOM event type of the\n  // element `el`. You can optionally specify the context of the listener\n  // (object the `this` keyword will point to). You can also pass several\n  // space-separated types (e.g. `'click dblclick'`).\n  // @alternative\n  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n\n  function on(obj, types, fn, context) {\n    if (typeof types === 'object') {\n      for (var type in types) {\n        addOne(obj, type, types[type], fn);\n      }\n    } else {\n      types = splitWords(types);\n\n      for (var i = 0, len = types.length; i < len; i++) {\n        addOne(obj, types[i], fn, context);\n      }\n    }\n\n    return this;\n  }\n\n  var eventsKey = '_leaflet_events'; // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Removes a previously added listener function.\n  // Note that if you passed a custom context to on, you must pass the same\n  // context to `off` in order to remove the listener.\n  // @alternative\n  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n\n  function off(obj, types, fn, context) {\n    if (typeof types === 'object') {\n      for (var type in types) {\n        removeOne(obj, type, types[type], fn);\n      }\n    } else if (types) {\n      types = splitWords(types);\n\n      for (var i = 0, len = types.length; i < len; i++) {\n        removeOne(obj, types[i], fn, context);\n      }\n    } else {\n      for (var j in obj[eventsKey]) {\n        removeOne(obj, j, obj[eventsKey][j]);\n      }\n\n      delete obj[eventsKey];\n    }\n\n    return this;\n  }\n\n  function addOne(obj, type, fn, context) {\n    var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');\n\n    if (obj[eventsKey] && obj[eventsKey][id]) {\n      return this;\n    }\n\n    var handler = function (e) {\n      return fn.call(context || obj, e || window.event);\n    };\n\n    var originalHandler = handler;\n\n    if (pointer && type.indexOf('touch') === 0) {\n      // Needs DomEvent.Pointer.js\n      addPointerListener(obj, type, handler, id);\n    } else if (touch && type === 'dblclick' && addDoubleTapListener && !(pointer && chrome)) {\n      // Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener\n      // See #5180\n      addDoubleTapListener(obj, handler, id);\n    } else if ('addEventListener' in obj) {\n      if (type === 'mousewheel') {\n        obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, passiveEvents ? {\n          passive: false\n        } : false);\n      } else if (type === 'mouseenter' || type === 'mouseleave') {\n        handler = function (e) {\n          e = e || window.event;\n\n          if (isExternalTarget(obj, e)) {\n            originalHandler(e);\n          }\n        };\n\n        obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);\n      } else {\n        if (type === 'click' && android) {\n          handler = function (e) {\n            filterClick(e, originalHandler);\n          };\n        }\n\n        obj.addEventListener(type, handler, false);\n      }\n    } else if ('attachEvent' in obj) {\n      obj.attachEvent('on' + type, handler);\n    }\n\n    obj[eventsKey] = obj[eventsKey] || {};\n    obj[eventsKey][id] = handler;\n  }\n\n  function removeOne(obj, type, fn, context) {\n    var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),\n        handler = obj[eventsKey] && obj[eventsKey][id];\n\n    if (!handler) {\n      return this;\n    }\n\n    if (pointer && type.indexOf('touch') === 0) {\n      removePointerListener(obj, type, id);\n    } else if (touch && type === 'dblclick' && removeDoubleTapListener && !(pointer && chrome)) {\n      removeDoubleTapListener(obj, id);\n    } else if ('removeEventListener' in obj) {\n      if (type === 'mousewheel') {\n        obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, passiveEvents ? {\n          passive: false\n        } : false);\n      } else {\n        obj.removeEventListener(type === 'mouseenter' ? 'mouseover' : type === 'mouseleave' ? 'mouseout' : type, handler, false);\n      }\n    } else if ('detachEvent' in obj) {\n      obj.detachEvent('on' + type, handler);\n    }\n\n    obj[eventsKey][id] = null;\n  } // @function stopPropagation(ev: DOMEvent): this\n  // Stop the given event from propagation to parent elements. Used inside the listener functions:\n  // ```js\n  // L.DomEvent.on(div, 'click', function (ev) {\n  // \tL.DomEvent.stopPropagation(ev);\n  // });\n  // ```\n\n\n  function stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else if (e.originalEvent) {\n      // In case of Leaflet event.\n      e.originalEvent._stopped = true;\n    } else {\n      e.cancelBubble = true;\n    }\n\n    skipped(e);\n    return this;\n  } // @function disableScrollPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).\n\n\n  function disableScrollPropagation(el) {\n    addOne(el, 'mousewheel', stopPropagation);\n    return this;\n  } // @function disableClickPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,\n  // `'mousedown'` and `'touchstart'` events (plus browser variants).\n\n\n  function disableClickPropagation(el) {\n    on(el, 'mousedown touchstart dblclick', stopPropagation);\n    addOne(el, 'click', fakeStop);\n    return this;\n  } // @function preventDefault(ev: DOMEvent): this\n  // Prevents the default action of the DOM Event `ev` from happening (such as\n  // following a link in the href of the a element, or doing a POST request\n  // with page reload when a `<form>` is submitted).\n  // Use it inside listener functions.\n\n\n  function preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n    } else {\n      e.returnValue = false;\n    }\n\n    return this;\n  } // @function stop(ev: DOMEvent): this\n  // Does `stopPropagation` and `preventDefault` at the same time.\n\n\n  function stop(e) {\n    preventDefault(e);\n    stopPropagation(e);\n    return this;\n  } // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point\n  // Gets normalized mouse position from a DOM event relative to the\n  // `container` (border excluded) or to the whole page if not specified.\n\n\n  function getMousePosition(e, container) {\n    if (!container) {\n      return new Point(e.clientX, e.clientY);\n    }\n\n    var scale = getScale(container),\n        offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)\n\n    return new Point( // offset.left/top values are in page scale (like clientX/Y),\n    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).\n    (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);\n  } // Chrome on Win scrolls double the pixels as in other platforms (see #4538),\n  // and Firefox scrolls device pixels, not CSS pixels\n\n\n  var wheelPxFactor = win && chrome ? 2 * window.devicePixelRatio : gecko ? window.devicePixelRatio : 1; // @function getWheelDelta(ev: DOMEvent): Number\n  // Gets normalized wheel delta from a mousewheel DOM event, in vertical\n  // pixels scrolled (negative if scrolling down).\n  // Events from pointing devices without precise scrolling are mapped to\n  // a best guess of 60 pixels.\n\n  function getWheelDelta(e) {\n    return edge ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta\n    e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : // Pixels\n    e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : // Lines\n    e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : // Pages\n    e.deltaX || e.deltaZ ? 0 : // Skip horizontal/depth wheel events\n    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels\n    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : // Legacy Moz lines\n    e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages\n    0;\n  }\n\n  var skipEvents = {};\n\n  function fakeStop(e) {\n    // fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)\n    skipEvents[e.type] = true;\n  }\n\n  function skipped(e) {\n    var events = skipEvents[e.type]; // reset when checking, as it's only used in map container and propagates outside of the map\n\n    skipEvents[e.type] = false;\n    return events;\n  } // check if element really left/entered the event target (for mouseenter/mouseleave)\n\n\n  function isExternalTarget(el, e) {\n    var related = e.relatedTarget;\n\n    if (!related) {\n      return true;\n    }\n\n    try {\n      while (related && related !== el) {\n        related = related.parentNode;\n      }\n    } catch (err) {\n      return false;\n    }\n\n    return related !== el;\n  }\n\n  var lastClick; // this is a horrible workaround for a bug in Android where a single touch triggers two click events\n\n  function filterClick(e, handler) {\n    var timeStamp = e.timeStamp || e.originalEvent && e.originalEvent.timeStamp,\n        elapsed = lastClick && timeStamp - lastClick; // are they closer together than 500ms yet more than 100ms?\n    // Android typically triggers them ~300ms apart while multiple listeners\n    // on the same event should be triggered far faster;\n    // or check if click is simulated on the element, and if it is, reject any non-simulated events\n\n    if (elapsed && elapsed > 100 && elapsed < 500 || e.target._simulatedClick && !e._simulated) {\n      stop(e);\n      return;\n    }\n\n    lastClick = timeStamp;\n    handler(e);\n  }\n\n  var DomEvent = (Object.freeze || Object)({\n    on: on,\n    off: off,\n    stopPropagation: stopPropagation,\n    disableScrollPropagation: disableScrollPropagation,\n    disableClickPropagation: disableClickPropagation,\n    preventDefault: preventDefault,\n    stop: stop,\n    getMousePosition: getMousePosition,\n    getWheelDelta: getWheelDelta,\n    fakeStop: fakeStop,\n    skipped: skipped,\n    isExternalTarget: isExternalTarget,\n    addListener: on,\n    removeListener: off\n  });\n  /*\n   * @class PosAnimation\n   * @aka L.PosAnimation\n   * @inherits Evented\n   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.\n   *\n   * @example\n   * ```js\n   * var fx = new L.PosAnimation();\n   * fx.run(el, [300, 500], 0.5);\n   * ```\n   *\n   * @constructor L.PosAnimation()\n   * Creates a `PosAnimation` object.\n   *\n   */\n\n  var PosAnimation = Evented.extend({\n    // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)\n    // Run an animation of a given element to a new position, optionally setting\n    // duration in seconds (`0.25` by default) and easing linearity factor (3rd\n    // argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),\n    // `0.5` by default).\n    run: function (el, newPos, duration, easeLinearity) {\n      this.stop();\n      this._el = el;\n      this._inProgress = true;\n      this._duration = duration || 0.25;\n      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n      this._startPos = getPosition(el);\n      this._offset = newPos.subtract(this._startPos);\n      this._startTime = +new Date(); // @event start: Event\n      // Fired when the animation starts\n\n      this.fire('start');\n\n      this._animate();\n    },\n    // @method stop()\n    // Stops the animation (if currently running).\n    stop: function () {\n      if (!this._inProgress) {\n        return;\n      }\n\n      this._step(true);\n\n      this._complete();\n    },\n    _animate: function () {\n      // animation loop\n      this._animId = requestAnimFrame(this._animate, this);\n\n      this._step();\n    },\n    _step: function (round) {\n      var elapsed = +new Date() - this._startTime,\n          duration = this._duration * 1000;\n\n      if (elapsed < duration) {\n        this._runFrame(this._easeOut(elapsed / duration), round);\n      } else {\n        this._runFrame(1);\n\n        this._complete();\n      }\n    },\n    _runFrame: function (progress, round) {\n      var pos = this._startPos.add(this._offset.multiplyBy(progress));\n\n      if (round) {\n        pos._round();\n      }\n\n      setPosition(this._el, pos); // @event step: Event\n      // Fired continuously during the animation.\n\n      this.fire('step');\n    },\n    _complete: function () {\n      cancelAnimFrame(this._animId);\n      this._inProgress = false; // @event end: Event\n      // Fired when the animation ends.\n\n      this.fire('end');\n    },\n    _easeOut: function (t) {\n      return 1 - Math.pow(1 - t, this._easeOutPower);\n    }\n  });\n  /*\r\n   * @class Map\r\n   * @aka L.Map\r\n   * @inherits Evented\r\n   *\r\n   * The central class of the API — it is used to create a map on a page and manipulate it.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * // initialize the map on the \"map\" div with a given center and zoom\r\n   * var map = L.map('map', {\r\n   * \tcenter: [51.505, -0.09],\r\n   * \tzoom: 13\r\n   * });\r\n   * ```\r\n   *\r\n   */\n\n  var Map = Evented.extend({\n    options: {\n      // @section Map State Options\n      // @option crs: CRS = L.CRS.EPSG3857\n      // The [Coordinate Reference System](#crs) to use. Don't change this if you're not\n      // sure what it means.\n      crs: EPSG3857,\n      // @option center: LatLng = undefined\n      // Initial geographic center of the map\n      center: undefined,\n      // @option zoom: Number = undefined\n      // Initial map zoom level\n      zoom: undefined,\n      // @option minZoom: Number = *\n      // Minimum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the lowest of their `minZoom` options will be used instead.\n      minZoom: undefined,\n      // @option maxZoom: Number = *\n      // Maximum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the highest of their `maxZoom` options will be used instead.\n      maxZoom: undefined,\n      // @option layers: Layer[] = []\n      // Array of layers that will be added to the map initially\n      layers: [],\n      // @option maxBounds: LatLngBounds = null\n      // When this option is set, the map restricts the view to the given\n      // geographical bounds, bouncing the user back if the user tries to pan\n      // outside the view. To set the restriction dynamically, use\n      // [`setMaxBounds`](#map-setmaxbounds) method.\n      maxBounds: undefined,\n      // @option renderer: Renderer = *\n      // The default method for drawing vector layers on the map. `L.SVG`\n      // or `L.Canvas` by default depending on browser support.\n      renderer: undefined,\n      // @section Animation Options\n      // @option zoomAnimation: Boolean = true\n      // Whether the map zoom animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      zoomAnimation: true,\n      // @option zoomAnimationThreshold: Number = 4\n      // Won't animate zoom if the zoom difference exceeds this value.\n      zoomAnimationThreshold: 4,\n      // @option fadeAnimation: Boolean = true\n      // Whether the tile fade animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      fadeAnimation: true,\n      // @option markerZoomAnimation: Boolean = true\n      // Whether markers animate their zoom with the zoom animation, if disabled\n      // they will disappear for the length of the animation. By default it's\n      // enabled in all browsers that support CSS3 Transitions except Android.\n      markerZoomAnimation: true,\n      // @option transform3DLimit: Number = 2^23\n      // Defines the maximum size of a CSS translation transform. The default\n      // value should not be changed unless a web browser positions layers in\n      // the wrong place after doing a large `panBy`.\n      transform3DLimit: 8388608,\n      // Precision limit of a 32-bit float\n      // @section Interaction Options\n      // @option zoomSnap: Number = 1\n      // Forces the map's zoom level to always be a multiple of this, particularly\n      // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\n      // By default, the zoom level snaps to the nearest integer; lower values\n      // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\n      // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\n      zoomSnap: 1,\n      // @option zoomDelta: Number = 1\n      // Controls how much the map's zoom level will change after a\n      // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\n      // or `-` on the keyboard, or using the [zoom controls](#control-zoom).\n      // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\n      zoomDelta: 1,\n      // @option trackResize: Boolean = true\n      // Whether the map automatically handles browser window resize to update itself.\n      trackResize: true\n    },\n    initialize: function (id, options) {\n      // (HTMLElement or String, Object)\n      options = setOptions(this, options); // Make sure to assign internal flags at the beginning,\n      // to avoid inconsistent state in some edge cases.\n\n      this._handlers = [];\n      this._layers = {};\n      this._zoomBoundLayers = {};\n      this._sizeChanged = true;\n\n      this._initContainer(id);\n\n      this._initLayout(); // hack for https://github.com/Leaflet/Leaflet/issues/1980\n\n\n      this._onResize = bind(this._onResize, this);\n\n      this._initEvents();\n\n      if (options.maxBounds) {\n        this.setMaxBounds(options.maxBounds);\n      }\n\n      if (options.zoom !== undefined) {\n        this._zoom = this._limitZoom(options.zoom);\n      }\n\n      if (options.center && options.zoom !== undefined) {\n        this.setView(toLatLng(options.center), options.zoom, {\n          reset: true\n        });\n      }\n\n      this.callInitHooks(); // don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\n      this._zoomAnimated = TRANSITION && any3d && !mobileOpera && this.options.zoomAnimation; // zoom transitions run with the same duration for all layers, so if one of transitionend events\n      // happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\n      if (this._zoomAnimated) {\n        this._createAnimProxy();\n\n        on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);\n      }\n\n      this._addLayers(this.options.layers);\n    },\n    // @section Methods for modifying map state\n    // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) with the given\n    // animation options.\n    setView: function (center, zoom, options) {\n      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n      center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\n      options = options || {};\n\n      this._stop();\n\n      if (this._loaded && !options.reset && options !== true) {\n        if (options.animate !== undefined) {\n          options.zoom = extend({\n            animate: options.animate\n          }, options.zoom);\n          options.pan = extend({\n            animate: options.animate,\n            duration: options.duration\n          }, options.pan);\n        } // try animating pan or zoom\n\n\n        var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);\n\n        if (moved) {\n          // prevent resize handler call, the view will refresh after animation anyway\n          clearTimeout(this._sizeTimer);\n          return this;\n        }\n      } // animation didn't start, just reset the map view\n\n\n      this._resetView(center, zoom);\n\n      return this;\n    },\n    // @method setZoom(zoom: Number, options?: Zoom/pan options): this\n    // Sets the zoom of the map.\n    setZoom: function (zoom, options) {\n      if (!this._loaded) {\n        this._zoom = zoom;\n        return this;\n      }\n\n      return this.setView(this.getCenter(), zoom, {\n        zoom: options\n      });\n    },\n    // @method zoomIn(delta?: Number, options?: Zoom options): this\n    // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomIn: function (delta, options) {\n      delta = delta || (any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom + delta, options);\n    },\n    // @method zoomOut(delta?: Number, options?: Zoom options): this\n    // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomOut: function (delta, options) {\n      delta = delta || (any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom - delta, options);\n    },\n    // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified geographical point on the map\n    // stationary (e.g. used internally for scroll zoom and double-click zoom).\n    // @alternative\n    // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\n    setZoomAround: function (latlng, zoom, options) {\n      var scale = this.getZoomScale(zoom),\n          viewHalf = this.getSize().divideBy(2),\n          containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),\n          centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\n          newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\n      return this.setView(newCenter, zoom, {\n        zoom: options\n      });\n    },\n    _getBoundsCenterZoom: function (bounds, options) {\n      options = options || {};\n      bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n          zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n      zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;\n\n      if (zoom === Infinity) {\n        return {\n          center: bounds.getCenter(),\n          zoom: zoom\n        };\n      }\n\n      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\n          swPoint = this.project(bounds.getSouthWest(), zoom),\n          nePoint = this.project(bounds.getNorthEast(), zoom),\n          center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\n      return {\n        center: center,\n        zoom: zoom\n      };\n    },\n    // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets a map view that contains the given geographical bounds with the\n    // maximum zoom level possible.\n    fitBounds: function (bounds, options) {\n      bounds = toLatLngBounds(bounds);\n\n      if (!bounds.isValid()) {\n        throw new Error('Bounds are not valid.');\n      }\n\n      var target = this._getBoundsCenterZoom(bounds, options);\n\n      return this.setView(target.center, target.zoom, options);\n    },\n    // @method fitWorld(options?: fitBounds options): this\n    // Sets a map view that mostly contains the whole world with the maximum\n    // zoom level possible.\n    fitWorld: function (options) {\n      return this.fitBounds([[-90, -180], [90, 180]], options);\n    },\n    // @method panTo(latlng: LatLng, options?: Pan options): this\n    // Pans the map to a given center.\n    panTo: function (center, options) {\n      // (LatLng)\n      return this.setView(center, this._zoom, {\n        pan: options\n      });\n    },\n    // @method panBy(offset: Point, options?: Pan options): this\n    // Pans the map by a given number of pixels (animated).\n    panBy: function (offset, options) {\n      offset = toPoint(offset).round();\n      options = options || {};\n\n      if (!offset.x && !offset.y) {\n        return this.fire('moveend');\n      } // If we pan too far, Chrome gets issues with tiles\n      // and makes them disappear or appear in the wrong place (slightly offset) #2602\n\n\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\n\n        return this;\n      }\n\n      if (!this._panAnim) {\n        this._panAnim = new PosAnimation();\n\n        this._panAnim.on({\n          'step': this._onPanTransitionStep,\n          'end': this._onPanTransitionEnd\n        }, this);\n      } // don't fire movestart if animating inertia\n\n\n      if (!options.noMoveStart) {\n        this.fire('movestart');\n      } // animate pan unless animate: false specified\n\n\n      if (options.animate !== false) {\n        addClass(this._mapPane, 'leaflet-pan-anim');\n\n        var newPos = this._getMapPanePos().subtract(offset).round();\n\n        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n      } else {\n        this._rawPanBy(offset);\n\n        this.fire('move').fire('moveend');\n      }\n\n      return this;\n    },\n    // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) performing a smooth\n    // pan-zoom animation.\n    flyTo: function (targetCenter, targetZoom, options) {\n      options = options || {};\n\n      if (options.animate === false || !any3d) {\n        return this.setView(targetCenter, targetZoom, options);\n      }\n\n      this._stop();\n\n      var from = this.project(this.getCenter()),\n          to = this.project(targetCenter),\n          size = this.getSize(),\n          startZoom = this._zoom;\n      targetCenter = toLatLng(targetCenter);\n      targetZoom = targetZoom === undefined ? startZoom : targetZoom;\n      var w0 = Math.max(size.x, size.y),\n          w1 = w0 * this.getZoomScale(startZoom, targetZoom),\n          u1 = to.distanceTo(from) || 1,\n          rho = 1.42,\n          rho2 = rho * rho;\n\n      function r(i) {\n        var s1 = i ? -1 : 1,\n            s2 = i ? w1 : w0,\n            t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,\n            b1 = 2 * s2 * rho2 * u1,\n            b = t1 / b1,\n            sq = Math.sqrt(b * b + 1) - b; // workaround for floating point precision bug when sq = 0, log = -Infinite,\n        // thus triggering an infinite loop in flyTo\n\n        var log = sq < 0.000000001 ? -18 : Math.log(sq);\n        return log;\n      }\n\n      function sinh(n) {\n        return (Math.exp(n) - Math.exp(-n)) / 2;\n      }\n\n      function cosh(n) {\n        return (Math.exp(n) + Math.exp(-n)) / 2;\n      }\n\n      function tanh(n) {\n        return sinh(n) / cosh(n);\n      }\n\n      var r0 = r(0);\n\n      function w(s) {\n        return w0 * (cosh(r0) / cosh(r0 + rho * s));\n      }\n\n      function u(s) {\n        return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;\n      }\n\n      function easeOut(t) {\n        return 1 - Math.pow(1 - t, 1.5);\n      }\n\n      var start = Date.now(),\n          S = (r(1) - r0) / rho,\n          duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\n\n      function frame() {\n        var t = (Date.now() - start) / duration,\n            s = easeOut(t) * S;\n\n        if (t <= 1) {\n          this._flyToFrame = requestAnimFrame(frame, this);\n\n          this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {\n            flyTo: true\n          });\n        } else {\n          this._move(targetCenter, targetZoom)._moveEnd(true);\n        }\n      }\n\n      this._moveStart(true, options.noMoveStart);\n\n      frame.call(this);\n      return this;\n    },\n    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\n    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\n    flyToBounds: function (bounds, options) {\n      var target = this._getBoundsCenterZoom(bounds, options);\n\n      return this.flyTo(target.center, target.zoom, options);\n    },\n    // @method setMaxBounds(bounds: Bounds): this\n    // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\n    setMaxBounds: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n\n      if (!bounds.isValid()) {\n        this.options.maxBounds = null;\n        return this.off('moveend', this._panInsideMaxBounds);\n      } else if (this.options.maxBounds) {\n        this.off('moveend', this._panInsideMaxBounds);\n      }\n\n      this.options.maxBounds = bounds;\n\n      if (this._loaded) {\n        this._panInsideMaxBounds();\n      }\n\n      return this.on('moveend', this._panInsideMaxBounds);\n    },\n    // @method setMinZoom(zoom: Number): this\n    // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\n    setMinZoom: function (zoom) {\n      var oldZoom = this.options.minZoom;\n      this.options.minZoom = zoom;\n\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n\n        if (this.getZoom() < this.options.minZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n\n      return this;\n    },\n    // @method setMaxZoom(zoom: Number): this\n    // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\n    setMaxZoom: function (zoom) {\n      var oldZoom = this.options.maxZoom;\n      this.options.maxZoom = zoom;\n\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n\n        if (this.getZoom() > this.options.maxZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n\n      return this;\n    },\n    // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\n    // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\n    panInsideBounds: function (bounds, options) {\n      this._enforcingBounds = true;\n\n      var center = this.getCenter(),\n          newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\n\n      if (!center.equals(newCenter)) {\n        this.panTo(newCenter, options);\n      }\n\n      this._enforcingBounds = false;\n      return this;\n    },\n    // @method panInside(latlng: LatLng, options?: options): this\n    // Pans the map the minimum amount to make the `latlng` visible. Use\n    // `padding`, `paddingTopLeft` and `paddingTopRight` options to fit\n    // the display to more restricted bounds, like [`fitBounds`](#map-fitbounds).\n    // If `latlng` is already within the (optionally padded) display bounds,\n    // the map will not be panned.\n    panInside: function (latlng, options) {\n      options = options || {};\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n          center = this.getCenter(),\n          pixelCenter = this.project(center),\n          pixelPoint = this.project(latlng),\n          pixelBounds = this.getPixelBounds(),\n          halfPixelBounds = pixelBounds.getSize().divideBy(2),\n          paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);\n\n      if (!paddedBounds.contains(pixelPoint)) {\n        this._enforcingBounds = true;\n        var diff = pixelCenter.subtract(pixelPoint),\n            newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);\n\n        if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {\n          newCenter.x = pixelCenter.x - diff.x;\n\n          if (diff.x > 0) {\n            newCenter.x += halfPixelBounds.x - paddingTL.x;\n          } else {\n            newCenter.x -= halfPixelBounds.x - paddingBR.x;\n          }\n        }\n\n        if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {\n          newCenter.y = pixelCenter.y - diff.y;\n\n          if (diff.y > 0) {\n            newCenter.y += halfPixelBounds.y - paddingTL.y;\n          } else {\n            newCenter.y -= halfPixelBounds.y - paddingBR.y;\n          }\n        }\n\n        this.panTo(this.unproject(newCenter), options);\n        this._enforcingBounds = false;\n      }\n\n      return this;\n    },\n    // @method invalidateSize(options: Zoom/pan options): this\n    // Checks if the map container size changed and updates the map if so —\n    // call it after you've changed the map size dynamically, also animating\n    // pan by default. If `options.pan` is `false`, panning will not occur.\n    // If `options.debounceMoveend` is `true`, it will delay `moveend` event so\n    // that it doesn't happen often even if the method is called many\n    // times in a row.\n    // @alternative\n    // @method invalidateSize(animate: Boolean): this\n    // Checks if the map container size changed and updates the map if so —\n    // call it after you've changed the map size dynamically, also animating\n    // pan by default.\n    invalidateSize: function (options) {\n      if (!this._loaded) {\n        return this;\n      }\n\n      options = extend({\n        animate: false,\n        pan: true\n      }, options === true ? {\n        animate: true\n      } : options);\n      var oldSize = this.getSize();\n      this._sizeChanged = true;\n      this._lastCenter = null;\n      var newSize = this.getSize(),\n          oldCenter = oldSize.divideBy(2).round(),\n          newCenter = newSize.divideBy(2).round(),\n          offset = oldCenter.subtract(newCenter);\n\n      if (!offset.x && !offset.y) {\n        return this;\n      }\n\n      if (options.animate && options.pan) {\n        this.panBy(offset);\n      } else {\n        if (options.pan) {\n          this._rawPanBy(offset);\n        }\n\n        this.fire('move');\n\n        if (options.debounceMoveend) {\n          clearTimeout(this._sizeTimer);\n          this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);\n        } else {\n          this.fire('moveend');\n        }\n      } // @section Map state change events\n      // @event resize: ResizeEvent\n      // Fired when the map is resized.\n\n\n      return this.fire('resize', {\n        oldSize: oldSize,\n        newSize: newSize\n      });\n    },\n    // @section Methods for modifying map state\n    // @method stop(): this\n    // Stops the currently running `panTo` or `flyTo` animation, if any.\n    stop: function () {\n      this.setZoom(this._limitZoom(this._zoom));\n\n      if (!this.options.zoomSnap) {\n        this.fire('viewreset');\n      }\n\n      return this._stop();\n    },\n    // @section Geolocation methods\n    // @method locate(options?: Locate options): this\n    // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\n    // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\n    // and optionally sets the map view to the user's location with respect to\n    // detection accuracy (or to the world view if geolocation failed).\n    // Note that, if your page doesn't use HTTPS, this method will fail in\n    // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\n    // See `Locate options` for more details.\n    locate: function (options) {\n      options = this._locateOptions = extend({\n        timeout: 10000,\n        watch: false // setView: false\n        // maxZoom: <Number>\n        // maximumAge: 0\n        // enableHighAccuracy: false\n\n      }, options);\n\n      if (!('geolocation' in navigator)) {\n        this._handleGeolocationError({\n          code: 0,\n          message: 'Geolocation not supported.'\n        });\n\n        return this;\n      }\n\n      var onResponse = bind(this._handleGeolocationResponse, this),\n          onError = bind(this._handleGeolocationError, this);\n\n      if (options.watch) {\n        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);\n      } else {\n        navigator.geolocation.getCurrentPosition(onResponse, onError, options);\n      }\n\n      return this;\n    },\n    // @method stopLocate(): this\n    // Stops watching location previously initiated by `map.locate({watch: true})`\n    // and aborts resetting the map view if map.locate was called with\n    // `{setView: true}`.\n    stopLocate: function () {\n      if (navigator.geolocation && navigator.geolocation.clearWatch) {\n        navigator.geolocation.clearWatch(this._locationWatchId);\n      }\n\n      if (this._locateOptions) {\n        this._locateOptions.setView = false;\n      }\n\n      return this;\n    },\n    _handleGeolocationError: function (error) {\n      var c = error.code,\n          message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');\n\n      if (this._locateOptions.setView && !this._loaded) {\n        this.fitWorld();\n      } // @section Location events\n      // @event locationerror: ErrorEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method) failed.\n\n\n      this.fire('locationerror', {\n        code: c,\n        message: 'Geolocation error: ' + message + '.'\n      });\n    },\n    _handleGeolocationResponse: function (pos) {\n      var lat = pos.coords.latitude,\n          lng = pos.coords.longitude,\n          latlng = new LatLng(lat, lng),\n          bounds = latlng.toBounds(pos.coords.accuracy * 2),\n          options = this._locateOptions;\n\n      if (options.setView) {\n        var zoom = this.getBoundsZoom(bounds);\n        this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\n      }\n\n      var data = {\n        latlng: latlng,\n        bounds: bounds,\n        timestamp: pos.timestamp\n      };\n\n      for (var i in pos.coords) {\n        if (typeof pos.coords[i] === 'number') {\n          data[i] = pos.coords[i];\n        }\n      } // @event locationfound: LocationEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method)\n      // went successfully.\n\n\n      this.fire('locationfound', data);\n    },\n    // TODO Appropriate docs section?\n    // @section Other Methods\n    // @method addHandler(name: String, HandlerClass: Function): this\n    // Adds a new `Handler` to the map, given its name and constructor function.\n    addHandler: function (name, HandlerClass) {\n      if (!HandlerClass) {\n        return this;\n      }\n\n      var handler = this[name] = new HandlerClass(this);\n\n      this._handlers.push(handler);\n\n      if (this.options[name]) {\n        handler.enable();\n      }\n\n      return this;\n    },\n    // @method remove(): this\n    // Destroys the map and clears all related event listeners.\n    remove: function () {\n      this._initEvents(true);\n\n      if (this._containerId !== this._container._leaflet_id) {\n        throw new Error('Map container is being reused by another instance');\n      }\n\n      try {\n        // throws error in IE6-8\n        delete this._container._leaflet_id;\n        delete this._containerId;\n      } catch (e) {\n        /*eslint-disable */\n        this._container._leaflet_id = undefined;\n        /* eslint-enable */\n\n        this._containerId = undefined;\n      }\n\n      if (this._locationWatchId !== undefined) {\n        this.stopLocate();\n      }\n\n      this._stop();\n\n      remove(this._mapPane);\n\n      if (this._clearControlPos) {\n        this._clearControlPos();\n      }\n\n      if (this._resizeRequest) {\n        cancelAnimFrame(this._resizeRequest);\n        this._resizeRequest = null;\n      }\n\n      this._clearHandlers();\n\n      if (this._loaded) {\n        // @section Map state change events\n        // @event unload: Event\n        // Fired when the map is destroyed with [remove](#map-remove) method.\n        this.fire('unload');\n      }\n\n      var i;\n\n      for (i in this._layers) {\n        this._layers[i].remove();\n      }\n\n      for (i in this._panes) {\n        remove(this._panes[i]);\n      }\n\n      this._layers = [];\n      this._panes = [];\n      delete this._mapPane;\n      delete this._renderer;\n      return this;\n    },\n    // @section Other Methods\n    // @method createPane(name: String, container?: HTMLElement): HTMLElement\n    // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\n    // then returns it. The pane is created as a child of `container`, or\n    // as a child of the main map pane if not set.\n    createPane: function (name, container) {\n      var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\n          pane = create$1('div', className, container || this._mapPane);\n\n      if (name) {\n        this._panes[name] = pane;\n      }\n\n      return pane;\n    },\n    // @section Methods for Getting Map State\n    // @method getCenter(): LatLng\n    // Returns the geographical center of the map view\n    getCenter: function () {\n      this._checkIfLoaded();\n\n      if (this._lastCenter && !this._moved()) {\n        return this._lastCenter;\n      }\n\n      return this.layerPointToLatLng(this._getCenterLayerPoint());\n    },\n    // @method getZoom(): Number\n    // Returns the current zoom level of the map view\n    getZoom: function () {\n      return this._zoom;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the geographical bounds visible in the current map view\n    getBounds: function () {\n      var bounds = this.getPixelBounds(),\n          sw = this.unproject(bounds.getBottomLeft()),\n          ne = this.unproject(bounds.getTopRight());\n      return new LatLngBounds(sw, ne);\n    },\n    // @method getMinZoom(): Number\n    // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\n    getMinZoom: function () {\n      return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\n    },\n    // @method getMaxZoom(): Number\n    // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\n    getMaxZoom: function () {\n      return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;\n    },\n    // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\n    // Returns the maximum zoom level on which the given bounds fit to the map\n    // view in its entirety. If `inside` (optional) is set to `true`, the method\n    // instead returns the minimum zoom level on which the map view fits into\n    // the given bounds in its entirety.\n    getBoundsZoom: function (bounds, inside, padding) {\n      // (LatLngBounds[, Boolean, Point]) -> Number\n      bounds = toLatLngBounds(bounds);\n      padding = toPoint(padding || [0, 0]);\n      var zoom = this.getZoom() || 0,\n          min = this.getMinZoom(),\n          max = this.getMaxZoom(),\n          nw = bounds.getNorthWest(),\n          se = bounds.getSouthEast(),\n          size = this.getSize().subtract(padding),\n          boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\n          snap = any3d ? this.options.zoomSnap : 1,\n          scalex = size.x / boundsSize.x,\n          scaley = size.y / boundsSize.y,\n          scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\n      zoom = this.getScaleZoom(scale, zoom);\n\n      if (snap) {\n        zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\n\n        zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\n      }\n\n      return Math.max(min, Math.min(max, zoom));\n    },\n    // @method getSize(): Point\n    // Returns the current size of the map container (in pixels).\n    getSize: function () {\n      if (!this._size || this._sizeChanged) {\n        this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);\n        this._sizeChanged = false;\n      }\n\n      return this._size.clone();\n    },\n    // @method getPixelBounds(): Bounds\n    // Returns the bounds of the current map view in projected pixel\n    // coordinates (sometimes useful in layer and overlay implementations).\n    getPixelBounds: function (center, zoom) {\n      var topLeftPoint = this._getTopLeftPoint(center, zoom);\n\n      return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n    },\n    // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\n    // the map pane? \"left point of the map layer\" can be confusing, specially\n    // since there can be negative offsets.\n    // @method getPixelOrigin(): Point\n    // Returns the projected pixel coordinates of the top left point of\n    // the map layer (useful in custom layer and overlay implementations).\n    getPixelOrigin: function () {\n      this._checkIfLoaded();\n\n      return this._pixelOrigin;\n    },\n    // @method getPixelWorldBounds(zoom?: Number): Bounds\n    // Returns the world's bounds in pixel coordinates for zoom level `zoom`.\n    // If `zoom` is omitted, the map's current zoom level is used.\n    getPixelWorldBounds: function (zoom) {\n      return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\n    },\n    // @section Other Methods\n    // @method getPane(pane: String|HTMLElement): HTMLElement\n    // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\n    getPane: function (pane) {\n      return typeof pane === 'string' ? this._panes[pane] : pane;\n    },\n    // @method getPanes(): Object\n    // Returns a plain object containing the names of all [panes](#map-pane) as keys and\n    // the panes as values.\n    getPanes: function () {\n      return this._panes;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the map.\n    getContainer: function () {\n      return this._container;\n    },\n    // @section Conversion Methods\n    // @method getZoomScale(toZoom: Number, fromZoom: Number): Number\n    // Returns the scale factor to be applied to a map transition from zoom level\n    // `fromZoom` to `toZoom`. Used internally to help with zoom animations.\n    getZoomScale: function (toZoom, fromZoom) {\n      // TODO replace with universal implementation after refactoring projections\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      return crs.scale(toZoom) / crs.scale(fromZoom);\n    },\n    // @method getScaleZoom(scale: Number, fromZoom: Number): Number\n    // Returns the zoom level that the map would end up at, if it is at `fromZoom`\n    // level and everything is scaled by a factor of `scale`. Inverse of\n    // [`getZoomScale`](#map-getZoomScale).\n    getScaleZoom: function (scale, fromZoom) {\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      var zoom = crs.zoom(scale * crs.scale(fromZoom));\n      return isNaN(zoom) ? Infinity : zoom;\n    },\n    // @method project(latlng: LatLng, zoom: Number): Point\n    // Projects a geographical coordinate `LatLng` according to the projection\n    // of the map's CRS, then scales it according to `zoom` and the CRS's\n    // `Transformation`. The result is pixel coordinate relative to\n    // the CRS origin.\n    project: function (latlng, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\n    },\n    // @method unproject(point: Point, zoom: Number): LatLng\n    // Inverse of [`project`](#map-project).\n    unproject: function (point, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.pointToLatLng(toPoint(point), zoom);\n    },\n    // @method layerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding geographical coordinate (for the current zoom level).\n    layerPointToLatLng: function (point) {\n      var projectedPoint = toPoint(point).add(this.getPixelOrigin());\n      return this.unproject(projectedPoint);\n    },\n    // @method latLngToLayerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the [origin pixel](#map-getpixelorigin).\n    latLngToLayerPoint: function (latlng) {\n      var projectedPoint = this.project(toLatLng(latlng))._round();\n\n      return projectedPoint._subtract(this.getPixelOrigin());\n    },\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\n    // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\n    // CRS's bounds.\n    // By default this means longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees.\n    wrapLatLng: function (latlng) {\n      return this.options.crs.wrapLatLng(toLatLng(latlng));\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring that\n    // its center is within the CRS's bounds.\n    // By default this means the center longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees, and the majority of the bounds\n    // overlaps the CRS's bounds.\n    wrapLatLngBounds: function (latlng) {\n      return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates according to\n    // the map's CRS. By default this measures distance in meters.\n    distance: function (latlng1, latlng2) {\n      return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\n    },\n    // @method containerPointToLayerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the map container, returns the corresponding\n    // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\n    containerPointToLayerPoint: function (point) {\n      // (Point)\n      return toPoint(point).subtract(this._getMapPanePos());\n    },\n    // @method layerPointToContainerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding pixel coordinate relative to the map container.\n    layerPointToContainerPoint: function (point) {\n      // (Point)\n      return toPoint(point).add(this._getMapPanePos());\n    },\n    // @method containerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the map container, returns\n    // the corresponding geographical coordinate (for the current zoom level).\n    containerPointToLatLng: function (point) {\n      var layerPoint = this.containerPointToLayerPoint(toPoint(point));\n      return this.layerPointToLatLng(layerPoint);\n    },\n    // @method latLngToContainerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the map container.\n    latLngToContainerPoint: function (latlng) {\n      return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\n    },\n    // @method mouseEventToContainerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to the\n    // map container where the event took place.\n    mouseEventToContainerPoint: function (e) {\n      return getMousePosition(e, this._container);\n    },\n    // @method mouseEventToLayerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to\n    // the [origin pixel](#map-getpixelorigin) where the event took place.\n    mouseEventToLayerPoint: function (e) {\n      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\n    },\n    // @method mouseEventToLatLng(ev: MouseEvent): LatLng\n    // Given a MouseEvent object, returns geographical coordinate where the\n    // event took place.\n    mouseEventToLatLng: function (e) {\n      // (MouseEvent)\n      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\n    },\n    // map initialization methods\n    _initContainer: function (id) {\n      var container = this._container = get(id);\n\n      if (!container) {\n        throw new Error('Map container not found.');\n      } else if (container._leaflet_id) {\n        throw new Error('Map container is already initialized.');\n      }\n\n      on(container, 'scroll', this._onScroll, this);\n      this._containerId = stamp(container);\n    },\n    _initLayout: function () {\n      var container = this._container;\n      this._fadeAnimated = this.options.fadeAnimation && any3d;\n      addClass(container, 'leaflet-container' + (touch ? ' leaflet-touch' : '') + (retina ? ' leaflet-retina' : '') + (ielt9 ? ' leaflet-oldie' : '') + (safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));\n      var position = getStyle(container, 'position');\n\n      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\n        container.style.position = 'relative';\n      }\n\n      this._initPanes();\n\n      if (this._initControlPos) {\n        this._initControlPos();\n      }\n    },\n    _initPanes: function () {\n      var panes = this._panes = {};\n      this._paneRenderers = {}; // @section\n      //\n      // Panes are DOM elements used to control the ordering of layers on the map. You\n      // can access panes with [`map.getPane`](#map-getpane) or\n      // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\n      // [`map.createPane`](#map-createpane) method.\n      //\n      // Every map has the following default panes that differ only in zIndex.\n      //\n      // @pane mapPane: HTMLElement = 'auto'\n      // Pane that contains all other map panes\n\n      this._mapPane = this.createPane('mapPane', this._container);\n      setPosition(this._mapPane, new Point(0, 0)); // @pane tilePane: HTMLElement = 200\n      // Pane for `GridLayer`s and `TileLayer`s\n\n      this.createPane('tilePane'); // @pane overlayPane: HTMLElement = 400\n      // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\n\n      this.createPane('shadowPane'); // @pane shadowPane: HTMLElement = 500\n      // Pane for overlay shadows (e.g. `Marker` shadows)\n\n      this.createPane('overlayPane'); // @pane markerPane: HTMLElement = 600\n      // Pane for `Icon`s of `Marker`s\n\n      this.createPane('markerPane'); // @pane tooltipPane: HTMLElement = 650\n      // Pane for `Tooltip`s.\n\n      this.createPane('tooltipPane'); // @pane popupPane: HTMLElement = 700\n      // Pane for `Popup`s.\n\n      this.createPane('popupPane');\n\n      if (!this.options.markerZoomAnimation) {\n        addClass(panes.markerPane, 'leaflet-zoom-hide');\n        addClass(panes.shadowPane, 'leaflet-zoom-hide');\n      }\n    },\n    // private methods that modify map state\n    // @section Map state change events\n    _resetView: function (center, zoom) {\n      setPosition(this._mapPane, new Point(0, 0));\n      var loading = !this._loaded;\n      this._loaded = true;\n      zoom = this._limitZoom(zoom);\n      this.fire('viewprereset');\n      var zoomChanged = this._zoom !== zoom;\n\n      this._moveStart(zoomChanged, false)._move(center, zoom)._moveEnd(zoomChanged); // @event viewreset: Event\n      // Fired when the map needs to redraw its content (this usually happens\n      // on map zoom or load). Very useful for creating custom overlays.\n\n\n      this.fire('viewreset'); // @event load: Event\n      // Fired when the map is initialized (when its center and zoom are set\n      // for the first time).\n\n      if (loading) {\n        this.fire('load');\n      }\n    },\n    _moveStart: function (zoomChanged, noMoveStart) {\n      // @event zoomstart: Event\n      // Fired when the map zoom is about to change (e.g. before zoom animation).\n      // @event movestart: Event\n      // Fired when the view of the map starts changing (e.g. user starts dragging the map).\n      if (zoomChanged) {\n        this.fire('zoomstart');\n      }\n\n      if (!noMoveStart) {\n        this.fire('movestart');\n      }\n\n      return this;\n    },\n    _move: function (center, zoom, data) {\n      if (zoom === undefined) {\n        zoom = this._zoom;\n      }\n\n      var zoomChanged = this._zoom !== zoom;\n      this._zoom = zoom;\n      this._lastCenter = center;\n      this._pixelOrigin = this._getNewPixelOrigin(center); // @event zoom: Event\n      // Fired repeatedly during any change in zoom level, including zoom\n      // and fly animations.\n\n      if (zoomChanged || data && data.pinch) {\n        // Always fire 'zoom' if pinching because #3530\n        this.fire('zoom', data);\n      } // @event move: Event\n      // Fired repeatedly during any movement of the map, including pan and\n      // fly animations.\n\n\n      return this.fire('move', data);\n    },\n    _moveEnd: function (zoomChanged) {\n      // @event zoomend: Event\n      // Fired when the map has changed, after any animations.\n      if (zoomChanged) {\n        this.fire('zoomend');\n      } // @event moveend: Event\n      // Fired when the center of the map stops changing (e.g. user stopped\n      // dragging the map).\n\n\n      return this.fire('moveend');\n    },\n    _stop: function () {\n      cancelAnimFrame(this._flyToFrame);\n\n      if (this._panAnim) {\n        this._panAnim.stop();\n      }\n\n      return this;\n    },\n    _rawPanBy: function (offset) {\n      setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\n    },\n    _getZoomSpan: function () {\n      return this.getMaxZoom() - this.getMinZoom();\n    },\n    _panInsideMaxBounds: function () {\n      if (!this._enforcingBounds) {\n        this.panInsideBounds(this.options.maxBounds);\n      }\n    },\n    _checkIfLoaded: function () {\n      if (!this._loaded) {\n        throw new Error('Set map center and zoom first.');\n      }\n    },\n    // DOM event handling\n    // @section Interaction events\n    _initEvents: function (remove$$1) {\n      this._targets = {};\n      this._targets[stamp(this._container)] = this;\n      var onOff = remove$$1 ? off : on; // @event click: MouseEvent\n      // Fired when the user clicks (or taps) the map.\n      // @event dblclick: MouseEvent\n      // Fired when the user double-clicks (or double-taps) the map.\n      // @event mousedown: MouseEvent\n      // Fired when the user pushes the mouse button on the map.\n      // @event mouseup: MouseEvent\n      // Fired when the user releases the mouse button on the map.\n      // @event mouseover: MouseEvent\n      // Fired when the mouse enters the map.\n      // @event mouseout: MouseEvent\n      // Fired when the mouse leaves the map.\n      // @event mousemove: MouseEvent\n      // Fired while the mouse moves over the map.\n      // @event contextmenu: MouseEvent\n      // Fired when the user pushes the right mouse button on the map, prevents\n      // default browser context menu from showing if there are listeners on\n      // this event. Also fired on mobile when the user holds a single touch\n      // for a second (also called long press).\n      // @event keypress: KeyboardEvent\n      // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\n      // @event keydown: KeyboardEvent\n      // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\n      // the `keydown` event is fired for keys that produce a character value and for keys\n      // that do not produce a character value.\n      // @event keyup: KeyboardEvent\n      // Fired when the user releases a key from the keyboard while the map is focused.\n\n      onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);\n\n      if (this.options.trackResize) {\n        onOff(window, 'resize', this._onResize, this);\n      }\n\n      if (any3d && this.options.transform3DLimit) {\n        (remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);\n      }\n    },\n    _onResize: function () {\n      cancelAnimFrame(this._resizeRequest);\n      this._resizeRequest = requestAnimFrame(function () {\n        this.invalidateSize({\n          debounceMoveend: true\n        });\n      }, this);\n    },\n    _onScroll: function () {\n      this._container.scrollTop = 0;\n      this._container.scrollLeft = 0;\n    },\n    _onMoveEnd: function () {\n      var pos = this._getMapPanePos();\n\n      if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\n        // a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/\n        this._resetView(this.getCenter(), this.getZoom());\n      }\n    },\n    _findEventTargets: function (e, type) {\n      var targets = [],\n          target,\n          isHover = type === 'mouseout' || type === 'mouseover',\n          src = e.target || e.srcElement,\n          dragging = false;\n\n      while (src) {\n        target = this._targets[stamp(src)];\n\n        if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {\n          // Prevent firing click after you just dragged an object.\n          dragging = true;\n          break;\n        }\n\n        if (target && target.listens(type, true)) {\n          if (isHover && !isExternalTarget(src, e)) {\n            break;\n          }\n\n          targets.push(target);\n\n          if (isHover) {\n            break;\n          }\n        }\n\n        if (src === this._container) {\n          break;\n        }\n\n        src = src.parentNode;\n      }\n\n      if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {\n        targets = [this];\n      }\n\n      return targets;\n    },\n    _handleDOMEvent: function (e) {\n      if (!this._loaded || skipped(e)) {\n        return;\n      }\n\n      var type = e.type;\n\n      if (type === 'mousedown' || type === 'keypress' || type === 'keyup' || type === 'keydown') {\n        // prevents outline when clicking on keyboard-focusable element\n        preventOutline(e.target || e.srcElement);\n      }\n\n      this._fireDOMEvent(e, type);\n    },\n    _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\n    _fireDOMEvent: function (e, type, targets) {\n      if (e.type === 'click') {\n        // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\n        // @event preclick: MouseEvent\n        // Fired before mouse click on the map (sometimes useful when you\n        // want something to happen on click before any existing click\n        // handlers start running).\n        var synth = extend({}, e);\n        synth.type = 'preclick';\n\n        this._fireDOMEvent(synth, synth.type, targets);\n      }\n\n      if (e._stopped) {\n        return;\n      } // Find the layer the event is propagating from and its parents.\n\n\n      targets = (targets || []).concat(this._findEventTargets(e, type));\n\n      if (!targets.length) {\n        return;\n      }\n\n      var target = targets[0];\n\n      if (type === 'contextmenu' && target.listens(type, true)) {\n        preventDefault(e);\n      }\n\n      var data = {\n        originalEvent: e\n      };\n\n      if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {\n        var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\n        data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\n        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\n        data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\n      }\n\n      for (var i = 0; i < targets.length; i++) {\n        targets[i].fire(type, data, true);\n\n        if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {\n          return;\n        }\n      }\n    },\n    _draggableMoved: function (obj) {\n      obj = obj.dragging && obj.dragging.enabled() ? obj : this;\n      return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();\n    },\n    _clearHandlers: function () {\n      for (var i = 0, len = this._handlers.length; i < len; i++) {\n        this._handlers[i].disable();\n      }\n    },\n    // @section Other Methods\n    // @method whenReady(fn: Function, context?: Object): this\n    // Runs the given function `fn` when the map gets initialized with\n    // a view (center and zoom) and at least one layer, or immediately\n    // if it's already initialized, optionally passing a function context.\n    whenReady: function (callback, context) {\n      if (this._loaded) {\n        callback.call(context || this, {\n          target: this\n        });\n      } else {\n        this.on('load', callback, context);\n      }\n\n      return this;\n    },\n    // private methods for getting map state\n    _getMapPanePos: function () {\n      return getPosition(this._mapPane) || new Point(0, 0);\n    },\n    _moved: function () {\n      var pos = this._getMapPanePos();\n\n      return pos && !pos.equals([0, 0]);\n    },\n    _getTopLeftPoint: function (center, zoom) {\n      var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();\n      return pixelOrigin.subtract(this._getMapPanePos());\n    },\n    _getNewPixelOrigin: function (center, zoom) {\n      var viewHalf = this.getSize()._divideBy(2);\n\n      return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\n    },\n    _latLngToNewLayerPoint: function (latlng, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n\n      return this.project(latlng, zoom)._subtract(topLeft);\n    },\n    _latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n\n      return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);\n    },\n    // layer point of the current center\n    _getCenterLayerPoint: function () {\n      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n    },\n    // offset of the specified place to the current center in pixels\n    _getCenterOffset: function (latlng) {\n      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\n    },\n    // adjust center for view to get inside bounds\n    _limitCenter: function (center, zoom, bounds) {\n      if (!bounds) {\n        return center;\n      }\n\n      var centerPoint = this.project(center, zoom),\n          viewHalf = this.getSize().divideBy(2),\n          viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\n          offset = this._getBoundsOffset(viewBounds, bounds, zoom); // If offset is less than a pixel, ignore.\n      // This prevents unstable projections from getting into\n      // an infinite loop of tiny offsets.\n\n\n      if (offset.round().equals([0, 0])) {\n        return center;\n      }\n\n      return this.unproject(centerPoint.add(offset), zoom);\n    },\n    // adjust offset for view to get inside bounds\n    _limitOffset: function (offset, bounds) {\n      if (!bounds) {\n        return offset;\n      }\n\n      var viewBounds = this.getPixelBounds(),\n          newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\n      return offset.add(this._getBoundsOffset(newBounds, bounds));\n    },\n    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom\n    _getBoundsOffset: function (pxBounds, maxBounds, zoom) {\n      var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),\n          minOffset = projectedMaxBounds.min.subtract(pxBounds.min),\n          maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),\n          dx = this._rebound(minOffset.x, -maxOffset.x),\n          dy = this._rebound(minOffset.y, -maxOffset.y);\n\n      return new Point(dx, dy);\n    },\n    _rebound: function (left, right) {\n      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\n    },\n    _limitZoom: function (zoom) {\n      var min = this.getMinZoom(),\n          max = this.getMaxZoom(),\n          snap = any3d ? this.options.zoomSnap : 1;\n\n      if (snap) {\n        zoom = Math.round(zoom / snap) * snap;\n      }\n\n      return Math.max(min, Math.min(max, zoom));\n    },\n    _onPanTransitionStep: function () {\n      this.fire('move');\n    },\n    _onPanTransitionEnd: function () {\n      removeClass(this._mapPane, 'leaflet-pan-anim');\n      this.fire('moveend');\n    },\n    _tryAnimatedPan: function (center, options) {\n      // difference between the new and current centers in pixels\n      var offset = this._getCenterOffset(center)._trunc(); // don't animate too far unless animate: true specified in options\n\n\n      if ((options && options.animate) !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n\n      this.panBy(offset, options);\n      return true;\n    },\n    _createAnimProxy: function () {\n      var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');\n\n      this._panes.mapPane.appendChild(proxy);\n\n      this.on('zoomanim', function (e) {\n        var prop = TRANSFORM,\n            transform = this._proxy.style[prop];\n        setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1)); // workaround for case when transform is the same and so transitionend event is not fired\n\n        if (transform === this._proxy.style[prop] && this._animatingZoom) {\n          this._onZoomTransitionEnd();\n        }\n      }, this);\n      this.on('load moveend', this._animMoveEnd, this);\n\n      this._on('unload', this._destroyAnimProxy, this);\n    },\n    _destroyAnimProxy: function () {\n      remove(this._proxy);\n      this.off('load moveend', this._animMoveEnd, this);\n      delete this._proxy;\n    },\n    _animMoveEnd: function () {\n      var c = this.getCenter(),\n          z = this.getZoom();\n      setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\n    },\n    _catchTransitionEnd: function (e) {\n      if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n        this._onZoomTransitionEnd();\n      }\n    },\n    _nothingToAnimate: function () {\n      return !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n    },\n    _tryAnimatedZoom: function (center, zoom, options) {\n      if (this._animatingZoom) {\n        return true;\n      }\n\n      options = options || {}; // don't animate if disabled, not supported or zoom difference is too large\n\n      if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {\n        return false;\n      } // offset is the pixel coords of the zoom origin relative to the current center\n\n\n      var scale = this.getZoomScale(zoom),\n          offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale); // don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\n\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n\n      requestAnimFrame(function () {\n        this._moveStart(true, false)._animateZoom(center, zoom, true);\n      }, this);\n      return true;\n    },\n    _animateZoom: function (center, zoom, startAnim, noUpdate) {\n      if (!this._mapPane) {\n        return;\n      }\n\n      if (startAnim) {\n        this._animatingZoom = true; // remember what center/zoom to set after animation\n\n        this._animateToCenter = center;\n        this._animateToZoom = zoom;\n        addClass(this._mapPane, 'leaflet-zoom-anim');\n      } // @section Other Events\n      // @event zoomanim: ZoomAnimEvent\n      // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\n\n\n      this.fire('zoomanim', {\n        center: center,\n        zoom: zoom,\n        noUpdate: noUpdate\n      }); // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\n\n      setTimeout(bind(this._onZoomTransitionEnd, this), 250);\n    },\n    _onZoomTransitionEnd: function () {\n      if (!this._animatingZoom) {\n        return;\n      }\n\n      if (this._mapPane) {\n        removeClass(this._mapPane, 'leaflet-zoom-anim');\n      }\n\n      this._animatingZoom = false;\n\n      this._move(this._animateToCenter, this._animateToZoom); // This anim frame should prevent an obscure iOS webkit tile loading race condition.\n\n\n      requestAnimFrame(function () {\n        this._moveEnd(true);\n      }, this);\n    }\n  }); // @section\n  // @factory L.map(id: String, options?: Map options)\n  // Instantiates a map object given the DOM ID of a `<div>` element\n  // and optionally an object literal with `Map options`.\n  //\n  // @alternative\n  // @factory L.map(el: HTMLElement, options?: Map options)\n  // Instantiates a map object given an instance of a `<div>` HTML element\n  // and optionally an object literal with `Map options`.\n\n  function createMap(id, options) {\n    return new Map(id, options);\n  }\n  /*\r\n   * @class Control\r\n   * @aka L.Control\r\n   * @inherits Class\r\n   *\r\n   * L.Control is a base class for implementing map controls. Handles positioning.\r\n   * All other controls extend from this class.\r\n   */\n\n\n  var Control = Class.extend({\n    // @section\n    // @aka Control options\n    options: {\n      // @option position: String = 'topright'\n      // The position of the control (one of the map corners). Possible values are `'topleft'`,\n      // `'topright'`, `'bottomleft'` or `'bottomright'`\n      position: 'topright'\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n\n    /* @section\r\n     * Classes extending L.Control will inherit the following methods:\r\n     *\r\n     * @method getPosition: string\r\n     * Returns the position of the control.\r\n     */\n    getPosition: function () {\n      return this.options.position;\n    },\n    // @method setPosition(position: string): this\n    // Sets the position of the control.\n    setPosition: function (position) {\n      var map = this._map;\n\n      if (map) {\n        map.removeControl(this);\n      }\n\n      this.options.position = position;\n\n      if (map) {\n        map.addControl(this);\n      }\n\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTMLElement that contains the control.\n    getContainer: function () {\n      return this._container;\n    },\n    // @method addTo(map: Map): this\n    // Adds the control to the given map.\n    addTo: function (map) {\n      this.remove();\n      this._map = map;\n      var container = this._container = this.onAdd(map),\n          pos = this.getPosition(),\n          corner = map._controlCorners[pos];\n      addClass(container, 'leaflet-control');\n\n      if (pos.indexOf('bottom') !== -1) {\n        corner.insertBefore(container, corner.firstChild);\n      } else {\n        corner.appendChild(container);\n      }\n\n      this._map.on('unload', this.remove, this);\n\n      return this;\n    },\n    // @method remove: this\n    // Removes the control from the map it is currently active on.\n    remove: function () {\n      if (!this._map) {\n        return this;\n      }\n\n      remove(this._container);\n\n      if (this.onRemove) {\n        this.onRemove(this._map);\n      }\n\n      this._map.off('unload', this.remove, this);\n\n      this._map = null;\n      return this;\n    },\n    _refocusOnMap: function (e) {\n      // if map exists and event is not a keyboard event\n      if (this._map && e && e.screenX > 0 && e.screenY > 0) {\n        this._map.getContainer().focus();\n      }\n    }\n  });\n\n  var control = function (options) {\n    return new Control(options);\n  };\n  /* @section Extension methods\r\n   * @uninheritable\r\n   *\r\n   * Every control should extend from `L.Control` and (re-)implement the following methods.\r\n   *\r\n   * @method onAdd(map: Map): HTMLElement\r\n   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).\r\n   *\r\n   * @method onRemove(map: Map)\r\n   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).\r\n   */\n\n  /* @namespace Map\r\n   * @section Methods for Layers and Controls\r\n   */\n\n\n  Map.include({\n    // @method addControl(control: Control): this\n    // Adds the given control to the map\n    addControl: function (control) {\n      control.addTo(this);\n      return this;\n    },\n    // @method removeControl(control: Control): this\n    // Removes the given control from the map\n    removeControl: function (control) {\n      control.remove();\n      return this;\n    },\n    _initControlPos: function () {\n      var corners = this._controlCorners = {},\n          l = 'leaflet-',\n          container = this._controlContainer = create$1('div', l + 'control-container', this._container);\n\n      function createCorner(vSide, hSide) {\n        var className = l + vSide + ' ' + l + hSide;\n        corners[vSide + hSide] = create$1('div', className, container);\n      }\n\n      createCorner('top', 'left');\n      createCorner('top', 'right');\n      createCorner('bottom', 'left');\n      createCorner('bottom', 'right');\n    },\n    _clearControlPos: function () {\n      for (var i in this._controlCorners) {\n        remove(this._controlCorners[i]);\n      }\n\n      remove(this._controlContainer);\n      delete this._controlCorners;\n      delete this._controlContainer;\n    }\n  });\n  /*\r\n   * @class Control.Layers\r\n   * @aka L.Control.Layers\r\n   * @inherits Control\r\n   *\r\n   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var baseLayers = {\r\n   * \t\"Mapbox\": mapbox,\r\n   * \t\"OpenStreetMap\": osm\r\n   * };\r\n   *\r\n   * var overlays = {\r\n   * \t\"Marker\": marker,\r\n   * \t\"Roads\": roadsLayer\r\n   * };\r\n   *\r\n   * L.control.layers(baseLayers, overlays).addTo(map);\r\n   * ```\r\n   *\r\n   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:\r\n   *\r\n   * ```js\r\n   * {\r\n   *     \"<someName1>\": layer1,\r\n   *     \"<someName2>\": layer2\r\n   * }\r\n   * ```\r\n   *\r\n   * The layer names can contain HTML, which allows you to add additional styling to the items:\r\n   *\r\n   * ```js\r\n   * {\"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>\": myLayer}\r\n   * ```\r\n   */\n\n  var Layers = Control.extend({\n    // @section\n    // @aka Control.Layers options\n    options: {\n      // @option collapsed: Boolean = true\n      // If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.\n      collapsed: true,\n      position: 'topright',\n      // @option autoZIndex: Boolean = true\n      // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.\n      autoZIndex: true,\n      // @option hideSingleBase: Boolean = false\n      // If `true`, the base layers in the control will be hidden when there is only one.\n      hideSingleBase: false,\n      // @option sortLayers: Boolean = false\n      // Whether to sort the layers. When `false`, layers will keep the order\n      // in which they were added to the control.\n      sortLayers: false,\n      // @option sortFunction: Function = *\n      // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n      // that will be used for sorting the layers, when `sortLayers` is `true`.\n      // The function receives both the `L.Layer` instances and their names, as in\n      // `sortFunction(layerA, layerB, nameA, nameB)`.\n      // By default, it sorts layers alphabetically by their name.\n      sortFunction: function (layerA, layerB, nameA, nameB) {\n        return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;\n      }\n    },\n    initialize: function (baseLayers, overlays, options) {\n      setOptions(this, options);\n      this._layerControlInputs = [];\n      this._layers = [];\n      this._lastZIndex = 0;\n      this._handlingClick = false;\n\n      for (var i in baseLayers) {\n        this._addLayer(baseLayers[i], i);\n      }\n\n      for (i in overlays) {\n        this._addLayer(overlays[i], i, true);\n      }\n    },\n    onAdd: function (map) {\n      this._initLayout();\n\n      this._update();\n\n      this._map = map;\n      map.on('zoomend', this._checkDisabledLayers, this);\n\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.on('add remove', this._onLayerChange, this);\n      }\n\n      return this._container;\n    },\n    addTo: function (map) {\n      Control.prototype.addTo.call(this, map); // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.\n\n      return this._expandIfNotCollapsed();\n    },\n    onRemove: function () {\n      this._map.off('zoomend', this._checkDisabledLayers, this);\n\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.off('add remove', this._onLayerChange, this);\n      }\n    },\n    // @method addBaseLayer(layer: Layer, name: String): this\n    // Adds a base layer (radio button entry) with the given name to the control.\n    addBaseLayer: function (layer, name) {\n      this._addLayer(layer, name);\n\n      return this._map ? this._update() : this;\n    },\n    // @method addOverlay(layer: Layer, name: String): this\n    // Adds an overlay (checkbox entry) with the given name to the control.\n    addOverlay: function (layer, name) {\n      this._addLayer(layer, name, true);\n\n      return this._map ? this._update() : this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Remove the given layer from the control.\n    removeLayer: function (layer) {\n      layer.off('add remove', this._onLayerChange, this);\n\n      var obj = this._getLayer(stamp(layer));\n\n      if (obj) {\n        this._layers.splice(this._layers.indexOf(obj), 1);\n      }\n\n      return this._map ? this._update() : this;\n    },\n    // @method expand(): this\n    // Expand the control container if collapsed.\n    expand: function () {\n      addClass(this._container, 'leaflet-control-layers-expanded');\n      this._section.style.height = null;\n      var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);\n\n      if (acceptableHeight < this._section.clientHeight) {\n        addClass(this._section, 'leaflet-control-layers-scrollbar');\n        this._section.style.height = acceptableHeight + 'px';\n      } else {\n        removeClass(this._section, 'leaflet-control-layers-scrollbar');\n      }\n\n      this._checkDisabledLayers();\n\n      return this;\n    },\n    // @method collapse(): this\n    // Collapse the control container if expanded.\n    collapse: function () {\n      removeClass(this._container, 'leaflet-control-layers-expanded');\n      return this;\n    },\n    _initLayout: function () {\n      var className = 'leaflet-control-layers',\n          container = this._container = create$1('div', className),\n          collapsed = this.options.collapsed; // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\n\n      container.setAttribute('aria-haspopup', true);\n      disableClickPropagation(container);\n      disableScrollPropagation(container);\n      var section = this._section = create$1('section', className + '-list');\n\n      if (collapsed) {\n        this._map.on('click', this.collapse, this);\n\n        if (!android) {\n          on(container, {\n            mouseenter: this.expand,\n            mouseleave: this.collapse\n          }, this);\n        }\n      }\n\n      var link = this._layersLink = create$1('a', className + '-toggle', container);\n      link.href = '#';\n      link.title = 'Layers';\n\n      if (touch) {\n        on(link, 'click', stop);\n        on(link, 'click', this.expand, this);\n      } else {\n        on(link, 'focus', this.expand, this);\n      }\n\n      if (!collapsed) {\n        this.expand();\n      }\n\n      this._baseLayersList = create$1('div', className + '-base', section);\n      this._separator = create$1('div', className + '-separator', section);\n      this._overlaysList = create$1('div', className + '-overlays', section);\n      container.appendChild(section);\n    },\n    _getLayer: function (id) {\n      for (var i = 0; i < this._layers.length; i++) {\n        if (this._layers[i] && stamp(this._layers[i].layer) === id) {\n          return this._layers[i];\n        }\n      }\n    },\n    _addLayer: function (layer, name, overlay) {\n      if (this._map) {\n        layer.on('add remove', this._onLayerChange, this);\n      }\n\n      this._layers.push({\n        layer: layer,\n        name: name,\n        overlay: overlay\n      });\n\n      if (this.options.sortLayers) {\n        this._layers.sort(bind(function (a, b) {\n          return this.options.sortFunction(a.layer, b.layer, a.name, b.name);\n        }, this));\n      }\n\n      if (this.options.autoZIndex && layer.setZIndex) {\n        this._lastZIndex++;\n        layer.setZIndex(this._lastZIndex);\n      }\n\n      this._expandIfNotCollapsed();\n    },\n    _update: function () {\n      if (!this._container) {\n        return this;\n      }\n\n      empty(this._baseLayersList);\n      empty(this._overlaysList);\n      this._layerControlInputs = [];\n      var baseLayersPresent,\n          overlaysPresent,\n          i,\n          obj,\n          baseLayersCount = 0;\n\n      for (i = 0; i < this._layers.length; i++) {\n        obj = this._layers[i];\n\n        this._addItem(obj);\n\n        overlaysPresent = overlaysPresent || obj.overlay;\n        baseLayersPresent = baseLayersPresent || !obj.overlay;\n        baseLayersCount += !obj.overlay ? 1 : 0;\n      } // Hide base layers section if there's only one layer.\n\n\n      if (this.options.hideSingleBase) {\n        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;\n        this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';\n      }\n\n      this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\n      return this;\n    },\n    _onLayerChange: function (e) {\n      if (!this._handlingClick) {\n        this._update();\n      }\n\n      var obj = this._getLayer(stamp(e.target)); // @namespace Map\n      // @section Layer events\n      // @event baselayerchange: LayersControlEvent\n      // Fired when the base layer is changed through the [layer control](#control-layers).\n      // @event overlayadd: LayersControlEvent\n      // Fired when an overlay is selected through the [layer control](#control-layers).\n      // @event overlayremove: LayersControlEvent\n      // Fired when an overlay is deselected through the [layer control](#control-layers).\n      // @namespace Control.Layers\n\n\n      var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;\n\n      if (type) {\n        this._map.fire(type, obj);\n      }\n    },\n    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\n    _createRadioElement: function (name, checked) {\n      var radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"' + (checked ? ' checked=\"checked\"' : '') + '/>';\n      var radioFragment = document.createElement('div');\n      radioFragment.innerHTML = radioHtml;\n      return radioFragment.firstChild;\n    },\n    _addItem: function (obj) {\n      var label = document.createElement('label'),\n          checked = this._map.hasLayer(obj.layer),\n          input;\n\n      if (obj.overlay) {\n        input = document.createElement('input');\n        input.type = 'checkbox';\n        input.className = 'leaflet-control-layers-selector';\n        input.defaultChecked = checked;\n      } else {\n        input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);\n      }\n\n      this._layerControlInputs.push(input);\n\n      input.layerId = stamp(obj.layer);\n      on(input, 'click', this._onInputClick, this);\n      var name = document.createElement('span');\n      name.innerHTML = ' ' + obj.name; // Helps from preventing layer control flicker when checkboxes are disabled\n      // https://github.com/Leaflet/Leaflet/issues/2771\n\n      var holder = document.createElement('div');\n      label.appendChild(holder);\n      holder.appendChild(input);\n      holder.appendChild(name);\n      var container = obj.overlay ? this._overlaysList : this._baseLayersList;\n      container.appendChild(label);\n\n      this._checkDisabledLayers();\n\n      return label;\n    },\n    _onInputClick: function () {\n      var inputs = this._layerControlInputs,\n          input,\n          layer;\n      var addedLayers = [],\n          removedLayers = [];\n      this._handlingClick = true;\n\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n\n        if (input.checked) {\n          addedLayers.push(layer);\n        } else if (!input.checked) {\n          removedLayers.push(layer);\n        }\n      } // Bugfix issue 2318: Should remove all old layers before readding new ones\n\n\n      for (i = 0; i < removedLayers.length; i++) {\n        if (this._map.hasLayer(removedLayers[i])) {\n          this._map.removeLayer(removedLayers[i]);\n        }\n      }\n\n      for (i = 0; i < addedLayers.length; i++) {\n        if (!this._map.hasLayer(addedLayers[i])) {\n          this._map.addLayer(addedLayers[i]);\n        }\n      }\n\n      this._handlingClick = false;\n\n      this._refocusOnMap();\n    },\n    _checkDisabledLayers: function () {\n      var inputs = this._layerControlInputs,\n          input,\n          layer,\n          zoom = this._map.getZoom();\n\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n        input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;\n      }\n    },\n    _expandIfNotCollapsed: function () {\n      if (this._map && !this.options.collapsed) {\n        this.expand();\n      }\n\n      return this;\n    },\n    _expand: function () {\n      // Backward compatibility, remove me in 1.1.\n      return this.expand();\n    },\n    _collapse: function () {\n      // Backward compatibility, remove me in 1.1.\n      return this.collapse();\n    }\n  }); // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)\n  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.\n\n  var layers = function (baseLayers, overlays, options) {\n    return new Layers(baseLayers, overlays, options);\n  };\n  /*\r\n   * @class Control.Zoom\r\n   * @aka L.Control.Zoom\r\n   * @inherits Control\r\n   *\r\n   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.\r\n   */\n\n\n  var Zoom = Control.extend({\n    // @section\n    // @aka Control.Zoom options\n    options: {\n      position: 'topleft',\n      // @option zoomInText: String = '+'\n      // The text set on the 'zoom in' button.\n      zoomInText: '+',\n      // @option zoomInTitle: String = 'Zoom in'\n      // The title set on the 'zoom in' button.\n      zoomInTitle: 'Zoom in',\n      // @option zoomOutText: String = '&#x2212;'\n      // The text set on the 'zoom out' button.\n      zoomOutText: '&#x2212;',\n      // @option zoomOutTitle: String = 'Zoom out'\n      // The title set on the 'zoom out' button.\n      zoomOutTitle: 'Zoom out'\n    },\n    onAdd: function (map) {\n      var zoomName = 'leaflet-control-zoom',\n          container = create$1('div', zoomName + ' leaflet-bar'),\n          options = this.options;\n      this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);\n      this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);\n\n      this._updateDisabled();\n\n      map.on('zoomend zoomlevelschange', this._updateDisabled, this);\n      return container;\n    },\n    onRemove: function (map) {\n      map.off('zoomend zoomlevelschange', this._updateDisabled, this);\n    },\n    disable: function () {\n      this._disabled = true;\n\n      this._updateDisabled();\n\n      return this;\n    },\n    enable: function () {\n      this._disabled = false;\n\n      this._updateDisabled();\n\n      return this;\n    },\n    _zoomIn: function (e) {\n      if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {\n        this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _zoomOut: function (e) {\n      if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {\n        this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _createButton: function (html, title, className, container, fn) {\n      var link = create$1('a', className, container);\n      link.innerHTML = html;\n      link.href = '#';\n      link.title = title;\n      /*\r\n       * Will force screen readers like VoiceOver to read this as \"Zoom in - button\"\r\n       */\n\n      link.setAttribute('role', 'button');\n      link.setAttribute('aria-label', title);\n      disableClickPropagation(link);\n      on(link, 'click', stop);\n      on(link, 'click', fn, this);\n      on(link, 'click', this._refocusOnMap, this);\n      return link;\n    },\n    _updateDisabled: function () {\n      var map = this._map,\n          className = 'leaflet-disabled';\n      removeClass(this._zoomInButton, className);\n      removeClass(this._zoomOutButton, className);\n\n      if (this._disabled || map._zoom === map.getMinZoom()) {\n        addClass(this._zoomOutButton, className);\n      }\n\n      if (this._disabled || map._zoom === map.getMaxZoom()) {\n        addClass(this._zoomInButton, className);\n      }\n    }\n  }); // @namespace Map\n  // @section Control options\n  // @option zoomControl: Boolean = true\n  // Whether a [zoom control](#control-zoom) is added to the map by default.\n\n  Map.mergeOptions({\n    zoomControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.zoomControl) {\n      // @section Controls\n      // @property zoomControl: Control.Zoom\n      // The default zoom control (only available if the\n      // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).\n      this.zoomControl = new Zoom();\n      this.addControl(this.zoomControl);\n    }\n  }); // @namespace Control.Zoom\n  // @factory L.control.zoom(options: Control.Zoom options)\n  // Creates a zoom control\n\n  var zoom = function (options) {\n    return new Zoom(options);\n  };\n  /*\n   * @class Control.Scale\n   * @aka L.Control.Scale\n   * @inherits Control\n   *\n   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.\n   *\n   * @example\n   *\n   * ```js\n   * L.control.scale().addTo(map);\n   * ```\n   */\n\n\n  var Scale = Control.extend({\n    // @section\n    // @aka Control.Scale options\n    options: {\n      position: 'bottomleft',\n      // @option maxWidth: Number = 100\n      // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).\n      maxWidth: 100,\n      // @option metric: Boolean = True\n      // Whether to show the metric scale line (m/km).\n      metric: true,\n      // @option imperial: Boolean = True\n      // Whether to show the imperial scale line (mi/ft).\n      imperial: true // @option updateWhenIdle: Boolean = false\n      // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).\n\n    },\n    onAdd: function (map) {\n      var className = 'leaflet-control-scale',\n          container = create$1('div', className),\n          options = this.options;\n\n      this._addScales(options, className + '-line', container);\n\n      map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n      map.whenReady(this._update, this);\n      return container;\n    },\n    onRemove: function (map) {\n      map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n    },\n    _addScales: function (options, className, container) {\n      if (options.metric) {\n        this._mScale = create$1('div', className, container);\n      }\n\n      if (options.imperial) {\n        this._iScale = create$1('div', className, container);\n      }\n    },\n    _update: function () {\n      var map = this._map,\n          y = map.getSize().y / 2;\n      var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));\n\n      this._updateScales(maxMeters);\n    },\n    _updateScales: function (maxMeters) {\n      if (this.options.metric && maxMeters) {\n        this._updateMetric(maxMeters);\n      }\n\n      if (this.options.imperial && maxMeters) {\n        this._updateImperial(maxMeters);\n      }\n    },\n    _updateMetric: function (maxMeters) {\n      var meters = this._getRoundNum(maxMeters),\n          label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';\n\n      this._updateScale(this._mScale, label, meters / maxMeters);\n    },\n    _updateImperial: function (maxMeters) {\n      var maxFeet = maxMeters * 3.2808399,\n          maxMiles,\n          miles,\n          feet;\n\n      if (maxFeet > 5280) {\n        maxMiles = maxFeet / 5280;\n        miles = this._getRoundNum(maxMiles);\n\n        this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);\n      } else {\n        feet = this._getRoundNum(maxFeet);\n\n        this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);\n      }\n    },\n    _updateScale: function (scale, text, ratio) {\n      scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';\n      scale.innerHTML = text;\n    },\n    _getRoundNum: function (num) {\n      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n          d = num / pow10;\n      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n      return pow10 * d;\n    }\n  }); // @factory L.control.scale(options?: Control.Scale options)\n  // Creates an scale control with the given options.\n\n  var scale = function (options) {\n    return new Scale(options);\n  };\n  /*\r\n   * @class Control.Attribution\r\n   * @aka L.Control.Attribution\r\n   * @inherits Control\r\n   *\r\n   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.\r\n   */\n\n\n  var Attribution = Control.extend({\n    // @section\n    // @aka Control.Attribution options\n    options: {\n      position: 'bottomright',\n      // @option prefix: String = 'Leaflet'\n      // The HTML text shown before the attributions. Pass `false` to disable.\n      prefix: '<a href=\"https://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n      this._attributions = {};\n    },\n    onAdd: function (map) {\n      map.attributionControl = this;\n      this._container = create$1('div', 'leaflet-control-attribution');\n      disableClickPropagation(this._container); // TODO ugly, refactor\n\n      for (var i in map._layers) {\n        if (map._layers[i].getAttribution) {\n          this.addAttribution(map._layers[i].getAttribution());\n        }\n      }\n\n      this._update();\n\n      return this._container;\n    },\n    // @method setPrefix(prefix: String): this\n    // Sets the text before the attributions.\n    setPrefix: function (prefix) {\n      this.options.prefix = prefix;\n\n      this._update();\n\n      return this;\n    },\n    // @method addAttribution(text: String): this\n    // Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).\n    addAttribution: function (text) {\n      if (!text) {\n        return this;\n      }\n\n      if (!this._attributions[text]) {\n        this._attributions[text] = 0;\n      }\n\n      this._attributions[text]++;\n\n      this._update();\n\n      return this;\n    },\n    // @method removeAttribution(text: String): this\n    // Removes an attribution text.\n    removeAttribution: function (text) {\n      if (!text) {\n        return this;\n      }\n\n      if (this._attributions[text]) {\n        this._attributions[text]--;\n\n        this._update();\n      }\n\n      return this;\n    },\n    _update: function () {\n      if (!this._map) {\n        return;\n      }\n\n      var attribs = [];\n\n      for (var i in this._attributions) {\n        if (this._attributions[i]) {\n          attribs.push(i);\n        }\n      }\n\n      var prefixAndAttribs = [];\n\n      if (this.options.prefix) {\n        prefixAndAttribs.push(this.options.prefix);\n      }\n\n      if (attribs.length) {\n        prefixAndAttribs.push(attribs.join(', '));\n      }\n\n      this._container.innerHTML = prefixAndAttribs.join(' | ');\n    }\n  }); // @namespace Map\n  // @section Control options\n  // @option attributionControl: Boolean = true\n  // Whether a [attribution control](#control-attribution) is added to the map by default.\n\n  Map.mergeOptions({\n    attributionControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.attributionControl) {\n      new Attribution().addTo(this);\n    }\n  }); // @namespace Control.Attribution\n  // @factory L.control.attribution(options: Control.Attribution options)\n  // Creates an attribution control.\n\n  var attribution = function (options) {\n    return new Attribution(options);\n  };\n\n  Control.Layers = Layers;\n  Control.Zoom = Zoom;\n  Control.Scale = Scale;\n  Control.Attribution = Attribution;\n  control.layers = layers;\n  control.zoom = zoom;\n  control.scale = scale;\n  control.attribution = attribution;\n  /*\n  \tL.Handler is a base class for handler classes that are used internally to inject\n  \tinteraction features like dragging to classes like Map and Marker.\n  */\n  // @class Handler\n  // @aka L.Handler\n  // Abstract class for map interaction handlers\n\n  var Handler = Class.extend({\n    initialize: function (map) {\n      this._map = map;\n    },\n    // @method enable(): this\n    // Enables the handler\n    enable: function () {\n      if (this._enabled) {\n        return this;\n      }\n\n      this._enabled = true;\n      this.addHooks();\n      return this;\n    },\n    // @method disable(): this\n    // Disables the handler\n    disable: function () {\n      if (!this._enabled) {\n        return this;\n      }\n\n      this._enabled = false;\n      this.removeHooks();\n      return this;\n    },\n    // @method enabled(): Boolean\n    // Returns `true` if the handler is enabled\n    enabled: function () {\n      return !!this._enabled;\n    } // @section Extension methods\n    // Classes inheriting from `Handler` must implement the two following methods:\n    // @method addHooks()\n    // Called when the handler is enabled, should add event hooks.\n    // @method removeHooks()\n    // Called when the handler is disabled, should remove the event hooks added previously.\n\n  }); // @section There is static function which can be called without instantiating L.Handler:\n  // @function addTo(map: Map, name: String): this\n  // Adds a new Handler to the given map with the given name.\n\n  Handler.addTo = function (map, name) {\n    map.addHandler(name, this);\n    return this;\n  };\n\n  var Mixin = {\n    Events: Events\n  };\n  /*\r\n   * @class Draggable\r\n   * @aka L.Draggable\r\n   * @inherits Evented\r\n   *\r\n   * A class for making DOM elements draggable (including touch support).\r\n   * Used internally for map and marker dragging. Only works for elements\r\n   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * var draggable = new L.Draggable(elementToDrag);\r\n   * draggable.enable();\r\n   * ```\r\n   */\n\n  var START = touch ? 'touchstart mousedown' : 'mousedown';\n  var END = {\n    mousedown: 'mouseup',\n    touchstart: 'touchend',\n    pointerdown: 'touchend',\n    MSPointerDown: 'touchend'\n  };\n  var MOVE = {\n    mousedown: 'mousemove',\n    touchstart: 'touchmove',\n    pointerdown: 'touchmove',\n    MSPointerDown: 'touchmove'\n  };\n  var Draggable = Evented.extend({\n    options: {\n      // @section\n      // @aka Draggable options\n      // @option clickTolerance: Number = 3\n      // The max number of pixels a user can shift the mouse pointer during a click\n      // for it to be considered a valid click (as opposed to a mouse drag).\n      clickTolerance: 3\n    },\n    // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)\n    // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).\n    initialize: function (element, dragStartTarget, preventOutline$$1, options) {\n      setOptions(this, options);\n      this._element = element;\n      this._dragStartTarget = dragStartTarget || element;\n      this._preventOutline = preventOutline$$1;\n    },\n    // @method enable()\n    // Enables the dragging ability\n    enable: function () {\n      if (this._enabled) {\n        return;\n      }\n\n      on(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = true;\n    },\n    // @method disable()\n    // Disables the dragging ability\n    disable: function () {\n      if (!this._enabled) {\n        return;\n      } // If we're currently dragging this draggable,\n      // disabling it counts as first ending the drag.\n\n\n      if (Draggable._dragging === this) {\n        this.finishDrag();\n      }\n\n      off(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = false;\n      this._moved = false;\n    },\n    _onDown: function (e) {\n      // Ignore simulated events, since we handle both touch and\n      // mouse explicitly; otherwise we risk getting duplicates of\n      // touch events, see #4315.\n      // Also ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (e._simulated || !this._enabled) {\n        return;\n      }\n\n      this._moved = false;\n\n      if (hasClass(this._element, 'leaflet-zoom-anim')) {\n        return;\n      }\n\n      if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {\n        return;\n      }\n\n      Draggable._dragging = this; // Prevent dragging multiple objects at once.\n\n      if (this._preventOutline) {\n        preventOutline(this._element);\n      }\n\n      disableImageDrag();\n      disableTextSelection();\n\n      if (this._moving) {\n        return;\n      } // @event down: Event\n      // Fired when a drag is about to start.\n\n\n      this.fire('down');\n      var first = e.touches ? e.touches[0] : e,\n          sizedParent = getSizedParentNode(this._element);\n      this._startPoint = new Point(first.clientX, first.clientY); // Cache the scale, so that we can continuously compensate for it during drag (_onMove).\n\n      this._parentScale = getScale(sizedParent);\n      on(document, MOVE[e.type], this._onMove, this);\n      on(document, END[e.type], this._onUp, this);\n    },\n    _onMove: function (e) {\n      // Ignore simulated events, since we handle both touch and\n      // mouse explicitly; otherwise we risk getting duplicates of\n      // touch events, see #4315.\n      // Also ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (e._simulated || !this._enabled) {\n        return;\n      }\n\n      if (e.touches && e.touches.length > 1) {\n        this._moved = true;\n        return;\n      }\n\n      var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,\n          offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);\n\n      if (!offset.x && !offset.y) {\n        return;\n      }\n\n      if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {\n        return;\n      } // We assume that the parent container's position, border and scale do not change for the duration of the drag.\n      // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)\n      // and we can use the cached value for the scale.\n\n\n      offset.x /= this._parentScale.x;\n      offset.y /= this._parentScale.y;\n      preventDefault(e);\n\n      if (!this._moved) {\n        // @event dragstart: Event\n        // Fired when a drag starts\n        this.fire('dragstart');\n        this._moved = true;\n        this._startPos = getPosition(this._element).subtract(offset);\n        addClass(document.body, 'leaflet-dragging');\n        this._lastTarget = e.target || e.srcElement; // IE and Edge do not give the <use> element, so fetch it\n        // if necessary\n\n        if (window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance) {\n          this._lastTarget = this._lastTarget.correspondingUseElement;\n        }\n\n        addClass(this._lastTarget, 'leaflet-drag-target');\n      }\n\n      this._newPos = this._startPos.add(offset);\n      this._moving = true;\n      cancelAnimFrame(this._animRequest);\n      this._lastEvent = e;\n      this._animRequest = requestAnimFrame(this._updatePosition, this, true);\n    },\n    _updatePosition: function () {\n      var e = {\n        originalEvent: this._lastEvent\n      }; // @event predrag: Event\n      // Fired continuously during dragging *before* each corresponding\n      // update of the element's position.\n\n      this.fire('predrag', e);\n      setPosition(this._element, this._newPos); // @event drag: Event\n      // Fired continuously during dragging.\n\n      this.fire('drag', e);\n    },\n    _onUp: function (e) {\n      // Ignore simulated events, since we handle both touch and\n      // mouse explicitly; otherwise we risk getting duplicates of\n      // touch events, see #4315.\n      // Also ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (e._simulated || !this._enabled) {\n        return;\n      }\n\n      this.finishDrag();\n    },\n    finishDrag: function () {\n      removeClass(document.body, 'leaflet-dragging');\n\n      if (this._lastTarget) {\n        removeClass(this._lastTarget, 'leaflet-drag-target');\n        this._lastTarget = null;\n      }\n\n      for (var i in MOVE) {\n        off(document, MOVE[i], this._onMove, this);\n        off(document, END[i], this._onUp, this);\n      }\n\n      enableImageDrag();\n      enableTextSelection();\n\n      if (this._moved && this._moving) {\n        // ensure drag is not fired after dragend\n        cancelAnimFrame(this._animRequest); // @event dragend: DragEndEvent\n        // Fired when the drag ends.\n\n        this.fire('dragend', {\n          distance: this._newPos.distanceTo(this._startPos)\n        });\n      }\n\n      this._moving = false;\n      Draggable._dragging = false;\n    }\n  });\n  /*\r\n   * @namespace LineUtil\r\n   *\r\n   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.\r\n   */\n  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.\n  // Improves rendering performance dramatically by lessening the number of points to draw.\n  // @function simplify(points: Point[], tolerance: Number): Point[]\n  // Dramatically reduces the number of points in a polyline while retaining\n  // its shape and returns a new array of simplified points, using the\n  // [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).\n  // Used for a huge performance boost when processing/displaying Leaflet polylines for\n  // each zoom level and also reducing visual noise. tolerance affects the amount of\n  // simplification (lesser value means higher quality but slower and with more points).\n  // Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).\n\n  function simplify(points, tolerance) {\n    if (!tolerance || !points.length) {\n      return points.slice();\n    }\n\n    var sqTolerance = tolerance * tolerance; // stage 1: vertex reduction\n\n    points = _reducePoints(points, sqTolerance); // stage 2: Douglas-Peucker simplification\n\n    points = _simplifyDP(points, sqTolerance);\n    return points;\n  } // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number\n  // Returns the distance between point `p` and segment `p1` to `p2`.\n\n\n  function pointToSegmentDistance(p, p1, p2) {\n    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));\n  } // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number\n  // Returns the closest point from a point `p` on a segment `p1` to `p2`.\n\n\n  function closestPointOnSegment(p, p1, p2) {\n    return _sqClosestPointOnSegment(p, p1, p2);\n  } // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\n\n\n  function _simplifyDP(points, sqTolerance) {\n    var len = points.length,\n        ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\n        markers = new ArrayConstructor(len);\n    markers[0] = markers[len - 1] = 1;\n\n    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\n\n    var i,\n        newPoints = [];\n\n    for (i = 0; i < len; i++) {\n      if (markers[i]) {\n        newPoints.push(points[i]);\n      }\n    }\n\n    return newPoints;\n  }\n\n  function _simplifyDPStep(points, markers, sqTolerance, first, last) {\n    var maxSqDist = 0,\n        index,\n        i,\n        sqDist;\n\n    for (i = first + 1; i <= last - 1; i++) {\n      sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);\n\n      if (sqDist > maxSqDist) {\n        index = i;\n        maxSqDist = sqDist;\n      }\n    }\n\n    if (maxSqDist > sqTolerance) {\n      markers[index] = 1;\n\n      _simplifyDPStep(points, markers, sqTolerance, first, index);\n\n      _simplifyDPStep(points, markers, sqTolerance, index, last);\n    }\n  } // reduce points that are too close to each other to a single point\n\n\n  function _reducePoints(points, sqTolerance) {\n    var reducedPoints = [points[0]];\n\n    for (var i = 1, prev = 0, len = points.length; i < len; i++) {\n      if (_sqDist(points[i], points[prev]) > sqTolerance) {\n        reducedPoints.push(points[i]);\n        prev = i;\n      }\n    }\n\n    if (prev < len - 1) {\n      reducedPoints.push(points[len - 1]);\n    }\n\n    return reducedPoints;\n  }\n\n  var _lastCode; // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean\n  // Clips the segment a to b by rectangular bounds with the\n  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)\n  // (modifying the segment points directly!). Used by Leaflet to only show polyline\n  // points that are on the screen or near, increasing performance.\n\n\n  function clipSegment(a, b, bounds, useLastCode, round) {\n    var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),\n        codeB = _getBitCode(b, bounds),\n        codeOut,\n        p,\n        newCode; // save 2nd code to avoid calculating it on the next segment\n\n\n    _lastCode = codeB;\n\n    while (true) {\n      // if a,b is inside the clip window (trivial accept)\n      if (!(codeA | codeB)) {\n        return [a, b];\n      } // if a,b is outside the clip window (trivial reject)\n\n\n      if (codeA & codeB) {\n        return false;\n      } // other cases\n\n\n      codeOut = codeA || codeB;\n      p = _getEdgeIntersection(a, b, codeOut, bounds, round);\n      newCode = _getBitCode(p, bounds);\n\n      if (codeOut === codeA) {\n        a = p;\n        codeA = newCode;\n      } else {\n        b = p;\n        codeB = newCode;\n      }\n    }\n  }\n\n  function _getEdgeIntersection(a, b, code, bounds, round) {\n    var dx = b.x - a.x,\n        dy = b.y - a.y,\n        min = bounds.min,\n        max = bounds.max,\n        x,\n        y;\n\n    if (code & 8) {\n      // top\n      x = a.x + dx * (max.y - a.y) / dy;\n      y = max.y;\n    } else if (code & 4) {\n      // bottom\n      x = a.x + dx * (min.y - a.y) / dy;\n      y = min.y;\n    } else if (code & 2) {\n      // right\n      x = max.x;\n      y = a.y + dy * (max.x - a.x) / dx;\n    } else if (code & 1) {\n      // left\n      x = min.x;\n      y = a.y + dy * (min.x - a.x) / dx;\n    }\n\n    return new Point(x, y, round);\n  }\n\n  function _getBitCode(p, bounds) {\n    var code = 0;\n\n    if (p.x < bounds.min.x) {\n      // left\n      code |= 1;\n    } else if (p.x > bounds.max.x) {\n      // right\n      code |= 2;\n    }\n\n    if (p.y < bounds.min.y) {\n      // bottom\n      code |= 4;\n    } else if (p.y > bounds.max.y) {\n      // top\n      code |= 8;\n    }\n\n    return code;\n  } // square distance (to avoid unnecessary Math.sqrt calls)\n\n\n  function _sqDist(p1, p2) {\n    var dx = p2.x - p1.x,\n        dy = p2.y - p1.y;\n    return dx * dx + dy * dy;\n  } // return closest point on segment or distance to that point\n\n\n  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\n    var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y,\n        dot = dx * dx + dy * dy,\n        t;\n\n    if (dot > 0) {\n      t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n\n      if (t > 1) {\n        x = p2.x;\n        y = p2.y;\n      } else if (t > 0) {\n        x += dx * t;\n        y += dy * t;\n      }\n    }\n\n    dx = p.x - x;\n    dy = p.y - y;\n    return sqDist ? dx * dx + dy * dy : new Point(x, y);\n  } // @function isFlat(latlngs: LatLng[]): Boolean\n  // Returns true if `latlngs` is a flat array, false is nested.\n\n\n  function isFlat(latlngs) {\n    return !isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';\n  }\n\n  function _flat(latlngs) {\n    console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');\n    return isFlat(latlngs);\n  }\n\n  var LineUtil = (Object.freeze || Object)({\n    simplify: simplify,\n    pointToSegmentDistance: pointToSegmentDistance,\n    closestPointOnSegment: closestPointOnSegment,\n    clipSegment: clipSegment,\n    _getEdgeIntersection: _getEdgeIntersection,\n    _getBitCode: _getBitCode,\n    _sqClosestPointOnSegment: _sqClosestPointOnSegment,\n    isFlat: isFlat,\n    _flat: _flat\n  });\n  /*\r\n   * @namespace PolyUtil\r\n   * Various utility functions for polygon geometries.\r\n   */\n\n  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]\r\n   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).\r\n   * Used by Leaflet to only show polygon points that are on the screen or near, increasing\r\n   * performance. Note that polygon points needs different algorithm for clipping\r\n   * than polyline, so there's a separate method for it.\r\n   */\n\n  function clipPolygon(points, bounds, round) {\n    var clippedPoints,\n        edges = [1, 4, 2, 8],\n        i,\n        j,\n        k,\n        a,\n        b,\n        len,\n        edge,\n        p;\n\n    for (i = 0, len = points.length; i < len; i++) {\n      points[i]._code = _getBitCode(points[i], bounds);\n    } // for each edge (left, bottom, right, top)\n\n\n    for (k = 0; k < 4; k++) {\n      edge = edges[k];\n      clippedPoints = [];\n\n      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        a = points[i];\n        b = points[j]; // if a is inside the clip window\n\n        if (!(a._code & edge)) {\n          // if b is outside the clip window (a->b goes out of screen)\n          if (b._code & edge) {\n            p = _getEdgeIntersection(b, a, edge, bounds, round);\n            p._code = _getBitCode(p, bounds);\n            clippedPoints.push(p);\n          }\n\n          clippedPoints.push(a); // else if b is inside the clip window (a->b enters the screen)\n        } else if (!(b._code & edge)) {\n          p = _getEdgeIntersection(b, a, edge, bounds, round);\n          p._code = _getBitCode(p, bounds);\n          clippedPoints.push(p);\n        }\n      }\n\n      points = clippedPoints;\n    }\n\n    return points;\n  }\n\n  var PolyUtil = (Object.freeze || Object)({\n    clipPolygon: clipPolygon\n  });\n  /*\r\n   * @namespace Projection\r\n   * @section\r\n   * Leaflet comes with a set of already defined Projections out of the box:\r\n   *\r\n   * @projection L.Projection.LonLat\r\n   *\r\n   * Equirectangular, or Plate Carree projection — the most simple projection,\r\n   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as\r\n   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the\r\n   * `EPSG:4326` and `Simple` CRS.\r\n   */\n\n  var LonLat = {\n    project: function (latlng) {\n      return new Point(latlng.lng, latlng.lat);\n    },\n    unproject: function (point) {\n      return new LatLng(point.y, point.x);\n    },\n    bounds: new Bounds([-180, -90], [180, 90])\n  };\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.Mercator\r\n   *\r\n   * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.\r\n   */\n\n  var Mercator = {\n    R: 6378137,\n    R_MINOR: 6356752.314245179,\n    bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),\n    project: function (latlng) {\n      var d = Math.PI / 180,\n          r = this.R,\n          y = latlng.lat * d,\n          tmp = this.R_MINOR / r,\n          e = Math.sqrt(1 - tmp * tmp),\n          con = e * Math.sin(y);\n      var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\n      y = -r * Math.log(Math.max(ts, 1E-10));\n      return new Point(latlng.lng * d * r, y);\n    },\n    unproject: function (point) {\n      var d = 180 / Math.PI,\n          r = this.R,\n          tmp = this.R_MINOR / r,\n          e = Math.sqrt(1 - tmp * tmp),\n          ts = Math.exp(-point.y / r),\n          phi = Math.PI / 2 - 2 * Math.atan(ts);\n\n      for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {\n        con = e * Math.sin(phi);\n        con = Math.pow((1 - con) / (1 + con), e / 2);\n        dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\n        phi += dphi;\n      }\n\n      return new LatLng(phi * d, point.x * d / r);\n    }\n  };\n  /*\n   * @class Projection\n  \n   * An object with methods for projecting geographical coordinates of the world onto\n   * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).\n  \n   * @property bounds: Bounds\n   * The bounds (specified in CRS units) where the projection is valid\n  \n   * @method project(latlng: LatLng): Point\n   * Projects geographical coordinates into a 2D point.\n   * Only accepts actual `L.LatLng` instances, not arrays.\n  \n   * @method unproject(point: Point): LatLng\n   * The inverse of `project`. Projects a 2D point into a geographical location.\n   * Only accepts actual `L.Point` instances, not arrays.\n  \n   * Note that the projection instances do not inherit from Leafet's `Class` object,\n   * and can't be instantiated. Also, new classes can't inherit from them,\n   * and methods can't be added to them with the `include` function.\n  \n   */\n\n  var index = (Object.freeze || Object)({\n    LonLat: LonLat,\n    Mercator: Mercator,\n    SphericalMercator: SphericalMercator\n  });\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3395\r\n   *\r\n   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.\r\n   */\n\n  var EPSG3395 = extend({}, Earth, {\n    code: 'EPSG:3395',\n    projection: Mercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * Mercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG4326\r\n   *\r\n   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\r\n   *\r\n   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),\r\n   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`\r\n   * with this CRS, ensure that there are two 256x256 pixel tiles covering the\r\n   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),\r\n   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.\r\n   */\n\n  var EPSG4326 = extend({}, Earth, {\n    code: 'EPSG:4326',\n    projection: LonLat,\n    transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)\n  });\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Simple\n   *\n   * A simple CRS that maps longitude and latitude into `x` and `y` directly.\n   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`\n   * axis should still be inverted (going from bottom to top). `distance()` returns\n   * simple euclidean distance.\n   */\n\n  var Simple = extend({}, CRS, {\n    projection: LonLat,\n    transformation: toTransformation(1, 0, -1, 0),\n    scale: function (zoom) {\n      return Math.pow(2, zoom);\n    },\n    zoom: function (scale) {\n      return Math.log(scale) / Math.LN2;\n    },\n    distance: function (latlng1, latlng2) {\n      var dx = latlng2.lng - latlng1.lng,\n          dy = latlng2.lat - latlng1.lat;\n      return Math.sqrt(dx * dx + dy * dy);\n    },\n    infinite: true\n  });\n  CRS.Earth = Earth;\n  CRS.EPSG3395 = EPSG3395;\n  CRS.EPSG3857 = EPSG3857;\n  CRS.EPSG900913 = EPSG900913;\n  CRS.EPSG4326 = EPSG4326;\n  CRS.Simple = Simple;\n  /*\n   * @class Layer\n   * @inherits Evented\n   * @aka L.Layer\n   * @aka ILayer\n   *\n   * A set of methods from the Layer base class that all Leaflet layers use.\n   * Inherits all methods, options and events from `L.Evented`.\n   *\n   * @example\n   *\n   * ```js\n   * var layer = L.marker(latlng).addTo(map);\n   * layer.addTo(map);\n   * layer.remove();\n   * ```\n   *\n   * @event add: Event\n   * Fired after the layer is added to a map\n   *\n   * @event remove: Event\n   * Fired after the layer is removed from a map\n   */\n\n  var Layer = Evented.extend({\n    // Classes extending `L.Layer` will inherit the following options:\n    options: {\n      // @option pane: String = 'overlayPane'\n      // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.\n      pane: 'overlayPane',\n      // @option attribution: String = null\n      // String to be shown in the attribution control, e.g. \"© OpenStreetMap contributors\". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.\n      attribution: null,\n      bubblingMouseEvents: true\n    },\n\n    /* @section\n     * Classes extending `L.Layer` will inherit the following methods:\n     *\n     * @method addTo(map: Map|LayerGroup): this\n     * Adds the layer to the given map or layer group.\n     */\n    addTo: function (map) {\n      map.addLayer(this);\n      return this;\n    },\n    // @method remove: this\n    // Removes the layer from the map it is currently active on.\n    remove: function () {\n      return this.removeFrom(this._map || this._mapToAdd);\n    },\n    // @method removeFrom(map: Map): this\n    // Removes the layer from the given map\n    removeFrom: function (obj) {\n      if (obj) {\n        obj.removeLayer(this);\n      }\n\n      return this;\n    },\n    // @method getPane(name? : String): HTMLElement\n    // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.\n    getPane: function (name) {\n      return this._map.getPane(name ? this.options[name] || name : this.options.pane);\n    },\n    addInteractiveTarget: function (targetEl) {\n      this._map._targets[stamp(targetEl)] = this;\n      return this;\n    },\n    removeInteractiveTarget: function (targetEl) {\n      delete this._map._targets[stamp(targetEl)];\n      return this;\n    },\n    // @method getAttribution: String\n    // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).\n    getAttribution: function () {\n      return this.options.attribution;\n    },\n    _layerAdd: function (e) {\n      var map = e.target; // check in case layer gets added and then removed before the map is ready\n\n      if (!map.hasLayer(this)) {\n        return;\n      }\n\n      this._map = map;\n      this._zoomAnimated = map._zoomAnimated;\n\n      if (this.getEvents) {\n        var events = this.getEvents();\n        map.on(events, this);\n        this.once('remove', function () {\n          map.off(events, this);\n        }, this);\n      }\n\n      this.onAdd(map);\n\n      if (this.getAttribution && map.attributionControl) {\n        map.attributionControl.addAttribution(this.getAttribution());\n      }\n\n      this.fire('add');\n      map.fire('layeradd', {\n        layer: this\n      });\n    }\n  });\n  /* @section Extension methods\n   * @uninheritable\n   *\n   * Every layer should extend from `L.Layer` and (re-)implement the following methods.\n   *\n   * @method onAdd(map: Map): this\n   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).\n   *\n   * @method onRemove(map: Map): this\n   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).\n   *\n   * @method getEvents(): Object\n   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.\n   *\n   * @method getAttribution(): String\n   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.\n   *\n   * @method beforeAdd(map: Map): this\n   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.\n   */\n\n  /* @namespace Map\n   * @section Layer events\n   *\n   * @event layeradd: LayerEvent\n   * Fired when a new layer is added to the map.\n   *\n   * @event layerremove: LayerEvent\n   * Fired when some layer is removed from the map\n   *\n   * @section Methods for Layers and Controls\n   */\n\n  Map.include({\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the map\n    addLayer: function (layer) {\n      if (!layer._layerAdd) {\n        throw new Error('The provided object is not a Layer.');\n      }\n\n      var id = stamp(layer);\n\n      if (this._layers[id]) {\n        return this;\n      }\n\n      this._layers[id] = layer;\n      layer._mapToAdd = this;\n\n      if (layer.beforeAdd) {\n        layer.beforeAdd(this);\n      }\n\n      this.whenReady(layer._layerAdd, layer);\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the map.\n    removeLayer: function (layer) {\n      var id = stamp(layer);\n\n      if (!this._layers[id]) {\n        return this;\n      }\n\n      if (this._loaded) {\n        layer.onRemove(this);\n      }\n\n      if (layer.getAttribution && this.attributionControl) {\n        this.attributionControl.removeAttribution(layer.getAttribution());\n      }\n\n      delete this._layers[id];\n\n      if (this._loaded) {\n        this.fire('layerremove', {\n          layer: layer\n        });\n        layer.fire('remove');\n      }\n\n      layer._map = layer._mapToAdd = null;\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the map\n    hasLayer: function (layer) {\n      return !!layer && stamp(layer) in this._layers;\n    },\n\n    /* @method eachLayer(fn: Function, context?: Object): this\n     * Iterates over the layers of the map, optionally specifying context of the iterator function.\n     * ```\n     * map.eachLayer(function(layer){\n     *     layer.bindPopup('Hello');\n     * });\n     * ```\n     */\n    eachLayer: function (method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n\n      return this;\n    },\n    _addLayers: function (layers) {\n      layers = layers ? isArray(layers) ? layers : [layers] : [];\n\n      for (var i = 0, len = layers.length; i < len; i++) {\n        this.addLayer(layers[i]);\n      }\n    },\n    _addZoomLimit: function (layer) {\n      if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n        this._zoomBoundLayers[stamp(layer)] = layer;\n\n        this._updateZoomLevels();\n      }\n    },\n    _removeZoomLimit: function (layer) {\n      var id = stamp(layer);\n\n      if (this._zoomBoundLayers[id]) {\n        delete this._zoomBoundLayers[id];\n\n        this._updateZoomLevels();\n      }\n    },\n    _updateZoomLevels: function () {\n      var minZoom = Infinity,\n          maxZoom = -Infinity,\n          oldZoomSpan = this._getZoomSpan();\n\n      for (var i in this._zoomBoundLayers) {\n        var options = this._zoomBoundLayers[i].options;\n        minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n        maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n      }\n\n      this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n      this._layersMinZoom = minZoom === Infinity ? undefined : minZoom; // @section Map state change events\n      // @event zoomlevelschange: Event\n      // Fired when the number of zoomlevels on the map is changed due\n      // to adding or removing a layer.\n\n      if (oldZoomSpan !== this._getZoomSpan()) {\n        this.fire('zoomlevelschange');\n      }\n\n      if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {\n        this.setZoom(this._layersMaxZoom);\n      }\n\n      if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {\n        this.setZoom(this._layersMinZoom);\n      }\n    }\n  });\n  /*\r\n   * @class LayerGroup\r\n   * @aka L.LayerGroup\r\n   * @inherits Layer\r\n   *\r\n   * Used to group several layers and handle them as one. If you add it to the map,\r\n   * any layers added or removed from the group will be added/removed on the map as\r\n   * well. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.layerGroup([marker1, marker2])\r\n   * \t.addLayer(polyline)\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n  var LayerGroup = Layer.extend({\n    initialize: function (layers, options) {\n      setOptions(this, options);\n      this._layers = {};\n      var i, len;\n\n      if (layers) {\n        for (i = 0, len = layers.length; i < len; i++) {\n          this.addLayer(layers[i]);\n        }\n      }\n    },\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the group.\n    addLayer: function (layer) {\n      var id = this.getLayerId(layer);\n      this._layers[id] = layer;\n\n      if (this._map) {\n        this._map.addLayer(layer);\n      }\n\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the group.\n    // @alternative\n    // @method removeLayer(id: Number): this\n    // Removes the layer with the given internal ID from the group.\n    removeLayer: function (layer) {\n      var id = layer in this._layers ? layer : this.getLayerId(layer);\n\n      if (this._map && this._layers[id]) {\n        this._map.removeLayer(this._layers[id]);\n      }\n\n      delete this._layers[id];\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the group.\n    // @alternative\n    // @method hasLayer(id: Number): Boolean\n    // Returns `true` if the given internal ID is currently added to the group.\n    hasLayer: function (layer) {\n      return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);\n    },\n    // @method clearLayers(): this\n    // Removes all the layers from the group.\n    clearLayers: function () {\n      return this.eachLayer(this.removeLayer, this);\n    },\n    // @method invoke(methodName: String, …): this\n    // Calls `methodName` on every layer contained in this group, passing any\n    // additional parameters. Has no effect if the layers contained do not\n    // implement `methodName`.\n    invoke: function (methodName) {\n      var args = Array.prototype.slice.call(arguments, 1),\n          i,\n          layer;\n\n      for (i in this._layers) {\n        layer = this._layers[i];\n\n        if (layer[methodName]) {\n          layer[methodName].apply(layer, args);\n        }\n      }\n\n      return this;\n    },\n    onAdd: function (map) {\n      this.eachLayer(map.addLayer, map);\n    },\n    onRemove: function (map) {\n      this.eachLayer(map.removeLayer, map);\n    },\n    // @method eachLayer(fn: Function, context?: Object): this\n    // Iterates over the layers of the group, optionally specifying context of the iterator function.\n    // ```js\n    // group.eachLayer(function (layer) {\n    // \tlayer.bindPopup('Hello');\n    // });\n    // ```\n    eachLayer: function (method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n\n      return this;\n    },\n    // @method getLayer(id: Number): Layer\n    // Returns the layer with the given internal ID.\n    getLayer: function (id) {\n      return this._layers[id];\n    },\n    // @method getLayers(): Layer[]\n    // Returns an array of all the layers added to the group.\n    getLayers: function () {\n      var layers = [];\n      this.eachLayer(layers.push, layers);\n      return layers;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Calls `setZIndex` on every layer contained in this group, passing the z-index.\n    setZIndex: function (zIndex) {\n      return this.invoke('setZIndex', zIndex);\n    },\n    // @method getLayerId(layer: Layer): Number\n    // Returns the internal ID for a layer\n    getLayerId: function (layer) {\n      return stamp(layer);\n    }\n  }); // @factory L.layerGroup(layers?: Layer[], options?: Object)\n  // Create a layer group, optionally given an initial set of layers and an `options` object.\n\n  var layerGroup = function (layers, options) {\n    return new LayerGroup(layers, options);\n  };\n  /*\r\n   * @class FeatureGroup\r\n   * @aka L.FeatureGroup\r\n   * @inherits LayerGroup\r\n   *\r\n   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:\r\n   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))\r\n   *  * Events are propagated to the `FeatureGroup`, so if the group has an event\r\n   * handler, it will handle events from any of the layers. This includes mouse events\r\n   * and custom events.\r\n   *  * Has `layeradd` and `layerremove` events\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.featureGroup([marker1, marker2, polyline])\r\n   * \t.bindPopup('Hello world!')\r\n   * \t.on('click', function() { alert('Clicked on a member of the group!'); })\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n\n  var FeatureGroup = LayerGroup.extend({\n    addLayer: function (layer) {\n      if (this.hasLayer(layer)) {\n        return this;\n      }\n\n      layer.addEventParent(this);\n      LayerGroup.prototype.addLayer.call(this, layer); // @event layeradd: LayerEvent\n      // Fired when a layer is added to this `FeatureGroup`\n\n      return this.fire('layeradd', {\n        layer: layer\n      });\n    },\n    removeLayer: function (layer) {\n      if (!this.hasLayer(layer)) {\n        return this;\n      }\n\n      if (layer in this._layers) {\n        layer = this._layers[layer];\n      }\n\n      layer.removeEventParent(this);\n      LayerGroup.prototype.removeLayer.call(this, layer); // @event layerremove: LayerEvent\n      // Fired when a layer is removed from this `FeatureGroup`\n\n      return this.fire('layerremove', {\n        layer: layer\n      });\n    },\n    // @method setStyle(style: Path options): this\n    // Sets the given path options to each layer of the group that has a `setStyle` method.\n    setStyle: function (style) {\n      return this.invoke('setStyle', style);\n    },\n    // @method bringToFront(): this\n    // Brings the layer group to the top of all other layers\n    bringToFront: function () {\n      return this.invoke('bringToFront');\n    },\n    // @method bringToBack(): this\n    // Brings the layer group to the back of all other layers\n    bringToBack: function () {\n      return this.invoke('bringToBack');\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).\n    getBounds: function () {\n      var bounds = new LatLngBounds();\n\n      for (var id in this._layers) {\n        var layer = this._layers[id];\n        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\n      }\n\n      return bounds;\n    }\n  }); // @factory L.featureGroup(layers: Layer[])\n  // Create a feature group, optionally given an initial set of layers.\n\n  var featureGroup = function (layers) {\n    return new FeatureGroup(layers);\n  };\n  /*\r\n   * @class Icon\r\n   * @aka L.Icon\r\n   *\r\n   * Represents an icon to provide when creating a marker.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var myIcon = L.icon({\r\n   *     iconUrl: 'my-icon.png',\r\n   *     iconRetinaUrl: 'my-icon@2x.png',\r\n   *     iconSize: [38, 95],\r\n   *     iconAnchor: [22, 94],\r\n   *     popupAnchor: [-3, -76],\r\n   *     shadowUrl: 'my-icon-shadow.png',\r\n   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',\r\n   *     shadowSize: [68, 95],\r\n   *     shadowAnchor: [22, 94]\r\n   * });\r\n   *\r\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\r\n   * ```\r\n   *\r\n   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.\r\n   *\r\n   */\n\n\n  var Icon = Class.extend({\n    /* @section\r\n     * @aka Icon options\r\n     *\r\n     * @option iconUrl: String = null\r\n     * **(required)** The URL to the icon image (absolute or relative to your script path).\r\n     *\r\n     * @option iconRetinaUrl: String = null\r\n     * The URL to a retina sized version of the icon image (absolute or relative to your\r\n     * script path). Used for Retina screen devices.\r\n     *\r\n     * @option iconSize: Point = null\r\n     * Size of the icon image in pixels.\r\n     *\r\n     * @option iconAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the icon (relative to its top left corner). The icon\r\n     * will be aligned so that this point is at the marker's geographical location. Centered\r\n     * by default if size is specified, also can be set in CSS with negative margins.\r\n     *\r\n     * @option popupAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which popups will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option tooltipAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which tooltips will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option shadowUrl: String = null\r\n     * The URL to the icon shadow image. If not specified, no shadow image will be created.\r\n     *\r\n     * @option shadowRetinaUrl: String = null\r\n     *\r\n     * @option shadowSize: Point = null\r\n     * Size of the shadow image in pixels.\r\n     *\r\n     * @option shadowAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the shadow (relative to its top left corner) (the same\r\n     * as iconAnchor if not specified).\r\n     *\r\n     * @option className: String = ''\r\n     * A custom class name to assign to both icon and shadow images. Empty by default.\r\n     */\n    options: {\n      popupAnchor: [0, 0],\n      tooltipAnchor: [0, 0]\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    // @method createIcon(oldIcon?: HTMLElement): HTMLElement\n    // Called internally when the icon has to be shown, returns a `<img>` HTML element\n    // styled according to the options.\n    createIcon: function (oldIcon) {\n      return this._createIcon('icon', oldIcon);\n    },\n    // @method createShadow(oldIcon?: HTMLElement): HTMLElement\n    // As `createIcon`, but for the shadow beneath it.\n    createShadow: function (oldIcon) {\n      return this._createIcon('shadow', oldIcon);\n    },\n    _createIcon: function (name, oldIcon) {\n      var src = this._getIconUrl(name);\n\n      if (!src) {\n        if (name === 'icon') {\n          throw new Error('iconUrl not set in Icon options (see the docs).');\n        }\n\n        return null;\n      }\n\n      var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);\n\n      this._setIconStyles(img, name);\n\n      return img;\n    },\n    _setIconStyles: function (img, name) {\n      var options = this.options;\n      var sizeOption = options[name + 'Size'];\n\n      if (typeof sizeOption === 'number') {\n        sizeOption = [sizeOption, sizeOption];\n      }\n\n      var size = toPoint(sizeOption),\n          anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));\n      img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\n\n      if (anchor) {\n        img.style.marginLeft = -anchor.x + 'px';\n        img.style.marginTop = -anchor.y + 'px';\n      }\n\n      if (size) {\n        img.style.width = size.x + 'px';\n        img.style.height = size.y + 'px';\n      }\n    },\n    _createImg: function (src, el) {\n      el = el || document.createElement('img');\n      el.src = src;\n      return el;\n    },\n    _getIconUrl: function (name) {\n      return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];\n    }\n  }); // @factory L.icon(options: Icon options)\n  // Creates an icon instance with the given options.\n\n  function icon(options) {\n    return new Icon(options);\n  }\n  /*\n   * @miniclass Icon.Default (Icon)\n   * @aka L.Icon.Default\n   * @section\n   *\n   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when\n   * no icon is specified. Points to the blue marker image distributed with Leaflet\n   * releases.\n   *\n   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`\n   * (which is a set of `Icon options`).\n   *\n   * If you want to _completely_ replace the default icon, override the\n   * `L.Marker.prototype.options.icon` with your own icon instead.\n   */\n\n\n  var IconDefault = Icon.extend({\n    options: {\n      iconUrl: 'marker-icon.png',\n      iconRetinaUrl: 'marker-icon-2x.png',\n      shadowUrl: 'marker-shadow.png',\n      iconSize: [25, 41],\n      iconAnchor: [12, 41],\n      popupAnchor: [1, -34],\n      tooltipAnchor: [16, -28],\n      shadowSize: [41, 41]\n    },\n    _getIconUrl: function (name) {\n      if (!IconDefault.imagePath) {\n        // Deprecated, backwards-compatibility only\n        IconDefault.imagePath = this._detectIconPath();\n      } // @option imagePath: String\n      // `Icon.Default` will try to auto-detect the location of the\n      // blue icon images. If you are placing these images in a non-standard\n      // way, set this option to point to the right path.\n\n\n      return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);\n    },\n    _detectIconPath: function () {\n      var el = create$1('div', 'leaflet-default-icon-path', document.body);\n      var path = getStyle(el, 'background-image') || getStyle(el, 'backgroundImage'); // IE8\n\n      document.body.removeChild(el);\n\n      if (path === null || path.indexOf('url') !== 0) {\n        path = '';\n      } else {\n        path = path.replace(/^url\\([\"']?/, '').replace(/marker-icon\\.png[\"']?\\)$/, '');\n      }\n\n      return path;\n    }\n  });\n  /*\n   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n   */\n\n  /* @namespace Marker\n   * @section Interaction handlers\n   *\n   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:\n   *\n   * ```js\n   * marker.dragging.disable();\n   * ```\n   *\n   * @property dragging: Handler\n   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).\n   */\n\n  var MarkerDrag = Handler.extend({\n    initialize: function (marker) {\n      this._marker = marker;\n    },\n    addHooks: function () {\n      var icon = this._marker._icon;\n\n      if (!this._draggable) {\n        this._draggable = new Draggable(icon, icon, true);\n      }\n\n      this._draggable.on({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).enable();\n\n      addClass(icon, 'leaflet-marker-draggable');\n    },\n    removeHooks: function () {\n      this._draggable.off({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).disable();\n\n      if (this._marker._icon) {\n        removeClass(this._marker._icon, 'leaflet-marker-draggable');\n      }\n    },\n    moved: function () {\n      return this._draggable && this._draggable._moved;\n    },\n    _adjustPan: function (e) {\n      var marker = this._marker,\n          map = marker._map,\n          speed = this._marker.options.autoPanSpeed,\n          padding = this._marker.options.autoPanPadding,\n          iconPos = getPosition(marker._icon),\n          bounds = map.getPixelBounds(),\n          origin = map.getPixelOrigin();\n      var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));\n\n      if (!panBounds.contains(iconPos)) {\n        // Compute incremental movement\n        var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);\n        map.panBy(movement, {\n          animate: false\n        });\n\n        this._draggable._newPos._add(movement);\n\n        this._draggable._startPos._add(movement);\n\n        setPosition(marker._icon, this._draggable._newPos);\n\n        this._onDrag(e);\n\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDragStart: function () {\n      // @section Dragging events\n      // @event dragstart: Event\n      // Fired when the user starts dragging the marker.\n      // @event movestart: Event\n      // Fired when the marker starts moving (because of dragging).\n      this._oldLatLng = this._marker.getLatLng();\n\n      this._marker.closePopup().fire('movestart').fire('dragstart');\n    },\n    _onPreDrag: function (e) {\n      if (this._marker.options.autoPan) {\n        cancelAnimFrame(this._panRequest);\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDrag: function (e) {\n      var marker = this._marker,\n          shadow = marker._shadow,\n          iconPos = getPosition(marker._icon),\n          latlng = marker._map.layerPointToLatLng(iconPos); // update shadow position\n\n\n      if (shadow) {\n        setPosition(shadow, iconPos);\n      }\n\n      marker._latlng = latlng;\n      e.latlng = latlng;\n      e.oldLatLng = this._oldLatLng; // @event drag: Event\n      // Fired repeatedly while the user drags the marker.\n\n      marker.fire('move', e).fire('drag', e);\n    },\n    _onDragEnd: function (e) {\n      // @event dragend: DragEndEvent\n      // Fired when the user stops dragging the marker.\n      cancelAnimFrame(this._panRequest); // @event moveend: Event\n      // Fired when the marker stops moving (because of dragging).\n\n      delete this._oldLatLng;\n\n      this._marker.fire('moveend').fire('dragend', e);\n    }\n  });\n  /*\r\n   * @class Marker\r\n   * @inherits Interactive layer\r\n   * @aka L.Marker\r\n   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.marker([50.5, 30.5]).addTo(map);\r\n   * ```\r\n   */\n\n  var Marker = Layer.extend({\n    // @section\n    // @aka Marker options\n    options: {\n      // @option icon: Icon = *\n      // Icon instance to use for rendering the marker.\n      // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.\n      // If not specified, a common instance of `L.Icon.Default` is used.\n      icon: new IconDefault(),\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option keyboard: Boolean = true\n      // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.\n      keyboard: true,\n      // @option title: String = ''\n      // Text for the browser tooltip that appear on marker hover (no tooltip by default).\n      title: '',\n      // @option alt: String = ''\n      // Text for the `alt` attribute of the icon image (useful for accessibility).\n      alt: '',\n      // @option zIndexOffset: Number = 0\n      // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).\n      zIndexOffset: 0,\n      // @option opacity: Number = 1.0\n      // The opacity of the marker.\n      opacity: 1,\n      // @option riseOnHover: Boolean = false\n      // If `true`, the marker will get on top of others when you hover the mouse over it.\n      riseOnHover: false,\n      // @option riseOffset: Number = 250\n      // The z-index offset used for the `riseOnHover` feature.\n      riseOffset: 250,\n      // @option pane: String = 'markerPane'\n      // `Map pane` where the markers icon will be added.\n      pane: 'markerPane',\n      // @option pane: String = 'shadowPane'\n      // `Map pane` where the markers shadow will be added.\n      shadowPane: 'shadowPane',\n      // @option bubblingMouseEvents: Boolean = false\n      // When `true`, a mouse event on this marker will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: false,\n      // @section Draggable marker options\n      // @option draggable: Boolean = false\n      // Whether the marker is draggable with mouse/touch or not.\n      draggable: false,\n      // @option autoPan: Boolean = false\n      // Whether to pan the map when dragging this marker near its edge or not.\n      autoPan: false,\n      // @option autoPanPadding: Point = Point(50, 50)\n      // Distance (in pixels to the left/right and to the top/bottom) of the\n      // map edge to start panning the map.\n      autoPanPadding: [50, 50],\n      // @option autoPanSpeed: Number = 10\n      // Number of pixels the map should pan by.\n      autoPanSpeed: 10\n    },\n\n    /* @section\r\n     *\r\n     * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:\r\n     */\n    initialize: function (latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n    },\n    onAdd: function (map) {\n      this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\n\n      if (this._zoomAnimated) {\n        map.on('zoomanim', this._animateZoom, this);\n      }\n\n      this._initIcon();\n\n      this.update();\n    },\n    onRemove: function (map) {\n      if (this.dragging && this.dragging.enabled()) {\n        this.options.draggable = true;\n        this.dragging.removeHooks();\n      }\n\n      delete this.dragging;\n\n      if (this._zoomAnimated) {\n        map.off('zoomanim', this._animateZoom, this);\n      }\n\n      this._removeIcon();\n\n      this._removeShadow();\n    },\n    getEvents: function () {\n      return {\n        zoom: this.update,\n        viewreset: this.update\n      };\n    },\n    // @method getLatLng: LatLng\n    // Returns the current geographical position of the marker.\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Changes the marker position to the given point.\n    setLatLng: function (latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.update(); // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method setZIndexOffset(offset: Number): this\n    // Changes the [zIndex offset](#marker-zindexoffset) of the marker.\n    setZIndexOffset: function (offset) {\n      this.options.zIndexOffset = offset;\n      return this.update();\n    },\n    // @method getIcon: Icon\n    // Returns the current icon used by the marker\n    getIcon: function () {\n      return this.options.icon;\n    },\n    // @method setIcon(icon: Icon): this\n    // Changes the marker icon.\n    setIcon: function (icon) {\n      this.options.icon = icon;\n\n      if (this._map) {\n        this._initIcon();\n\n        this.update();\n      }\n\n      if (this._popup) {\n        this.bindPopup(this._popup, this._popup.options);\n      }\n\n      return this;\n    },\n    getElement: function () {\n      return this._icon;\n    },\n    update: function () {\n      if (this._icon && this._map) {\n        var pos = this._map.latLngToLayerPoint(this._latlng).round();\n\n        this._setPos(pos);\n      }\n\n      return this;\n    },\n    _initIcon: function () {\n      var options = this.options,\n          classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      var icon = options.icon.createIcon(this._icon),\n          addIcon = false; // if we're not reusing the icon, remove the old one and init new one\n\n      if (icon !== this._icon) {\n        if (this._icon) {\n          this._removeIcon();\n        }\n\n        addIcon = true;\n\n        if (options.title) {\n          icon.title = options.title;\n        }\n\n        if (icon.tagName === 'IMG') {\n          icon.alt = options.alt || '';\n        }\n      }\n\n      addClass(icon, classToAdd);\n\n      if (options.keyboard) {\n        icon.tabIndex = '0';\n      }\n\n      this._icon = icon;\n\n      if (options.riseOnHover) {\n        this.on({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n\n      var newShadow = options.icon.createShadow(this._shadow),\n          addShadow = false;\n\n      if (newShadow !== this._shadow) {\n        this._removeShadow();\n\n        addShadow = true;\n      }\n\n      if (newShadow) {\n        addClass(newShadow, classToAdd);\n        newShadow.alt = '';\n      }\n\n      this._shadow = newShadow;\n\n      if (options.opacity < 1) {\n        this._updateOpacity();\n      }\n\n      if (addIcon) {\n        this.getPane().appendChild(this._icon);\n      }\n\n      this._initInteraction();\n\n      if (newShadow && addShadow) {\n        this.getPane(options.shadowPane).appendChild(this._shadow);\n      }\n    },\n    _removeIcon: function () {\n      if (this.options.riseOnHover) {\n        this.off({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n\n      remove(this._icon);\n      this.removeInteractiveTarget(this._icon);\n      this._icon = null;\n    },\n    _removeShadow: function () {\n      if (this._shadow) {\n        remove(this._shadow);\n      }\n\n      this._shadow = null;\n    },\n    _setPos: function (pos) {\n      if (this._icon) {\n        setPosition(this._icon, pos);\n      }\n\n      if (this._shadow) {\n        setPosition(this._shadow, pos);\n      }\n\n      this._zIndex = pos.y + this.options.zIndexOffset;\n\n      this._resetZIndex();\n    },\n    _updateZIndex: function (offset) {\n      if (this._icon) {\n        this._icon.style.zIndex = this._zIndex + offset;\n      }\n    },\n    _animateZoom: function (opt) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\n\n      this._setPos(pos);\n    },\n    _initInteraction: function () {\n      if (!this.options.interactive) {\n        return;\n      }\n\n      addClass(this._icon, 'leaflet-interactive');\n      this.addInteractiveTarget(this._icon);\n\n      if (MarkerDrag) {\n        var draggable = this.options.draggable;\n\n        if (this.dragging) {\n          draggable = this.dragging.enabled();\n          this.dragging.disable();\n        }\n\n        this.dragging = new MarkerDrag(this);\n\n        if (draggable) {\n          this.dragging.enable();\n        }\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the opacity of the marker.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      if (this._map) {\n        this._updateOpacity();\n      }\n\n      return this;\n    },\n    _updateOpacity: function () {\n      var opacity = this.options.opacity;\n\n      if (this._icon) {\n        setOpacity(this._icon, opacity);\n      }\n\n      if (this._shadow) {\n        setOpacity(this._shadow, opacity);\n      }\n    },\n    _bringToFront: function () {\n      this._updateZIndex(this.options.riseOffset);\n    },\n    _resetZIndex: function () {\n      this._updateZIndex(0);\n    },\n    _getPopupAnchor: function () {\n      return this.options.icon.options.popupAnchor;\n    },\n    _getTooltipAnchor: function () {\n      return this.options.icon.options.tooltipAnchor;\n    }\n  }); // factory L.marker(latlng: LatLng, options? : Marker options)\n  // @factory L.marker(latlng: LatLng, options? : Marker options)\n  // Instantiates a Marker object given a geographical point and optionally an options object.\n\n  function marker(latlng, options) {\n    return new Marker(latlng, options);\n  }\n  /*\n   * @class Path\n   * @aka L.Path\n   * @inherits Interactive layer\n   *\n   * An abstract class that contains options and constants shared between vector\n   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.\n   */\n\n\n  var Path = Layer.extend({\n    // @section\n    // @aka Path options\n    options: {\n      // @option stroke: Boolean = true\n      // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.\n      stroke: true,\n      // @option color: String = '#3388ff'\n      // Stroke color\n      color: '#3388ff',\n      // @option weight: Number = 3\n      // Stroke width in pixels\n      weight: 3,\n      // @option opacity: Number = 1.0\n      // Stroke opacity\n      opacity: 1,\n      // @option lineCap: String= 'round'\n      // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.\n      lineCap: 'round',\n      // @option lineJoin: String = 'round'\n      // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.\n      lineJoin: 'round',\n      // @option dashArray: String = null\n      // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashArray: null,\n      // @option dashOffset: String = null\n      // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashOffset: null,\n      // @option fill: Boolean = depends\n      // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.\n      fill: false,\n      // @option fillColor: String = *\n      // Fill color. Defaults to the value of the [`color`](#path-color) option\n      fillColor: null,\n      // @option fillOpacity: Number = 0.2\n      // Fill opacity.\n      fillOpacity: 0.2,\n      // @option fillRule: String = 'evenodd'\n      // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.\n      fillRule: 'evenodd',\n      // className: '',\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option bubblingMouseEvents: Boolean = true\n      // When `true`, a mouse event on this path will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: true\n    },\n    beforeAdd: function (map) {\n      // Renderer is set here because we need to call renderer.getEvents\n      // before this.getEvents.\n      this._renderer = map.getRenderer(this);\n    },\n    onAdd: function () {\n      this._renderer._initPath(this);\n\n      this._reset();\n\n      this._renderer._addPath(this);\n    },\n    onRemove: function () {\n      this._renderer._removePath(this);\n    },\n    // @method redraw(): this\n    // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.\n    redraw: function () {\n      if (this._map) {\n        this._renderer._updatePath(this);\n      }\n\n      return this;\n    },\n    // @method setStyle(style: Path options): this\n    // Changes the appearance of a Path based on the options in the `Path options` object.\n    setStyle: function (style) {\n      setOptions(this, style);\n\n      if (this._renderer) {\n        this._renderer._updateStyle(this);\n\n        if (this.options.stroke && style && style.hasOwnProperty('weight')) {\n          this._updateBounds();\n        }\n      }\n\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all path layers.\n    bringToFront: function () {\n      if (this._renderer) {\n        this._renderer._bringToFront(this);\n      }\n\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all path layers.\n    bringToBack: function () {\n      if (this._renderer) {\n        this._renderer._bringToBack(this);\n      }\n\n      return this;\n    },\n    getElement: function () {\n      return this._path;\n    },\n    _reset: function () {\n      // defined in child classes\n      this._project();\n\n      this._update();\n    },\n    _clickTolerance: function () {\n      // used when doing hit detection for Canvas layers\n      return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;\n    }\n  });\n  /*\n   * @class CircleMarker\n   * @aka L.CircleMarker\n   * @inherits Path\n   *\n   * A circle of a fixed size with radius specified in pixels. Extends `Path`.\n   */\n\n  var CircleMarker = Path.extend({\n    // @section\n    // @aka CircleMarker options\n    options: {\n      fill: true,\n      // @option radius: Number = 10\n      // Radius of the circle marker, in pixels\n      radius: 10\n    },\n    initialize: function (latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n      this._radius = this.options.radius;\n    },\n    // @method setLatLng(latLng: LatLng): this\n    // Sets the position of a circle marker to a new location.\n    setLatLng: function (latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.redraw(); // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method getLatLng(): LatLng\n    // Returns the current geographical position of the circle marker\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle marker. Units are in pixels.\n    setRadius: function (radius) {\n      this.options.radius = this._radius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of the circle\n    getRadius: function () {\n      return this._radius;\n    },\n    setStyle: function (options) {\n      var radius = options && options.radius || this._radius;\n      Path.prototype.setStyle.call(this, options);\n      this.setRadius(radius);\n      return this;\n    },\n    _project: function () {\n      this._point = this._map.latLngToLayerPoint(this._latlng);\n\n      this._updateBounds();\n    },\n    _updateBounds: function () {\n      var r = this._radius,\n          r2 = this._radiusY || r,\n          w = this._clickTolerance(),\n          p = [r + w, r2 + w];\n\n      this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));\n    },\n    _update: function () {\n      if (this._map) {\n        this._updatePath();\n      }\n    },\n    _updatePath: function () {\n      this._renderer._updateCircle(this);\n    },\n    _empty: function () {\n      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p) {\n      return p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n    }\n  }); // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)\n  // Instantiates a circle marker object given a geographical point, and an optional options object.\n\n  function circleMarker(latlng, options) {\n    return new CircleMarker(latlng, options);\n  }\n  /*\n   * @class Circle\n   * @aka L.Circle\n   * @inherits CircleMarker\n   *\n   * A class for drawing circle overlays on a map. Extends `CircleMarker`.\n   *\n   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).\n   *\n   * @example\n   *\n   * ```js\n   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);\n   * ```\n   */\n\n\n  var Circle = CircleMarker.extend({\n    initialize: function (latlng, options, legacyOptions) {\n      if (typeof options === 'number') {\n        // Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n        options = extend({}, legacyOptions, {\n          radius: options\n        });\n      }\n\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n\n      if (isNaN(this.options.radius)) {\n        throw new Error('Circle radius cannot be NaN');\n      } // @section\n      // @aka Circle options\n      // @option radius: Number; Radius of the circle, in meters.\n\n\n      this._mRadius = this.options.radius;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle. Units are in meters.\n    setRadius: function (radius) {\n      this._mRadius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of a circle. Units are in meters.\n    getRadius: function () {\n      return this._mRadius;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function () {\n      var half = [this._radius, this._radiusY || this._radius];\n      return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));\n    },\n    setStyle: Path.prototype.setStyle,\n    _project: function () {\n      var lng = this._latlng.lng,\n          lat = this._latlng.lat,\n          map = this._map,\n          crs = map.options.crs;\n\n      if (crs.distance === Earth.distance) {\n        var d = Math.PI / 180,\n            latR = this._mRadius / Earth.R / d,\n            top = map.project([lat + latR, lng]),\n            bottom = map.project([lat - latR, lng]),\n            p = top.add(bottom).divideBy(2),\n            lat2 = map.unproject(p).lat,\n            lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n\n        if (isNaN(lngR) || lngR === 0) {\n          lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425\n        }\n\n        this._point = p.subtract(map.getPixelOrigin());\n        this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;\n        this._radiusY = p.y - top.y;\n      } else {\n        var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));\n        this._point = map.latLngToLayerPoint(this._latlng);\n        this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n      }\n\n      this._updateBounds();\n    }\n  }); // @factory L.circle(latlng: LatLng, options?: Circle options)\n  // Instantiates a circle object given a geographical point, and an options object\n  // which contains the circle radius.\n  // @alternative\n  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)\n  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.\n  // Do not use in new applications or plugins.\n\n  function circle(latlng, options, legacyOptions) {\n    return new Circle(latlng, options, legacyOptions);\n  }\n  /*\n   * @class Polyline\n   * @aka L.Polyline\n   * @inherits Path\n   *\n   * A class for drawing polyline overlays on a map. Extends `Path`.\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polyline from an array of LatLng points\n   * var latlngs = [\n   * \t[45.51, -122.68],\n   * \t[37.77, -122.43],\n   * \t[34.04, -118.2]\n   * ];\n   *\n   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polyline\n   * map.fitBounds(polyline.getBounds());\n   * ```\n   *\n   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\n   *\n   * ```js\n   * // create a red polyline from an array of arrays of LatLng points\n   * var latlngs = [\n   * \t[[45.51, -122.68],\n   * \t [37.77, -122.43],\n   * \t [34.04, -118.2]],\n   * \t[[40.78, -73.91],\n   * \t [41.83, -87.62],\n   * \t [32.76, -96.72]]\n   * ];\n   * ```\n   */\n\n\n  var Polyline = Path.extend({\n    // @section\n    // @aka Polyline options\n    options: {\n      // @option smoothFactor: Number = 1.0\n      // How much to simplify the polyline on each zoom level. More means\n      // better performance and smoother look, and less means more accurate representation.\n      smoothFactor: 1.0,\n      // @option noClip: Boolean = false\n      // Disable polyline clipping.\n      noClip: false\n    },\n    initialize: function (latlngs, options) {\n      setOptions(this, options);\n\n      this._setLatLngs(latlngs);\n    },\n    // @method getLatLngs(): LatLng[]\n    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\n    getLatLngs: function () {\n      return this._latlngs;\n    },\n    // @method setLatLngs(latlngs: LatLng[]): this\n    // Replaces all the points in the polyline with the given array of geographical points.\n    setLatLngs: function (latlngs) {\n      this._setLatLngs(latlngs);\n\n      return this.redraw();\n    },\n    // @method isEmpty(): Boolean\n    // Returns `true` if the Polyline has no LatLngs.\n    isEmpty: function () {\n      return !this._latlngs.length;\n    },\n    // @method closestLayerPoint(p: Point): Point\n    // Returns the point closest to `p` on the Polyline.\n    closestLayerPoint: function (p) {\n      var minDistance = Infinity,\n          minPoint = null,\n          closest = _sqClosestPointOnSegment,\n          p1,\n          p2;\n\n      for (var j = 0, jLen = this._parts.length; j < jLen; j++) {\n        var points = this._parts[j];\n\n        for (var i = 1, len = points.length; i < len; i++) {\n          p1 = points[i - 1];\n          p2 = points[i];\n          var sqDist = closest(p, p1, p2, true);\n\n          if (sqDist < minDistance) {\n            minDistance = sqDist;\n            minPoint = closest(p, p1, p2);\n          }\n        }\n      }\n\n      if (minPoint) {\n        minPoint.distance = Math.sqrt(minDistance);\n      }\n\n      return minPoint;\n    },\n    // @method getCenter(): LatLng\n    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.\n    getCenter: function () {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n\n      var i,\n          halfDist,\n          segDist,\n          dist,\n          p1,\n          p2,\n          ratio,\n          points = this._rings[0],\n          len = points.length;\n\n      if (!len) {\n        return null;\n      } // polyline centroid algorithm; only uses the first ring if there are multiple\n\n\n      for (i = 0, halfDist = 0; i < len - 1; i++) {\n        halfDist += points[i].distanceTo(points[i + 1]) / 2;\n      } // The line is so small in the current view that all points are on the same pixel.\n\n\n      if (halfDist === 0) {\n        return this._map.layerPointToLatLng(points[0]);\n      }\n\n      for (i = 0, dist = 0; i < len - 1; i++) {\n        p1 = points[i];\n        p2 = points[i + 1];\n        segDist = p1.distanceTo(p2);\n        dist += segDist;\n\n        if (dist > halfDist) {\n          ratio = (dist - halfDist) / segDist;\n          return this._map.layerPointToLatLng([p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)]);\n        }\n      }\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function () {\n      return this._bounds;\n    },\n    // @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this\n    // Adds a given point to the polyline. By default, adds to the first ring of\n    // the polyline in case of a multi-polyline, but can be overridden by passing\n    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\n    addLatLng: function (latlng, latlngs) {\n      latlngs = latlngs || this._defaultShape();\n      latlng = toLatLng(latlng);\n      latlngs.push(latlng);\n\n      this._bounds.extend(latlng);\n\n      return this.redraw();\n    },\n    _setLatLngs: function (latlngs) {\n      this._bounds = new LatLngBounds();\n      this._latlngs = this._convertLatLngs(latlngs);\n    },\n    _defaultShape: function () {\n      return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];\n    },\n    // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n    _convertLatLngs: function (latlngs) {\n      var result = [],\n          flat = isFlat(latlngs);\n\n      for (var i = 0, len = latlngs.length; i < len; i++) {\n        if (flat) {\n          result[i] = toLatLng(latlngs[i]);\n\n          this._bounds.extend(result[i]);\n        } else {\n          result[i] = this._convertLatLngs(latlngs[i]);\n        }\n      }\n\n      return result;\n    },\n    _project: function () {\n      var pxBounds = new Bounds();\n      this._rings = [];\n\n      this._projectLatlngs(this._latlngs, this._rings, pxBounds);\n\n      if (this._bounds.isValid() && pxBounds.isValid()) {\n        this._rawPxBounds = pxBounds;\n\n        this._updateBounds();\n      }\n    },\n    _updateBounds: function () {\n      var w = this._clickTolerance(),\n          p = new Point(w, w);\n\n      this._pxBounds = new Bounds([this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p)]);\n    },\n    // recursively turns latlngs into a set of rings with projected coordinates\n    _projectLatlngs: function (latlngs, result, projectedBounds) {\n      var flat = latlngs[0] instanceof LatLng,\n          len = latlngs.length,\n          i,\n          ring;\n\n      if (flat) {\n        ring = [];\n\n        for (i = 0; i < len; i++) {\n          ring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n          projectedBounds.extend(ring[i]);\n        }\n\n        result.push(ring);\n      } else {\n        for (i = 0; i < len; i++) {\n          this._projectLatlngs(latlngs[i], result, projectedBounds);\n        }\n      }\n    },\n    // clip polyline by renderer bounds so that we have less to render for performance\n    _clipPoints: function () {\n      var bounds = this._renderer._bounds;\n      this._parts = [];\n\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n\n      var parts = this._parts,\n          i,\n          j,\n          k,\n          len,\n          len2,\n          segment,\n          points;\n\n      for (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n        points = this._rings[i];\n\n        for (j = 0, len2 = points.length; j < len2 - 1; j++) {\n          segment = clipSegment(points[j], points[j + 1], bounds, j, true);\n\n          if (!segment) {\n            continue;\n          }\n\n          parts[k] = parts[k] || [];\n          parts[k].push(segment[0]); // if segment goes out of screen, or it's the last one, it's the end of the line part\n\n          if (segment[1] !== points[j + 1] || j === len2 - 2) {\n            parts[k].push(segment[1]);\n            k++;\n          }\n        }\n      }\n    },\n    // simplify each clipped part of the polyline for performance\n    _simplifyPoints: function () {\n      var parts = this._parts,\n          tolerance = this.options.smoothFactor;\n\n      for (var i = 0, len = parts.length; i < len; i++) {\n        parts[i] = simplify(parts[i], tolerance);\n      }\n    },\n    _update: function () {\n      if (!this._map) {\n        return;\n      }\n\n      this._clipPoints();\n\n      this._simplifyPoints();\n\n      this._updatePath();\n    },\n    _updatePath: function () {\n      this._renderer._updatePoly(this);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p, closed) {\n      var i,\n          j,\n          k,\n          len,\n          len2,\n          part,\n          w = this._clickTolerance();\n\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      } // hit detection for polylines\n\n\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          if (!closed && j === 0) {\n            continue;\n          }\n\n          if (pointToSegmentDistance(p, part[k], part[j]) <= w) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n  }); // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)\n  // Instantiates a polyline object given an array of geographical points and\n  // optionally an options object. You can create a `Polyline` object with\n  // multiple separate lines (`MultiPolyline`) by passing an array of arrays\n  // of geographic points.\n\n  function polyline(latlngs, options) {\n    return new Polyline(latlngs, options);\n  } // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.\n\n\n  Polyline._flat = _flat;\n  /*\n   * @class Polygon\n   * @aka L.Polygon\n   * @inherits Polyline\n   *\n   * A class for drawing polygon overlays on a map. Extends `Polyline`.\n   *\n   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.\n   *\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polygon from an array of LatLng points\n   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];\n   *\n   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polygon\n   * map.fitBounds(polygon.getBounds());\n   * ```\n   *\n   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:\n   *\n   * ```js\n   * var latlngs = [\n   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   * ];\n   * ```\n   *\n   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.\n   *\n   * ```js\n   * var latlngs = [\n   *   [ // first polygon\n   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   *   ],\n   *   [ // second polygon\n   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]\n   *   ]\n   * ];\n   * ```\n   */\n\n  var Polygon = Polyline.extend({\n    options: {\n      fill: true\n    },\n    isEmpty: function () {\n      return !this._latlngs.length || !this._latlngs[0].length;\n    },\n    getCenter: function () {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n\n      var i,\n          j,\n          p1,\n          p2,\n          f,\n          area,\n          x,\n          y,\n          center,\n          points = this._rings[0],\n          len = points.length;\n\n      if (!len) {\n        return null;\n      } // polygon centroid algorithm; only uses the first ring if there are multiple\n\n\n      area = x = y = 0;\n\n      for (i = 0, j = len - 1; i < len; j = i++) {\n        p1 = points[i];\n        p2 = points[j];\n        f = p1.y * p2.x - p2.y * p1.x;\n        x += (p1.x + p2.x) * f;\n        y += (p1.y + p2.y) * f;\n        area += f * 3;\n      }\n\n      if (area === 0) {\n        // Polygon is so small that all points are on same pixel.\n        center = points[0];\n      } else {\n        center = [x / area, y / area];\n      }\n\n      return this._map.layerPointToLatLng(center);\n    },\n    _convertLatLngs: function (latlngs) {\n      var result = Polyline.prototype._convertLatLngs.call(this, latlngs),\n          len = result.length; // remove last point if it equals first one\n\n\n      if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {\n        result.pop();\n      }\n\n      return result;\n    },\n    _setLatLngs: function (latlngs) {\n      Polyline.prototype._setLatLngs.call(this, latlngs);\n\n      if (isFlat(this._latlngs)) {\n        this._latlngs = [this._latlngs];\n      }\n    },\n    _defaultShape: function () {\n      return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n    },\n    _clipPoints: function () {\n      // polygons need a different clipping algorithm so we redefine that\n      var bounds = this._renderer._bounds,\n          w = this.options.weight,\n          p = new Point(w, w); // increase clip padding by stroke width to avoid stroke on clip edges\n\n      bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));\n      this._parts = [];\n\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n\n      for (var i = 0, len = this._rings.length, clipped; i < len; i++) {\n        clipped = clipPolygon(this._rings[i], bounds, true);\n\n        if (clipped.length) {\n          this._parts.push(clipped);\n        }\n      }\n    },\n    _updatePath: function () {\n      this._renderer._updatePoly(this, true);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p) {\n      var inside = false,\n          part,\n          p1,\n          p2,\n          i,\n          j,\n          k,\n          len,\n          len2;\n\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      } // ray casting algorithm for detecting if point is in polygon\n\n\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          p1 = part[j];\n          p2 = part[k];\n\n          if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {\n            inside = !inside;\n          }\n        }\n      } // also check if it's on polygon stroke\n\n\n      return inside || Polyline.prototype._containsPoint.call(this, p, true);\n    }\n  }); // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)\n\n  function polygon(latlngs, options) {\n    return new Polygon(latlngs, options);\n  }\n  /*\r\n   * @class GeoJSON\r\n   * @aka L.GeoJSON\r\n   * @inherits FeatureGroup\r\n   *\r\n   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse\r\n   * GeoJSON data and display it on the map. Extends `FeatureGroup`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.geoJSON(data, {\r\n   * \tstyle: function (feature) {\r\n   * \t\treturn {color: feature.properties.color};\r\n   * \t}\r\n   * }).bindPopup(function (layer) {\r\n   * \treturn layer.feature.properties.description;\r\n   * }).addTo(map);\r\n   * ```\r\n   */\n\n\n  var GeoJSON = FeatureGroup.extend({\n    /* @section\r\n     * @aka GeoJSON options\r\n     *\r\n     * @option pointToLayer: Function = *\r\n     * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally\r\n     * called when data is added, passing the GeoJSON point feature and its `LatLng`.\r\n     * The default is to spawn a default `Marker`:\r\n     * ```js\r\n     * function(geoJsonPoint, latlng) {\r\n     * \treturn L.marker(latlng);\r\n     * }\r\n     * ```\r\n     *\r\n     * @option style: Function = *\r\n     * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,\r\n     * called internally when data is added.\r\n     * The default value is to not override any defaults:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn {}\r\n     * }\r\n     * ```\r\n     *\r\n     * @option onEachFeature: Function = *\r\n     * A `Function` that will be called once for each created `Feature`, after it has\r\n     * been created and styled. Useful for attaching events and popups to features.\r\n     * The default is to do nothing with the newly created layers:\r\n     * ```js\r\n     * function (feature, layer) {}\r\n     * ```\r\n     *\r\n     * @option filter: Function = *\r\n     * A `Function` that will be used to decide whether to include a feature or not.\r\n     * The default is to include all features:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn true;\r\n     * }\r\n     * ```\r\n     * Note: dynamically changing the `filter` option will have effect only on newly\r\n     * added data. It will _not_ re-evaluate already included features.\r\n     *\r\n     * @option coordsToLatLng: Function = *\r\n     * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.\r\n     * The default is the `coordsToLatLng` static method.\r\n     *\r\n     * @option markersInheritOptions: Boolean = false\r\n     * Whether default Markers for \"Point\" type Features inherit from group options.\r\n     */\n    initialize: function (geojson, options) {\n      setOptions(this, options);\n      this._layers = {};\n\n      if (geojson) {\n        this.addData(geojson);\n      }\n    },\n    // @method addData( <GeoJSON> data ): this\n    // Adds a GeoJSON object to the layer.\n    addData: function (geojson) {\n      var features = isArray(geojson) ? geojson : geojson.features,\n          i,\n          len,\n          feature;\n\n      if (features) {\n        for (i = 0, len = features.length; i < len; i++) {\n          // only add this if geometry or geometries are set and not null\n          feature = features[i];\n\n          if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\n            this.addData(feature);\n          }\n        }\n\n        return this;\n      }\n\n      var options = this.options;\n\n      if (options.filter && !options.filter(geojson)) {\n        return this;\n      }\n\n      var layer = geometryToLayer(geojson, options);\n\n      if (!layer) {\n        return this;\n      }\n\n      layer.feature = asFeature(geojson);\n      layer.defaultOptions = layer.options;\n      this.resetStyle(layer);\n\n      if (options.onEachFeature) {\n        options.onEachFeature(geojson, layer);\n      }\n\n      return this.addLayer(layer);\n    },\n    // @method resetStyle( <Path> layer? ): this\n    // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.\n    // If `layer` is omitted, the style of all features in the current layer is reset.\n    resetStyle: function (layer) {\n      if (layer === undefined) {\n        return this.eachLayer(this.resetStyle, this);\n      } // reset any custom styles\n\n\n      layer.options = extend({}, layer.defaultOptions);\n\n      this._setLayerStyle(layer, this.options.style);\n\n      return this;\n    },\n    // @method setStyle( <Function> style ): this\n    // Changes styles of GeoJSON vector layers with the given style function.\n    setStyle: function (style) {\n      return this.eachLayer(function (layer) {\n        this._setLayerStyle(layer, style);\n      }, this);\n    },\n    _setLayerStyle: function (layer, style) {\n      if (layer.setStyle) {\n        if (typeof style === 'function') {\n          style = style(layer.feature);\n        }\n\n        layer.setStyle(style);\n      }\n    }\n  }); // @section\n  // There are several static functions which can be called without instantiating L.GeoJSON:\n  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer\n  // Creates a `Layer` from a given GeoJSON feature. Can use a custom\n  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)\n  // functions if provided as options.\n\n  function geometryToLayer(geojson, options) {\n    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\n        coords = geometry ? geometry.coordinates : null,\n        layers = [],\n        pointToLayer = options && options.pointToLayer,\n        _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,\n        latlng,\n        latlngs,\n        i,\n        len;\n\n    if (!coords && !geometry) {\n      return null;\n    }\n\n    switch (geometry.type) {\n      case 'Point':\n        latlng = _coordsToLatLng(coords);\n        return _pointToLayer(pointToLayer, geojson, latlng, options);\n\n      case 'MultiPoint':\n        for (i = 0, len = coords.length; i < len; i++) {\n          latlng = _coordsToLatLng(coords[i]);\n          layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));\n        }\n\n        return new FeatureGroup(layers);\n\n      case 'LineString':\n      case 'MultiLineString':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);\n        return new Polyline(latlngs, options);\n\n      case 'Polygon':\n      case 'MultiPolygon':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);\n        return new Polygon(latlngs, options);\n\n      case 'GeometryCollection':\n        for (i = 0, len = geometry.geometries.length; i < len; i++) {\n          var layer = geometryToLayer({\n            geometry: geometry.geometries[i],\n            type: 'Feature',\n            properties: geojson.properties\n          }, options);\n\n          if (layer) {\n            layers.push(layer);\n          }\n        }\n\n        return new FeatureGroup(layers);\n\n      default:\n        throw new Error('Invalid GeoJSON object.');\n    }\n  }\n\n  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {\n    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);\n  } // @function coordsToLatLng(coords: Array): LatLng\n  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)\n  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.\n\n\n  function coordsToLatLng(coords) {\n    return new LatLng(coords[1], coords[0], coords[2]);\n  } // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array\n  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.\n  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).\n  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.\n\n\n  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {\n    var latlngs = [];\n\n    for (var i = 0, len = coords.length, latlng; i < len; i++) {\n      latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);\n      latlngs.push(latlng);\n    }\n\n    return latlngs;\n  } // @function latLngToCoords(latlng: LatLng, precision?: Number): Array\n  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)\n\n\n  function latLngToCoords(latlng, precision) {\n    precision = typeof precision === 'number' ? precision : 6;\n    return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];\n  } // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array\n  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)\n  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.\n\n\n  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {\n    var coords = [];\n\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));\n    }\n\n    if (!levelsDeep && closed) {\n      coords.push(coords[0]);\n    }\n\n    return coords;\n  }\n\n  function getFeature(layer, newGeometry) {\n    return layer.feature ? extend({}, layer.feature, {\n      geometry: newGeometry\n    }) : asFeature(newGeometry);\n  } // @function asFeature(geojson: Object): Object\n  // Normalize GeoJSON geometries/features into GeoJSON features.\n\n\n  function asFeature(geojson) {\n    if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {\n      return geojson;\n    }\n\n    return {\n      type: 'Feature',\n      properties: {},\n      geometry: geojson\n    };\n  }\n\n  var PointToGeoJSON = {\n    toGeoJSON: function (precision) {\n      return getFeature(this, {\n        type: 'Point',\n        coordinates: latLngToCoords(this.getLatLng(), precision)\n      });\n    }\n  }; // @namespace Marker\n  // @section Other methods\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).\n\n  Marker.include(PointToGeoJSON); // @namespace CircleMarker\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).\n\n  Circle.include(PointToGeoJSON);\n  CircleMarker.include(PointToGeoJSON); // @namespace Polyline\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).\n\n  Polyline.include({\n    toGeoJSON: function (precision) {\n      var multi = !isFlat(this._latlngs);\n      var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'LineString',\n        coordinates: coords\n      });\n    }\n  }); // @namespace Polygon\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).\n\n  Polygon.include({\n    toGeoJSON: function (precision) {\n      var holes = !isFlat(this._latlngs),\n          multi = holes && !isFlat(this._latlngs[0]);\n      var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);\n\n      if (!holes) {\n        coords = [coords];\n      }\n\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'Polygon',\n        coordinates: coords\n      });\n    }\n  }); // @namespace LayerGroup\n\n  LayerGroup.include({\n    toMultiPoint: function (precision) {\n      var coords = [];\n      this.eachLayer(function (layer) {\n        coords.push(layer.toGeoJSON(precision).geometry.coordinates);\n      });\n      return getFeature(this, {\n        type: 'MultiPoint',\n        coordinates: coords\n      });\n    },\n    // @method toGeoJSON(precision?: Number): Object\n    // `precision` is the number of decimal places for coordinates.\n    // The default value is 6 places.\n    // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).\n    toGeoJSON: function (precision) {\n      var type = this.feature && this.feature.geometry && this.feature.geometry.type;\n\n      if (type === 'MultiPoint') {\n        return this.toMultiPoint(precision);\n      }\n\n      var isGeometryCollection = type === 'GeometryCollection',\n          jsons = [];\n      this.eachLayer(function (layer) {\n        if (layer.toGeoJSON) {\n          var json = layer.toGeoJSON(precision);\n\n          if (isGeometryCollection) {\n            jsons.push(json.geometry);\n          } else {\n            var feature = asFeature(json); // Squash nested feature collections\n\n            if (feature.type === 'FeatureCollection') {\n              jsons.push.apply(jsons, feature.features);\n            } else {\n              jsons.push(feature);\n            }\n          }\n        }\n      });\n\n      if (isGeometryCollection) {\n        return getFeature(this, {\n          geometries: jsons,\n          type: 'GeometryCollection'\n        });\n      }\n\n      return {\n        type: 'FeatureCollection',\n        features: jsons\n      };\n    }\n  }); // @namespace GeoJSON\n  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)\n  // Creates a GeoJSON layer. Optionally accepts an object in\n  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map\n  // (you can alternatively add it later with `addData` method) and an `options` object.\n\n  function geoJSON(geojson, options) {\n    return new GeoJSON(geojson, options);\n  } // Backward compatibility.\n\n\n  var geoJson = geoJSON;\n  /*\r\n   * @class ImageOverlay\r\n   * @aka L.ImageOverlay\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',\r\n   * \timageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];\r\n   * L.imageOverlay(imageUrl, imageBounds).addTo(map);\r\n   * ```\r\n   */\n\n  var ImageOverlay = Layer.extend({\n    // @section\n    // @aka ImageOverlay options\n    options: {\n      // @option opacity: Number = 1.0\n      // The opacity of the image overlay.\n      opacity: 1,\n      // @option alt: String = ''\n      // Text for the `alt` attribute of the image (useful for accessibility).\n      alt: '',\n      // @option interactive: Boolean = false\n      // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.\n      interactive: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the image.\n      // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false,\n      // @option errorOverlayUrl: String = ''\n      // URL to the overlay image to show in place of the overlay that failed to load.\n      errorOverlayUrl: '',\n      // @option zIndex: Number = 1\n      // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.\n      zIndex: 1,\n      // @option className: String = ''\n      // A custom class name to assign to the image. Empty by default.\n      className: ''\n    },\n    initialize: function (url, bounds, options) {\n      // (String, LatLngBounds, Object)\n      this._url = url;\n      this._bounds = toLatLngBounds(bounds);\n      setOptions(this, options);\n    },\n    onAdd: function () {\n      if (!this._image) {\n        this._initImage();\n\n        if (this.options.opacity < 1) {\n          this._updateOpacity();\n        }\n      }\n\n      if (this.options.interactive) {\n        addClass(this._image, 'leaflet-interactive');\n        this.addInteractiveTarget(this._image);\n      }\n\n      this.getPane().appendChild(this._image);\n\n      this._reset();\n    },\n    onRemove: function () {\n      remove(this._image);\n\n      if (this.options.interactive) {\n        this.removeInteractiveTarget(this._image);\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Sets the opacity of the overlay.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      if (this._image) {\n        this._updateOpacity();\n      }\n\n      return this;\n    },\n    setStyle: function (styleOpts) {\n      if (styleOpts.opacity) {\n        this.setOpacity(styleOpts.opacity);\n      }\n\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all overlays.\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._image);\n      }\n\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all overlays.\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._image);\n      }\n\n      return this;\n    },\n    // @method setUrl(url: String): this\n    // Changes the URL of the image.\n    setUrl: function (url) {\n      this._url = url;\n\n      if (this._image) {\n        this._image.src = url;\n      }\n\n      return this;\n    },\n    // @method setBounds(bounds: LatLngBounds): this\n    // Update the bounds that this ImageOverlay covers\n    setBounds: function (bounds) {\n      this._bounds = toLatLngBounds(bounds);\n\n      if (this._map) {\n        this._reset();\n      }\n\n      return this;\n    },\n    getEvents: function () {\n      var events = {\n        zoom: this._reset,\n        viewreset: this._reset\n      };\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n\n      return events;\n    },\n    // @method setZIndex(value: Number): this\n    // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.\n    setZIndex: function (value) {\n      this.options.zIndex = value;\n\n      this._updateZIndex();\n\n      return this;\n    },\n    // @method getBounds(): LatLngBounds\n    // Get the bounds that this ImageOverlay covers\n    getBounds: function () {\n      return this._bounds;\n    },\n    // @method getElement(): HTMLElement\n    // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)\n    // used by this overlay.\n    getElement: function () {\n      return this._image;\n    },\n    _initImage: function () {\n      var wasElementSupplied = this._url.tagName === 'IMG';\n      var img = this._image = wasElementSupplied ? this._url : create$1('img');\n      addClass(img, 'leaflet-image-layer');\n\n      if (this._zoomAnimated) {\n        addClass(img, 'leaflet-zoom-animated');\n      }\n\n      if (this.options.className) {\n        addClass(img, this.options.className);\n      }\n\n      img.onselectstart = falseFn;\n      img.onmousemove = falseFn; // @event load: Event\n      // Fired when the ImageOverlay layer has loaded its image\n\n      img.onload = bind(this.fire, this, 'load');\n      img.onerror = bind(this._overlayOnError, this, 'error');\n\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n\n      if (this.options.zIndex) {\n        this._updateZIndex();\n      }\n\n      if (wasElementSupplied) {\n        this._url = img.src;\n        return;\n      }\n\n      img.src = this._url;\n      img.alt = this.options.alt;\n    },\n    _animateZoom: function (e) {\n      var scale = this._map.getZoomScale(e.zoom),\n          offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;\n\n      setTransform(this._image, offset, scale);\n    },\n    _reset: function () {\n      var image = this._image,\n          bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),\n          size = bounds.getSize();\n      setPosition(image, bounds.min);\n      image.style.width = size.x + 'px';\n      image.style.height = size.y + 'px';\n    },\n    _updateOpacity: function () {\n      setOpacity(this._image, this.options.opacity);\n    },\n    _updateZIndex: function () {\n      if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._image.style.zIndex = this.options.zIndex;\n      }\n    },\n    _overlayOnError: function () {\n      // @event error: Event\n      // Fired when the ImageOverlay layer fails to load its image\n      this.fire('error');\n      var errorUrl = this.options.errorOverlayUrl;\n\n      if (errorUrl && this._url !== errorUrl) {\n        this._url = errorUrl;\n        this._image.src = errorUrl;\n      }\n    }\n  }); // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)\n  // Instantiates an image overlay object given the URL of the image and the\n  // geographical bounds it is tied to.\n\n  var imageOverlay = function (url, bounds, options) {\n    return new ImageOverlay(url, bounds, options);\n  };\n  /*\r\n   * @class VideoOverlay\r\n   * @aka L.VideoOverlay\r\n   * @inherits ImageOverlay\r\n   *\r\n   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.\r\n   *\r\n   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)\r\n   * HTML5 element.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',\r\n   * \tvideoBounds = [[ 32, -130], [ 13, -100]];\r\n   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);\r\n   * ```\r\n   */\n\n\n  var VideoOverlay = ImageOverlay.extend({\n    // @section\n    // @aka VideoOverlay options\n    options: {\n      // @option autoplay: Boolean = true\n      // Whether the video starts playing automatically when loaded.\n      autoplay: true,\n      // @option loop: Boolean = true\n      // Whether the video will loop back to the beginning when played.\n      loop: true,\n      // @option keepAspectRatio: Boolean = true\n      // Whether the video will save aspect ratio after the projection.\n      // Relevant for supported browsers. Browser compatibility- https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit\n      keepAspectRatio: true\n    },\n    _initImage: function () {\n      var wasElementSupplied = this._url.tagName === 'VIDEO';\n      var vid = this._image = wasElementSupplied ? this._url : create$1('video');\n      addClass(vid, 'leaflet-image-layer');\n\n      if (this._zoomAnimated) {\n        addClass(vid, 'leaflet-zoom-animated');\n      }\n\n      if (this.options.className) {\n        addClass(vid, this.options.className);\n      }\n\n      vid.onselectstart = falseFn;\n      vid.onmousemove = falseFn; // @event load: Event\n      // Fired when the video has finished loading the first frame\n\n      vid.onloadeddata = bind(this.fire, this, 'load');\n\n      if (wasElementSupplied) {\n        var sourceElements = vid.getElementsByTagName('source');\n        var sources = [];\n\n        for (var j = 0; j < sourceElements.length; j++) {\n          sources.push(sourceElements[j].src);\n        }\n\n        this._url = sourceElements.length > 0 ? sources : [vid.src];\n        return;\n      }\n\n      if (!isArray(this._url)) {\n        this._url = [this._url];\n      }\n\n      if (!this.options.keepAspectRatio && vid.style.hasOwnProperty('objectFit')) {\n        vid.style['objectFit'] = 'fill';\n      }\n\n      vid.autoplay = !!this.options.autoplay;\n      vid.loop = !!this.options.loop;\n\n      for (var i = 0; i < this._url.length; i++) {\n        var source = create$1('source');\n        source.src = this._url[i];\n        vid.appendChild(source);\n      }\n    } // @method getElement(): HTMLVideoElement\n    // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)\n    // used by this overlay.\n\n  }); // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)\n  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the\n  // geographical bounds it is tied to.\n\n  function videoOverlay(video, bounds, options) {\n    return new VideoOverlay(video, bounds, options);\n  }\n  /*\n   * @class SVGOverlay\n   * @aka L.SVGOverlay\n   * @inherits ImageOverlay\n   *\n   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.\n   *\n   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.\n   *\n   * @example\n   *\n   * ```js\n   * var svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n   * svgElement.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n   * svgElement.setAttribute('viewBox', \"0 0 200 200\");\n   * svgElement.innerHTML = '<rect width=\"200\" height=\"200\"/><rect x=\"75\" y=\"23\" width=\"50\" height=\"50\" style=\"fill:red\"/><rect x=\"75\" y=\"123\" width=\"50\" height=\"50\" style=\"fill:#0013ff\"/>';\n   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];\n   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);\n   * ```\n   */\n\n\n  var SVGOverlay = ImageOverlay.extend({\n    _initImage: function () {\n      var el = this._image = this._url;\n      addClass(el, 'leaflet-image-layer');\n\n      if (this._zoomAnimated) {\n        addClass(el, 'leaflet-zoom-animated');\n      }\n\n      if (this.options.className) {\n        addClass(el, this.options.className);\n      }\n\n      el.onselectstart = falseFn;\n      el.onmousemove = falseFn;\n    } // @method getElement(): SVGElement\n    // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)\n    // used by this overlay.\n\n  }); // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)\n  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.\n  // A viewBox attribute is required on the SVG element to zoom in and out properly.\n\n  function svgOverlay(el, bounds, options) {\n    return new SVGOverlay(el, bounds, options);\n  }\n  /*\r\n   * @class DivOverlay\r\n   * @inherits Layer\r\n   * @aka L.DivOverlay\r\n   * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.\r\n   */\n  // @namespace DivOverlay\n\n\n  var DivOverlay = Layer.extend({\n    // @section\n    // @aka DivOverlay options\n    options: {\n      // @option offset: Point = Point(0, 7)\n      // The offset of the popup position. Useful to control the anchor\n      // of the popup when opening it on some overlays.\n      offset: [0, 7],\n      // @option className: String = ''\n      // A custom CSS class name to assign to the popup.\n      className: '',\n      // @option pane: String = 'popupPane'\n      // `Map pane` where the popup will be added.\n      pane: 'popupPane'\n    },\n    initialize: function (options, source) {\n      setOptions(this, options);\n      this._source = source;\n    },\n    onAdd: function (map) {\n      this._zoomAnimated = map._zoomAnimated;\n\n      if (!this._container) {\n        this._initLayout();\n      }\n\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 0);\n      }\n\n      clearTimeout(this._removeTimeout);\n      this.getPane().appendChild(this._container);\n      this.update();\n\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 1);\n      }\n\n      this.bringToFront();\n    },\n    onRemove: function (map) {\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 0);\n        this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);\n      } else {\n        remove(this._container);\n      }\n    },\n    // @namespace Popup\n    // @method getLatLng: LatLng\n    // Returns the geographical point of popup.\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Sets the geographical point where the popup will open.\n    setLatLng: function (latlng) {\n      this._latlng = toLatLng(latlng);\n\n      if (this._map) {\n        this._updatePosition();\n\n        this._adjustPan();\n      }\n\n      return this;\n    },\n    // @method getContent: String|HTMLElement\n    // Returns the content of the popup.\n    getContent: function () {\n      return this._content;\n    },\n    // @method setContent(htmlContent: String|HTMLElement|Function): this\n    // Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.\n    setContent: function (content) {\n      this._content = content;\n      this.update();\n      return this;\n    },\n    // @method getElement: String|HTMLElement\n    // Alias for [getContent()](#popup-getcontent)\n    getElement: function () {\n      return this._container;\n    },\n    // @method update: null\n    // Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.\n    update: function () {\n      if (!this._map) {\n        return;\n      }\n\n      this._container.style.visibility = 'hidden';\n\n      this._updateContent();\n\n      this._updateLayout();\n\n      this._updatePosition();\n\n      this._container.style.visibility = '';\n\n      this._adjustPan();\n    },\n    getEvents: function () {\n      var events = {\n        zoom: this._updatePosition,\n        viewreset: this._updatePosition\n      };\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n\n      return events;\n    },\n    // @method isOpen: Boolean\n    // Returns `true` when the popup is visible on the map.\n    isOpen: function () {\n      return !!this._map && this._map.hasLayer(this);\n    },\n    // @method bringToFront: this\n    // Brings this popup in front of other popups (in the same map pane).\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._container);\n      }\n\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings this popup to the back of other popups (in the same map pane).\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._container);\n      }\n\n      return this;\n    },\n    _prepareOpen: function (parent, layer, latlng) {\n      if (!(layer instanceof Layer)) {\n        latlng = layer;\n        layer = parent;\n      }\n\n      if (layer instanceof FeatureGroup) {\n        for (var id in parent._layers) {\n          layer = parent._layers[id];\n          break;\n        }\n      }\n\n      if (!latlng) {\n        if (layer.getCenter) {\n          latlng = layer.getCenter();\n        } else if (layer.getLatLng) {\n          latlng = layer.getLatLng();\n        } else {\n          throw new Error('Unable to get source layer LatLng.');\n        }\n      } // set overlay source to this layer\n\n\n      this._source = layer; // update the overlay (content, layout, ect...)\n\n      this.update();\n      return latlng;\n    },\n    _updateContent: function () {\n      if (!this._content) {\n        return;\n      }\n\n      var node = this._contentNode;\n      var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;\n\n      if (typeof content === 'string') {\n        node.innerHTML = content;\n      } else {\n        while (node.hasChildNodes()) {\n          node.removeChild(node.firstChild);\n        }\n\n        node.appendChild(content);\n      }\n\n      this.fire('contentupdate');\n    },\n    _updatePosition: function () {\n      if (!this._map) {\n        return;\n      }\n\n      var pos = this._map.latLngToLayerPoint(this._latlng),\n          offset = toPoint(this.options.offset),\n          anchor = this._getAnchor();\n\n      if (this._zoomAnimated) {\n        setPosition(this._container, pos.add(anchor));\n      } else {\n        offset = offset.add(pos).add(anchor);\n      }\n\n      var bottom = this._containerBottom = -offset.y,\n          left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x; // bottom position the popup in case the height of the popup changes (images loading etc)\n\n      this._container.style.bottom = bottom + 'px';\n      this._container.style.left = left + 'px';\n    },\n    _getAnchor: function () {\n      return [0, 0];\n    }\n  });\n  /*\r\n   * @class Popup\r\n   * @inherits DivOverlay\r\n   * @aka L.Popup\r\n   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to\r\n   * open popups while making sure that only one popup is open at one time\r\n   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.\r\n   *\r\n   * @example\r\n   *\r\n   * If you want to just bind a popup to marker click and then open it, it's really easy:\r\n   *\r\n   * ```js\r\n   * marker.bindPopup(popupContent).openPopup();\r\n   * ```\r\n   * Path overlays like polylines also have a `bindPopup` method.\r\n   * Here's a more complicated way to open a popup on a map:\r\n   *\r\n   * ```js\r\n   * var popup = L.popup()\r\n   * \t.setLatLng(latlng)\r\n   * \t.setContent('<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   */\n  // @namespace Popup\n\n  var Popup = DivOverlay.extend({\n    // @section\n    // @aka Popup options\n    options: {\n      // @option maxWidth: Number = 300\n      // Max width of the popup, in pixels.\n      maxWidth: 300,\n      // @option minWidth: Number = 50\n      // Min width of the popup, in pixels.\n      minWidth: 50,\n      // @option maxHeight: Number = null\n      // If set, creates a scrollable container of the given height\n      // inside a popup if its content exceeds it.\n      maxHeight: null,\n      // @option autoPan: Boolean = true\n      // Set it to `false` if you don't want the map to do panning animation\n      // to fit the opened popup.\n      autoPan: true,\n      // @option autoPanPaddingTopLeft: Point = null\n      // The margin between the popup and the top left corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingTopLeft: null,\n      // @option autoPanPaddingBottomRight: Point = null\n      // The margin between the popup and the bottom right corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingBottomRight: null,\n      // @option autoPanPadding: Point = Point(5, 5)\n      // Equivalent of setting both top left and bottom right autopan padding to the same value.\n      autoPanPadding: [5, 5],\n      // @option keepInView: Boolean = false\n      // Set it to `true` if you want to prevent users from panning the popup\n      // off of the screen while it is open.\n      keepInView: false,\n      // @option closeButton: Boolean = true\n      // Controls the presence of a close button in the popup.\n      closeButton: true,\n      // @option autoClose: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the popup closing when another popup is opened.\n      autoClose: true,\n      // @option closeOnEscapeKey: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the ESC key for closing of the popup.\n      closeOnEscapeKey: true,\n      // @option closeOnClick: Boolean = *\n      // Set it if you want to override the default behavior of the popup closing when user clicks\n      // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.\n      // @option className: String = ''\n      // A custom CSS class name to assign to the popup.\n      className: ''\n    },\n    // @namespace Popup\n    // @method openOn(map: Map): this\n    // Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.\n    openOn: function (map) {\n      map.openPopup(this);\n      return this;\n    },\n    onAdd: function (map) {\n      DivOverlay.prototype.onAdd.call(this, map); // @namespace Map\n      // @section Popup events\n      // @event popupopen: PopupEvent\n      // Fired when a popup is opened in the map\n\n      map.fire('popupopen', {\n        popup: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupopen: PopupEvent\n        // Fired when a popup bound to this layer is opened\n        this._source.fire('popupopen', {\n          popup: this\n        }, true); // For non-path layers, we toggle the popup when clicking\n        // again the layer, so prevent the map to reopen it.\n\n\n        if (!(this._source instanceof Path)) {\n          this._source.on('preclick', stopPropagation);\n        }\n      }\n    },\n    onRemove: function (map) {\n      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map\n      // @section Popup events\n      // @event popupclose: PopupEvent\n      // Fired when a popup in the map is closed\n\n      map.fire('popupclose', {\n        popup: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupclose: PopupEvent\n        // Fired when a popup bound to this layer is closed\n        this._source.fire('popupclose', {\n          popup: this\n        }, true);\n\n        if (!(this._source instanceof Path)) {\n          this._source.off('preclick', stopPropagation);\n        }\n      }\n    },\n    getEvents: function () {\n      var events = DivOverlay.prototype.getEvents.call(this);\n\n      if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\n        events.preclick = this._close;\n      }\n\n      if (this.options.keepInView) {\n        events.moveend = this._adjustPan;\n      }\n\n      return events;\n    },\n    _close: function () {\n      if (this._map) {\n        this._map.closePopup(this);\n      }\n    },\n    _initLayout: function () {\n      var prefix = 'leaflet-popup',\n          container = this._container = create$1('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');\n      var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);\n      this._contentNode = create$1('div', prefix + '-content', wrapper);\n      disableClickPropagation(wrapper);\n      disableScrollPropagation(this._contentNode);\n      on(wrapper, 'contextmenu', stopPropagation);\n      this._tipContainer = create$1('div', prefix + '-tip-container', container);\n      this._tip = create$1('div', prefix + '-tip', this._tipContainer);\n\n      if (this.options.closeButton) {\n        var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);\n        closeButton.href = '#close';\n        closeButton.innerHTML = '&#215;';\n        on(closeButton, 'click', this._onCloseButtonClick, this);\n      }\n    },\n    _updateLayout: function () {\n      var container = this._contentNode,\n          style = container.style;\n      style.width = '';\n      style.whiteSpace = 'nowrap';\n      var width = container.offsetWidth;\n      width = Math.min(width, this.options.maxWidth);\n      width = Math.max(width, this.options.minWidth);\n      style.width = width + 1 + 'px';\n      style.whiteSpace = '';\n      style.height = '';\n      var height = container.offsetHeight,\n          maxHeight = this.options.maxHeight,\n          scrolledClass = 'leaflet-popup-scrolled';\n\n      if (maxHeight && height > maxHeight) {\n        style.height = maxHeight + 'px';\n        addClass(container, scrolledClass);\n      } else {\n        removeClass(container, scrolledClass);\n      }\n\n      this._containerWidth = this._container.offsetWidth;\n    },\n    _animateZoom: function (e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),\n          anchor = this._getAnchor();\n\n      setPosition(this._container, pos.add(anchor));\n    },\n    _adjustPan: function () {\n      if (!this.options.autoPan) {\n        return;\n      }\n\n      if (this._map._panAnim) {\n        this._map._panAnim.stop();\n      }\n\n      var map = this._map,\n          marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,\n          containerHeight = this._container.offsetHeight + marginBottom,\n          containerWidth = this._containerWidth,\n          layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);\n\n      layerPos._add(getPosition(this._container));\n\n      var containerPos = map.layerPointToContainerPoint(layerPos),\n          padding = toPoint(this.options.autoPanPadding),\n          paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),\n          paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),\n          size = map.getSize(),\n          dx = 0,\n          dy = 0;\n\n      if (containerPos.x + containerWidth + paddingBR.x > size.x) {\n        // right\n        dx = containerPos.x + containerWidth - size.x + paddingBR.x;\n      }\n\n      if (containerPos.x - dx - paddingTL.x < 0) {\n        // left\n        dx = containerPos.x - paddingTL.x;\n      }\n\n      if (containerPos.y + containerHeight + paddingBR.y > size.y) {\n        // bottom\n        dy = containerPos.y + containerHeight - size.y + paddingBR.y;\n      }\n\n      if (containerPos.y - dy - paddingTL.y < 0) {\n        // top\n        dy = containerPos.y - paddingTL.y;\n      } // @namespace Map\n      // @section Popup events\n      // @event autopanstart: Event\n      // Fired when the map starts autopanning when opening a popup.\n\n\n      if (dx || dy) {\n        map.fire('autopanstart').panBy([dx, dy]);\n      }\n    },\n    _onCloseButtonClick: function (e) {\n      this._close();\n\n      stop(e);\n    },\n    _getAnchor: function () {\n      // Where should we anchor the popup on the source layer?\n      return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);\n    }\n  }); // @namespace Popup\n  // @factory L.popup(options?: Popup options, source?: Layer)\n  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.\n\n  var popup = function (options, source) {\n    return new Popup(options, source);\n  };\n  /* @namespace Map\r\n   * @section Interaction Options\r\n   * @option closePopupOnClick: Boolean = true\r\n   * Set it to `false` if you don't want popups to close when user clicks the map.\r\n   */\n\n\n  Map.mergeOptions({\n    closePopupOnClick: true\n  }); // @namespace Map\n  // @section Methods for Layers and Controls\n\n  Map.include({\n    // @method openPopup(popup: Popup): this\n    // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).\n    // @alternative\n    // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this\n    // Creates a popup with the specified content and options and opens it in the given point on a map.\n    openPopup: function (popup, latlng, options) {\n      if (!(popup instanceof Popup)) {\n        popup = new Popup(options).setContent(popup);\n      }\n\n      if (latlng) {\n        popup.setLatLng(latlng);\n      }\n\n      if (this.hasLayer(popup)) {\n        return this;\n      }\n\n      if (this._popup && this._popup.options.autoClose) {\n        this.closePopup();\n      }\n\n      this._popup = popup;\n      return this.addLayer(popup);\n    },\n    // @method closePopup(popup?: Popup): this\n    // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).\n    closePopup: function (popup) {\n      if (!popup || popup === this._popup) {\n        popup = this._popup;\n        this._popup = null;\n      }\n\n      if (popup) {\n        this.removeLayer(popup);\n      }\n\n      return this;\n    }\n  });\n  /*\r\n   * @namespace Layer\r\n   * @section Popup methods example\r\n   *\r\n   * All layers share a set of methods convenient for binding popups to it.\r\n   *\r\n   * ```js\r\n   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);\r\n   * layer.openPopup();\r\n   * layer.closePopup();\r\n   * ```\r\n   *\r\n   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.\r\n   */\n  // @section Popup methods\n\n  Layer.include({\n    // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this\n    // Binds a popup to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindPopup: function (content, options) {\n      if (content instanceof Popup) {\n        setOptions(content, options);\n        this._popup = content;\n        content._source = this;\n      } else {\n        if (!this._popup || options) {\n          this._popup = new Popup(options, this);\n        }\n\n        this._popup.setContent(content);\n      }\n\n      if (!this._popupHandlersAdded) {\n        this.on({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = true;\n      }\n\n      return this;\n    },\n    // @method unbindPopup(): this\n    // Removes the popup previously bound with `bindPopup`.\n    unbindPopup: function () {\n      if (this._popup) {\n        this.off({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = false;\n        this._popup = null;\n      }\n\n      return this;\n    },\n    // @method openPopup(latlng?: LatLng): this\n    // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.\n    openPopup: function (layer, latlng) {\n      if (this._popup && this._map) {\n        latlng = this._popup._prepareOpen(this, layer, latlng); // open the popup on the map\n\n        this._map.openPopup(this._popup, latlng);\n      }\n\n      return this;\n    },\n    // @method closePopup(): this\n    // Closes the popup bound to this layer if it is open.\n    closePopup: function () {\n      if (this._popup) {\n        this._popup._close();\n      }\n\n      return this;\n    },\n    // @method togglePopup(): this\n    // Opens or closes the popup bound to this layer depending on its current state.\n    togglePopup: function (target) {\n      if (this._popup) {\n        if (this._popup._map) {\n          this.closePopup();\n        } else {\n          this.openPopup(target);\n        }\n      }\n\n      return this;\n    },\n    // @method isPopupOpen(): boolean\n    // Returns `true` if the popup bound to this layer is currently open.\n    isPopupOpen: function () {\n      return this._popup ? this._popup.isOpen() : false;\n    },\n    // @method setPopupContent(content: String|HTMLElement|Popup): this\n    // Sets the content of the popup bound to this layer.\n    setPopupContent: function (content) {\n      if (this._popup) {\n        this._popup.setContent(content);\n      }\n\n      return this;\n    },\n    // @method getPopup(): Popup\n    // Returns the popup bound to this layer.\n    getPopup: function () {\n      return this._popup;\n    },\n    _openPopup: function (e) {\n      var layer = e.layer || e.target;\n\n      if (!this._popup) {\n        return;\n      }\n\n      if (!this._map) {\n        return;\n      } // prevent map click\n\n\n      stop(e); // if this inherits from Path its a vector and we can just\n      // open the popup at the new location\n\n      if (layer instanceof Path) {\n        this.openPopup(e.layer || e.target, e.latlng);\n        return;\n      } // otherwise treat it like a marker and figure out\n      // if we should toggle it open/closed\n\n\n      if (this._map.hasLayer(this._popup) && this._popup._source === layer) {\n        this.closePopup();\n      } else {\n        this.openPopup(layer, e.latlng);\n      }\n    },\n    _movePopup: function (e) {\n      this._popup.setLatLng(e.latlng);\n    },\n    _onKeyPress: function (e) {\n      if (e.originalEvent.keyCode === 13) {\n        this._openPopup(e);\n      }\n    }\n  });\n  /*\n   * @class Tooltip\n   * @inherits DivOverlay\n   * @aka L.Tooltip\n   * Used to display small texts on top of map layers.\n   *\n   * @example\n   *\n   * ```js\n   * marker.bindTooltip(\"my tooltip text\").openTooltip();\n   * ```\n   * Note about tooltip offset. Leaflet takes two options in consideration\n   * for computing tooltip offsetting:\n   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.\n   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to\n   *   move it to the bottom. Negatives will move to the left and top.\n   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You\n   *   should adapt this value if you use a custom icon.\n   */\n  // @namespace Tooltip\n\n  var Tooltip = DivOverlay.extend({\n    // @section\n    // @aka Tooltip options\n    options: {\n      // @option pane: String = 'tooltipPane'\n      // `Map pane` where the tooltip will be added.\n      pane: 'tooltipPane',\n      // @option offset: Point = Point(0, 0)\n      // Optional offset of the tooltip position.\n      offset: [0, 0],\n      // @option direction: String = 'auto'\n      // Direction where to open the tooltip. Possible values are: `right`, `left`,\n      // `top`, `bottom`, `center`, `auto`.\n      // `auto` will dynamically switch between `right` and `left` according to the tooltip\n      // position on the map.\n      direction: 'auto',\n      // @option permanent: Boolean = false\n      // Whether to open the tooltip permanently or only on mouseover.\n      permanent: false,\n      // @option sticky: Boolean = false\n      // If true, the tooltip will follow the mouse instead of being fixed at the feature center.\n      sticky: false,\n      // @option interactive: Boolean = false\n      // If true, the tooltip will listen to the feature events.\n      interactive: false,\n      // @option opacity: Number = 0.9\n      // Tooltip container opacity.\n      opacity: 0.9\n    },\n    onAdd: function (map) {\n      DivOverlay.prototype.onAdd.call(this, map);\n      this.setOpacity(this.options.opacity); // @namespace Map\n      // @section Tooltip events\n      // @event tooltipopen: TooltipEvent\n      // Fired when a tooltip is opened in the map.\n\n      map.fire('tooltipopen', {\n        tooltip: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipopen: TooltipEvent\n        // Fired when a tooltip bound to this layer is opened.\n        this._source.fire('tooltipopen', {\n          tooltip: this\n        }, true);\n      }\n    },\n    onRemove: function (map) {\n      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map\n      // @section Tooltip events\n      // @event tooltipclose: TooltipEvent\n      // Fired when a tooltip in the map is closed.\n\n      map.fire('tooltipclose', {\n        tooltip: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipclose: TooltipEvent\n        // Fired when a tooltip bound to this layer is closed.\n        this._source.fire('tooltipclose', {\n          tooltip: this\n        }, true);\n      }\n    },\n    getEvents: function () {\n      var events = DivOverlay.prototype.getEvents.call(this);\n\n      if (touch && !this.options.permanent) {\n        events.preclick = this._close;\n      }\n\n      return events;\n    },\n    _close: function () {\n      if (this._map) {\n        this._map.closeTooltip(this);\n      }\n    },\n    _initLayout: function () {\n      var prefix = 'leaflet-tooltip',\n          className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      this._contentNode = this._container = create$1('div', className);\n    },\n    _updateLayout: function () {},\n    _adjustPan: function () {},\n    _setPosition: function (pos) {\n      var map = this._map,\n          container = this._container,\n          centerPoint = map.latLngToContainerPoint(map.getCenter()),\n          tooltipPoint = map.layerPointToContainerPoint(pos),\n          direction = this.options.direction,\n          tooltipWidth = container.offsetWidth,\n          tooltipHeight = container.offsetHeight,\n          offset = toPoint(this.options.offset),\n          anchor = this._getAnchor();\n\n      if (direction === 'top') {\n        pos = pos.add(toPoint(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));\n      } else if (direction === 'bottom') {\n        pos = pos.subtract(toPoint(tooltipWidth / 2 - offset.x, -offset.y, true));\n      } else if (direction === 'center') {\n        pos = pos.subtract(toPoint(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));\n      } else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {\n        direction = 'right';\n        pos = pos.add(toPoint(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));\n      } else {\n        direction = 'left';\n        pos = pos.subtract(toPoint(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));\n      }\n\n      removeClass(container, 'leaflet-tooltip-right');\n      removeClass(container, 'leaflet-tooltip-left');\n      removeClass(container, 'leaflet-tooltip-top');\n      removeClass(container, 'leaflet-tooltip-bottom');\n      addClass(container, 'leaflet-tooltip-' + direction);\n      setPosition(container, pos);\n    },\n    _updatePosition: function () {\n      var pos = this._map.latLngToLayerPoint(this._latlng);\n\n      this._setPosition(pos);\n    },\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      if (this._container) {\n        setOpacity(this._container, opacity);\n      }\n    },\n    _animateZoom: function (e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n\n      this._setPosition(pos);\n    },\n    _getAnchor: function () {\n      // Where should we anchor the tooltip on the source layer?\n      return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);\n    }\n  }); // @namespace Tooltip\n  // @factory L.tooltip(options?: Tooltip options, source?: Layer)\n  // Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.\n\n  var tooltip = function (options, source) {\n    return new Tooltip(options, source);\n  }; // @namespace Map\n  // @section Methods for Layers and Controls\n\n\n  Map.include({\n    // @method openTooltip(tooltip: Tooltip): this\n    // Opens the specified tooltip.\n    // @alternative\n    // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this\n    // Creates a tooltip with the specified content and options and open it.\n    openTooltip: function (tooltip, latlng, options) {\n      if (!(tooltip instanceof Tooltip)) {\n        tooltip = new Tooltip(options).setContent(tooltip);\n      }\n\n      if (latlng) {\n        tooltip.setLatLng(latlng);\n      }\n\n      if (this.hasLayer(tooltip)) {\n        return this;\n      }\n\n      return this.addLayer(tooltip);\n    },\n    // @method closeTooltip(tooltip?: Tooltip): this\n    // Closes the tooltip given as parameter.\n    closeTooltip: function (tooltip) {\n      if (tooltip) {\n        this.removeLayer(tooltip);\n      }\n\n      return this;\n    }\n  });\n  /*\n   * @namespace Layer\n   * @section Tooltip methods example\n   *\n   * All layers share a set of methods convenient for binding tooltips to it.\n   *\n   * ```js\n   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);\n   * layer.openTooltip();\n   * layer.closeTooltip();\n   * ```\n   */\n  // @section Tooltip methods\n\n  Layer.include({\n    // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this\n    // Binds a tooltip to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindTooltip: function (content, options) {\n      if (content instanceof Tooltip) {\n        setOptions(content, options);\n        this._tooltip = content;\n        content._source = this;\n      } else {\n        if (!this._tooltip || options) {\n          this._tooltip = new Tooltip(options, this);\n        }\n\n        this._tooltip.setContent(content);\n      }\n\n      this._initTooltipInteractions();\n\n      if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {\n        this.openTooltip();\n      }\n\n      return this;\n    },\n    // @method unbindTooltip(): this\n    // Removes the tooltip previously bound with `bindTooltip`.\n    unbindTooltip: function () {\n      if (this._tooltip) {\n        this._initTooltipInteractions(true);\n\n        this.closeTooltip();\n        this._tooltip = null;\n      }\n\n      return this;\n    },\n    _initTooltipInteractions: function (remove$$1) {\n      if (!remove$$1 && this._tooltipHandlersAdded) {\n        return;\n      }\n\n      var onOff = remove$$1 ? 'off' : 'on',\n          events = {\n        remove: this.closeTooltip,\n        move: this._moveTooltip\n      };\n\n      if (!this._tooltip.options.permanent) {\n        events.mouseover = this._openTooltip;\n        events.mouseout = this.closeTooltip;\n\n        if (this._tooltip.options.sticky) {\n          events.mousemove = this._moveTooltip;\n        }\n\n        if (touch) {\n          events.click = this._openTooltip;\n        }\n      } else {\n        events.add = this._openTooltip;\n      }\n\n      this[onOff](events);\n      this._tooltipHandlersAdded = !remove$$1;\n    },\n    // @method openTooltip(latlng?: LatLng): this\n    // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.\n    openTooltip: function (layer, latlng) {\n      if (this._tooltip && this._map) {\n        latlng = this._tooltip._prepareOpen(this, layer, latlng); // open the tooltip on the map\n\n        this._map.openTooltip(this._tooltip, latlng); // Tooltip container may not be defined if not permanent and never\n        // opened.\n\n\n        if (this._tooltip.options.interactive && this._tooltip._container) {\n          addClass(this._tooltip._container, 'leaflet-clickable');\n          this.addInteractiveTarget(this._tooltip._container);\n        }\n      }\n\n      return this;\n    },\n    // @method closeTooltip(): this\n    // Closes the tooltip bound to this layer if it is open.\n    closeTooltip: function () {\n      if (this._tooltip) {\n        this._tooltip._close();\n\n        if (this._tooltip.options.interactive && this._tooltip._container) {\n          removeClass(this._tooltip._container, 'leaflet-clickable');\n          this.removeInteractiveTarget(this._tooltip._container);\n        }\n      }\n\n      return this;\n    },\n    // @method toggleTooltip(): this\n    // Opens or closes the tooltip bound to this layer depending on its current state.\n    toggleTooltip: function (target) {\n      if (this._tooltip) {\n        if (this._tooltip._map) {\n          this.closeTooltip();\n        } else {\n          this.openTooltip(target);\n        }\n      }\n\n      return this;\n    },\n    // @method isTooltipOpen(): boolean\n    // Returns `true` if the tooltip bound to this layer is currently open.\n    isTooltipOpen: function () {\n      return this._tooltip.isOpen();\n    },\n    // @method setTooltipContent(content: String|HTMLElement|Tooltip): this\n    // Sets the content of the tooltip bound to this layer.\n    setTooltipContent: function (content) {\n      if (this._tooltip) {\n        this._tooltip.setContent(content);\n      }\n\n      return this;\n    },\n    // @method getTooltip(): Tooltip\n    // Returns the tooltip bound to this layer.\n    getTooltip: function () {\n      return this._tooltip;\n    },\n    _openTooltip: function (e) {\n      var layer = e.layer || e.target;\n\n      if (!this._tooltip || !this._map) {\n        return;\n      }\n\n      this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);\n    },\n    _moveTooltip: function (e) {\n      var latlng = e.latlng,\n          containerPoint,\n          layerPoint;\n\n      if (this._tooltip.options.sticky && e.originalEvent) {\n        containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);\n        layerPoint = this._map.containerPointToLayerPoint(containerPoint);\n        latlng = this._map.layerPointToLatLng(layerPoint);\n      }\n\n      this._tooltip.setLatLng(latlng);\n    }\n  });\n  /*\n   * @class DivIcon\n   * @aka L.DivIcon\n   * @inherits Icon\n   *\n   * Represents a lightweight icon for markers that uses a simple `<div>`\n   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.\n   *\n   * @example\n   * ```js\n   * var myIcon = L.divIcon({className: 'my-div-icon'});\n   * // you can set .my-div-icon styles in CSS\n   *\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\n   * ```\n   *\n   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.\n   */\n\n  var DivIcon = Icon.extend({\n    options: {\n      // @section\n      // @aka DivIcon options\n      iconSize: [12, 12],\n      // also can be set through CSS\n      // iconAnchor: (Point),\n      // popupAnchor: (Point),\n      // @option html: String|HTMLElement = ''\n      // Custom HTML code to put inside the div element, empty by default. Alternatively,\n      // an instance of `HTMLElement`.\n      html: false,\n      // @option bgPos: Point = [0, 0]\n      // Optional relative position of the background, in pixels\n      bgPos: null,\n      className: 'leaflet-div-icon'\n    },\n    createIcon: function (oldIcon) {\n      var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),\n          options = this.options;\n\n      if (options.html instanceof Element) {\n        empty(div);\n        div.appendChild(options.html);\n      } else {\n        div.innerHTML = options.html !== false ? options.html : '';\n      }\n\n      if (options.bgPos) {\n        var bgPos = toPoint(options.bgPos);\n        div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';\n      }\n\n      this._setIconStyles(div, 'icon');\n\n      return div;\n    },\n    createShadow: function () {\n      return null;\n    }\n  }); // @factory L.divIcon(options: DivIcon options)\n  // Creates a `DivIcon` instance with the given options.\n\n  function divIcon(options) {\n    return new DivIcon(options);\n  }\n\n  Icon.Default = IconDefault;\n  /*\n   * @class GridLayer\n   * @inherits Layer\n   * @aka L.GridLayer\n   *\n   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.\n   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.\n   *\n   *\n   * @section Synchronous usage\n   * @example\n   *\n   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords){\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z\n   *         var ctx = tile.getContext('2d');\n   *\n   *         // return the tile so it can be rendered on screen\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section Asynchronous usage\n   * @example\n   *\n   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords, done){\n   *         var error;\n   *\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // draw something asynchronously and pass the tile to the done() callback\n   *         setTimeout(function() {\n   *             done(error, tile);\n   *         }, 1000);\n   *\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section\n   */\n\n  var GridLayer = Layer.extend({\n    // @section\n    // @aka GridLayer options\n    options: {\n      // @option tileSize: Number|Point = 256\n      // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n      tileSize: 256,\n      // @option opacity: Number = 1.0\n      // Opacity of the tiles. Can be used in the `createTile()` function.\n      opacity: 1,\n      // @option updateWhenIdle: Boolean = (depends)\n      // Load new tiles only when panning ends.\n      // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n      // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the\n      // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n      updateWhenIdle: mobile,\n      // @option updateWhenZooming: Boolean = true\n      // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.\n      updateWhenZooming: true,\n      // @option updateInterval: Number = 200\n      // Tiles will not update more than once every `updateInterval` milliseconds when panning.\n      updateInterval: 200,\n      // @option zIndex: Number = 1\n      // The explicit zIndex of the tile layer.\n      zIndex: 1,\n      // @option bounds: LatLngBounds = undefined\n      // If set, tiles will only be loaded inside the set `LatLngBounds`.\n      bounds: null,\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = undefined\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: undefined,\n      // @option maxNativeZoom: Number = undefined\n      // Maximum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded\n      // from `maxNativeZoom` level and auto-scaled.\n      maxNativeZoom: undefined,\n      // @option minNativeZoom: Number = undefined\n      // Minimum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels lower than `minNativeZoom` will be loaded\n      // from `minNativeZoom` level and auto-scaled.\n      minNativeZoom: undefined,\n      // @option noWrap: Boolean = false\n      // Whether the layer is wrapped around the antimeridian. If `true`, the\n      // GridLayer will only be displayed once at low zoom levels. Has no\n      // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n      // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n      // tiles outside the CRS limits.\n      noWrap: false,\n      // @option pane: String = 'tilePane'\n      // `Map pane` where the grid layer will be added.\n      pane: 'tilePane',\n      // @option className: String = ''\n      // A custom class name to assign to the tile layer. Empty by default.\n      className: '',\n      // @option keepBuffer: Number = 2\n      // When panning the map, keep this many rows and columns of tiles before unloading them.\n      keepBuffer: 2\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    onAdd: function () {\n      this._initContainer();\n\n      this._levels = {};\n      this._tiles = {};\n\n      this._resetView();\n\n      this._update();\n    },\n    beforeAdd: function (map) {\n      map._addZoomLimit(this);\n    },\n    onRemove: function (map) {\n      this._removeAllTiles();\n\n      remove(this._container);\n\n      map._removeZoomLimit(this);\n\n      this._container = null;\n      this._tileZoom = undefined;\n    },\n    // @method bringToFront: this\n    // Brings the tile layer to the top of all tile layers.\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._container);\n\n        this._setAutoZIndex(Math.max);\n      }\n\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings the tile layer to the bottom of all tile layers.\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._container);\n\n        this._setAutoZIndex(Math.min);\n      }\n\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the tiles for this layer.\n    getContainer: function () {\n      return this._container;\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the [opacity](#gridlayer-opacity) of the grid layer.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      this._updateOpacity();\n\n      return this;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Changes the [zIndex](#gridlayer-zindex) of the grid layer.\n    setZIndex: function (zIndex) {\n      this.options.zIndex = zIndex;\n\n      this._updateZIndex();\n\n      return this;\n    },\n    // @method isLoading: Boolean\n    // Returns `true` if any tile in the grid layer has not finished loading.\n    isLoading: function () {\n      return this._loading;\n    },\n    // @method redraw: this\n    // Causes the layer to clear all the tiles and request them again.\n    redraw: function () {\n      if (this._map) {\n        this._removeAllTiles();\n\n        this._update();\n      }\n\n      return this;\n    },\n    getEvents: function () {\n      var events = {\n        viewprereset: this._invalidateAll,\n        viewreset: this._resetView,\n        zoom: this._resetView,\n        moveend: this._onMoveEnd\n      };\n\n      if (!this.options.updateWhenIdle) {\n        // update tiles on move, but not more often than once per given interval\n        if (!this._onMove) {\n          this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);\n        }\n\n        events.move = this._onMove;\n      }\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n\n      return events;\n    },\n    // @section Extension methods\n    // Layers extending `GridLayer` shall reimplement the following method.\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, must be overridden by classes extending `GridLayer`.\n    // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n    // is specified, it must be called when the tile has finished loading and drawing.\n    createTile: function () {\n      return document.createElement('div');\n    },\n    // @section\n    // @method getTileSize: Point\n    // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.\n    getTileSize: function () {\n      var s = this.options.tileSize;\n      return s instanceof Point ? s : new Point(s, s);\n    },\n    _updateZIndex: function () {\n      if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._container.style.zIndex = this.options.zIndex;\n      }\n    },\n    _setAutoZIndex: function (compare) {\n      // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n      var layers = this.getPane().children,\n          edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n\n      for (var i = 0, len = layers.length, zIndex; i < len; i++) {\n        zIndex = layers[i].style.zIndex;\n\n        if (layers[i] !== this._container && zIndex) {\n          edgeZIndex = compare(edgeZIndex, +zIndex);\n        }\n      }\n\n      if (isFinite(edgeZIndex)) {\n        this.options.zIndex = edgeZIndex + compare(-1, 1);\n\n        this._updateZIndex();\n      }\n    },\n    _updateOpacity: function () {\n      if (!this._map) {\n        return;\n      } // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n\n\n      if (ielt9) {\n        return;\n      }\n\n      setOpacity(this._container, this.options.opacity);\n      var now = +new Date(),\n          nextFrame = false,\n          willPrune = false;\n\n      for (var key in this._tiles) {\n        var tile = this._tiles[key];\n\n        if (!tile.current || !tile.loaded) {\n          continue;\n        }\n\n        var fade = Math.min(1, (now - tile.loaded) / 200);\n        setOpacity(tile.el, fade);\n\n        if (fade < 1) {\n          nextFrame = true;\n        } else {\n          if (tile.active) {\n            willPrune = true;\n          } else {\n            this._onOpaqueTile(tile);\n          }\n\n          tile.active = true;\n        }\n      }\n\n      if (willPrune && !this._noPrune) {\n        this._pruneTiles();\n      }\n\n      if (nextFrame) {\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      }\n    },\n    _onOpaqueTile: falseFn,\n    _initContainer: function () {\n      if (this._container) {\n        return;\n      }\n\n      this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));\n\n      this._updateZIndex();\n\n      if (this.options.opacity < 1) {\n        this._updateOpacity();\n      }\n\n      this.getPane().appendChild(this._container);\n    },\n    _updateLevels: function () {\n      var zoom = this._tileZoom,\n          maxZoom = this.options.maxZoom;\n\n      if (zoom === undefined) {\n        return undefined;\n      }\n\n      for (var z in this._levels) {\n        if (this._levels[z].el.children.length || z === zoom) {\n          this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n\n          this._onUpdateLevel(z);\n        } else {\n          remove(this._levels[z].el);\n\n          this._removeTilesAtZoom(z);\n\n          this._onRemoveLevel(z);\n\n          delete this._levels[z];\n        }\n      }\n\n      var level = this._levels[zoom],\n          map = this._map;\n\n      if (!level) {\n        level = this._levels[zoom] = {};\n        level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);\n        level.el.style.zIndex = maxZoom;\n        level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n        level.zoom = zoom;\n\n        this._setZoomTransform(level, map.getCenter(), map.getZoom()); // force the browser to consider the newly added element for transition\n\n\n        falseFn(level.el.offsetWidth);\n\n        this._onCreateLevel(level);\n      }\n\n      this._level = level;\n      return level;\n    },\n    _onUpdateLevel: falseFn,\n    _onRemoveLevel: falseFn,\n    _onCreateLevel: falseFn,\n    _pruneTiles: function () {\n      if (!this._map) {\n        return;\n      }\n\n      var key, tile;\n\n      var zoom = this._map.getZoom();\n\n      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n        this._removeAllTiles();\n\n        return;\n      }\n\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n        tile.retain = tile.current;\n      }\n\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n\n        if (tile.current && !tile.active) {\n          var coords = tile.coords;\n\n          if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n            this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n          }\n        }\n      }\n\n      for (key in this._tiles) {\n        if (!this._tiles[key].retain) {\n          this._removeTile(key);\n        }\n      }\n    },\n    _removeTilesAtZoom: function (zoom) {\n      for (var key in this._tiles) {\n        if (this._tiles[key].coords.z !== zoom) {\n          continue;\n        }\n\n        this._removeTile(key);\n      }\n    },\n    _removeAllTiles: function () {\n      for (var key in this._tiles) {\n        this._removeTile(key);\n      }\n    },\n    _invalidateAll: function () {\n      for (var z in this._levels) {\n        remove(this._levels[z].el);\n\n        this._onRemoveLevel(z);\n\n        delete this._levels[z];\n      }\n\n      this._removeAllTiles();\n\n      this._tileZoom = undefined;\n    },\n    _retainParent: function (x, y, z, minZoom) {\n      var x2 = Math.floor(x / 2),\n          y2 = Math.floor(y / 2),\n          z2 = z - 1,\n          coords2 = new Point(+x2, +y2);\n      coords2.z = +z2;\n\n      var key = this._tileCoordsToKey(coords2),\n          tile = this._tiles[key];\n\n      if (tile && tile.active) {\n        tile.retain = true;\n        return true;\n      } else if (tile && tile.loaded) {\n        tile.retain = true;\n      }\n\n      if (z2 > minZoom) {\n        return this._retainParent(x2, y2, z2, minZoom);\n      }\n\n      return false;\n    },\n    _retainChildren: function (x, y, z, maxZoom) {\n      for (var i = 2 * x; i < 2 * x + 2; i++) {\n        for (var j = 2 * y; j < 2 * y + 2; j++) {\n          var coords = new Point(i, j);\n          coords.z = z + 1;\n\n          var key = this._tileCoordsToKey(coords),\n              tile = this._tiles[key];\n\n          if (tile && tile.active) {\n            tile.retain = true;\n            continue;\n          } else if (tile && tile.loaded) {\n            tile.retain = true;\n          }\n\n          if (z + 1 < maxZoom) {\n            this._retainChildren(i, j, z + 1, maxZoom);\n          }\n        }\n      }\n    },\n    _resetView: function (e) {\n      var animating = e && (e.pinch || e.flyTo);\n\n      this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n    },\n    _animateZoom: function (e) {\n      this._setView(e.center, e.zoom, true, e.noUpdate);\n    },\n    _clampZoom: function (zoom) {\n      var options = this.options;\n\n      if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {\n        return options.minNativeZoom;\n      }\n\n      if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {\n        return options.maxNativeZoom;\n      }\n\n      return zoom;\n    },\n    _setView: function (center, zoom, noPrune, noUpdate) {\n      var tileZoom = this._clampZoom(Math.round(zoom));\n\n      if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {\n        tileZoom = undefined;\n      }\n\n      var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;\n\n      if (!noUpdate || tileZoomChanged) {\n        this._tileZoom = tileZoom;\n\n        if (this._abortLoading) {\n          this._abortLoading();\n        }\n\n        this._updateLevels();\n\n        this._resetGrid();\n\n        if (tileZoom !== undefined) {\n          this._update(center);\n        }\n\n        if (!noPrune) {\n          this._pruneTiles();\n        } // Flag to prevent _updateOpacity from pruning tiles during\n        // a zoom anim or a pinch gesture\n\n\n        this._noPrune = !!noPrune;\n      }\n\n      this._setZoomTransforms(center, zoom);\n    },\n    _setZoomTransforms: function (center, zoom) {\n      for (var i in this._levels) {\n        this._setZoomTransform(this._levels[i], center, zoom);\n      }\n    },\n    _setZoomTransform: function (level, center, zoom) {\n      var scale = this._map.getZoomScale(zoom, level.zoom),\n          translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n\n      if (any3d) {\n        setTransform(level.el, translate, scale);\n      } else {\n        setPosition(level.el, translate);\n      }\n    },\n    _resetGrid: function () {\n      var map = this._map,\n          crs = map.options.crs,\n          tileSize = this._tileSize = this.getTileSize(),\n          tileZoom = this._tileZoom;\n\n      var bounds = this._map.getPixelWorldBounds(this._tileZoom);\n\n      if (bounds) {\n        this._globalTileRange = this._pxBoundsToTileRange(bounds);\n      }\n\n      this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];\n      this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];\n    },\n    _onMoveEnd: function () {\n      if (!this._map || this._map._animatingZoom) {\n        return;\n      }\n\n      this._update();\n    },\n    _getTiledPixelBounds: function (center) {\n      var map = this._map,\n          mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),\n          scale = map.getZoomScale(mapZoom, this._tileZoom),\n          pixelCenter = map.project(center, this._tileZoom).floor(),\n          halfSize = map.getSize().divideBy(scale * 2);\n      return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n    },\n    // Private method to load tiles in the grid's active zoom level according to map bounds\n    _update: function (center) {\n      var map = this._map;\n\n      if (!map) {\n        return;\n      }\n\n      var zoom = this._clampZoom(map.getZoom());\n\n      if (center === undefined) {\n        center = map.getCenter();\n      }\n\n      if (this._tileZoom === undefined) {\n        return;\n      } // if out of minzoom/maxzoom\n\n\n      var pixelBounds = this._getTiledPixelBounds(center),\n          tileRange = this._pxBoundsToTileRange(pixelBounds),\n          tileCenter = tileRange.getCenter(),\n          queue = [],\n          margin = this.options.keepBuffer,\n          noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin])); // Sanity check: panic if the tile range contains Infinity somewhere.\n\n\n      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {\n        throw new Error('Attempted to load an infinite number of tiles');\n      }\n\n      for (var key in this._tiles) {\n        var c = this._tiles[key].coords;\n\n        if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n          this._tiles[key].current = false;\n        }\n      } // _update just loads more tiles. If the tile zoom level differs too much\n      // from the map's, let _setView reset levels and prune old tiles.\n\n\n      if (Math.abs(zoom - this._tileZoom) > 1) {\n        this._setView(center, zoom);\n\n        return;\n      } // create a queue of coordinates to load tiles from\n\n\n      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n          var coords = new Point(i, j);\n          coords.z = this._tileZoom;\n\n          if (!this._isValidTile(coords)) {\n            continue;\n          }\n\n          var tile = this._tiles[this._tileCoordsToKey(coords)];\n\n          if (tile) {\n            tile.current = true;\n          } else {\n            queue.push(coords);\n          }\n        }\n      } // sort tile queue to load tiles in order of their distance to center\n\n\n      queue.sort(function (a, b) {\n        return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n      });\n\n      if (queue.length !== 0) {\n        // if it's the first batch of tiles to load\n        if (!this._loading) {\n          this._loading = true; // @event loading: Event\n          // Fired when the grid layer starts loading tiles.\n\n          this.fire('loading');\n        } // create DOM fragment to append tiles in one batch\n\n\n        var fragment = document.createDocumentFragment();\n\n        for (i = 0; i < queue.length; i++) {\n          this._addTile(queue[i], fragment);\n        }\n\n        this._level.el.appendChild(fragment);\n      }\n    },\n    _isValidTile: function (coords) {\n      var crs = this._map.options.crs;\n\n      if (!crs.infinite) {\n        // don't load tile if it's out of bounds and not wrapped\n        var bounds = this._globalTileRange;\n\n        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n          return false;\n        }\n      }\n\n      if (!this.options.bounds) {\n        return true;\n      } // don't load tile if it doesn't intersect the bounds in options\n\n\n      var tileBounds = this._tileCoordsToBounds(coords);\n\n      return toLatLngBounds(this.options.bounds).overlaps(tileBounds);\n    },\n    _keyToBounds: function (key) {\n      return this._tileCoordsToBounds(this._keyToTileCoords(key));\n    },\n    _tileCoordsToNwSe: function (coords) {\n      var map = this._map,\n          tileSize = this.getTileSize(),\n          nwPoint = coords.scaleBy(tileSize),\n          sePoint = nwPoint.add(tileSize),\n          nw = map.unproject(nwPoint, coords.z),\n          se = map.unproject(sePoint, coords.z);\n      return [nw, se];\n    },\n    // converts tile coordinates to its geographical bounds\n    _tileCoordsToBounds: function (coords) {\n      var bp = this._tileCoordsToNwSe(coords),\n          bounds = new LatLngBounds(bp[0], bp[1]);\n\n      if (!this.options.noWrap) {\n        bounds = this._map.wrapLatLngBounds(bounds);\n      }\n\n      return bounds;\n    },\n    // converts tile coordinates to key for the tile cache\n    _tileCoordsToKey: function (coords) {\n      return coords.x + ':' + coords.y + ':' + coords.z;\n    },\n    // converts tile cache key to coordinates\n    _keyToTileCoords: function (key) {\n      var k = key.split(':'),\n          coords = new Point(+k[0], +k[1]);\n      coords.z = +k[2];\n      return coords;\n    },\n    _removeTile: function (key) {\n      var tile = this._tiles[key];\n\n      if (!tile) {\n        return;\n      }\n\n      remove(tile.el);\n      delete this._tiles[key]; // @event tileunload: TileEvent\n      // Fired when a tile is removed (e.g. when a tile goes off the screen).\n\n      this.fire('tileunload', {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key)\n      });\n    },\n    _initTile: function (tile) {\n      addClass(tile, 'leaflet-tile');\n      var tileSize = this.getTileSize();\n      tile.style.width = tileSize.x + 'px';\n      tile.style.height = tileSize.y + 'px';\n      tile.onselectstart = falseFn;\n      tile.onmousemove = falseFn; // update opacity on tiles in IE7-8 because of filter inheritance problems\n\n      if (ielt9 && this.options.opacity < 1) {\n        setOpacity(tile, this.options.opacity);\n      } // without this hack, tiles disappear after zoom on Chrome for Android\n      // https://github.com/Leaflet/Leaflet/issues/2078\n\n\n      if (android && !android23) {\n        tile.style.WebkitBackfaceVisibility = 'hidden';\n      }\n    },\n    _addTile: function (coords, container) {\n      var tilePos = this._getTilePos(coords),\n          key = this._tileCoordsToKey(coords);\n\n      var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));\n\n      this._initTile(tile); // if createTile is defined with a second argument (\"done\" callback),\n      // we know that tile is async and will be ready later; otherwise\n\n\n      if (this.createTile.length < 2) {\n        // mark tile as ready, but delay one frame for opacity animation to happen\n        requestAnimFrame(bind(this._tileReady, this, coords, null, tile));\n      }\n\n      setPosition(tile, tilePos); // save tile in cache\n\n      this._tiles[key] = {\n        el: tile,\n        coords: coords,\n        current: true\n      };\n      container.appendChild(tile); // @event tileloadstart: TileEvent\n      // Fired when a tile is requested and starts loading.\n\n      this.fire('tileloadstart', {\n        tile: tile,\n        coords: coords\n      });\n    },\n    _tileReady: function (coords, err, tile) {\n      if (err) {\n        // @event tileerror: TileErrorEvent\n        // Fired when there is an error loading a tile.\n        this.fire('tileerror', {\n          error: err,\n          tile: tile,\n          coords: coords\n        });\n      }\n\n      var key = this._tileCoordsToKey(coords);\n\n      tile = this._tiles[key];\n\n      if (!tile) {\n        return;\n      }\n\n      tile.loaded = +new Date();\n\n      if (this._map._fadeAnimated) {\n        setOpacity(tile.el, 0);\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      } else {\n        tile.active = true;\n\n        this._pruneTiles();\n      }\n\n      if (!err) {\n        addClass(tile.el, 'leaflet-tile-loaded'); // @event tileload: TileEvent\n        // Fired when a tile loads.\n\n        this.fire('tileload', {\n          tile: tile.el,\n          coords: coords\n        });\n      }\n\n      if (this._noTilesToLoad()) {\n        this._loading = false; // @event load: Event\n        // Fired when the grid layer loaded all visible tiles.\n\n        this.fire('load');\n\n        if (ielt9 || !this._map._fadeAnimated) {\n          requestAnimFrame(this._pruneTiles, this);\n        } else {\n          // Wait a bit more than 0.2 secs (the duration of the tile fade-in)\n          // to trigger a pruning.\n          setTimeout(bind(this._pruneTiles, this), 250);\n        }\n      }\n    },\n    _getTilePos: function (coords) {\n      return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n    },\n    _wrapCoords: function (coords) {\n      var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);\n      newCoords.z = coords.z;\n      return newCoords;\n    },\n    _pxBoundsToTileRange: function (bounds) {\n      var tileSize = this.getTileSize();\n      return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));\n    },\n    _noTilesToLoad: function () {\n      for (var key in this._tiles) {\n        if (!this._tiles[key].loaded) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }); // @factory L.gridLayer(options?: GridLayer options)\n  // Creates a new instance of GridLayer with the supplied options.\n\n  function gridLayer(options) {\n    return new GridLayer(options);\n  }\n  /*\r\n   * @class TileLayer\r\n   * @inherits GridLayer\r\n   * @aka L.TileLayer\r\n   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: 'Map data &copy; <a href=\"https://www.openstreetmap.org/\">OpenStreetMap</a> contributors, <a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>'}).addTo(map);\r\n   * ```\r\n   *\r\n   * @section URL template\r\n   * @example\r\n   *\r\n   * A string of the following form:\r\n   *\r\n   * ```\r\n   * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'\r\n   * ```\r\n   *\r\n   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add \"&commat;2x\" to the URL to load retina tiles.\r\n   *\r\n   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:\r\n   *\r\n   * ```\r\n   * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});\r\n   * ```\r\n   */\n\n\n  var TileLayer = GridLayer.extend({\n    // @section\n    // @aka TileLayer options\n    options: {\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = 18\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: 18,\n      // @option subdomains: String|String[] = 'abc'\n      // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.\n      subdomains: 'abc',\n      // @option errorTileUrl: String = ''\n      // URL to the tile image to show in place of the tile that failed to load.\n      errorTileUrl: '',\n      // @option zoomOffset: Number = 0\n      // The zoom number used in tile URLs will be offset with this value.\n      zoomOffset: 0,\n      // @option tms: Boolean = false\n      // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).\n      tms: false,\n      // @option zoomReverse: Boolean = false\n      // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)\n      zoomReverse: false,\n      // @option detectRetina: Boolean = false\n      // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.\n      detectRetina: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false\n    },\n    initialize: function (url, options) {\n      this._url = url;\n      options = setOptions(this, options); // detecting retina displays, adjusting tileSize and zoom levels\n\n      if (options.detectRetina && retina && options.maxZoom > 0) {\n        options.tileSize = Math.floor(options.tileSize / 2);\n\n        if (!options.zoomReverse) {\n          options.zoomOffset++;\n          options.maxZoom--;\n        } else {\n          options.zoomOffset--;\n          options.minZoom++;\n        }\n\n        options.minZoom = Math.max(0, options.minZoom);\n      }\n\n      if (typeof options.subdomains === 'string') {\n        options.subdomains = options.subdomains.split('');\n      } // for https://github.com/Leaflet/Leaflet/issues/137\n\n\n      if (!android) {\n        this.on('tileunload', this._onTileRemove);\n      }\n    },\n    // @method setUrl(url: String, noRedraw?: Boolean): this\n    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).\n    // If the URL does not change, the layer will not be redrawn unless\n    // the noRedraw parameter is set to false.\n    setUrl: function (url, noRedraw) {\n      if (this._url === url && noRedraw === undefined) {\n        noRedraw = true;\n      }\n\n      this._url = url;\n\n      if (!noRedraw) {\n        this.redraw();\n      }\n\n      return this;\n    },\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)\n    // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`\n    // callback is called when the tile has been loaded.\n    createTile: function (coords, done) {\n      var tile = document.createElement('img');\n      on(tile, 'load', bind(this._tileOnLoad, this, done, tile));\n      on(tile, 'error', bind(this._tileOnError, this, done, tile));\n\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n      /*\r\n       Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons\r\n       http://www.w3.org/TR/WCAG20-TECHS/H67\r\n      */\n\n\n      tile.alt = '';\n      /*\r\n       Set role=\"presentation\" to force screen readers to ignore this\r\n       https://www.w3.org/TR/wai-aria/roles#textalternativecomputation\r\n      */\n\n      tile.setAttribute('role', 'presentation');\n      tile.src = this.getTileUrl(coords);\n      return tile;\n    },\n    // @section Extension methods\n    // @uninheritable\n    // Layers extending `TileLayer` might reimplement the following method.\n    // @method getTileUrl(coords: Object): String\n    // Called only internally, returns the URL for a tile given its coordinates.\n    // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.\n    getTileUrl: function (coords) {\n      var data = {\n        r: retina ? '@2x' : '',\n        s: this._getSubdomain(coords),\n        x: coords.x,\n        y: coords.y,\n        z: this._getZoomForUrl()\n      };\n\n      if (this._map && !this._map.options.crs.infinite) {\n        var invertedY = this._globalTileRange.max.y - coords.y;\n\n        if (this.options.tms) {\n          data['y'] = invertedY;\n        }\n\n        data['-y'] = invertedY;\n      }\n\n      return template(this._url, extend(data, this.options));\n    },\n    _tileOnLoad: function (done, tile) {\n      // For https://github.com/Leaflet/Leaflet/issues/3332\n      if (ielt9) {\n        setTimeout(bind(done, this, null, tile), 0);\n      } else {\n        done(null, tile);\n      }\n    },\n    _tileOnError: function (done, tile, e) {\n      var errorUrl = this.options.errorTileUrl;\n\n      if (errorUrl && tile.getAttribute('src') !== errorUrl) {\n        tile.src = errorUrl;\n      }\n\n      done(e, tile);\n    },\n    _onTileRemove: function (e) {\n      e.tile.onload = null;\n    },\n    _getZoomForUrl: function () {\n      var zoom = this._tileZoom,\n          maxZoom = this.options.maxZoom,\n          zoomReverse = this.options.zoomReverse,\n          zoomOffset = this.options.zoomOffset;\n\n      if (zoomReverse) {\n        zoom = maxZoom - zoom;\n      }\n\n      return zoom + zoomOffset;\n    },\n    _getSubdomain: function (tilePoint) {\n      var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n      return this.options.subdomains[index];\n    },\n    // stops loading all tiles in the background layer\n    _abortLoading: function () {\n      var i, tile;\n\n      for (i in this._tiles) {\n        if (this._tiles[i].coords.z !== this._tileZoom) {\n          tile = this._tiles[i].el;\n          tile.onload = falseFn;\n          tile.onerror = falseFn;\n\n          if (!tile.complete) {\n            tile.src = emptyImageUrl;\n            remove(tile);\n            delete this._tiles[i];\n          }\n        }\n      }\n    },\n    _removeTile: function (key) {\n      var tile = this._tiles[key];\n\n      if (!tile) {\n        return;\n      } // Cancels any pending http requests associated with the tile\n      // unless we're on Android's stock browser,\n      // see https://github.com/Leaflet/Leaflet/issues/137\n\n\n      if (!androidStock) {\n        tile.el.setAttribute('src', emptyImageUrl);\n      }\n\n      return GridLayer.prototype._removeTile.call(this, key);\n    },\n    _tileReady: function (coords, err, tile) {\n      if (!this._map || tile && tile.getAttribute('src') === emptyImageUrl) {\n        return;\n      }\n\n      return GridLayer.prototype._tileReady.call(this, coords, err, tile);\n    }\n  }); // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)\n  // Instantiates a tile layer object given a `URL template` and optionally an options object.\n\n  function tileLayer(url, options) {\n    return new TileLayer(url, options);\n  }\n  /*\r\n   * @class TileLayer.WMS\r\n   * @inherits TileLayer\r\n   * @aka L.TileLayer.WMS\r\n   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var nexrad = L.tileLayer.wms(\"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\", {\r\n   * \tlayers: 'nexrad-n0r-900913',\r\n   * \tformat: 'image/png',\r\n   * \ttransparent: true,\r\n   * \tattribution: \"Weather data © 2012 IEM Nexrad\"\r\n   * });\r\n   * ```\r\n   */\n\n\n  var TileLayerWMS = TileLayer.extend({\n    // @section\n    // @aka TileLayer.WMS options\n    // If any custom options not documented here are used, they will be sent to the\n    // WMS server as extra parameters in each request URL. This can be useful for\n    // [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).\n    defaultWmsParams: {\n      service: 'WMS',\n      request: 'GetMap',\n      // @option layers: String = ''\n      // **(required)** Comma-separated list of WMS layers to show.\n      layers: '',\n      // @option styles: String = ''\n      // Comma-separated list of WMS styles.\n      styles: '',\n      // @option format: String = 'image/jpeg'\n      // WMS image format (use `'image/png'` for layers with transparency).\n      format: 'image/jpeg',\n      // @option transparent: Boolean = false\n      // If `true`, the WMS service will return images with transparency.\n      transparent: false,\n      // @option version: String = '1.1.1'\n      // Version of the WMS service to use\n      version: '1.1.1'\n    },\n    options: {\n      // @option crs: CRS = null\n      // Coordinate Reference System to use for the WMS requests, defaults to\n      // map CRS. Don't change this if you're not sure what it means.\n      crs: null,\n      // @option uppercase: Boolean = false\n      // If `true`, WMS request parameter keys will be uppercase.\n      uppercase: false\n    },\n    initialize: function (url, options) {\n      this._url = url;\n      var wmsParams = extend({}, this.defaultWmsParams); // all keys that are not TileLayer options go to WMS params\n\n      for (var i in options) {\n        if (!(i in this.options)) {\n          wmsParams[i] = options[i];\n        }\n      }\n\n      options = setOptions(this, options);\n      var realRetina = options.detectRetina && retina ? 2 : 1;\n      var tileSize = this.getTileSize();\n      wmsParams.width = tileSize.x * realRetina;\n      wmsParams.height = tileSize.y * realRetina;\n      this.wmsParams = wmsParams;\n    },\n    onAdd: function (map) {\n      this._crs = this.options.crs || map.options.crs;\n      this._wmsVersion = parseFloat(this.wmsParams.version);\n      var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\n      this.wmsParams[projectionKey] = this._crs.code;\n      TileLayer.prototype.onAdd.call(this, map);\n    },\n    getTileUrl: function (coords) {\n      var tileBounds = this._tileCoordsToNwSe(coords),\n          crs = this._crs,\n          bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),\n          min = bounds.min,\n          max = bounds.max,\n          bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(','),\n          url = TileLayer.prototype.getTileUrl.call(this, coords);\n\n      return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;\n    },\n    // @method setParams(params: Object, noRedraw?: Boolean): this\n    // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).\n    setParams: function (params, noRedraw) {\n      extend(this.wmsParams, params);\n\n      if (!noRedraw) {\n        this.redraw();\n      }\n\n      return this;\n    }\n  }); // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)\n  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.\n\n  function tileLayerWMS(url, options) {\n    return new TileLayerWMS(url, options);\n  }\n\n  TileLayer.WMS = TileLayerWMS;\n  tileLayer.wms = tileLayerWMS;\n  /*\n   * @class Renderer\n   * @inherits Layer\n   * @aka L.Renderer\n   *\n   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the\n   * DOM container of the renderer, its bounds, and its zoom animation.\n   *\n   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer\n   * itself can be added or removed to the map. All paths use a renderer, which can\n   * be implicit (the map will decide the type of renderer and use it automatically)\n   * or explicit (using the [`renderer`](#path-renderer) option of the path).\n   *\n   * Do not use this class directly, use `SVG` and `Canvas` instead.\n   *\n   * @event update: Event\n   * Fired when the renderer updates its bounds, center and zoom, for example when\n   * its map has moved\n   */\n\n  var Renderer = Layer.extend({\n    // @section\n    // @aka Renderer options\n    options: {\n      // @option padding: Number = 0.1\n      // How much to extend the clip area around the map view (relative to its size)\n      // e.g. 0.1 would be 10% of map view in each direction\n      padding: 0.1,\n      // @option tolerance: Number = 0\n      // How much to extend click tolerance round a path/object on the map\n      tolerance: 0\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n      stamp(this);\n      this._layers = this._layers || {};\n    },\n    onAdd: function () {\n      if (!this._container) {\n        this._initContainer(); // defined by renderer implementations\n\n\n        if (this._zoomAnimated) {\n          addClass(this._container, 'leaflet-zoom-animated');\n        }\n      }\n\n      this.getPane().appendChild(this._container);\n\n      this._update();\n\n      this.on('update', this._updatePaths, this);\n    },\n    onRemove: function () {\n      this.off('update', this._updatePaths, this);\n\n      this._destroyContainer();\n    },\n    getEvents: function () {\n      var events = {\n        viewreset: this._reset,\n        zoom: this._onZoom,\n        moveend: this._update,\n        zoomend: this._onZoomEnd\n      };\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._onAnimZoom;\n      }\n\n      return events;\n    },\n    _onAnimZoom: function (ev) {\n      this._updateTransform(ev.center, ev.zoom);\n    },\n    _onZoom: function () {\n      this._updateTransform(this._map.getCenter(), this._map.getZoom());\n    },\n    _updateTransform: function (center, zoom) {\n      var scale = this._map.getZoomScale(zoom, this._zoom),\n          position = getPosition(this._container),\n          viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),\n          currentCenterPoint = this._map.project(this._center, zoom),\n          destCenterPoint = this._map.project(center, zoom),\n          centerOffset = destCenterPoint.subtract(currentCenterPoint),\n          topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);\n\n      if (any3d) {\n        setTransform(this._container, topLeftOffset, scale);\n      } else {\n        setPosition(this._container, topLeftOffset);\n      }\n    },\n    _reset: function () {\n      this._update();\n\n      this._updateTransform(this._center, this._zoom);\n\n      for (var id in this._layers) {\n        this._layers[id]._reset();\n      }\n    },\n    _onZoomEnd: function () {\n      for (var id in this._layers) {\n        this._layers[id]._project();\n      }\n    },\n    _updatePaths: function () {\n      for (var id in this._layers) {\n        this._layers[id]._update();\n      }\n    },\n    _update: function () {\n      // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n      // Subclasses are responsible of firing the 'update' event.\n      var p = this.options.padding,\n          size = this._map.getSize(),\n          min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n\n      this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n      this._center = this._map.getCenter();\n      this._zoom = this._map.getZoom();\n    }\n  });\n  /*\n   * @class Canvas\n   * @inherits Renderer\n   * @aka L.Canvas\n   *\n   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not\n   * available in all web browsers, notably IE8, and overlapping geometries might\n   * not display properly in some edge cases.\n   *\n   * @example\n   *\n   * Use Canvas by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.canvas()\n   * });\n   * ```\n   *\n   * Use a Canvas renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.canvas({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var Canvas = Renderer.extend({\n    getEvents: function () {\n      var events = Renderer.prototype.getEvents.call(this);\n      events.viewprereset = this._onViewPreReset;\n      return events;\n    },\n    _onViewPreReset: function () {\n      // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once\n      this._postponeUpdatePaths = true;\n    },\n    onAdd: function () {\n      Renderer.prototype.onAdd.call(this); // Redraw vectors since canvas is cleared upon removal,\n      // in case of removing the renderer itself from the map.\n\n      this._draw();\n    },\n    _initContainer: function () {\n      var container = this._container = document.createElement('canvas');\n      on(container, 'mousemove', this._onMouseMove, this);\n      on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);\n      on(container, 'mouseout', this._handleMouseOut, this);\n      this._ctx = container.getContext('2d');\n    },\n    _destroyContainer: function () {\n      cancelAnimFrame(this._redrawRequest);\n      delete this._ctx;\n      remove(this._container);\n      off(this._container);\n      delete this._container;\n    },\n    _updatePaths: function () {\n      if (this._postponeUpdatePaths) {\n        return;\n      }\n\n      var layer;\n      this._redrawBounds = null;\n\n      for (var id in this._layers) {\n        layer = this._layers[id];\n\n        layer._update();\n      }\n\n      this._redraw();\n    },\n    _update: function () {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n\n      Renderer.prototype._update.call(this);\n\n      var b = this._bounds,\n          container = this._container,\n          size = b.getSize(),\n          m = retina ? 2 : 1;\n      setPosition(container, b.min); // set canvas size (also clearing it); use double size on retina\n\n      container.width = m * size.x;\n      container.height = m * size.y;\n      container.style.width = size.x + 'px';\n      container.style.height = size.y + 'px';\n\n      if (retina) {\n        this._ctx.scale(2, 2);\n      } // translate so we use the same path coordinates after canvas element moves\n\n\n      this._ctx.translate(-b.min.x, -b.min.y); // Tell paths to redraw themselves\n\n\n      this.fire('update');\n    },\n    _reset: function () {\n      Renderer.prototype._reset.call(this);\n\n      if (this._postponeUpdatePaths) {\n        this._postponeUpdatePaths = false;\n\n        this._updatePaths();\n      }\n    },\n    _initPath: function (layer) {\n      this._updateDashArray(layer);\n\n      this._layers[stamp(layer)] = layer;\n      var order = layer._order = {\n        layer: layer,\n        prev: this._drawLast,\n        next: null\n      };\n\n      if (this._drawLast) {\n        this._drawLast.next = order;\n      }\n\n      this._drawLast = order;\n      this._drawFirst = this._drawFirst || this._drawLast;\n    },\n    _addPath: function (layer) {\n      this._requestRedraw(layer);\n    },\n    _removePath: function (layer) {\n      var order = layer._order;\n      var next = order.next;\n      var prev = order.prev;\n\n      if (next) {\n        next.prev = prev;\n      } else {\n        this._drawLast = prev;\n      }\n\n      if (prev) {\n        prev.next = next;\n      } else {\n        this._drawFirst = next;\n      }\n\n      delete layer._order;\n      delete this._layers[stamp(layer)];\n\n      this._requestRedraw(layer);\n    },\n    _updatePath: function (layer) {\n      // Redraw the union of the layer's old pixel\n      // bounds and the new pixel bounds.\n      this._extendRedrawBounds(layer);\n\n      layer._project();\n\n      layer._update(); // The redraw will extend the redraw bounds\n      // with the new pixel bounds.\n\n\n      this._requestRedraw(layer);\n    },\n    _updateStyle: function (layer) {\n      this._updateDashArray(layer);\n\n      this._requestRedraw(layer);\n    },\n    _updateDashArray: function (layer) {\n      if (typeof layer.options.dashArray === 'string') {\n        var parts = layer.options.dashArray.split(/[, ]+/),\n            dashArray = [],\n            dashValue,\n            i;\n\n        for (i = 0; i < parts.length; i++) {\n          dashValue = Number(parts[i]); // Ignore dash array containing invalid lengths\n\n          if (isNaN(dashValue)) {\n            return;\n          }\n\n          dashArray.push(dashValue);\n        }\n\n        layer.options._dashArray = dashArray;\n      } else {\n        layer.options._dashArray = layer.options.dashArray;\n      }\n    },\n    _requestRedraw: function (layer) {\n      if (!this._map) {\n        return;\n      }\n\n      this._extendRedrawBounds(layer);\n\n      this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);\n    },\n    _extendRedrawBounds: function (layer) {\n      if (layer._pxBounds) {\n        var padding = (layer.options.weight || 0) + 1;\n        this._redrawBounds = this._redrawBounds || new Bounds();\n\n        this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));\n\n        this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));\n      }\n    },\n    _redraw: function () {\n      this._redrawRequest = null;\n\n      if (this._redrawBounds) {\n        this._redrawBounds.min._floor();\n\n        this._redrawBounds.max._ceil();\n      }\n\n      this._clear(); // clear layers in redraw bounds\n\n\n      this._draw(); // draw layers\n\n\n      this._redrawBounds = null;\n    },\n    _clear: function () {\n      var bounds = this._redrawBounds;\n\n      if (bounds) {\n        var size = bounds.getSize();\n\n        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\n      } else {\n        this._ctx.clearRect(0, 0, this._container.width, this._container.height);\n      }\n    },\n    _draw: function () {\n      var layer,\n          bounds = this._redrawBounds;\n\n      this._ctx.save();\n\n      if (bounds) {\n        var size = bounds.getSize();\n\n        this._ctx.beginPath();\n\n        this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\n\n        this._ctx.clip();\n      }\n\n      this._drawing = true;\n\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n\n        if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {\n          layer._updatePath();\n        }\n      }\n\n      this._drawing = false;\n\n      this._ctx.restore(); // Restore state before clipping.\n\n    },\n    _updatePoly: function (layer, closed) {\n      if (!this._drawing) {\n        return;\n      }\n\n      var i,\n          j,\n          len2,\n          p,\n          parts = layer._parts,\n          len = parts.length,\n          ctx = this._ctx;\n\n      if (!len) {\n        return;\n      }\n\n      ctx.beginPath();\n\n      for (i = 0; i < len; i++) {\n        for (j = 0, len2 = parts[i].length; j < len2; j++) {\n          p = parts[i][j];\n          ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);\n        }\n\n        if (closed) {\n          ctx.closePath();\n        }\n      }\n\n      this._fillStroke(ctx, layer); // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n\n    },\n    _updateCircle: function (layer) {\n      if (!this._drawing || layer._empty()) {\n        return;\n      }\n\n      var p = layer._point,\n          ctx = this._ctx,\n          r = Math.max(Math.round(layer._radius), 1),\n          s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;\n\n      if (s !== 1) {\n        ctx.save();\n        ctx.scale(1, s);\n      }\n\n      ctx.beginPath();\n      ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n\n      if (s !== 1) {\n        ctx.restore();\n      }\n\n      this._fillStroke(ctx, layer);\n    },\n    _fillStroke: function (ctx, layer) {\n      var options = layer.options;\n\n      if (options.fill) {\n        ctx.globalAlpha = options.fillOpacity;\n        ctx.fillStyle = options.fillColor || options.color;\n        ctx.fill(options.fillRule || 'evenodd');\n      }\n\n      if (options.stroke && options.weight !== 0) {\n        if (ctx.setLineDash) {\n          ctx.setLineDash(layer.options && layer.options._dashArray || []);\n        }\n\n        ctx.globalAlpha = options.opacity;\n        ctx.lineWidth = options.weight;\n        ctx.strokeStyle = options.color;\n        ctx.lineCap = options.lineCap;\n        ctx.lineJoin = options.lineJoin;\n        ctx.stroke();\n      }\n    },\n    // Canvas obviously doesn't have mouse events for individual drawn objects,\n    // so we emulate that by calculating what's under the mouse on mousemove/click manually\n    _onClick: function (e) {\n      var point = this._map.mouseEventToLayerPoint(e),\n          layer,\n          clickedLayer;\n\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n\n        if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {\n          clickedLayer = layer;\n        }\n      }\n\n      if (clickedLayer) {\n        fakeStop(e);\n\n        this._fireEvent([clickedLayer], e);\n      }\n    },\n    _onMouseMove: function (e) {\n      if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {\n        return;\n      }\n\n      var point = this._map.mouseEventToLayerPoint(e);\n\n      this._handleMouseHover(e, point);\n    },\n    _handleMouseOut: function (e) {\n      var layer = this._hoveredLayer;\n\n      if (layer) {\n        // if we're leaving the layer, fire mouseout\n        removeClass(this._container, 'leaflet-interactive');\n\n        this._fireEvent([layer], e, 'mouseout');\n\n        this._hoveredLayer = null;\n        this._mouseHoverThrottled = false;\n      }\n    },\n    _handleMouseHover: function (e, point) {\n      if (this._mouseHoverThrottled) {\n        return;\n      }\n\n      var layer, candidateHoveredLayer;\n\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n\n        if (layer.options.interactive && layer._containsPoint(point)) {\n          candidateHoveredLayer = layer;\n        }\n      }\n\n      if (candidateHoveredLayer !== this._hoveredLayer) {\n        this._handleMouseOut(e);\n\n        if (candidateHoveredLayer) {\n          addClass(this._container, 'leaflet-interactive'); // change cursor\n\n          this._fireEvent([candidateHoveredLayer], e, 'mouseover');\n\n          this._hoveredLayer = candidateHoveredLayer;\n        }\n      }\n\n      if (this._hoveredLayer) {\n        this._fireEvent([this._hoveredLayer], e);\n      }\n\n      this._mouseHoverThrottled = true;\n      setTimeout(L.bind(function () {\n        this._mouseHoverThrottled = false;\n      }, this), 32);\n    },\n    _fireEvent: function (layers, e, type) {\n      this._map._fireDOMEvent(e, type || e.type, layers);\n    },\n    _bringToFront: function (layer) {\n      var order = layer._order;\n\n      if (!order) {\n        return;\n      }\n\n      var next = order.next;\n      var prev = order.prev;\n\n      if (next) {\n        next.prev = prev;\n      } else {\n        // Already last\n        return;\n      }\n\n      if (prev) {\n        prev.next = next;\n      } else if (next) {\n        // Update first entry unless this is the\n        // single entry\n        this._drawFirst = next;\n      }\n\n      order.prev = this._drawLast;\n      this._drawLast.next = order;\n      order.next = null;\n      this._drawLast = order;\n\n      this._requestRedraw(layer);\n    },\n    _bringToBack: function (layer) {\n      var order = layer._order;\n\n      if (!order) {\n        return;\n      }\n\n      var next = order.next;\n      var prev = order.prev;\n\n      if (prev) {\n        prev.next = next;\n      } else {\n        // Already first\n        return;\n      }\n\n      if (next) {\n        next.prev = prev;\n      } else if (prev) {\n        // Update last entry unless this is the\n        // single entry\n        this._drawLast = prev;\n      }\n\n      order.prev = null;\n      order.next = this._drawFirst;\n      this._drawFirst.prev = order;\n      this._drawFirst = order;\n\n      this._requestRedraw(layer);\n    }\n  }); // @factory L.canvas(options?: Renderer options)\n  // Creates a Canvas renderer with the given options.\n\n  function canvas$1(options) {\n    return canvas ? new Canvas(options) : null;\n  }\n  /*\n   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n   */\n\n\n  var vmlCreate = function () {\n    try {\n      document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n      return function (name) {\n        return document.createElement('<lvml:' + name + ' class=\"lvml\">');\n      };\n    } catch (e) {\n      return function (name) {\n        return document.createElement('<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n      };\n    }\n  }();\n  /*\n   * @class SVG\n   *\n   *\n   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility\n   * with old versions of Internet Explorer.\n   */\n  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences\n\n\n  var vmlMixin = {\n    _initContainer: function () {\n      this._container = create$1('div', 'leaflet-vml-container');\n    },\n    _update: function () {\n      if (this._map._animatingZoom) {\n        return;\n      }\n\n      Renderer.prototype._update.call(this);\n\n      this.fire('update');\n    },\n    _initPath: function (layer) {\n      var container = layer._container = vmlCreate('shape');\n      addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));\n      container.coordsize = '1 1';\n      layer._path = vmlCreate('path');\n      container.appendChild(layer._path);\n\n      this._updateStyle(layer);\n\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function (layer) {\n      var container = layer._container;\n\n      this._container.appendChild(container);\n\n      if (layer.options.interactive) {\n        layer.addInteractiveTarget(container);\n      }\n    },\n    _removePath: function (layer) {\n      var container = layer._container;\n      remove(container);\n      layer.removeInteractiveTarget(container);\n      delete this._layers[stamp(layer)];\n    },\n    _updateStyle: function (layer) {\n      var stroke = layer._stroke,\n          fill = layer._fill,\n          options = layer.options,\n          container = layer._container;\n      container.stroked = !!options.stroke;\n      container.filled = !!options.fill;\n\n      if (options.stroke) {\n        if (!stroke) {\n          stroke = layer._stroke = vmlCreate('stroke');\n        }\n\n        container.appendChild(stroke);\n        stroke.weight = options.weight + 'px';\n        stroke.color = options.color;\n        stroke.opacity = options.opacity;\n\n        if (options.dashArray) {\n          stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');\n        } else {\n          stroke.dashStyle = '';\n        }\n\n        stroke.endcap = options.lineCap.replace('butt', 'flat');\n        stroke.joinstyle = options.lineJoin;\n      } else if (stroke) {\n        container.removeChild(stroke);\n        layer._stroke = null;\n      }\n\n      if (options.fill) {\n        if (!fill) {\n          fill = layer._fill = vmlCreate('fill');\n        }\n\n        container.appendChild(fill);\n        fill.color = options.fillColor || options.color;\n        fill.opacity = options.fillOpacity;\n      } else if (fill) {\n        container.removeChild(fill);\n        layer._fill = null;\n      }\n    },\n    _updateCircle: function (layer) {\n      var p = layer._point.round(),\n          r = Math.round(layer._radius),\n          r2 = Math.round(layer._radiusY || r);\n\n      this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);\n    },\n    _setPath: function (layer, path) {\n      layer._path.v = path;\n    },\n    _bringToFront: function (layer) {\n      toFront(layer._container);\n    },\n    _bringToBack: function (layer) {\n      toBack(layer._container);\n    }\n  };\n  var create$2 = vml ? vmlCreate : svgCreate;\n  /*\n   * @class SVG\n   * @inherits Renderer\n   * @aka L.SVG\n   *\n   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not\n   * available in all web browsers, notably Android 2.x and 3.x.\n   *\n   * Although SVG is not available on IE7 and IE8, these browsers support\n   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)\n   * (a now deprecated technology), and the SVG renderer will fall back to VML in\n   * this case.\n   *\n   * @example\n   *\n   * Use SVG by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.svg()\n   * });\n   * ```\n   *\n   * Use a SVG renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.svg({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var SVG = Renderer.extend({\n    getEvents: function () {\n      var events = Renderer.prototype.getEvents.call(this);\n      events.zoomstart = this._onZoomStart;\n      return events;\n    },\n    _initContainer: function () {\n      this._container = create$2('svg'); // makes it possible to click through svg root; we'll reset it back in individual paths\n\n      this._container.setAttribute('pointer-events', 'none');\n\n      this._rootGroup = create$2('g');\n\n      this._container.appendChild(this._rootGroup);\n    },\n    _destroyContainer: function () {\n      remove(this._container);\n      off(this._container);\n      delete this._container;\n      delete this._rootGroup;\n      delete this._svgSize;\n    },\n    _onZoomStart: function () {\n      // Drag-then-pinch interactions might mess up the center and zoom.\n      // In this case, the easiest way to prevent this is re-do the renderer\n      //   bounds and padding when the zooming starts.\n      this._update();\n    },\n    _update: function () {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n\n      Renderer.prototype._update.call(this);\n\n      var b = this._bounds,\n          size = b.getSize(),\n          container = this._container; // set size of svg-container if changed\n\n      if (!this._svgSize || !this._svgSize.equals(size)) {\n        this._svgSize = size;\n        container.setAttribute('width', size.x);\n        container.setAttribute('height', size.y);\n      } // movement: update container viewBox so that we don't have to change coordinates of individual layers\n\n\n      setPosition(container, b.min);\n      container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));\n      this.fire('update');\n    },\n    // methods below are called by vector layers implementations\n    _initPath: function (layer) {\n      var path = layer._path = create$2('path'); // @namespace Path\n      // @option className: String = null\n      // Custom class name set on an element. Only for SVG renderer.\n\n      if (layer.options.className) {\n        addClass(path, layer.options.className);\n      }\n\n      if (layer.options.interactive) {\n        addClass(path, 'leaflet-interactive');\n      }\n\n      this._updateStyle(layer);\n\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function (layer) {\n      if (!this._rootGroup) {\n        this._initContainer();\n      }\n\n      this._rootGroup.appendChild(layer._path);\n\n      layer.addInteractiveTarget(layer._path);\n    },\n    _removePath: function (layer) {\n      remove(layer._path);\n      layer.removeInteractiveTarget(layer._path);\n      delete this._layers[stamp(layer)];\n    },\n    _updatePath: function (layer) {\n      layer._project();\n\n      layer._update();\n    },\n    _updateStyle: function (layer) {\n      var path = layer._path,\n          options = layer.options;\n\n      if (!path) {\n        return;\n      }\n\n      if (options.stroke) {\n        path.setAttribute('stroke', options.color);\n        path.setAttribute('stroke-opacity', options.opacity);\n        path.setAttribute('stroke-width', options.weight);\n        path.setAttribute('stroke-linecap', options.lineCap);\n        path.setAttribute('stroke-linejoin', options.lineJoin);\n\n        if (options.dashArray) {\n          path.setAttribute('stroke-dasharray', options.dashArray);\n        } else {\n          path.removeAttribute('stroke-dasharray');\n        }\n\n        if (options.dashOffset) {\n          path.setAttribute('stroke-dashoffset', options.dashOffset);\n        } else {\n          path.removeAttribute('stroke-dashoffset');\n        }\n      } else {\n        path.setAttribute('stroke', 'none');\n      }\n\n      if (options.fill) {\n        path.setAttribute('fill', options.fillColor || options.color);\n        path.setAttribute('fill-opacity', options.fillOpacity);\n        path.setAttribute('fill-rule', options.fillRule || 'evenodd');\n      } else {\n        path.setAttribute('fill', 'none');\n      }\n    },\n    _updatePoly: function (layer, closed) {\n      this._setPath(layer, pointsToPath(layer._parts, closed));\n    },\n    _updateCircle: function (layer) {\n      var p = layer._point,\n          r = Math.max(Math.round(layer._radius), 1),\n          r2 = Math.max(Math.round(layer._radiusY), 1) || r,\n          arc = 'a' + r + ',' + r2 + ' 0 1,0 '; // drawing a circle with two half-arcs\n\n      var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';\n\n      this._setPath(layer, d);\n    },\n    _setPath: function (layer, path) {\n      layer._path.setAttribute('d', path);\n    },\n    // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n    _bringToFront: function (layer) {\n      toFront(layer._path);\n    },\n    _bringToBack: function (layer) {\n      toBack(layer._path);\n    }\n  });\n\n  if (vml) {\n    SVG.include(vmlMixin);\n  } // @namespace SVG\n  // @factory L.svg(options?: Renderer options)\n  // Creates a SVG renderer with the given options.\n\n\n  function svg$1(options) {\n    return svg || vml ? new SVG(options) : null;\n  }\n\n  Map.include({\n    // @namespace Map; @method getRenderer(layer: Path): Renderer\n    // Returns the instance of `Renderer` that should be used to render the given\n    // `Path`. It will ensure that the `renderer` options of the map and paths\n    // are respected, and that the renderers do exist on the map.\n    getRenderer: function (layer) {\n      // @namespace Path; @option renderer: Renderer\n      // Use this specific instance of `Renderer` for this path. Takes\n      // precedence over the map's [default renderer](#map-renderer).\n      var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n\n      if (!renderer) {\n        renderer = this._renderer = this._createRenderer();\n      }\n\n      if (!this.hasLayer(renderer)) {\n        this.addLayer(renderer);\n      }\n\n      return renderer;\n    },\n    _getPaneRenderer: function (name) {\n      if (name === 'overlayPane' || name === undefined) {\n        return false;\n      }\n\n      var renderer = this._paneRenderers[name];\n\n      if (renderer === undefined) {\n        renderer = this._createRenderer({\n          pane: name\n        });\n        this._paneRenderers[name] = renderer;\n      }\n\n      return renderer;\n    },\n    _createRenderer: function (options) {\n      // @namespace Map; @option preferCanvas: Boolean = false\n      // Whether `Path`s should be rendered on a `Canvas` renderer.\n      // By default, all `Path`s are rendered in a `SVG` renderer.\n      return this.options.preferCanvas && canvas$1(options) || svg$1(options);\n    }\n  });\n  /*\n   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n   */\n\n  /*\n   * @class Rectangle\n   * @aka L.Rectangle\n   * @inherits Polygon\n   *\n   * A class for drawing rectangle overlays on a map. Extends `Polygon`.\n   *\n   * @example\n   *\n   * ```js\n   * // define rectangle geographical bounds\n   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];\n   *\n   * // create an orange rectangle\n   * L.rectangle(bounds, {color: \"#ff7800\", weight: 1}).addTo(map);\n   *\n   * // zoom the map to the rectangle bounds\n   * map.fitBounds(bounds);\n   * ```\n   *\n   */\n\n  var Rectangle = Polygon.extend({\n    initialize: function (latLngBounds, options) {\n      Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n    },\n    // @method setBounds(latLngBounds: LatLngBounds): this\n    // Redraws the rectangle with the passed bounds.\n    setBounds: function (latLngBounds) {\n      return this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n    },\n    _boundsToLatLngs: function (latLngBounds) {\n      latLngBounds = toLatLngBounds(latLngBounds);\n      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];\n    }\n  }); // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)\n\n  function rectangle(latLngBounds, options) {\n    return new Rectangle(latLngBounds, options);\n  }\n\n  SVG.create = create$2;\n  SVG.pointsToPath = pointsToPath;\n  GeoJSON.geometryToLayer = geometryToLayer;\n  GeoJSON.coordsToLatLng = coordsToLatLng;\n  GeoJSON.coordsToLatLngs = coordsToLatLngs;\n  GeoJSON.latLngToCoords = latLngToCoords;\n  GeoJSON.latLngsToCoords = latLngsToCoords;\n  GeoJSON.getFeature = getFeature;\n  GeoJSON.asFeature = asFeature;\n  /*\n   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map\n   * (zoom to a selected bounding box), enabled by default.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option boxZoom: Boolean = true\n    // Whether the map can be zoomed to a rectangular area specified by\n    // dragging the mouse while pressing the shift key.\n    boxZoom: true\n  });\n  var BoxZoom = Handler.extend({\n    initialize: function (map) {\n      this._map = map;\n      this._container = map._container;\n      this._pane = map._panes.overlayPane;\n      this._resetStateTimeout = 0;\n      map.on('unload', this._destroy, this);\n    },\n    addHooks: function () {\n      on(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    removeHooks: function () {\n      off(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    moved: function () {\n      return this._moved;\n    },\n    _destroy: function () {\n      remove(this._pane);\n      delete this._pane;\n    },\n    _resetState: function () {\n      this._resetStateTimeout = 0;\n      this._moved = false;\n    },\n    _clearDeferredResetState: function () {\n      if (this._resetStateTimeout !== 0) {\n        clearTimeout(this._resetStateTimeout);\n        this._resetStateTimeout = 0;\n      }\n    },\n    _onMouseDown: function (e) {\n      if (!e.shiftKey || e.which !== 1 && e.button !== 1) {\n        return false;\n      } // Clear the deferred resetState if it hasn't executed yet, otherwise it\n      // will interrupt the interaction and orphan a box element in the container.\n\n\n      this._clearDeferredResetState();\n\n      this._resetState();\n\n      disableTextSelection();\n      disableImageDrag();\n      this._startPoint = this._map.mouseEventToContainerPoint(e);\n      on(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseMove: function (e) {\n      if (!this._moved) {\n        this._moved = true;\n        this._box = create$1('div', 'leaflet-zoom-box', this._container);\n        addClass(this._container, 'leaflet-crosshair');\n\n        this._map.fire('boxzoomstart');\n      }\n\n      this._point = this._map.mouseEventToContainerPoint(e);\n      var bounds = new Bounds(this._point, this._startPoint),\n          size = bounds.getSize();\n      setPosition(this._box, bounds.min);\n      this._box.style.width = size.x + 'px';\n      this._box.style.height = size.y + 'px';\n    },\n    _finish: function () {\n      if (this._moved) {\n        remove(this._box);\n        removeClass(this._container, 'leaflet-crosshair');\n      }\n\n      enableTextSelection();\n      enableImageDrag();\n      off(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseUp: function (e) {\n      if (e.which !== 1 && e.button !== 1) {\n        return;\n      }\n\n      this._finish();\n\n      if (!this._moved) {\n        return;\n      } // Postpone to next JS tick so internal click event handling\n      // still see it as \"moved\".\n\n\n      this._clearDeferredResetState();\n\n      this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);\n      var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));\n\n      this._map.fitBounds(bounds).fire('boxzoomend', {\n        boxZoomBounds: bounds\n      });\n    },\n    _onKeyDown: function (e) {\n      if (e.keyCode === 27) {\n        this._finish();\n      }\n    }\n  }); // @section Handlers\n  // @property boxZoom: Handler\n  // Box (shift-drag with mouse) zoom handler.\n\n  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);\n  /*\n   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option doubleClickZoom: Boolean|String = true\n    // Whether the map can be zoomed in by double clicking on it and\n    // zoomed out by double clicking while holding shift. If passed\n    // `'center'`, double-click zoom will zoom to the center of the\n    //  view regardless of where the mouse was.\n    doubleClickZoom: true\n  });\n  var DoubleClickZoom = Handler.extend({\n    addHooks: function () {\n      this._map.on('dblclick', this._onDoubleClick, this);\n    },\n    removeHooks: function () {\n      this._map.off('dblclick', this._onDoubleClick, this);\n    },\n    _onDoubleClick: function (e) {\n      var map = this._map,\n          oldZoom = map.getZoom(),\n          delta = map.options.zoomDelta,\n          zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;\n\n      if (map.options.doubleClickZoom === 'center') {\n        map.setZoom(zoom);\n      } else {\n        map.setZoomAround(e.containerPoint, zoom);\n      }\n    }\n  }); // @section Handlers\n  //\n  // Map properties include interaction handlers that allow you to control\n  // interaction behavior in runtime, enabling or disabling certain features such\n  // as dragging or touch zoom (see `Handler` methods). For example:\n  //\n  // ```js\n  // map.doubleClickZoom.disable();\n  // ```\n  //\n  // @property doubleClickZoom: Handler\n  // Double click zoom handler.\n\n  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);\n  /*\n   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option dragging: Boolean = true\n    // Whether the map be draggable with mouse/touch or not.\n    dragging: true,\n    // @section Panning Inertia Options\n    // @option inertia: Boolean = *\n    // If enabled, panning of the map will have an inertia effect where\n    // the map builds momentum while dragging and continues moving in\n    // the same direction for some time. Feels especially nice on touch\n    // devices. Enabled by default unless running on old Android devices.\n    inertia: !android23,\n    // @option inertiaDeceleration: Number = 3000\n    // The rate with which the inertial movement slows down, in pixels/second².\n    inertiaDeceleration: 3400,\n    // px/s^2\n    // @option inertiaMaxSpeed: Number = Infinity\n    // Max speed of the inertial movement, in pixels/second.\n    inertiaMaxSpeed: Infinity,\n    // px/s\n    // @option easeLinearity: Number = 0.2\n    easeLinearity: 0.2,\n    // TODO refactor, move to CRS\n    // @option worldCopyJump: Boolean = false\n    // With this option enabled, the map tracks when you pan to another \"copy\"\n    // of the world and seamlessly jumps to the original one so that all overlays\n    // like markers and vector layers are still visible.\n    worldCopyJump: false,\n    // @option maxBoundsViscosity: Number = 0.0\n    // If `maxBounds` is set, this option will control how solid the bounds\n    // are when dragging the map around. The default value of `0.0` allows the\n    // user to drag outside the bounds at normal speed, higher values will\n    // slow down map dragging outside bounds, and `1.0` makes the bounds fully\n    // solid, preventing the user from dragging outside the bounds.\n    maxBoundsViscosity: 0.0\n  });\n  var Drag = Handler.extend({\n    addHooks: function () {\n      if (!this._draggable) {\n        var map = this._map;\n        this._draggable = new Draggable(map._mapPane, map._container);\n\n        this._draggable.on({\n          dragstart: this._onDragStart,\n          drag: this._onDrag,\n          dragend: this._onDragEnd\n        }, this);\n\n        this._draggable.on('predrag', this._onPreDragLimit, this);\n\n        if (map.options.worldCopyJump) {\n          this._draggable.on('predrag', this._onPreDragWrap, this);\n\n          map.on('zoomend', this._onZoomEnd, this);\n          map.whenReady(this._onZoomEnd, this);\n        }\n      }\n\n      addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');\n\n      this._draggable.enable();\n\n      this._positions = [];\n      this._times = [];\n    },\n    removeHooks: function () {\n      removeClass(this._map._container, 'leaflet-grab');\n      removeClass(this._map._container, 'leaflet-touch-drag');\n\n      this._draggable.disable();\n    },\n    moved: function () {\n      return this._draggable && this._draggable._moved;\n    },\n    moving: function () {\n      return this._draggable && this._draggable._moving;\n    },\n    _onDragStart: function () {\n      var map = this._map;\n\n      map._stop();\n\n      if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n        var bounds = toLatLngBounds(this._map.options.maxBounds);\n        this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));\n        this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n      } else {\n        this._offsetLimit = null;\n      }\n\n      map.fire('movestart').fire('dragstart');\n\n      if (map.options.inertia) {\n        this._positions = [];\n        this._times = [];\n      }\n    },\n    _onDrag: function (e) {\n      if (this._map.options.inertia) {\n        var time = this._lastTime = +new Date(),\n            pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n\n        this._positions.push(pos);\n\n        this._times.push(time);\n\n        this._prunePositions(time);\n      }\n\n      this._map.fire('move', e).fire('drag', e);\n    },\n    _prunePositions: function (time) {\n      while (this._positions.length > 1 && time - this._times[0] > 50) {\n        this._positions.shift();\n\n        this._times.shift();\n      }\n    },\n    _onZoomEnd: function () {\n      var pxCenter = this._map.getSize().divideBy(2),\n          pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n      this._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n    },\n    _viscousLimit: function (value, threshold) {\n      return value - (value - threshold) * this._viscosity;\n    },\n    _onPreDragLimit: function () {\n      if (!this._viscosity || !this._offsetLimit) {\n        return;\n      }\n\n      var offset = this._draggable._newPos.subtract(this._draggable._startPos);\n\n      var limit = this._offsetLimit;\n\n      if (offset.x < limit.min.x) {\n        offset.x = this._viscousLimit(offset.x, limit.min.x);\n      }\n\n      if (offset.y < limit.min.y) {\n        offset.y = this._viscousLimit(offset.y, limit.min.y);\n      }\n\n      if (offset.x > limit.max.x) {\n        offset.x = this._viscousLimit(offset.x, limit.max.x);\n      }\n\n      if (offset.y > limit.max.y) {\n        offset.y = this._viscousLimit(offset.y, limit.max.y);\n      }\n\n      this._draggable._newPos = this._draggable._startPos.add(offset);\n    },\n    _onPreDragWrap: function () {\n      // TODO refactor to be able to adjust map pane position after zoom\n      var worldWidth = this._worldWidth,\n          halfWidth = Math.round(worldWidth / 2),\n          dx = this._initialWorldOffset,\n          x = this._draggable._newPos.x,\n          newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n          newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n          newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n      this._draggable._absPos = this._draggable._newPos.clone();\n      this._draggable._newPos.x = newX;\n    },\n    _onDragEnd: function (e) {\n      var map = this._map,\n          options = map.options,\n          noInertia = !options.inertia || this._times.length < 2;\n      map.fire('dragend', e);\n\n      if (noInertia) {\n        map.fire('moveend');\n      } else {\n        this._prunePositions(+new Date());\n\n        var direction = this._lastPos.subtract(this._positions[0]),\n            duration = (this._lastTime - this._times[0]) / 1000,\n            ease = options.easeLinearity,\n            speedVector = direction.multiplyBy(ease / duration),\n            speed = speedVector.distanceTo([0, 0]),\n            limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n            limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n            decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n            offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n        if (!offset.x && !offset.y) {\n          map.fire('moveend');\n        } else {\n          offset = map._limitOffset(offset, map.options.maxBounds);\n          requestAnimFrame(function () {\n            map.panBy(offset, {\n              duration: decelerationDuration,\n              easeLinearity: ease,\n              noMoveStart: true,\n              animate: true\n            });\n          });\n        }\n      }\n    }\n  }); // @section Handlers\n  // @property dragging: Handler\n  // Map dragging handler (by both mouse and touch).\n\n  Map.addInitHook('addHandler', 'dragging', Drag);\n  /*\n   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n   */\n  // @namespace Map\n  // @section Keyboard Navigation Options\n\n  Map.mergeOptions({\n    // @option keyboard: Boolean = true\n    // Makes the map focusable and allows users to navigate the map with keyboard\n    // arrows and `+`/`-` keys.\n    keyboard: true,\n    // @option keyboardPanDelta: Number = 80\n    // Amount of pixels to pan when pressing an arrow key.\n    keyboardPanDelta: 80\n  });\n  var Keyboard = Handler.extend({\n    keyCodes: {\n      left: [37],\n      right: [39],\n      down: [40],\n      up: [38],\n      zoomIn: [187, 107, 61, 171],\n      zoomOut: [189, 109, 54, 173]\n    },\n    initialize: function (map) {\n      this._map = map;\n\n      this._setPanDelta(map.options.keyboardPanDelta);\n\n      this._setZoomDelta(map.options.zoomDelta);\n    },\n    addHooks: function () {\n      var container = this._map._container; // make the container focusable by tabbing\n\n      if (container.tabIndex <= 0) {\n        container.tabIndex = '0';\n      }\n\n      on(container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n\n      this._map.on({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    removeHooks: function () {\n      this._removeHooks();\n\n      off(this._map._container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n\n      this._map.off({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    _onMouseDown: function () {\n      if (this._focused) {\n        return;\n      }\n\n      var body = document.body,\n          docEl = document.documentElement,\n          top = body.scrollTop || docEl.scrollTop,\n          left = body.scrollLeft || docEl.scrollLeft;\n\n      this._map._container.focus();\n\n      window.scrollTo(left, top);\n    },\n    _onFocus: function () {\n      this._focused = true;\n\n      this._map.fire('focus');\n    },\n    _onBlur: function () {\n      this._focused = false;\n\n      this._map.fire('blur');\n    },\n    _setPanDelta: function (panDelta) {\n      var keys = this._panKeys = {},\n          codes = this.keyCodes,\n          i,\n          len;\n\n      for (i = 0, len = codes.left.length; i < len; i++) {\n        keys[codes.left[i]] = [-1 * panDelta, 0];\n      }\n\n      for (i = 0, len = codes.right.length; i < len; i++) {\n        keys[codes.right[i]] = [panDelta, 0];\n      }\n\n      for (i = 0, len = codes.down.length; i < len; i++) {\n        keys[codes.down[i]] = [0, panDelta];\n      }\n\n      for (i = 0, len = codes.up.length; i < len; i++) {\n        keys[codes.up[i]] = [0, -1 * panDelta];\n      }\n    },\n    _setZoomDelta: function (zoomDelta) {\n      var keys = this._zoomKeys = {},\n          codes = this.keyCodes,\n          i,\n          len;\n\n      for (i = 0, len = codes.zoomIn.length; i < len; i++) {\n        keys[codes.zoomIn[i]] = zoomDelta;\n      }\n\n      for (i = 0, len = codes.zoomOut.length; i < len; i++) {\n        keys[codes.zoomOut[i]] = -zoomDelta;\n      }\n    },\n    _addHooks: function () {\n      on(document, 'keydown', this._onKeyDown, this);\n    },\n    _removeHooks: function () {\n      off(document, 'keydown', this._onKeyDown, this);\n    },\n    _onKeyDown: function (e) {\n      if (e.altKey || e.ctrlKey || e.metaKey) {\n        return;\n      }\n\n      var key = e.keyCode,\n          map = this._map,\n          offset;\n\n      if (key in this._panKeys) {\n        if (!map._panAnim || !map._panAnim._inProgress) {\n          offset = this._panKeys[key];\n\n          if (e.shiftKey) {\n            offset = toPoint(offset).multiplyBy(3);\n          }\n\n          map.panBy(offset);\n\n          if (map.options.maxBounds) {\n            map.panInsideBounds(map.options.maxBounds);\n          }\n        }\n      } else if (key in this._zoomKeys) {\n        map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n      } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {\n        map.closePopup();\n      } else {\n        return;\n      }\n\n      stop(e);\n    }\n  }); // @section Handlers\n  // @section Handlers\n  // @property keyboard: Handler\n  // Keyboard navigation handler.\n\n  Map.addInitHook('addHandler', 'keyboard', Keyboard);\n  /*\n   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @section Mousewheel options\n    // @option scrollWheelZoom: Boolean|String = true\n    // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\n    // it will zoom to the center of the view regardless of where the mouse was.\n    scrollWheelZoom: true,\n    // @option wheelDebounceTime: Number = 40\n    // Limits the rate at which a wheel can fire (in milliseconds). By default\n    // user can't zoom via wheel more often than once per 40 ms.\n    wheelDebounceTime: 40,\n    // @option wheelPxPerZoomLevel: Number = 60\n    // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\n    // mean a change of one full zoom level. Smaller values will make wheel-zooming\n    // faster (and vice versa).\n    wheelPxPerZoomLevel: 60\n  });\n  var ScrollWheelZoom = Handler.extend({\n    addHooks: function () {\n      on(this._map._container, 'mousewheel', this._onWheelScroll, this);\n      this._delta = 0;\n    },\n    removeHooks: function () {\n      off(this._map._container, 'mousewheel', this._onWheelScroll, this);\n    },\n    _onWheelScroll: function (e) {\n      var delta = getWheelDelta(e);\n      var debounce = this._map.options.wheelDebounceTime;\n      this._delta += delta;\n      this._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n      if (!this._startTime) {\n        this._startTime = +new Date();\n      }\n\n      var left = Math.max(debounce - (+new Date() - this._startTime), 0);\n      clearTimeout(this._timer);\n      this._timer = setTimeout(bind(this._performZoom, this), left);\n      stop(e);\n    },\n    _performZoom: function () {\n      var map = this._map,\n          zoom = map.getZoom(),\n          snap = this._map.options.zoomSnap || 0;\n\n      map._stop(); // stop panning and fly animations if any\n      // map the delta with a sigmoid function to -4..4 range leaning on -1..1\n\n\n      var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),\n          d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,\n          d4 = snap ? Math.ceil(d3 / snap) * snap : d3,\n          delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;\n      this._delta = 0;\n      this._startTime = null;\n\n      if (!delta) {\n        return;\n      }\n\n      if (map.options.scrollWheelZoom === 'center') {\n        map.setZoom(zoom + delta);\n      } else {\n        map.setZoomAround(this._lastMousePos, zoom + delta);\n      }\n    }\n  }); // @section Handlers\n  // @property scrollWheelZoom: Handler\n  // Scroll wheel zoom handler.\n\n  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);\n  /*\n   * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option tap: Boolean = true\n    // Enables mobile hacks for supporting instant taps (fixing 200ms click\n    // delay on iOS/Android) and touch holds (fired as `contextmenu` events).\n    tap: true,\n    // @option tapTolerance: Number = 15\n    // The max number of pixels a user can shift his finger during touch\n    // for it to be considered a valid tap.\n    tapTolerance: 15\n  });\n  var Tap = Handler.extend({\n    addHooks: function () {\n      on(this._map._container, 'touchstart', this._onDown, this);\n    },\n    removeHooks: function () {\n      off(this._map._container, 'touchstart', this._onDown, this);\n    },\n    _onDown: function (e) {\n      if (!e.touches) {\n        return;\n      }\n\n      preventDefault(e);\n      this._fireClick = true; // don't simulate click or track longpress if more than 1 touch\n\n      if (e.touches.length > 1) {\n        this._fireClick = false;\n        clearTimeout(this._holdTimeout);\n        return;\n      }\n\n      var first = e.touches[0],\n          el = first.target;\n      this._startPos = this._newPos = new Point(first.clientX, first.clientY); // if touching a link, highlight it\n\n      if (el.tagName && el.tagName.toLowerCase() === 'a') {\n        addClass(el, 'leaflet-active');\n      } // simulate long hold but setting a timeout\n\n\n      this._holdTimeout = setTimeout(bind(function () {\n        if (this._isTapValid()) {\n          this._fireClick = false;\n\n          this._onUp();\n\n          this._simulateEvent('contextmenu', first);\n        }\n      }, this), 1000);\n\n      this._simulateEvent('mousedown', first);\n\n      on(document, {\n        touchmove: this._onMove,\n        touchend: this._onUp\n      }, this);\n    },\n    _onUp: function (e) {\n      clearTimeout(this._holdTimeout);\n      off(document, {\n        touchmove: this._onMove,\n        touchend: this._onUp\n      }, this);\n\n      if (this._fireClick && e && e.changedTouches) {\n        var first = e.changedTouches[0],\n            el = first.target;\n\n        if (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n          removeClass(el, 'leaflet-active');\n        }\n\n        this._simulateEvent('mouseup', first); // simulate click if the touch didn't move too much\n\n\n        if (this._isTapValid()) {\n          this._simulateEvent('click', first);\n        }\n      }\n    },\n    _isTapValid: function () {\n      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n    },\n    _onMove: function (e) {\n      var first = e.touches[0];\n      this._newPos = new Point(first.clientX, first.clientY);\n\n      this._simulateEvent('mousemove', first);\n    },\n    _simulateEvent: function (type, e) {\n      var simulatedEvent = document.createEvent('MouseEvents');\n      simulatedEvent._simulated = true;\n      e.target._simulatedClick = true;\n      simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);\n      e.target.dispatchEvent(simulatedEvent);\n    }\n  }); // @section Handlers\n  // @property tap: Handler\n  // Mobile touch hacks (quick tap and touch hold) handler.\n\n  if (touch && !pointer) {\n    Map.addInitHook('addHandler', 'tap', Tap);\n  }\n  /*\n   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option touchZoom: Boolean|String = *\n    // Whether the map can be zoomed by touch-dragging with two fingers. If\n    // passed `'center'`, it will zoom to the center of the view regardless of\n    // where the touch events (fingers) were. Enabled for touch-capable web\n    // browsers except for old Androids.\n    touchZoom: touch && !android23,\n    // @option bounceAtZoomLimits: Boolean = true\n    // Set it to false if you don't want the map to zoom beyond min/max zoom\n    // and then bounce back when pinch-zooming.\n    bounceAtZoomLimits: true\n  });\n  var TouchZoom = Handler.extend({\n    addHooks: function () {\n      addClass(this._map._container, 'leaflet-touch-zoom');\n      on(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    removeHooks: function () {\n      removeClass(this._map._container, 'leaflet-touch-zoom');\n      off(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    _onTouchStart: function (e) {\n      var map = this._map;\n\n      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {\n        return;\n      }\n\n      var p1 = map.mouseEventToContainerPoint(e.touches[0]),\n          p2 = map.mouseEventToContainerPoint(e.touches[1]);\n      this._centerPoint = map.getSize()._divideBy(2);\n      this._startLatLng = map.containerPointToLatLng(this._centerPoint);\n\n      if (map.options.touchZoom !== 'center') {\n        this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n      }\n\n      this._startDist = p1.distanceTo(p2);\n      this._startZoom = map.getZoom();\n      this._moved = false;\n      this._zooming = true;\n\n      map._stop();\n\n      on(document, 'touchmove', this._onTouchMove, this);\n      on(document, 'touchend', this._onTouchEnd, this);\n      preventDefault(e);\n    },\n    _onTouchMove: function (e) {\n      if (!e.touches || e.touches.length !== 2 || !this._zooming) {\n        return;\n      }\n\n      var map = this._map,\n          p1 = map.mouseEventToContainerPoint(e.touches[0]),\n          p2 = map.mouseEventToContainerPoint(e.touches[1]),\n          scale = p1.distanceTo(p2) / this._startDist;\n\n      this._zoom = map.getScaleZoom(scale, this._startZoom);\n\n      if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {\n        this._zoom = map._limitZoom(this._zoom);\n      }\n\n      if (map.options.touchZoom === 'center') {\n        this._center = this._startLatLng;\n\n        if (scale === 1) {\n          return;\n        }\n      } else {\n        // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n        var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n\n        if (scale === 1 && delta.x === 0 && delta.y === 0) {\n          return;\n        }\n\n        this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);\n      }\n\n      if (!this._moved) {\n        map._moveStart(true, false);\n\n        this._moved = true;\n      }\n\n      cancelAnimFrame(this._animRequest);\n      var moveFn = bind(map._move, map, this._center, this._zoom, {\n        pinch: true,\n        round: false\n      });\n      this._animRequest = requestAnimFrame(moveFn, this, true);\n      preventDefault(e);\n    },\n    _onTouchEnd: function () {\n      if (!this._moved || !this._zooming) {\n        this._zooming = false;\n        return;\n      }\n\n      this._zooming = false;\n      cancelAnimFrame(this._animRequest);\n      off(document, 'touchmove', this._onTouchMove);\n      off(document, 'touchend', this._onTouchEnd); // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\n\n      if (this._map.options.zoomAnimation) {\n        this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\n      } else {\n        this._map._resetView(this._center, this._map._limitZoom(this._zoom));\n      }\n    }\n  }); // @section Handlers\n  // @property touchZoom: Handler\n  // Touch zoom handler.\n\n  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);\n  Map.BoxZoom = BoxZoom;\n  Map.DoubleClickZoom = DoubleClickZoom;\n  Map.Drag = Drag;\n  Map.Keyboard = Keyboard;\n  Map.ScrollWheelZoom = ScrollWheelZoom;\n  Map.Tap = Tap;\n  Map.TouchZoom = TouchZoom;\n  Object.freeze = freeze;\n  exports.version = version;\n  exports.Control = Control;\n  exports.control = control;\n  exports.Browser = Browser;\n  exports.Evented = Evented;\n  exports.Mixin = Mixin;\n  exports.Util = Util;\n  exports.Class = Class;\n  exports.Handler = Handler;\n  exports.extend = extend;\n  exports.bind = bind;\n  exports.stamp = stamp;\n  exports.setOptions = setOptions;\n  exports.DomEvent = DomEvent;\n  exports.DomUtil = DomUtil;\n  exports.PosAnimation = PosAnimation;\n  exports.Draggable = Draggable;\n  exports.LineUtil = LineUtil;\n  exports.PolyUtil = PolyUtil;\n  exports.Point = Point;\n  exports.point = toPoint;\n  exports.Bounds = Bounds;\n  exports.bounds = toBounds;\n  exports.Transformation = Transformation;\n  exports.transformation = toTransformation;\n  exports.Projection = index;\n  exports.LatLng = LatLng;\n  exports.latLng = toLatLng;\n  exports.LatLngBounds = LatLngBounds;\n  exports.latLngBounds = toLatLngBounds;\n  exports.CRS = CRS;\n  exports.GeoJSON = GeoJSON;\n  exports.geoJSON = geoJSON;\n  exports.geoJson = geoJson;\n  exports.Layer = Layer;\n  exports.LayerGroup = LayerGroup;\n  exports.layerGroup = layerGroup;\n  exports.FeatureGroup = FeatureGroup;\n  exports.featureGroup = featureGroup;\n  exports.ImageOverlay = ImageOverlay;\n  exports.imageOverlay = imageOverlay;\n  exports.VideoOverlay = VideoOverlay;\n  exports.videoOverlay = videoOverlay;\n  exports.SVGOverlay = SVGOverlay;\n  exports.svgOverlay = svgOverlay;\n  exports.DivOverlay = DivOverlay;\n  exports.Popup = Popup;\n  exports.popup = popup;\n  exports.Tooltip = Tooltip;\n  exports.tooltip = tooltip;\n  exports.Icon = Icon;\n  exports.icon = icon;\n  exports.DivIcon = DivIcon;\n  exports.divIcon = divIcon;\n  exports.Marker = Marker;\n  exports.marker = marker;\n  exports.TileLayer = TileLayer;\n  exports.tileLayer = tileLayer;\n  exports.GridLayer = GridLayer;\n  exports.gridLayer = gridLayer;\n  exports.SVG = SVG;\n  exports.svg = svg$1;\n  exports.Renderer = Renderer;\n  exports.Canvas = Canvas;\n  exports.canvas = canvas$1;\n  exports.Path = Path;\n  exports.CircleMarker = CircleMarker;\n  exports.circleMarker = circleMarker;\n  exports.Circle = Circle;\n  exports.circle = circle;\n  exports.Polyline = Polyline;\n  exports.polyline = polyline;\n  exports.Polygon = Polygon;\n  exports.polygon = polygon;\n  exports.Rectangle = Rectangle;\n  exports.rectangle = rectangle;\n  exports.Map = Map;\n  exports.map = createMap;\n  var oldL = window.L;\n\n  exports.noConflict = function () {\n    window.L = oldL;\n    return this;\n  }; // Always export us to window global (see #2364)\n\n\n  window.L = exports;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvVXRpbC5qcz8yZTY0Iiwid2VicGFjazovLy8uLi9zcmMvY29yZS9DbGFzcy5qcz8wMWFjIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9FdmVudHMuanM/MTM2ZiIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlb21ldHJ5L1BvaW50LmpzPzE1NDAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW9tZXRyeS9Cb3VuZHMuanM/MWM3OSIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9MYXRMbmdCb3VuZHMuanM/YjU3YyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9MYXRMbmcuanM/NWI2NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9jcnMvQ1JTLmpzP2IyY2QiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW8vY3JzL0NSUy5FYXJ0aC5qcz8xMDE5Iiwid2VicGFjazovLy8uLi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5qcz8xZTVlIiwid2VicGFjazovLy8uLi9zcmMvZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24uanM/YzI1MyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9jcnMvQ1JTLkVQU0czODU3LmpzP2YyMmUiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci92ZWN0b3IvU1ZHLlV0aWwuanM/OTBjMSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvQnJvd3Nlci5qcz83ZGUzIiwid2VicGFjazovLy8uLi9zcmMvZG9tL0RvbUV2ZW50LlBvaW50ZXIuanM/ODY0NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9Eb21FdmVudC5Eb3VibGVUYXAuanM/ZTc2ZCIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9Eb21VdGlsLmpzPzdjOTMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9kb20vRG9tRXZlbnQuanM/MWVhYyIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9Qb3NBbmltYXRpb24uanM/YjZiMSIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9NYXAuanM/NzNlYSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5qcz81MjkxIiwid2VicGFjazovLy8uLi9zcmMvY29udHJvbC9Db250cm9sLkxheWVycy5qcz82NGQ0Iiwid2VicGFjazovLy8uLi9zcmMvY29udHJvbC9Db250cm9sLlpvb20uanM/MTU1MCIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5TY2FsZS5qcz84YzY0Iiwid2VicGFjazovLy8uLi9zcmMvY29udHJvbC9Db250cm9sLkF0dHJpYnV0aW9uLmpzPzJjZDciLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb250cm9sL2luZGV4LmpzPzBjYTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL0hhbmRsZXIuanM/NGU1ZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvaW5kZXguanM/ZTBlMCIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9EcmFnZ2FibGUuanM/Y2NlYyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlb21ldHJ5L0xpbmVVdGlsLmpzPzE4N2EiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW9tZXRyeS9Qb2x5VXRpbC5qcz9kNTdlIiwid2VicGFjazovLy8uLi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQuanM/OWQ4NSIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3IuanM/YjJiYyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9wcm9qZWN0aW9uL2luZGV4LmpzP2ZkYTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW8vY3JzL0NSUy5FUFNHMzM5NS5qcz8wYzNiIiwid2VicGFjazovLy8uLi9zcmMvZ2VvL2Nycy9DUlMuRVBTRzQzMjYuanM/ZDk4MyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9jcnMvQ1JTLlNpbXBsZS5qcz85YmU4Iiwid2VicGFjazovLy8uLi9zcmMvZ2VvL2Nycy9pbmRleC5qcz82NmQ5Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvTGF5ZXIuanM/NjcwMyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0xheWVyR3JvdXAuanM/N2Y2NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0ZlYXR1cmVHcm91cC5qcz8yNDRhIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvbWFya2VyL0ljb24uanM/MDU4OCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL21hcmtlci9JY29uLkRlZmF1bHQuanM/MjdlNyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL21hcmtlci9NYXJrZXIuRHJhZy5qcz8yZmI1Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvbWFya2VyL01hcmtlci5qcz8zZGQyIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1BhdGguanM/ZjY2YSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGVNYXJrZXIuanM/MjQ4ZiIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGUuanM/OWQxYSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9Qb2x5bGluZS5qcz85YzM3Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1BvbHlnb24uanM/MjcyNyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0dlb0pTT04uanM/YWFlYSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0ltYWdlT3ZlcmxheS5qcz8wMTg5Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvVmlkZW9PdmVybGF5LmpzPzAzZTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9TVkdPdmVybGF5LmpzPzNjZjMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9EaXZPdmVybGF5LmpzPzAwMjMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9Qb3B1cC5qcz84ZTExIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvVG9vbHRpcC5qcz8wZGIyIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvbWFya2VyL0Rpdkljb24uanM/ZTBkZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL21hcmtlci9pbmRleC5qcz84ZjM4Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdGlsZS9HcmlkTGF5ZXIuanM/Mzg4ZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzPzI2MjAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci90aWxlL1RpbGVMYXllci5XTVMuanM/ZjllNiIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3RpbGUvaW5kZXguanM/NDI4YyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5qcz8xMGVlIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL0NhbnZhcy5qcz9iOWViIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1NWRy5WTUwuanM/YzkzNCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9TVkcuanM/Zjg0YiIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5nZXRSZW5kZXJlci5qcz81ZmE3Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1JlY3RhbmdsZS5qcz8wZDdhIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL2luZGV4LmpzPzFlMTMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9pbmRleC5qcz8xMjIyIiwid2VicGFjazovLy8uLi9zcmMvbWFwL2hhbmRsZXIvTWFwLkJveFpvb20uanM/ZTljYyIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20uanM/MDJkNSIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5EcmFnLmpzP2JjZDAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9tYXAvaGFuZGxlci9NYXAuS2V5Ym9hcmQuanM/M2YzYiIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20uanM/MWYxNCIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5UYXAuanM/OTFiZCIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5Ub3VjaFpvb20uanM/ZjY2YSIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9pbmRleC5qcz8yMDUyIiwid2VicGFjazovLy8uLi9zcmMvTGVhZmxldC5qcz82YzExIl0sIm5hbWVzIjpbIlV0aWwuY3JlYXRlIiwiVXRpbC5leHRlbmQiLCJVdGlsLmlzQXJyYXkiLCJVdGlsLnNwbGl0V29yZHMiLCJVdGlsLmZhbHNlRm4iLCJVdGlsLmJpbmQiLCJVdGlsLnN0YW1wIiwiVXRpbC5mb3JtYXROdW0iLCJVdGlsLndyYXBOdW0iLCJCcm93c2VyLnN2ZyIsInN0eWxlIiwiQnJvd3Nlci5tc1BvaW50ZXIiLCJEb21FdmVudC5wcmV2ZW50RGVmYXVsdCIsIkJyb3dzZXIucG9pbnRlciIsInRvdWNoIiwiQnJvd3Nlci5lZGdlIiwiQnJvd3Nlci5wYXNzaXZlRXZlbnRzIiwiY3JlYXRlIiwiVXRpbC50cmltIiwiQnJvd3Nlci5pZTNkIiwiQnJvd3Nlci5hbnkzZCIsIkRvbUV2ZW50Lm9uIiwiRG9tRXZlbnQub2ZmIiwiQnJvd3Nlci50b3VjaCIsIkJyb3dzZXIuY2hyb21lIiwiQnJvd3Nlci5hbmRyb2lkIiwiQnJvd3Nlci53aW4iLCJCcm93c2VyLmdlY2tvIiwiRG9tVXRpbC5nZXRQb3NpdGlvbiIsIlV0aWwucmVxdWVzdEFuaW1GcmFtZSIsIkRvbVV0aWwuc2V0UG9zaXRpb24iLCJVdGlsLmNhbmNlbEFuaW1GcmFtZSIsIlV0aWwuc2V0T3B0aW9ucyIsIkRvbVV0aWwuVFJBTlNJVElPTiIsIkJyb3dzZXIubW9iaWxlT3BlcmEiLCJEb21VdGlsLlRSQU5TSVRJT05fRU5EIiwiRG9tVXRpbC5hZGRDbGFzcyIsIkRvbVV0aWwucmVtb3ZlIiwiRG9tVXRpbC5jcmVhdGUiLCJEb21FdmVudC5nZXRNb3VzZVBvc2l0aW9uIiwiRG9tVXRpbC5nZXQiLCJCcm93c2VyLnJldGluYSIsIkJyb3dzZXIuaWVsdDkiLCJCcm93c2VyLnNhZmFyaSIsIkRvbVV0aWwuZ2V0U3R5bGUiLCJyZW1vdmUiLCJEb21FdmVudC5pc0V4dGVybmFsVGFyZ2V0IiwiRG9tRXZlbnQuc2tpcHBlZCIsIkRvbVV0aWwucHJldmVudE91dGxpbmUiLCJVdGlsLmluZGV4T2YiLCJEb21VdGlsLnJlbW92ZUNsYXNzIiwiRG9tVXRpbC5UUkFOU0ZPUk0iLCJEb21VdGlsLnNldFRyYW5zZm9ybSIsIkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uIiwiRG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uIiwiRG9tRXZlbnQuc3RvcCIsIkRvbVV0aWwuZW1wdHkiLCJwcmV2ZW50T3V0bGluZSIsIkRvbVV0aWwuaGFzQ2xhc3MiLCJEb21VdGlsLmRpc2FibGVJbWFnZURyYWciLCJEb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uIiwiRG9tVXRpbC5nZXRTaXplZFBhcmVudE5vZGUiLCJEb21VdGlsLmdldFNjYWxlIiwiRG9tVXRpbC5lbmFibGVJbWFnZURyYWciLCJEb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24iLCJMaW5lVXRpbC5fZ2V0Qml0Q29kZSIsIkxpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uIiwicG9pbnQiLCJsYXRMbmciLCJEb21VdGlsLnNldE9wYWNpdHkiLCJMaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJMaW5lVXRpbC5pc0ZsYXQiLCJMaW5lVXRpbC5jbGlwU2VnbWVudCIsIkxpbmVVdGlsLnNpbXBsaWZ5IiwiTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZSIsIkxpbmVVdGlsLl9mbGF0IiwiUG9seVV0aWwuY2xpcFBvbHlnb24iLCJEb21VdGlsLnRvRnJvbnQiLCJEb21VdGlsLnRvQmFjayIsIkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbiIsIkJyb3dzZXIubW9iaWxlIiwiVXRpbC50aHJvdHRsZSIsImxhdExuZ0JvdW5kcyIsIkJyb3dzZXIuYW5kcm9pZDIzIiwiVXRpbC50ZW1wbGF0ZSIsIlV0aWwuZW1wdHlJbWFnZVVybCIsIkJyb3dzZXIuYW5kcm9pZFN0b2NrIiwiRG9tRXZlbnQuZmFrZVN0b3AiLCJjYW52YXMiLCJCcm93c2VyLmNhbnZhcyIsIkJyb3dzZXIudm1sIiwic3ZnIiwiRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFQUFBOzs7Ozs7RUFNTyxJQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBcEI7O0VBQ1AsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsVUFBVSxHQUFWLEVBQWU7SUFBRSxPQUFPLEdBQVA7RUFBYSxDQUE5QyxDOzs7O0VBSU8sU0FBUyxNQUFULENBQWdCLElBQWhCLEVBQXNCO0lBQzVCLElBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxHQUFWLEVBQWUsR0FBZjs7SUFFQSxLQUFLLENBQUMsR0FBRyxDQUFKLEVBQU8sR0FBRyxHQUFHLFNBQVMsQ0FBQyxNQUE1QixFQUFvQyxDQUFDLEdBQUcsR0FBeEMsRUFBNkMsQ0FBQyxFQUE5QyxFQUFrRDtNQUNqRCxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUQsQ0FBZjs7TUFDQSxLQUFLLENBQUwsSUFBVSxHQUFWLEVBQWU7UUFDZCxJQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVUsR0FBRyxDQUFDLENBQUQsQ0FBYjtNQUNBO0lBQ0Q7O0lBQ0QsT0FBTyxJQUFQO0VBQ0EsQzs7OztFQUlNLElBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFQLElBQWtCLFlBQVk7SUFDakQsU0FBUyxDQUFULEdBQWEsQ0FBRTs7SUFDZixPQUFPLFVBQVUsS0FBVixFQUFpQjtNQUN2QixDQUFDLENBQUMsU0FBRixHQUFjLEtBQWQ7TUFDQSxPQUFPLElBQUksQ0FBSixFQUFQO0lBQ0EsQ0FIRDtFQUlBLENBTm9DLEVBQTlCLEM7Ozs7O0VBV0EsU0FBUyxJQUFULENBQWMsRUFBZCxFQUFrQixHQUFsQixF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QUFlLFFBQWY7RUFFQSxHQUFHLENBQUMsZUFBSixHQUFzQixlQUF0QjtFQUVBLEdBQUcsQ0FBQyxHQUFKLEdBQVUsR0FBVjtFQUVBLEdBQUcsQ0FBQyxTQUFKLEdBQWdCLFNBQWhCO0VDWUEsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsTUFBaEIiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIEBuYW1lc3BhY2UgVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIGZyZWV6ZSA9IE9iamVjdC5mcmVlemU7XHJcbk9iamVjdC5mcmVlemUgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmo7IH07XHJcblxyXG4vLyBAZnVuY3Rpb24gZXh0ZW5kKGRlc3Q6IE9iamVjdCwgc3JjPzogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgYHNyY2Agb2JqZWN0IChvciBtdWx0aXBsZSBvYmplY3RzKSBpbnRvIGBkZXN0YCBvYmplY3QgYW5kIHJldHVybnMgdGhlIGxhdHRlci4gSGFzIGFuIGBMLmV4dGVuZGAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQoZGVzdCkge1xyXG5cdHZhciBpLCBqLCBsZW4sIHNyYztcclxuXHJcblx0Zm9yIChqID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XHJcblx0XHRzcmMgPSBhcmd1bWVudHNbal07XHJcblx0XHRmb3IgKGkgaW4gc3JjKSB7XHJcblx0XHRcdGRlc3RbaV0gPSBzcmNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBkZXN0O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY3JlYXRlKHByb3RvOiBPYmplY3QsIHByb3BlcnRpZXM/OiBPYmplY3QpOiBPYmplY3RcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW09iamVjdC5jcmVhdGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGUpXHJcbmV4cG9ydCB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xyXG5cdGZ1bmN0aW9uIEYoKSB7fVxyXG5cdHJldHVybiBmdW5jdGlvbiAocHJvdG8pIHtcclxuXHRcdEYucHJvdG90eXBlID0gcHJvdG87XHJcblx0XHRyZXR1cm4gbmV3IEYoKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGJpbmQoZm46IEZ1bmN0aW9uLCDigKYpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBhcmd1bWVudHMgcGFzc2VkLCBsaWtlIFtGdW5jdGlvbi5wcm90b3R5cGUuYmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCkuXHJcbi8vIEhhcyBhIGBMLmJpbmQoKWAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBiaW5kKGZuLCBvYmopIHtcclxuXHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG5cdGlmIChmbi5iaW5kKSB7XHJcblx0XHRyZXR1cm4gZm4uYmluZC5hcHBseShmbiwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuXHR9XHJcblxyXG5cdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5sZW5ndGggPyBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogYXJndW1lbnRzKTtcclxuXHR9O1xyXG59XHJcblxyXG4vLyBAcHJvcGVydHkgbGFzdElkOiBOdW1iZXJcclxuLy8gTGFzdCB1bmlxdWUgSUQgdXNlZCBieSBbYHN0YW1wKClgXSgjdXRpbC1zdGFtcClcclxuZXhwb3J0IHZhciBsYXN0SWQgPSAwO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHN0YW1wKG9iajogT2JqZWN0KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIHVuaXF1ZSBJRCBvZiBhbiBvYmplY3QsIGFzc2lnbmluZyBpdCBvbmUgaWYgaXQgZG9lc24ndCBoYXZlIGl0LlxyXG5leHBvcnQgZnVuY3Rpb24gc3RhbXAob2JqKSB7XHJcblx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdG9iai5fbGVhZmxldF9pZCA9IG9iai5fbGVhZmxldF9pZCB8fCArK2xhc3RJZDtcclxuXHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xyXG5cdC8qIGVzbGludC1lbmFibGUgKi9cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRocm90dGxlKGZuOiBGdW5jdGlvbiwgdGltZTogTnVtYmVyLCBjb250ZXh0OiBPYmplY3QpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZXhlY3V0ZXMgZnVuY3Rpb24gYGZuYCB3aXRoIHRoZSBnaXZlbiBzY29wZSBgY29udGV4dGBcclxuLy8gKHNvIHRoYXQgdGhlIGB0aGlzYCBrZXl3b3JkIHJlZmVycyB0byBgY29udGV4dGAgaW5zaWRlIGBmbmAncyBjb2RlKS4gVGhlIGZ1bmN0aW9uXHJcbi8vIGBmbmAgd2lsbCBiZSBjYWxsZWQgbm8gbW9yZSB0aGFuIG9uZSB0aW1lIHBlciBnaXZlbiBhbW91bnQgb2YgYHRpbWVgLiBUaGUgYXJndW1lbnRzXHJcbi8vIHJlY2VpdmVkIGJ5IHRoZSBib3VuZCBmdW5jdGlvbiB3aWxsIGJlIGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gYmluZGluZyB0aGVcclxuLy8gZnVuY3Rpb24sIGZvbGxvd2VkIGJ5IGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gaW52b2tpbmcgdGhlIGJvdW5kIGZ1bmN0aW9uLlxyXG4vLyBIYXMgYW4gYEwudGhyb3R0bGVgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHRpbWUsIGNvbnRleHQpIHtcclxuXHR2YXIgbG9jaywgYXJncywgd3JhcHBlckZuLCBsYXRlcjtcclxuXHJcblx0bGF0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyByZXNldCBsb2NrIGFuZCBjYWxsIGlmIHF1ZXVlZFxyXG5cdFx0bG9jayA9IGZhbHNlO1xyXG5cdFx0aWYgKGFyZ3MpIHtcclxuXHRcdFx0d3JhcHBlckZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG5cdFx0XHRhcmdzID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0d3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKGxvY2spIHtcclxuXHRcdFx0Ly8gY2FsbGVkIHRvbyBzb29uLCBxdWV1ZSB0byBjYWxsIGxhdGVyXHJcblx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gY2FsbCBhbmQgbG9jayB1bnRpbCBsYXRlclxyXG5cdFx0XHRmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xyXG5cdFx0XHRzZXRUaW1lb3V0KGxhdGVyLCB0aW1lKTtcclxuXHRcdFx0bG9jayA9IHRydWU7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHdyYXBwZXJGbjtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHdyYXBOdW0obnVtOiBOdW1iZXIsIHJhbmdlOiBOdW1iZXJbXSwgaW5jbHVkZU1heD86IEJvb2xlYW4pOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIG1vZHVsbyBgcmFuZ2VgIGluIHN1Y2ggYSB3YXkgc28gaXQgbGllcyB3aXRoaW5cclxuLy8gYHJhbmdlWzBdYCBhbmQgYHJhbmdlWzFdYC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgYWx3YXlzIHNtYWxsZXIgdGhhblxyXG4vLyBgcmFuZ2VbMV1gIHVubGVzcyBgaW5jbHVkZU1heGAgaXMgc2V0IHRvIGB0cnVlYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBOdW0oeCwgcmFuZ2UsIGluY2x1ZGVNYXgpIHtcclxuXHR2YXIgbWF4ID0gcmFuZ2VbMV0sXHJcblx0ICAgIG1pbiA9IHJhbmdlWzBdLFxyXG5cdCAgICBkID0gbWF4IC0gbWluO1xyXG5cdHJldHVybiB4ID09PSBtYXggJiYgaW5jbHVkZU1heCA/IHggOiAoKHggLSBtaW4pICUgZCArIGQpICUgZCArIG1pbjtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGZhbHNlRm4oKTogRnVuY3Rpb25cclxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWxzZUZuKCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbi8vIEBmdW5jdGlvbiBmb3JtYXROdW0obnVtOiBOdW1iZXIsIGRpZ2l0cz86IE51bWJlcik6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgcm91bmRlZCB0byBgZGlnaXRzYCBkZWNpbWFscywgb3IgdG8gNiBkZWNpbWFscyBieSBkZWZhdWx0LlxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtKG51bSwgZGlnaXRzKSB7XHJcblx0dmFyIHBvdyA9IE1hdGgucG93KDEwLCAoZGlnaXRzID09PSB1bmRlZmluZWQgPyA2IDogZGlnaXRzKSk7XHJcblx0cmV0dXJuIE1hdGgucm91bmQobnVtICogcG93KSAvIHBvdztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRyaW0oc3RyOiBTdHJpbmcpOiBTdHJpbmdcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW1N0cmluZy5wcm90b3R5cGUudHJpbV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0pXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmltKHN0cikge1xyXG5cdHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHI6IFN0cmluZyk6IFN0cmluZ1tdXHJcbi8vIFRyaW1zIGFuZCBzcGxpdHMgdGhlIHN0cmluZyBvbiB3aGl0ZXNwYWNlIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiBwYXJ0cy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyKSB7XHJcblx0cmV0dXJuIHRyaW0oc3RyKS5zcGxpdCgvXFxzKy8pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmo6IE9iamVjdCwgb3B0aW9uczogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE1lcmdlcyB0aGUgZ2l2ZW4gcHJvcGVydGllcyB0byB0aGUgYG9wdGlvbnNgIG9mIHRoZSBgb2JqYCBvYmplY3QsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIG9wdGlvbnMuIFNlZSBgQ2xhc3Mgb3B0aW9uc2AuIEhhcyBhbiBgTC5zZXRPcHRpb25zYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqLCBvcHRpb25zKSB7XHJcblx0aWYgKCFvYmouaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSkge1xyXG5cdFx0b2JqLm9wdGlvbnMgPSBvYmoub3B0aW9ucyA/IGNyZWF0ZShvYmoub3B0aW9ucykgOiB7fTtcclxuXHR9XHJcblx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRvYmoub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0fVxyXG5cdHJldHVybiBvYmoub3B0aW9ucztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iajogT2JqZWN0LCBleGlzdGluZ1VybD86IFN0cmluZywgdXBwZXJjYXNlPzogQm9vbGVhbik6IFN0cmluZ1xyXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIHBhcmFtZXRlciBVUkwgc3RyaW5nLCBlLmcuIGB7YTogXCJmb29cIiwgYjogXCJiYXJcIn1gXHJcbi8vIHRyYW5zbGF0ZXMgdG8gYCc/YT1mb28mYj1iYXInYC4gSWYgYGV4aXN0aW5nVXJsYCBpcyBzZXQsIHRoZSBwYXJhbWV0ZXJzIHdpbGxcclxuLy8gYmUgYXBwZW5kZWQgYXQgdGhlIGVuZC4gSWYgYHVwcGVyY2FzZWAgaXMgYHRydWVgLCB0aGUgcGFyYW1ldGVyIG5hbWVzIHdpbGxcclxuLy8gYmUgdXBwZXJjYXNlZCAoZS5nLiBgJz9BPWZvbyZCPWJhcidgKVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqLCBleGlzdGluZ1VybCwgdXBwZXJjYXNlKSB7XHJcblx0dmFyIHBhcmFtcyA9IFtdO1xyXG5cdGZvciAodmFyIGkgaW4gb2JqKSB7XHJcblx0XHRwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQodXBwZXJjYXNlID8gaS50b1VwcGVyQ2FzZSgpIDogaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKSk7XHJcblx0fVxyXG5cdHJldHVybiAoKCFleGlzdGluZ1VybCB8fCBleGlzdGluZ1VybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyBwYXJhbXMuam9pbignJicpO1xyXG59XHJcblxyXG52YXIgdGVtcGxhdGVSZSA9IC9cXHsgKihbXFx3Xy1dKykgKlxcfS9nO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHRlbXBsYXRlKHN0cjogU3RyaW5nLCBkYXRhOiBPYmplY3QpOiBTdHJpbmdcclxuLy8gU2ltcGxlIHRlbXBsYXRpbmcgZmFjaWxpdHksIGFjY2VwdHMgYSB0ZW1wbGF0ZSBzdHJpbmcgb2YgdGhlIGZvcm0gYCdIZWxsbyB7YX0sIHtifSdgXHJcbi8vIGFuZCBhIGRhdGEgb2JqZWN0IGxpa2UgYHthOiAnZm9vJywgYjogJ2Jhcid9YCwgcmV0dXJucyBldmFsdWF0ZWQgc3RyaW5nXHJcbi8vIGAoJ0hlbGxvIGZvbywgYmFyJylgLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvclxyXG4vLyBkYXRhIHZhbHVlcyDigJQgdGhleSB3aWxsIGJlIGV2YWx1YXRlZCBwYXNzaW5nIGBkYXRhYCBhcyBhbiBhcmd1bWVudC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlKHN0ciwgZGF0YSkge1xyXG5cdHJldHVybiBzdHIucmVwbGFjZSh0ZW1wbGF0ZVJlLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcclxuXHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIHByb3ZpZGVkIGZvciB2YXJpYWJsZSAnICsgc3RyKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gaXNBcnJheShvYmopOiBCb29sZWFuXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5pc0FycmF5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5KVxyXG5leHBvcnQgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBpbmRleE9mKGFycmF5OiBBcnJheSwgZWw6IE9iamVjdCk6IE51bWJlclxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkucHJvdG90eXBlLmluZGV4T2ZdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YpXHJcbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbCkge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChhcnJheVtpXSA9PT0gZWwpIHsgcmV0dXJuIGk7IH1cclxuXHR9XHJcblx0cmV0dXJuIC0xO1xyXG59XHJcblxyXG4vLyBAcHJvcGVydHkgZW1wdHlJbWFnZVVybDogU3RyaW5nXHJcbi8vIERhdGEgVVJJIHN0cmluZyBjb250YWluaW5nIGEgYmFzZTY0LWVuY29kZWQgZW1wdHkgR0lGIGltYWdlLlxyXG4vLyBVc2VkIGFzIGEgaGFjayB0byBmcmVlIG1lbW9yeSBmcm9tIHVudXNlZCBpbWFnZXMgb24gV2ViS2l0LXBvd2VyZWRcclxuLy8gbW9iaWxlIGRldmljZXMgKGJ5IHNldHRpbmcgaW1hZ2UgYHNyY2AgdG8gdGhpcyBzdHJpbmcpLlxyXG5leHBvcnQgdmFyIGVtcHR5SW1hZ2VVcmwgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPSc7XHJcblxyXG4vLyBpbnNwaXJlZCBieSBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG5cclxuZnVuY3Rpb24gZ2V0UHJlZml4ZWQobmFtZSkge1xyXG5cdHJldHVybiB3aW5kb3dbJ3dlYmtpdCcgKyBuYW1lXSB8fCB3aW5kb3dbJ21veicgKyBuYW1lXSB8fCB3aW5kb3dbJ21zJyArIG5hbWVdO1xyXG59XHJcblxyXG52YXIgbGFzdFRpbWUgPSAwO1xyXG5cclxuLy8gZmFsbGJhY2sgZm9yIElFIDctOFxyXG5mdW5jdGlvbiB0aW1lb3V0RGVmZXIoZm4pIHtcclxuXHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxyXG5cdCAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAodGltZSAtIGxhc3RUaW1lKSk7XHJcblxyXG5cdGxhc3RUaW1lID0gdGltZSArIHRpbWVUb0NhbGw7XHJcblx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lVG9DYWxsKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXI7XHJcbmV4cG9ydCB2YXIgY2FuY2VsRm4gPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJykgfHxcclxuXHRcdGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIGltbWVkaWF0ZT86IEJvb2xlYW4pOiBOdW1iZXJcclxuLy8gU2NoZWR1bGVzIGBmbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgYnJvd3NlciByZXBhaW50cy4gYGZuYCBpcyBib3VuZCB0b1xyXG4vLyBgY29udGV4dGAgaWYgZ2l2ZW4uIFdoZW4gYGltbWVkaWF0ZWAgaXMgc2V0LCBgZm5gIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpZlxyXG4vLyB0aGUgYnJvd3NlciBkb2Vzbid0IGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yXHJcbi8vIFtgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSxcclxuLy8gb3RoZXJ3aXNlIGl0J3MgZGVsYXllZC4gUmV0dXJucyBhIHJlcXVlc3QgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXHJcbmV4cG9ydCBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuLCBjb250ZXh0LCBpbW1lZGlhdGUpIHtcclxuXHRpZiAoaW1tZWRpYXRlICYmIHJlcXVlc3RGbiA9PT0gdGltZW91dERlZmVyKSB7XHJcblx0XHRmbi5jYWxsKGNvbnRleHQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gcmVxdWVzdEZuLmNhbGwod2luZG93LCBiaW5kKGZuLCBjb250ZXh0KSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkOiBOdW1iZXIpOiB1bmRlZmluZWRcclxuLy8gQ2FuY2VscyBhIHByZXZpb3VzIGByZXF1ZXN0QW5pbUZyYW1lYC4gU2VlIGFsc28gW3dpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZSkuXHJcbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQpIHtcclxuXHRpZiAoaWQpIHtcclxuXHRcdGNhbmNlbEZuLmNhbGwod2luZG93LCBpZCk7XHJcblx0fVxyXG59XHJcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuXHJcbi8vIEBjbGFzcyBDbGFzc1xyXG4vLyBAYWthIEwuQ2xhc3NcclxuXHJcbi8vIEBzZWN0aW9uXHJcbi8vIEB1bmluaGVyaXRhYmxlXHJcblxyXG4vLyBUaGFua3MgdG8gSm9obiBSZXNpZyBhbmQgRGVhbiBFZHdhcmRzIGZvciBpbnNwaXJhdGlvbiFcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDbGFzcygpIHt9XHJcblxyXG5DbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGV4dGVuZChwcm9wczogT2JqZWN0KTogRnVuY3Rpb25cclxuXHQvLyBbRXh0ZW5kcyB0aGUgY3VycmVudCBjbGFzc10oI2NsYXNzLWluaGVyaXRhbmNlKSBnaXZlbiB0aGUgcHJvcGVydGllcyB0byBiZSBpbmNsdWRlZC5cclxuXHQvLyBSZXR1cm5zIGEgSmF2YXNjcmlwdCBmdW5jdGlvbiB0aGF0IGlzIGEgY2xhc3MgY29uc3RydWN0b3IgKHRvIGJlIGNhbGxlZCB3aXRoIGBuZXdgKS5cclxuXHR2YXIgTmV3Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gY2FsbCB0aGUgY29uc3RydWN0b3JcclxuXHRcdGlmICh0aGlzLmluaXRpYWxpemUpIHtcclxuXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2FsbCBhbGwgY29uc3RydWN0b3IgaG9va3NcclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cdH07XHJcblxyXG5cdHZhciBwYXJlbnRQcm90byA9IE5ld0NsYXNzLl9fc3VwZXJfXyA9IHRoaXMucHJvdG90eXBlO1xyXG5cclxuXHR2YXIgcHJvdG8gPSBVdGlsLmNyZWF0ZShwYXJlbnRQcm90byk7XHJcblx0cHJvdG8uY29uc3RydWN0b3IgPSBOZXdDbGFzcztcclxuXHJcblx0TmV3Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XHJcblxyXG5cdC8vIGluaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG5cdGZvciAodmFyIGkgaW4gdGhpcykge1xyXG5cdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScgJiYgaSAhPT0gJ19fc3VwZXJfXycpIHtcclxuXHRcdFx0TmV3Q2xhc3NbaV0gPSB0aGlzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gbWl4IHN0YXRpYyBwcm9wZXJ0aWVzIGludG8gdGhlIGNsYXNzXHJcblx0aWYgKHByb3BzLnN0YXRpY3MpIHtcclxuXHRcdFV0aWwuZXh0ZW5kKE5ld0NsYXNzLCBwcm9wcy5zdGF0aWNzKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5zdGF0aWNzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdGlmIChwcm9wcy5pbmNsdWRlcykge1xyXG5cdFx0Y2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMocHJvcHMuaW5jbHVkZXMpO1xyXG5cdFx0VXRpbC5leHRlbmQuYXBwbHkobnVsbCwgW3Byb3RvXS5jb25jYXQocHJvcHMuaW5jbHVkZXMpKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5pbmNsdWRlcztcclxuXHR9XHJcblxyXG5cdC8vIG1lcmdlIG9wdGlvbnNcclxuXHRpZiAocHJvdG8ub3B0aW9ucykge1xyXG5cdFx0cHJvcHMub3B0aW9ucyA9IFV0aWwuZXh0ZW5kKFV0aWwuY3JlYXRlKHByb3RvLm9wdGlvbnMpLCBwcm9wcy5vcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdC8vIG1peCBnaXZlbiBwcm9wZXJ0aWVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdFV0aWwuZXh0ZW5kKHByb3RvLCBwcm9wcyk7XHJcblxyXG5cdHByb3RvLl9pbml0SG9va3MgPSBbXTtcclxuXHJcblx0Ly8gYWRkIG1ldGhvZCBmb3IgY2FsbGluZyBhbGwgaG9va3NcclxuXHRwcm90by5jYWxsSW5pdEhvb2tzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MpIHtcclxuXHRcdFx0cGFyZW50UHJvdG8uY2FsbEluaXRIb29rcy5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRIb29rc0NhbGxlZCA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3RvLl9pbml0SG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cHJvdG8uX2luaXRIb29rc1tpXS5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiBOZXdDbGFzcztcclxufTtcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaW5jbHVkZShwcm9wZXJ0aWVzOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtJbmNsdWRlcyBhIG1peGluXSgjY2xhc3MtaW5jbHVkZXMpIGludG8gdGhlIGN1cnJlbnQgY2xhc3MuXHJcbkNsYXNzLmluY2x1ZGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHRVdGlsLmV4dGVuZCh0aGlzLnByb3RvdHlwZSwgcHJvcHMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtNZXJnZXMgYG9wdGlvbnNgXSgjY2xhc3Mtb3B0aW9ucykgaW50byB0aGUgZGVmYXVsdHMgb2YgdGhlIGNsYXNzLlxyXG5DbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuLy8gQWRkcyBhIFtjb25zdHJ1Y3RvciBob29rXSgjY2xhc3MtY29uc3RydWN0b3ItaG9va3MpIHRvIHRoZSBjbGFzcy5cclxuQ2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHsgLy8gKEZ1bmN0aW9uKSB8fCAoU3RyaW5nLCBhcmdzLi4uKVxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcblx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXNbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKGluY2x1ZGVzKSB7XHJcblx0aWYgKHR5cGVvZiBMID09PSAndW5kZWZpbmVkJyB8fCAhTCB8fCAhTC5NaXhpbikgeyByZXR1cm47IH1cclxuXHJcblx0aW5jbHVkZXMgPSBVdGlsLmlzQXJyYXkoaW5jbHVkZXMpID8gaW5jbHVkZXMgOiBbaW5jbHVkZXNdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGluY2x1ZGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAoaW5jbHVkZXNbaV0gPT09IEwuTWl4aW4uRXZlbnRzKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCBpbmNsdWRlIG9mIEwuTWl4aW4uRXZlbnRzOiAnICtcclxuXHRcdFx0XHQndGhpcyBwcm9wZXJ0eSB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzLCAnICtcclxuXHRcdFx0XHQncGxlYXNlIGluaGVyaXQgZnJvbSBMLkV2ZW50ZWQgaW5zdGVhZC4nLCBuZXcgRXJyb3IoKS5zdGFjayk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRXZlbnRlZFxyXG4gKiBAYWthIEwuRXZlbnRlZFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogQSBzZXQgb2YgbWV0aG9kcyBzaGFyZWQgYmV0d2VlbiBldmVudC1wb3dlcmVkIGNsYXNzZXMgKGxpa2UgYE1hcGAgYW5kIGBNYXJrZXJgKS4gR2VuZXJhbGx5LCBldmVudHMgYWxsb3cgeW91IHRvIGV4ZWN1dGUgc29tZSBmdW5jdGlvbiB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIHdpdGggYW4gb2JqZWN0IChlLmcuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwLCBjYXVzaW5nIHRoZSBtYXAgdG8gZmlyZSBgJ2NsaWNrJ2AgZXZlbnQpLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gKiBcdGFsZXJ0KGUubGF0bG5nKTtcclxuICogfSApO1xyXG4gKiBgYGBcclxuICpcclxuICogTGVhZmxldCBkZWFscyB3aXRoIGV2ZW50IGxpc3RlbmVycyBieSByZWZlcmVuY2UsIHNvIGlmIHlvdSB3YW50IHRvIGFkZCBhIGxpc3RlbmVyIGFuZCB0aGVuIHJlbW92ZSBpdCwgZGVmaW5lIGl0IGFzIGEgZnVuY3Rpb246XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGZ1bmN0aW9uIG9uQ2xpY2soZSkgeyAuLi4gfVxyXG4gKlxyXG4gKiBtYXAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIG1hcC5vZmYoJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRXZlbnRzID0ge1xyXG5cdC8qIEBtZXRob2Qgb24odHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBvZiB0aGUgb2JqZWN0LiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXIgKG9iamVjdCB0aGUgdGhpcyBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvbihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHQgKi9cclxuXHRvbjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG5cdFx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0LyogQG1ldGhvZCBvZmYodHlwZTogU3RyaW5nLCBmbj86IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBldmVudCBmcm9tIHRoZSBvYmplY3QuIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gYG9uYCwgeW91IG11c3QgcGFzcyB0aGUgc2FtZSBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycy5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgb24gdGhlIG9iamVjdC4gVGhpcyBpbmNsdWRlcyBpbXBsaWNpdGx5IGF0dGFjaGVkIGV2ZW50cy5cclxuXHQgKi9cclxuXHRvZmY6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAoIXR5cGVzKSB7XHJcblx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgaWYgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gYXR0YWNoIGxpc3RlbmVyICh3aXRob3V0IHN5bnRhY3RpYyBzdWdhciBub3cpXHJcblx0X29uOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcclxuXHJcblx0XHQvKiBnZXQvaW5pdCBsaXN0ZW5lcnMgZm9yIHR5cGUgKi9cclxuXHRcdHZhciB0eXBlTGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKCF0eXBlTGlzdGVuZXJzKSB7XHJcblx0XHRcdHR5cGVMaXN0ZW5lcnMgPSBbXTtcclxuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gdHlwZUxpc3RlbmVycztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHR2YXIgbmV3TGlzdGVuZXIgPSB7Zm46IGZuLCBjdHg6IGNvbnRleHR9LFxyXG5cdFx0ICAgIGxpc3RlbmVycyA9IHR5cGVMaXN0ZW5lcnM7XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgZm4gYWxyZWFkeSB0aGVyZVxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbiAmJiBsaXN0ZW5lcnNbaV0uY3R4ID09PSBjb250ZXh0KSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGlzdGVuZXJzLnB1c2gobmV3TGlzdGVuZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9vZmY6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyxcclxuXHRcdCAgICBpLFxyXG5cdFx0ICAgIGxlbjtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2V2ZW50cykgeyByZXR1cm47IH1cclxuXHJcblx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghZm4pIHtcclxuXHRcdFx0Ly8gU2V0IGFsbCByZW1vdmVkIGxpc3RlbmVycyB0byBub29wIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRsaXN0ZW5lcnNbaV0uZm4gPSBVdGlsLmZhbHNlRm47XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblxyXG5cdFx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0aWYgKGwuY3R4ICE9PSBjb250ZXh0KSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdFx0aWYgKGwuZm4gPT09IGZuKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRcdFx0bC5mbiA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuXHRcdFx0XHRcdFx0LyogY29weSBhcnJheSBpbiBjYXNlIGV2ZW50cyBhcmUgYmVpbmcgZmlyZWQgKi9cclxuXHRcdFx0XHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpcmUodHlwZTogU3RyaW5nLCBkYXRhPzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIEZpcmVzIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gWW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYW4gZGF0YVxyXG5cdC8vIG9iamVjdCDigJQgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiB3aWxsIGNvbnRhaW4gaXRzXHJcblx0Ly8gcHJvcGVydGllcy4gVGhlIGV2ZW50IGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQgdG8gZXZlbnQgcGFyZW50cy5cclxuXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGV2ZW50ID0gVXRpbC5leHRlbmQoe30sIGRhdGEsIHtcclxuXHRcdFx0dHlwZTogdHlwZSxcclxuXHRcdFx0dGFyZ2V0OiB0aGlzLFxyXG5cdFx0XHRzb3VyY2VUYXJnZXQ6IGRhdGEgJiYgZGF0YS5zb3VyY2VUYXJnZXQgfHwgdGhpc1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2V2ZW50cykge1xyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuXHRcdFx0aWYgKGxpc3RlbmVycykge1xyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50ID0gKHRoaXMuX2ZpcmluZ0NvdW50ICsgMSkgfHwgMTtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRcdGwuZm4uY2FsbChsLmN0eCB8fCB0aGlzLCBldmVudCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudC0tO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHBhcmVudHMgKHNldCB3aXRoIGFkZEV2ZW50UGFyZW50KVxyXG5cdFx0XHR0aGlzLl9wcm9wYWdhdGVFdmVudChldmVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBoYXMgYW55IGxpc3RlbmVycyBhdHRhY2hlZCB0byBpdC5cclxuXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLmxlbmd0aCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gYWxzbyBjaGVjayBwYXJlbnRzIGZvciBsaXN0ZW5lcnMgaWYgZXZlbnQgcHJvcGFnYXRlc1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb25jZSjigKYpOiB0aGlzXHJcblx0Ly8gQmVoYXZlcyBhcyBbYG9uKOKApilgXSgjZXZlbnRlZC1vbiksIGV4Y2VwdCB0aGUgbGlzdGVuZXIgd2lsbCBvbmx5IGdldCBmaXJlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXHJcblx0b25jZTogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLm9uY2UodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IFV0aWwuYmluZChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5vZmYodHlwZXMsIGZuLCBjb250ZXh0KVxyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHQvLyBhZGQgYSBsaXN0ZW5lciB0aGF0J3MgZXhlY3V0ZWQgb25jZSBhbmQgcmVtb3ZlZCBhZnRlciB0aGF0XHJcblx0XHRyZXR1cm4gdGhpc1xyXG5cdFx0ICAgIC5vbih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHQgICAgLm9uKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGV2ZW50IHBhcmVudCAtIGFuIGBFdmVudGVkYCB0aGF0IHdpbGwgcmVjZWl2ZSBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdGFkZEV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHMgPSB0aGlzLl9ldmVudFBhcmVudHMgfHwge307XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHNbVXRpbC5zdGFtcChvYmopXSA9IG9iajtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gZXZlbnQgcGFyZW50LCBzbyBpdCB3aWxsIHN0b3AgcmVjZWl2aW5nIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0cmVtb3ZlRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50UGFyZW50c1tVdGlsLnN0YW1wKG9iaildO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Byb3BhZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdHRoaXMuX2V2ZW50UGFyZW50c1tpZF0uZmlyZShlLnR5cGUsIFV0aWwuZXh0ZW5kKHtcclxuXHRcdFx0XHRsYXllcjogZS50YXJnZXQsXHJcblx0XHRcdFx0cHJvcGFnYXRlZEZyb206IGUudGFyZ2V0XHJcblx0XHRcdH0sIGUpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vLyBhbGlhc2VzOyB3ZSBzaG91bGQgZGl0Y2ggdGhvc2UgZXZlbnR1YWxseVxyXG5cclxuLy8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pXHJcbkV2ZW50cy5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uO1xyXG5cclxuLy8gQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYo4oCmKWBdKCNldmVudGVkLW9mZilcclxuXHJcbi8vIEBtZXRob2QgY2xlYXJBbGxFdmVudExpc3RlbmVycyjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKClgXSgjZXZlbnRlZC1vZmYpXHJcbkV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyID0gRXZlbnRzLmNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMub2ZmO1xyXG5cclxuLy8gQG1ldGhvZCBhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb25jZSjigKYpYF0oI2V2ZW50ZWQtb25jZSlcclxuRXZlbnRzLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uY2U7XHJcblxyXG4vLyBAbWV0aG9kIGZpcmVFdmVudCjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgZmlyZSjigKYpYF0oI2V2ZW50ZWQtZmlyZSlcclxuRXZlbnRzLmZpcmVFdmVudCA9IEV2ZW50cy5maXJlO1xyXG5cclxuLy8gQG1ldGhvZCBoYXNFdmVudExpc3RlbmVycyjigKYpOiBCb29sZWFuXHJcbi8vIEFsaWFzIHRvIFtgbGlzdGVucyjigKYpYF0oI2V2ZW50ZWQtbGlzdGVucylcclxuRXZlbnRzLmhhc0V2ZW50TGlzdGVuZXJzID0gRXZlbnRzLmxpc3RlbnM7XHJcblxyXG5leHBvcnQgdmFyIEV2ZW50ZWQgPSBDbGFzcy5leHRlbmQoRXZlbnRzKTtcclxuIiwiaW1wb3J0IHtpc0FycmF5LCBmb3JtYXROdW19IGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgUG9pbnRcclxuICogQGFrYSBMLlBvaW50XHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBwb2ludCB3aXRoIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGluIHBpeGVscy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvaW50ID0gTC5wb2ludCgyMDAsIDMwMCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIGFuZCBvcHRpb25zIHRoYXQgYWNjZXB0IGBQb2ludGAgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBganNcclxuICogbWFwLnBhbkJ5KFsyMDAsIDMwMF0pO1xyXG4gKiBtYXAucGFuQnkoTC5wb2ludCgyMDAsIDMwMCkpO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBQb2ludGAgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFBvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0Ly8gQHByb3BlcnR5IHg6IE51bWJlcjsgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG5cdHRoaXMueCA9IChyb3VuZCA/IE1hdGgucm91bmQoeCkgOiB4KTtcclxuXHQvLyBAcHJvcGVydHkgeTogTnVtYmVyOyBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy55ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh5KSA6IHkpO1xyXG59XHJcblxyXG52YXIgdHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uICh2KSB7XHJcblx0cmV0dXJuIHYgPiAwID8gTWF0aC5mbG9vcih2KSA6IE1hdGguY2VpbCh2KTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9uZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50LlxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGFkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBub24tZGVzdHJ1Y3RpdmUsIHJldHVybnMgYSBuZXcgcG9pbnRcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2FkZCh0b1BvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X2FkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XHJcblx0XHR0aGlzLnggKz0gcG9pbnQueDtcclxuXHRcdHRoaXMueSArPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzdWJ0cmFjdChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCBmcm9tIHRoZSBjdXJyZW50LlxyXG5cdHN1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3N1YnRyYWN0KHRvUG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfc3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dGhpcy54IC09IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgLT0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGl2aWRlQnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdGRpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9kaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54IC89IG51bTtcclxuXHRcdHRoaXMueSAvPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG11bHRpcGx5QnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfbXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54ICo9IG51bTtcclxuXHRcdHRoaXMueSAqPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBNdWx0aXBseSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgZWFjaCBjb29yZGluYXRlIG9mXHJcblx0Ly8gYHNjYWxlYC4gSW4gbGluZWFyIGFsZ2VicmEgdGVybXMsIG11bHRpcGx5IHRoZSBwb2ludCBieSB0aGVcclxuXHQvLyBbc2NhbGluZyBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjYWxpbmdfJTI4Z2VvbWV0cnklMjkjTWF0cml4X3JlcHJlc2VudGF0aW9uKVxyXG5cdC8vIGRlZmluZWQgYnkgYHNjYWxlYC5cclxuXHRzY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZUJ5YC4gRGl2aWRlIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieVxyXG5cdC8vIGVhY2ggY29vcmRpbmF0ZSBvZiBgc2NhbGVgLlxyXG5cdHVuc2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgcm91bmQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHJvdW5kZWQgY29vcmRpbmF0ZXMuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X3JvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZsb29yKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBmbG9vcmVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIGRvd24pLlxyXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9mbG9vcigpO1xyXG5cdH0sXHJcblxyXG5cdF9mbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjZWlsKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBjZWlsZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdXApLlxyXG5cdGNlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2NlaWwoKTtcclxuXHR9LFxyXG5cclxuXHRfY2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdHJ1bmMoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHRydW5jYXRlZCBjb29yZGluYXRlcyAocm91bmRlZCB0b3dhcmRzIHplcm8pLlxyXG5cdHRydW5jOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl90cnVuYygpO1xyXG5cdH0sXHJcblxyXG5cdF90cnVuYzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gdHJ1bmModGhpcy54KTtcclxuXHRcdHRoaXMueSA9IHRydW5jKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJQb2ludDogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjYXJ0ZXNpYW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy54LFxyXG5cdFx0ICAgIHkgPSBwb2ludC55IC0gdGhpcy55O1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBvaW50IGhhcyB0aGUgc2FtZSBjb29yZGluYXRlcy5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmXHJcblx0XHQgICAgICAgcG9pbnQueSA9PT0gdGhpcy55O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gcG9pbnQgYXJlIGxlc3MgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBjdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzIChpbiBhYnNvbHV0ZSB2YWx1ZXMpLlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiZcclxuXHRcdCAgICAgICBNYXRoLmFicyhwb2ludC55KSA8PSBNYXRoLmFicyh0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICdQb2ludCgnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueCkgKyAnLCAnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueSkgKyAnKSc7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQGZhY3RvcnkgTC5wb2ludCh4OiBOdW1iZXIsIHk6IE51bWJlciwgcm91bmQ/OiBCb29sZWFuKVxyXG4vLyBDcmVhdGVzIGEgUG9pbnQgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzLiBJZiBvcHRpb25hbCBgcm91bmRgIGlzIHNldCB0byB0cnVlLCByb3VuZHMgdGhlIGB4YCBhbmQgYHlgIHZhbHVlcy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogTnVtYmVyW10pXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5XWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogT2JqZWN0KVxyXG4vLyBFeHBlY3RzIGEgcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eDogTnVtYmVyLCB5OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Qb2ludCh4LCB5LCByb3VuZCkge1xyXG5cdGlmICh4IGluc3RhbmNlb2YgUG9pbnQpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAoaXNBcnJheSh4KSkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh4WzBdLCB4WzFdKTtcclxuXHR9XHJcblx0aWYgKHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAneCcgaW4geCAmJiAneScgaW4geCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh4LngsIHgueSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59XHJcbiIsImltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEJvdW5kc1xyXG4gKiBAYWthIEwuQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIGluIHBpeGVsIGNvb3JkaW5hdGVzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcDEgPSBMLnBvaW50KDEwLCAxMCksXHJcbiAqIHAyID0gTC5wb2ludCg0MCwgNjApLFxyXG4gKiBib3VuZHMgPSBMLmJvdW5kcyhwMSwgcDIpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBgQm91bmRzYCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogb3RoZXJCb3VuZHMuaW50ZXJzZWN0cyhbWzEwLCAxMF0sIFs0MCwgNjBdXSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYEJvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJvdW5kcyhhLCBiKSB7XHJcblx0aWYgKCFhKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKHBvaW50c1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5Cb3VuZHMucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuXHQvLyBFeHRlbmRzIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbWluOiBQb2ludFxyXG5cdFx0Ly8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuXHRcdC8vIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHRpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xyXG5cdFx0XHR0aGlzLm1pbiA9IHBvaW50LmNsb25lKCk7XHJcblx0XHRcdHRoaXMubWF4ID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMubWluLnggPSBNYXRoLm1pbihwb2ludC54LCB0aGlzLm1pbi54KTtcclxuXHRcdFx0dGhpcy5tYXgueCA9IE1hdGgubWF4KHBvaW50LngsIHRoaXMubWF4LngpO1xyXG5cdFx0XHR0aGlzLm1pbi55ID0gTWF0aC5taW4ocG9pbnQueSwgdGhpcy5taW4ueSk7XHJcblx0XHRcdHRoaXMubWF4LnkgPSBNYXRoLm1heChwb2ludC55LCB0aGlzLm1heC55KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKHJvdW5kPzogQm9vbGVhbik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi54ICsgdGhpcy5tYXgueCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueSArIHRoaXMubWF4LnkpIC8gMiwgcm91bmQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tTGVmdCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGJvdHRvbS1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Qm90dG9tTGVmdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLm1pbi54LCB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFRvcFJpZ2h0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0VG9wUmlnaHQ6IGZ1bmN0aW9uICgpIHsgLy8gLT4gUG9pbnRcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BMZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWluYF0oI2JvdW5kcy1taW4pKS5cclxuXHRnZXRUb3BMZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5taW47IC8vIGxlZnQsIHRvcFxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWF4YF0oI2JvdW5kcy1tYXgpKS5cclxuXHRnZXRCb3R0b21SaWdodDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4OyAvLyByaWdodCwgYm90dG9tXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIFBvaW50KSB7XHJcblx0XHRcdG9iaiA9IHRvUG9pbnQob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0XHRtaW4gPSBvYmoubWluO1xyXG5cdFx0XHRtYXggPSBvYmoubWF4O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWluID0gbWF4ID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuXHRcdCAgICAgICAobWF4LnggPD0gdGhpcy5tYXgueCkgJiZcclxuXHRcdCAgICAgICAobWluLnkgPj0gdGhpcy5taW4ueSkgJiZcclxuXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4SW50ZXJzZWN0cyA9IChtYXgyLnggPj0gbWluLngpICYmIChtaW4yLnggPD0gbWF4LngpLFxyXG5cdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhPdmVybGFwcyA9IChtYXgyLnggPiBtaW4ueCkgJiYgKG1pbjIueCA8IG1heC54KSxcclxuXHRcdCAgICB5T3ZlcmxhcHMgPSAobWF4Mi55ID4gbWluLnkpICYmIChtaW4yLnkgPCBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhPdmVybGFwcyAmJiB5T3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMubWluICYmIHRoaXMubWF4KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5ib3VuZHMoY29ybmVyMTogUG9pbnQsIGNvcm5lcjI6IFBvaW50KVxyXG4vLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHR3byBjb3JuZXJzIGNvb3JkaW5hdGUgcGFpcnMuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhwb2ludHM6IFBvaW50W10pXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5IG9mIHBvaW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgQm91bmRzKGEsIGIpO1xyXG59XHJcbiIsImltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi9MYXRMbmcnO1xyXG5cclxuLypcclxuICogQGNsYXNzIExhdExuZ0JvdW5kc1xyXG4gKiBAYWthIEwuTGF0TG5nQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBnZW9ncmFwaGljYWwgYXJlYSBvbiBhIG1hcC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGNvcm5lcjEgPSBMLmxhdExuZyg0MC43MTIsIC03NC4yMjcpLFxyXG4gKiBjb3JuZXIyID0gTC5sYXRMbmcoNDAuNzc0LCAtNzQuMTI1KSxcclxuICogYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZ0JvdW5kcyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogbWFwLmZpdEJvdW5kcyhbXHJcbiAqIFx0WzQwLjcxMiwgLTc0LjIyN10sXHJcbiAqIFx0WzQwLjc3NCwgLTc0LjEyNV1cclxuICogXSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBDYXV0aW9uOiBpZiB0aGUgYXJlYSBjcm9zc2VzIHRoZSBhbnRpbWVyaWRpYW4gKG9mdGVuIGNvbmZ1c2VkIHdpdGggdGhlIEludGVybmF0aW9uYWwgRGF0ZSBMaW5lKSwgeW91IG11c3Qgc3BlY2lmeSBjb3JuZXJzIF9vdXRzaWRlXyB0aGUgWy0xODAsIDE4MF0gZGVncmVlcyBsb25naXR1ZGUgcmFuZ2UuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgTGF0TG5nQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcblx0aWYgKCFjb3JuZXIxKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgbGF0bG5ncyA9IGNvcm5lcjIgPyBbY29ybmVyMSwgY29ybmVyMl0gOiBjb3JuZXIxO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5MYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGV4dGVuZChsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuXHRcdFx0c3cyID0gb2JqO1xyXG5cdFx0XHRuZTIgPSBvYmo7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLl9zb3V0aFdlc3Q7XHJcblx0XHRcdG5lMiA9IG9iai5fbm9ydGhFYXN0O1xyXG5cclxuXHRcdFx0aWYgKCFzdzIgfHwgIW5lMikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBvYmogPyB0aGlzLmV4dGVuZCh0b0xhdExuZyhvYmopIHx8IHRvTGF0TG5nQm91bmRzKG9iaikpIDogdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXN3ICYmICFuZSkge1xyXG5cdFx0XHR0aGlzLl9zb3V0aFdlc3QgPSBuZXcgTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xyXG5cdFx0XHR0aGlzLl9ub3J0aEVhc3QgPSBuZXcgTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcclxuXHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcclxuXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuXHRcdFx0bmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcblx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcoc3cubGF0IC0gaGVpZ2h0QnVmZmVyLCBzdy5sbmcgLSB3aWR0aEJ1ZmZlciksXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubGF0ICsgdGhpcy5fbm9ydGhFYXN0LmxhdCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxuZyArIHRoaXMuX25vcnRoRWFzdC5sbmcpIC8gMik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB3ZXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0V2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0U291dGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWFzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBlYXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMgKGxhdGxuZzogTGF0TG5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMYXRMbmcgfHwgJ2xhdCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0xhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcblx0XHQgICAgbG5nSW50ZXJzZWN0cyA9IChuZTIubG5nID49IHN3LmxuZykgJiYgKHN3Mi5sbmcgPD0gbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0SW50ZXJzZWN0cyAmJiBsbmdJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ092ZXJsYXBzID0gKG5lMi5sbmcgPiBzdy5sbmcpICYmIChzdzIubG5nIDwgbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0T3ZlcmxhcHMgJiYgbG5nT3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JCb3hTdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyB3aXRoIGJvdW5kaW5nIGJveCBjb29yZGluYXRlcyBpbiBhICdzb3V0aHdlc3RfbG5nLHNvdXRod2VzdF9sYXQsbm9ydGhlYXN0X2xuZyxub3J0aGVhc3RfbGF0JyBmb3JtYXQuIFVzZWZ1bCBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byB3ZWIgc2VydmljZXMgdGhhdCByZXR1cm4gZ2VvIGRhdGEuXHJcblx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpcyBlcXVpdmFsZW50ICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpIHRvIHRoZSBnaXZlbiBib3VuZHMuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMsIG1heE1hcmdpbikge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCksIG1heE1hcmdpbikgJiZcclxuXHRcdCAgICAgICB0aGlzLl9ub3J0aEVhc3QuZXF1YWxzKGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgbWF4TWFyZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzVmFsaWQoKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLl9zb3V0aFdlc3QgJiYgdGhpcy5fbm9ydGhFYXN0KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBUT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMoY29ybmVyMTogTGF0TG5nLCBjb3JuZXIyOiBMYXRMbmcpXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgYnkgZGVmaW5pbmcgdHdvIGRpYWdvbmFsbHkgb3Bwb3NpdGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGxhdGxuZ3M6IExhdExuZ1tdKVxyXG4vLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGRlZmluZWQgYnkgdGhlIGdlb2dyYXBoaWNhbCBwb2ludHMgaXQgY29udGFpbnMuIFZlcnkgdXNlZnVsIGZvciB6b29taW5nIHRoZSBtYXAgdG8gZml0IGEgcGFydGljdWxhciBzZXQgb2YgbG9jYXRpb25zIHdpdGggW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0xhdExuZ0JvdW5kcyhhLCBiKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhhLCBiKTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7RWFydGh9IGZyb20gJy4vY3JzL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4vTGF0TG5nQm91bmRzJztcclxuXHJcbi8qIEBjbGFzcyBMYXRMbmdcclxuICogQGFrYSBMLkxhdExuZ1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggYSBjZXJ0YWluIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiB2YXIgbGF0bG5nID0gTC5sYXRMbmcoNTAuNSwgMzAuNSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSBhbmQgc2ltcGxlIG9iamVjdCBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBtYXAucGFuVG8oWzUwLCAzMF0pO1xyXG4gKiBtYXAucGFuVG8oe2xvbjogMzAsIGxhdDogNTB9KTtcclxuICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAqIG1hcC5wYW5UbyhMLmxhdExuZyg1MCwgMzApKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgTGF0TG5nYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZywgYWx0KSB7XHJcblx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XHJcblx0fVxyXG5cclxuXHQvLyBAcHJvcGVydHkgbGF0OiBOdW1iZXJcclxuXHQvLyBMYXRpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuXHQvLyBAcHJvcGVydHkgbG5nOiBOdW1iZXJcclxuXHQvLyBMb25naXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubG5nID0gK2xuZztcclxuXHJcblx0Ly8gQHByb3BlcnR5IGFsdDogTnVtYmVyXHJcblx0Ly8gQWx0aXR1ZGUgaW4gbWV0ZXJzIChvcHRpb25hbClcclxuXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuYWx0ID0gK2FsdDtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJMYXRMbmc6IExhdExuZywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKG9iaiwgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cclxuXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG5cdFx0cmV0dXJuIG1hcmdpbiA8PSAobWF4TWFyZ2luID09PSB1bmRlZmluZWQgPyAxLjBFLTkgOiBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyTGF0TG5nOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSB0byB0aGUgZ2l2ZW4gYExhdExuZ2AgY2FsY3VsYXRlZCB1c2luZyB0aGUgW1NwaGVyaWNhbCBMYXcgb2YgQ29zaW5lc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2xhd19vZl9jb3NpbmVzKS5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuXHRcdHJldHVybiBFYXJ0aC5kaXN0YW5jZSh0aGlzLCB0b0xhdExuZyhvdGhlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdgIG9iamVjdCB3aXRoIHRoZSBsb25naXR1ZGUgd3JhcHBlZCBzbyBpdCdzIGFsd2F5cyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gRWFydGgud3JhcExhdExuZyh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQm91bmRzKHNpemVJbk1ldGVyczogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nQm91bmRzYCBvYmplY3QgaW4gd2hpY2ggZWFjaCBib3VuZGFyeSBpcyBgc2l6ZUluTWV0ZXJzLzJgIG1ldGVycyBhcGFydCBmcm9tIHRoZSBgTGF0TG5nYC5cclxuXHR0b0JvdW5kczogZnVuY3Rpb24gKHNpemVJbk1ldGVycykge1xyXG5cdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcblx0XHQgICAgbG5nQWNjdXJhY3kgPSBsYXRBY2N1cmFjeSAvIE1hdGguY29zKChNYXRoLlBJIC8gMTgwKSAqIHRoaXMubGF0KTtcclxuXHJcblx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuXHRcdCAgICAgICAgW3RoaXMubGF0ICsgbGF0QWNjdXJhY3ksIHRoaXMubG5nICsgbG5nQWNjdXJhY3ldKTtcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5sYXQsIHRoaXMubG5nLCB0aGlzLmFsdCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhsYXRpdHVkZTogTnVtYmVyLCBsb25naXR1ZGU6IE51bWJlciwgYWx0aXR1ZGU/OiBOdW1iZXIpOiBMYXRMbmdcclxuLy8gQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggdGhlIGdpdmVuIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKGFuZCBvcHRpb25hbGx5IGFsdGl0dWRlKS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFtOdW1iZXIsIE51bWJlcl1gIG9yIGBbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl1gIGluc3RlYWQuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBPYmplY3QpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXJ9YCBvciBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlciwgYWx0OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTGF0TG5nKGEsIGIsIGMpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmIChVdGlsLmlzQXJyYXkoYSkgJiYgdHlwZW9mIGFbMF0gIT09ICdvYmplY3QnKSB7XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDMpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhhLmxhdCwgJ2xuZycgaW4gYSA/IGEubG5nIDogYS5sb24sIGEuYWx0KTtcclxuXHR9XHJcblx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nKGEsIGIsIGMpO1xyXG59XHJcbiIsIlxyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkJhc2VcclxuICogT2JqZWN0IHRoYXQgZGVmaW5lcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGZvciBwcm9qZWN0aW5nXHJcbiAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAqIFtzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29vcmRpbmF0ZV9yZWZlcmVuY2Vfc3lzdGVtKS5cclxuICpcclxuICogTGVhZmxldCBkZWZpbmVzIHRoZSBtb3N0IHVzdWFsIENSU3MgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG8gdXNlIGFcclxuICogQ1JTIG5vdCBkZWZpbmVkIGJ5IGRlZmF1bHQsIHRha2UgYSBsb29rIGF0IHRoZVxyXG4gKiBbUHJvajRMZWFmbGV0XShodHRwczovL2dpdGh1Yi5jb20va2FydGVuYS9Qcm9qNExlYWZsZXQpIHBsdWdpbi5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSBDUlMgaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxyXG4gKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIENSUyA9IHtcclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvUG9pbnQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuXHRsYXRMbmdUb1BvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHByb2plY3RlZFBvaW50LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYGxhdExuZ1RvUG9pbnRgLiBQcm9qZWN0cyBwaXhlbCBjb29yZGluYXRlcyBvbiBhIGdpdmVuXHJcblx0Ly8gem9vbSBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuXHQvLyB0aGlzIENSUyAoZS5nLiBtZXRlcnMgZm9yIEVQU0c6Mzg1NywgZm9yIHBhc3NpbmcgaXQgdG8gV01TIHNlcnZpY2VzKS5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG5cdC8vIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGUoem9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIHBhcnRpY3VsYXIgem9vbS4gRm9yIGV4YW1wbGUsIGl0IHJldHVybnNcclxuXHQvLyBgMjU2ICogMl56b29tYCBmb3IgTWVyY2F0b3ItYmFzZWQgQ1JTLlxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIDI1NiAqIE1hdGgucG93KDIsIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGUoKWAsIHJldHVybnMgdGhlIHpvb20gbGV2ZWwgY29ycmVzcG9uZGluZyB0byBhIHNjYWxlXHJcblx0Ly8gZmFjdG9yIG9mIGBzY2FsZWAuXHJcblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUgLyAyNTYpIC8gTWF0aC5MTjI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGlvbidzIGJvdW5kcyBzY2FsZWQgYW5kIHRyYW5zZm9ybWVkIGZvciB0aGUgcHJvdmlkZWQgYHpvb21gLlxyXG5cdGdldFByb2plY3RlZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG5cdFx0dmFyIGIgPSB0aGlzLnByb2plY3Rpb24uYm91bmRzLFxyXG5cdFx0ICAgIHMgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1heCwgcyk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMobWluLCBtYXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuXHQvLyBTdGFuZGFyZCBjb2RlIG5hbWUgb2YgdGhlIENSUyBwYXNzZWQgaW50byBXTVMgc2VydmljZXMgKGUuZy4gYCdFUFNHOjM4NTcnYClcclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG5cdC8vIEFuIGFycmF5IG9mIHR3byBudW1iZXJzIGRlZmluaW5nIHdoZXRoZXIgdGhlIGxvbmdpdHVkZSAoaG9yaXpvbnRhbCkgY29vcmRpbmF0ZVxyXG5cdC8vIGF4aXMgd3JhcHMgYXJvdW5kIGEgZ2l2ZW4gcmFuZ2UgYW5kIGhvdy4gRGVmYXVsdHMgdG8gYFstMTgwLCAxODBdYCBpbiBtb3N0XHJcblx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExhdDogTnVtYmVyW11cclxuXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxyXG5cclxuXHQvLyB3cmFwTG5nOiBbbWluLCBtYXhdLFxyXG5cdC8vIHdyYXBMYXQ6IFttaW4sIG1heF0sXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhblxyXG5cdC8vIElmIHRydWUsIHRoZSBjb29yZGluYXRlIHNwYWNlIHdpbGwgYmUgdW5ib3VuZGVkIChpbmZpbml0ZSBpbiBib3RoIGF4ZXMpXHJcblx0aW5maW5pdGU6IGZhbHNlLFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgbGF0IGFuZCBsbmcgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBsbmcgPSB0aGlzLndyYXBMbmcgPyBVdGlsLndyYXBOdW0obGF0bG5nLmxuZywgdGhpcy53cmFwTG5nLCB0cnVlKSA6IGxhdGxuZy5sbmcsXHJcblx0XHQgICAgbGF0ID0gdGhpcy53cmFwTGF0ID8gVXRpbC53cmFwTnVtKGxhdGxuZy5sYXQsIHRoaXMud3JhcExhdCwgdHJ1ZSkgOiBsYXRsbmcubGF0LFxyXG5cdFx0ICAgIGFsdCA9IGxhdGxuZy5hbHQ7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcobGF0LCBsbmcsIGFsdCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZ1xyXG5cdC8vIHRoYXQgaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ0JvdW5kc2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHZhciBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy53cmFwTGF0TG5nKGNlbnRlciksXHJcblx0XHQgICAgbGF0U2hpZnQgPSBjZW50ZXIubGF0IC0gbmV3Q2VudGVyLmxhdCxcclxuXHRcdCAgICBsbmdTaGlmdCA9IGNlbnRlci5sbmcgLSBuZXdDZW50ZXIubG5nO1xyXG5cclxuXHRcdGlmIChsYXRTaGlmdCA9PT0gMCAmJiBsbmdTaGlmdCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZSA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHRcdCAgICBuZXdTdyA9IG5ldyBMYXRMbmcoc3cubGF0IC0gbGF0U2hpZnQsIHN3LmxuZyAtIGxuZ1NoaWZ0KSxcclxuXHRcdCAgICBuZXdOZSA9IG5ldyBMYXRMbmcobmUubGF0IC0gbGF0U2hpZnQsIG5lLmxuZyAtIGxuZ1NoaWZ0KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhuZXdTdywgbmV3TmUpO1xyXG5cdH1cclxufTtcclxuIiwiaW1wb3J0IHtDUlN9IGZyb20gJy4vQ1JTJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLkVhcnRoXG4gKlxuICogU2VydmVzIGFzIHRoZSBiYXNlIGZvciBDUlMgdGhhdCBhcmUgZ2xvYmFsIHN1Y2ggdGhhdCB0aGV5IGNvdmVyIHRoZSBlYXJ0aC5cbiAqIENhbiBvbmx5IGJlIHVzZWQgYXMgdGhlIGJhc2UgZm9yIG90aGVyIENSUyBhbmQgY2Fubm90IGJlIHVzZWQgZGlyZWN0bHksXG4gKiBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlIGEgYGNvZGVgLCBgcHJvamVjdGlvbmAgb3IgYHRyYW5zZm9ybWF0aW9uYC4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAqIG1ldGVycy5cbiAqL1xuXG5leHBvcnQgdmFyIEVhcnRoID0gVXRpbC5leHRlbmQoe30sIENSUywge1xuXHR3cmFwTG5nOiBbLTE4MCwgMTgwXSxcblxuXHQvLyBNZWFuIEVhcnRoIFJhZGl1cywgYXMgcmVjb21tZW5kZWQgZm9yIHVzZSBieVxuXHQvLyB0aGUgSW50ZXJuYXRpb25hbCBVbmlvbiBvZiBHZW9kZXN5IGFuZCBHZW9waHlzaWNzLFxuXHQvLyBzZWUgaHR0cDovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG5cdFI6IDYzNzEwMDAsXG5cblx0Ly8gZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIHBvaW50cyB1c2luZyBzcGhlcmljYWwgbGF3IG9mIGNvc2luZXMgYXBwcm94aW1hdGlvblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgcmFkID0gTWF0aC5QSSAvIDE4MCxcblx0XHQgICAgbGF0MSA9IGxhdGxuZzEubGF0ICogcmFkLFxuXHRcdCAgICBsYXQyID0gbGF0bG5nMi5sYXQgKiByYWQsXG5cdFx0ICAgIHNpbkRMYXQgPSBNYXRoLnNpbigobGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdCkgKiByYWQgLyAyKSxcblx0XHQgICAgc2luRExvbiA9IE1hdGguc2luKChsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nKSAqIHJhZCAvIDIpLFxuXHRcdCAgICBhID0gc2luRExhdCAqIHNpbkRMYXQgKyBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogc2luRExvbiAqIHNpbkRMb24sXG5cdFx0ICAgIGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuXHRcdHJldHVybiB0aGlzLlIgKiBjO1xuXHR9XG59KTtcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gKlxyXG4gKiBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gZm9yIG9ubGluZSBtYXBzLFxyXG4gKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAqIGEgc3BoZXJlLiBVc2VkIGJ5IHRoZSBgRVBTRzozODU3YCBDUlMuXHJcbiAqL1xyXG5cclxudmFyIGVhcnRoUmFkaXVzID0gNjM3ODEzNztcclxuXHJcbmV4cG9ydCB2YXIgU3BoZXJpY2FsTWVyY2F0b3IgPSB7XHJcblxyXG5cdFI6IGVhcnRoUmFkaXVzLFxyXG5cdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG5cdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG5cdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHRcdHRoaXMuUiAqIGxhdGxuZy5sbmcgKiBkLFxyXG5cdFx0XHR0aGlzLlIgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gMik7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuXHRcdFx0KDIgKiBNYXRoLmF0YW4oTWF0aC5leHAocG9pbnQueSAvIHRoaXMuUikpIC0gKE1hdGguUEkgLyAyKSkgKiBkLFxyXG5cdFx0XHRwb2ludC54ICogZCAvIHRoaXMuUik7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGQgPSBlYXJ0aFJhZGl1cyAqIE1hdGguUEk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhbLWQsIC1kXSwgW2QsIGRdKTtcclxuXHR9KSgpXHJcbn07XHJcbiIsImltcG9ydCB7UG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICogQGFrYSBMLlRyYW5zZm9ybWF0aW9uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAqIGZvciB0cmFuc2Zvcm1pbmcgYSBwb2ludCBvZiBhIGZvcm0gYCh4LCB5KWAgaW50byBgKGEqeCArIGIsIGMqeSArIGQpYCBhbmQgZG9pbmdcclxuICogdGhlIHJldmVyc2UuIFVzZWQgYnkgTGVhZmxldCBpbiBpdHMgcHJvamVjdGlvbnMgY29kZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHRyYW5zZm9ybWF0aW9uID0gTC50cmFuc2Zvcm1hdGlvbigyLCA1LCAtMSwgMTApLFxyXG4gKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gKiBcdHAzID0gdHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocDIpOyAvLyAgTC5wb2ludCgxLCAyKVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gZmFjdG9yeSBuZXcgTC5UcmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0aWYgKFV0aWwuaXNBcnJheShhKSkge1xyXG5cdFx0Ly8gdXNlIGFycmF5IHByb3BlcnRpZXNcclxuXHRcdHRoaXMuX2EgPSBhWzBdO1xyXG5cdFx0dGhpcy5fYiA9IGFbMV07XHJcblx0XHR0aGlzLl9jID0gYVsyXTtcclxuXHRcdHRoaXMuX2QgPSBhWzNdO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHR0aGlzLl9hID0gYTtcclxuXHR0aGlzLl9iID0gYjtcclxuXHR0aGlzLl9jID0gYztcclxuXHR0aGlzLl9kID0gZDtcclxufVxyXG5cclxuVHJhbnNmb3JtYXRpb24ucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgdHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSB0cmFuc2Zvcm1lZCBwb2ludCwgb3B0aW9uYWxseSBtdWx0aXBsaWVkIGJ5IHRoZSBnaXZlbiBzY2FsZS5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcblx0X3RyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcblx0XHRwb2ludC55ID0gc2NhbGUgKiAodGhpcy5fYyAqIHBvaW50LnkgKyB0aGlzLl9kKTtcclxuXHRcdHJldHVybiBwb2ludDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVudHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR1bnRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdCAgICAgICAgKHBvaW50LnggLyBzY2FsZSAtIHRoaXMuX2IpIC8gdGhpcy5fYSxcclxuXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBUcmFuc2Zvcm1hdGlvbiBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oY29lZmZpY2llbnRzOiBBcnJheSk6IFRyYW5zZm9ybWF0aW9uXHJcbi8vIEV4cGVjdHMgYW4gY29lZmZpY2llbnRzIGFycmF5IG9mIHRoZSBmb3JtXHJcbi8vIGBbYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyXWAuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9UcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0cmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKTtcclxufVxyXG4iLCJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7U3BoZXJpY2FsTWVyY2F0b3J9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvcic7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czODU3XHJcbiAqXHJcbiAqIFRoZSBtb3N0IGNvbW1vbiBDUlMgZm9yIG9ubGluZSBtYXBzLCB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbFxyXG4gKiB0aWxlIHByb3ZpZGVycy4gVXNlcyBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi4gU2V0IGluIGJ5IGRlZmF1bHQgaW5cclxuICogTWFwJ3MgYGNyc2Agb3B0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRVBTRzM4NTcgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozODU3JyxcclxuXHRwcm9qZWN0aW9uOiBTcGhlcmljYWxNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIFNwaGVyaWNhbE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcblxyXG5leHBvcnQgdmFyIEVQU0c5MDA5MTMgPSBVdGlsLmV4dGVuZCh7fSwgRVBTRzM4NTcsIHtcclxuXHRjb2RlOiAnRVBTRzo5MDA5MTMnXHJcbn0pO1xyXG4iLCJpbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8vIEBuYW1lc3BhY2UgU1ZHOyBAc2VjdGlvblxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLlNWRzpcblxuLy8gQGZ1bmN0aW9uIGNyZWF0ZShuYW1lOiBTdHJpbmcpOiBTVkdFbGVtZW50XG4vLyBSZXR1cm5zIGEgaW5zdGFuY2Ugb2YgW1NWR0VsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KSxcbi8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWUgcGFzc2VkLiBGb3IgZXhhbXBsZSwgdXNpbmcgJ2xpbmUnIHdpbGwgcmV0dXJuXG4vLyBhbiBpbnN0YW5jZSBvZiBbU1ZHTGluZUVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdMaW5lRWxlbWVudCkuXG5leHBvcnQgZnVuY3Rpb24gc3ZnQ3JlYXRlKG5hbWUpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbn1cblxuLy8gQGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5nczogUG9pbnRbXSwgY2xvc2VkOiBCb29sZWFuKTogU3RyaW5nXG4vLyBHZW5lcmF0ZXMgYSBTVkcgcGF0aCBzdHJpbmcgZm9yIG11bHRpcGxlIHJpbmdzLCB3aXRoIGVhY2ggcmluZyB0dXJuaW5nXG4vLyBpbnRvIFwiTS4uTC4uTC4uXCIgaW5zdHJ1Y3Rpb25zXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzLCBjbG9zZWQpIHtcblx0dmFyIHN0ciA9ICcnLFxuXHRpLCBqLCBsZW4sIGxlbjIsIHBvaW50cywgcDtcblxuXHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHBvaW50cyA9IHJpbmdzW2ldO1xuXG5cdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdHAgPSBwb2ludHNbal07XG5cdFx0XHRzdHIgKz0gKGogPyAnTCcgOiAnTScpICsgcC54ICsgJyAnICsgcC55O1xuXHRcdH1cblxuXHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcblx0XHRzdHIgKz0gY2xvc2VkID8gKEJyb3dzZXIuc3ZnID8gJ3onIDogJ3gnKSA6ICcnO1xuXHR9XG5cblx0Ly8gU1ZHIGNvbXBsYWlucyBhYm91dCBlbXB0eSBwYXRoIHN0cmluZ3Ncblx0cmV0dXJuIHN0ciB8fCAnTTAgMCc7XG59XG5cblxuXG5cbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuaW1wb3J0IHtzdmdDcmVhdGV9IGZyb20gJy4uL2xheWVyL3ZlY3Rvci9TVkcuVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIEJyb3dzZXJcclxuICogQGFrYSBMLkJyb3dzZXJcclxuICpcclxuICogQSBuYW1lc3BhY2Ugd2l0aCBzdGF0aWMgcHJvcGVydGllcyBmb3IgYnJvd3Nlci9mZWF0dXJlIGRldGVjdGlvbiB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogaWYgKEwuQnJvd3Nlci5pZWx0OSkge1xyXG4gKiAgIGFsZXJ0KCdVcGdyYWRlIHlvdXIgYnJvd3NlciwgZHVkZSEnKTtcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgaWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIChub3QgRWRnZSkuXHJcbmV4cG9ydCB2YXIgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93O1xyXG5cclxuLy8gQHByb3BlcnR5IGllbHQ5OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIGxlc3MgdGhhbiA5LlxyXG5leHBvcnQgdmFyIGllbHQ5ID0gaWUgJiYgIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI7XHJcblxyXG4vLyBAcHJvcGVydHkgZWRnZTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgRWRnZSB3ZWIgYnJvd3Nlci5cclxuZXhwb3J0IHZhciBlZGdlID0gJ21zTGF1bmNoVXJpJyBpbiBuYXZpZ2F0b3IgJiYgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCk7XHJcblxyXG4vLyBAcHJvcGVydHkgd2Via2l0OiBCb29sZWFuO1xyXG4vLyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBsaWtlIENocm9tZSBhbmQgU2FmYXJpIChpbmNsdWRpbmcgbW9iaWxlIHZlcnNpb25zKS5cclxuZXhwb3J0IHZhciB3ZWJraXQgPSB1c2VyQWdlbnRDb250YWlucygnd2Via2l0Jyk7XHJcblxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFueSBicm93c2VyIHJ1bm5pbmcgb24gYW4gQW5kcm9pZCBwbGF0Zm9ybS5cclxuZXhwb3J0IHZhciBhbmRyb2lkID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkMjM6IEJvb2xlYW47IGB0cnVlYCBmb3IgYnJvd3NlcnMgcnVubmluZyBvbiBBbmRyb2lkIDIgb3IgQW5kcm9pZCAzLlxyXG5leHBvcnQgdmFyIGFuZHJvaWQyMyA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDInKSB8fCB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAzJyk7XHJcblxyXG4vKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3OTYxMjY2IGZvciBkZXRhaWxzIG9uIGRldGVjdGluZyBzdG9jayBBbmRyb2lkICovXHJcbnZhciB3ZWJraXRWZXIgPSBwYXJzZUludCgvV2ViS2l0XFwvKFswLTldKyl8JC8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVsxXSwgMTApOyAvLyBhbHNvIG1hdGNoZXMgQXBwbGVXZWJLaXRcclxuLy8gQHByb3BlcnR5IGFuZHJvaWRTdG9jazogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgQW5kcm9pZCBzdG9jayBicm93c2VyIChpLmUuIG5vdCBDaHJvbWUpXHJcbmV4cG9ydCB2YXIgYW5kcm9pZFN0b2NrID0gYW5kcm9pZCAmJiB1c2VyQWdlbnRDb250YWlucygnR29vZ2xlJykgJiYgd2Via2l0VmVyIDwgNTM3ICYmICEoJ0F1ZGlvTm9kZScgaW4gd2luZG93KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBvcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlclxyXG5leHBvcnQgdmFyIG9wZXJhID0gISF3aW5kb3cub3BlcmE7XHJcblxyXG4vLyBAcHJvcGVydHkgY2hyb21lOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBDaHJvbWUgYnJvd3Nlci5cclxuZXhwb3J0IHZhciBjaHJvbWUgPSB1c2VyQWdlbnRDb250YWlucygnY2hyb21lJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja286IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxyXG5leHBvcnQgdmFyIGdlY2tvID0gdXNlckFnZW50Q29udGFpbnMoJ2dlY2tvJykgJiYgIXdlYmtpdCAmJiAhb3BlcmEgJiYgIWllO1xyXG5cclxuLy8gQHByb3BlcnR5IHNhZmFyaTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgU2FmYXJpIGJyb3dzZXIuXHJcbmV4cG9ydCB2YXIgc2FmYXJpID0gIWNocm9tZSAmJiB1c2VyQWdlbnRDb250YWlucygnc2FmYXJpJyk7XHJcblxyXG5leHBvcnQgdmFyIHBoYW50b20gPSB1c2VyQWdlbnRDb250YWlucygncGhhbnRvbScpO1xyXG5cclxuLy8gQHByb3BlcnR5IG9wZXJhMTI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zICh2ZXJzaW9uIDEyIG9yIGxhdGVyKS5cclxuZXhwb3J0IHZhciBvcGVyYTEyID0gJ09UcmFuc2l0aW9uJyBpbiBzdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3aW46IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBXaW5kb3dzIHBsYXRmb3JtXHJcbmV4cG9ydCB2YXIgd2luID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ1dpbicpID09PSAwO1xyXG5cclxuLy8gQHByb3BlcnR5IGllM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgaWUzZCA9IGllICYmICgndHJhbnNpdGlvbicgaW4gc3R5bGUpO1xyXG5cclxuLy8gQHByb3BlcnR5IHdlYmtpdDNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgdmFyIHdlYmtpdDNkID0gKCdXZWJLaXRDU1NNYXRyaXgnIGluIHdpbmRvdykgJiYgKCdtMTEnIGluIG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KCkpICYmICFhbmRyb2lkMjM7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja28zZDogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgdmFyIGdlY2tvM2QgPSAnTW96UGVyc3BlY3RpdmUnIGluIHN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IGFueTNkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgYW55M2QgPSAhd2luZG93LkxfRElTQUJMRV8zRCAmJiAoaWUzZCB8fCB3ZWJraXQzZCB8fCBnZWNrbzNkKSAmJiAhb3BlcmExMiAmJiAhcGhhbnRvbTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZSA9IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgfHwgdXNlckFnZW50Q29udGFpbnMoJ21vYmlsZScpO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZS5cclxuZXhwb3J0IHZhciBtb2JpbGVXZWJraXQgPSBtb2JpbGUgJiYgd2Via2l0O1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDNkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2Ugc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciBtb2JpbGVXZWJraXQzZCA9IG1vYmlsZSAmJiB3ZWJraXQzZDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtc1BvaW50ZXI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyBpbXBsZW1lbnRpbmcgdGhlIE1pY3Jvc29mdCB0b3VjaCBldmVudHMgbW9kZWwgKG5vdGFibHkgSUUxMCkuXHJcbmV4cG9ydCB2YXIgbXNQb2ludGVyID0gIXdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgd2luZG93Lk1TUG9pbnRlckV2ZW50O1xyXG5cclxuLy8gQHByb3BlcnR5IHBvaW50ZXI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbcG9pbnRlciBldmVudHNdKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDQlMjh2PXZzLjg1JTI5LmFzcHgpLlxyXG5leHBvcnQgdmFyIHBvaW50ZXIgPSAhd2Via2l0ICYmICEhKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgbXNQb2ludGVyKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB0b3VjaDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG4vLyBUaGlzIGRvZXMgbm90IG5lY2Vzc2FyaWx5IG1lYW4gdGhhdCB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgY29tcHV0ZXIgd2l0aFxyXG4vLyBhIHRvdWNoc2NyZWVuLCBpdCBvbmx5IG1lYW5zIHRoYXQgdGhlIGJyb3dzZXIgaXMgY2FwYWJsZSBvZiB1bmRlcnN0YW5kaW5nXHJcbi8vIHRvdWNoIGV2ZW50cy5cclxuZXhwb3J0IHZhciB0b3VjaCA9ICF3aW5kb3cuTF9OT19UT1VDSCAmJiAocG9pbnRlciB8fCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHxcclxuXHRcdCh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlT3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZU9wZXJhID0gbW9iaWxlICYmIG9wZXJhO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZUdlY2tvOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbmV4cG9ydCB2YXIgbW9iaWxlR2Vja28gPSBtb2JpbGUgJiYgZ2Vja287XHJcblxyXG4vLyBAcHJvcGVydHkgcmV0aW5hOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgb24gYSBoaWdoLXJlc29sdXRpb24gXCJyZXRpbmFcIiBzY3JlZW4gb3Igb24gYW55IHNjcmVlbiB3aGVuIGJyb3dzZXIncyBkaXNwbGF5IHpvb20gaXMgbW9yZSB0aGFuIDEwMCUuXHJcbmV4cG9ydCB2YXIgcmV0aW5hID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8ICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSkgPiAxO1xyXG5cclxuLy8gQHByb3BlcnR5IHBhc3NpdmVFdmVudHM6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgcGFzc2l2ZSBldmVudHMuXHJcbmV4cG9ydCB2YXIgcGFzc2l2ZUV2ZW50cyA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IGZhbHNlO1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlRXZlbnRTdXBwb3J0JywgVXRpbC5mYWxzZUZuLCBvcHRzKTtcclxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIFV0aWwuZmFsc2VGbiwgb3B0cyk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0Ly8gRXJyb3JzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBzaW5jZSB0aGlzIGlzIG9ubHkgYSBicm93c2VyIHN1cHBvcnQgdGVzdC5cclxuXHR9XHJcblx0cmV0dXJuIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbjtcclxufSk7XHJcblxyXG4vLyBAcHJvcGVydHkgY2FudmFzOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXHJcbmV4cG9ydCB2YXIgY2FudmFzID0gKGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0O1xyXG59KCkpO1xyXG5cclxuLy8gQHByb3BlcnR5IHN2ZzogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxyXG5leHBvcnQgdmFyIHN2ZyA9ICEhKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiBzdmdDcmVhdGUoJ3N2ZycpLmNyZWF0ZVNWR1JlY3QpO1xyXG5cclxuLy8gQHByb3BlcnR5IHZtbDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSkuXHJcbmV4cG9ydCB2YXIgdm1sID0gIXN2ZyAmJiAoZnVuY3Rpb24gKCkge1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRkaXYuaW5uZXJIVE1MID0gJzx2OnNoYXBlIGFkaj1cIjFcIi8+JztcclxuXHJcblx0XHR2YXIgc2hhcGUgPSBkaXYuZmlyc3RDaGlsZDtcclxuXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcclxuXHJcblx0XHRyZXR1cm4gc2hhcGUgJiYgKHR5cGVvZiBzaGFwZS5hZGogPT09ICdvYmplY3QnKTtcclxuXHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufSgpKTtcclxuXHJcblxyXG5mdW5jdGlvbiB1c2VyQWdlbnRDb250YWlucyhzdHIpIHtcclxuXHRyZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyKSA+PSAwO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xuXG4vKlxuICogRXh0ZW5kcyBMLkRvbUV2ZW50IHRvIHByb3ZpZGUgdG91Y2ggc3VwcG9ydCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgYW5kIFdpbmRvd3MtYmFzZWQgZGV2aWNlcy5cbiAqL1xuXG5cbnZhciBQT0lOVEVSX0RPV04gPSAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nICAgOiAncG9pbnRlcmRvd24nO1xudmFyIFBPSU5URVJfTU9WRSA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyTW92ZScgICA6ICdwb2ludGVybW92ZSc7XG52YXIgUE9JTlRFUl9VUCA9ICAgICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgICAgIDogJ3BvaW50ZXJ1cCc7XG52YXIgUE9JTlRFUl9DQU5DRUwgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnO1xudmFyIFRBR19XSElURV9MSVNUID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnT1BUSU9OJ107XG5cbnZhciBfcG9pbnRlcnMgPSB7fTtcbnZhciBfcG9pbnRlckRvY0xpc3RlbmVyID0gZmFsc2U7XG5cbi8vIERvbUV2ZW50LkRvdWJsZVRhcCBuZWVkcyB0byBrbm93IGFib3V0IHRoaXNcbmV4cG9ydCB2YXIgX3BvaW50ZXJzQ291bnQgPSAwO1xuXG4vLyBQcm92aWRlcyBhIHRvdWNoIGV2ZW50cyB3cmFwcGVyIGZvciAobXMpcG9pbnRlciBldmVudHMuXG4vLyByZWYgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8gaHR0cHM6Ly93d3cudzMub3JnL0J1Z3MvUHVibGljL3Nob3dfYnVnLmNnaT9pZD0yMjg5MFxuXG5leHBvcnQgZnVuY3Rpb24gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpIHtcblx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdF9hZGRQb2ludGVyU3RhcnQob2JqLCBoYW5kbGVyLCBpZCk7XG5cblx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuXHRcdF9hZGRQb2ludGVyTW92ZShvYmosIGhhbmRsZXIsIGlkKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRfYWRkUG9pbnRlckVuZChvYmosIGhhbmRsZXIsIGlkKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaWQpIHtcblx0dmFyIGhhbmRsZXIgPSBvYmpbJ19sZWFmbGV0XycgKyB0eXBlICsgaWRdO1xuXG5cdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIGhhbmRsZXIsIGZhbHNlKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBoYW5kbGVyLCBmYWxzZSk7XG5cblx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgaGFuZGxlciwgZmFsc2UpO1xuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBoYW5kbGVyLCBmYWxzZSk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJTdGFydChvYmosIGhhbmRsZXIsIGlkKSB7XG5cdHZhciBvbkRvd24gPSBVdGlsLmJpbmQoZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJyAmJiBlLk1TUE9JTlRFUl9UWVBFX01PVVNFICYmIGUucG9pbnRlclR5cGUgIT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UpIHtcblx0XHRcdC8vIEluIElFMTEsIHNvbWUgdG91Y2ggZXZlbnRzIG5lZWRzIHRvIGZpcmUgZm9yIGZvcm0gY29udHJvbHMsIG9yXG5cdFx0XHQvLyB0aGUgY29udHJvbHMgd2lsbCBzdG9wIHdvcmtpbmcuIFdlIGtlZXAgYSB3aGl0ZWxpc3Qgb2YgdGFnIG5hbWVzIHRoYXRcblx0XHRcdC8vIG5lZWQgdGhlc2UgZXZlbnRzLiBGb3Igb3RoZXIgdGFyZ2V0IHRhZ3MsIHdlIHByZXZlbnQgZGVmYXVsdCBvbiB0aGUgZXZlbnQuXG5cdFx0XHRpZiAoVEFHX1dISVRFX0xJU1QuaW5kZXhPZihlLnRhcmdldC50YWdOYW1lKSA8IDApIHtcblx0XHRcdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdH0pO1xuXG5cdG9ialsnX2xlYWZsZXRfdG91Y2hzdGFydCcgKyBpZF0gPSBvbkRvd247XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgb25Eb3duLCBmYWxzZSk7XG5cblx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG5cdGlmICghX3BvaW50ZXJEb2NMaXN0ZW5lcikge1xuXHRcdC8vIHdlIGxpc3RlbiBkb2N1bWVudEVsZW1lbnQgYXMgYW55IGRyYWdzIHRoYXQgZW5kIGJ5IG1vdmluZyB0aGUgdG91Y2ggb2ZmIHRoZSBzY3JlZW4gZ2V0IGZpcmVkIHRoZXJlXG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBfZ2xvYmFsUG9pbnRlckRvd24sIHRydWUpO1xuXHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgX2dsb2JhbFBvaW50ZXJNb3ZlLCB0cnVlKTtcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0NBTkNFTCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG5cblx0XHRfcG9pbnRlckRvY0xpc3RlbmVyID0gdHJ1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlckRvd24oZSkge1xuXHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0X3BvaW50ZXJzQ291bnQrKztcbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJNb3ZlKGUpIHtcblx0aWYgKF9wb2ludGVyc1tlLnBvaW50ZXJJZF0pIHtcblx0XHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0fVxufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlclVwKGUpIHtcblx0ZGVsZXRlIF9wb2ludGVyc1tlLnBvaW50ZXJJZF07XG5cdF9wb2ludGVyc0NvdW50LS07XG59XG5cbmZ1bmN0aW9uIF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpIHtcblx0ZS50b3VjaGVzID0gW107XG5cdGZvciAodmFyIGkgaW4gX3BvaW50ZXJzKSB7XG5cdFx0ZS50b3VjaGVzLnB1c2goX3BvaW50ZXJzW2ldKTtcblx0fVxuXHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG5cdGhhbmRsZXIoZSk7XG59XG5cbmZ1bmN0aW9uIF9hZGRQb2ludGVyTW92ZShvYmosIGhhbmRsZXIsIGlkKSB7XG5cdHZhciBvbk1vdmUgPSBmdW5jdGlvbiAoZSkge1xuXHRcdC8vIGRvbid0IGZpcmUgdG91Y2ggbW92ZXMgd2hlbiBtb3VzZSBpc24ndCBkb3duXG5cdFx0aWYgKChlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpICYmIGUuYnV0dG9ucyA9PT0gMCkgeyByZXR1cm47IH1cblxuXHRcdF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuXHR9O1xuXG5cdG9ialsnX2xlYWZsZXRfdG91Y2htb3ZlJyArIGlkXSA9IG9uTW92ZTtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBvbk1vdmUsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJFbmQob2JqLCBoYW5kbGVyLCBpZCkge1xuXHR2YXIgb25VcCA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdH07XG5cblx0b2JqWydfbGVhZmxldF90b3VjaGVuZCcgKyBpZF0gPSBvblVwO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBvblVwLCBmYWxzZSk7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBvblVwLCBmYWxzZSk7XG59XG5cbiIsImltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHtfcG9pbnRlcnNDb3VudH0gZnJvbSAnLi9Eb21FdmVudC5Qb2ludGVyJztcclxuXHJcbi8qXHJcbiAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICovXHJcblxyXG52YXIgX3RvdWNoc3RhcnQgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyA6IEJyb3dzZXIucG9pbnRlciA/ICdwb2ludGVyZG93bicgOiAndG91Y2hzdGFydCc7XHJcbnZhciBfdG91Y2hlbmQgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgOiBCcm93c2VyLnBvaW50ZXIgPyAncG9pbnRlcnVwJyA6ICd0b3VjaGVuZCc7XHJcbnZhciBfcHJlID0gJ19sZWFmbGV0Xyc7XHJcblxyXG4vLyBpbnNwaXJlZCBieSBaZXB0byB0b3VjaCBjb2RlIGJ5IFRob21hcyBGdWNoc1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyLCBpZCkge1xyXG5cdHZhciBsYXN0LCB0b3VjaCxcclxuXHQgICAgZG91YmxlVGFwID0gZmFsc2UsXHJcblx0ICAgIGRlbGF5ID0gMjUwO1xyXG5cclxuXHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xyXG5cdFx0dmFyIGNvdW50O1xyXG5cclxuXHRcdGlmIChCcm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0aWYgKCghQnJvd3Nlci5lZGdlKSB8fCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7IHJldHVybjsgfVxyXG5cdFx0XHRjb3VudCA9IF9wb2ludGVyc0NvdW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y291bnQgPSBlLnRvdWNoZXMubGVuZ3RoO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb3VudCA+IDEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG5vdyA9IERhdGUubm93KCksXHJcblx0XHQgICAgZGVsdGEgPSBub3cgLSAobGFzdCB8fCBub3cpO1xyXG5cclxuXHRcdHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHRcdGRvdWJsZVRhcCA9IChkZWx0YSA+IDAgJiYgZGVsdGEgPD0gZGVsYXkpO1xyXG5cdFx0bGFzdCA9IG5vdztcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uVG91Y2hFbmQoZSkge1xyXG5cdFx0aWYgKGRvdWJsZVRhcCAmJiAhdG91Y2guY2FuY2VsQnViYmxlKSB7XHJcblx0XHRcdGlmIChCcm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0XHRpZiAoKCFCcm93c2VyLmVkZ2UpIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHsgcmV0dXJuOyB9XHJcblx0XHRcdFx0Ly8gd29yayBhcm91bmQgLnR5cGUgYmVpbmcgcmVhZG9ubHkgd2l0aCBNU1BvaW50ZXIqIGV2ZW50c1xyXG5cdFx0XHRcdHZhciBuZXdUb3VjaCA9IHt9LFxyXG5cdFx0XHRcdCAgICBwcm9wLCBpO1xyXG5cclxuXHRcdFx0XHRmb3IgKGkgaW4gdG91Y2gpIHtcclxuXHRcdFx0XHRcdHByb3AgPSB0b3VjaFtpXTtcclxuXHRcdFx0XHRcdG5ld1RvdWNoW2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQodG91Y2gpIDogcHJvcDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dG91Y2ggPSBuZXdUb3VjaDtcclxuXHRcdFx0fVxyXG5cdFx0XHR0b3VjaC50eXBlID0gJ2RibGNsaWNrJztcclxuXHRcdFx0dG91Y2guYnV0dG9uID0gMDtcclxuXHRcdFx0aGFuZGxlcih0b3VjaCk7XHJcblx0XHRcdGxhc3QgPSBudWxsO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0b2JqW19wcmUgKyBfdG91Y2hzdGFydCArIGlkXSA9IG9uVG91Y2hTdGFydDtcclxuXHRvYmpbX3ByZSArIF90b3VjaGVuZCArIGlkXSA9IG9uVG91Y2hFbmQ7XHJcblx0b2JqW19wcmUgKyAnZGJsY2xpY2snICsgaWRdID0gaGFuZGxlcjtcclxuXHJcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoX3RvdWNoc3RhcnQsIG9uVG91Y2hTdGFydCwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihfdG91Y2hlbmQsIG9uVG91Y2hFbmQsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblxyXG5cdC8vIE9uIHNvbWUgcGxhdGZvcm1zIChub3RhYmx5LCBjaHJvbWU8NTUgb24gd2luMTAgKyB0b3VjaHNjcmVlbiArIG1vdXNlKSxcclxuXHQvLyB0aGUgYnJvd3NlciBkb2Vzbid0IGZpcmUgdG91Y2hlbmQvcG9pbnRlcnVwIGV2ZW50cyBidXQgZG9lcyBmaXJlXHJcblx0Ly8gbmF0aXZlIGRibGNsaWNrcy4gU2VlICM0MTI3LlxyXG5cdC8vIEVkZ2UgMTQgYWxzbyBmaXJlcyBuYXRpdmUgZGJsY2xpY2tzLCBidXQgb25seSBmb3IgcG9pbnRlclR5cGUgbW91c2UsIHNlZSAjNTE4MC5cclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBpZCkge1xyXG5cdHZhciB0b3VjaHN0YXJ0ID0gb2JqW19wcmUgKyBfdG91Y2hzdGFydCArIGlkXSxcclxuXHQgICAgdG91Y2hlbmQgPSBvYmpbX3ByZSArIF90b3VjaGVuZCArIGlkXSxcclxuXHQgICAgZGJsY2xpY2sgPSBvYmpbX3ByZSArICdkYmxjbGljaycgKyBpZF07XHJcblxyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKF90b3VjaHN0YXJ0LCB0b3VjaHN0YXJ0LCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKF90b3VjaGVuZCwgdG91Y2hlbmQsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblx0aWYgKCFCcm93c2VyLmVkZ2UpIHtcclxuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGRibGNsaWNrLCBmYWxzZSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tVXRpbFxyXG4gKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Eb2N1bWVudF9PYmplY3RfTW9kZWwpXHJcbiAqIHRyZWUsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBNb3N0IGZ1bmN0aW9ucyBleHBlY3Rpbmcgb3IgcmV0dXJuaW5nIGEgYEhUTUxFbGVtZW50YCBhbHNvIHdvcmsgZm9yXHJcbiAqIFNWRyBlbGVtZW50cy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGNsYXNzZXMgcmVmZXIgdG8gQ1NTIGNsYXNzZXNcclxuICogaW4gSFRNTCBhbmQgU1ZHIGNsYXNzZXMgaW4gU1ZHLlxyXG4gKi9cclxuXHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNGT1JNOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zZm9ybSBzdHlsZSBuYW1lIChlLmcuIGAnd2Via2l0VHJhbnNmb3JtJ2AgZm9yIFdlYktpdCkuXHJcbmV4cG9ydCB2YXIgVFJBTlNGT1JNID0gdGVzdFByb3AoXHJcblx0Wyd0cmFuc2Zvcm0nLCAnd2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ10pO1xyXG5cclxuLy8gd2Via2l0VHJhbnNpdGlvbiBjb21lcyBmaXJzdCBiZWNhdXNlIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyB0aGF0IGRyb3AgdmVuZG9yIHByZWZpeCBkb24ndCBkb1xyXG4vLyB0aGUgc2FtZSBmb3IgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQsIGluIHBhcnRpY3VsYXIgdGhlIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb24gc3R5bGUgbmFtZS5cclxuZXhwb3J0IHZhciBUUkFOU0lUSU9OID0gdGVzdFByb3AoXHJcblx0Wyd3ZWJraXRUcmFuc2l0aW9uJywgJ3RyYW5zaXRpb24nLCAnT1RyYW5zaXRpb24nLCAnTW96VHJhbnNpdGlvbicsICdtc1RyYW5zaXRpb24nXSk7XHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNJVElPTl9FTkQ6IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbmVuZCBldmVudCBuYW1lLlxyXG5leHBvcnQgdmFyIFRSQU5TSVRJT05fRU5EID1cclxuXHRUUkFOU0lUSU9OID09PSAnd2Via2l0VHJhbnNpdGlvbicgfHwgVFJBTlNJVElPTiA9PT0gJ09UcmFuc2l0aW9uJyA/IFRSQU5TSVRJT04gKyAnRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0KGlkOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBSZXR1cm5zIGFuIGVsZW1lbnQgZ2l2ZW4gaXRzIERPTSBpZCwgb3IgcmV0dXJucyB0aGUgZWxlbWVudCBpdHNlbGZcclxuLy8gaWYgaXQgd2FzIHBhc3NlZCBkaXJlY3RseS5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldChpZCkge1xyXG5cdHJldHVybiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTdHlsZShlbDogSFRNTEVsZW1lbnQsIHN0eWxlQXR0cmliOiBTdHJpbmcpOiBTdHJpbmdcclxuLy8gUmV0dXJucyB0aGUgdmFsdWUgZm9yIGEgY2VydGFpbiBzdHlsZSBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcclxuLy8gaW5jbHVkaW5nIGNvbXB1dGVkIHZhbHVlcyBvciB2YWx1ZXMgc2V0IHRocm91Z2ggQ1NTLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGUoZWwsIHN0eWxlKSB7XHJcblx0dmFyIHZhbHVlID0gZWwuc3R5bGVbc3R5bGVdIHx8IChlbC5jdXJyZW50U3R5bGUgJiYgZWwuY3VycmVudFN0eWxlW3N0eWxlXSk7XHJcblxyXG5cdGlmICgoIXZhbHVlIHx8IHZhbHVlID09PSAnYXV0bycpICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XHJcblx0XHR2YXIgY3NzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XHJcblx0XHR2YWx1ZSA9IGNzcyA/IGNzc1tzdHlsZV0gOiBudWxsO1xyXG5cdH1cclxuXHRyZXR1cm4gdmFsdWUgPT09ICdhdXRvJyA/IG51bGwgOiB2YWx1ZTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lOiBTdHJpbmcsIGNsYXNzTmFtZT86IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBDcmVhdGVzIGFuIEhUTUwgZWxlbWVudCB3aXRoIGB0YWdOYW1lYCwgc2V0cyBpdHMgY2xhc3MgdG8gYGNsYXNzTmFtZWAsIGFuZCBvcHRpb25hbGx5IGFwcGVuZHMgaXQgdG8gYGNvbnRhaW5lcmAgZWxlbWVudC5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xyXG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcblx0ZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8ICcnO1xyXG5cclxuXHRpZiAoY29udGFpbmVyKSB7XHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gZWw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmUoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBSZW1vdmVzIGBlbGAgZnJvbSBpdHMgcGFyZW50IGVsZW1lbnRcclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQpIHtcclxuXHRcdHBhcmVudC5yZW1vdmVDaGlsZChlbCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZW1wdHkoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBSZW1vdmVzIGFsbCBvZiBgZWxgJ3MgY2hpbGRyZW4gZWxlbWVudHMgZnJvbSBgZWxgXHJcbmV4cG9ydCBmdW5jdGlvbiBlbXB0eShlbCkge1xyXG5cdHdoaWxlIChlbC5maXJzdENoaWxkKSB7XHJcblx0XHRlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0b0Zyb250KGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgYGVsYCB0aGUgbGFzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGluIGZyb250IG9mIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvRnJvbnQoZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50ICYmIHBhcmVudC5sYXN0Q2hpbGQgIT09IGVsKSB7XHJcblx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRvQmFjayhlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIGBlbGAgdGhlIGZpcnN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgYmVoaW5kIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQmFjayhlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQgJiYgcGFyZW50LmZpcnN0Q2hpbGQgIT09IGVsKSB7XHJcblx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLCBwYXJlbnQuZmlyc3RDaGlsZCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gaGFzQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpOiBCb29sZWFuXHJcbi8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIGNvbnRhaW5zIGBuYW1lYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xyXG5cdH1cclxuXHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG5cdHJldHVybiBjbGFzc05hbWUubGVuZ3RoID4gMCAmJiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgbmFtZSArICcoXFxcXHN8JCknKS50ZXN0KGNsYXNzTmFtZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gQWRkcyBgbmFtZWAgdG8gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dmFyIGNsYXNzZXMgPSBVdGlsLnNwbGl0V29yZHMobmFtZSk7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsLCBuYW1lKSkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuXHRcdHNldENsYXNzKGVsLCAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgJyAnIDogJycpICsgbmFtZSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIFJlbW92ZXMgYG5hbWVgIGZyb20gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c2V0Q2xhc3MoZWwsIFV0aWwudHJpbSgoJyAnICsgZ2V0Q2xhc3MoZWwpICsgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJykpKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gU2V0cyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0Q2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZWwuY2xhc3NOYW1lID0gbmFtZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gaW4gY2FzZSBvZiBTVkcgZWxlbWVudFxyXG5cdFx0ZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBuYW1lO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldENsYXNzKGVsOiBIVE1MRWxlbWVudCk6IFN0cmluZ1xyXG4vLyBSZXR1cm5zIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzcyhlbCkge1xyXG5cdC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIGFuIFNWR0VsZW1lbnRJbnN0YW5jZSBhbmQgdXNlIHRoZSBjb3JyZXNwb25kaW5nRWxlbWVudCBpbnN0ZWFkXHJcblx0Ly8gKFJlcXVpcmVkIGZvciBsaW5rZWQgU1ZHIGVsZW1lbnRzIGluIElFMTEuKVxyXG5cdGlmIChlbC5jb3JyZXNwb25kaW5nRWxlbWVudCkge1xyXG5cdFx0ZWwgPSBlbC5jb3JyZXNwb25kaW5nRWxlbWVudDtcclxuXHR9XHJcblx0cmV0dXJuIGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQgPyBlbC5jbGFzc05hbWUgOiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldE9wYWNpdHkoZWw6IEhUTUxFbGVtZW50LCBvcGFjaXR5OiBOdW1iZXIpXHJcbi8vIFNldCB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50IChpbmNsdWRpbmcgb2xkIElFIHN1cHBvcnQpLlxyXG4vLyBgb3BhY2l0eWAgbXVzdCBiZSBhIG51bWJlciBmcm9tIGAwYCB0byBgMWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsLCB2YWx1ZSkge1xyXG5cdGlmICgnb3BhY2l0eScgaW4gZWwuc3R5bGUpIHtcclxuXHRcdGVsLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHR9IGVsc2UgaWYgKCdmaWx0ZXInIGluIGVsLnN0eWxlKSB7XHJcblx0XHRfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSkge1xyXG5cdHZhciBmaWx0ZXIgPSBmYWxzZSxcclxuXHQgICAgZmlsdGVyTmFtZSA9ICdEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYSc7XHJcblxyXG5cdC8vIGZpbHRlcnMgY29sbGVjdGlvbiB0aHJvd3MgYW4gZXJyb3IgaWYgd2UgdHJ5IHRvIHJldHJpZXZlIGEgZmlsdGVyIHRoYXQgZG9lc24ndCBleGlzdFxyXG5cdHRyeSB7XHJcblx0XHRmaWx0ZXIgPSBlbC5maWx0ZXJzLml0ZW0oZmlsdGVyTmFtZSk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0Ly8gZG9uJ3Qgc2V0IG9wYWNpdHkgdG8gMSBpZiB3ZSBoYXZlbid0IGFscmVhZHkgc2V0IGFuIG9wYWNpdHksXHJcblx0XHQvLyBpdCBpc24ndCBuZWVkZWQgYW5kIGJyZWFrcyB0cmFuc3BhcmVudCBwbmdzLlxyXG5cdFx0aWYgKHZhbHVlID09PSAxKSB7IHJldHVybjsgfVxyXG5cdH1cclxuXHJcblx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogMTAwKTtcclxuXHJcblx0aWYgKGZpbHRlcikge1xyXG5cdFx0ZmlsdGVyLkVuYWJsZWQgPSAodmFsdWUgIT09IDEwMCk7XHJcblx0XHRmaWx0ZXIuT3BhY2l0eSA9IHZhbHVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlbC5zdHlsZS5maWx0ZXIgKz0gJyBwcm9naWQ6JyArIGZpbHRlck5hbWUgKyAnKG9wYWNpdHk9JyArIHZhbHVlICsgJyknO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzOiBTdHJpbmdbXSk6IFN0cmluZ3xmYWxzZVxyXG4vLyBHb2VzIHRocm91Z2ggdGhlIGFycmF5IG9mIHN0eWxlIG5hbWVzIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBuYW1lXHJcbi8vIHRoYXQgaXMgYSB2YWxpZCBzdHlsZSBuYW1lIGZvciBhbiBlbGVtZW50LiBJZiBubyBzdWNoIG5hbWUgaXMgZm91bmQsXHJcbi8vIGl0IHJldHVybnMgZmFsc2UuIFVzZWZ1bCBmb3IgdmVuZG9yLXByZWZpeGVkIHN0eWxlcyBsaWtlIGB0cmFuc2Zvcm1gLlxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdFByb3AocHJvcHMpIHtcclxuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChwcm9wc1tpXSBpbiBzdHlsZSkge1xyXG5cdFx0XHRyZXR1cm4gcHJvcHNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbDogSFRNTEVsZW1lbnQsIG9mZnNldDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKVxyXG4vLyBSZXNldHMgdGhlIDNEIENTUyB0cmFuc2Zvcm0gb2YgYGVsYCBzbyBpdCBpcyB0cmFuc2xhdGVkIGJ5IGBvZmZzZXRgIHBpeGVsc1xyXG4vLyBhbmQgb3B0aW9uYWxseSBzY2FsZWQgYnkgYHNjYWxlYC4gRG9lcyBub3QgaGF2ZSBhbiBlZmZlY3QgaWYgdGhlXHJcbi8vIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IDNEIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsLCBvZmZzZXQsIHNjYWxlKSB7XHJcblx0dmFyIHBvcyA9IG9mZnNldCB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcblxyXG5cdGVsLnN0eWxlW1RSQU5TRk9STV0gPVxyXG5cdFx0KEJyb3dzZXIuaWUzZCA/XHJcblx0XHRcdCd0cmFuc2xhdGUoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCknIDpcclxuXHRcdFx0J3RyYW5zbGF0ZTNkKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgsMCknKSArXHJcblx0XHQoc2NhbGUgPyAnIHNjYWxlKCcgKyBzY2FsZSArICcpJyA6ICcnKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCwgcG9zaXRpb246IFBvaW50KVxyXG4vLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBgZWxgIHRvIGNvb3JkaW5hdGVzIHNwZWNpZmllZCBieSBgcG9zaXRpb25gLFxyXG4vLyB1c2luZyBDU1MgdHJhbnNsYXRlIG9yIHRvcC9sZWZ0IHBvc2l0aW9uaW5nIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlclxyXG4vLyAodXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gcG9zaXRpb24gaXRzIGxheWVycykuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbCwgcG9pbnQpIHtcclxuXHJcblx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdGVsLl9sZWFmbGV0X3BvcyA9IHBvaW50O1xyXG5cdC8qIGVzbGludC1lbmFibGUgKi9cclxuXHJcblx0aWYgKEJyb3dzZXIuYW55M2QpIHtcclxuXHRcdHNldFRyYW5zZm9ybShlbCwgcG9pbnQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlbC5zdHlsZS5sZWZ0ID0gcG9pbnQueCArICdweCc7XHJcblx0XHRlbC5zdHlsZS50b3AgPSBwb2ludC55ICsgJ3B4JztcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4vLyBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiBhbiBlbGVtZW50IHByZXZpb3VzbHkgcG9zaXRpb25lZCB3aXRoIHNldFBvc2l0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWwpIHtcclxuXHQvLyB0aGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZm9yIGVsZW1lbnRzIHByZXZpb3VzbHkgcG9zaXRpb25lZCB1c2luZyBzZXRQb3NpdGlvbixcclxuXHQvLyBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgdGhlIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZVxyXG5cclxuXHRyZXR1cm4gZWwuX2xlYWZsZXRfcG9zIHx8IG5ldyBQb2ludCgwLCAwKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVUZXh0U2VsZWN0aW9uKClcclxuLy8gUHJldmVudHMgdGhlIHVzZXIgZnJvbSBnZW5lcmF0aW5nIGBzZWxlY3RzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWRcclxuLy8gd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgbW91c2UgdGhyb3VnaCBhIHBhZ2Ugd2l0aCB0ZXh0LiBVc2VkIGludGVybmFsbHlcclxuLy8gYnkgTGVhZmxldCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3VyIG9mIGFueSBjbGljay1hbmQtZHJhZyBpbnRlcmFjdGlvbiBvblxyXG4vLyB0aGUgbWFwLiBBZmZlY3RzIGRyYWcgaW50ZXJhY3Rpb25zIG9uIHRoZSB3aG9sZSBkb2N1bWVudC5cclxuXHJcbi8vIEBmdW5jdGlvbiBlbmFibGVUZXh0U2VsZWN0aW9uKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG5leHBvcnQgdmFyIGRpc2FibGVUZXh0U2VsZWN0aW9uO1xyXG5leHBvcnQgdmFyIGVuYWJsZVRleHRTZWxlY3Rpb247XHJcbnZhciBfdXNlclNlbGVjdDtcclxuaWYgKCdvbnNlbGVjdHN0YXJ0JyBpbiBkb2N1bWVudCkge1xyXG5cdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tRXZlbnQub24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxuXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tRXZlbnQub2ZmKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcbn0gZWxzZSB7XHJcblx0dmFyIHVzZXJTZWxlY3RQcm9wZXJ0eSA9IHRlc3RQcm9wKFxyXG5cdFx0Wyd1c2VyU2VsZWN0JywgJ1dlYmtpdFVzZXJTZWxlY3QnLCAnT1VzZXJTZWxlY3QnLCAnTW96VXNlclNlbGVjdCcsICdtc1VzZXJTZWxlY3QnXSk7XHJcblxyXG5cdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblx0XHRcdF91c2VyU2VsZWN0ID0gc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XTtcclxuXHRcdFx0c3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9ICdub25lJztcclxuXHRcdH1cclxuXHR9O1xyXG5cdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gX3VzZXJTZWxlY3Q7XHJcblx0XHRcdF91c2VyU2VsZWN0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKClcclxuLy8gQXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbiksIGJ1dFxyXG4vLyBmb3IgYGRyYWdzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWQgd2hlbiB0aGUgdXNlciBkcmFncyBhbiBpbWFnZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKSB7XHJcblx0RG9tRXZlbnQub24od2luZG93LCAnZHJhZ3N0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWdgXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKSB7XHJcblx0RG9tRXZlbnQub2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxufVxyXG5cclxudmFyIF9vdXRsaW5lRWxlbWVudCwgX291dGxpbmVTdHlsZTtcclxuLy8gQGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgdGhlIFtvdXRsaW5lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1Mvb3V0bGluZSlcclxuLy8gb2YgdGhlIGVsZW1lbnQgYGVsYCBpbnZpc2libGUuIFVzZWQgaW50ZXJuYWxseSBieSBMZWFmbGV0IHRvIHByZXZlbnRcclxuLy8gZm9jdXNhYmxlIGVsZW1lbnRzIGZyb20gZGlzcGxheWluZyBhbiBvdXRsaW5lIHdoZW4gdGhlIHVzZXIgcGVyZm9ybXMgYVxyXG4vLyBkcmFnIGludGVyYWN0aW9uIG9uIHRoZW0uXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbGVtZW50KSB7XHJcblx0d2hpbGUgKGVsZW1lbnQudGFiSW5kZXggPT09IC0xKSB7XHJcblx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdH1cclxuXHRpZiAoIWVsZW1lbnQuc3R5bGUpIHsgcmV0dXJuOyB9XHJcblx0cmVzdG9yZU91dGxpbmUoKTtcclxuXHRfb3V0bGluZUVsZW1lbnQgPSBlbGVtZW50O1xyXG5cdF9vdXRsaW5lU3R5bGUgPSBlbGVtZW50LnN0eWxlLm91dGxpbmU7XHJcblx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xyXG5cdERvbUV2ZW50Lm9uKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZWBdKCkuXHJcbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpIHtcclxuXHRpZiAoIV9vdXRsaW5lRWxlbWVudCkgeyByZXR1cm47IH1cclxuXHRfb3V0bGluZUVsZW1lbnQuc3R5bGUub3V0bGluZSA9IF9vdXRsaW5lU3R5bGU7XHJcblx0X291dGxpbmVFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG5cdF9vdXRsaW5lU3R5bGUgPSB1bmRlZmluZWQ7XHJcblx0RG9tRXZlbnQub2ZmKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWw6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gRmluZHMgdGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgd2hpY2ggc2l6ZSAod2lkdGggYW5kIGhlaWdodCkgaXMgbm90IG51bGwuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWxlbWVudCkge1xyXG5cdGRvIHtcclxuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblx0fSB3aGlsZSAoKCFlbGVtZW50Lm9mZnNldFdpZHRoIHx8ICFlbGVtZW50Lm9mZnNldEhlaWdodCkgJiYgZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSk7XHJcblx0cmV0dXJuIGVsZW1lbnQ7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTY2FsZShlbDogSFRNTEVsZW1lbnQpOiBPYmplY3RcclxuLy8gQ29tcHV0ZXMgdGhlIENTUyBzY2FsZSBjdXJyZW50bHkgYXBwbGllZCBvbiB0aGUgZWxlbWVudC5cclxuLy8gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBgeGAgYW5kIGB5YCBtZW1iZXJzIGFzIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHNjYWxlcyByZXNwZWN0aXZlbHksXHJcbi8vIGFuZCBgYm91bmRpbmdDbGllbnRSZWN0YCBhcyB0aGUgcmVzdWx0IG9mIFtgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9nZXRCb3VuZGluZ0NsaWVudFJlY3QpLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xyXG5cdHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gUmVhZC1vbmx5IGluIG9sZCBicm93c2Vycy5cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHg6IHJlY3Qud2lkdGggLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEsXHJcblx0XHR5OiByZWN0LmhlaWdodCAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEsXHJcblx0XHRib3VuZGluZ0NsaWVudFJlY3Q6IHJlY3RcclxuXHR9O1xyXG59XHJcbiIsImltcG9ydCB7UG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCB7YWRkUG9pbnRlckxpc3RlbmVyLCByZW1vdmVQb2ludGVyTGlzdGVuZXJ9IGZyb20gJy4vRG9tRXZlbnQuUG9pbnRlcic7XHJcbmltcG9ydCB7YWRkRG91YmxlVGFwTGlzdGVuZXIsIHJlbW92ZURvdWJsZVRhcExpc3RlbmVyfSBmcm9tICcuL0RvbUV2ZW50LkRvdWJsZVRhcCc7XHJcbmltcG9ydCB7Z2V0U2NhbGV9IGZyb20gJy4vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbUV2ZW50XHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTSBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudCksIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEluc3BpcmVkIGJ5IEpvaG4gUmVzaWcsIERlYW4gRWR3YXJkcyBhbmQgWVVJIGFkZEV2ZW50IGltcGxlbWVudGF0aW9ucy5cclxuXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgRE9NIGV2ZW50IHR5cGUgb2YgdGhlXHJcbi8vIGVsZW1lbnQgYGVsYC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyXHJcbi8vIChvYmplY3QgdGhlIGB0aGlzYCBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsXHJcbi8vIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuZXhwb3J0IGZ1bmN0aW9uIG9uKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdGFkZE9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG52YXIgZXZlbnRzS2V5ID0gJ19sZWFmbGV0X2V2ZW50cyc7XHJcblxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi5cclxuLy8gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBvbiwgeW91IG11c3QgcGFzcyB0aGUgc2FtZVxyXG4vLyBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuZXhwb3J0IGZ1bmN0aW9uIG9mZihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAodHlwZXMpIHtcclxuXHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yICh2YXIgaiBpbiBvYmpbZXZlbnRzS2V5XSkge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCBqLCBvYmpbZXZlbnRzS2V5XVtqXSk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgb2JqW2V2ZW50c0tleV07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHR2YXIgaWQgPSB0eXBlICsgVXRpbC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIFV0aWwuc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcblxyXG5cdGlmIChvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcclxuXHR9O1xyXG5cclxuXHR2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcblx0aWYgKEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdC8vIE5lZWRzIERvbUV2ZW50LlBvaW50ZXIuanNcclxuXHRcdGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiBhZGREb3VibGVUYXBMaXN0ZW5lciAmJlxyXG5cdCAgICAgICAgICAgIShCcm93c2VyLnBvaW50ZXIgJiYgQnJvd3Nlci5jaHJvbWUpKSB7XHJcblx0XHQvLyBDaHJvbWUgPjU1IGRvZXMgbm90IG5lZWQgdGhlIHN5bnRoZXRpYyBkYmxjbGlja3MgZnJvbSBhZGREb3VibGVUYXBMaXN0ZW5lclxyXG5cdFx0Ly8gU2VlICM1MTgwXHJcblx0XHRhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCh0eXBlID09PSAnbW91c2VlbnRlcicpIHx8ICh0eXBlID09PSAnbW91c2VsZWF2ZScpKSB7XHJcblx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcclxuXHRcdFx0XHRpZiAoaXNFeHRlcm5hbFRhcmdldChvYmosIGUpKSB7XHJcblx0XHRcdFx0XHRvcmlnaW5hbEhhbmRsZXIoZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6ICdtb3VzZW91dCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJyAmJiBCcm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdGZpbHRlckNsaWNrKGUsIG9yaWdpbmFsSGFuZGxlcik7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XSA9IG9ialtldmVudHNLZXldIHx8IHt9O1xyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IGhhbmRsZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZU9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdHZhciBpZCA9IHR5cGUgKyBVdGlsLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgVXRpbC5zdGFtcChjb250ZXh0KSA6ICcnKSxcclxuXHQgICAgaGFuZGxlciA9IG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXTtcclxuXHJcblx0aWYgKCFoYW5kbGVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdGlmIChCcm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHRyZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAoQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIgJiZcclxuXHQgICAgICAgICAgICEoQnJvd3Nlci5wb2ludGVyICYmIEJyb3dzZXIuY2hyb21lKSkge1xyXG5cdFx0cmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ud2hlZWwnIGluIG9iaiA/ICd3aGVlbCcgOiAnbW91c2V3aGVlbCcsIGhhbmRsZXIsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXHJcblx0XHRcdFx0dHlwZSA9PT0gJ21vdXNlZW50ZXInID8gJ21vdXNlb3ZlcicgOlxyXG5cdFx0XHRcdHR5cGUgPT09ICdtb3VzZWxlYXZlJyA/ICdtb3VzZW91dCcgOiB0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2RldGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdG9iai5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBudWxsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gU3RvcCB0aGUgZ2l2ZW4gZXZlbnQgZnJvbSBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuIFVzZWQgaW5zaWRlIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnM6XHJcbi8vIGBgYGpzXHJcbi8vIEwuRG9tRXZlbnQub24oZGl2LCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuLy8gXHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldik7XHJcbi8vIH0pO1xyXG4vLyBgYGBcclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihlKSB7XHJcblxyXG5cdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHR9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudCkgeyAgLy8gSW4gY2FzZSBvZiBMZWFmbGV0IGV2ZW50LlxyXG5cdFx0ZS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkID0gdHJ1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdH1cclxuXHRza2lwcGVkKGUpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbi8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ21vdXNld2hlZWwnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWwpIHtcclxuXHRhZGRPbmUoZWwsICdtb3VzZXdoZWVsJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnY2xpY2snYCwgYCdkb3VibGVjbGljaydgLFxyXG4vLyBgJ21vdXNlZG93bidgIGFuZCBgJ3RvdWNoc3RhcnQnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbCkge1xyXG5cdG9uKGVsLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQgZGJsY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdGFkZE9uZShlbCwgJ2NsaWNrJywgZmFrZVN0b3ApO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIERPTSBFdmVudCBgZXZgIGZyb20gaGFwcGVuaW5nIChzdWNoIGFzXHJcbi8vIGZvbGxvd2luZyBhIGxpbmsgaW4gdGhlIGhyZWYgb2YgdGhlIGEgZWxlbWVudCwgb3IgZG9pbmcgYSBQT1NUIHJlcXVlc3RcclxuLy8gd2l0aCBwYWdlIHJlbG9hZCB3aGVuIGEgYDxmb3JtPmAgaXMgc3VibWl0dGVkKS5cclxuLy8gVXNlIGl0IGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XHJcblx0aWYgKGUucHJldmVudERlZmF1bHQpIHtcclxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHN0b3AoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBEb2VzIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIGF0IHRoZSBzYW1lIHRpbWUuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdG9wKGUpIHtcclxuXHRwcmV2ZW50RGVmYXVsdChlKTtcclxuXHRzdG9wUHJvcGFnYXRpb24oZSk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGV2OiBET01FdmVudCwgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4vLyBHZXRzIG5vcm1hbGl6ZWQgbW91c2UgcG9zaXRpb24gZnJvbSBhIERPTSBldmVudCByZWxhdGl2ZSB0byB0aGVcclxuLy8gYGNvbnRhaW5lcmAgKGJvcmRlciBleGNsdWRlZCkgb3IgdG8gdGhlIHdob2xlIHBhZ2UgaWYgbm90IHNwZWNpZmllZC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSwgY29udGFpbmVyKSB7XHJcblx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xyXG5cdH1cclxuXHJcblx0dmFyIHNjYWxlID0gZ2V0U2NhbGUoY29udGFpbmVyKSxcclxuXHQgICAgb2Zmc2V0ID0gc2NhbGUuYm91bmRpbmdDbGllbnRSZWN0OyAvLyBsZWZ0IGFuZCB0b3AgIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSB0aGUgZXZlbnQgY2xpZW50WC9ZKVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0Ly8gb2Zmc2V0LmxlZnQvdG9wIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSBjbGllbnRYL1kpLFxyXG5cdFx0Ly8gd2hlcmVhcyBjbGllbnRMZWZ0L1RvcCAoYm9yZGVyIHdpZHRoKSB2YWx1ZXMgYXJlIHRoZSBvcmlnaW5hbCB2YWx1ZXMgKGJlZm9yZSBDU1Mgc2NhbGUgYXBwbGllcykuXHJcblx0XHQoZS5jbGllbnRYIC0gb2Zmc2V0LmxlZnQpIC8gc2NhbGUueCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG5cdFx0KGUuY2xpZW50WSAtIG9mZnNldC50b3ApIC8gc2NhbGUueSAtIGNvbnRhaW5lci5jbGllbnRUb3BcclxuXHQpO1xyXG59XHJcblxyXG4vLyBDaHJvbWUgb24gV2luIHNjcm9sbHMgZG91YmxlIHRoZSBwaXhlbHMgYXMgaW4gb3RoZXIgcGxhdGZvcm1zIChzZWUgIzQ1MzgpLFxyXG4vLyBhbmQgRmlyZWZveCBzY3JvbGxzIGRldmljZSBwaXhlbHMsIG5vdCBDU1MgcGl4ZWxzXHJcbnZhciB3aGVlbFB4RmFjdG9yID1cclxuXHQoQnJvd3Nlci53aW4gJiYgQnJvd3Nlci5jaHJvbWUpID8gMiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDpcclxuXHRCcm93c2VyLmdlY2tvID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZXY6IERPTUV2ZW50KTogTnVtYmVyXHJcbi8vIEdldHMgbm9ybWFsaXplZCB3aGVlbCBkZWx0YSBmcm9tIGEgbW91c2V3aGVlbCBET00gZXZlbnQsIGluIHZlcnRpY2FsXHJcbi8vIHBpeGVscyBzY3JvbGxlZCAobmVnYXRpdmUgaWYgc2Nyb2xsaW5nIGRvd24pLlxyXG4vLyBFdmVudHMgZnJvbSBwb2ludGluZyBkZXZpY2VzIHdpdGhvdXQgcHJlY2lzZSBzY3JvbGxpbmcgYXJlIG1hcHBlZCB0b1xyXG4vLyBhIGJlc3QgZ3Vlc3Mgb2YgNjAgcGl4ZWxzLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShlKSB7XHJcblx0cmV0dXJuIChCcm93c2VyLmVkZ2UpID8gZS53aGVlbERlbHRhWSAvIDIgOiAvLyBEb24ndCB0cnVzdCB3aW5kb3ctZ2VvbWV0cnktYmFzZWQgZGVsdGFcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAwKSA/IC1lLmRlbHRhWSAvIHdoZWVsUHhGYWN0b3IgOiAvLyBQaXhlbHNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAxKSA/IC1lLmRlbHRhWSAqIDIwIDogLy8gTGluZXNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAyKSA/IC1lLmRlbHRhWSAqIDYwIDogLy8gUGFnZXNcclxuXHQgICAgICAgKGUuZGVsdGFYIHx8IGUuZGVsdGFaKSA/IDAgOlx0Ly8gU2tpcCBob3Jpem9udGFsL2RlcHRoIHdoZWVsIGV2ZW50c1xyXG5cdCAgICAgICBlLndoZWVsRGVsdGEgPyAoZS53aGVlbERlbHRhWSB8fCBlLndoZWVsRGVsdGEpIC8gMiA6IC8vIExlZ2FjeSBJRSBwaXhlbHNcclxuXHQgICAgICAgKGUuZGV0YWlsICYmIE1hdGguYWJzKGUuZGV0YWlsKSA8IDMyNzY1KSA/IC1lLmRldGFpbCAqIDIwIDogLy8gTGVnYWN5IE1veiBsaW5lc1xyXG5cdCAgICAgICBlLmRldGFpbCA/IGUuZGV0YWlsIC8gLTMyNzY1ICogNjAgOiAvLyBMZWdhY3kgTW96IHBhZ2VzXHJcblx0ICAgICAgIDA7XHJcbn1cclxuXHJcbnZhciBza2lwRXZlbnRzID0ge307XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmFrZVN0b3AoZSkge1xyXG5cdC8vIGZha2VzIHN0b3BQcm9wYWdhdGlvbiBieSBzZXR0aW5nIGEgc3BlY2lhbCBldmVudCBmbGFnLCBjaGVja2VkL3Jlc2V0IHdpdGggc2tpcHBlZChlKVxyXG5cdHNraXBFdmVudHNbZS50eXBlXSA9IHRydWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBza2lwcGVkKGUpIHtcclxuXHR2YXIgZXZlbnRzID0gc2tpcEV2ZW50c1tlLnR5cGVdO1xyXG5cdC8vIHJlc2V0IHdoZW4gY2hlY2tpbmcsIGFzIGl0J3Mgb25seSB1c2VkIGluIG1hcCBjb250YWluZXIgYW5kIHByb3BhZ2F0ZXMgb3V0c2lkZSBvZiB0aGUgbWFwXHJcblx0c2tpcEV2ZW50c1tlLnR5cGVdID0gZmFsc2U7XHJcblx0cmV0dXJuIGV2ZW50cztcclxufVxyXG5cclxuLy8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0V4dGVybmFsVGFyZ2V0KGVsLCBlKSB7XHJcblxyXG5cdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuXHRpZiAoIXJlbGF0ZWQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0dHJ5IHtcclxuXHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuXHRcdFx0cmVsYXRlZCA9IHJlbGF0ZWQucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcbn1cclxuXHJcbnZhciBsYXN0Q2xpY2s7XHJcblxyXG4vLyB0aGlzIGlzIGEgaG9ycmlibGUgd29ya2Fyb3VuZCBmb3IgYSBidWcgaW4gQW5kcm9pZCB3aGVyZSBhIHNpbmdsZSB0b3VjaCB0cmlnZ2VycyB0d28gY2xpY2sgZXZlbnRzXHJcbmZ1bmN0aW9uIGZpbHRlckNsaWNrKGUsIGhhbmRsZXIpIHtcclxuXHR2YXIgdGltZVN0YW1wID0gKGUudGltZVN0YW1wIHx8IChlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LnRpbWVTdGFtcCkpLFxyXG5cdCAgICBlbGFwc2VkID0gbGFzdENsaWNrICYmICh0aW1lU3RhbXAgLSBsYXN0Q2xpY2spO1xyXG5cclxuXHQvLyBhcmUgdGhleSBjbG9zZXIgdG9nZXRoZXIgdGhhbiA1MDBtcyB5ZXQgbW9yZSB0aGFuIDEwMG1zP1xyXG5cdC8vIEFuZHJvaWQgdHlwaWNhbGx5IHRyaWdnZXJzIHRoZW0gfjMwMG1zIGFwYXJ0IHdoaWxlIG11bHRpcGxlIGxpc3RlbmVyc1xyXG5cdC8vIG9uIHRoZSBzYW1lIGV2ZW50IHNob3VsZCBiZSB0cmlnZ2VyZWQgZmFyIGZhc3RlcjtcclxuXHQvLyBvciBjaGVjayBpZiBjbGljayBpcyBzaW11bGF0ZWQgb24gdGhlIGVsZW1lbnQsIGFuZCBpZiBpdCBpcywgcmVqZWN0IGFueSBub24tc2ltdWxhdGVkIGV2ZW50c1xyXG5cclxuXHRpZiAoKGVsYXBzZWQgJiYgZWxhcHNlZCA+IDEwMCAmJiBlbGFwc2VkIDwgNTAwKSB8fCAoZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrICYmICFlLl9zaW11bGF0ZWQpKSB7XHJcblx0XHRzdG9wKGUpO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHRsYXN0Q2xpY2sgPSB0aW1lU3RhbXA7XHJcblxyXG5cdGhhbmRsZXIoZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vbmBdKCNkb21ldmVudC1vbilcclxuZXhwb3J0IHtvbiBhcyBhZGRMaXN0ZW5lcn07XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYEwuRG9tRXZlbnQub2ZmYF0oI2RvbWV2ZW50LW9mZilcclxuZXhwb3J0IHtvZmYgYXMgcmVtb3ZlTGlzdGVuZXJ9O1xyXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG5cbi8qXG4gKiBAY2xhc3MgUG9zQW5pbWF0aW9uXG4gKiBAYWthIEwuUG9zQW5pbWF0aW9uXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBwYW5uaW5nIGFuaW1hdGlvbnMsIHV0aWxpemluZyBDU1MzIFRyYW5zaXRpb25zIGZvciBtb2Rlcm4gYnJvd3NlcnMgYW5kIGEgdGltZXIgZmFsbGJhY2sgZm9yIElFNi05LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIGZ4ID0gbmV3IEwuUG9zQW5pbWF0aW9uKCk7XG4gKiBmeC5ydW4oZWwsIFszMDAsIDUwMF0sIDAuNSk7XG4gKiBgYGBcbiAqXG4gKiBAY29uc3RydWN0b3IgTC5Qb3NBbmltYXRpb24oKVxuICogQ3JlYXRlcyBhIGBQb3NBbmltYXRpb25gIG9iamVjdC5cbiAqXG4gKi9cblxuZXhwb3J0IHZhciBQb3NBbmltYXRpb24gPSBFdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQG1ldGhvZCBydW4oZWw6IEhUTUxFbGVtZW50LCBuZXdQb3M6IFBvaW50LCBkdXJhdGlvbj86IE51bWJlciwgZWFzZUxpbmVhcml0eT86IE51bWJlcilcblx0Ly8gUnVuIGFuIGFuaW1hdGlvbiBvZiBhIGdpdmVuIGVsZW1lbnQgdG8gYSBuZXcgcG9zaXRpb24sIG9wdGlvbmFsbHkgc2V0dGluZ1xuXHQvLyBkdXJhdGlvbiBpbiBzZWNvbmRzIChgMC4yNWAgYnkgZGVmYXVsdCkgYW5kIGVhc2luZyBsaW5lYXJpdHkgZmFjdG9yICgzcmRcblx0Ly8gYXJndW1lbnQgb2YgdGhlIFtjdWJpYyBiZXppZXIgY3VydmVdKGh0dHA6Ly9jdWJpYy1iZXppZXIuY29tLyMwLDAsLjUsMSksXG5cdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuXHRydW46IGZ1bmN0aW9uIChlbCwgbmV3UG9zLCBkdXJhdGlvbiwgZWFzZUxpbmVhcml0eSkge1xuXHRcdHRoaXMuc3RvcCgpO1xuXG5cdFx0dGhpcy5fZWwgPSBlbDtcblx0XHR0aGlzLl9pblByb2dyZXNzID0gdHJ1ZTtcblx0XHR0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDAuMjU7XG5cdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKGVsKTtcblx0XHR0aGlzLl9vZmZzZXQgPSBuZXdQb3Muc3VidHJhY3QodGhpcy5fc3RhcnRQb3MpO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHNcblx0XHR0aGlzLmZpcmUoJ3N0YXJ0Jyk7XG5cblx0XHR0aGlzLl9hbmltYXRlKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzdG9wKClcblx0Ly8gU3RvcHMgdGhlIGFuaW1hdGlvbiAoaWYgY3VycmVudGx5IHJ1bm5pbmcpLlxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fc3RlcCh0cnVlKTtcblx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLl9hbmltSWQgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fYW5pbWF0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fc3RlcCgpO1xuXHR9LFxuXG5cdF9zdGVwOiBmdW5jdGlvbiAocm91bmQpIHtcblx0XHR2YXIgZWxhcHNlZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG5cdFx0aWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlbGFwc2VkIC8gZHVyYXRpb24pLCByb3VuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKDEpO1xuXHRcdFx0dGhpcy5fY29tcGxldGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3J1bkZyYW1lOiBmdW5jdGlvbiAocHJvZ3Jlc3MsIHJvdW5kKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0cG9zLl9yb3VuZCgpO1xuXHRcdH1cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsLCBwb3MpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0ZXA6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyB0aGUgYW5pbWF0aW9uLlxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuXHR9LFxuXG5cdF9jb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1JZCk7XG5cblx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG5cdFx0Ly8gQGV2ZW50IGVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZW5kcy5cblx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuXHR9LFxuXG5cdF9lYXNlT3V0OiBmdW5jdGlvbiAodCkge1xuXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG5cdH1cbn0pO1xuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcclxuaW1wb3J0IHtFUFNHMzg1N30gZnJvbSAnLi4vZ2VvL2Nycy9DUlMuRVBTRzM4NTcnO1xyXG5pbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCB7Qm91bmRzLCB0b0JvdW5kc30gZnJvbSAnLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHMsIHRvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IHtQb3NBbmltYXRpb259IGZyb20gJy4uL2RvbS9Qb3NBbmltYXRpb24nO1xyXG5cclxuLypcclxuICogQGNsYXNzIE1hcFxyXG4gKiBAYWthIEwuTWFwXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIFRoZSBjZW50cmFsIGNsYXNzIG9mIHRoZSBBUEkg4oCUIGl0IGlzIHVzZWQgdG8gY3JlYXRlIGEgbWFwIG9uIGEgcGFnZSBhbmQgbWFuaXB1bGF0ZSBpdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogLy8gaW5pdGlhbGl6ZSB0aGUgbWFwIG9uIHRoZSBcIm1hcFwiIGRpdiB3aXRoIGEgZ2l2ZW4gY2VudGVyIGFuZCB6b29tXHJcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xyXG4gKiBcdGNlbnRlcjogWzUxLjUwNSwgLTAuMDldLFxyXG4gKiBcdHpvb206IDEzXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICovXHJcblxyXG5leHBvcnQgdmFyIE1hcCA9IEV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIFN0YXRlIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBMLkNSUy5FUFNHMzg1N1xyXG5cdFx0Ly8gVGhlIFtDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW1dKCNjcnMpIHRvIHVzZS4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdFxyXG5cdFx0Ly8gc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG5cdFx0Y3JzOiBFUFNHMzg1NyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNlbnRlcjogTGF0TG5nID0gdW5kZWZpbmVkXHJcblx0XHQvLyBJbml0aWFsIGdlb2dyYXBoaWMgY2VudGVyIG9mIHRoZSBtYXBcclxuXHRcdGNlbnRlcjogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcblx0XHQvLyBJbml0aWFsIG1hcCB6b29tIGxldmVsXHJcblx0XHR6b29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAqXHJcblx0XHQvLyBNaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxyXG5cdFx0Ly8gdGhlIGxvd2VzdCBvZiB0aGVpciBgbWluWm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuXHRcdG1pblpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9ICpcclxuXHRcdC8vIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcblx0XHQvLyB0aGUgaGlnaGVzdCBvZiB0aGVpciBgbWF4Wm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuXHRcdG1heFpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogTGF5ZXJbXSA9IFtdXHJcblx0XHQvLyBBcnJheSBvZiBsYXllcnMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAgaW5pdGlhbGx5XHJcblx0XHRsYXllcnM6IFtdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Qm91bmRzOiBMYXRMbmdCb3VuZHMgPSBudWxsXHJcblx0XHQvLyBXaGVuIHRoaXMgb3B0aW9uIGlzIHNldCwgdGhlIG1hcCByZXN0cmljdHMgdGhlIHZpZXcgdG8gdGhlIGdpdmVuXHJcblx0XHQvLyBnZW9ncmFwaGljYWwgYm91bmRzLCBib3VuY2luZyB0aGUgdXNlciBiYWNrIGlmIHRoZSB1c2VyIHRyaWVzIHRvIHBhblxyXG5cdFx0Ly8gb3V0c2lkZSB0aGUgdmlldy4gVG8gc2V0IHRoZSByZXN0cmljdGlvbiBkeW5hbWljYWxseSwgdXNlXHJcblx0XHQvLyBbYHNldE1heEJvdW5kc2BdKCNtYXAtc2V0bWF4Ym91bmRzKSBtZXRob2QuXHJcblx0XHRtYXhCb3VuZHM6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlciA9ICpcclxuXHRcdC8vIFRoZSBkZWZhdWx0IG1ldGhvZCBmb3IgZHJhd2luZyB2ZWN0b3IgbGF5ZXJzIG9uIHRoZSBtYXAuIGBMLlNWR2BcclxuXHRcdC8vIG9yIGBMLkNhbnZhc2AgYnkgZGVmYXVsdCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0LlxyXG5cdFx0cmVuZGVyZXI6IHVuZGVmaW5lZCxcclxuXHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gQW5pbWF0aW9uIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCB6b29tIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxyXG5cdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IE51bWJlciA9IDRcclxuXHRcdC8vIFdvbid0IGFuaW1hdGUgem9vbSBpZiB0aGUgem9vbSBkaWZmZXJlbmNlIGV4Y2VlZHMgdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IDQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBmYWRlQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdGlsZSBmYWRlIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxyXG5cdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0ZmFkZUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1hcmtlclpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIG1hcmtlcnMgYW5pbWF0ZSB0aGVpciB6b29tIHdpdGggdGhlIHpvb20gYW5pbWF0aW9uLCBpZiBkaXNhYmxlZFxyXG5cdFx0Ly8gdGhleSB3aWxsIGRpc2FwcGVhciBmb3IgdGhlIGxlbmd0aCBvZiB0aGUgYW5pbWF0aW9uLiBCeSBkZWZhdWx0IGl0J3NcclxuXHRcdC8vIGVuYWJsZWQgaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0bWFya2VyWm9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYW5zZm9ybTNETGltaXQ6IE51bWJlciA9IDJeMjNcclxuXHRcdC8vIERlZmluZXMgdGhlIG1heGltdW0gc2l6ZSBvZiBhIENTUyB0cmFuc2xhdGlvbiB0cmFuc2Zvcm0uIFRoZSBkZWZhdWx0XHJcblx0XHQvLyB2YWx1ZSBzaG91bGQgbm90IGJlIGNoYW5nZWQgdW5sZXNzIGEgd2ViIGJyb3dzZXIgcG9zaXRpb25zIGxheWVycyBpblxyXG5cdFx0Ly8gdGhlIHdyb25nIHBsYWNlIGFmdGVyIGRvaW5nIGEgbGFyZ2UgYHBhbkJ5YC5cclxuXHRcdHRyYW5zZm9ybTNETGltaXQ6IDgzODg2MDgsIC8vIFByZWNpc2lvbiBsaW1pdCBvZiBhIDMyLWJpdCBmbG9hdFxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gem9vbVNuYXA6IE51bWJlciA9IDFcclxuXHRcdC8vIEZvcmNlcyB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB0byBhbHdheXMgYmUgYSBtdWx0aXBsZSBvZiB0aGlzLCBwYXJ0aWN1bGFybHlcclxuXHRcdC8vIHJpZ2h0IGFmdGVyIGEgW2BmaXRCb3VuZHMoKWBdKCNtYXAtZml0Ym91bmRzKSBvciBhIHBpbmNoLXpvb20uXHJcblx0XHQvLyBCeSBkZWZhdWx0LCB0aGUgem9vbSBsZXZlbCBzbmFwcyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyOyBsb3dlciB2YWx1ZXNcclxuXHRcdC8vIChlLmcuIGAwLjVgIG9yIGAwLjFgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS4gQSB2YWx1ZSBvZiBgMGBcclxuXHRcdC8vIG1lYW5zIHRoZSB6b29tIGxldmVsIHdpbGwgbm90IGJlIHNuYXBwZWQgYWZ0ZXIgYGZpdEJvdW5kc2Agb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0em9vbVNuYXA6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tRGVsdGE6IE51bWJlciA9IDFcclxuXHRcdC8vIENvbnRyb2xzIGhvdyBtdWNoIHRoZSBtYXAncyB6b29tIGxldmVsIHdpbGwgY2hhbmdlIGFmdGVyIGFcclxuXHRcdC8vIFtgem9vbUluKClgXSgjbWFwLXpvb21pbiksIFtgem9vbU91dCgpYF0oI21hcC16b29tb3V0KSwgcHJlc3NpbmcgYCtgXHJcblx0XHQvLyBvciBgLWAgb24gdGhlIGtleWJvYXJkLCBvciB1c2luZyB0aGUgW3pvb20gY29udHJvbHNdKCNjb250cm9sLXpvb20pLlxyXG5cdFx0Ly8gVmFsdWVzIHNtYWxsZXIgdGhhbiBgMWAgKGUuZy4gYDAuNWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LlxyXG5cdFx0em9vbURlbHRhOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhY2tSZXNpemU6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgYXV0b21hdGljYWxseSBoYW5kbGVzIGJyb3dzZXIgd2luZG93IHJlc2l6ZSB0byB1cGRhdGUgaXRzZWxmLlxyXG5cdFx0dHJhY2tSZXNpemU6IHRydWVcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBNYWtlIHN1cmUgdG8gYXNzaWduIGludGVybmFsIGZsYWdzIGF0IHRoZSBiZWdpbm5pbmcsXHJcblx0XHQvLyB0byBhdm9pZCBpbmNvbnNpc3RlbnQgc3RhdGUgaW4gc29tZSBlZGdlIGNhc2VzLlxyXG5cdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcihpZCk7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblxyXG5cdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG5cdFx0dGhpcy5fb25SZXNpemUgPSBVdGlsLmJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKG9wdGlvbnMuem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuY2VudGVyICYmIG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc2V0Vmlldyh0b0xhdExuZyhvcHRpb25zLmNlbnRlciksIG9wdGlvbnMuem9vbSwge3Jlc2V0OiB0cnVlfSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBEb21VdGlsLlRSQU5TSVRJT04gJiYgQnJvd3Nlci5hbnkzZCAmJiAhQnJvd3Nlci5tb2JpbGVPcGVyYSAmJlxyXG5cdFx0XHRcdHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xyXG5cdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdHRoaXMuX2NyZWF0ZUFuaW1Qcm94eSgpO1xyXG5cdFx0XHREb21FdmVudC5vbih0aGlzLl9wcm94eSwgRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fY2F0Y2hUcmFuc2l0aW9uRW5kLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hZGRMYXllcnModGhpcy5vcHRpb25zLmxheWVycyk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRWaWV3KGNlbnRlcjogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgd2l0aCB0aGUgZ2l2ZW5cclxuXHQvLyBhbmltYXRpb24gb3B0aW9ucy5cclxuXHRzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblx0XHRjZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcih0b0xhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbSA9IFV0aWwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGV9LCBvcHRpb25zLnpvb20pO1xyXG5cdFx0XHRcdG9wdGlvbnMucGFuID0gVXRpbC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSwgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb259LCBvcHRpb25zLnBhbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cclxuXHRcdFx0dmFyIG1vdmVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cclxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6XHJcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XHJcblxyXG5cdFx0XHRpZiAobW92ZWQpIHtcclxuXHRcdFx0XHQvLyBwcmV2ZW50IHJlc2l6ZSBoYW5kbGVyIGNhbGwsIHRoZSB2aWV3IHdpbGwgcmVmcmVzaCBhZnRlciBhbmltYXRpb24gYW55d2F5XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRpb24gZGlkbid0IHN0YXJ0LCBqdXN0IHJlc2V0IHRoZSBtYXAgdmlld1xyXG5cdFx0dGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tKHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgem9vbSBvZiB0aGUgbWFwLlxyXG5cdHNldFpvb206IGZ1bmN0aW9uICh6b29tLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tSW4oZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gSW5jcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbUluOiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tT3V0KGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIERlY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG5cdHpvb21PdXQ6IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSAtIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBnZW9ncmFwaGljYWwgcG9pbnQgb24gdGhlIG1hcFxyXG5cdC8vIHN0YXRpb25hcnkgKGUuZy4gdXNlZCBpbnRlcm5hbGx5IGZvciBzY3JvbGwgem9vbSBhbmQgZG91YmxlLWNsaWNrIHpvb20pLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChvZmZzZXQ6IFBvaW50LCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgcGl4ZWwgb24gdGhlIG1hcCAocmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lcikgc3RhdGlvbmFyeS5cclxuXHRzZXRab29tQXJvdW5kOiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIGNvbnRhaW5lclBvaW50ID0gbGF0bG5nIGluc3RhbmNlb2YgUG9pbnQgPyBsYXRsbmcgOiB0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nKSxcclxuXHJcblx0XHQgICAgY2VudGVyT2Zmc2V0ID0gY29udGFpbmVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLm11bHRpcGx5QnkoMSAtIDEgLyBzY2FsZSksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF0TG5nKHZpZXdIYWxmLmFkZChjZW50ZXJPZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KG5ld0NlbnRlciwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Qm91bmRzQ2VudGVyWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0Ym91bmRzID0gYm91bmRzLmdldEJvdW5kcyA/IGJvdW5kcy5nZXRCb3VuZHMoKSA6IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cclxuXHRcdCAgICB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIHBhZGRpbmdUTC5hZGQocGFkZGluZ0JSKSk7XHJcblxyXG5cdFx0em9vbSA9ICh0eXBlb2Ygb3B0aW9ucy5tYXhab29tID09PSAnbnVtYmVyJykgPyBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIHpvb20pIDogem9vbTtcclxuXHJcblx0XHRpZiAoem9vbSA9PT0gSW5maW5pdHkpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRjZW50ZXI6IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdFx0XHR6b29tOiB6b29tXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdPZmZzZXQgPSBwYWRkaW5nQlIuc3VidHJhY3QocGFkZGluZ1RMKS5kaXZpZGVCeSgyKSxcclxuXHJcblx0XHQgICAgc3dQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIG5lUG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICBjZW50ZXIgPSB0aGlzLnVucHJvamVjdChzd1BvaW50LmFkZChuZVBvaW50KS5kaXZpZGVCeSgyKS5hZGQocGFkZGluZ09mZnNldCksIHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZml0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgY29udGFpbnMgdGhlIGdpdmVuIGdlb2dyYXBoaWNhbCBib3VuZHMgd2l0aCB0aGVcclxuXHQvLyBtYXhpbXVtIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcblx0Zml0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCb3VuZHMgYXJlIG5vdCB2YWxpZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRXb3JsZChvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgbW9zdGx5IGNvbnRhaW5zIHRoZSB3aG9sZSB3b3JsZCB3aXRoIHRoZSBtYXhpbXVtXHJcblx0Ly8gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRXb3JsZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLmZpdEJvdW5kcyhbWy05MCwgLTE4MF0sIFs5MCwgMTgwXV0sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuVG8obGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gYSBnaXZlbiBjZW50ZXIuXHJcblx0cGFuVG86IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHsgLy8gKExhdExuZylcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcoY2VudGVyLCB0aGlzLl96b29tLCB7cGFuOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5CeShvZmZzZXQ6IFBvaW50LCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIGJ5IGEgZ2l2ZW4gbnVtYmVyIG9mIHBpeGVscyAoYW5pbWF0ZWQpLlxyXG5cdHBhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0LCBvcHRpb25zKSB7XHJcblx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkucm91bmQoKTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdH1cclxuXHRcdC8vIElmIHdlIHBhbiB0b28gZmFyLCBDaHJvbWUgZ2V0cyBpc3N1ZXMgd2l0aCB0aWxlc1xyXG5cdFx0Ly8gYW5kIG1ha2VzIHRoZW0gZGlzYXBwZWFyIG9yIGFwcGVhciBpbiB0aGUgd3JvbmcgcGxhY2UgKHNsaWdodGx5IG9mZnNldCkgIzI2MDJcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHtcclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMudW5wcm9qZWN0KHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKS5hZGQob2Zmc2V0KSksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0gPSBuZXcgUG9zQW5pbWF0aW9uKCk7XHJcblxyXG5cdFx0XHR0aGlzLl9wYW5BbmltLm9uKHtcclxuXHRcdFx0XHQnc3RlcCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvblN0ZXAsXHJcblx0XHRcdFx0J2VuZCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZFxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBkb24ndCBmaXJlIG1vdmVzdGFydCBpZiBhbmltYXRpbmcgaW5lcnRpYVxyXG5cdFx0aWYgKCFvcHRpb25zLm5vTW92ZVN0YXJ0KSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYW5pbWF0ZSBwYW4gdW5sZXNzIGFuaW1hdGU6IGZhbHNlIHNwZWNpZmllZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cclxuXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ucnVuKHRoaXMuX21hcFBhbmUsIG5ld1Bvcywgb3B0aW9ucy5kdXJhdGlvbiB8fCAwLjI1LCBvcHRpb25zLmVhc2VMaW5lYXJpdHkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG8obGF0bG5nOiBMYXRMbmcsIHpvb20/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgcGVyZm9ybWluZyBhIHNtb290aFxyXG5cdC8vIHBhbi16b29tIGFuaW1hdGlvbi5cclxuXHRmbHlUbzogZnVuY3Rpb24gKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIUJyb3dzZXIuYW55M2QpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHR2YXIgZnJvbSA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcclxuXHRcdCAgICB0byA9IHRoaXMucHJvamVjdCh0YXJnZXRDZW50ZXIpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBzdGFydFpvb20gPSB0aGlzLl96b29tO1xyXG5cclxuXHRcdHRhcmdldENlbnRlciA9IHRvTGF0TG5nKHRhcmdldENlbnRlcik7XHJcblx0XHR0YXJnZXRab29tID0gdGFyZ2V0Wm9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogdGFyZ2V0Wm9vbTtcclxuXHJcblx0XHR2YXIgdzAgPSBNYXRoLm1heChzaXplLngsIHNpemUueSksXHJcblx0XHQgICAgdzEgPSB3MCAqIHRoaXMuZ2V0Wm9vbVNjYWxlKHN0YXJ0Wm9vbSwgdGFyZ2V0Wm9vbSksXHJcblx0XHQgICAgdTEgPSAodG8uZGlzdGFuY2VUbyhmcm9tKSkgfHwgMSxcclxuXHRcdCAgICByaG8gPSAxLjQyLFxyXG5cdFx0ICAgIHJobzIgPSByaG8gKiByaG87XHJcblxyXG5cdFx0ZnVuY3Rpb24gcihpKSB7XHJcblx0XHRcdHZhciBzMSA9IGkgPyAtMSA6IDEsXHJcblx0XHRcdCAgICBzMiA9IGkgPyB3MSA6IHcwLFxyXG5cdFx0XHQgICAgdDEgPSB3MSAqIHcxIC0gdzAgKiB3MCArIHMxICogcmhvMiAqIHJobzIgKiB1MSAqIHUxLFxyXG5cdFx0XHQgICAgYjEgPSAyICogczIgKiByaG8yICogdTEsXHJcblx0XHRcdCAgICBiID0gdDEgLyBiMSxcclxuXHRcdFx0ICAgIHNxID0gTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiO1xyXG5cclxuXHRcdFx0ICAgIC8vIHdvcmthcm91bmQgZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBidWcgd2hlbiBzcSA9IDAsIGxvZyA9IC1JbmZpbml0ZSxcclxuXHRcdFx0ICAgIC8vIHRodXMgdHJpZ2dlcmluZyBhbiBpbmZpbml0ZSBsb29wIGluIGZseVRvXHJcblx0XHRcdCAgICB2YXIgbG9nID0gc3EgPCAwLjAwMDAwMDAwMSA/IC0xOCA6IE1hdGgubG9nKHNxKTtcclxuXHJcblx0XHRcdHJldHVybiBsb2c7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2luaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gdGFuaChuKSB7IHJldHVybiBzaW5oKG4pIC8gY29zaChuKTsgfVxyXG5cclxuXHRcdHZhciByMCA9IHIoMCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gdyhzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7IH1cclxuXHRcdGZ1bmN0aW9uIHUocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yOyB9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZWFzZU91dCh0KSB7IHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIDEuNSk7IH1cclxuXHJcblx0XHR2YXIgc3RhcnQgPSBEYXRlLm5vdygpLFxyXG5cdFx0ICAgIFMgPSAocigxKSAtIHIwKSAvIHJobyxcclxuXHRcdCAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPyAxMDAwICogb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDAgKiBTICogMC44O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGZyYW1lKCkge1xyXG5cdFx0XHR2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24sXHJcblx0XHRcdCAgICBzID0gZWFzZU91dCh0KSAqIFM7XHJcblxyXG5cdFx0XHRpZiAodCA8PSAxKSB7XHJcblx0XHRcdFx0dGhpcy5fZmx5VG9GcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShmcmFtZSwgdGhpcyk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX21vdmUoXHJcblx0XHRcdFx0XHR0aGlzLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWJ0cmFjdChmcm9tKS5tdWx0aXBseUJ5KHUocykgLyB1MSkpLCBzdGFydFpvb20pLFxyXG5cdFx0XHRcdFx0dGhpcy5nZXRTY2FsZVpvb20odzAgLyB3KHMpLCBzdGFydFpvb20pLFxyXG5cdFx0XHRcdFx0e2ZseVRvOiB0cnVlfSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXNcclxuXHRcdFx0XHRcdC5fbW92ZSh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20pXHJcblx0XHRcdFx0XHQuX21vdmVFbmQodHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlU3RhcnQodHJ1ZSwgb3B0aW9ucy5ub01vdmVTdGFydCk7XHJcblxyXG5cdFx0ZnJhbWUuY2FsbCh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG9Cb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgd2l0aCBhIHNtb290aCBhbmltYXRpb24gbGlrZSBbYGZseVRvYF0oI21hcC1mbHl0byksXHJcblx0Ly8gYnV0IHRha2VzIGEgYm91bmRzIHBhcmFtZXRlciBsaWtlIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5cdGZseVRvQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZmx5VG8odGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Qm91bmRzKGJvdW5kczogQm91bmRzKTogdGhpc1xyXG5cdC8vIFJlc3RyaWN0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIGdpdmVuIGJvdW5kcyAoc2VlIHRoZSBbbWF4Qm91bmRzXSgjbWFwLW1heGJvdW5kcykgb3B0aW9uKS5cclxuXHRzZXRNYXhCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBudWxsO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gYm91bmRzO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWluWm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21pblpvb21dKCNtYXAtbWluem9vbSkgb3B0aW9uKS5cclxuXHRzZXRNaW5ab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHRcdHRoaXMub3B0aW9ucy5taW5ab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heFpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttYXhab29tXSgjbWFwLW1heHpvb20pIG9wdGlvbikuXHJcblx0c2V0TWF4Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGVCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gdGhlIGNsb3Nlc3QgdmlldyB0aGF0IHdvdWxkIGxpZSBpbnNpZGUgdGhlIGdpdmVuIGJvdW5kcyAoaWYgaXQncyBub3QgYWxyZWFkeSksIGNvbnRyb2xsaW5nIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIG9wdGlvbnMgc3BlY2lmaWMsIGlmIGFueS5cclxuXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIHRvTGF0TG5nQm91bmRzKGJvdW5kcykpO1xyXG5cclxuXHRcdGlmICghY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7XHJcblx0XHRcdHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuSW5zaWRlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdGhlIG1pbmltdW0gYW1vdW50IHRvIG1ha2UgdGhlIGBsYXRsbmdgIHZpc2libGUuIFVzZVxyXG5cdC8vIGBwYWRkaW5nYCwgYHBhZGRpbmdUb3BMZWZ0YCBhbmQgYHBhZGRpbmdUb3BSaWdodGAgb3B0aW9ucyB0byBmaXRcclxuXHQvLyB0aGUgZGlzcGxheSB0byBtb3JlIHJlc3RyaWN0ZWQgYm91bmRzLCBsaWtlIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5cdC8vIElmIGBsYXRsbmdgIGlzIGFscmVhZHkgd2l0aGluIHRoZSAob3B0aW9uYWxseSBwYWRkZWQpIGRpc3BsYXkgYm91bmRzLFxyXG5cdC8vIHRoZSBtYXAgd2lsbCBub3QgYmUgcGFubmVkLlxyXG5cdHBhbkluc2lkZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgcGl4ZWxDZW50ZXIgPSB0aGlzLnByb2plY3QoY2VudGVyKSxcclxuXHRcdCAgICBwaXhlbFBvaW50ID0gdGhpcy5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgcGl4ZWxCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgaGFsZlBpeGVsQm91bmRzID0gcGl4ZWxCb3VuZHMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIHBhZGRlZEJvdW5kcyA9IHRvQm91bmRzKFtwaXhlbEJvdW5kcy5taW4uYWRkKHBhZGRpbmdUTCksIHBpeGVsQm91bmRzLm1heC5zdWJ0cmFjdChwYWRkaW5nQlIpXSk7XHJcblxyXG5cdFx0aWYgKCFwYWRkZWRCb3VuZHMuY29udGFpbnMocGl4ZWxQb2ludCkpIHtcclxuXHRcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuXHRcdFx0dmFyIGRpZmYgPSBwaXhlbENlbnRlci5zdWJ0cmFjdChwaXhlbFBvaW50KSxcclxuXHRcdFx0ICAgIG5ld0NlbnRlciA9IHRvUG9pbnQocGl4ZWxQb2ludC54ICsgZGlmZi54LCBwaXhlbFBvaW50LnkgKyBkaWZmLnkpO1xyXG5cclxuXHRcdFx0aWYgKHBpeGVsUG9pbnQueCA8IHBhZGRlZEJvdW5kcy5taW4ueCB8fCBwaXhlbFBvaW50LnggPiBwYWRkZWRCb3VuZHMubWF4LngpIHtcclxuXHRcdFx0XHRuZXdDZW50ZXIueCA9IHBpeGVsQ2VudGVyLnggLSBkaWZmLng7XHJcblx0XHRcdFx0aWYgKGRpZmYueCA+IDApIHtcclxuXHRcdFx0XHRcdG5ld0NlbnRlci54ICs9IGhhbGZQaXhlbEJvdW5kcy54IC0gcGFkZGluZ1RMLng7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG5ld0NlbnRlci54IC09IGhhbGZQaXhlbEJvdW5kcy54IC0gcGFkZGluZ0JSLng7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChwaXhlbFBvaW50LnkgPCBwYWRkZWRCb3VuZHMubWluLnkgfHwgcGl4ZWxQb2ludC55ID4gcGFkZGVkQm91bmRzLm1heC55KSB7XHJcblx0XHRcdFx0bmV3Q2VudGVyLnkgPSBwaXhlbENlbnRlci55IC0gZGlmZi55O1xyXG5cdFx0XHRcdGlmIChkaWZmLnkgPiAwKSB7XHJcblx0XHRcdFx0XHRuZXdDZW50ZXIueSArPSBoYWxmUGl4ZWxCb3VuZHMueSAtIHBhZGRpbmdUTC55O1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRuZXdDZW50ZXIueSAtPSBoYWxmUGl4ZWxCb3VuZHMueSAtIHBhZGRpbmdCUi55O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnBhblRvKHRoaXMudW5wcm9qZWN0KG5ld0NlbnRlciksIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUob3B0aW9uczogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuIElmIGBvcHRpb25zLnBhbmAgaXMgYGZhbHNlYCwgcGFubmluZyB3aWxsIG5vdCBvY2N1ci5cclxuXHQvLyBJZiBgb3B0aW9ucy5kZWJvdW5jZU1vdmVlbmRgIGlzIGB0cnVlYCwgaXQgd2lsbCBkZWxheSBgbW92ZWVuZGAgZXZlbnQgc29cclxuXHQvLyB0aGF0IGl0IGRvZXNuJ3QgaGFwcGVuIG9mdGVuIGV2ZW4gaWYgdGhlIG1ldGhvZCBpcyBjYWxsZWQgbWFueVxyXG5cdC8vIHRpbWVzIGluIGEgcm93LlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKGFuaW1hdGU6IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LlxyXG5cdGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRvcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuXHRcdFx0cGFuOiB0cnVlXHJcblx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG5cdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdC8vIEBldmVudCByZXNpemU6IFJlc2l6ZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGBwYW5Ub2Agb3IgYGZseVRvYCBhbmltYXRpb24sIGlmIGFueS5cclxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnNldFpvb20odGhpcy5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEdlb2xvY2F0aW9uIG1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGxvY2F0ZShvcHRpb25zPzogTG9jYXRlIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gVHJpZXMgdG8gbG9jYXRlIHRoZSB1c2VyIHVzaW5nIHRoZSBHZW9sb2NhdGlvbiBBUEksIGZpcmluZyBhIFtgbG9jYXRpb25mb3VuZGBdKCNtYXAtbG9jYXRpb25mb3VuZClcclxuXHQvLyBldmVudCB3aXRoIGxvY2F0aW9uIGRhdGEgb24gc3VjY2VzcyBvciBhIFtgbG9jYXRpb25lcnJvcmBdKCNtYXAtbG9jYXRpb25lcnJvcikgZXZlbnQgb24gZmFpbHVyZSxcclxuXHQvLyBhbmQgb3B0aW9uYWxseSBzZXRzIHRoZSBtYXAgdmlldyB0byB0aGUgdXNlcidzIGxvY2F0aW9uIHdpdGggcmVzcGVjdCB0b1xyXG5cdC8vIGRldGVjdGlvbiBhY2N1cmFjeSAob3IgdG8gdGhlIHdvcmxkIHZpZXcgaWYgZ2VvbG9jYXRpb24gZmFpbGVkKS5cclxuXHQvLyBOb3RlIHRoYXQsIGlmIHlvdXIgcGFnZSBkb2Vzbid0IHVzZSBIVFRQUywgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIGluXHJcblx0Ly8gbW9kZXJuIGJyb3dzZXJzIChbQ2hyb21lIDUwIGFuZCBuZXdlcl0oaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2Rldi9Ib21lL2Nocm9taXVtLXNlY3VyaXR5L2RlcHJlY2F0aW5nLXBvd2VyZnVsLWZlYXR1cmVzLW9uLWluc2VjdXJlLW9yaWdpbnMpKVxyXG5cdC8vIFNlZSBgTG9jYXRlIG9wdGlvbnNgIGZvciBtb3JlIGRldGFpbHMuXHJcblx0bG9jYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHR0aW1lb3V0OiAxMDAwMCxcclxuXHRcdFx0d2F0Y2g6IGZhbHNlXHJcblx0XHRcdC8vIHNldFZpZXc6IGZhbHNlXHJcblx0XHRcdC8vIG1heFpvb206IDxOdW1iZXI+XHJcblx0XHRcdC8vIG1heGltdW1BZ2U6IDBcclxuXHRcdFx0Ly8gZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxyXG5cdFx0fSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0aWYgKCEoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe1xyXG5cdFx0XHRcdGNvZGU6IDAsXHJcblx0XHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIG5vdCBzdXBwb3J0ZWQuJ1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9uUmVzcG9uc2UgPSBVdGlsLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcblx0XHQgICAgb25FcnJvciA9IFV0aWwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG5cdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3RvcExvY2F0ZSgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcblx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcblx0Ly8gYHtzZXRWaWV3OiB0cnVlfWAuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZXJyb3I6IEVycm9yRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMYXRMbmcobGF0LCBsbmcpLFxyXG5cdFx0ICAgIGJvdW5kcyA9IGxhdGxuZy50b0JvdW5kcyhwb3MuY29vcmRzLmFjY3VyYWN5ICogMiksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG5cdFx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpO1xyXG5cdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCBvcHRpb25zLm1heFpvb20gPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heFpvb20pIDogem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuXHRcdFx0dGltZXN0YW1wOiBwb3MudGltZXN0YW1wXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG5cdFx0XHRpZiAodHlwZW9mIHBvcy5jb29yZHNbaV0gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdFx0ZGF0YVtpXSA9IHBvcy5jb29yZHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25mb3VuZDogTG9jYXRpb25FdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZClcclxuXHRcdC8vIHdlbnQgc3VjY2Vzc2Z1bGx5LlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmZvdW5kJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETyBBcHByb3ByaWF0ZSBkb2NzIHNlY3Rpb24/XHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgYWRkSGFuZGxlcihuYW1lOiBTdHJpbmcsIEhhbmRsZXJDbGFzczogRnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gQWRkcyBhIG5ldyBgSGFuZGxlcmAgdG8gdGhlIG1hcCwgZ2l2ZW4gaXRzIG5hbWUgYW5kIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG5cdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIChuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcclxuXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuXHRcdFx0aGFuZGxlci5lbmFibGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZSgpOiB0aGlzXHJcblx0Ly8gRGVzdHJveXMgdGhlIG1hcCBhbmQgY2xlYXJzIGFsbCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jb250YWluZXJJZCAhPT0gdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBiZWluZyByZXVzZWQgYnkgYW5vdGhlciBpbnN0YW5jZScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIHRocm93cyBlcnJvciBpbiBJRTYtOFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkO1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVySWQ7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkID0gdW5kZWZpbmVkO1xyXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlICovXHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lcklkID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9sb2NhdGlvbldhdGNoSWQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnN0b3BMb2NhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NsZWFyQ29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9jbGVhckNvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9yZXNpemVSZXF1ZXN0KSB7XHJcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jbGVhckhhbmRsZXJzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgdW5sb2FkOiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgZGVzdHJveWVkIHdpdGggW3JlbW92ZV0oI21hcC1yZW1vdmUpIG1ldGhvZC5cclxuXHRcdFx0dGhpcy5maXJlKCd1bmxvYWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLnJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX3BhbmVzKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3BhbmVzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX3BhbmVzID0gW107XHJcblx0XHRkZWxldGUgdGhpcy5fbWFwUGFuZTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9yZW5kZXJlcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVQYW5lKG5hbWU6IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENyZWF0ZXMgYSBuZXcgW21hcCBwYW5lXSgjbWFwLXBhbmUpIHdpdGggdGhlIGdpdmVuIG5hbWUgaWYgaXQgZG9lc24ndCBleGlzdCBhbHJlYWR5LFxyXG5cdC8vIHRoZW4gcmV0dXJucyBpdC4gVGhlIHBhbmUgaXMgY3JlYXRlZCBhcyBhIGNoaWxkIG9mIGBjb250YWluZXJgLCBvclxyXG5cdC8vIGFzIGEgY2hpbGQgb2YgdGhlIG1haW4gbWFwIHBhbmUgaWYgbm90IHNldC5cclxuXHRjcmVhdGVQYW5lOiBmdW5jdGlvbiAobmFtZSwgY29udGFpbmVyKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtcGFuZScgKyAobmFtZSA/ICcgbGVhZmxldC0nICsgbmFtZS5yZXBsYWNlKCdQYW5lJywgJycpICsgJy1wYW5lJyA6ICcnKSxcclxuXHRcdCAgICBwYW5lID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyIHx8IHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmIChuYW1lKSB7XHJcblx0XHRcdHRoaXMuX3BhbmVzW25hbWVdID0gcGFuZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIEdldHRpbmcgTWFwIFN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBjZW50ZXIgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RDZW50ZXIgJiYgIXRoaXMuX21vdmVkKCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2xhc3RDZW50ZXI7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXAgdmlld1xyXG5cdGdldFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl96b29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgdmlzaWJsZSBpbiB0aGUgY3VycmVudCBtYXAgdmlld1xyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBzdyA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRCb3R0b21MZWZ0KCkpLFxyXG5cdFx0ICAgIG5lID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldFRvcFJpZ2h0KCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKHN3LCBuZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNaW5ab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtaW5ab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKSwgb3IgYDBgIGJ5IGRlZmF1bHQuXHJcblx0Z2V0TWluWm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9sYXllcnNNaW5ab29tIHx8IDAgOiB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1heFpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1heFpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLlxyXG5cdGdldE1heFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID9cclxuXHRcdFx0KHRoaXMuX2xheWVyc01heFpvb20gPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogdGhpcy5fbGF5ZXJzTWF4Wm9vbSkgOlxyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kc1pvb20oYm91bmRzOiBMYXRMbmdCb3VuZHMsIGluc2lkZT86IEJvb2xlYW4sIHBhZGRpbmc/OiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgZ2l2ZW4gYm91bmRzIGZpdCB0byB0aGUgbWFwXHJcblx0Ly8gdmlldyBpbiBpdHMgZW50aXJldHkuIElmIGBpbnNpZGVgIChvcHRpb25hbCkgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG1ldGhvZFxyXG5cdC8vIGluc3RlYWQgcmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBtYXAgdmlldyBmaXRzIGludG9cclxuXHQvLyB0aGUgZ2l2ZW4gYm91bmRzIGluIGl0cyBlbnRpcmV0eS5cclxuXHRnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHsgLy8gKExhdExuZ0JvdW5kc1ssIEJvb2xlYW4sIFBvaW50XSkgLT4gTnVtYmVyXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cdFx0cGFkZGluZyA9IHRvUG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuXHRcdHZhciB6b29tID0gdGhpcy5nZXRab29tKCkgfHwgMCxcclxuXHRcdCAgICBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdCAgICBzZSA9IGJvdW5kcy5nZXRTb3V0aEVhc3QoKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCkuc3VidHJhY3QocGFkZGluZyksXHJcblx0XHQgICAgYm91bmRzU2l6ZSA9IHRvQm91bmRzKHRoaXMucHJvamVjdChzZSwgem9vbSksIHRoaXMucHJvamVjdChudywgem9vbSkpLmdldFNpemUoKSxcclxuXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDEsXHJcblx0XHQgICAgc2NhbGV4ID0gc2l6ZS54IC8gYm91bmRzU2l6ZS54LFxyXG5cdFx0ICAgIHNjYWxleSA9IHNpemUueSAvIGJvdW5kc1NpemUueSxcclxuXHRcdCAgICBzY2FsZSA9IGluc2lkZSA/IE1hdGgubWF4KHNjYWxleCwgc2NhbGV5KSA6IE1hdGgubWluKHNjYWxleCwgc2NhbGV5KTtcclxuXHJcblx0XHR6b29tID0gdGhpcy5nZXRTY2FsZVpvb20oc2NhbGUsIHpvb20pO1xyXG5cclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyAoc25hcCAvIDEwMCkpICogKHNuYXAgLyAxMDApOyAvLyBkb24ndCBqdW1wIGlmIHdpdGhpbiAxJSBvZiBhIHNuYXAgbGV2ZWxcclxuXHRcdFx0em9vbSA9IGluc2lkZSA/IE1hdGguY2VpbCh6b29tIC8gc25hcCkgKiBzbmFwIDogTWF0aC5mbG9vcih6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgbWFwIGNvbnRhaW5lciAoaW4gcGl4ZWxzKS5cclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX3NpemUgfHwgdGhpcy5fc2l6ZUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBQb2ludChcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggfHwgMCxcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0IHx8IDApO1xyXG5cclxuXHRcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zaXplLmNsb25lKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbEJvdW5kcygpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgbWFwIHZpZXcgaW4gcHJvamVjdGVkIHBpeGVsXHJcblx0Ly8gY29vcmRpbmF0ZXMgKHNvbWV0aW1lcyB1c2VmdWwgaW4gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHRvcExlZnRQb2ludCA9IHRoaXMuX2dldFRvcExlZnRQb2ludChjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHModG9wTGVmdFBvaW50LCB0b3BMZWZ0UG9pbnQuYWRkKHRoaXMuZ2V0U2l6ZSgpKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETzogQ2hlY2sgc2VtYW50aWNzIC0gaXNuJ3QgdGhlIHBpeGVsIG9yaWdpbiB0aGUgMCwwIGNvb3JkIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIG1hcCBwYW5lPyBcImxlZnQgcG9pbnQgb2YgdGhlIG1hcCBsYXllclwiIGNhbiBiZSBjb25mdXNpbmcsIHNwZWNpYWxseVxyXG5cdC8vIHNpbmNlIHRoZXJlIGNhbiBiZSBuZWdhdGl2ZSBvZmZzZXRzLlxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxPcmlnaW4oKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0ZWQgcGl4ZWwgY29vcmRpbmF0ZXMgb2YgdGhlIHRvcCBsZWZ0IHBvaW50IG9mXHJcblx0Ly8gdGhlIG1hcCBsYXllciAodXNlZnVsIGluIGN1c3RvbSBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsT3JpZ2luOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxPcmlnaW47XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbFdvcmxkQm91bmRzKHpvb20/OiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSB3b3JsZCdzIGJvdW5kcyBpbiBwaXhlbCBjb29yZGluYXRlcyBmb3Igem9vbSBsZXZlbCBgem9vbWAuXHJcblx0Ly8gSWYgYHpvb21gIGlzIG9taXR0ZWQsIHRoZSBtYXAncyBjdXJyZW50IHpvb20gbGV2ZWwgaXMgdXNlZC5cclxuXHRnZXRQaXhlbFdvcmxkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZ2V0UHJvamVjdGVkQm91bmRzKHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmUocGFuZTogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIGEgW21hcCBwYW5lXSgjbWFwLXBhbmUpLCBnaXZlbiBpdHMgbmFtZSBvciBpdHMgSFRNTCBlbGVtZW50IChpdHMgaWRlbnRpdHkpLlxyXG5cdGdldFBhbmU6IGZ1bmN0aW9uIChwYW5lKSB7XHJcblx0XHRyZXR1cm4gdHlwZW9mIHBhbmUgPT09ICdzdHJpbmcnID8gdGhpcy5fcGFuZXNbcGFuZV0gOiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZXMoKTogT2JqZWN0XHJcblx0Ly8gUmV0dXJucyBhIHBsYWluIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgW3BhbmVzXSgjbWFwLXBhbmUpIGFzIGtleXMgYW5kXHJcblx0Ly8gdGhlIHBhbmVzIGFzIHZhbHVlcy5cclxuXHRnZXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhbmVzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBtYXAuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBDb252ZXJzaW9uIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tU2NhbGUodG9ab29tOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSBmYWN0b3IgdG8gYmUgYXBwbGllZCB0byBhIG1hcCB0cmFuc2l0aW9uIGZyb20gem9vbSBsZXZlbFxyXG5cdC8vIGBmcm9tWm9vbWAgdG8gYHRvWm9vbWAuIFVzZWQgaW50ZXJuYWxseSB0byBoZWxwIHdpdGggem9vbSBhbmltYXRpb25zLlxyXG5cdGdldFpvb21TY2FsZTogZnVuY3Rpb24gKHRvWm9vbSwgZnJvbVpvb20pIHtcclxuXHRcdC8vIFRPRE8gcmVwbGFjZSB3aXRoIHVuaXZlcnNhbCBpbXBsZW1lbnRhdGlvbiBhZnRlciByZWZhY3RvcmluZyBwcm9qZWN0aW9uc1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUoZnJvbVpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2NhbGVab29tKHNjYWxlOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgdGhlIG1hcCB3b3VsZCBlbmQgdXAgYXQsIGlmIGl0IGlzIGF0IGBmcm9tWm9vbWBcclxuXHQvLyBsZXZlbCBhbmQgZXZlcnl0aGluZyBpcyBzY2FsZWQgYnkgYSBmYWN0b3Igb2YgYHNjYWxlYC4gSW52ZXJzZSBvZlxyXG5cdC8vIFtgZ2V0Wm9vbVNjYWxlYF0oI21hcC1nZXRab29tU2NhbGUpLlxyXG5cdGdldFNjYWxlWm9vbTogZnVuY3Rpb24gKHNjYWxlLCBmcm9tWm9vbSkge1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHR2YXIgem9vbSA9IGNycy56b29tKHNjYWxlICogY3JzLnNjYWxlKGZyb21ab29tKSk7XHJcblx0XHRyZXR1cm4gaXNOYU4oem9vbSkgPyBJbmZpbml0eSA6IHpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgYExhdExuZ2AgYWNjb3JkaW5nIHRvIHRoZSBwcm9qZWN0aW9uXHJcblx0Ly8gb2YgdGhlIG1hcCdzIENSUywgdGhlbiBzY2FsZXMgaXQgYWNjb3JkaW5nIHRvIGB6b29tYCBhbmQgdGhlIENSUydzXHJcblx0Ly8gYFRyYW5zZm9ybWF0aW9uYC4gVGhlIHJlc3VsdCBpcyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIENSUyBvcmlnaW4uXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMubGF0TG5nVG9Qb2ludCh0b0xhdExuZyhsYXRsbmcpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG5cdC8vIEludmVyc2Ugb2YgW2Bwcm9qZWN0YF0oI21hcC1wcm9qZWN0KS5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMucG9pbnRUb0xhdExuZyh0b1BvaW50KHBvaW50KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0bGF5ZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KHByb2plY3RlZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGxhdExuZ1RvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0KHRvTGF0TG5nKGxhdGxuZykpLl9yb3VuZCgpO1xyXG5cdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBgbGF0YCBhbmQgYGxuZ2AgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gbWFwJ3MgQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGVcclxuXHQvLyBDUlMncyBib3VuZHMuXHJcblx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcblx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZyh0b0xhdExuZyhsYXRsbmcpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nIHRoYXRcclxuXHQvLyBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyB0aGUgY2VudGVyIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcblx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMsIGFuZCB0aGUgbWFqb3JpdHkgb2YgdGhlIGJvdW5kc1xyXG5cdC8vIG92ZXJsYXBzIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZ0JvdW5kcyh0b0xhdExuZ0JvdW5kcyhsYXRsbmcpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGFjY29yZGluZyB0b1xyXG5cdC8vIHRoZSBtYXAncyBDUlMuIEJ5IGRlZmF1bHQgdGhpcyBtZWFzdXJlcyBkaXN0YW5jZSBpbiBtZXRlcnMuXHJcblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5kaXN0YW5jZSh0b0xhdExuZyhsYXRsbmcxKSwgdG9MYXRMbmcobGF0bG5nMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcclxuXHQvLyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuXHRsYXllclBvaW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zXHJcblx0Ly8gdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRjb250YWluZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0b1BvaW50KHBvaW50KSk7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuXHRsYXRMbmdUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9Db250YWluZXJQb2ludCh0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludCh0b0xhdExuZyhsYXRsbmcpKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGVcclxuXHQvLyBtYXAgY29udGFpbmVyIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIERvbUV2ZW50LmdldE1vdXNlUG9zaXRpb24oZSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF0TG5nKGV2OiBNb3VzZUV2ZW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSB3aGVyZSB0aGVcclxuXHQvLyBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xhdExuZzogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gbWFwIGluaXRpYWxpemF0aW9uIG1ldGhvZHNcclxuXHJcblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuZ2V0KGlkKTtcclxuXHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG5cdFx0fSBlbHNlIGlmIChjb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIHRoaXMpO1xyXG5cdFx0dGhpcy5fY29udGFpbmVySWQgPSBVdGlsLnN0YW1wKGNvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcblxyXG5cdFx0dGhpcy5fZmFkZUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gJiYgQnJvd3Nlci5hbnkzZDtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udGFpbmVyJyArXHJcblx0XHRcdChCcm93c2VyLnRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLnJldGluYSA/ICcgbGVhZmxldC1yZXRpbmEnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIuaWVsdDkgPyAnIGxlYWZsZXQtb2xkaWUnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIuc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgK1xyXG5cdFx0XHQodGhpcy5fZmFkZUFuaW1hdGVkID8gJyBsZWFmbGV0LWZhZGUtYW5pbScgOiAnJykpO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IERvbVV0aWwuZ2V0U3R5bGUoY29udGFpbmVyLCAncG9zaXRpb24nKTtcclxuXHJcblx0XHRpZiAocG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgcG9zaXRpb24gIT09ICdyZWxhdGl2ZScgJiYgcG9zaXRpb24gIT09ICdmaXhlZCcpIHtcclxuXHRcdFx0Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0UGFuZXMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdENvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5faW5pdENvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFuZXMgPSB0aGlzLl9wYW5lcyA9IHt9O1xyXG5cdFx0dGhpcy5fcGFuZVJlbmRlcmVycyA9IHt9O1xyXG5cclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvL1xyXG5cdFx0Ly8gUGFuZXMgYXJlIERPTSBlbGVtZW50cyB1c2VkIHRvIGNvbnRyb2wgdGhlIG9yZGVyaW5nIG9mIGxheWVycyBvbiB0aGUgbWFwLiBZb3VcclxuXHRcdC8vIGNhbiBhY2Nlc3MgcGFuZXMgd2l0aCBbYG1hcC5nZXRQYW5lYF0oI21hcC1nZXRwYW5lKSBvclxyXG5cdFx0Ly8gW2BtYXAuZ2V0UGFuZXNgXSgjbWFwLWdldHBhbmVzKSBtZXRob2RzLiBOZXcgcGFuZXMgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGVcclxuXHRcdC8vIFtgbWFwLmNyZWF0ZVBhbmVgXSgjbWFwLWNyZWF0ZXBhbmUpIG1ldGhvZC5cclxuXHRcdC8vXHJcblx0XHQvLyBFdmVyeSBtYXAgaGFzIHRoZSBmb2xsb3dpbmcgZGVmYXVsdCBwYW5lcyB0aGF0IGRpZmZlciBvbmx5IGluIHpJbmRleC5cclxuXHRcdC8vXHJcblx0XHQvLyBAcGFuZSBtYXBQYW5lOiBIVE1MRWxlbWVudCA9ICdhdXRvJ1xyXG5cdFx0Ly8gUGFuZSB0aGF0IGNvbnRhaW5zIGFsbCBvdGhlciBtYXAgcGFuZXNcclxuXHJcblx0XHR0aGlzLl9tYXBQYW5lID0gdGhpcy5jcmVhdGVQYW5lKCdtYXBQYW5lJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHQvLyBAcGFuZSB0aWxlUGFuZTogSFRNTEVsZW1lbnQgPSAyMDBcclxuXHRcdC8vIFBhbmUgZm9yIGBHcmlkTGF5ZXJgcyBhbmQgYFRpbGVMYXllcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3RpbGVQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBvdmVybGF5UGFuZTogSFRNTEVsZW1lbnQgPSA0MDBcclxuXHRcdC8vIFBhbmUgZm9yIHZlY3RvcnMgKGBQYXRoYHMsIGxpa2UgYFBvbHlsaW5lYHMgYW5kIGBQb2x5Z29uYHMpLCBgSW1hZ2VPdmVybGF5YHMgYW5kIGBWaWRlb092ZXJsYXlgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdzaGFkb3dQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxyXG5cdFx0Ly8gUGFuZSBmb3Igb3ZlcmxheSBzaGFkb3dzIChlLmcuIGBNYXJrZXJgIHNoYWRvd3MpXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ292ZXJsYXlQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBtYXJrZXJQYW5lOiBIVE1MRWxlbWVudCA9IDYwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEljb25gcyBvZiBgTWFya2VyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnbWFya2VyUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgdG9vbHRpcFBhbmU6IEhUTUxFbGVtZW50ID0gNjUwXHJcblx0XHQvLyBQYW5lIGZvciBgVG9vbHRpcGBzLlxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCd0b29sdGlwUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgcG9wdXBQYW5lOiBIVE1MRWxlbWVudCA9IDcwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYFBvcHVwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3BvcHVwUGFuZScpO1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5zaGFkb3dQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHR2YXIgbG9hZGluZyA9ICF0aGlzLl9sb2FkZWQ7XHJcblx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xyXG5cdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdwcmVyZXNldCcpO1xyXG5cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblx0XHR0aGlzXHJcblx0XHRcdC5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkLCBmYWxzZSlcclxuXHRcdFx0Ll9tb3ZlKGNlbnRlciwgem9vbSlcclxuXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgdmlld3Jlc2V0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIG5lZWRzIHRvIHJlZHJhdyBpdHMgY29udGVudCAodGhpcyB1c3VhbGx5IGhhcHBlbnNcclxuXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuXHRcdC8vIGZvciB0aGUgZmlyc3QgdGltZSkuXHJcblx0XHRpZiAobG9hZGluZykge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gaXMgYWJvdXQgdG8gY2hhbmdlIChlLmcuIGJlZm9yZSB6b29tIGFuaW1hdGlvbikuXHJcblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlldyBvZiB0aGUgbWFwIHN0YXJ0cyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21zdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFub01vdmVTdGFydCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X21vdmU6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGRhdGEpIHtcclxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0em9vbSA9IHRoaXMuX3pvb207XHJcblx0XHR9XHJcblx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cclxuXHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0dGhpcy5fbGFzdENlbnRlciA9IGNlbnRlcjtcclxuXHRcdHRoaXMuX3BpeGVsT3JpZ2luID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgem9vbTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBjaGFuZ2UgaW4gem9vbSBsZXZlbCwgaW5jbHVkaW5nIHpvb21cclxuXHRcdC8vIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCB8fCAoZGF0YSAmJiBkYXRhLnBpbmNoKSkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tJywgZGF0YSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgbW92ZW1lbnQgb2YgdGhlIG1hcCwgaW5jbHVkaW5nIHBhbiBhbmRcclxuXHRcdC8vIGZseSBhbmltYXRpb25zLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIGRhdGEpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlRW5kOiBmdW5jdGlvbiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGhhcyBjaGFuZ2VkLCBhZnRlciBhbnkgYW5pbWF0aW9ucy5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21lbmQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGNlbnRlciBvZiB0aGUgbWFwIHN0b3BzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RvcHBlZFxyXG5cdFx0Ly8gZHJhZ2dpbmcgdGhlIG1hcCkuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X3N0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZseVRvRnJhbWUpO1xyXG5cdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5zdG9wKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmF3UGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tU3BhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWF4Wm9vbSgpIC0gdGhpcy5nZXRNaW5ab29tKCk7XHJcblx0fSxcclxuXHJcblx0X3Bhbkluc2lkZU1heEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmZvcmNpbmdCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5wYW5JbnNpZGVCb3VuZHModGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NoZWNrSWZMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignU2V0IG1hcCBjZW50ZXIgYW5kIHpvb20gZmlyc3QuJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gRE9NIGV2ZW50IGhhbmRsaW5nXHJcblxyXG5cdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIGV2ZW50c1xyXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAocmVtb3ZlKSB7XHJcblx0XHR0aGlzLl90YXJnZXRzID0ge307XHJcblx0XHR0aGlzLl90YXJnZXRzW1V0aWwuc3RhbXAodGhpcy5fY29udGFpbmVyKV0gPSB0aGlzO1xyXG5cclxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/IERvbUV2ZW50Lm9mZiA6IERvbUV2ZW50Lm9uO1xyXG5cclxuXHRcdC8vIEBldmVudCBjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKG9yIHRhcHMpIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgZGJsY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgZG91YmxlLWNsaWNrcyAob3IgZG91YmxlLXRhcHMpIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2Vkb3duOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2V1cDogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdmVyOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBlbnRlcnMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW91dDogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2Vtb3ZlOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGlsZSB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGNvbnRleHRtZW51OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgcmlnaHQgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAsIHByZXZlbnRzXHJcblx0XHQvLyBkZWZhdWx0IGJyb3dzZXIgY29udGV4dCBtZW51IGZyb20gc2hvd2luZyBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzIG9uXHJcblx0XHQvLyB0aGlzIGV2ZW50LiBBbHNvIGZpcmVkIG9uIG1vYmlsZSB3aGVuIHRoZSB1c2VyIGhvbGRzIGEgc2luZ2xlIHRvdWNoXHJcblx0XHQvLyBmb3IgYSBzZWNvbmQgKGFsc28gY2FsbGVkIGxvbmcgcHJlc3MpLlxyXG5cdFx0Ly8gQGV2ZW50IGtleXByZXNzOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgdGhhdCBwcm9kdWNlcyBhIGNoYXJhY3RlciB2YWx1ZSB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcblx0XHQvLyBAZXZlbnQga2V5ZG93bjogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC4gVW5saWtlIHRoZSBga2V5cHJlc3NgIGV2ZW50LFxyXG5cdFx0Ly8gdGhlIGBrZXlkb3duYCBldmVudCBpcyBmaXJlZCBmb3Iga2V5cyB0aGF0IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUgYW5kIGZvciBrZXlzXHJcblx0XHQvLyB0aGF0IGRvIG5vdCBwcm9kdWNlIGEgY2hhcmFjdGVyIHZhbHVlLlxyXG5cdFx0Ly8gQGV2ZW50IGtleXVwOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuXHRcdG9uT2ZmKHRoaXMuX2NvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwICcgK1xyXG5cdFx0XHQnbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudSBrZXlwcmVzcyBrZXlkb3duIGtleXVwJywgdGhpcy5faGFuZGxlRE9NRXZlbnQsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUpIHtcclxuXHRcdFx0b25PZmYod2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChCcm93c2VyLmFueTNkICYmIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdChyZW1vdmUgPyB0aGlzLm9mZiA6IHRoaXMub24pLmNhbGwodGhpcywgJ21vdmVlbmQnLCB0aGlzLl9vbk1vdmVFbmQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFxyXG5cdFx0ICAgICAgICBmdW5jdGlvbiAoKSB7IHRoaXMuaW52YWxpZGF0ZVNpemUoe2RlYm91bmNlTW92ZWVuZDogdHJ1ZX0pOyB9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25TY3JvbGw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3AgID0gMDtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxMZWZ0ID0gMDtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0aWYgKE1hdGgubWF4KE1hdGguYWJzKHBvcy54KSwgTWF0aC5hYnMocG9zLnkpKSA+PSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHQvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjAzODczIGJ1dCBXZWJraXQgYWxzbyBoYXZlXHJcblx0XHRcdC8vIGEgcGl4ZWwgb2Zmc2V0IG9uIHZlcnkgaGlnaCB2YWx1ZXMsIHNlZTogaHR0cDovL2pzZmlkZGxlLm5ldC9kZzZyNWhoYi9cclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZmluZEV2ZW50VGFyZ2V0czogZnVuY3Rpb24gKGUsIHR5cGUpIHtcclxuXHRcdHZhciB0YXJnZXRzID0gW10sXHJcblx0XHQgICAgdGFyZ2V0LFxyXG5cdFx0ICAgIGlzSG92ZXIgPSB0eXBlID09PSAnbW91c2VvdXQnIHx8IHR5cGUgPT09ICdtb3VzZW92ZXInLFxyXG5cdFx0ICAgIHNyYyA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcclxuXHRcdCAgICBkcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuXHRcdHdoaWxlIChzcmMpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1tVdGlsLnN0YW1wKHNyYyldO1xyXG5cdFx0XHRpZiAodGFyZ2V0ICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdwcmVjbGljaycpICYmICFlLl9zaW11bGF0ZWQgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG5cdFx0XHRcdC8vIFByZXZlbnQgZmlyaW5nIGNsaWNrIGFmdGVyIHlvdSBqdXN0IGRyYWdnZWQgYW4gb2JqZWN0LlxyXG5cdFx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGFyZ2V0ICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIURvbUV2ZW50LmlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG5cdFx0XHRcdHRhcmdldHMucHVzaCh0YXJnZXQpO1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHNyYyA9PT0gdGhpcy5fY29udGFpbmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdHNyYyA9IHNyYy5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiAhZHJhZ2dpbmcgJiYgIWlzSG92ZXIgJiYgRG9tRXZlbnQuaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7XHJcblx0XHRcdHRhcmdldHMgPSBbdGhpc107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBEb21FdmVudC5za2lwcGVkKGUpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciB0eXBlID0gZS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2Vkb3duJyB8fCB0eXBlID09PSAna2V5cHJlc3MnIHx8IHR5cGUgPT09ICdrZXl1cCcgfHwgdHlwZSA9PT0gJ2tleWRvd24nKSB7XHJcblx0XHRcdC8vIHByZXZlbnRzIG91dGxpbmUgd2hlbiBjbGlja2luZyBvbiBrZXlib2FyZC1mb2N1c2FibGUgZWxlbWVudFxyXG5cdFx0XHREb21VdGlsLnByZXZlbnRPdXRsaW5lKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZmlyZURPTUV2ZW50KGUsIHR5cGUpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3VzZUV2ZW50czogWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnY29udGV4dG1lbnUnXSxcclxuXHJcblx0X2ZpcmVET01FdmVudDogZnVuY3Rpb24gKGUsIHR5cGUsIHRhcmdldHMpIHtcclxuXHJcblx0XHRpZiAoZS50eXBlID09PSAnY2xpY2snKSB7XHJcblx0XHRcdC8vIEZpcmUgYSBzeW50aGV0aWMgJ3ByZWNsaWNrJyBldmVudCB3aGljaCBwcm9wYWdhdGVzIHVwIChtYWlubHkgZm9yIGNsb3NpbmcgcG9wdXBzKS5cclxuXHRcdFx0Ly8gQGV2ZW50IHByZWNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIGJlZm9yZSBtb3VzZSBjbGljayBvbiB0aGUgbWFwIChzb21ldGltZXMgdXNlZnVsIHdoZW4geW91XHJcblx0XHRcdC8vIHdhbnQgc29tZXRoaW5nIHRvIGhhcHBlbiBvbiBjbGljayBiZWZvcmUgYW55IGV4aXN0aW5nIGNsaWNrXHJcblx0XHRcdC8vIGhhbmRsZXJzIHN0YXJ0IHJ1bm5pbmcpLlxyXG5cdFx0XHR2YXIgc3ludGggPSBVdGlsLmV4dGVuZCh7fSwgZSk7XHJcblx0XHRcdHN5bnRoLnR5cGUgPSAncHJlY2xpY2snO1xyXG5cdFx0XHR0aGlzLl9maXJlRE9NRXZlbnQoc3ludGgsIHN5bnRoLnR5cGUsIHRhcmdldHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlLl9zdG9wcGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEZpbmQgdGhlIGxheWVyIHRoZSBldmVudCBpcyBwcm9wYWdhdGluZyBmcm9tIGFuZCBpdHMgcGFyZW50cy5cclxuXHRcdHRhcmdldHMgPSAodGFyZ2V0cyB8fCBbXSkuY29uY2F0KHRoaXMuX2ZpbmRFdmVudFRhcmdldHMoZSwgdHlwZSkpO1xyXG5cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGgpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbMF07XHJcblx0XHRpZiAodHlwZSA9PT0gJ2NvbnRleHRtZW51JyAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0b3JpZ2luYWxFdmVudDogZVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoZS50eXBlICE9PSAna2V5cHJlc3MnICYmIGUudHlwZSAhPT0gJ2tleWRvd24nICYmIGUudHlwZSAhPT0gJ2tleXVwJykge1xyXG5cdFx0XHR2YXIgaXNNYXJrZXIgPSB0YXJnZXQuZ2V0TGF0TG5nICYmICghdGFyZ2V0Ll9yYWRpdXMgfHwgdGFyZ2V0Ll9yYWRpdXMgPD0gMTApO1xyXG5cdFx0XHRkYXRhLmNvbnRhaW5lclBvaW50ID0gaXNNYXJrZXIgP1xyXG5cdFx0XHRcdHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludCh0YXJnZXQuZ2V0TGF0TG5nKCkpIDogdGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcclxuXHRcdFx0ZGF0YS5sYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChkYXRhLmNvbnRhaW5lclBvaW50KTtcclxuXHRcdFx0ZGF0YS5sYXRsbmcgPSBpc01hcmtlciA/IHRhcmdldC5nZXRMYXRMbmcoKSA6IHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGRhdGEubGF5ZXJQb2ludCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRhcmdldHNbaV0uZmlyZSh0eXBlLCBkYXRhLCB0cnVlKTtcclxuXHRcdFx0aWYgKGRhdGEub3JpZ2luYWxFdmVudC5fc3RvcHBlZCB8fFxyXG5cdFx0XHRcdCh0YXJnZXRzW2ldLm9wdGlvbnMuYnViYmxpbmdNb3VzZUV2ZW50cyA9PT0gZmFsc2UgJiYgVXRpbC5pbmRleE9mKHRoaXMuX21vdXNlRXZlbnRzLCB0eXBlKSAhPT0gLTEpKSB7IHJldHVybjsgfVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9kcmFnZ2FibGVNb3ZlZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0b2JqID0gb2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5lbmFibGVkKCkgPyBvYmogOiB0aGlzO1xyXG5cdFx0cmV0dXJuIChvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLm1vdmVkKCkpIHx8ICh0aGlzLmJveFpvb20gJiYgdGhpcy5ib3hab29tLm1vdmVkKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlcnNbaV0uZGlzYWJsZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCB3aGVuUmVhZHkoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGBmbmAgd2hlbiB0aGUgbWFwIGdldHMgaW5pdGlhbGl6ZWQgd2l0aFxyXG5cdC8vIGEgdmlldyAoY2VudGVyIGFuZCB6b29tKSBhbmQgYXQgbGVhc3Qgb25lIGxheWVyLCBvciBpbW1lZGlhdGVseVxyXG5cdC8vIGlmIGl0J3MgYWxyZWFkeSBpbml0aWFsaXplZCwgb3B0aW9uYWxseSBwYXNzaW5nIGEgZnVuY3Rpb24gY29udGV4dC5cclxuXHR3aGVuUmVhZHk6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQgfHwgdGhpcywge3RhcmdldDogdGhpc30pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5vbignbG9hZCcsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgZm9yIGdldHRpbmcgbWFwIHN0YXRlXHJcblxyXG5cdF9nZXRNYXBQYW5lUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lKSB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcblx0fSxcclxuXHJcblx0X21vdmVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0cmV0dXJuIHBvcyAmJiAhcG9zLmVxdWFscyhbMCwgMF0pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciBwaXhlbE9yaWdpbiA9IGNlbnRlciAmJiB6b29tICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0XHR0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pIDpcclxuXHRcdFx0dGhpcy5nZXRQaXhlbE9yaWdpbigpO1xyXG5cdFx0cmV0dXJuIHBpeGVsT3JpZ2luLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0X2dldE5ld1BpeGVsT3JpZ2luOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSkuX3N1YnRyYWN0KHZpZXdIYWxmKS5fYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ1RvTmV3TGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgY2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGxhdGxuZywgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCB6b29tLCBjZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiB0b0JvdW5kcyhbXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KVxyXG5cdFx0XSk7XHJcblx0fSxcclxuXHJcblx0Ly8gbGF5ZXIgcG9pbnQgb2YgdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0X2dldENlbnRlckxheWVyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgcGxhY2UgdG8gdGhlIGN1cnJlbnQgY2VudGVyIGluIHBpeGVsc1xyXG5cdF9nZXRDZW50ZXJPZmZzZXQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpLnN1YnRyYWN0KHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IGNlbnRlciBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdENlbnRlcjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgYm91bmRzKSB7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGNlbnRlcjsgfVxyXG5cclxuXHRcdHZhciBjZW50ZXJQb2ludCA9IHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgdmlld0JvdW5kcyA9IG5ldyBCb3VuZHMoY2VudGVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLCBjZW50ZXJQb2ludC5hZGQodmlld0hhbGYpKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRCb3VuZHNPZmZzZXQodmlld0JvdW5kcywgYm91bmRzLCB6b29tKTtcclxuXHJcblx0XHQvLyBJZiBvZmZzZXQgaXMgbGVzcyB0aGFuIGEgcGl4ZWwsIGlnbm9yZS5cclxuXHRcdC8vIFRoaXMgcHJldmVudHMgdW5zdGFibGUgcHJvamVjdGlvbnMgZnJvbSBnZXR0aW5nIGludG9cclxuXHRcdC8vIGFuIGluZmluaXRlIGxvb3Agb2YgdGlueSBvZmZzZXRzLlxyXG5cdFx0aWYgKG9mZnNldC5yb3VuZCgpLmVxdWFscyhbMCwgMF0pKSB7XHJcblx0XHRcdHJldHVybiBjZW50ZXI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KGNlbnRlclBvaW50LmFkZChvZmZzZXQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3Qgb2Zmc2V0IGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0LCBib3VuZHMpIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBvZmZzZXQ7IH1cclxuXHJcblx0XHR2YXIgdmlld0JvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBuZXdCb3VuZHMgPSBuZXcgQm91bmRzKHZpZXdCb3VuZHMubWluLmFkZChvZmZzZXQpLCB2aWV3Qm91bmRzLm1heC5hZGQob2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIG9mZnNldC5hZGQodGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KG5ld0JvdW5kcywgYm91bmRzKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJucyBvZmZzZXQgbmVlZGVkIGZvciBweEJvdW5kcyB0byBnZXQgaW5zaWRlIG1heEJvdW5kcyBhdCBhIHNwZWNpZmllZCB6b29tXHJcblx0X2dldEJvdW5kc09mZnNldDogZnVuY3Rpb24gKHB4Qm91bmRzLCBtYXhCb3VuZHMsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRNYXhCb3VuZHMgPSB0b0JvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pXHJcblx0XHQgICAgKSxcclxuXHRcdCAgICBtaW5PZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWluLnN1YnRyYWN0KHB4Qm91bmRzLm1pbiksXHJcblx0XHQgICAgbWF4T2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1heC5zdWJ0cmFjdChweEJvdW5kcy5tYXgpLFxyXG5cclxuXHRcdCAgICBkeCA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LngsIC1tYXhPZmZzZXQueCksXHJcblx0XHQgICAgZHkgPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC55LCAtbWF4T2Zmc2V0LnkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQoZHgsIGR5KTtcclxuXHR9LFxyXG5cclxuXHRfcmVib3VuZDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcblx0XHRyZXR1cm4gbGVmdCArIHJpZ2h0ID4gMCA/XHJcblx0XHRcdE1hdGgucm91bmQobGVmdCAtIHJpZ2h0KSAvIDIgOlxyXG5cdFx0XHRNYXRoLm1heCgwLCBNYXRoLmNlaWwobGVmdCkpIC0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihyaWdodCkpO1xyXG5cdH0sXHJcblxyXG5cdF9saW1pdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgc25hcCA9IEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxO1xyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH0sXHJcblxyXG5cdF9vblBhblRyYW5zaXRpb25TdGVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHR9LFxyXG5cclxuXHRfb25QYW5UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRQYW46IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHtcclxuXHRcdC8vIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbmV3IGFuZCBjdXJyZW50IGNlbnRlcnMgaW4gcGl4ZWxzXHJcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX3RydW5jKCk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSB0b28gZmFyIHVubGVzcyBhbmltYXRlOiB0cnVlIHNwZWNpZmllZCBpbiBvcHRpb25zXHJcblx0XHRpZiAoKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRlKSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHR0aGlzLnBhbkJ5KG9mZnNldCwgb3B0aW9ucyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBwcm94eSA9IHRoaXMuX3Byb3h5ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXByb3h5IGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cdFx0dGhpcy5fcGFuZXMubWFwUGFuZS5hcHBlbmRDaGlsZChwcm94eSk7XHJcblxyXG5cdFx0dGhpcy5vbignem9vbWFuaW0nLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHR2YXIgcHJvcCA9IERvbVV0aWwuVFJBTlNGT1JNLFxyXG5cdFx0XHQgICAgdHJhbnNmb3JtID0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF07XHJcblxyXG5cdFx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGUuY2VudGVyLCBlLnpvb20pLCB0aGlzLmdldFpvb21TY2FsZShlLnpvb20sIDEpKTtcclxuXHJcblx0XHRcdC8vIHdvcmthcm91bmQgZm9yIGNhc2Ugd2hlbiB0cmFuc2Zvcm0gaXMgdGhlIHNhbWUgYW5kIHNvIHRyYW5zaXRpb25lbmQgZXZlbnQgaXMgbm90IGZpcmVkXHJcblx0XHRcdGlmICh0cmFuc2Zvcm0gPT09IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdICYmIHRoaXMuX2FuaW1hdGluZ1pvb20pIHtcclxuXHRcdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMub24oJ2xvYWQgbW92ZWVuZCcsIHRoaXMuX2FuaW1Nb3ZlRW5kLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveUFuaW1Qcm94eSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X2Rlc3Ryb3lBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3Byb3h5KTtcclxuXHRcdHRoaXMub2ZmKCdsb2FkIG1vdmVlbmQnLCB0aGlzLl9hbmltTW92ZUVuZCwgdGhpcyk7XHJcblx0XHRkZWxldGUgdGhpcy5fcHJveHk7XHJcblx0fSxcclxuXHJcblx0X2FuaW1Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYyA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgeiA9IHRoaXMuZ2V0Wm9vbSgpO1xyXG5cdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChjLCB6KSwgdGhpcy5nZXRab29tU2NhbGUoeiwgMSkpO1xyXG5cdH0sXHJcblxyXG5cdF9jYXRjaFRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSAmJiBlLnByb3BlcnR5TmFtZS5pbmRleE9mKCd0cmFuc2Zvcm0nKSA+PSAwKSB7XHJcblx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbm90aGluZ1RvQW5pbWF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICF0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVhZmxldC16b29tLWFuaW1hdGVkJykubGVuZ3RoO1xyXG5cdH0sXHJcblxyXG5cdF90cnlBbmltYXRlZFpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgZGlzYWJsZWQsIG5vdCBzdXBwb3J0ZWQgb3Igem9vbSBkaWZmZXJlbmNlIGlzIHRvbyBsYXJnZVxyXG5cdFx0aWYgKCF0aGlzLl96b29tQW5pbWF0ZWQgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCB0aGlzLl9ub3RoaW5nVG9BbmltYXRlKCkgfHxcclxuXHRcdCAgICAgICAgTWF0aC5hYnMoem9vbSAtIHRoaXMuX3pvb20pID4gdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb25UaHJlc2hvbGQpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ly8gb2Zmc2V0IGlzIHRoZSBwaXhlbCBjb29yZHMgb2YgdGhlIHpvb20gb3JpZ2luIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2RpdmlkZUJ5KDEgLSAxIC8gc2NhbGUpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgdGhlIHpvb20gb3JpZ2luIGlzbid0IHdpdGhpbiBvbmUgc2NyZWVuIGZyb20gdGhlIGN1cnJlbnQgY2VudGVyLCB1bmxlc3MgZm9yY2VkXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKVxyXG5cdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBzdGFydEFuaW0sIG5vVXBkYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcFBhbmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHN0YXJ0QW5pbSkge1xyXG5cdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vIHJlbWVtYmVyIHdoYXQgY2VudGVyL3pvb20gdG8gc2V0IGFmdGVyIGFuaW1hdGlvblxyXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBPdGhlciBFdmVudHNcclxuXHRcdC8vIEBldmVudCB6b29tYW5pbTogWm9vbUFuaW1FdmVudFxyXG5cdFx0Ly8gRmlyZWQgYXQgbGVhc3Qgb25jZSBwZXIgem9vbSBhbmltYXRpb24uIEZvciBjb250aW51b3VzIHpvb20sIGxpa2UgcGluY2ggem9vbWluZywgZmlyZWQgb25jZSBwZXIgZnJhbWUgZHVyaW5nIHpvb20uXHJcblx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0em9vbTogem9vbSxcclxuXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBXb3JrIGFyb3VuZCB3ZWJraXQgbm90IGZpcmluZyAndHJhbnNpdGlvbmVuZCcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5LCAyNjkzXHJcblx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kLCB0aGlzKSwgMjUwKTtcclxuXHR9LFxyXG5cclxuXHRfb25ab29tVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9tYXBQYW5lKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tKTtcclxuXHJcblx0XHQvLyBUaGlzIGFuaW0gZnJhbWUgc2hvdWxkIHByZXZlbnQgYW4gb2JzY3VyZSBpT1Mgd2Via2l0IHRpbGUgbG9hZGluZyByYWNlIGNvbmRpdGlvbi5cclxuXHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuX21vdmVFbmQodHJ1ZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuXHJcbi8vIEBmYWN0b3J5IEwubWFwKGlkOiBTdHJpbmcsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiB0aGUgRE9NIElEIG9mIGEgYDxkaXY+YCBlbGVtZW50XHJcbi8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuLy9cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubWFwKGVsOiBIVE1MRWxlbWVudCwgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIGFuIGluc3RhbmNlIG9mIGEgYDxkaXY+YCBIVE1MIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWFwKGlkLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBNYXAoaWQsIG9wdGlvbnMpO1xyXG59XHJcbiIsIlxyXG5pbXBvcnQge0NsYXNzfSBmcm9tICcuLi9jb3JlL0NsYXNzJztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2xcclxuICogQGFrYSBMLkNvbnRyb2xcclxuICogQGluaGVyaXRzIENsYXNzXHJcbiAqXHJcbiAqIEwuQ29udHJvbCBpcyBhIGJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGluZyBtYXAgY29udHJvbHMuIEhhbmRsZXMgcG9zaXRpb25pbmcuXHJcbiAqIEFsbCBvdGhlciBjb250cm9scyBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQ29udHJvbCA9IENsYXNzLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gcG9zaXRpb246IFN0cmluZyA9ICd0b3ByaWdodCdcclxuXHRcdC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCAob25lIG9mIHRoZSBtYXAgY29ybmVycykuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYCd0b3BsZWZ0J2AsXHJcblx0XHQvLyBgJ3RvcHJpZ2h0J2AsIGAnYm90dG9tbGVmdCdgIG9yIGAnYm90dG9tcmlnaHQnYFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgTC5Db250cm9sIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGdldFBvc2l0aW9uOiBzdHJpbmdcclxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHQgKi9cclxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5yZW1vdmVDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLmFkZENvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRUbyhtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBjb250cm9sIHRvIHRoZSBnaXZlbiBtYXAuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMucmVtb3ZlKCk7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKSxcclxuXHRcdCAgICBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKCksXHJcblx0XHQgICAgY29ybmVyID0gbWFwLl9jb250cm9sQ29ybmVyc1twb3NdO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sJyk7XHJcblxyXG5cdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcclxuXHRcdFx0Y29ybmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIGNvcm5lci5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5vbigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub25SZW1vdmUpIHtcclxuXHRcdFx0dGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5vZmYoJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3JlZm9jdXNPbk1hcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIGlmIG1hcCBleGlzdHMgYW5kIGV2ZW50IGlzIG5vdCBhIGtleWJvYXJkIGV2ZW50XHJcblx0XHRpZiAodGhpcy5fbWFwICYmIGUgJiYgZS5zY3JlZW5YID4gMCAmJiBlLnNjcmVlblkgPiAwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5mb2N1cygpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5leHBvcnQgdmFyIGNvbnRyb2wgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgQ29udHJvbChvcHRpb25zKTtcclxufTtcclxuXHJcbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcbiAqIEB1bmluaGVyaXRhYmxlXHJcbiAqXHJcbiAqIEV2ZXJ5IGNvbnRyb2wgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkNvbnRyb2xgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiBIVE1MRWxlbWVudFxyXG4gKiBTaG91bGQgcmV0dXJuIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgZm9yIHRoZSBjb250cm9sIGFuZCBhZGQgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYGNvbnRyb2wuYWRkVG8obWFwKWBdKCNjb250cm9sLWFkZFRvKS5cclxuICpcclxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcClcclxuICogT3B0aW9uYWwgbWV0aG9kLiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjY29udHJvbC1vbmFkZCkuIENhbGxlZCBvbiBbYGNvbnRyb2wucmVtb3ZlKClgXSgjY29udHJvbC1yZW1vdmUpLlxyXG4gKi9cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuICovXHJcbk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAbWV0aG9kIGFkZENvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXBcclxuXHRhZGRDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5hZGRUbyh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGNvbnRyb2wgZnJvbSB0aGUgbWFwXHJcblx0cmVtb3ZlQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wucmVtb3ZlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdENvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuXHRcdCAgICBsID0gJ2xlYWZsZXQtJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID1cclxuXHRcdCAgICAgICAgICAgIERvbVV0aWwuY3JlYXRlKCdkaXYnLCBsICsgJ2NvbnRyb2wtY29udGFpbmVyJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRmdW5jdGlvbiBjcmVhdGVDb3JuZXIodlNpZGUsIGhTaWRlKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBsICsgdlNpZGUgKyAnICcgKyBsICsgaFNpZGU7XHJcblxyXG5cdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdyaWdodCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAncmlnaHQnKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2NvbnRyb2xDb3JuZXJzKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb3JuZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb3JuZXJzO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb250YWluZXI7XHJcblx0fVxyXG59KTtcclxuIiwiXHJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuTGF5ZXJzXHJcbiAqIEBha2EgTC5Db250cm9sLkxheWVyc1xyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXJzIGNvbnRyb2wgZ2l2ZXMgdXNlcnMgdGhlIGFiaWxpdHkgdG8gc3dpdGNoIGJldHdlZW4gZGlmZmVyZW50IGJhc2UgbGF5ZXJzIGFuZCBzd2l0Y2ggb3ZlcmxheXMgb24vb2ZmIChjaGVjayBvdXQgdGhlIFtkZXRhaWxlZCBleGFtcGxlXShodHRwOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9sYXllcnMtY29udHJvbC8pKS4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBiYXNlTGF5ZXJzID0ge1xyXG4gKiBcdFwiTWFwYm94XCI6IG1hcGJveCxcclxuICogXHRcIk9wZW5TdHJlZXRNYXBcIjogb3NtXHJcbiAqIH07XHJcbiAqXHJcbiAqIHZhciBvdmVybGF5cyA9IHtcclxuICogXHRcIk1hcmtlclwiOiBtYXJrZXIsXHJcbiAqIFx0XCJSb2Fkc1wiOiByb2Fkc0xheWVyXHJcbiAqIH07XHJcbiAqXHJcbiAqIEwuY29udHJvbC5sYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMpLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgYGJhc2VMYXllcnNgIGFuZCBgb3ZlcmxheXNgIHBhcmFtZXRlcnMgYXJlIG9iamVjdCBsaXRlcmFscyB3aXRoIGxheWVyIG5hbWVzIGFzIGtleXMgYW5kIGBMYXllcmAgb2JqZWN0cyBhcyB2YWx1ZXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcclxuICogICAgIFwiPHNvbWVOYW1lMT5cIjogbGF5ZXIxLFxyXG4gKiAgICAgXCI8c29tZU5hbWUyPlwiOiBsYXllcjJcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGxheWVyIG5hbWVzIGNhbiBjb250YWluIEhUTUwsIHdoaWNoIGFsbG93cyB5b3UgdG8gYWRkIGFkZGl0aW9uYWwgc3R5bGluZyB0byB0aGUgaXRlbXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcIjxpbWcgc3JjPSdteS1sYXllci1pY29uJyAvPiA8c3BhbiBjbGFzcz0nbXktbGF5ZXItaXRlbSc+TXkgTGF5ZXI8L3NwYW4+XCI6IG15TGF5ZXJ9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTGF5ZXJzID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkxheWVycyBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjb2xsYXBzZWQ6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYmUgY29sbGFwc2VkIGludG8gYW4gaWNvbiBhbmQgZXhwYW5kZWQgb24gbW91c2UgaG92ZXIgb3IgdG91Y2guXHJcblx0XHRjb2xsYXBzZWQ6IHRydWUsXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9aSW5kZXg6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYXNzaWduIHpJbmRleGVzIGluIGluY3JlYXNpbmcgb3JkZXIgdG8gYWxsIG9mIGl0cyBsYXllcnMgc28gdGhhdCB0aGUgb3JkZXIgaXMgcHJlc2VydmVkIHdoZW4gc3dpdGNoaW5nIHRoZW0gb24vb2ZmLlxyXG5cdFx0YXV0b1pJbmRleDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGhpZGVTaW5nbGVCYXNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGJhc2UgbGF5ZXJzIGluIHRoZSBjb250cm9sIHdpbGwgYmUgaGlkZGVuIHdoZW4gdGhlcmUgaXMgb25seSBvbmUuXHJcblx0XHRoaWRlU2luZ2xlQmFzZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzb3J0TGF5ZXJzOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgbGF5ZXJzLiBXaGVuIGBmYWxzZWAsIGxheWVycyB3aWxsIGtlZXAgdGhlIG9yZGVyXHJcblx0XHQvLyBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQgdG8gdGhlIGNvbnRyb2wuXHJcblx0XHRzb3J0TGF5ZXJzOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRGdW5jdGlvbjogRnVuY3Rpb24gPSAqXHJcblx0XHQvLyBBIFtjb21wYXJlIGZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0KVxyXG5cdFx0Ly8gdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHNvcnRpbmcgdGhlIGxheWVycywgd2hlbiBgc29ydExheWVyc2AgaXMgYHRydWVgLlxyXG5cdFx0Ly8gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGJvdGggdGhlIGBMLkxheWVyYCBpbnN0YW5jZXMgYW5kIHRoZWlyIG5hbWVzLCBhcyBpblxyXG5cdFx0Ly8gYHNvcnRGdW5jdGlvbihsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKWAuXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBpdCBzb3J0cyBsYXllcnMgYWxwaGFiZXRpY2FsbHkgYnkgdGhlaXIgbmFtZS5cclxuXHRcdHNvcnRGdW5jdGlvbjogZnVuY3Rpb24gKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpIHtcclxuXHRcdFx0cmV0dXJuIG5hbWVBIDwgbmFtZUIgPyAtMSA6IChuYW1lQiA8IG5hbWVBID8gMSA6IDApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXN0WkluZGV4ID0gMDtcclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIoYmFzZUxheWVyc1tpXSwgaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKG92ZXJsYXlzW2ldLCBpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0Q29udHJvbC5wcm90b3R5cGUuYWRkVG8uY2FsbCh0aGlzLCBtYXApO1xyXG5cdFx0Ly8gVHJpZ2dlciBleHBhbmQgYWZ0ZXIgTGF5ZXJzIENvbnRyb2wgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byBET00gc28gdGhhdCBpcyBub3cgaGFzIGFuIGFjdHVhbCBoZWlnaHQuXHJcblx0XHRyZXR1cm4gdGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9mZignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEJhc2VMYXllcihsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGEgYmFzZSBsYXllciAocmFkaW8gYnV0dG9uIGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRPdmVybGF5KGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gb3ZlcmxheSAoY2hlY2tib3ggZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSwgdHJ1ZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBjb250cm9sLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihVdGlsLnN0YW1wKGxheWVyKSk7XHJcblx0XHRpZiAob2JqKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zcGxpY2UodGhpcy5fbGF5ZXJzLmluZGV4T2Yob2JqKSwgMSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBleHBhbmQoKTogdGhpc1xyXG5cdC8vIEV4cGFuZCB0aGUgY29udHJvbCBjb250YWluZXIgaWYgY29sbGFwc2VkLlxyXG5cdGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHR0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodCA9IG51bGw7XHJcblx0XHR2YXIgYWNjZXB0YWJsZUhlaWdodCA9IHRoaXMuX21hcC5nZXRTaXplKCkueSAtICh0aGlzLl9jb250YWluZXIub2Zmc2V0VG9wICsgNTApO1xyXG5cdFx0aWYgKGFjY2VwdGFibGVIZWlnaHQgPCB0aGlzLl9zZWN0aW9uLmNsaWVudEhlaWdodCkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0XHR0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodCA9IGFjY2VwdGFibGVIZWlnaHQgKyAncHgnO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9zZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29sbGFwc2UoKTogdGhpc1xyXG5cdC8vIENvbGxhcHNlIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBleHBhbmRlZC5cclxuXHRjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKSxcclxuXHRcdCAgICBjb2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2VkO1xyXG5cclxuXHRcdC8vIG1ha2VzIHRoaXMgd29yayBvbiBJRSB0b3VjaCBkZXZpY2VzIGJ5IHN0b3BwaW5nIGl0IGZyb20gZmlyaW5nIGEgbW91c2VvdXQgZXZlbnQgd2hlbiB0aGUgdG91Y2ggaXMgcmVsZWFzZWRcclxuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcclxuXHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblxyXG5cdFx0dmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uID0gRG9tVXRpbC5jcmVhdGUoJ3NlY3Rpb24nLCBjbGFzc05hbWUgKyAnLWxpc3QnKTtcclxuXHJcblx0XHRpZiAoY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLmNvbGxhcHNlLCB0aGlzKTtcclxuXHJcblx0XHRcdGlmICghQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCB7XHJcblx0XHRcdFx0XHRtb3VzZWVudGVyOiB0aGlzLmV4cGFuZCxcclxuXHRcdFx0XHRcdG1vdXNlbGVhdmU6IHRoaXMuY29sbGFwc2VcclxuXHRcdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IERvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lICsgJy10b2dnbGUnLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xyXG5cclxuXHRcdGlmIChCcm93c2VyLnRvdWNoKSB7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIERvbUV2ZW50LnN0b3ApO1xyXG5cdFx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21FdmVudC5vbihsaW5rLCAnZm9jdXMnLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBzZWN0aW9uKTtcclxuXHRcdHRoaXMuX3NlcGFyYXRvciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLXNlcGFyYXRvcicsIHNlY3Rpb24pO1xyXG5cdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBzZWN0aW9uKTtcclxuXHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XHJcblx0fSxcclxuXHJcblx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5fbGF5ZXJzW2ldICYmIFV0aWwuc3RhbXAodGhpcy5fbGF5ZXJzW2ldLmxheWVyKSA9PT0gaWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0bGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllcnMucHVzaCh7XHJcblx0XHRcdGxheWVyOiBsYXllcixcclxuXHRcdFx0bmFtZTogbmFtZSxcclxuXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zb3J0TGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zb3J0KFV0aWwuYmluZChmdW5jdGlvbiAoYSwgYikge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKGEubGF5ZXIsIGIubGF5ZXIsIGEubmFtZSwgYi5uYW1lKTtcclxuXHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1pJbmRleCAmJiBsYXllci5zZXRaSW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fbGFzdFpJbmRleCsrO1xyXG5cdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdERvbVV0aWwuZW1wdHkodGhpcy5fYmFzZUxheWVyc0xpc3QpO1xyXG5cdFx0RG9tVXRpbC5lbXB0eSh0aGlzLl9vdmVybGF5c0xpc3QpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG5cdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50LCBvdmVybGF5c1ByZXNlbnQsIGksIG9iaiwgYmFzZUxheWVyc0NvdW50ID0gMDtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0dGhpcy5fYWRkSXRlbShvYmopO1xyXG5cdFx0XHRvdmVybGF5c1ByZXNlbnQgPSBvdmVybGF5c1ByZXNlbnQgfHwgb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzQ291bnQgKz0gIW9iai5vdmVybGF5ID8gMSA6IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmhpZGVTaW5nbGVCYXNlKSB7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgJiYgYmFzZUxheWVyc0NvdW50ID4gMTtcclxuXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2VwYXJhdG9yLnN0eWxlLmRpc3BsYXkgPSBvdmVybGF5c1ByZXNlbnQgJiYgYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb25MYXllckNoYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoVXRpbC5zdGFtcChlLnRhcmdldCkpO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBMYXllciBldmVudHNcclxuXHRcdC8vIEBldmVudCBiYXNlbGF5ZXJjaGFuZ2U6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllciBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlhZGQ6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIHNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllciBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlyZW1vdmU6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIGRlc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAbmFtZXNwYWNlIENvbnRyb2wuTGF5ZXJzXHJcblx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xyXG5cclxuXHRcdGlmICh0eXBlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIG9iaik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwOi8vYml0Lmx5L1BxWUxCZSlcclxuXHRfY3JlYXRlUmFkaW9FbGVtZW50OiBmdW5jdGlvbiAobmFtZSwgY2hlY2tlZCkge1xyXG5cclxuXHRcdHZhciByYWRpb0h0bWwgPSAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiIG5hbWU9XCInICtcclxuXHRcdFx0XHRuYW1lICsgJ1wiJyArIChjaGVja2VkID8gJyBjaGVja2VkPVwiY2hlY2tlZFwiJyA6ICcnKSArICcvPic7XHJcblxyXG5cdFx0dmFyIHJhZGlvRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdHJhZGlvRnJhZ21lbnQuaW5uZXJIVE1MID0gcmFkaW9IdG1sO1xyXG5cclxuXHRcdHJldHVybiByYWRpb0ZyYWdtZW50LmZpcnN0Q2hpbGQ7XHJcblx0fSxcclxuXHJcblx0X2FkZEl0ZW06IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyksXHJcblx0XHQgICAgY2hlY2tlZCA9IHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpLFxyXG5cdFx0ICAgIGlucHV0O1xyXG5cclxuXHRcdGlmIChvYmoub3ZlcmxheSkge1xyXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcblx0XHRcdGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xyXG5cdFx0XHRpbnB1dC5jbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3Rvcic7XHJcblx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlucHV0ID0gdGhpcy5fY3JlYXRlUmFkaW9FbGVtZW50KCdsZWFmbGV0LWJhc2UtbGF5ZXJzXycgKyBVdGlsLnN0YW1wKHRoaXMpLCBjaGVja2VkKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMucHVzaChpbnB1dCk7XHJcblx0XHRpbnB1dC5sYXllcklkID0gVXRpbC5zdGFtcChvYmoubGF5ZXIpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGlucHV0LCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpO1xyXG5cclxuXHRcdHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcclxuXHJcblx0XHQvLyBIZWxwcyBmcm9tIHByZXZlbnRpbmcgbGF5ZXIgY29udHJvbCBmbGlja2VyIHdoZW4gY2hlY2tib3hlcyBhcmUgZGlzYWJsZWRcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzI3NzFcclxuXHRcdHZhciBob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKGlucHV0KTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChuYW1lKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH0sXHJcblxyXG5cdF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcblx0XHQgICAgaW5wdXQsIGxheWVyO1xyXG5cdFx0dmFyIGFkZGVkTGF5ZXJzID0gW10sXHJcblx0XHQgICAgcmVtb3ZlZExheWVycyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblxyXG5cdFx0XHRpZiAoaW5wdXQuY2hlY2tlZCkge1xyXG5cdFx0XHRcdGFkZGVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFpbnB1dC5jaGVja2VkKSB7XHJcblx0XHRcdFx0cmVtb3ZlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJ1Z2ZpeCBpc3N1ZSAyMzE4OiBTaG91bGQgcmVtb3ZlIGFsbCBvbGQgbGF5ZXJzIGJlZm9yZSByZWFkZGluZyBuZXcgb25lc1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcihyZW1vdmVkTGF5ZXJzW2ldKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihyZW1vdmVkTGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGFkZGVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICghdGhpcy5fbWFwLmhhc0xheWVyKGFkZGVkTGF5ZXJzW2ldKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihhZGRlZExheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fcmVmb2N1c09uTWFwKCk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrRGlzYWJsZWRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcblx0XHQgICAgaW5wdXQsXHJcblx0XHQgICAgbGF5ZXIsXHJcblx0XHQgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHRcdFx0aW5wdXQuZGlzYWJsZWQgPSAobGF5ZXIub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA8IGxheWVyLm9wdGlvbnMubWluWm9vbSkgfHxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAobGF5ZXIub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA+IGxheWVyLm9wdGlvbnMubWF4Wm9vbSk7XHJcblxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9leHBhbmRJZk5vdENvbGxhcHNlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmV4cGFuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmNvbGxhcHNlKCk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmxheWVycyhiYXNlbGF5ZXJzPzogT2JqZWN0LCBvdmVybGF5cz86IE9iamVjdCwgb3B0aW9ucz86IENvbnRyb2wuTGF5ZXJzIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSBsYXllcnMgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBsYXllcnMuIEJhc2UgbGF5ZXJzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCByYWRpbyBidXR0b25zLCB3aGlsZSBvdmVybGF5cyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggY2hlY2tib3hlcy4gTm90ZSB0aGF0IGFsbCBiYXNlIGxheWVycyBzaG91bGQgYmUgcGFzc2VkIGluIHRoZSBiYXNlIGxheWVycyBvYmplY3QsIGJ1dCBvbmx5IG9uZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG1hcCBkdXJpbmcgbWFwIGluc3RhbnRpYXRpb24uXHJcbmV4cG9ydCB2YXIgbGF5ZXJzID0gZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuWm9vbVxyXG4gKiBAYWthIEwuQ29udHJvbC5ab29tXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIEEgYmFzaWMgem9vbSBjb250cm9sIHdpdGggdHdvIGJ1dHRvbnMgKHpvb20gaW4gYW5kIHpvb20gb3V0KS4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB0byBgZmFsc2VgLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIFpvb20gPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuWm9vbSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICd0b3BsZWZ0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRleHQ6IFN0cmluZyA9ICcrJ1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGV4dDogJysnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGl0bGU6IFN0cmluZyA9ICdab29tIGluJ1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJyYjeDIyMTI7J1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUZXh0OiAnJiN4MjIxMjsnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRpdGxlOiBTdHJpbmcgPSAnWm9vbSBvdXQnXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUaXRsZTogJ1pvb20gb3V0J1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR2YXIgem9vbU5hbWUgPSAnbGVhZmxldC1jb250cm9sLXpvb20nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCB6b29tTmFtZSArICcgbGVhZmxldC1iYXInKSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdHRoaXMuX3pvb21JbkJ1dHRvbiAgPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tSW5UZXh0LCBvcHRpb25zLnpvb21JblRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4pO1xyXG5cdFx0dGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21PdXRUZXh0LCBvcHRpb25zLnpvb21PdXRUaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdG1hcC5vbignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBjb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IHRydWU7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF96b29tSW46IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA8IHRoaXMuX21hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21Jbih0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3pvb21PdXQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA+IHRoaXMuX21hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uIChodG1sLCB0aXRsZSwgY2xhc3NOYW1lLCBjb250YWluZXIsIGZuKSB7XHJcblx0XHR2YXIgbGluayA9IERvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5pbm5lckhUTUwgPSBodG1sO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9IHRpdGxlO1xyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBXaWxsIGZvcmNlIHNjcmVlbiByZWFkZXJzIGxpa2UgVm9pY2VPdmVyIHRvIHJlYWQgdGhpcyBhcyBcIlpvb20gaW4gLSBidXR0b25cIlxyXG5cdFx0ICovXHJcblx0XHRsaW5rLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGxpbmspO1xyXG5cdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgRG9tRXZlbnQuc3RvcCk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcyk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLl9yZWZvY3VzT25NYXAsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBsaW5rO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBjbGFzc05hbWUgPSAnbGVhZmxldC1kaXNhYmxlZCc7XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFt6b29tIGNvbnRyb2xdKCNjb250cm9sLXpvb20pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0em9vbUNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuXHRcdC8vIEBzZWN0aW9uIENvbnRyb2xzXHJcblx0XHQvLyBAcHJvcGVydHkgem9vbUNvbnRyb2w6IENvbnRyb2wuWm9vbVxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgem9vbSBjb250cm9sIChvbmx5IGF2YWlsYWJsZSBpZiB0aGVcclxuXHRcdC8vIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgd2FzIGB0cnVlYCB3aGVuIGNyZWF0aW5nIHRoZSBtYXApLlxyXG5cdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBab29tKCk7XHJcblx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC56b29tKG9wdGlvbnM6IENvbnRyb2wuWm9vbSBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgem9vbSBjb250cm9sXHJcbmV4cG9ydCB2YXIgem9vbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBab29tKG9wdGlvbnMpO1xyXG59O1xyXG4iLCJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIENvbnRyb2wuU2NhbGVcbiAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxuICpcbiAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY29udHJvbC5zY2FsZSgpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNjYWxlID0gQ29udHJvbC5leHRlbmQoe1xuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENvbnRyb2wuU2NhbGUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0cG9zaXRpb246ICdib3R0b21sZWZ0JyxcblxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDEwMFxuXHRcdC8vIE1heGltdW0gd2lkdGggb2YgdGhlIGNvbnRyb2wgaW4gcGl4ZWxzLiBUaGUgd2lkdGggaXMgc2V0IGR5bmFtaWNhbGx5IHRvIHNob3cgcm91bmQgdmFsdWVzIChlLmcuIDEwMCwgMjAwLCA1MDApLlxuXHRcdG1heFdpZHRoOiAxMDAsXG5cblx0XHQvLyBAb3B0aW9uIG1ldHJpYzogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIG1ldHJpYyBzY2FsZSBsaW5lIChtL2ttKS5cblx0XHRtZXRyaWM6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGltcGVyaWFsOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgaW1wZXJpYWwgc2NhbGUgbGluZSAobWkvZnQpLlxuXHRcdGltcGVyaWFsOiB0cnVlXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIGlzIHVwZGF0ZWQgb24gW2Btb3ZlZW5kYF0oI21hcC1tb3ZlZW5kKSwgb3RoZXJ3aXNlIGl0J3MgYWx3YXlzIHVwLXRvLWRhdGUgKHVwZGF0ZWQgb24gW2Btb3ZlYF0oI21hcC1tb3ZlKSkuXG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXG5cdFx0ICAgIGNvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5fYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cblx0XHRtYXAub24ob3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0XHRtYXAud2hlblJlYWR5KHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdH0sXG5cblx0X2FkZFNjYWxlczogZnVuY3Rpb24gKG9wdGlvbnMsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG5cdFx0aWYgKG9wdGlvbnMubWV0cmljKSB7XG5cdFx0XHR0aGlzLl9tU2NhbGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5pbXBlcmlhbCkge1xuXHRcdFx0dGhpcy5faVNjYWxlID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHkgPSBtYXAuZ2V0U2l6ZSgpLnkgLyAyO1xuXG5cdFx0dmFyIG1heE1ldGVycyA9IG1hcC5kaXN0YW5jZShcblx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFswLCB5XSksXG5cdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLCB5XSkpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGVzKG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlczogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMubWV0cmljICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlTWV0cmljKG1heE1ldGVycyk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW1wZXJpYWwgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVJbXBlcmlhbChtYXhNZXRlcnMpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlTWV0cmljOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyksXG5cdFx0ICAgIGxhYmVsID0gbWV0ZXJzIDwgMTAwMCA/IG1ldGVycyArICcgbScgOiAobWV0ZXJzIC8gMTAwMCkgKyAnIGttJztcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX21TY2FsZSwgbGFiZWwsIG1ldGVycyAvIG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZUltcGVyaWFsOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1heEZlZXQgPSBtYXhNZXRlcnMgKiAzLjI4MDgzOTksXG5cdFx0ICAgIG1heE1pbGVzLCBtaWxlcywgZmVldDtcblxuXHRcdGlmIChtYXhGZWV0ID4gNTI4MCkge1xuXHRcdFx0bWF4TWlsZXMgPSBtYXhGZWV0IC8gNTI4MDtcblx0XHRcdG1pbGVzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWlsZXMpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBtaWxlcyArICcgbWknLCBtaWxlcyAvIG1heE1pbGVzKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmZWV0ID0gdGhpcy5fZ2V0Um91bmROdW0obWF4RmVldCk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIGZlZXQgKyAnIGZ0JywgZmVldCAvIG1heEZlZXQpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlU2NhbGU6IGZ1bmN0aW9uIChzY2FsZSwgdGV4dCwgcmF0aW8pIHtcblx0XHRzY2FsZS5zdHlsZS53aWR0aCA9IE1hdGgucm91bmQodGhpcy5vcHRpb25zLm1heFdpZHRoICogcmF0aW8pICsgJ3B4Jztcblx0XHRzY2FsZS5pbm5lckhUTUwgPSB0ZXh0O1xuXHR9LFxuXG5cdF9nZXRSb3VuZE51bTogZnVuY3Rpb24gKG51bSkge1xuXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuXHRcdCAgICBkID0gbnVtIC8gcG93MTA7XG5cblx0XHRkID0gZCA+PSAxMCA/IDEwIDpcblx0XHQgICAgZCA+PSA1ID8gNSA6XG5cdFx0ICAgIGQgPj0gMyA/IDMgOlxuXHRcdCAgICBkID49IDIgPyAyIDogMTtcblxuXHRcdHJldHVybiBwb3cxMCAqIGQ7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY29udHJvbC5zY2FsZShvcHRpb25zPzogQ29udHJvbC5TY2FsZSBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhbiBzY2FsZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgdmFyIHNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTY2FsZShvcHRpb25zKTtcbn07XG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEF0dHJpYnV0aW9uID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHByZWZpeDogU3RyaW5nID0gJ0xlYWZsZXQnXHJcblx0XHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuXHRcdHByZWZpeDogJzxhIGhyZWY9XCJodHRwczovL2xlYWZsZXRqcy5jb21cIiB0aXRsZT1cIkEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwc1wiPkxlYWZsZXQ8L2E+J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zID0ge307XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wgPSB0aGlzO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24nKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0Ly8gVE9ETyB1Z2x5LCByZWZhY3RvclxyXG5cdFx0Zm9yICh2YXIgaSBpbiBtYXAuX2xheWVycykge1xyXG5cdFx0XHRpZiAobWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFByZWZpeChwcmVmaXg6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB0ZXh0IGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLlxyXG5cdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnVmVjdG9yIGRhdGEgJmNvcHk7IE1hcGJveCdgKS5cclxuXHRhZGRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSA9IDA7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFuIGF0dHJpYnV0aW9uIHRleHQuXHJcblx0cmVtb3ZlQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XS0tO1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgYXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fYXR0cmlidXRpb25zKSB7XHJcblx0XHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcclxuXHRcdFx0XHRhdHRyaWJzLnB1c2goaSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcHJlZml4QW5kQXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucHJlZml4KSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaCh0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuXHRcdH1cclxuXHRcdGlmIChhdHRyaWJzLmxlbmd0aCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gcHJlZml4QW5kQXR0cmlicy5qb2luKCcgfCAnKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW2F0dHJpYnV0aW9uIGNvbnRyb2xdKCNjb250cm9sLWF0dHJpYnV0aW9uKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuXHRcdG5ldyBBdHRyaWJ1dGlvbigpLmFkZFRvKHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuQXR0cmlidXRpb25cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG5leHBvcnQgdmFyIGF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0NvbnRyb2wsIGNvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XG5pbXBvcnQge0xheWVycywgbGF5ZXJzfSBmcm9tICcuL0NvbnRyb2wuTGF5ZXJzJztcbmltcG9ydCB7Wm9vbSwgem9vbX0gZnJvbSAnLi9Db250cm9sLlpvb20nO1xuaW1wb3J0IHtTY2FsZSwgc2NhbGV9IGZyb20gJy4vQ29udHJvbC5TY2FsZSc7XG5pbXBvcnQge0F0dHJpYnV0aW9uLCBhdHRyaWJ1dGlvbn0gZnJvbSAnLi9Db250cm9sLkF0dHJpYnV0aW9uJztcblxuQ29udHJvbC5MYXllcnMgPSBMYXllcnM7XG5Db250cm9sLlpvb20gPSBab29tO1xuQ29udHJvbC5TY2FsZSA9IFNjYWxlO1xuQ29udHJvbC5BdHRyaWJ1dGlvbiA9IEF0dHJpYnV0aW9uO1xuXG5jb250cm9sLmxheWVycyA9IGxheWVycztcbmNvbnRyb2wuem9vbSA9IHpvb207XG5jb250cm9sLnNjYWxlID0gc2NhbGU7XG5jb250cm9sLmF0dHJpYnV0aW9uID0gYXR0cmlidXRpb247XG5cbmV4cG9ydCB7Q29udHJvbCwgY29udHJvbH07XG4iLCJpbXBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcblxuLypcblx0TC5IYW5kbGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgaGFuZGxlciBjbGFzc2VzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseSB0byBpbmplY3Rcblx0aW50ZXJhY3Rpb24gZmVhdHVyZXMgbGlrZSBkcmFnZ2luZyB0byBjbGFzc2VzIGxpa2UgTWFwIGFuZCBNYXJrZXIuXG4qL1xuXG4vLyBAY2xhc3MgSGFuZGxlclxuLy8gQGFrYSBMLkhhbmRsZXJcbi8vIEFic3RyYWN0IGNsYXNzIGZvciBtYXAgaW50ZXJhY3Rpb24gaGFuZGxlcnNcblxuZXhwb3J0IHZhciBIYW5kbGVyID0gQ2xhc3MuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpOiB0aGlzXG5cdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuYWRkSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuXHQvLyBEaXNhYmxlcyB0aGUgaGFuZGxlclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlZCgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcblx0ZW5hYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG5cdH1cblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQsIHNob3VsZCBhZGQgZXZlbnQgaG9va3MuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbn0pO1xuXG4vLyBAc2VjdGlvbiBUaGVyZSBpcyBzdGF0aWMgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5IYW5kbGVyOlxuLy8gQGZ1bmN0aW9uIGFkZFRvKG1hcDogTWFwLCBuYW1lOiBTdHJpbmcpOiB0aGlzXG4vLyBBZGRzIGEgbmV3IEhhbmRsZXIgdG8gdGhlIGdpdmVuIG1hcCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuSGFuZGxlci5hZGRUbyA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcblx0bWFwLmFkZEhhbmRsZXIobmFtZSwgdGhpcyk7XG5cdHJldHVybiB0aGlzO1xufTtcbiIsImltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi9Ccm93c2VyJztcbmV4cG9ydCB7QnJvd3Nlcn07XG5cbmV4cG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xuXG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4vRXZlbnRzJztcbmltcG9ydCB7RXZlbnRzfSBmcm9tICcuL0V2ZW50cyc7XG5leHBvcnQge0V2ZW50ZWR9O1xuZXhwb3J0IHZhciBNaXhpbiA9IHtFdmVudHM6IEV2ZW50c307XG5cbmV4cG9ydCB7SGFuZGxlcn0gZnJvbSAnLi9IYW5kbGVyJztcblxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xuZXhwb3J0IHtVdGlsfTtcbmV4cG9ydCB7ZXh0ZW5kLCBiaW5kLCBzdGFtcCwgc2V0T3B0aW9uc30gZnJvbSAnLi9VdGlsJztcbiIsImltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIERyYWdnYWJsZVxyXG4gKiBAYWthIEwuRHJhZ2dhYmxlXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIEEgY2xhc3MgZm9yIG1ha2luZyBET00gZWxlbWVudHMgZHJhZ2dhYmxlIChpbmNsdWRpbmcgdG91Y2ggc3VwcG9ydCkuXHJcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgbWFwIGFuZCBtYXJrZXIgZHJhZ2dpbmcuIE9ubHkgd29ya3MgZm9yIGVsZW1lbnRzXHJcbiAqIHRoYXQgd2VyZSBwb3NpdGlvbmVkIHdpdGggW2BMLkRvbVV0aWwuc2V0UG9zaXRpb25gXSgjZG9tdXRpbC1zZXRwb3NpdGlvbikuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBkcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoZWxlbWVudFRvRHJhZyk7XHJcbiAqIGRyYWdnYWJsZS5lbmFibGUoKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIFNUQVJUID0gQnJvd3Nlci50b3VjaCA/ICd0b3VjaHN0YXJ0IG1vdXNlZG93bicgOiAnbW91c2Vkb3duJztcclxudmFyIEVORCA9IHtcclxuXHRtb3VzZWRvd246ICdtb3VzZXVwJyxcclxuXHR0b3VjaHN0YXJ0OiAndG91Y2hlbmQnLFxyXG5cdHBvaW50ZXJkb3duOiAndG91Y2hlbmQnLFxyXG5cdE1TUG9pbnRlckRvd246ICd0b3VjaGVuZCdcclxufTtcclxudmFyIE1PVkUgPSB7XHJcblx0bW91c2Vkb3duOiAnbW91c2Vtb3ZlJyxcclxuXHR0b3VjaHN0YXJ0OiAndG91Y2htb3ZlJyxcclxuXHRwb2ludGVyZG93bjogJ3RvdWNobW92ZScsXHJcblx0TVNQb2ludGVyRG93bjogJ3RvdWNobW92ZSdcclxufTtcclxuXHJcblxyXG5leHBvcnQgdmFyIERyYWdnYWJsZSA9IEV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vIEBha2EgRHJhZ2dhYmxlIG9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gY2xpY2tUb2xlcmFuY2U6IE51bWJlciA9IDNcclxuXHRcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGNsaWNrXHJcblx0XHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIGNsaWNrIChhcyBvcHBvc2VkIHRvIGEgbW91c2UgZHJhZykuXHJcblx0XHRjbGlja1RvbGVyYW5jZTogM1xyXG5cdH0sXHJcblxyXG5cdC8vIEBjb25zdHJ1Y3RvciBMLkRyYWdnYWJsZShlbDogSFRNTEVsZW1lbnQsIGRyYWdIYW5kbGU/OiBIVE1MRWxlbWVudCwgcHJldmVudE91dGxpbmU/OiBCb29sZWFuLCBvcHRpb25zPzogRHJhZ2dhYmxlIG9wdGlvbnMpXHJcblx0Ly8gQ3JlYXRlcyBhIGBEcmFnZ2FibGVgIG9iamVjdCBmb3IgbW92aW5nIGBlbGAgd2hlbiB5b3Ugc3RhcnQgZHJhZ2dpbmcgdGhlIGBkcmFnSGFuZGxlYCBlbGVtZW50IChlcXVhbHMgYGVsYCBpdHNlbGYgYnkgZGVmYXVsdCkuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGRyYWdTdGFydFRhcmdldCwgcHJldmVudE91dGxpbmUsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcclxuXHRcdHRoaXMuX2RyYWdTdGFydFRhcmdldCA9IGRyYWdTdGFydFRhcmdldCB8fCBlbGVtZW50O1xyXG5cdFx0dGhpcy5fcHJldmVudE91dGxpbmUgPSBwcmV2ZW50T3V0bGluZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpXHJcblx0Ly8gRW5hYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0RG9tRXZlbnQub24odGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKVxyXG5cdC8vIERpc2FibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIElmIHdlJ3JlIGN1cnJlbnRseSBkcmFnZ2luZyB0aGlzIGRyYWdnYWJsZSxcclxuXHRcdC8vIGRpc2FibGluZyBpdCBjb3VudHMgYXMgZmlyc3QgZW5kaW5nIHRoZSBkcmFnLlxyXG5cdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgPT09IHRoaXMpIHtcclxuXHRcdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChEb21VdGlsLmhhc0NsYXNzKHRoaXMuX2VsZW1lbnQsICdsZWFmbGV0LXpvb20tYW5pbScpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nIHx8IGUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpICYmICFlLnRvdWNoZXMpKSB7IHJldHVybjsgfVxyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRoaXM7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcblx0XHRpZiAodGhpcy5fcHJldmVudE91dGxpbmUpIHtcclxuXHRcdFx0RG9tVXRpbC5wcmV2ZW50T3V0bGluZSh0aGlzLl9lbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcclxuXHRcdERvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEBldmVudCBkb3duOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgaXMgYWJvdXQgdG8gc3RhcnQuXHJcblx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxyXG5cdFx0ICAgIHNpemVkUGFyZW50ID0gRG9tVXRpbC5nZXRTaXplZFBhcmVudE5vZGUodGhpcy5fZWxlbWVudCk7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuXHJcblx0XHQvLyBDYWNoZSB0aGUgc2NhbGUsIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVvdXNseSBjb21wZW5zYXRlIGZvciBpdCBkdXJpbmcgZHJhZyAoX29uTW92ZSkuXHJcblx0XHR0aGlzLl9wYXJlbnRTY2FsZSA9IERvbVV0aWwuZ2V0U2NhbGUoc2l6ZWRQYXJlbnQpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCBNT1ZFW2UudHlwZV0sIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgRU5EW2UudHlwZV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcblx0XHQgICAgb2Zmc2V0ID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpLl9zdWJ0cmFjdCh0aGlzLl9zdGFydFBvaW50KTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm47IH1cclxuXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgKyBNYXRoLmFicyhvZmZzZXQueSkgPCB0aGlzLm9wdGlvbnMuY2xpY2tUb2xlcmFuY2UpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgdGhlIHBhcmVudCBjb250YWluZXIncyBwb3NpdGlvbiwgYm9yZGVyIGFuZCBzY2FsZSBkbyBub3QgY2hhbmdlIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGRyYWcuXHJcblx0XHQvLyBUaGVyZWZvcmUgdGhlcmUgaXMgbm8gbmVlZCB0byBhY2NvdW50IGZvciB0aGUgcG9zaXRpb24gYW5kIGJvcmRlciAodGhleSBhcmUgZWxpbWluYXRlZCBieSB0aGUgc3VidHJhY3Rpb24pXHJcblx0XHQvLyBhbmQgd2UgY2FuIHVzZSB0aGUgY2FjaGVkIHZhbHVlIGZvciB0aGUgc2NhbGUuXHJcblx0XHRvZmZzZXQueCAvPSB0aGlzLl9wYXJlbnRTY2FsZS54O1xyXG5cdFx0b2Zmc2V0LnkgLz0gdGhpcy5fcGFyZW50U2NhbGUueTtcclxuXHJcblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XHJcblx0XHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIHN0YXJ0c1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdzdGFydCcpO1xyXG5cclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLl9zdGFydFBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCkuc3VidHJhY3Qob2Zmc2V0KTtcclxuXHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XHJcblx0XHRcdC8vIElFIGFuZCBFZGdlIGRvIG5vdCBnaXZlIHRoZSA8dXNlPiBlbGVtZW50LCBzbyBmZXRjaCBpdFxyXG5cdFx0XHQvLyBpZiBuZWNlc3NhcnlcclxuXHRcdFx0aWYgKCh3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlKSAmJiAodGhpcy5fbGFzdFRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnRJbnN0YW5jZSkpIHtcclxuXHRcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gdGhpcy5fbGFzdFRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcclxuXHRcdFx0fVxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XHJcblx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHRcdHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVQb3NpdGlvbiwgdGhpcywgdHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZSA9IHtvcmlnaW5hbEV2ZW50OiB0aGlzLl9sYXN0RXZlbnR9O1xyXG5cclxuXHRcdC8vIEBldmVudCBwcmVkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZyAqYmVmb3JlKiBlYWNoIGNvcnJlc3BvbmRpbmdcclxuXHRcdC8vIHVwZGF0ZSBvZiB0aGUgZWxlbWVudCdzIHBvc2l0aW9uLlxyXG5cdFx0dGhpcy5maXJlKCdwcmVkcmFnJywgZSk7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuX25ld1Bvcyk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nLlxyXG5cdFx0dGhpcy5maXJlKCdkcmFnJywgZSk7XHJcblx0fSxcclxuXHJcblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcblx0fSxcclxuXHJcblx0ZmluaXNoRHJhZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0VGFyZ2V0KSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBNT1ZFKSB7XHJcblx0XHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgTU9WRVtpXSwgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCBFTkRbaV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHREb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nKSB7XHJcblx0XHRcdC8vIGVuc3VyZSBkcmFnIGlzIG5vdCBmaXJlZCBhZnRlciBkcmFnZW5kXHJcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHJcblx0XHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZHJhZyBlbmRzLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdlbmQnLCB7XHJcblx0XHRcdFx0ZGlzdGFuY2U6IHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZpbmcgPSBmYWxzZTtcclxuXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHR9XHJcblxyXG59KTtcclxuIiwiaW1wb3J0IHtQb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIExpbmVVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlsaW5lIHBvaW50cyBwcm9jZXNzaW5nLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBtYWtlIHBvbHlsaW5lcyBsaWdodG5pbmctZmFzdC5cclxuICovXHJcblxyXG4vLyBTaW1wbGlmeSBwb2x5bGluZSB3aXRoIHZlcnRleCByZWR1Y3Rpb24gYW5kIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbi5cclxuLy8gSW1wcm92ZXMgcmVuZGVyaW5nIHBlcmZvcm1hbmNlIGRyYW1hdGljYWxseSBieSBsZXNzZW5pbmcgdGhlIG51bWJlciBvZiBwb2ludHMgdG8gZHJhdy5cclxuXHJcbi8vIEBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHM6IFBvaW50W10sIHRvbGVyYW5jZTogTnVtYmVyKTogUG9pbnRbXVxyXG4vLyBEcmFtYXRpY2FsbHkgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiBhIHBvbHlsaW5lIHdoaWxlIHJldGFpbmluZ1xyXG4vLyBpdHMgc2hhcGUgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc2ltcGxpZmllZCBwb2ludHMsIHVzaW5nIHRoZVxyXG4vLyBbRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtKS5cclxuLy8gVXNlZCBmb3IgYSBodWdlIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gcHJvY2Vzc2luZy9kaXNwbGF5aW5nIExlYWZsZXQgcG9seWxpbmVzIGZvclxyXG4vLyBlYWNoIHpvb20gbGV2ZWwgYW5kIGFsc28gcmVkdWNpbmcgdmlzdWFsIG5vaXNlLiB0b2xlcmFuY2UgYWZmZWN0cyB0aGUgYW1vdW50IG9mXHJcbi8vIHNpbXBsaWZpY2F0aW9uIChsZXNzZXIgdmFsdWUgbWVhbnMgaGlnaGVyIHF1YWxpdHkgYnV0IHNsb3dlciBhbmQgd2l0aCBtb3JlIHBvaW50cykuXHJcbi8vIEFsc28gcmVsZWFzZWQgYXMgYSBzZXBhcmF0ZWQgbWljcm8tbGlicmFyeSBbU2ltcGxpZnkuanNdKGh0dHA6Ly9tb3VybmVyLmdpdGh1Yi5jb20vc2ltcGxpZnktanMvKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgdG9sZXJhbmNlKSB7XHJcblx0aWYgKCF0b2xlcmFuY2UgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuXHRcdHJldHVybiBwb2ludHMuc2xpY2UoKTtcclxuXHR9XHJcblxyXG5cdHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcclxuXHJcblx0ICAgIC8vIHN0YWdlIDE6IHZlcnRleCByZWR1Y3Rpb25cclxuXHQgICAgcG9pbnRzID0gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0ICAgIC8vIHN0YWdlIDI6IERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvblxyXG5cdCAgICBwb2ludHMgPSBfc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnQgYHBgIGFuZCBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIE1hdGguc3FydChfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCB0cnVlKSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIGNsb3Nlc3QgcG9pbnQgZnJvbSBhIHBvaW50IGBwYCBvbiBhIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMikge1xyXG5cdHJldHVybiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKTtcclxufVxyXG5cclxuLy8gRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLCBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcbmZ1bmN0aW9uIF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHJcblx0dmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXHJcblx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcblx0ICAgIG1hcmtlcnMgPSBuZXcgQXJyYXlDb25zdHJ1Y3RvcihsZW4pO1xyXG5cclxuXHQgICAgbWFya2Vyc1swXSA9IG1hcmtlcnNbbGVuIC0gMV0gPSAxO1xyXG5cclxuXHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG5cdHZhciBpLFxyXG5cdCAgICBuZXdQb2ludHMgPSBbXTtcclxuXHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAobWFya2Vyc1tpXSkge1xyXG5cdFx0XHRuZXdQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ld1BvaW50cztcclxufVxyXG5cclxuZnVuY3Rpb24gX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBsYXN0KSB7XHJcblxyXG5cdHZhciBtYXhTcURpc3QgPSAwLFxyXG5cdGluZGV4LCBpLCBzcURpc3Q7XHJcblxyXG5cdGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0IC0gMTsgaSsrKSB7XHJcblx0XHRzcURpc3QgPSBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0sIHRydWUpO1xyXG5cclxuXHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuXHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHRtYXhTcURpc3QgPSBzcURpc3Q7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcblx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGluZGV4KTtcclxuXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBpbmRleCwgbGFzdCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyByZWR1Y2UgcG9pbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyIHRvIGEgc2luZ2xlIHBvaW50XHJcbmZ1bmN0aW9uIF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cdHZhciByZWR1Y2VkUG9pbnRzID0gW3BvaW50c1swXV07XHJcblxyXG5cdGZvciAodmFyIGkgPSAxLCBwcmV2ID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAoX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0cHJldiA9IGk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChwcmV2IDwgbGVuIC0gMSkge1xyXG5cdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcblx0fVxyXG5cdHJldHVybiByZWR1Y2VkUG9pbnRzO1xyXG59XHJcblxyXG52YXIgX2xhc3RDb2RlO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGNsaXBTZWdtZW50KGE6IFBvaW50LCBiOiBQb2ludCwgYm91bmRzOiBCb3VuZHMsIHVzZUxhc3RDb2RlPzogQm9vbGVhbiwgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXXxCb29sZWFuXHJcbi8vIENsaXBzIHRoZSBzZWdtZW50IGEgdG8gYiBieSByZWN0YW5ndWxhciBib3VuZHMgd2l0aCB0aGVcclxuLy8gW0NvaGVuLVN1dGhlcmxhbmQgYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbiVFMiU4MCU5M1N1dGhlcmxhbmRfYWxnb3JpdGhtKVxyXG4vLyAobW9kaWZ5aW5nIHRoZSBzZWdtZW50IHBvaW50cyBkaXJlY3RseSEpLiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlsaW5lXHJcbi8vIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGlwU2VnbWVudChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlLCByb3VuZCkge1xyXG5cdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gX2xhc3RDb2RlIDogX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuXHQgICAgY29kZUIgPSBfZ2V0Qml0Q29kZShiLCBib3VuZHMpLFxyXG5cclxuXHQgICAgY29kZU91dCwgcCwgbmV3Q29kZTtcclxuXHJcblx0ICAgIC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG5cdCAgICBfbGFzdENvZGUgPSBjb2RlQjtcclxuXHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuXHRcdGlmICghKGNvZGVBIHwgY29kZUIpKSB7XHJcblx0XHRcdHJldHVybiBbYSwgYl07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgYSxiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIHJlamVjdClcclxuXHRcdGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlciBjYXNlc1xyXG5cdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG5cdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0bmV3Q29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcblx0XHRcdGEgPSBwO1xyXG5cdFx0XHRjb2RlQSA9IG5ld0NvZGU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRiID0gcDtcclxuXHRcdFx0Y29kZUIgPSBuZXdDb2RlO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGUsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgZHggPSBiLnggLSBhLngsXHJcblx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG5cdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdCAgICB4LCB5O1xyXG5cclxuXHRpZiAoY29kZSAmIDgpIHsgLy8gdG9wXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWF4LnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWF4Lnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWluLnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuXHRcdHggPSBtYXgueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMSkgeyAvLyBsZWZ0XHJcblx0XHR4ID0gbWluLng7XHJcblx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRCaXRDb2RlKHAsIGJvdW5kcykge1xyXG5cdHZhciBjb2RlID0gMDtcclxuXHJcblx0aWYgKHAueCA8IGJvdW5kcy5taW4ueCkgeyAvLyBsZWZ0XHJcblx0XHRjb2RlIHw9IDE7XHJcblx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuXHRcdGNvZGUgfD0gMjtcclxuXHR9XHJcblxyXG5cdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcblx0XHRjb2RlIHw9IDQ7XHJcblx0fSBlbHNlIGlmIChwLnkgPiBib3VuZHMubWF4LnkpIHsgLy8gdG9wXHJcblx0XHRjb2RlIHw9IDg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29kZTtcclxufVxyXG5cclxuLy8gc3F1YXJlIGRpc3RhbmNlICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBNYXRoLnNxcnQgY2FsbHMpXHJcbmZ1bmN0aW9uIF9zcURpc3QocDEsIHAyKSB7XHJcblx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcblx0ICAgIGR5ID0gcDIueSAtIHAxLnk7XHJcblx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG59XHJcblxyXG4vLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcclxuZXhwb3J0IGZ1bmN0aW9uIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG5cdHZhciB4ID0gcDEueCxcclxuXHQgICAgeSA9IHAxLnksXHJcblx0ICAgIGR4ID0gcDIueCAtIHgsXHJcblx0ICAgIGR5ID0gcDIueSAtIHksXHJcblx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG5cdCAgICB0O1xyXG5cclxuXHRpZiAoZG90ID4gMCkge1xyXG5cdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcblx0XHRpZiAodCA+IDEpIHtcclxuXHRcdFx0eCA9IHAyLng7XHJcblx0XHRcdHkgPSBwMi55O1xyXG5cdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG5cdFx0XHR4ICs9IGR4ICogdDtcclxuXHRcdFx0eSArPSBkeSAqIHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRkeCA9IHAueCAtIHg7XHJcblx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuXHRyZXR1cm4gc3FEaXN0ID8gZHggKiBkeCArIGR5ICogZHkgOiBuZXcgUG9pbnQoeCwgeSk7XHJcbn1cclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3M6IExhdExuZ1tdKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIHRydWUgaWYgYGxhdGxuZ3NgIGlzIGEgZmxhdCBhcnJheSwgZmFsc2UgaXMgbmVzdGVkLlxyXG5leHBvcnQgZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3MpIHtcclxuXHRyZXR1cm4gIVV0aWwuaXNBcnJheShsYXRsbmdzWzBdKSB8fCAodHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZmxhdChsYXRsbmdzKSB7XHJcblx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIHVzZSBvZiBfZmxhdCwgcGxlYXNlIHVzZSBMLkxpbmVVdGlsLmlzRmxhdCBpbnN0ZWFkLicpO1xyXG5cdHJldHVybiBpc0ZsYXQobGF0bG5ncyk7XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi9MaW5lVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFBvbHlVdGlsXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlnb24gZ2VvbWV0cmllcy5cclxuICovXHJcblxyXG4vKiBAZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzOiBQb2ludFtdLCBib3VuZHM6IEJvdW5kcywgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXVxyXG4gKiBDbGlwcyB0aGUgcG9seWdvbiBnZW9tZXRyeSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBgcG9pbnRzYCBieSB0aGUgZ2l2ZW4gYm91bmRzICh1c2luZyB0aGUgW1N1dGhlcmxhbmQtSG9kZ21hbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobSkpLlxyXG4gKiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlnb24gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZ1xyXG4gKiBwZXJmb3JtYW5jZS4gTm90ZSB0aGF0IHBvbHlnb24gcG9pbnRzIG5lZWRzIGRpZmZlcmVudCBhbGdvcml0aG0gZm9yIGNsaXBwaW5nXHJcbiAqIHRoYW4gcG9seWxpbmUsIHNvIHRoZXJlJ3MgYSBzZXBhcmF0ZSBtZXRob2QgZm9yIGl0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50cywgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBjbGlwcGVkUG9pbnRzLFxyXG5cdCAgICBlZGdlcyA9IFsxLCA0LCAyLCA4XSxcclxuXHQgICAgaSwgaiwgayxcclxuXHQgICAgYSwgYixcclxuXHQgICAgbGVuLCBlZGdlLCBwO1xyXG5cclxuXHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHBvaW50c1tpXS5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHBvaW50c1tpXSwgYm91bmRzKTtcclxuXHR9XHJcblxyXG5cdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcclxuXHRmb3IgKGsgPSAwOyBrIDwgNDsgaysrKSB7XHJcblx0XHRlZGdlID0gZWRnZXNba107XHJcblx0XHRjbGlwcGVkUG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuXHRcdFx0YSA9IHBvaW50c1tpXTtcclxuXHRcdFx0YiA9IHBvaW50c1tqXTtcclxuXHJcblx0XHRcdC8vIGlmIGEgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvd1xyXG5cdFx0XHRpZiAoIShhLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHQvLyBpZiBiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGdvZXMgb3V0IG9mIHNjcmVlbilcclxuXHRcdFx0XHRpZiAoYi5fY29kZSAmIGVkZ2UpIHtcclxuXHRcdFx0XHRcdHAgPSBMaW5lVXRpbC5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRcdHAuX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdHAgPSBMaW5lVXRpbC5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRwLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59XHJcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBzZWN0aW9uXHJcbiAqIExlYWZsZXQgY29tZXMgd2l0aCBhIHNldCBvZiBhbHJlYWR5IGRlZmluZWQgUHJvamVjdGlvbnMgb3V0IG9mIHRoZSBib3g6XHJcbiAqXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5Mb25MYXRcclxuICpcclxuICogRXF1aXJlY3Rhbmd1bGFyLCBvciBQbGF0ZSBDYXJyZWUgcHJvamVjdGlvbiDigJQgdGhlIG1vc3Qgc2ltcGxlIHByb2plY3Rpb24sXHJcbiAqIG1vc3RseSB1c2VkIGJ5IEdJUyBlbnRodXNpYXN0cy4gRGlyZWN0bHkgbWFwcyBgeGAgYXMgbG9uZ2l0dWRlLCBhbmQgYHlgIGFzXHJcbiAqIGxhdGl0dWRlLiBBbHNvIHN1aXRhYmxlIGZvciBmbGF0IHdvcmxkcywgZS5nLiBnYW1lIG1hcHMuIFVzZWQgYnkgdGhlXHJcbiAqIGBFUFNHOjQzMjZgIGFuZCBgU2ltcGxlYCBDUlMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMb25MYXQgPSB7XHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMTgwLCAtOTBdLCBbMTgwLCA5MF0pXHJcbn07XHJcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5NZXJjYXRvclxyXG4gKlxyXG4gKiBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIG1vcmUgY29tcGxleCB0aGFuIFNwaGVyaWNhbCBNZXJjYXRvci4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzIGFuIGVsbGlwc29pZC4gVXNlZCBieSB0aGUgRVBTRzozMzk1IENSUy5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIE1lcmNhdG9yID0ge1xyXG5cdFI6IDYzNzgxMzcsXHJcblx0Ul9NSU5PUjogNjM1Njc1Mi4zMTQyNDUxNzksXHJcblxyXG5cdGJvdW5kczogbmV3IEJvdW5kcyhbLTIwMDM3NTA4LjM0Mjc5LCAtMTU0OTY1NzAuNzM5NzJdLCBbMjAwMzc1MDguMzQyNzksIDE4NzY0NjU2LjIzMTM4XSksXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHkgPSBsYXRsbmcubGF0ICogZCxcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgY29uID0gZSAqIE1hdGguc2luKHkpO1xyXG5cclxuXHRcdHZhciB0cyA9IE1hdGgudGFuKE1hdGguUEkgLyA0IC0geSAvIDIpIC8gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHR5ID0gLXIgKiBNYXRoLmxvZyhNYXRoLm1heCh0cywgMUUtMTApKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGxhdGxuZy5sbmcgKiBkICogciwgeSk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSSxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICB0cyA9IE1hdGguZXhwKC1wb2ludC55IC8gciksXHJcblx0XHQgICAgcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgZHBoaSA9IDAuMSwgY29uOyBpIDwgMTUgJiYgTWF0aC5hYnMoZHBoaSkgPiAxZS03OyBpKyspIHtcclxuXHRcdFx0Y29uID0gZSAqIE1hdGguc2luKHBoaSk7XHJcblx0XHRcdGNvbiA9IE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0XHRkcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzICogY29uKSAtIHBoaTtcclxuXHRcdFx0cGhpICs9IGRwaGk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocGhpICogZCwgcG9pbnQueCAqIGQgLyByKTtcclxuXHR9XHJcbn07XHJcbiIsIi8qXG4gKiBAY2xhc3MgUHJvamVjdGlvblxuXG4gKiBBbiBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBwcm9qZWN0aW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgd29ybGQgb250b1xuICogYSBmbGF0IHN1cmZhY2UgKGFuZCBiYWNrKS4gU2VlIFtNYXAgcHJvamVjdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBfcHJvamVjdGlvbikuXG5cbiAqIEBwcm9wZXJ0eSBib3VuZHM6IEJvdW5kc1xuICogVGhlIGJvdW5kcyAoc3BlY2lmaWVkIGluIENSUyB1bml0cykgd2hlcmUgdGhlIHByb2plY3Rpb24gaXMgdmFsaWRcblxuICogQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcbiAqIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGEgMkQgcG9pbnQuXG4gKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gKiBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcbiAqIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC4gUHJvamVjdHMgYSAyRCBwb2ludCBpbnRvIGEgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLlxuICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gKiBOb3RlIHRoYXQgdGhlIHByb2plY3Rpb24gaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXG4gKiBhbmQgY2FuJ3QgYmUgaW5zdGFudGlhdGVkLiBBbHNvLCBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gdGhlbSxcbiAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxuXG4gKi9cblxuZXhwb3J0IHtMb25MYXR9IGZyb20gJy4vUHJvamVjdGlvbi5Mb25MYXQnO1xuZXhwb3J0IHtNZXJjYXRvcn0gZnJvbSAnLi9Qcm9qZWN0aW9uLk1lcmNhdG9yJztcbmV4cG9ydCB7U3BoZXJpY2FsTWVyY2F0b3J9IGZyb20gJy4vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvcic7XG4iLCJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7TWVyY2F0b3J9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5NZXJjYXRvcic7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czMzk1XHJcbiAqXHJcbiAqIFJhcmVseSB1c2VkIGJ5IHNvbWUgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gVXNlcyBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgdmFyIEVQU0czMzk1ID0gVXRpbC5leHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6MzM5NScsXHJcblx0cHJvamVjdGlvbjogTWVyY2F0b3IsXHJcblxyXG5cdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBNZXJjYXRvci5SKTtcclxuXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG4iLCJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7TG9uTGF0fSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTG9uTGF0JztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzQzMjZcclxuICpcclxuICogQSBjb21tb24gQ1JTIGFtb25nIEdJUyBlbnRodXNpYXN0cy4gVXNlcyBzaW1wbGUgRXF1aXJlY3Rhbmd1bGFyIHByb2plY3Rpb24uXHJcbiAqXHJcbiAqIExlYWZsZXQgMS4wLnggY29tcGxpZXMgd2l0aCB0aGUgW1RNUyBjb29yZGluYXRlIHNjaGVtZSBmb3IgRVBTRzo0MzI2XShodHRwczovL3dpa2kub3NnZW8ub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZV9TcGVjaWZpY2F0aW9uI2dsb2JhbC1nZW9kZXRpYyksXHJcbiAqIHdoaWNoIGlzIGEgYnJlYWtpbmcgY2hhbmdlIGZyb20gMC43LnggYmVoYXZpb3VyLiAgSWYgeW91IGFyZSB1c2luZyBhIGBUaWxlTGF5ZXJgXHJcbiAqIHdpdGggdGhpcyBDUlMsIGVuc3VyZSB0aGF0IHRoZXJlIGFyZSB0d28gMjU2eDI1NiBwaXhlbCB0aWxlcyBjb3ZlcmluZyB0aGVcclxuICogd2hvbGUgZWFydGggYXQgem9vbSBsZXZlbCB6ZXJvLCBhbmQgdGhhdCB0aGUgdGlsZSBjb29yZGluYXRlIG9yaWdpbiBpcyAoLTE4MCwrOTApLFxyXG4gKiBvciAoLTE4MCwtOTApIGZvciBgVGlsZUxheWVyYHMgd2l0aCBbdGhlIGB0bXNgIG9wdGlvbl0oI3RpbGVsYXllci10bXMpIHNldC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEVQU0c0MzI2ID0gVXRpbC5leHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6NDMyNicsXHJcblx0cHJvamVjdGlvbjogTG9uTGF0LFxyXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEgLyAxODAsIDEsIC0xIC8gMTgwLCAwLjUpXHJcbn0pO1xyXG4iLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0IHtMb25MYXR9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQnO1xuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIENSU1xuICogQGNycyBMLkNSUy5TaW1wbGVcbiAqXG4gKiBBIHNpbXBsZSBDUlMgdGhhdCBtYXBzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgaW50byBgeGAgYW5kIGB5YCBkaXJlY3RseS5cbiAqIE1heSBiZSB1c2VkIGZvciBtYXBzIG9mIGZsYXQgc3VyZmFjZXMgKGUuZy4gZ2FtZSBtYXBzKS4gTm90ZSB0aGF0IHRoZSBgeWBcbiAqIGF4aXMgc2hvdWxkIHN0aWxsIGJlIGludmVydGVkIChnb2luZyBmcm9tIGJvdHRvbSB0byB0b3ApLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogc2ltcGxlIGV1Y2xpZGVhbiBkaXN0YW5jZS5cbiAqL1xuXG5leHBvcnQgdmFyIFNpbXBsZSA9IFV0aWwuZXh0ZW5kKHt9LCBDUlMsIHtcblx0cHJvamVjdGlvbjogTG9uTGF0LFxuXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxLCAwLCAtMSwgMCksXG5cblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0cmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xuXHR9LFxuXG5cdHpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSkgLyBNYXRoLkxOMjtcblx0fSxcblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgZHggPSBsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nLFxuXHRcdCAgICBkeSA9IGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQ7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0fSxcblxuXHRpbmZpbml0ZTogdHJ1ZVxufSk7XG4iLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xuaW1wb3J0IHtFUFNHMzM5NX0gZnJvbSAnLi9DUlMuRVBTRzMzOTUnO1xuaW1wb3J0IHtFUFNHMzg1NywgRVBTRzkwMDkxM30gZnJvbSAnLi9DUlMuRVBTRzM4NTcnO1xuaW1wb3J0IHtFUFNHNDMyNn0gZnJvbSAnLi9DUlMuRVBTRzQzMjYnO1xuaW1wb3J0IHtTaW1wbGV9IGZyb20gJy4vQ1JTLlNpbXBsZSc7XG5cbkNSUy5FYXJ0aCA9IEVhcnRoO1xuQ1JTLkVQU0czMzk1ID0gRVBTRzMzOTU7XG5DUlMuRVBTRzM4NTcgPSBFUFNHMzg1NztcbkNSUy5FUFNHOTAwOTEzID0gRVBTRzkwMDkxMztcbkNSUy5FUFNHNDMyNiA9IEVQU0c0MzI2O1xuQ1JTLlNpbXBsZSA9IFNpbXBsZTtcblxuZXhwb3J0IHtDUlN9O1xuIiwiaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgTGF5ZXJcbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBAYWthIEwuTGF5ZXJcbiAqIEBha2EgSUxheWVyXG4gKlxuICogQSBzZXQgb2YgbWV0aG9kcyBmcm9tIHRoZSBMYXllciBiYXNlIGNsYXNzIHRoYXQgYWxsIExlYWZsZXQgbGF5ZXJzIHVzZS5cbiAqIEluaGVyaXRzIGFsbCBtZXRob2RzLCBvcHRpb25zIGFuZCBldmVudHMgZnJvbSBgTC5FdmVudGVkYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLm1hcmtlcihsYXRsbmcpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5hZGRUbyhtYXApO1xuICogbGF5ZXIucmVtb3ZlKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXZlbnQgYWRkOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIGFkZGVkIHRvIGEgbWFwXG4gKlxuICogQGV2ZW50IHJlbW92ZTogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBtYXBcbiAqL1xuXG5cbmV4cG9ydCB2YXIgTGF5ZXIgPSBFdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdvdmVybGF5UGFuZSdcblx0XHQvLyBCeSBkZWZhdWx0IHRoZSBsYXllciB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAncyBbb3ZlcmxheSBwYW5lXSgjbWFwLW92ZXJsYXlwYW5lKS4gT3ZlcnJpZGluZyB0aGlzIG9wdGlvbiB3aWxsIGNhdXNlIHRoZSBsYXllciB0byBiZSBwbGFjZWQgb24gYW5vdGhlciBwYW5lIGJ5IGRlZmF1bHQuXG5cdFx0cGFuZTogJ292ZXJsYXlQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb246IFN0cmluZyA9IG51bGxcblx0XHQvLyBTdHJpbmcgdG8gYmUgc2hvd24gaW4gdGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wsIGUuZy4gXCLCqSBPcGVuU3RyZWV0TWFwIGNvbnRyaWJ1dG9yc1wiLiBJdCBkZXNjcmliZXMgdGhlIGxheWVyIGRhdGEgYW5kIGlzIG9mdGVuIGEgbGVnYWwgb2JsaWdhdGlvbiB0b3dhcmRzIGNvcHlyaWdodCBob2xkZXJzIGFuZCB0aWxlIHByb3ZpZGVycy5cblx0XHRhdHRyaWJ1dGlvbjogbnVsbCxcblxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcblx0fSxcblxuXHQvKiBAc2VjdGlvblxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcblx0ICpcblx0ICogQG1ldGhvZCBhZGRUbyhtYXA6IE1hcHxMYXllckdyb3VwKTogdGhpc1xuXHQgKiBBZGRzIHRoZSBsYXllciB0byB0aGUgZ2l2ZW4gbWFwIG9yIGxheWVyIGdyb3VwLlxuXHQgKi9cblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZUZyb20odGhpcy5fbWFwIHx8IHRoaXMuX21hcFRvQWRkKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20obWFwOiBNYXApOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIG1hcFxuXHRyZW1vdmVGcm9tOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0aWYgKG9iaikge1xuXHRcdFx0b2JqLnJlbW92ZUxheWVyKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFBhbmUobmFtZT8gOiBTdHJpbmcpOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIHJlcHJlc2VudGluZyB0aGUgbmFtZWQgcGFuZSBvbiB0aGUgbWFwLiBJZiBgbmFtZWAgaXMgb21pdHRlZCwgcmV0dXJucyB0aGUgcGFuZSBmb3IgdGhpcyBsYXllci5cblx0Z2V0UGFuZTogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFwLmdldFBhbmUobmFtZSA/ICh0aGlzLm9wdGlvbnNbbmFtZV0gfHwgbmFtZSkgOiB0aGlzLm9wdGlvbnMucGFuZSk7XG5cdH0sXG5cblx0YWRkSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdHRoaXMuX21hcC5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRhcmdldEVsKV0gPSB0aGlzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHRkZWxldGUgdGhpcy5fbWFwLl90YXJnZXRzW1V0aWwuc3RhbXAodGFyZ2V0RWwpXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEF0dHJpYnV0aW9uOiBTdHJpbmdcblx0Ly8gVXNlZCBieSB0aGUgYGF0dHJpYnV0aW9uIGNvbnRyb2xgLCByZXR1cm5zIHRoZSBbYXR0cmlidXRpb24gb3B0aW9uXSgjZ3JpZGxheWVyLWF0dHJpYnV0aW9uKS5cblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuXHR9LFxuXG5cdF9sYXllckFkZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gZS50YXJnZXQ7XG5cblx0XHQvLyBjaGVjayBpbiBjYXNlIGxheWVyIGdldHMgYWRkZWQgYW5kIHRoZW4gcmVtb3ZlZCBiZWZvcmUgdGhlIG1hcCBpcyByZWFkeVxuXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xuXG5cdFx0aWYgKHRoaXMuZ2V0RXZlbnRzKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5nZXRFdmVudHMoKTtcblx0XHRcdG1hcC5vbihldmVudHMsIHRoaXMpO1xuXHRcdFx0dGhpcy5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdG1hcC5vZmYoZXZlbnRzLCB0aGlzKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMub25BZGQobWFwKTtcblxuXHRcdGlmICh0aGlzLmdldEF0dHJpYnV0aW9uICYmIG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcblx0XHRcdG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuYWRkQXR0cmlidXRpb24odGhpcy5nZXRBdHRyaWJ1dGlvbigpKTtcblx0XHR9XG5cblx0XHR0aGlzLmZpcmUoJ2FkZCcpO1xuXHRcdG1hcC5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogdGhpc30pO1xuXHR9XG59KTtcblxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAqIEB1bmluaGVyaXRhYmxlXG4gKlxuICogRXZlcnkgbGF5ZXIgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkxheWVyYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxuICpcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBjb2RlIHRoYXQgY3JlYXRlcyBET00gZWxlbWVudHMgZm9yIHRoZSBsYXllciwgYWRkcyB0aGVtIHRvIGBtYXAgcGFuZXNgIHdoZXJlIHRoZXkgc2hvdWxkIGJlbG9uZyBhbmQgcHV0cyBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLlxuICpcbiAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApOiB0aGlzXG4gKiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxheWVyJ3MgZWxlbWVudHMgZnJvbSB0aGUgRE9NIGFuZCByZW1vdmVzIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjbGF5ZXItb25hZGQpLiBDYWxsZWQgb24gW2BtYXAucmVtb3ZlTGF5ZXIobGF5ZXIpYF0oI21hcC1yZW1vdmVsYXllcikuXG4gKlxuICogQG1ldGhvZCBnZXRFdmVudHMoKTogT2JqZWN0XG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBsaWtlIGB7IHZpZXdyZXNldDogdGhpcy5fcmVzZXQgfWAgZm9yIFtgYWRkRXZlbnRMaXN0ZW5lcmBdKCNldmVudGVkLWFkZGV2ZW50bGlzdGVuZXIpLiBUaGUgZXZlbnQgaGFuZGxlcnMgaW4gdGhpcyBvYmplY3Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIG1hcCB3aXRoIHlvdXIgbGF5ZXIuXG4gKlxuICogQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbigpOiBTdHJpbmdcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgY29udGFpbmluZyBIVE1MIHRvIGJlIHNob3duIG9uIHRoZSBgQXR0cmlidXRpb24gY29udHJvbGAgd2hlbmV2ZXIgdGhlIGxheWVyIGlzIHZpc2libGUuXG4gKlxuICogQG1ldGhvZCBiZWZvcmVBZGQobWFwOiBNYXApOiB0aGlzXG4gKiBPcHRpb25hbCBtZXRob2QuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKSwgYmVmb3JlIHRoZSBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLCBiZWZvcmUgZXZlbnRzIGFyZSBpbml0aWFsaXplZCwgd2l0aG91dCB3YWl0aW5nIHVudGlsIHRoZSBtYXAgaXMgaW4gYSB1c2FibGUgc3RhdGUuIFVzZSBmb3IgZWFybHkgaW5pdGlhbGl6YXRpb24gb25seS5cbiAqL1xuXG5cbi8qIEBuYW1lc3BhY2UgTWFwXG4gKiBAc2VjdGlvbiBMYXllciBldmVudHNcbiAqXG4gKiBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gYSBuZXcgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAqXG4gKiBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcbiAqIEZpcmVkIHdoZW4gc29tZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcFxuICpcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAqL1xuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIG1hcFxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCFsYXllci5fbGF5ZXJBZGQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIG9iamVjdCBpcyBub3QgYSBMYXllci4nKTtcblx0XHR9XG5cblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcblxuXHRcdGxheWVyLl9tYXBUb0FkZCA9IHRoaXM7XG5cblx0XHRpZiAobGF5ZXIuYmVmb3JlQWRkKSB7XG5cdFx0XHRsYXllci5iZWZvcmVBZGQodGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy53aGVuUmVhZHkobGF5ZXIuX2xheWVyQWRkLCBsYXllcik7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgbWFwLlxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gVXRpbC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdGxheWVyLm9uUmVtb3ZlKHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5nZXRBdHRyaWJ1dGlvbiAmJiB0aGlzLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wucmVtb3ZlQXR0cmlidXRpb24obGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xuXHRcdFx0bGF5ZXIuZmlyZSgncmVtb3ZlJyk7XG5cdFx0fVxuXG5cdFx0bGF5ZXIuX21hcCA9IGxheWVyLl9tYXBUb0FkZCA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgbWFwXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRyZXR1cm4gISFsYXllciAmJiAoVXRpbC5zdGFtcChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcblx0fSxcblxuXHQvKiBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXG5cdCAqIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgbWFwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXG5cdCAqIGBgYFxuXHQgKiBtYXAuZWFjaExheWVyKGZ1bmN0aW9uKGxheWVyKXtcblx0ICogICAgIGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcblx0ICogfSk7XG5cdCAqIGBgYFxuXHQgKi9cblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9hZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcblx0XHRsYXllcnMgPSBsYXllcnMgPyAoVXRpbC5pc0FycmF5KGxheWVycykgPyBsYXllcnMgOiBbbGF5ZXJzXSkgOiBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZFpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKGlzTmFOKGxheWVyLm9wdGlvbnMubWF4Wm9vbSkgfHwgIWlzTmFOKGxheWVyLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVyc1tVdGlsLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gVXRpbC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAodGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF07XG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVab29tTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1pblpvb20gPSBJbmZpbml0eSxcblx0XHQgICAgbWF4Wm9vbSA9IC1JbmZpbml0eSxcblx0XHQgICAgb2xkWm9vbVNwYW4gPSB0aGlzLl9nZXRab29tU3BhbigpO1xuXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2ldLm9wdGlvbnM7XG5cblx0XHRcdG1pblpvb20gPSBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IG1pblpvb20gOiBNYXRoLm1pbihtaW5ab29tLCBvcHRpb25zLm1pblpvb20pO1xuXHRcdFx0bWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gbWF4Wm9vbSA6IE1hdGgubWF4KG1heFpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGF5ZXJzTWF4Wm9vbSA9IG1heFpvb20gPT09IC1JbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1heFpvb207XG5cdFx0dGhpcy5fbGF5ZXJzTWluWm9vbSA9IG1pblpvb20gPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbWluWm9vbTtcblxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHpvb21sZXZlbHNjaGFuZ2U6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHpvb21sZXZlbHMgb24gdGhlIG1hcCBpcyBjaGFuZ2VkIGR1ZVxuXHRcdC8vIHRvIGFkZGluZyBvciByZW1vdmluZyBhIGxheWVyLlxuXHRcdGlmIChvbGRab29tU3BhbiAhPT0gdGhpcy5fZ2V0Wm9vbVNwYW4oKSkge1xuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWF4Wm9vbSAmJiB0aGlzLmdldFpvb20oKSA+IHRoaXMuX2xheWVyc01heFpvb20pIHtcblx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNYXhab29tKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWluWm9vbSAmJiB0aGlzLmdldFpvb20oKSA8IHRoaXMuX2xheWVyc01pblpvb20pIHtcblx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNaW5ab29tKTtcblx0XHR9XG5cdH1cbn0pO1xuIiwiXHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gKiBAYWthIEwuTGF5ZXJHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICpcclxuICogVXNlZCB0byBncm91cCBzZXZlcmFsIGxheWVycyBhbmQgaGFuZGxlIHRoZW0gYXMgb25lLiBJZiB5b3UgYWRkIGl0IHRvIHRoZSBtYXAsXHJcbiAqIGFueSBsYXllcnMgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgb24gdGhlIG1hcCBhc1xyXG4gKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubGF5ZXJHcm91cChbbWFya2VyMSwgbWFya2VyMl0pXHJcbiAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIExheWVyR3JvdXAgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0dmFyIGksIGxlbjtcclxuXHJcblx0XHRpZiAobGF5ZXJzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBncm91cC5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihpZDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElEIGZyb20gdGhlIGdyb3VwLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIoaWQ6IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gISFsYXllciAmJiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzIHx8IHRoaXMuZ2V0TGF5ZXJJZChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsZWFyTGF5ZXJzKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFsbCB0aGUgbGF5ZXJzIGZyb20gdGhlIGdyb3VwLlxyXG5cdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZW1vdmVMYXllciwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZva2UobWV0aG9kTmFtZTogU3RyaW5nLCDigKYpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYG1ldGhvZE5hbWVgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIGFueVxyXG5cdC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVycy4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgbGF5ZXJzIGNvbnRhaW5lZCBkbyBub3RcclxuXHQvLyBpbXBsZW1lbnQgYG1ldGhvZE5hbWVgLlxyXG5cdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuXHRcdCAgICBpLCBsYXllcjtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcblx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5hZGRMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobWFwLnJlbW92ZUxheWVyLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIGdyb3VwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXHJcblx0Ly8gYGBganNcclxuXHQvLyBncm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0Ly8gXHRsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XHJcblx0Ly8gfSk7XHJcblx0Ly8gYGBgXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcihpZDogTnVtYmVyKTogTGF5ZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRC5cclxuXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVycygpOiBMYXllcltdXHJcblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGxheWVycyBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLmVhY2hMYXllcihsYXllcnMucHVzaCwgbGF5ZXJzKTtcclxuXHRcdHJldHVybiBsYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYHNldFpJbmRleGAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgdGhlIHotaW5kZXguXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcklkKGxheWVyOiBMYXllcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGludGVybmFsIElEIGZvciBhIGxheWVyXHJcblx0Z2V0TGF5ZXJJZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gVXRpbC5zdGFtcChsYXllcik7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxheWVyR3JvdXAobGF5ZXJzPzogTGF5ZXJbXSwgb3B0aW9ucz86IE9iamVjdClcclxuLy8gQ3JlYXRlIGEgbGF5ZXIgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgdmFyIGxheWVyR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllckdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbn07XHJcbiIsImltcG9ydCB7TGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEZlYXR1cmVHcm91cFxyXG4gKiBAYWthIEwuRmVhdHVyZUdyb3VwXHJcbiAqIEBpbmhlcml0cyBMYXllckdyb3VwXHJcbiAqXHJcbiAqIEV4dGVuZGVkIGBMYXllckdyb3VwYCB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBkbyB0aGUgc2FtZSB0aGluZyB0byBhbGwgaXRzIG1lbWJlciBsYXllcnM6XHJcbiAqICAqIFtgYmluZFBvcHVwYF0oI2xheWVyLWJpbmRwb3B1cCkgYmluZHMgYSBwb3B1cCB0byBhbGwgb2YgdGhlIGxheWVycyBhdCBvbmNlIChsaWtld2lzZSB3aXRoIFtgYmluZFRvb2x0aXBgXSgjbGF5ZXItYmluZHRvb2x0aXApKVxyXG4gKiAgKiBFdmVudHMgYXJlIHByb3BhZ2F0ZWQgdG8gdGhlIGBGZWF0dXJlR3JvdXBgLCBzbyBpZiB0aGUgZ3JvdXAgaGFzIGFuIGV2ZW50XHJcbiAqIGhhbmRsZXIsIGl0IHdpbGwgaGFuZGxlIGV2ZW50cyBmcm9tIGFueSBvZiB0aGUgbGF5ZXJzLiBUaGlzIGluY2x1ZGVzIG1vdXNlIGV2ZW50c1xyXG4gKiBhbmQgY3VzdG9tIGV2ZW50cy5cclxuICogICogSGFzIGBsYXllcmFkZGAgYW5kIGBsYXllcnJlbW92ZWAgZXZlbnRzXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwuZmVhdHVyZUdyb3VwKFttYXJrZXIxLCBtYXJrZXIyLCBwb2x5bGluZV0pXHJcbiAqIFx0LmJpbmRQb3B1cCgnSGVsbG8gd29ybGQhJylcclxuICogXHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGFsZXJ0KCdDbGlja2VkIG9uIGEgbWVtYmVyIG9mIHRoZSBncm91cCEnKTsgfSlcclxuICogXHQuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBGZWF0dXJlR3JvdXAgPSBMYXllckdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMYXllckdyb3VwLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyBhZGRlZCB0byB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxheWVyIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcl07XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnaXZlbiBwYXRoIG9wdGlvbnMgdG8gZWFjaCBsYXllciBvZiB0aGUgZ3JvdXAgdGhhdCBoYXMgYSBgc2V0U3R5bGVgIG1ldGhvZC5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFN0eWxlJywgc3R5bGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvRnJvbnQnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSBiYWNrIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvQmFjaycpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGUgRmVhdHVyZSBHcm91cCAoY3JlYXRlZCBmcm9tIGJvdW5kcyBhbmQgY29vcmRpbmF0ZXMgb2YgaXRzIGNoaWxkcmVuKS5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XHJcblx0XHRcdGJvdW5kcy5leHRlbmQobGF5ZXIuZ2V0Qm91bmRzID8gbGF5ZXIuZ2V0Qm91bmRzKCkgOiBsYXllci5nZXRMYXRMbmcoKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmZlYXR1cmVHcm91cChsYXllcnM6IExheWVyW10pXHJcbi8vIENyZWF0ZSBhIGZlYXR1cmUgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzLlxyXG5leHBvcnQgdmFyIGZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0NsYXNzfSBmcm9tICcuLi8uLi9jb3JlL0NsYXNzJztcclxuaW1wb3J0IHtzZXRPcHRpb25zfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IHtyZXRpbmF9IGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgSWNvblxyXG4gKiBAYWthIEwuSWNvblxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGljb24gdG8gcHJvdmlkZSB3aGVuIGNyZWF0aW5nIGEgbWFya2VyLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbXlJY29uID0gTC5pY29uKHtcclxuICogICAgIGljb25Vcmw6ICdteS1pY29uLnBuZycsXHJcbiAqICAgICBpY29uUmV0aW5hVXJsOiAnbXktaWNvbkAyeC5wbmcnLFxyXG4gKiAgICAgaWNvblNpemU6IFszOCwgOTVdLFxyXG4gKiAgICAgaWNvbkFuY2hvcjogWzIyLCA5NF0sXHJcbiAqICAgICBwb3B1cEFuY2hvcjogWy0zLCAtNzZdLFxyXG4gKiAgICAgc2hhZG93VXJsOiAnbXktaWNvbi1zaGFkb3cucG5nJyxcclxuICogICAgIHNoYWRvd1JldGluYVVybDogJ215LWljb24tc2hhZG93QDJ4LnBuZycsXHJcbiAqICAgICBzaGFkb3dTaXplOiBbNjgsIDk1XSxcclxuICogICAgIHNoYWRvd0FuY2hvcjogWzIyLCA5NF1cclxuICogfSk7XHJcbiAqXHJcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBgTC5JY29uLkRlZmF1bHRgIGV4dGVuZHMgYEwuSWNvbmAgYW5kIGlzIHRoZSBibHVlIGljb24gTGVhZmxldCB1c2VzIGZvciBtYXJrZXJzIGJ5IGRlZmF1bHQuXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBJY29uID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEljb24gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogKioocmVxdWlyZWQpKiogVGhlIFVSTCB0byB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91ciBzY3JpcHQgcGF0aCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25SZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIGEgcmV0aW5hIHNpemVkIHZlcnNpb24gb2YgdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXJcclxuXHQgKiBzY3JpcHQgcGF0aCkuIFVzZWQgZm9yIFJldGluYSBzY3JlZW4gZGV2aWNlcy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblNpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIGljb24gaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uQW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIGljb24gKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpLiBUaGUgaWNvblxyXG5cdCAqIHdpbGwgYmUgYWxpZ25lZCBzbyB0aGF0IHRoaXMgcG9pbnQgaXMgYXQgdGhlIG1hcmtlcidzIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi4gQ2VudGVyZWRcclxuXHQgKiBieSBkZWZhdWx0IGlmIHNpemUgaXMgc3BlY2lmaWVkLCBhbHNvIGNhbiBiZSBzZXQgaW4gQ1NTIHdpdGggbmVnYXRpdmUgbWFyZ2lucy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9wdXBBbmNob3I6IFBvaW50ID0gWzAsIDBdXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHBvcHVwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHRvb2x0aXBBbmNob3I6IFBvaW50ID0gWzAsIDBdXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHRvb2x0aXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93VXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byB0aGUgaWNvbiBzaGFkb3cgaW1hZ2UuIElmIG5vdCBzcGVjaWZpZWQsIG5vIHNoYWRvdyBpbWFnZSB3aWxsIGJlIGNyZWF0ZWQuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1JldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dTaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBzaGFkb3cgaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dBbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgc2hhZG93IChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKSAodGhlIHNhbWVcclxuXHQgKiBhcyBpY29uQW5jaG9yIGlmIG5vdCBzcGVjaWZpZWQpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0ICogQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gYm90aCBpY29uIGFuZCBzaGFkb3cgaW1hZ2VzLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdCAqL1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3B1cEFuY2hvcjogWzAsIDBdLFxyXG5cdFx0dG9vbHRpcEFuY2hvcjogWzAsIDBdXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVJY29uKG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ2FsbGVkIGludGVybmFsbHkgd2hlbiB0aGUgaWNvbiBoYXMgdG8gYmUgc2hvd24sIHJldHVybnMgYSBgPGltZz5gIEhUTUwgZWxlbWVudFxyXG5cdC8vIHN0eWxlZCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnMuXHJcblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdpY29uJywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVTaGFkb3cob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBBcyBgY3JlYXRlSWNvbmAsIGJ1dCBmb3IgdGhlIHNoYWRvdyBiZW5lYXRoIGl0LlxyXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdzaGFkb3cnLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSWNvbjogZnVuY3Rpb24gKG5hbWUsIG9sZEljb24pIHtcclxuXHRcdHZhciBzcmMgPSB0aGlzLl9nZXRJY29uVXJsKG5hbWUpO1xyXG5cclxuXHRcdGlmICghc3JjKSB7XHJcblx0XHRcdGlmIChuYW1lID09PSAnaWNvbicpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMsIG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnSU1HJyA/IG9sZEljb24gOiBudWxsKTtcclxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoaW1nLCBuYW1lKTtcclxuXHJcblx0XHRyZXR1cm4gaW1nO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRJY29uU3R5bGVzOiBmdW5jdGlvbiAoaW1nLCBuYW1lKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHRcdHZhciBzaXplT3B0aW9uID0gb3B0aW9uc1tuYW1lICsgJ1NpemUnXTtcclxuXHJcblx0XHRpZiAodHlwZW9mIHNpemVPcHRpb24gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdHNpemVPcHRpb24gPSBbc2l6ZU9wdGlvbiwgc2l6ZU9wdGlvbl07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNpemUgPSBwb2ludChzaXplT3B0aW9uKSxcclxuXHRcdCAgICBhbmNob3IgPSBwb2ludChuYW1lID09PSAnc2hhZG93JyAmJiBvcHRpb25zLnNoYWRvd0FuY2hvciB8fCBvcHRpb25zLmljb25BbmNob3IgfHxcclxuXHRcdCAgICAgICAgICAgIHNpemUgJiYgc2l6ZS5kaXZpZGVCeSgyLCB0cnVlKSk7XHJcblxyXG5cdFx0aW1nLmNsYXNzTmFtZSA9ICdsZWFmbGV0LW1hcmtlci0nICsgbmFtZSArICcgJyArIChvcHRpb25zLmNsYXNzTmFtZSB8fCAnJyk7XHJcblxyXG5cdFx0aWYgKGFuY2hvcikge1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luTGVmdCA9ICgtYW5jaG9yLngpICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoLWFuY2hvci55KSArICdweCc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNpemUpIHtcclxuXHRcdFx0aW1nLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJbWc6IGZ1bmN0aW9uIChzcmMsIGVsKSB7XHJcblx0XHRlbCA9IGVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cdFx0ZWwuc3JjID0gc3JjO1xyXG5cdFx0cmV0dXJuIGVsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0cmV0dXJuIHJldGluYSAmJiB0aGlzLm9wdGlvbnNbbmFtZSArICdSZXRpbmFVcmwnXSB8fCB0aGlzLm9wdGlvbnNbbmFtZSArICdVcmwnXTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuaWNvbihvcHRpb25zOiBJY29uIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gaWNvbiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gaWNvbihvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBJY29uKG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQG1pbmljbGFzcyBJY29uLkRlZmF1bHQgKEljb24pXG4gKiBAYWthIEwuSWNvbi5EZWZhdWx0XG4gKiBAc2VjdGlvblxuICpcbiAqIEEgdHJpdmlhbCBzdWJjbGFzcyBvZiBgSWNvbmAsIHJlcHJlc2VudHMgdGhlIGljb24gdG8gdXNlIGluIGBNYXJrZXJgcyB3aGVuXG4gKiBubyBpY29uIGlzIHNwZWNpZmllZC4gUG9pbnRzIHRvIHRoZSBibHVlIG1hcmtlciBpbWFnZSBkaXN0cmlidXRlZCB3aXRoIExlYWZsZXRcbiAqIHJlbGVhc2VzLlxuICpcbiAqIEluIG9yZGVyIHRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBpY29uLCBqdXN0IGNoYW5nZSB0aGUgcHJvcGVydGllcyBvZiBgTC5JY29uLkRlZmF1bHQucHJvdG90eXBlLm9wdGlvbnNgXG4gKiAod2hpY2ggaXMgYSBzZXQgb2YgYEljb24gb3B0aW9uc2ApLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIF9jb21wbGV0ZWx5XyByZXBsYWNlIHRoZSBkZWZhdWx0IGljb24sIG92ZXJyaWRlIHRoZVxuICogYEwuTWFya2VyLnByb3RvdHlwZS5vcHRpb25zLmljb25gIHdpdGggeW91ciBvd24gaWNvbiBpbnN0ZWFkLlxuICovXG5cbmV4cG9ydCB2YXIgSWNvbkRlZmF1bHQgPSBJY29uLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGljb25Vcmw6ICAgICAgICdtYXJrZXItaWNvbi5wbmcnLFxuXHRcdGljb25SZXRpbmFVcmw6ICdtYXJrZXItaWNvbi0yeC5wbmcnLFxuXHRcdHNoYWRvd1VybDogICAgICdtYXJrZXItc2hhZG93LnBuZycsXG5cdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuXHRcdGljb25BbmNob3I6ICBbMTIsIDQxXSxcblx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG5cdFx0dG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuXHRcdHNoYWRvd1NpemU6ICBbNDEsIDQxXVxuXHR9LFxuXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmICghSWNvbkRlZmF1bHQuaW1hZ2VQYXRoKSB7XHQvLyBEZXByZWNhdGVkLCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBvbmx5XG5cdFx0XHRJY29uRGVmYXVsdC5pbWFnZVBhdGggPSB0aGlzLl9kZXRlY3RJY29uUGF0aCgpO1xuXHRcdH1cblxuXHRcdC8vIEBvcHRpb24gaW1hZ2VQYXRoOiBTdHJpbmdcblx0XHQvLyBgSWNvbi5EZWZhdWx0YCB3aWxsIHRyeSB0byBhdXRvLWRldGVjdCB0aGUgbG9jYXRpb24gb2YgdGhlXG5cdFx0Ly8gYmx1ZSBpY29uIGltYWdlcy4gSWYgeW91IGFyZSBwbGFjaW5nIHRoZXNlIGltYWdlcyBpbiBhIG5vbi1zdGFuZGFyZFxuXHRcdC8vIHdheSwgc2V0IHRoaXMgb3B0aW9uIHRvIHBvaW50IHRvIHRoZSByaWdodCBwYXRoLlxuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLmltYWdlUGF0aCB8fCBJY29uRGVmYXVsdC5pbWFnZVBhdGgpICsgSWNvbi5wcm90b3R5cGUuX2dldEljb25VcmwuY2FsbCh0aGlzLCBuYW1lKTtcblx0fSxcblxuXHRfZGV0ZWN0SWNvblBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWwgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgICdsZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoJywgZG9jdW1lbnQuYm9keSk7XG5cdFx0dmFyIHBhdGggPSBEb21VdGlsLmdldFN0eWxlKGVsLCAnYmFja2dyb3VuZC1pbWFnZScpIHx8XG5cdFx0ICAgICAgICAgICBEb21VdGlsLmdldFN0eWxlKGVsLCAnYmFja2dyb3VuZEltYWdlJyk7XHQvLyBJRThcblxuXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuXG5cdFx0aWYgKHBhdGggPT09IG51bGwgfHwgcGF0aC5pbmRleE9mKCd1cmwnKSAhPT0gMCkge1xuXHRcdFx0cGF0aCA9ICcnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC9edXJsXFwoW1wiJ10/LywgJycpLnJlcGxhY2UoL21hcmtlci1pY29uXFwucG5nW1wiJ10/XFwpJC8sICcnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0aDtcblx0fVxufSk7XG4iLCJpbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7cmVxdWVzdEFuaW1GcmFtZSwgY2FuY2VsQW5pbUZyYW1lfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXJrZXJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gKlxuICogSW50ZXJhY3Rpb24gaGFuZGxlcnMgYXJlIHByb3BlcnRpZXMgb2YgYSBtYXJrZXIgaW5zdGFuY2UgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbCBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoIGFzIGRyYWdnaW5nIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICogYGBgXG4gKlxuICogQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLiBPbmx5IHZhbGlkIHdoZW4gdGhlIG1hcmtlciBpcyBvbiB0aGUgbWFwIChPdGhlcndpc2Ugc2V0IFtgbWFya2VyLm9wdGlvbnMuZHJhZ2dhYmxlYF0oI21hcmtlci1kcmFnZ2FibGUpKS5cbiAqL1xuXG5leHBvcnQgdmFyIE1hcmtlckRyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHR0aGlzLl9tYXJrZXIgPSBtYXJrZXI7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblxuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKGljb24sIGljb24sIHRydWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZW5hYmxlKCk7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5vZmYoe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXIuX2ljb24pIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHQgICAgbWFwID0gbWFya2VyLl9tYXAsXG5cdFx0ICAgIHNwZWVkID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblNwZWVkLFxuXHRcdCAgICBwYWRkaW5nID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcsXG5cdFx0ICAgIGljb25Qb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGJvdW5kcyA9IG1hcC5nZXRQaXhlbEJvdW5kcygpLFxuXHRcdCAgICBvcmlnaW4gPSBtYXAuZ2V0UGl4ZWxPcmlnaW4oKTtcblxuXHRcdHZhciBwYW5Cb3VuZHMgPSB0b0JvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4uX3N1YnRyYWN0KG9yaWdpbikuYWRkKHBhZGRpbmcpLFxuXHRcdFx0Ym91bmRzLm1heC5fc3VidHJhY3Qob3JpZ2luKS5zdWJ0cmFjdChwYWRkaW5nKVxuXHRcdCk7XG5cblx0XHRpZiAoIXBhbkJvdW5kcy5jb250YWlucyhpY29uUG9zKSkge1xuXHRcdFx0Ly8gQ29tcHV0ZSBpbmNyZW1lbnRhbCBtb3ZlbWVudFxuXHRcdFx0dmFyIG1vdmVtZW50ID0gdG9Qb2ludChcblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5tYXgueCkgLyAoYm91bmRzLm1heC54IC0gcGFuQm91bmRzLm1heC54KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLngsIGljb25Qb3MueCkgLSBwYW5Cb3VuZHMubWluLngpIC8gKGJvdW5kcy5taW4ueCAtIHBhbkJvdW5kcy5taW4ueCksXG5cblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5tYXgueSkgLyAoYm91bmRzLm1heC55IC0gcGFuQm91bmRzLm1heC55KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWluLnkpIC8gKGJvdW5kcy5taW4ueSAtIHBhbkJvdW5kcy5taW4ueSlcblx0XHRcdCkubXVsdGlwbHlCeShzcGVlZCk7XG5cblx0XHRcdG1hcC5wYW5CeShtb3ZlbWVudCwge2FuaW1hdGU6IGZhbHNlfSk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLl9hZGQobW92ZW1lbnQpO1xuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5fYWRkKG1vdmVtZW50KTtcblxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihtYXJrZXIuX2ljb24sIHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zKTtcblx0XHRcdHRoaXMuX29uRHJhZyhlKTtcblxuXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBAc2VjdGlvbiBEcmFnZ2luZyBldmVudHNcblx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdGFydHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblxuXHRcdHRoaXMuX29sZExhdExuZyA9IHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKTtcblx0XHR0aGlzLl9tYXJrZXJcblx0XHQgICAgLmNsb3NlUG9wdXAoKVxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXHR9LFxuXG5cdF9vblByZURyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW4pIHtcblx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuXHRcdCAgICBzaGFkb3cgPSBtYXJrZXIuX3NoYWRvdyxcblx0XHQgICAgaWNvblBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcblx0XHQgICAgbGF0bG5nID0gbWFya2VyLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xuXG5cdFx0Ly8gdXBkYXRlIHNoYWRvdyBwb3NpdGlvblxuXHRcdGlmIChzaGFkb3cpIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcblx0XHR9XG5cblx0XHRtYXJrZXIuX2xhdGxuZyA9IGxhdGxuZztcblx0XHRlLmxhdGxuZyA9IGxhdGxuZztcblx0XHRlLm9sZExhdExuZyA9IHRoaXMuX29sZExhdExuZztcblxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIG1hcmtlci5cblx0XHRtYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdCBjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG5cblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RvcHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblx0XHRkZWxldGUgdGhpcy5fb2xkTGF0TG5nO1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZWVuZCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnZW5kJywgZSk7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xyXG5pbXBvcnQge0ljb25EZWZhdWx0fSBmcm9tICcuL0ljb24uRGVmYXVsdCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZyBhcyBsYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IHtNYXJrZXJEcmFnfSBmcm9tICcuL01hcmtlci5EcmFnJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBNYXJrZXJcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqIEBha2EgTC5NYXJrZXJcclxuICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWFya2VyID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIE1hcmtlciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBpY29uOiBJY29uID0gKlxyXG5cdFx0Ly8gSWNvbiBpbnN0YW5jZSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbWFya2VyLlxyXG5cdFx0Ly8gU2VlIFtJY29uIGRvY3VtZW50YXRpb25dKCNMLkljb24pIGZvciBkZXRhaWxzIG9uIGhvdyB0byBjdXN0b21pemUgdGhlIG1hcmtlciBpY29uLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCwgYSBjb21tb24gaW5zdGFuY2Ugb2YgYEwuSWNvbi5EZWZhdWx0YCBpcyB1c2VkLlxyXG5cdFx0aWNvbjogbmV3IEljb25EZWZhdWx0KCksXHJcblxyXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xyXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBjYW4gYmUgdGFiYmVkIHRvIHdpdGggYSBrZXlib2FyZCBhbmQgY2xpY2tlZCBieSBwcmVzc2luZyBlbnRlci5cclxuXHRcdGtleWJvYXJkOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYnJvd3NlciB0b29sdGlwIHRoYXQgYXBwZWFyIG9uIG1hcmtlciBob3ZlciAobm8gdG9vbHRpcCBieSBkZWZhdWx0KS5cclxuXHRcdHRpdGxlOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGljb24gaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4T2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBtYXJrZXIgaW1hZ2VzIHpJbmRleCBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgbGF0aXR1ZGUuIFVzZSB0aGlzIG9wdGlvbiBpZiB5b3Ugd2FudCB0byBwdXQgdGhlIG1hcmtlciBvbiB0b3Agb2YgYWxsIG90aGVycyAob3IgYmVsb3cpLCBzcGVjaWZ5aW5nIGEgaGlnaCB2YWx1ZSBsaWtlIGAxMDAwYCAob3IgaGlnaCBuZWdhdGl2ZSB2YWx1ZSwgcmVzcGVjdGl2ZWx5KS5cclxuXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT25Ib3ZlcjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBtYXJrZXIgd2lsbCBnZXQgb24gdG9wIG9mIG90aGVycyB3aGVuIHlvdSBob3ZlciB0aGUgbW91c2Ugb3ZlciBpdC5cclxuXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPZmZzZXQ6IE51bWJlciA9IDI1MFxyXG5cdFx0Ly8gVGhlIHotaW5kZXggb2Zmc2V0IHVzZWQgZm9yIHRoZSBgcmlzZU9uSG92ZXJgIGZlYXR1cmUuXHJcblx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnbWFya2VyUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgaWNvbiB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3NoYWRvd1BhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIHNoYWRvdyB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0c2hhZG93UGFuZTogJ3NoYWRvd1BhbmUnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIG1hcmtlciB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxyXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXHJcblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBEcmFnZ2FibGUgbWFya2VyIG9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gZHJhZ2dhYmxlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXHJcblx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRvIHBhbiB0aGUgbWFwIHdoZW4gZHJhZ2dpbmcgdGhpcyBtYXJrZXIgbmVhciBpdHMgZWRnZSBvciBub3QuXHJcblx0XHRhdXRvUGFuOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUwLCA1MClcclxuXHRcdC8vIERpc3RhbmNlIChpbiBwaXhlbHMgdG8gdGhlIGxlZnQvcmlnaHQgYW5kIHRvIHRoZSB0b3AvYm90dG9tKSBvZiB0aGVcclxuXHRcdC8vIG1hcCBlZGdlIHRvIHN0YXJ0IHBhbm5pbmcgdGhlIG1hcC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNTAsIDUwXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5TcGVlZDogTnVtYmVyID0gMTBcclxuXHRcdC8vIE51bWJlciBvZiBwaXhlbHMgdGhlIG1hcCBzaG91bGQgcGFuIGJ5LlxyXG5cdFx0YXV0b1BhblNwZWVkOiAxMFxyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICpcclxuXHQgKiBJbiBhZGRpdGlvbiB0byBbc2hhcmVkIGxheWVyIG1ldGhvZHNdKCNMYXllcikgbGlrZSBgYWRkVG8oKWAgYW5kIGByZW1vdmUoKWAgYW5kIFtwb3B1cCBtZXRob2RzXSgjUG9wdXApIGxpa2UgYmluZFBvcHVwKCkgeW91IGNhbiBhbHNvIHVzZSB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IGxhdExuZyhsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmICh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nLnJlbW92ZUhvb2tzKCk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgdGhpcy5kcmFnZ2luZztcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0em9vbTogdGhpcy51cGRhdGUsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy51cGRhdGVcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBwb3NpdGlvbiB0byB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gbGF0TG5nKGxhdGxuZyk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNtYXJrZXItc2V0bGF0bG5nKSBvciBieSBbZHJhZ2dpbmddKCNtYXJrZXItZHJhZ2dpbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXhPZmZzZXQob2Zmc2V0OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleCBvZmZzZXRdKCNtYXJrZXItemluZGV4b2Zmc2V0KSBvZiB0aGUgbWFya2VyLlxyXG5cdHNldFpJbmRleE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9IG9mZnNldDtcclxuXHRcdHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0SWNvbjogSWNvblxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgaWNvbiB1c2VkIGJ5IHRoZSBtYXJrZXJcclxuXHRnZXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb247XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRJY29uKGljb246IEljb24pOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIGljb24uXHJcblx0c2V0SWNvbjogZnVuY3Rpb24gKGljb24pIHtcclxuXHJcblx0XHR0aGlzLm9wdGlvbnMuaWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLmJpbmRQb3B1cCh0aGlzLl9wb3B1cCwgdGhpcy5fcG9wdXAub3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ljb247XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24gJiYgdGhpcy5fbWFwKSB7XHJcblx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICBjbGFzc1RvQWRkID0gJ2xlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xyXG5cclxuXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcblx0XHQgICAgYWRkSWNvbiA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGlmIHdlJ3JlIG5vdCByZXVzaW5nIHRoZSBpY29uLCByZW1vdmUgdGhlIG9sZCBvbmUgYW5kIGluaXQgbmV3IG9uZVxyXG5cdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YWRkSWNvbiA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy50aXRsZSkge1xyXG5cdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaWNvbi50YWdOYW1lID09PSAnSU1HJykge1xyXG5cdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQgfHwgJyc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sIGNsYXNzVG9BZGQpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmtleWJvYXJkKSB7XHJcblx0XHRcdGljb24udGFiSW5kZXggPSAnMCc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdTaGFkb3cgPSBvcHRpb25zLmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdyksXHJcblx0XHQgICAgYWRkU2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdyAhPT0gdGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdFx0XHRhZGRTaGFkb3cgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhuZXdTaGFkb3csIGNsYXNzVG9BZGQpO1xyXG5cdFx0XHRuZXdTaGFkb3cuYWx0ID0gJyc7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBuZXdTaGFkb3c7XHJcblxyXG5cclxuXHRcdGlmIChvcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKGFkZEljb24pIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faWNvbik7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuXHRcdGlmIChuZXdTaGFkb3cgJiYgYWRkU2hhZG93KSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZShvcHRpb25zLnNoYWRvd1BhbmUpLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vZmYoe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9pY29uKTtcclxuXHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfc2V0UG9zOiBmdW5jdGlvbiAocG9zKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9pY29uLCBwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9zaGFkb3csIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fekluZGV4ID0gcG9zLnkgKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuX3Jlc2V0WkluZGV4KCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAob3B0KSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBvcHQuem9vbSwgb3B0LmNlbnRlcikucm91bmQoKTtcclxuXHJcblx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEludGVyYWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pY29uLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cclxuXHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0aWYgKE1hcmtlckRyYWcpIHtcclxuXHRcdFx0dmFyIGRyYWdnYWJsZSA9IHRoaXMub3B0aW9ucy5kcmFnZ2FibGU7XHJcblx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcblx0XHRcdFx0ZHJhZ2dhYmxlID0gdGhpcy5kcmFnZ2luZy5lbmFibGVkKCk7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBuZXcgTWFya2VyRHJhZyh0aGlzKTtcclxuXHJcblx0XHRcdGlmIChkcmFnZ2FibGUpIHtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3BhY2l0eSA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pY29uLCBvcGFjaXR5KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9zaGFkb3csIG9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCh0aGlzLm9wdGlvbnMucmlzZU9mZnNldCk7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0WkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoMCk7XHJcblx0fSxcclxuXHJcblx0X2dldFBvcHVwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy5wb3B1cEFuY2hvcjtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9vbHRpcEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMudG9vbHRpcEFuY2hvcjtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcblxyXG4vLyBAZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgTWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtlcihsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBQYXRoXG4gKiBAYWthIEwuUGF0aFxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXG4gKlxuICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBjb250YWlucyBvcHRpb25zIGFuZCBjb25zdGFudHMgc2hhcmVkIGJldHdlZW4gdmVjdG9yXG4gKiBvdmVybGF5cyAoUG9seWdvbiwgUG9seWxpbmUsIENpcmNsZSkuIERvIG5vdCB1c2UgaXQgZGlyZWN0bHkuIEV4dGVuZHMgYExheWVyYC5cbiAqL1xuXG5leHBvcnQgdmFyIFBhdGggPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUGF0aCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHN0cm9rZTogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGV0aGVyIHRvIGRyYXcgc3Ryb2tlIGFsb25nIHRoZSBwYXRoLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRzdHJva2U6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGNvbG9yOiBTdHJpbmcgPSAnIzMzODhmZidcblx0XHQvLyBTdHJva2UgY29sb3Jcblx0XHRjb2xvcjogJyMzMzg4ZmYnLFxuXG5cdFx0Ly8gQG9wdGlvbiB3ZWlnaHQ6IE51bWJlciA9IDNcblx0XHQvLyBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG5cdFx0d2VpZ2h0OiAzLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBTdHJva2Ugb3BhY2l0eVxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVDYXA6IFN0cmluZz0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVDYXA6ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVKb2luOiBTdHJpbmcgPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBjb3JuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lam9pbikgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lSm9pbjogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gZGFzaEFycmF5OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hBcnJheTogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZGFzaE9mZnNldDogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgW2Rpc3RhbmNlIGludG8gdGhlIGRhc2ggcGF0dGVybiB0byBzdGFydCB0aGUgZGFzaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaG9mZnNldCkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoT2Zmc2V0OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsOiBCb29sZWFuID0gZGVwZW5kc1xuXHRcdC8vIFdoZXRoZXIgdG8gZmlsbCB0aGUgcGF0aCB3aXRoIGNvbG9yLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGZpbGxpbmcgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRmaWxsOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gZmlsbENvbG9yOiBTdHJpbmcgPSAqXG5cdFx0Ly8gRmlsbCBjb2xvci4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBbYGNvbG9yYF0oI3BhdGgtY29sb3IpIG9wdGlvblxuXHRcdGZpbGxDb2xvcjogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbE9wYWNpdHk6IE51bWJlciA9IDAuMlxuXHRcdC8vIEZpbGwgb3BhY2l0eS5cblx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsUnVsZTogU3RyaW5nID0gJ2V2ZW5vZGQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cblx0XHRmaWxsUnVsZTogJ2V2ZW5vZGQnLFxuXG5cdFx0Ly8gY2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3Ncblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIHBhdGggd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcblx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiB0cnVlXG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0Ly8gUmVuZGVyZXIgaXMgc2V0IGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIGNhbGwgcmVuZGVyZXIuZ2V0RXZlbnRzXG5cdFx0Ly8gYmVmb3JlIHRoaXMuZ2V0RXZlbnRzLlxuXHRcdHRoaXMuX3JlbmRlcmVyID0gbWFwLmdldFJlbmRlcmVyKHRoaXMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2luaXRQYXRoKHRoaXMpO1xuXHRcdHRoaXMuX3Jlc2V0KCk7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2FkZFBhdGgodGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdygpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIGxheWVyLiBTb21ldGltZXMgdXNlZnVsIGFmdGVyIHlvdSBjaGFuZ2VkIHRoZSBjb29yZGluYXRlcyB0aGF0IHRoZSBwYXRoIHVzZXMuXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIGFwcGVhcmFuY2Ugb2YgYSBQYXRoIGJhc2VkIG9uIHRoZSBvcHRpb25zIGluIHRoZSBgUGF0aCBvcHRpb25zYCBvYmplY3QuXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgc3R5bGUpO1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVN0eWxlKHRoaXMpO1xuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zdHJva2UgJiYgc3R5bGUgJiYgc3R5bGUuaGFzT3duUHJvcGVydHkoJ3dlaWdodCcpKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9Gcm9udCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0JhY2sodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXNcblx0XHR0aGlzLl9wcm9qZWN0KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2NsaWNrVG9sZXJhbmNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdXNlZCB3aGVuIGRvaW5nIGhpdCBkZXRlY3Rpb24gZm9yIENhbnZhcyBsYXllcnNcblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICsgdGhpcy5fcmVuZGVyZXIub3B0aW9ucy50b2xlcmFuY2U7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuXG4vKlxuICogQGNsYXNzIENpcmNsZU1hcmtlclxuICogQGFrYSBMLkNpcmNsZU1hcmtlclxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNpcmNsZSBvZiBhIGZpeGVkIHNpemUgd2l0aCByYWRpdXMgc3BlY2lmaWVkIGluIHBpeGVscy4gRXh0ZW5kcyBgUGF0aGAuXG4gKi9cblxuZXhwb3J0IHZhciBDaXJjbGVNYXJrZXIgPSBQYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDaXJjbGVNYXJrZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXIgPSAxMFxuXHRcdC8vIFJhZGl1cyBvZiB0aGUgY2lyY2xlIG1hcmtlciwgaW4gcGl4ZWxzXG5cdFx0cmFkaXVzOiAxMFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdExuZzogTGF0TG5nKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIGNpcmNsZSBtYXJrZXIgdG8gYSBuZXcgbG9jYXRpb24uXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLnJlZHJhdygpO1xuXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNjaXJjbGVtYXJrZXItc2V0bGF0bG5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZygpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlIG1hcmtlci4gVW5pdHMgYXJlIGluIHBpeGVscy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5vcHRpb25zLnJhZGl1cyA9IHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgdGhlIGNpcmNsZVxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzO1xuXHR9LFxuXG5cdHNldFN0eWxlIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHR2YXIgcmFkaXVzID0gb3B0aW9ucyAmJiBvcHRpb25zLnJhZGl1cyB8fCB0aGlzLl9yYWRpdXM7XG5cdFx0UGF0aC5wcm90b3R5cGUuc2V0U3R5bGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLnNldFJhZGl1cyhyYWRpdXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH0sXG5cblx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByID0gdGhpcy5fcmFkaXVzLFxuXHRcdCAgICByMiA9IHRoaXMuX3JhZGl1c1kgfHwgcixcblx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBbciArIHcsIHIyICsgd107XG5cdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LnN1YnRyYWN0KHApLCB0aGlzLl9wb2ludC5hZGQocCkpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZUNpcmNsZSh0aGlzKTtcblx0fSxcblxuXHRfZW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzICYmICF0aGlzLl9yZW5kZXJlci5fYm91bmRzLmludGVyc2VjdHModGhpcy5fcHhCb3VuZHMpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0cmV0dXJuIHAuZGlzdGFuY2VUbyh0aGlzLl9wb2ludCkgPD0gdGhpcy5fcmFkaXVzICsgdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jaXJjbGVNYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGVNYXJrZXIgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBtYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IENpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtDaXJjbGVNYXJrZXJ9IGZyb20gJy4vQ2lyY2xlTWFya2VyJztcbmltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi4vLi4vZ2VvL2Nycy9DUlMuRWFydGgnO1xuXG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlXG4gKiBAYWthIEwuQ2lyY2xlXG4gKiBAaW5oZXJpdHMgQ2lyY2xlTWFya2VyXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBjaXJjbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYENpcmNsZU1hcmtlcmAuXG4gKlxuICogSXQncyBhbiBhcHByb3hpbWF0aW9uIGFuZCBzdGFydHMgdG8gZGl2ZXJnZSBmcm9tIGEgcmVhbCBjaXJjbGUgY2xvc2VyIHRvIHBvbGVzIChkdWUgdG8gcHJvamVjdGlvbiBkaXN0b3J0aW9uKS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBMLmNpcmNsZShbNTAuNSwgMzAuNV0sIHtyYWRpdXM6IDIwMH0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIENpcmNsZSA9IENpcmNsZU1hcmtlci5leHRlbmQoe1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGZhY3RvcnkgKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zPylcblx0XHRcdG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgbGVnYWN5T3B0aW9ucywge3JhZGl1czogb3B0aW9uc30pO1xuXHRcdH1cblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblxuXHRcdGlmIChpc05hTih0aGlzLm9wdGlvbnMucmFkaXVzKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0NpcmNsZSByYWRpdXMgY2Fubm90IGJlIE5hTicpOyB9XG5cblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgQ2lyY2xlIG9wdGlvbnNcblx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyOyBSYWRpdXMgb2YgdGhlIGNpcmNsZSwgaW4gbWV0ZXJzLlxuXHRcdHRoaXMuX21SYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuXHRcdHRoaXMuX21SYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbVJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBoYWxmID0gW3RoaXMuX3JhZGl1cywgdGhpcy5fcmFkaXVzWSB8fCB0aGlzLl9yYWRpdXNdO1xuXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LnN1YnRyYWN0KGhhbGYpKSxcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKGhhbGYpKSk7XG5cdH0sXG5cblx0c2V0U3R5bGU6IFBhdGgucHJvdG90eXBlLnNldFN0eWxlLFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbG5nID0gdGhpcy5fbGF0bG5nLmxuZyxcblx0XHQgICAgbGF0ID0gdGhpcy5fbGF0bG5nLmxhdCxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoY3JzLmRpc3RhbmNlID09PSBFYXJ0aC5kaXN0YW5jZSkge1xuXHRcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdFx0ICAgIGxhdFIgPSAodGhpcy5fbVJhZGl1cyAvIEVhcnRoLlIpIC8gZCxcblx0XHRcdCAgICB0b3AgPSBtYXAucHJvamVjdChbbGF0ICsgbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgYm90dG9tID0gbWFwLnByb2plY3QoW2xhdCAtIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIHAgPSB0b3AuYWRkKGJvdHRvbSkuZGl2aWRlQnkoMiksXG5cdFx0XHQgICAgbGF0MiA9IG1hcC51bnByb2plY3QocCkubGF0LFxuXHRcdFx0ICAgIGxuZ1IgPSBNYXRoLmFjb3MoKE1hdGguY29zKGxhdFIgKiBkKSAtIE1hdGguc2luKGxhdCAqIGQpICogTWF0aC5zaW4obGF0MiAqIGQpKSAvXG5cdFx0XHQgICAgICAgICAgICAoTWF0aC5jb3MobGF0ICogZCkgKiBNYXRoLmNvcyhsYXQyICogZCkpKSAvIGQ7XG5cblx0XHRcdGlmIChpc05hTihsbmdSKSB8fCBsbmdSID09PSAwKSB7XG5cdFx0XHRcdGxuZ1IgPSBsYXRSIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIGxhdCk7IC8vIEZhbGxiYWNrIGZvciBlZGdlIGNhc2UsICMyNDI1XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gcC5zdWJ0cmFjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSBpc05hTihsbmdSKSA/IDAgOiBwLnggLSBtYXAucHJvamVjdChbbGF0MiwgbG5nIC0gbG5nUl0pLng7XG5cdFx0XHR0aGlzLl9yYWRpdXNZID0gcC55IC0gdG9wLnk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxhdGxuZzIgPSBjcnMudW5wcm9qZWN0KGNycy5wcm9qZWN0KHRoaXMuX2xhdGxuZykuc3VidHJhY3QoW3RoaXMuX21SYWRpdXMsIDBdKSk7XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5fcG9pbnQueCAtIG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nMikueDtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9ucyBvYmplY3Rcbi8vIHdoaWNoIGNvbnRhaW5zIHRoZSBjaXJjbGUgcmFkaXVzLlxuLy8gQGFsdGVybmF0aXZlXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgcmFkaXVzOiBOdW1iZXIsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIE9ic29sZXRlIHdheSBvZiBpbnN0YW50aWF0aW5nIGEgY2lyY2xlLCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGNvZGUuXG4vLyBEbyBub3QgdXNlIGluIG5ldyBhcHBsaWNhdGlvbnMgb3IgcGx1Z2lucy5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9MaW5lVXRpbCc7XG5pbXBvcnQge0xhdExuZywgdG9MYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5cbi8qXG4gKiBAY2xhc3MgUG9seWxpbmVcbiAqIEBha2EgTC5Qb2x5bGluZVxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlsaW5lIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQYXRoYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0WzQ1LjUxLCAtMTIyLjY4XSxcbiAqIFx0WzM3Ljc3LCAtMTIyLjQzXSxcbiAqIFx0WzM0LjA0LCAtMTE4LjJdXG4gKiBdO1xuICpcbiAqIHZhciBwb2x5bGluZSA9IEwucG9seWxpbmUobGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5bGluZVxuICogbWFwLmZpdEJvdW5kcyhwb2x5bGluZS5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIGBNdWx0aVBvbHlsaW5lYCBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbWzQ1LjUxLCAtMTIyLjY4XSxcbiAqIFx0IFszNy43NywgLTEyMi40M10sXG4gKiBcdCBbMzQuMDQsIC0xMTguMl1dLFxuICogXHRbWzQwLjc4LCAtNzMuOTFdLFxuICogXHQgWzQxLjgzLCAtODcuNjJdLFxuICogXHQgWzMyLjc2LCAtOTYuNzJdXVxuICogXTtcbiAqIGBgYFxuICovXG5cblxuZXhwb3J0IHZhciBQb2x5bGluZSA9IFBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBvbHlsaW5lIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gc21vb3RoRmFjdG9yOiBOdW1iZXIgPSAxLjBcblx0XHQvLyBIb3cgbXVjaCB0byBzaW1wbGlmeSB0aGUgcG9seWxpbmUgb24gZWFjaCB6b29tIGxldmVsLiBNb3JlIG1lYW5zXG5cdFx0Ly8gYmV0dGVyIHBlcmZvcm1hbmNlIGFuZCBzbW9vdGhlciBsb29rLCBhbmQgbGVzcyBtZWFucyBtb3JlIGFjY3VyYXRlIHJlcHJlc2VudGF0aW9uLlxuXHRcdHNtb290aEZhY3RvcjogMS4wLFxuXG5cdFx0Ly8gQG9wdGlvbiBub0NsaXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIERpc2FibGUgcG9seWxpbmUgY2xpcHBpbmcuXG5cdFx0bm9DbGlwOiBmYWxzZVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmdzKCk6IExhdExuZ1tdXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBvaW50cyBpbiB0aGUgcGF0aCwgb3IgbmVzdGVkIGFycmF5cyBvZiBwb2ludHMgaW4gY2FzZSBvZiBtdWx0aS1wb2x5bGluZS5cblx0Z2V0TGF0TG5nczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmdzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5ncyhsYXRsbmdzOiBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gUmVwbGFjZXMgYWxsIHRoZSBwb2ludHMgaW4gdGhlIHBvbHlsaW5lIHdpdGggdGhlIGdpdmVuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMuXG5cdHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzRW1wdHkoKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgUG9seWxpbmUgaGFzIG5vIExhdExuZ3MuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VzdExheWVyUG9pbnQocDogUG9pbnQpOiBQb2ludFxuXHQvLyBSZXR1cm5zIHRoZSBwb2ludCBjbG9zZXN0IHRvIGBwYCBvbiB0aGUgUG9seWxpbmUuXG5cdGNsb3Nlc3RMYXllclBvaW50OiBmdW5jdGlvbiAocCkge1xuXHRcdHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5LFxuXHRcdCAgICBtaW5Qb2ludCA9IG51bGwsXG5cdFx0ICAgIGNsb3Nlc3QgPSBMaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQsXG5cdFx0ICAgIHAxLCBwMjtcblxuXHRcdGZvciAodmFyIGogPSAwLCBqTGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG5cdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5fcGFydHNbal07XG5cblx0XHRcdGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cDEgPSBwb2ludHNbaSAtIDFdO1xuXHRcdFx0XHRwMiA9IHBvaW50c1tpXTtcblxuXHRcdFx0XHR2YXIgc3FEaXN0ID0gY2xvc2VzdChwLCBwMSwgcDIsIHRydWUpO1xuXG5cdFx0XHRcdGlmIChzcURpc3QgPCBtaW5EaXN0YW5jZSkge1xuXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gc3FEaXN0O1xuXHRcdFx0XHRcdG1pblBvaW50ID0gY2xvc2VzdChwLCBwMSwgcDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtaW5Qb2ludCkge1xuXHRcdFx0bWluUG9pbnQuZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWluUG9pbnQ7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBvbHlsaW5lLlxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGksIGhhbGZEaXN0LCBzZWdEaXN0LCBkaXN0LCBwMSwgcDIsIHJhdGlvLFxuXHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcblx0XHQgICAgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cblx0XHQvLyBwb2x5bGluZSBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGZvciAoaSA9IDAsIGhhbGZEaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0aGFsZkRpc3QgKz0gcG9pbnRzW2ldLmRpc3RhbmNlVG8ocG9pbnRzW2kgKyAxXSkgLyAyO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBsaW5lIGlzIHNvIHNtYWxsIGluIHRoZSBjdXJyZW50IHZpZXcgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiB0aGUgc2FtZSBwaXhlbC5cblx0XHRpZiAoaGFsZkRpc3QgPT09IDApIHtcblx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50c1swXSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgZGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcblx0XHRcdHAxID0gcG9pbnRzW2ldO1xuXHRcdFx0cDIgPSBwb2ludHNbaSArIDFdO1xuXHRcdFx0c2VnRGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdFx0ZGlzdCArPSBzZWdEaXN0O1xuXG5cdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XG5cdFx0XHRcdHJhdGlvID0gKGRpc3QgLSBoYWxmRGlzdCkgLyBzZWdEaXN0O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhbXG5cdFx0XHRcdFx0cDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSxcblx0XHRcdFx0XHRwMi55IC0gcmF0aW8gKiAocDIueSAtIHAxLnkpXG5cdFx0XHRcdF0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRMYXRMbmcobGF0bG5nOiBMYXRMbmcsIGxhdGxuZ3M/IExhdExuZ1tdKTogdGhpc1xuXHQvLyBBZGRzIGEgZ2l2ZW4gcG9pbnQgdG8gdGhlIHBvbHlsaW5lLiBCeSBkZWZhdWx0LCBhZGRzIHRvIHRoZSBmaXJzdCByaW5nIG9mXG5cdC8vIHRoZSBwb2x5bGluZSBpbiBjYXNlIG9mIGEgbXVsdGktcG9seWxpbmUsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nXG5cdC8vIGEgc3BlY2lmaWMgcmluZyBhcyBhIExhdExuZyBhcnJheSAodGhhdCB5b3UgY2FuIGVhcmxpZXIgYWNjZXNzIHdpdGggW2BnZXRMYXRMbmdzYF0oI3BvbHlsaW5lLWdldGxhdGxuZ3MpKS5cblx0YWRkTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nLCBsYXRsbmdzKSB7XG5cdFx0bGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5fZGVmYXVsdFNoYXBlKCk7XG5cdFx0bGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcblx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xuXHRcdHRoaXMuX2xhdGxuZ3MgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIExpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKSA/IHRoaXMuX2xhdGxuZ3MgOiB0aGlzLl9sYXRsbmdzWzBdO1xuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IGNvbnZlcnQgbGF0bG5ncyBpbnB1dCBpbnRvIGFjdHVhbCBMYXRMbmcgaW5zdGFuY2VzOyBjYWxjdWxhdGUgYm91bmRzIGFsb25nIHRoZSB3YXlcblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHQgICAgZmxhdCA9IExpbmVVdGlsLmlzRmxhdChsYXRsbmdzKTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoZmxhdCkge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcblx0XHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChyZXN1bHRbaV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5nc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcblx0XHR0aGlzLl9yaW5ncyA9IFtdO1xuXHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKHRoaXMuX2xhdGxuZ3MsIHRoaXMuX3JpbmdzLCBweEJvdW5kcyk7XG5cblx0XHRpZiAodGhpcy5fYm91bmRzLmlzVmFsaWQoKSAmJiBweEJvdW5kcy5pc1ZhbGlkKCkpIHtcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzID0gcHhCb3VuZHM7XG5cdFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHMoW1xuXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWluLnN1YnRyYWN0KHApLFxuXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWF4LmFkZChwKVxuXHRcdF0pO1xuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IHR1cm5zIGxhdGxuZ3MgaW50byBhIHNldCBvZiByaW5ncyB3aXRoIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRfcHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcykge1xuXHRcdHZhciBmbGF0ID0gbGF0bG5nc1swXSBpbnN0YW5jZW9mIExhdExuZyxcblx0XHQgICAgbGVuID0gbGF0bG5ncy5sZW5ndGgsXG5cdFx0ICAgIGksIHJpbmc7XG5cblx0XHRpZiAoZmxhdCkge1xuXHRcdFx0cmluZyA9IFtdO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJpbmdbaV0gPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHRwcm9qZWN0ZWRCb3VuZHMuZXh0ZW5kKHJpbmdbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnB1c2gocmluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyhsYXRsbmdzW2ldLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGNsaXAgcG9seWxpbmUgYnkgcmVuZGVyZXIgYm91bmRzIHNvIHRoYXQgd2UgaGF2ZSBsZXNzIHRvIHJlbmRlciBmb3IgcGVyZm9ybWFuY2Vcblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcztcblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcblx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIGksIGosIGssIGxlbiwgbGVuMiwgc2VnbWVudCwgcG9pbnRzO1xuXG5cdFx0Zm9yIChpID0gMCwgayA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwb2ludHMgPSB0aGlzLl9yaW5nc1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBMaW5lVXRpbC5jbGlwU2VnbWVudChwb2ludHNbal0sIHBvaW50c1tqICsgMV0sIGJvdW5kcywgaiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKCFzZWdtZW50KSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0cGFydHNba10gPSBwYXJ0c1trXSB8fCBbXTtcblx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzBdKTtcblxuXHRcdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XG5cdFx0XHRcdGlmICgoc2VnbWVudFsxXSAhPT0gcG9pbnRzW2ogKyAxXSkgfHwgKGogPT09IGxlbjIgLSAyKSkge1xuXHRcdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFsxXSk7XG5cdFx0XHRcdFx0aysrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIHNpbXBsaWZ5IGVhY2ggY2xpcHBlZCBwYXJ0IG9mIHRoZSBwb2x5bGluZSBmb3IgcGVyZm9ybWFuY2Vcblx0X3NpbXBsaWZ5UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIHRvbGVyYW5jZSA9IHRoaXMub3B0aW9ucy5zbW9vdGhGYWN0b3I7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnRzW2ldID0gTGluZVV0aWwuc2ltcGxpZnkocGFydHNbaV0sIHRvbGVyYW5jZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NsaXBQb2ludHMoKTtcblx0XHR0aGlzLl9zaW1wbGlmeVBvaW50cygpO1xuXHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwLCBjbG9zZWQpIHtcblx0XHR2YXIgaSwgaiwgaywgbGVuLCBsZW4yLCBwYXJ0LFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblxuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gaGl0IGRldGVjdGlvbiBmb3IgcG9seWxpbmVzXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRcdGlmICghY2xvc2VkICYmIChqID09PSAwKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdGlmIChMaW5lVXRpbC5wb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHBhcnRba10sIHBhcnRbal0pIDw9IHcpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLnBvbHlsaW5lKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIHBvbHlsaW5lIG9iamVjdCBnaXZlbiBhbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzIGFuZFxuLy8gb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC4gWW91IGNhbiBjcmVhdGUgYSBgUG9seWxpbmVgIG9iamVjdCB3aXRoXG4vLyBtdWx0aXBsZSBzZXBhcmF0ZSBsaW5lcyAoYE11bHRpUG9seWxpbmVgKSBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGFycmF5c1xuLy8gb2YgZ2VvZ3JhcGhpYyBwb2ludHMuXG5leHBvcnQgZnVuY3Rpb24gcG9seWxpbmUobGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xufVxuXG4vLyBSZXRyb2NvbXBhdC4gQWxsb3cgcGx1Z2lucyB0byBzdXBwb3J0IExlYWZsZXQgdmVyc2lvbnMgYmVmb3JlIGFuZCBhZnRlciAxLjEuXG5Qb2x5bGluZS5fZmxhdCA9IExpbmVVdGlsLl9mbGF0O1xuIiwiaW1wb3J0IHtQb2x5bGluZX0gZnJvbSAnLi9Qb2x5bGluZSc7XG5pbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9MaW5lVXRpbCc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCAqIGFzIFBvbHlVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvbHlVdGlsJztcblxuLypcbiAqIEBjbGFzcyBQb2x5Z29uXG4gKiBAYWthIEwuUG9seWdvblxuICogQGluaGVyaXRzIFBvbHlsaW5lXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5Z29uIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5bGluZWAuXG4gKlxuICogTm90ZSB0aGF0IHBvaW50cyB5b3UgcGFzcyB3aGVuIGNyZWF0aW5nIGEgcG9seWdvbiBzaG91bGRuJ3QgaGF2ZSBhbiBhZGRpdGlvbmFsIGxhc3QgcG9pbnQgZXF1YWwgdG8gdGhlIGZpcnN0IG9uZSDigJQgaXQncyBiZXR0ZXIgdG8gZmlsdGVyIG91dCBzdWNoIHBvaW50cy5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlnb24gZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXTtcbiAqXG4gKiB2YXIgcG9seWdvbiA9IEwucG9seWdvbihsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlnb25cbiAqIG1hcC5maXRCb3VuZHMocG9seWdvbi5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgbGF0bG5ncywgd2l0aCB0aGUgZmlyc3QgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBvdXRlciBzaGFwZSBhbmQgdGhlIG90aGVyIGFycmF5cyByZXByZXNlbnRpbmcgaG9sZXMgaW4gdGhlIG91dGVyIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gKiAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gKiBdO1xuICogYGBgXG4gKlxuICogQWRkaXRpb25hbGx5LCB5b3UgY2FuIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBNdWx0aVBvbHlnb24gc2hhcGUuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbIC8vIGZpcnN0IHBvbHlnb25cbiAqICAgICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAqICAgICBbWzM3LjI5LCAtMTA4LjU4XSxbNDAuNzEsIC0xMDguNThdLFs0MC43MSwgLTEwMi41MF0sWzM3LjI5LCAtMTAyLjUwXV0gLy8gaG9sZVxuICogICBdLFxuICogICBbIC8vIHNlY29uZCBwb2x5Z29uXG4gKiAgICAgW1s0MSwgLTExMS4wM10sWzQ1LCAtMTExLjA0XSxbNDUsIC0xMDQuMDVdLFs0MSwgLTEwNC4wNV1dXG4gKiAgIF1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFBvbHlnb24gPSBQb2x5bGluZS5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlXG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGggfHwgIXRoaXMuX2xhdGxuZ3NbMF0ubGVuZ3RoO1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cblx0XHR2YXIgaSwgaiwgcDEsIHAyLCBmLCBhcmVhLCB4LCB5LCBjZW50ZXIsXG5cdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuIG51bGw7IH1cblxuXHRcdC8vIHBvbHlnb24gY2VudHJvaWQgYWxnb3JpdGhtOyBvbmx5IHVzZXMgdGhlIGZpcnN0IHJpbmcgaWYgdGhlcmUgYXJlIG11bHRpcGxlXG5cblx0XHRhcmVhID0geCA9IHkgPSAwO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcblx0XHRcdHAxID0gcG9pbnRzW2ldO1xuXHRcdFx0cDIgPSBwb2ludHNbal07XG5cblx0XHRcdGYgPSBwMS55ICogcDIueCAtIHAyLnkgKiBwMS54O1xuXHRcdFx0eCArPSAocDEueCArIHAyLngpICogZjtcblx0XHRcdHkgKz0gKHAxLnkgKyBwMi55KSAqIGY7XG5cdFx0XHRhcmVhICs9IGYgKiAzO1xuXHRcdH1cblxuXHRcdGlmIChhcmVhID09PSAwKSB7XG5cdFx0XHQvLyBQb2x5Z29uIGlzIHNvIHNtYWxsIHRoYXQgYWxsIHBvaW50cyBhcmUgb24gc2FtZSBwaXhlbC5cblx0XHRcdGNlbnRlciA9IHBvaW50c1swXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2VudGVyID0gW3ggLyBhcmVhLCB5IC8gYXJlYV07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGNlbnRlcik7XG5cdH0sXG5cblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnZlcnRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyksXG5cdFx0ICAgIGxlbiA9IHJlc3VsdC5sZW5ndGg7XG5cblx0XHQvLyByZW1vdmUgbGFzdCBwb2ludCBpZiBpdCBlcXVhbHMgZmlyc3Qgb25lXG5cdFx0aWYgKGxlbiA+PSAyICYmIHJlc3VsdFswXSBpbnN0YW5jZW9mIExhdExuZyAmJiByZXN1bHRbMF0uZXF1YWxzKHJlc3VsdFtsZW4gLSAxXSkpIHtcblx0XHRcdHJlc3VsdC5wb3AoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHRQb2x5bGluZS5wcm90b3R5cGUuX3NldExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKTtcblx0XHRpZiAoTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpKSB7XG5cdFx0XHR0aGlzLl9sYXRsbmdzID0gW3RoaXMuX2xhdGxuZ3NdO1xuXHRcdH1cblx0fSxcblxuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIExpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKSA/IHRoaXMuX2xhdGxuZ3NbMF0gOiB0aGlzLl9sYXRsbmdzWzBdWzBdO1xuXHR9LFxuXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcG9seWdvbnMgbmVlZCBhIGRpZmZlcmVudCBjbGlwcGluZyBhbGdvcml0aG0gc28gd2UgcmVkZWZpbmUgdGhhdFxuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHMsXG5cdFx0ICAgIHcgPSB0aGlzLm9wdGlvbnMud2VpZ2h0LFxuXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXG5cdFx0Ly8gaW5jcmVhc2UgY2xpcCBwYWRkaW5nIGJ5IHN0cm9rZSB3aWR0aCB0byBhdm9pZCBzdHJva2Ugb24gY2xpcCBlZGdlc1xuXHRcdGJvdW5kcyA9IG5ldyBCb3VuZHMoYm91bmRzLm1pbi5zdWJ0cmFjdChwKSwgYm91bmRzLm1heC5hZGQocCkpO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoLCBjbGlwcGVkOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGNsaXBwZWQgPSBQb2x5VXRpbC5jbGlwUG9seWdvbih0aGlzLl9yaW5nc1tpXSwgYm91bmRzLCB0cnVlKTtcblx0XHRcdGlmIChjbGlwcGVkLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl9wYXJ0cy5wdXNoKGNsaXBwZWQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMsIHRydWUpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIGluc2lkZSA9IGZhbHNlLFxuXHRcdCAgICBwYXJ0LCBwMSwgcDIsIGksIGosIGssIGxlbiwgbGVuMjtcblxuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gcmF5IGNhc3RpbmcgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgaWYgcG9pbnQgaXMgaW4gcG9seWdvblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0XHRwMSA9IHBhcnRbal07XG5cdFx0XHRcdHAyID0gcGFydFtrXTtcblxuXHRcdFx0XHRpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuXHRcdFx0XHRcdGluc2lkZSA9ICFpbnNpZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBhbHNvIGNoZWNrIGlmIGl0J3Mgb24gcG9seWdvbiBzdHJva2Vcblx0XHRyZXR1cm4gaW5zaWRlIHx8IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludC5jYWxsKHRoaXMsIHAsIHRydWUpO1xuXHR9XG5cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwucG9seWdvbihsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbihsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7TGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcclxuaW1wb3J0IHtGZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge01hcmtlcn0gZnJvbSAnLi9tYXJrZXIvTWFya2VyJztcclxuaW1wb3J0IHtDaXJjbGV9IGZyb20gJy4vdmVjdG9yL0NpcmNsZSc7XHJcbmltcG9ydCB7Q2lyY2xlTWFya2VyfSBmcm9tICcuL3ZlY3Rvci9DaXJjbGVNYXJrZXInO1xyXG5pbXBvcnQge1BvbHlsaW5lfSBmcm9tICcuL3ZlY3Rvci9Qb2x5bGluZSc7XHJcbmltcG9ydCB7UG9seWdvbn0gZnJvbSAnLi92ZWN0b3IvUG9seWdvbic7XHJcbmltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi4vZ2VvbWV0cnkvTGluZVV0aWwnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBHZW9KU09OXHJcbiAqIEBha2EgTC5HZW9KU09OXHJcbiAqIEBpbmhlcml0cyBGZWF0dXJlR3JvdXBcclxuICpcclxuICogUmVwcmVzZW50cyBhIEdlb0pTT04gb2JqZWN0IG9yIGFuIGFycmF5IG9mIEdlb0pTT04gb2JqZWN0cy4gQWxsb3dzIHlvdSB0byBwYXJzZVxyXG4gKiBHZW9KU09OIGRhdGEgYW5kIGRpc3BsYXkgaXQgb24gdGhlIG1hcC4gRXh0ZW5kcyBgRmVhdHVyZUdyb3VwYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5nZW9KU09OKGRhdGEsIHtcclxuICogXHRzdHlsZTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICogXHRcdHJldHVybiB7Y29sb3I6IGZlYXR1cmUucHJvcGVydGllcy5jb2xvcn07XHJcbiAqIFx0fVxyXG4gKiB9KS5iaW5kUG9wdXAoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAqIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbjtcclxuICogfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBHZW9KU09OID0gRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBHZW9KU09OIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9pbnRUb0xheWVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgaG93IEdlb0pTT04gcG9pbnRzIHNwYXduIExlYWZsZXQgbGF5ZXJzLiBJdCBpcyBpbnRlcm5hbGx5XHJcblx0ICogY2FsbGVkIHdoZW4gZGF0YSBpcyBhZGRlZCwgcGFzc2luZyB0aGUgR2VvSlNPTiBwb2ludCBmZWF0dXJlIGFuZCBpdHMgYExhdExuZ2AuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gc3Bhd24gYSBkZWZhdWx0IGBNYXJrZXJgOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24oZ2VvSnNvblBvaW50LCBsYXRsbmcpIHtcclxuXHQgKiBcdHJldHVybiBMLm1hcmtlcihsYXRsbmcpO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc3R5bGU6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyB0aGUgYFBhdGggb3B0aW9uc2AgZm9yIHN0eWxpbmcgR2VvSlNPTiBsaW5lcyBhbmQgcG9seWdvbnMsXHJcblx0ICogY2FsbGVkIGludGVybmFsbHkgd2hlbiBkYXRhIGlzIGFkZGVkLlxyXG5cdCAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRvIG5vdCBvdmVycmlkZSBhbnkgZGVmYXVsdHM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuXHQgKiBcdHJldHVybiB7fVxyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gb25FYWNoRmVhdHVyZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBjcmVhdGVkIGBGZWF0dXJlYCwgYWZ0ZXIgaXQgaGFzXHJcblx0ICogYmVlbiBjcmVhdGVkIGFuZCBzdHlsZWQuIFVzZWZ1bCBmb3IgYXR0YWNoaW5nIGV2ZW50cyBhbmQgcG9wdXBzIHRvIGZlYXR1cmVzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGRvIG5vdGhpbmcgd2l0aCB0aGUgbmV3bHkgY3JlYXRlZCBsYXllcnM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZmVhdHVyZSwgbGF5ZXIpIHt9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGZpbHRlcjogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGluY2x1ZGUgYSBmZWF0dXJlIG9yIG5vdC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBpbmNsdWRlIGFsbCBmZWF0dXJlczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHRydWU7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqIE5vdGU6IGR5bmFtaWNhbGx5IGNoYW5naW5nIHRoZSBgZmlsdGVyYCBvcHRpb24gd2lsbCBoYXZlIGVmZmVjdCBvbmx5IG9uIG5ld2x5XHJcblx0ICogYWRkZWQgZGF0YS4gSXQgd2lsbCBfbm90XyByZS1ldmFsdWF0ZSBhbHJlYWR5IGluY2x1ZGVkIGZlYXR1cmVzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjb29yZHNUb0xhdExuZzogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBjb252ZXJ0aW5nIEdlb0pTT04gY29vcmRpbmF0ZXMgdG8gYExhdExuZ2BzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRoZSBgY29vcmRzVG9MYXRMbmdgIHN0YXRpYyBtZXRob2QuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIG1hcmtlcnNJbmhlcml0T3B0aW9uczogQm9vbGVhbiA9IGZhbHNlXHJcblx0ICogV2hldGhlciBkZWZhdWx0IE1hcmtlcnMgZm9yIFwiUG9pbnRcIiB0eXBlIEZlYXR1cmVzIGluaGVyaXQgZnJvbSBncm91cCBvcHRpb25zLlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdGlmIChnZW9qc29uKSB7XHJcblx0XHRcdHRoaXMuYWRkRGF0YShnZW9qc29uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZERhdGEoIDxHZW9KU09OPiBkYXRhICk6IHRoaXNcclxuXHQvLyBBZGRzIGEgR2VvSlNPTiBvYmplY3QgdG8gdGhlIGxheWVyLlxyXG5cdGFkZERhdGE6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcblx0XHR2YXIgZmVhdHVyZXMgPSBVdGlsLmlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuXHRcdCAgICBpLCBsZW4sIGZlYXR1cmU7XHJcblxyXG5cdFx0aWYgKGZlYXR1cmVzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Ly8gb25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXHJcblx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG5cdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkRGF0YShmZWF0dXJlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKTtcclxuXHRcdGlmICghbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRsYXllci5mZWF0dXJlID0gYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuXHRcdGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG5cdFx0XHRvcHRpb25zLm9uRWFjaEZlYXR1cmUoZ2VvanNvbiwgbGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlc2V0U3R5bGUoIDxQYXRoPiBsYXllcj8gKTogdGhpc1xyXG5cdC8vIFJlc2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIGxheWVyJ3Mgc3R5bGUgdG8gdGhlIG9yaWdpbmFsIEdlb0pTT04gc3R5bGUsIHVzZWZ1bCBmb3IgcmVzZXR0aW5nIHN0eWxlIGFmdGVyIGhvdmVyIGV2ZW50cy5cclxuXHQvLyBJZiBgbGF5ZXJgIGlzIG9taXR0ZWQsIHRoZSBzdHlsZSBvZiBhbGwgZmVhdHVyZXMgaW4gdGhlIGN1cnJlbnQgbGF5ZXIgaXMgcmVzZXQuXHJcblx0cmVzZXRTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZXNldFN0eWxlLCB0aGlzKTtcclxuXHRcdH1cclxuXHRcdC8vIHJlc2V0IGFueSBjdXN0b20gc3R5bGVzXHJcblx0XHRsYXllci5vcHRpb25zID0gVXRpbC5leHRlbmQoe30sIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcclxuXHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHRoaXMub3B0aW9ucy5zdHlsZSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKCA8RnVuY3Rpb24+IHN0eWxlICk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHN0eWxlcyBvZiBHZW9KU09OIHZlY3RvciBsYXllcnMgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUgZnVuY3Rpb24uXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfc2V0TGF5ZXJTdHlsZTogZnVuY3Rpb24gKGxheWVyLCBzdHlsZSkge1xyXG5cdFx0aWYgKGxheWVyLnNldFN0eWxlKSB7XHJcblx0XHRcdGlmICh0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRzdHlsZSA9IHN0eWxlKGxheWVyLmZlYXR1cmUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxheWVyLnNldFN0eWxlKHN0eWxlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkdlb0pTT046XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGZlYXR1cmVEYXRhOiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpOiBMYXllclxyXG4vLyBDcmVhdGVzIGEgYExheWVyYCBmcm9tIGEgZ2l2ZW4gR2VvSlNPTiBmZWF0dXJlLiBDYW4gdXNlIGEgY3VzdG9tXHJcbi8vIFtgcG9pbnRUb0xheWVyYF0oI2dlb2pzb24tcG9pbnR0b2xheWVyKSBhbmQvb3IgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG4vLyBmdW5jdGlvbnMgaWYgcHJvdmlkZWQgYXMgb3B0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb24sXHJcblx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBudWxsLFxyXG5cdCAgICBsYXllcnMgPSBbXSxcclxuXHQgICAgcG9pbnRUb0xheWVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnBvaW50VG9MYXllcixcclxuXHQgICAgX2Nvb3Jkc1RvTGF0TG5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nLFxyXG5cdCAgICBsYXRsbmcsIGxhdGxuZ3MsIGksIGxlbjtcclxuXHJcblx0aWYgKCFjb29yZHMgJiYgIWdlb21ldHJ5KSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xyXG5cdGNhc2UgJ1BvaW50JzpcclxuXHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG5cdFx0cmV0dXJuIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdNdWx0aVBvaW50JzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdFx0bGF5ZXJzLnB1c2goX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0Y2FzZSAnTGluZVN0cmluZyc6XHJcblx0Y2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcclxuXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgPyAwIDogMSwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ1BvbHlnb24nOlxyXG5cdGNhc2UgJ011bHRpUG9seWdvbic6XHJcblx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nID8gMSA6IDIsIF9jb29yZHNUb0xhdExuZyk7XHJcblx0XHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcih7XHJcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcblx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRcdHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllc1xyXG5cdFx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRcdGlmIChsYXllcikge1xyXG5cdFx0XHRcdGxheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0ZGVmYXVsdDpcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyRm4sIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBwb2ludFRvTGF5ZXJGbiA/XHJcblx0XHRwb2ludFRvTGF5ZXJGbihnZW9qc29uLCBsYXRsbmcpIDpcclxuXHRcdG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zICYmIG9wdGlvbnMubWFya2Vyc0luaGVyaXRPcHRpb25zICYmIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGEgYExhdExuZ2Agb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgMiBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlKVxyXG4vLyBvciAzIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlKSB1c2VkIGluIEdlb0pTT04gZm9yIHBvaW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3Jkcykge1xyXG5cdHJldHVybiBuZXcgTGF0TG5nKGNvb3Jkc1sxXSwgY29vcmRzWzBdLCBjb29yZHNbMl0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNvb3Jkc1RvTGF0TG5nPzogRnVuY3Rpb24pOiBBcnJheVxyXG4vLyBDcmVhdGVzIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBvZiBgTGF0TG5nYHMgZnJvbSBhIEdlb0pTT04gY29vcmRpbmF0ZXMgYXJyYXkuXHJcbi8vIGBsZXZlbHNEZWVwYCBzcGVjaWZpZXMgdGhlIG5lc3RpbmcgbGV2ZWwgKDAgaXMgZm9yIGFuIGFycmF5IG9mIHBvaW50cywgMSBmb3IgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBvaW50cywgZXRjLiwgMCBieSBkZWZhdWx0KS5cclxuLy8gQ2FuIHVzZSBhIGN1c3RvbSBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpIGZ1bmN0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgbGV2ZWxzRGVlcCwgX2Nvb3Jkc1RvTGF0TG5nKSB7XHJcblx0dmFyIGxhdGxuZ3MgPSBbXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGgsIGxhdGxuZzsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRsYXRsbmcgPSBsZXZlbHNEZWVwID9cclxuXHRcdFx0Y29vcmRzVG9MYXRMbmdzKGNvb3Jkc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIF9jb29yZHNUb0xhdExuZykgOlxyXG5cdFx0XHQoX2Nvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nKShjb29yZHNbaV0pO1xyXG5cclxuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGxhdGxuZ3M7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmc6IExhdExuZywgcHJlY2lzaW9uPzogTnVtYmVyKTogQXJyYXlcclxuLy8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmcsIHByZWNpc2lvbikge1xyXG5cdHByZWNpc2lvbiA9IHR5cGVvZiBwcmVjaXNpb24gPT09ICdudW1iZXInID8gcHJlY2lzaW9uIDogNjtcclxuXHRyZXR1cm4gbGF0bG5nLmFsdCAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFtVdGlsLmZvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcuYWx0LCBwcmVjaXNpb24pXSA6XHJcblx0XHRbVXRpbC5mb3JtYXROdW0obGF0bG5nLmxuZywgcHJlY2lzaW9uKSwgVXRpbC5mb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKV07XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5nczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNsb3NlZD86IEJvb2xlYW4pOiBBcnJheVxyXG4vLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdzYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmdzKVxyXG4vLyBgY2xvc2VkYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZpcnN0IHBvaW50IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSB0byBjbG9zZSB0aGUgZmVhdHVyZSwgb25seSB1c2VkIHdoZW4gYGxldmVsc0RlZXBgIGlzIDAuIEZhbHNlIGJ5IGRlZmF1bHQuXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5ncywgbGV2ZWxzRGVlcCwgY2xvc2VkLCBwcmVjaXNpb24pIHtcclxuXHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRjb29yZHMucHVzaChsZXZlbHNEZWVwID9cclxuXHRcdFx0bGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3NbaV0sIGxldmVsc0RlZXAgLSAxLCBjbG9zZWQsIHByZWNpc2lvbikgOlxyXG5cdFx0XHRsYXRMbmdUb0Nvb3JkcyhsYXRsbmdzW2ldLCBwcmVjaXNpb24pKTtcclxuXHR9XHJcblxyXG5cdGlmICghbGV2ZWxzRGVlcCAmJiBjbG9zZWQpIHtcclxuXHRcdGNvb3Jkcy5wdXNoKGNvb3Jkc1swXSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29vcmRzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmVhdHVyZShsYXllciwgbmV3R2VvbWV0cnkpIHtcclxuXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/XHJcblx0XHRVdGlsLmV4dGVuZCh7fSwgbGF5ZXIuZmVhdHVyZSwge2dlb21ldHJ5OiBuZXdHZW9tZXRyeX0pIDpcclxuXHRcdGFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbjogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE5vcm1hbGl6ZSBHZW9KU09OIGdlb21ldHJpZXMvZmVhdHVyZXMgaW50byBHZW9KU09OIGZlYXR1cmVzLlxyXG5leHBvcnQgZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb24pIHtcclxuXHRpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgfHwgZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcblx0XHRyZXR1cm4gZ2VvanNvbjtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRwcm9wZXJ0aWVzOiB7fSxcclxuXHRcdGdlb21ldHJ5OiBnZW9qc29uXHJcblx0fTtcclxufVxyXG5cclxudmFyIFBvaW50VG9HZW9KU09OID0ge1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogbGF0TG5nVG9Db29yZHModGhpcy5nZXRMYXRMbmcoKSwgcHJlY2lzaW9uKVxyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXJrZXJcclxuLy8gQHNlY3Rpb24gT3RoZXIgbWV0aG9kc1xyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXIpOiBPYmplY3RcclxuLy8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcbi8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDaXJjbGVNYXJrZXJcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcbi8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG4vLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2IHBsYWNlcy5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG5DaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbkNpcmNsZU1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlsaW5lXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4vLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5bGluZSAoYXMgYSBHZW9KU09OIGBMaW5lU3RyaW5nYCBvciBgTXVsdGlMaW5lU3RyaW5nYCBGZWF0dXJlKS5cclxuUG9seWxpbmUuaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgbXVsdGkgPSAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpO1xyXG5cclxuXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAxIDogMCwgZmFsc2UsIHByZWNpc2lvbik7XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ0xpbmVTdHJpbmcnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5Z29uXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4vLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5Z29uIChhcyBhIEdlb0pTT04gYFBvbHlnb25gIG9yIGBNdWx0aVBvbHlnb25gIEZlYXR1cmUpLlxyXG5Qb2x5Z29uLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIGhvbGVzID0gIUxpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKSxcclxuXHRcdCAgICBtdWx0aSA9IGhvbGVzICYmICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5nc1swXSk7XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDIgOiBob2xlcyA/IDEgOiAwLCB0cnVlLCBwcmVjaXNpb24pO1xyXG5cclxuXHRcdGlmICghaG9sZXMpIHtcclxuXHRcdFx0Y29vcmRzID0gW2Nvb3Jkc107XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ1BvbHlnb24nLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTGF5ZXJHcm91cFxyXG5MYXllckdyb3VwLmluY2x1ZGUoe1xyXG5cdHRvTXVsdGlQb2ludDogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRjb29yZHMucHVzaChsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdNdWx0aVBvaW50JyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcblx0Ly8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcblx0Ly8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcblx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyIGdyb3VwIChhcyBhIEdlb0pTT04gYEZlYXR1cmVDb2xsZWN0aW9uYCwgYEdlb21ldHJ5Q29sbGVjdGlvbmAsIG9yIGBNdWx0aVBvaW50YCkuXHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblxyXG5cdFx0dmFyIHR5cGUgPSB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5ICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KHByZWNpc2lvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicsXHJcblx0XHQgICAganNvbnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0aWYgKGxheWVyLnRvR2VvSlNPTikge1xyXG5cdFx0XHRcdHZhciBqc29uID0gbGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbik7XHJcblx0XHRcdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdFx0XHRqc29ucy5wdXNoKGpzb24uZ2VvbWV0cnkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgZmVhdHVyZSA9IGFzRmVhdHVyZShqc29uKTtcclxuXHRcdFx0XHRcdC8vIFNxdWFzaCBuZXN0ZWQgZmVhdHVyZSBjb2xsZWN0aW9uc1xyXG5cdFx0XHRcdFx0aWYgKGZlYXR1cmUudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRqc29ucy5wdXNoLmFwcGx5KGpzb25zLCBmZWF0dXJlLmZlYXR1cmVzKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGpzb25zLnB1c2goZmVhdHVyZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHRcdGdlb21ldHJpZXM6IGpzb25zLFxyXG5cdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcblx0XHRcdGZlYXR1cmVzOiBqc29uc1xyXG5cdFx0fTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBHZW9KU09OXHJcbi8vIEBmYWN0b3J5IEwuZ2VvSlNPTihnZW9qc29uPzogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgR2VvSlNPTiBsYXllci4gT3B0aW9uYWxseSBhY2NlcHRzIGFuIG9iamVjdCBpblxyXG4vLyBbR2VvSlNPTiBmb3JtYXRdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3OTQ2KSB0byBkaXNwbGF5IG9uIHRoZSBtYXBcclxuLy8gKHlvdSBjYW4gYWx0ZXJuYXRpdmVseSBhZGQgaXQgbGF0ZXIgd2l0aCBgYWRkRGF0YWAgbWV0aG9kKSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgR2VvSlNPTihnZW9qc29uLCBvcHRpb25zKTtcclxufVxyXG5cclxuLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxuZXhwb3J0IHZhciBnZW9Kc29uID0gZ2VvSlNPTjtcclxuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBJbWFnZU92ZXJsYXlcclxuICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGltYWdlVXJsID0gJ2h0dHA6Ly93d3cubGliLnV0ZXhhcy5lZHUvbWFwcy9oaXN0b3JpY2FsL25ld2Fya19ual8xOTIyLmpwZycsXHJcbiAqIFx0aW1hZ2VCb3VuZHMgPSBbWzQwLjcxMjIxNiwgLTc0LjIyNjU1XSwgWzQwLjc3Mzk0MSwgLTc0LjEyNTQ0XV07XHJcbiAqIEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsLCBpbWFnZUJvdW5kcykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBJbWFnZU92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgSW1hZ2VPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgaW1hZ2Ugb3ZlcmxheSB3aWxsIGVtaXQgW21vdXNlIGV2ZW50c10oI2ludGVyYWN0aXZlLWxheWVyKSB3aGVuIGNsaWNrZWQgb3IgaG92ZXJlZC5cclxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgaW1hZ2UuXHJcblx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgdGhlIGltYWdlIHdpbGwgaGF2ZSBpdHMgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgaW1hZ2UgcGl4ZWwgZGF0YS5cclxuXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBlcnJvck92ZXJsYXlVcmw6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBVUkwgdG8gdGhlIG92ZXJsYXkgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgb3ZlcmxheSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG5cdFx0ZXJyb3JPdmVybGF5VXJsOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IFt6SW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4KSBvZiB0aGUgb3ZlcmxheSBsYXllci5cclxuXHRcdHpJbmRleDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBpbWFnZS4gRW1wdHkgYnkgZGVmYXVsdC5cclxuXHRcdGNsYXNzTmFtZTogJydcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgTGF0TG5nQm91bmRzLCBPYmplY3QpXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl9pbml0SW1hZ2UoKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5faW1hZ2UsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ltYWdlKTtcclxuXHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2ltYWdlKTtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBvdmVybGF5LlxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGVPcHRzKSB7XHJcblx0XHRpZiAoc3R5bGVPcHRzLm9wYWNpdHkpIHtcclxuXHRcdFx0dGhpcy5zZXRPcGFjaXR5KHN0eWxlT3B0cy5vcGFjaXR5KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBvdmVybGF5cy5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBVUkwgb2YgdGhlIGltYWdlLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCkge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSB1cmw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuXHQvLyBVcGRhdGUgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3Jlc2V0LFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh2YWx1ZTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNpbWFnZW92ZXJsYXktemluZGV4KSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHZhbHVlO1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBHZXQgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxJbWFnZUVsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTEltYWdlRWxlbWVudClcclxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2U7XHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnSU1HJztcclxuXHRcdHZhciBpbWcgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IERvbVV0aWwuY3JlYXRlKCdpbWcnKTtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGltZywgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgRG9tVXRpbC5hZGRDbGFzcyhpbWcsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgRG9tVXRpbC5hZGRDbGFzcyhpbWcsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG5cdFx0aW1nLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHRpbWcub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgaGFzIGxvYWRlZCBpdHMgaW1hZ2VcclxuXHRcdGltZy5vbmxvYWQgPSBVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cdFx0aW1nLm9uZXJyb3IgPSBVdGlsLmJpbmQodGhpcy5fb3ZlcmxheU9uRXJyb3IsIHRoaXMsICdlcnJvcicpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG5cdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcblx0XHRcdHRoaXMuX3VybCA9IGltZy5zcmM7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpbWcuc3JjID0gdGhpcy5fdXJsO1xyXG5cdFx0aW1nLmFsdCA9IHRoaXMub3B0aW9ucy5hbHQ7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZShlLnpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX21hcC5fbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyh0aGlzLl9ib3VuZHMsIGUuem9vbSwgZS5jZW50ZXIpLm1pbjtcclxuXHJcblx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9pbWFnZSwgb2Zmc2V0LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcclxuXHRcdCAgICBib3VuZHMgPSBuZXcgQm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoRWFzdCgpKSksXHJcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XHJcblxyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihpbWFnZSwgYm91bmRzLm1pbik7XHJcblxyXG5cdFx0aW1hZ2Uuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdGltYWdlLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pbWFnZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9pbWFnZSAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vdmVybGF5T25FcnJvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQGV2ZW50IGVycm9yOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGZhaWxzIHRvIGxvYWQgaXRzIGltYWdlXHJcblx0XHR0aGlzLmZpcmUoJ2Vycm9yJyk7XHJcblxyXG5cdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yT3ZlcmxheVVybDtcclxuXHRcdGlmIChlcnJvclVybCAmJiB0aGlzLl91cmwgIT09IGVycm9yVXJsKSB7XHJcblx0XHRcdHRoaXMuX3VybCA9IGVycm9yVXJsO1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSBlcnJvclVybDtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmw6IFN0cmluZywgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBJbWFnZU92ZXJsYXkgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIGltYWdlIGFuZCB0aGVcclxuLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5leHBvcnQgdmFyIGltYWdlT3ZlcmxheSA9IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCBvcHRpb25zKTtcclxufTtcclxuIiwiaW1wb3J0IHtJbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBWaWRlb092ZXJsYXlcclxuICogQGFrYSBMLlZpZGVvT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XHJcbiAqXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHZpZGVvIHBsYXllciBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxyXG4gKlxyXG4gKiBBIHZpZGVvIG92ZXJsYXkgdXNlcyB0aGUgW2A8dmlkZW8+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3ZpZGVvKVxyXG4gKiBIVE1MNSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdmlkZW9VcmwgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9iaXRlcy8wMDE4OC9wYXRyaWNpYV9uYXNhLndlYm0nLFxyXG4gKiBcdHZpZGVvQm91bmRzID0gW1sgMzIsIC0xMzBdLCBbIDEzLCAtMTAwXV07XHJcbiAqIEwudmlkZW9PdmVybGF5KHZpZGVvVXJsLCB2aWRlb0JvdW5kcyApLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgVmlkZW9PdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBWaWRlb092ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gYXV0b3BsYXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgcGxheWluZyBhdXRvbWF0aWNhbGx5IHdoZW4gbG9hZGVkLlxyXG5cdFx0YXV0b3BsYXk6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsb29wOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBsb29wIGJhY2sgdG8gdGhlIGJlZ2lubmluZyB3aGVuIHBsYXllZC5cclxuXHRcdGxvb3A6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZWVwQXNwZWN0UmF0aW86IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIHNhdmUgYXNwZWN0IHJhdGlvIGFmdGVyIHRoZSBwcm9qZWN0aW9uLlxyXG5cdFx0Ly8gUmVsZXZhbnQgZm9yIHN1cHBvcnRlZCBicm93c2Vycy4gQnJvd3NlciBjb21wYXRpYmlsaXR5LSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvb2JqZWN0LWZpdFxyXG5cdFx0a2VlcEFzcGVjdFJhdGlvOiB0cnVlXHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnVklERU8nO1xyXG5cdFx0dmFyIHZpZCA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogRG9tVXRpbC5jcmVhdGUoJ3ZpZGVvJyk7XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh2aWQsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IERvbVV0aWwuYWRkQ2xhc3ModmlkLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IERvbVV0aWwuYWRkQ2xhc3ModmlkLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxyXG5cclxuXHRcdHZpZC5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0dmlkLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlkZW8gaGFzIGZpbmlzaGVkIGxvYWRpbmcgdGhlIGZpcnN0IGZyYW1lXHJcblx0XHR2aWQub25sb2FkZWRkYXRhID0gVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHJcblx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcblx0XHRcdHZhciBzb3VyY2VFbGVtZW50cyA9IHZpZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJyk7XHJcblx0XHRcdHZhciBzb3VyY2VzID0gW107XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc291cmNlRWxlbWVudHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRzb3VyY2VzLnB1c2goc291cmNlRWxlbWVudHNbal0uc3JjKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fdXJsID0gKHNvdXJjZUVsZW1lbnRzLmxlbmd0aCA+IDApID8gc291cmNlcyA6IFt2aWQuc3JjXTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghVXRpbC5pc0FycmF5KHRoaXMuX3VybCkpIHsgdGhpcy5fdXJsID0gW3RoaXMuX3VybF07IH1cclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5rZWVwQXNwZWN0UmF0aW8gJiYgdmlkLnN0eWxlLmhhc093blByb3BlcnR5KCdvYmplY3RGaXQnKSkgeyB2aWQuc3R5bGVbJ29iamVjdEZpdCddID0gJ2ZpbGwnOyB9XHJcblx0XHR2aWQuYXV0b3BsYXkgPSAhIXRoaXMub3B0aW9ucy5hdXRvcGxheTtcclxuXHRcdHZpZC5sb29wID0gISF0aGlzLm9wdGlvbnMubG9vcDtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdXJsLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBzb3VyY2UgPSBEb21VdGlsLmNyZWF0ZSgnc291cmNlJyk7XHJcblx0XHRcdHNvdXJjZS5zcmMgPSB0aGlzLl91cmxbaV07XHJcblx0XHRcdHZpZC5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxWaWRlb0VsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxWaWRlb0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTFZpZGVvRWxlbWVudClcclxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC52aWRlb092ZXJsYXkodmlkZW86IFN0cmluZ3xBcnJheXxIVE1MVmlkZW9FbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFZpZGVvT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgdmlkZW8gKG9yIGFycmF5IG9mIFVSTHMsIG9yIGV2ZW4gYSB2aWRlbyBlbGVtZW50KSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7SW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBTVkdPdmVybGF5XG4gKiBAYWthIEwuU1ZHT3ZlcmxheVxuICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxuICpcbiAqIFVzZWQgdG8gbG9hZCwgZGlzcGxheSBhbmQgcHJvdmlkZSBET00gYWNjZXNzIHRvIGFuIFNWRyBmaWxlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXG4gKlxuICogQW4gU1ZHIG92ZXJsYXkgdXNlcyB0aGUgW2A8c3ZnPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9FbGVtZW50L3N2ZykgZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKTtcbiAqIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgXCIwIDAgMjAwIDIwMFwiKTtcbiAqIHN2Z0VsZW1lbnQuaW5uZXJIVE1MID0gJzxyZWN0IHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjAwXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDpyZWRcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjEyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDojMDAxM2ZmXCIvPic7XG4gKiB2YXIgc3ZnRWxlbWVudEJvdW5kcyA9IFsgWyAzMiwgLTEzMCBdLCBbIDEzLCAtMTAwIF0gXTtcbiAqIEwuc3ZnT3ZlcmxheShzdmdFbGVtZW50LCBzdmdFbGVtZW50Qm91bmRzKS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTVkdPdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWwgPSB0aGlzLl9pbWFnZSA9IHRoaXMuX3VybDtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBEb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBEb21VdGlsLmFkZENsYXNzKGVsLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxuXG5cdFx0ZWwub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcblx0XHRlbC5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcblx0fVxuXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBTVkdFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgU1ZHRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KVxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuc3ZnT3ZlcmxheShzdmc6IFN0cmluZ3xTVkdFbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFNWR092ZXJsYXkgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiBhbiBTVkcgZWxlbWVudCBhbmQgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cbi8vIEEgdmlld0JveCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgb24gdGhlIFNWRyBlbGVtZW50IHRvIHpvb20gaW4gYW5kIG91dCBwcm9wZXJseS5cblxuZXhwb3J0IGZ1bmN0aW9uIHN2Z092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFNWR092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0IHtGZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIERpdk92ZXJsYXlcclxuICogQGluaGVyaXRzIExheWVyXHJcbiAqIEBha2EgTC5EaXZPdmVybGF5XHJcbiAqIEJhc2UgbW9kZWwgZm9yIEwuUG9wdXAgYW5kIEwuVG9vbHRpcC4gSW5oZXJpdCBmcm9tIGl0IGZvciBjdXN0b20gcG9wdXAgbGlrZSBwbHVnaW5zLlxyXG4gKi9cclxuXHJcbi8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG5leHBvcnQgdmFyIERpdk92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgRGl2T3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgNylcclxuXHRcdC8vIFRoZSBvZmZzZXQgb2YgdGhlIHBvcHVwIHBvc2l0aW9uLiBVc2VmdWwgdG8gY29udHJvbCB0aGUgYW5jaG9yXHJcblx0XHQvLyBvZiB0aGUgcG9wdXAgd2hlbiBvcGVuaW5nIGl0IG9uIHNvbWUgb3ZlcmxheXMuXHJcblx0XHRvZmZzZXQ6IFswLCA3XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3BvcHVwUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAncG9wdXBQYW5lJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZVRpbWVvdXQpO1xyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYnJpbmdUb0Zyb250KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKERvbVV0aWwucmVtb3ZlLCB1bmRlZmluZWQsIHRoaXMuX2NvbnRhaW5lciksIDIwMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IG9mIHBvcHVwLlxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgd2hlcmUgdGhlIHBvcHVwIHdpbGwgb3Blbi5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblx0XHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBwb3B1cC5cclxuXHRnZXRDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldENvbnRlbnQoaHRtbENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIHBvcHVwLiBJZiBhIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgc291cmNlIGxheWVyIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIHBvcHVwLlxyXG5cdHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcblx0XHR0aGlzLl9jb250ZW50ID0gY29udGVudDtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG5cdC8vIEFsaWFzIGZvciBbZ2V0Q29udGVudCgpXSgjcG9wdXAtZ2V0Y29udGVudClcclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdXBkYXRlOiBudWxsXHJcblx0Ly8gVXBkYXRlcyB0aGUgcG9wdXAgY29udGVudCwgbGF5b3V0IGFuZCBwb3NpdGlvbi4gVXNlZnVsIGZvciB1cGRhdGluZyB0aGUgcG9wdXAgYWZ0ZXIgc29tZXRoaW5nIGluc2lkZSBjaGFuZ2VkLCBlLmcuIGltYWdlIGxvYWRlZC5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlQ29udGVudCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlTGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XHJcblxyXG5cdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR6b29tOiB0aGlzLl91cGRhdGVQb3NpdGlvbixcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl91cGRhdGVQb3NpdGlvblxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzT3BlbjogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIHdoZW4gdGhlIHBvcHVwIGlzIHZpc2libGUgb24gdGhlIG1hcC5cclxuXHRpc09wZW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhIXRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBwb3B1cCBpbiBmcm9udCBvZiBvdGhlciBwb3B1cHMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgdG8gdGhlIGJhY2sgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9wcmVwYXJlT3BlbjogZnVuY3Rpb24gKHBhcmVudCwgbGF5ZXIsIGxhdGxuZykge1xyXG5cdFx0aWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBMYXllcikpIHtcclxuXHRcdFx0bGF0bG5nID0gbGF5ZXI7XHJcblx0XHRcdGxheWVyID0gcGFyZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkge1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiBwYXJlbnQuX2xheWVycykge1xyXG5cdFx0XHRcdGxheWVyID0gcGFyZW50Ll9sYXllcnNbaWRdO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFsYXRsbmcpIHtcclxuXHRcdFx0aWYgKGxheWVyLmdldENlbnRlcikge1xyXG5cdFx0XHRcdGxhdGxuZyA9IGxheWVyLmdldENlbnRlcigpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGxheWVyLmdldExhdExuZykge1xyXG5cdFx0XHRcdGxhdGxuZyA9IGxheWVyLmdldExhdExuZygpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBzb3VyY2UgbGF5ZXIgTGF0TG5nLicpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2V0IG92ZXJsYXkgc291cmNlIHRvIHRoaXMgbGF5ZXJcclxuXHRcdHRoaXMuX3NvdXJjZSA9IGxheWVyO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSB0aGUgb3ZlcmxheSAoY29udGVudCwgbGF5b3V0LCBlY3QuLi4pXHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiBsYXRsbmc7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm9kZSA9IHRoaXMuX2NvbnRlbnROb2RlO1xyXG5cdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBjb250ZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcblx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmZpcmUoJ2NvbnRlbnR1cGRhdGUnKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2Zmc2V0ID0gb2Zmc2V0LmFkZChwb3MpLmFkZChhbmNob3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBib3R0b20gPSB0aGlzLl9jb250YWluZXJCb3R0b20gPSAtb2Zmc2V0LnksXHJcblx0XHQgICAgbGVmdCA9IHRoaXMuX2NvbnRhaW5lckxlZnQgPSAtTWF0aC5yb3VuZCh0aGlzLl9jb250YWluZXJXaWR0aCAvIDIpICsgb2Zmc2V0Lng7XHJcblxyXG5cdFx0Ly8gYm90dG9tIHBvc2l0aW9uIHRoZSBwb3B1cCBpbiBjYXNlIHRoZSBoZWlnaHQgb2YgdGhlIHBvcHVwIGNoYW5nZXMgKGltYWdlcyBsb2FkaW5nIGV0YylcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gWzAsIDBdO1xyXG5cdH1cclxuXHJcbn0pO1xyXG4iLCJpbXBvcnQge0Rpdk92ZXJsYXl9IGZyb20gJy4vRGl2T3ZlcmxheSc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtQYXRofSBmcm9tICcuL3ZlY3Rvci9QYXRoJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBQb3B1cFxyXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxyXG4gKiBAYWthIEwuUG9wdXBcclxuICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gKiBvcGVuIHBvcHVwcyB3aGlsZSBtYWtpbmcgc3VyZSB0aGF0IG9ubHkgb25lIHBvcHVwIGlzIG9wZW4gYXQgb25lIHRpbWVcclxuICogKHJlY29tbWVuZGVkIGZvciB1c2FiaWxpdHkpLCBvciB1c2UgW01hcC5hZGRMYXllcl0oI21hcC1hZGRsYXllcikgdG8gb3BlbiBhcyBtYW55IGFzIHlvdSB3YW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICpcclxuICogYGBganNcclxuICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gKiBgYGBcclxuICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFBvcHVwYCBtZXRob2QuXHJcbiAqIEhlcmUncyBhIG1vcmUgY29tcGxpY2F0ZWQgd2F5IHRvIG9wZW4gYSBwb3B1cCBvbiBhIG1hcDpcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAqIFx0LnNldExhdExuZyhsYXRsbmcpXHJcbiAqIFx0LnNldENvbnRlbnQoJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gKiBcdC5vcGVuT24obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxuZXhwb3J0IHZhciBQb3B1cCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFBvcHVwIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAzMDBcclxuXHRcdC8vIE1heCB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1heFdpZHRoOiAzMDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5XaWR0aDogTnVtYmVyID0gNTBcclxuXHRcdC8vIE1pbiB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1pbldpZHRoOiA1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEhlaWdodDogTnVtYmVyID0gbnVsbFxyXG5cdFx0Ly8gSWYgc2V0LCBjcmVhdGVzIGEgc2Nyb2xsYWJsZSBjb250YWluZXIgb2YgdGhlIGdpdmVuIGhlaWdodFxyXG5cdFx0Ly8gaW5zaWRlIGEgcG9wdXAgaWYgaXRzIGNvbnRlbnQgZXhjZWVkcyBpdC5cclxuXHRcdG1heEhlaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIGRvIHBhbm5pbmcgYW5pbWF0aW9uXHJcblx0XHQvLyB0byBmaXQgdGhlIG9wZW5lZCBwb3B1cC5cclxuXHRcdGF1dG9QYW46IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1LCA1KVxyXG5cdFx0Ly8gRXF1aXZhbGVudCBvZiBzZXR0aW5nIGJvdGggdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBhdXRvcGFuIHBhZGRpbmcgdG8gdGhlIHNhbWUgdmFsdWUuXHJcblx0XHRhdXRvUGFuUGFkZGluZzogWzUsIDVdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2VlcEluVmlldzogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBTZXQgaXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIHByZXZlbnQgdXNlcnMgZnJvbSBwYW5uaW5nIHRoZSBwb3B1cFxyXG5cdFx0Ly8gb2ZmIG9mIHRoZSBzY3JlZW4gd2hpbGUgaXQgaXMgb3Blbi5cclxuXHRcdGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VCdXR0b246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBDb250cm9scyB0aGUgcHJlc2VuY2Ugb2YgYSBjbG9zZSBidXR0b24gaW4gdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VCdXR0b246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvQ2xvc2U6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuXHRcdGF1dG9DbG9zZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlT25Fc2NhcGVLZXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIEVTQyBrZXkgZm9yIGNsb3Npbmcgb2YgdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VPbkVzY2FwZUtleTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlT25DbGljazogQm9vbGVhbiA9ICpcclxuXHRcdC8vIFNldCBpdCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIHVzZXIgY2xpY2tzXHJcblx0XHQvLyBvbiB0aGUgbWFwLiBEZWZhdWx0cyB0byB0aGUgbWFwJ3MgW2BjbG9zZVBvcHVwT25DbGlja2BdKCNtYXAtY2xvc2Vwb3B1cG9uY2xpY2spIG9wdGlvbi5cclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnXHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIHBvcHVwIHRvIHRoZSBtYXAgYW5kIGNsb3NlcyB0aGUgcHJldmlvdXMgb25lLiBUaGUgc2FtZSBhcyBgbWFwLm9wZW5Qb3B1cChwb3B1cClgLlxyXG5cdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9wZW5Qb3B1cCh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGlzIG9wZW5lZCBpbiB0aGUgbWFwXHJcblx0XHRtYXAuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcblx0XHRcdC8vIEZvciBub24tcGF0aCBsYXllcnMsIHdlIHRvZ2dsZSB0aGUgcG9wdXAgd2hlbiBjbGlja2luZ1xyXG5cdFx0XHQvLyBhZ2FpbiB0aGUgbGF5ZXIsIHNvIHByZXZlbnQgdGhlIG1hcCB0byByZW9wZW4gaXQuXHJcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcblx0XHRcdFx0dGhpcy5fc291cmNlLm9uKCdwcmVjbGljaycsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaW4gdGhlIG1hcCBpcyBjbG9zZWRcclxuXHRcdG1hcC5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWRcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub2ZmKCdwcmVjbGljaycsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAhPT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA6IHRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSB7XHJcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuX2Nsb3NlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG5cdFx0XHRldmVudHMubW92ZWVuZCA9IHRoaXMuX2FkanVzdFBhbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdF9jbG9zZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuY2xvc2VQb3B1cCh0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXBvcHVwJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JyxcclxuXHRcdFx0cHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICtcclxuXHRcdFx0JyBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHJcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50Jywgd3JhcHBlcik7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24od3JhcHBlcik7XHJcblx0XHREb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24odGhpcy5fY29udGVudE5vZGUpO1xyXG5cdFx0RG9tRXZlbnQub24od3JhcHBlciwgJ2NvbnRleHRtZW51JywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHJcblx0XHR0aGlzLl90aXBDb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAtY29udGFpbmVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX3RpcCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcCcsIHRoaXMuX3RpcENvbnRhaW5lcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xyXG5cdFx0XHR2YXIgY2xvc2VCdXR0b24gPSB0aGlzLl9jbG9zZUJ1dHRvbiA9IERvbVV0aWwuY3JlYXRlKCdhJywgcHJlZml4ICsgJy1jbG9zZS1idXR0b24nLCBjb250YWluZXIpO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5ocmVmID0gJyNjbG9zZSc7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmlubmVySFRNTCA9ICcmIzIxNTsnO1xyXG5cclxuXHRcdFx0RG9tRXZlbnQub24oY2xvc2VCdXR0b24sICdjbGljaycsIHRoaXMuX29uQ2xvc2VCdXR0b25DbGljaywgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRlbnROb2RlLFxyXG5cdFx0ICAgIHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gJyc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XHJcblxyXG5cdFx0dmFyIHdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1pbih3aWR0aCwgdGhpcy5vcHRpb25zLm1heFdpZHRoKTtcclxuXHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHRoaXMub3B0aW9ucy5taW5XaWR0aCk7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAod2lkdGggKyAxKSArICdweCc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJyc7XHJcblxyXG5cdFx0c3R5bGUuaGVpZ2h0ID0gJyc7XHJcblxyXG5cdFx0dmFyIGhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXHJcblx0XHQgICAgbWF4SGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1heEhlaWdodCxcclxuXHRcdCAgICBzY3JvbGxlZENsYXNzID0gJ2xlYWZsZXQtcG9wdXAtc2Nyb2xsZWQnO1xyXG5cclxuXHRcdGlmIChtYXhIZWlnaHQgJiYgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XHJcblx0XHRcdHN0eWxlLmhlaWdodCA9IG1heEhlaWdodCArICdweCc7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmF1dG9QYW4pIHsgcmV0dXJuOyB9XHJcblx0XHRpZiAodGhpcy5fbWFwLl9wYW5BbmltKSB7IHRoaXMuX21hcC5fcGFuQW5pbS5zdG9wKCk7IH1cclxuXHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIG1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KERvbVV0aWwuZ2V0U3R5bGUodGhpcy5fY29udGFpbmVyLCAnbWFyZ2luQm90dG9tJyksIDEwKSB8fCAwLFxyXG5cdFx0ICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyBtYXJnaW5Cb3R0b20sXHJcblx0XHQgICAgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJXaWR0aCxcclxuXHRcdCAgICBsYXllclBvcyA9IG5ldyBQb2ludCh0aGlzLl9jb250YWluZXJMZWZ0LCAtY29udGFpbmVySGVpZ2h0IC0gdGhpcy5fY29udGFpbmVyQm90dG9tKTtcclxuXHJcblx0XHRsYXllclBvcy5fYWRkKERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcblx0XHQgICAgcGFkZGluZyA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nVEwgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBzaXplID0gbWFwLmdldFNpemUoKSxcclxuXHRcdCAgICBkeCA9IDAsXHJcblx0XHQgICAgZHkgPSAwO1xyXG5cclxuXHRcdGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0IC0gc2l6ZS55ICsgcGFkZGluZ0JSLnk7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBhdXRvcGFuc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgc3RhcnRzIGF1dG9wYW5uaW5nIHdoZW4gb3BlbmluZyBhIHBvcHVwLlxyXG5cdFx0aWYgKGR4IHx8IGR5KSB7XHJcblx0XHRcdG1hcFxyXG5cdFx0XHQgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXHJcblx0XHRcdCAgICAucGFuQnkoW2R4LCBkeV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbkNsb3NlQnV0dG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9jbG9zZSgpO1xyXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSBwb3B1cCBvbiB0aGUgc291cmNlIGxheWVyP1xyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXHJcbmV4cG9ydCB2YXIgcG9wdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0cmV0dXJuIG5ldyBQb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG59O1xyXG5cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICogQG9wdGlvbiBjbG9zZVBvcHVwT25DbGljazogQm9vbGVhbiA9IHRydWVcclxuICogU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgcG9wdXBzIHRvIGNsb3NlIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcC5cclxuICovXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKHBvcHVwOiBQb3B1cCk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHBvcHVwIHdoaWxlIGNsb3NpbmcgdGhlIHByZXZpb3VzbHkgb3BlbmVkICh0byBtYWtlIHN1cmUgb25seSBvbmUgaXMgb3BlbmVkIGF0IG9uZSB0aW1lIGZvciB1c2FiaWxpdHkpLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENyZWF0ZXMgYSBwb3B1cCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbnMgaXQgaW4gdGhlIGdpdmVuIHBvaW50IG9uIGEgbWFwLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdGlmICghKHBvcHVwIGluc3RhbmNlb2YgUG9wdXApKSB7XHJcblx0XHRcdHBvcHVwID0gbmV3IFBvcHVwKG9wdGlvbnMpLnNldENvbnRlbnQocG9wdXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXRsbmcpIHtcclxuXHRcdFx0cG9wdXAuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIocG9wdXApKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSkge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wb3B1cCA9IHBvcHVwO1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIocG9wdXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBvcGVuZWQgd2l0aCBbb3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgKG9yIHRoZSBnaXZlbiBvbmUpLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG5cdFx0aWYgKCFwb3B1cCB8fCBwb3B1cCA9PT0gdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cG9wdXAgPSB0aGlzLl9wb3B1cDtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHBvcHVwKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIocG9wdXApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICogQHNlY3Rpb24gUG9wdXAgbWV0aG9kcyBleGFtcGxlXHJcbiAqXHJcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICpcclxuICogYGBganNcclxuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICogbGF5ZXIub3BlblBvcHVwKCk7XHJcbiAqIGxheWVyLmNsb3NlUG9wdXAoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFBvcHVwcyB3aWxsIGFsc28gYmUgYXV0b21hdGljYWxseSBvcGVuZWQgd2hlbiB0aGUgbGF5ZXIgaXMgY2xpY2tlZCBvbiBhbmQgY2xvc2VkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIG9yIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG4gKi9cclxuXHJcbi8vIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHNcclxuTGF5ZXIuaW5jbHVkZSh7XHJcblxyXG5cdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQmluZHMgYSBwb3B1cCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcclxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxyXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxyXG5cdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIFBvcHVwKSB7XHJcblx0XHRcdFV0aWwuc2V0T3B0aW9ucyhjb250ZW50LCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBjb250ZW50O1xyXG5cdFx0XHRjb250ZW50Ll9zb3VyY2UgPSB0aGlzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCBvcHRpb25zKSB7XHJcblx0XHRcdFx0dGhpcy5fcG9wdXAgPSBuZXcgUG9wdXAob3B0aW9ucywgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuYmluZFBvcHVwKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBwb3B1cCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRQb3B1cGAuXHJcblx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHBvcHVwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgcG9wdXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fbWFwKSB7XHJcblx0XHRcdGxhdGxuZyA9IHRoaXMuX3BvcHVwLl9wcmVwYXJlT3Blbih0aGlzLCBsYXllciwgbGF0bG5nKTtcclxuXHJcblx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Qb3B1cCh0aGlzLl9wb3B1cCwgbGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAoKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5fY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9nZ2xlUG9wdXAoKTogdGhpc1xyXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcblx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRpZiAodGhpcy5fcG9wdXAuX21hcCkge1xyXG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMub3BlblBvcHVwKHRhcmdldCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNQb3B1cE9wZW4oKTogYm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxyXG5cdGlzUG9wdXBPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gKHRoaXMuX3BvcHVwID8gdGhpcy5fcG9wdXAuaXNPcGVuKCkgOiBmYWxzZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQb3B1cENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFBvcHVwKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcblx0c2V0UG9wdXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBvcHVwKCk6IFBvcHVwXHJcblx0Ly8gUmV0dXJucyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BvcHVwO1xyXG5cdH0sXHJcblxyXG5cdF9vcGVuUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xyXG5cclxuXHRcdGlmICghdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xyXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcclxuXHJcblx0XHQvLyBpZiB0aGlzIGluaGVyaXRzIGZyb20gUGF0aCBpdHMgYSB2ZWN0b3IgYW5kIHdlIGNhbiBqdXN0XHJcblx0XHQvLyBvcGVuIHRoZSBwb3B1cCBhdCB0aGUgbmV3IGxvY2F0aW9uXHJcblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBQYXRoKSB7XHJcblx0XHRcdHRoaXMub3BlblBvcHVwKGUubGF5ZXIgfHwgZS50YXJnZXQsIGUubGF0bG5nKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG90aGVyd2lzZSB0cmVhdCBpdCBsaWtlIGEgbWFya2VyIGFuZCBmaWd1cmUgb3V0XHJcblx0XHQvLyBpZiB3ZSBzaG91bGQgdG9nZ2xlIGl0IG9wZW4vY2xvc2VkXHJcblx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHRoaXMuX3BvcHVwKSAmJiB0aGlzLl9wb3B1cC5fc291cmNlID09PSBsYXllcikge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub3BlblBvcHVwKGxheWVyLCBlLmxhdGxuZyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X21vdmVQb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhlLmxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0X29uS2V5UHJlc3M6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDEzKSB7XHJcblx0XHRcdHRoaXMuX29wZW5Qb3B1cChlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG4iLCJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBjbGFzcyBUb29sdGlwXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxuICogQGFrYSBMLlRvb2x0aXBcbiAqIFVzZWQgdG8gZGlzcGxheSBzbWFsbCB0ZXh0cyBvbiB0b3Agb2YgbWFwIGxheWVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuYmluZFRvb2x0aXAoXCJteSB0b29sdGlwIHRleHRcIikub3BlblRvb2x0aXAoKTtcbiAqIGBgYFxuICogTm90ZSBhYm91dCB0b29sdGlwIG9mZnNldC4gTGVhZmxldCB0YWtlcyB0d28gb3B0aW9ucyBpbiBjb25zaWRlcmF0aW9uXG4gKiBmb3IgY29tcHV0aW5nIHRvb2x0aXAgb2Zmc2V0dGluZzpcbiAqIC0gdGhlIGBvZmZzZXRgIFRvb2x0aXAgb3B0aW9uOiBpdCBkZWZhdWx0cyB0byBbMCwgMF0sIGFuZCBpdCdzIHNwZWNpZmljIHRvIG9uZSB0b29sdGlwLlxuICogICBBZGQgYSBwb3NpdGl2ZSB4IG9mZnNldCB0byBtb3ZlIHRoZSB0b29sdGlwIHRvIHRoZSByaWdodCwgYW5kIGEgcG9zaXRpdmUgeSBvZmZzZXQgdG9cbiAqICAgbW92ZSBpdCB0byB0aGUgYm90dG9tLiBOZWdhdGl2ZXMgd2lsbCBtb3ZlIHRvIHRoZSBsZWZ0IGFuZCB0b3AuXG4gKiAtIHRoZSBgdG9vbHRpcEFuY2hvcmAgSWNvbiBvcHRpb246IHRoaXMgd2lsbCBvbmx5IGJlIGNvbnNpZGVyZWQgZm9yIE1hcmtlci4gWW91XG4gKiAgIHNob3VsZCBhZGFwdCB0aGlzIHZhbHVlIGlmIHlvdSB1c2UgYSBjdXN0b20gaWNvbi5cbiAqL1xuXG5cbi8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuZXhwb3J0IHZhciBUb29sdGlwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgVG9vbHRpcCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0b29sdGlwUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSB0b29sdGlwIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3Rvb2x0aXBQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDApXG5cdFx0Ly8gT3B0aW9uYWwgb2Zmc2V0IG9mIHRoZSB0b29sdGlwIHBvc2l0aW9uLlxuXHRcdG9mZnNldDogWzAsIDBdLFxuXG5cdFx0Ly8gQG9wdGlvbiBkaXJlY3Rpb246IFN0cmluZyA9ICdhdXRvJ1xuXHRcdC8vIERpcmVjdGlvbiB3aGVyZSB0byBvcGVuIHRoZSB0b29sdGlwLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiBgcmlnaHRgLCBgbGVmdGAsXG5cdFx0Ly8gYHRvcGAsIGBib3R0b21gLCBgY2VudGVyYCwgYGF1dG9gLlxuXHRcdC8vIGBhdXRvYCB3aWxsIGR5bmFtaWNhbGx5IHN3aXRjaCBiZXR3ZWVuIGByaWdodGAgYW5kIGBsZWZ0YCBhY2NvcmRpbmcgdG8gdGhlIHRvb2x0aXBcblx0XHQvLyBwb3NpdGlvbiBvbiB0aGUgbWFwLlxuXHRcdGRpcmVjdGlvbjogJ2F1dG8nLFxuXG5cdFx0Ly8gQG9wdGlvbiBwZXJtYW5lbnQ6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgdG8gb3BlbiB0aGUgdG9vbHRpcCBwZXJtYW5lbnRseSBvciBvbmx5IG9uIG1vdXNlb3Zlci5cblx0XHRwZXJtYW5lbnQ6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBzdGlja3k6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgZm9sbG93IHRoZSBtb3VzZSBpbnN0ZWFkIG9mIGJlaW5nIGZpeGVkIGF0IHRoZSBmZWF0dXJlIGNlbnRlci5cblx0XHRzdGlja3k6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBsaXN0ZW4gdG8gdGhlIGZlYXR1cmUgZXZlbnRzLlxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMC45XG5cdFx0Ly8gVG9vbHRpcCBjb250YWluZXIgb3BhY2l0eS5cblx0XHRvcGFjaXR5OiAwLjlcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcblx0XHR0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaXMgb3BlbmVkIGluIHRoZSBtYXAuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpbiB0aGUgbWFwIGlzIGNsb3NlZC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblxuXHRcdGlmIChCcm93c2VyLnRvdWNoICYmICF0aGlzLm9wdGlvbnMucGVybWFuZW50KSB7XG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLl9jbG9zZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9jbG9zZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX21hcC5jbG9zZVRvb2x0aXAodGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXRvb2x0aXAnLFxuXHRcdCAgICBjbGFzc05hbWUgPSBwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgKyAnIGxlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xuXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKTtcblx0fSxcblxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfc2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3MpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIGNlbnRlclBvaW50ID0gbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobWFwLmdldENlbnRlcigpKSxcblx0XHQgICAgdG9vbHRpcFBvaW50ID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvcyksXG5cdFx0ICAgIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24sXG5cdFx0ICAgIHRvb2x0aXBXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcblx0XHQgICAgdG9vbHRpcEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG5cdFx0ICAgIG9mZnNldCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xuXG5cdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdHBvcyA9IHBvcy5hZGQodG9Qb2ludCgtdG9vbHRpcFdpZHRoIC8gMiArIG9mZnNldC54LCAtdG9vbHRpcEhlaWdodCArIG9mZnNldC55ICsgYW5jaG9yLnksIHRydWUpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHRvb2x0aXBXaWR0aCAvIDIgLSBvZmZzZXQueCwgLW9mZnNldC55LCB0cnVlKSk7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludCh0b29sdGlwV2lkdGggLyAyICsgb2Zmc2V0LngsIHRvb2x0aXBIZWlnaHQgLyAyIC0gYW5jaG9yLnkgKyBvZmZzZXQueSwgdHJ1ZSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnIHx8IGRpcmVjdGlvbiA9PT0gJ2F1dG8nICYmIHRvb2x0aXBQb2ludC54IDwgY2VudGVyUG9pbnQueCkge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ3JpZ2h0Jztcblx0XHRcdHBvcyA9IHBvcy5hZGQodG9Qb2ludChvZmZzZXQueCArIGFuY2hvci54LCBhbmNob3IueSAtIHRvb2x0aXBIZWlnaHQgLyAyICsgb2Zmc2V0LnksIHRydWUpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ2xlZnQnO1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQodG9vbHRpcFdpZHRoICsgYW5jaG9yLnggLSBvZmZzZXQueCwgdG9vbHRpcEhlaWdodCAvIDIgLSBhbmNob3IueSAtIG9mZnNldC55LCB0cnVlKSk7XG5cdFx0fVxuXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtcmlnaHQnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1sZWZ0Jyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtdG9wJyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtYm90dG9tJyk7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtJyArIGRpcmVjdGlvbik7XG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIHBvcyk7XG5cdH0sXG5cblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgb3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSB0b29sdGlwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvciAmJiAhdGhpcy5vcHRpb25zLnN0aWNreSA/IHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvcigpIDogWzAsIDBdKTtcblx0fVxuXG59KTtcblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4vLyBAZmFjdG9yeSBMLnRvb2x0aXAob3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXG4vLyBJbnN0YW50aWF0ZXMgYSBUb29sdGlwIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHRvb2x0aXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxuZXhwb3J0IHZhciB0b29sdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuXHRyZXR1cm4gbmV3IFRvb2x0aXAob3B0aW9ucywgc291cmNlKTtcbn07XG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG5NYXAuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHRvb2x0aXAuXG5cdC8vIEBhbHRlcm5hdGl2ZVxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENyZWF0ZXMgYSB0b29sdGlwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVuIGl0LlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucykge1xuXHRcdGlmICghKHRvb2x0aXAgaW5zdGFuY2VvZiBUb29sdGlwKSkge1xuXHRcdFx0dG9vbHRpcCA9IG5ldyBUb29sdGlwKG9wdGlvbnMpLnNldENvbnRlbnQodG9vbHRpcCk7XG5cdFx0fVxuXG5cdFx0aWYgKGxhdGxuZykge1xuXHRcdFx0dG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5oYXNMYXllcih0b29sdGlwKSkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIodG9vbHRpcCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAodG9vbHRpcD86IFRvb2x0aXApOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBnaXZlbiBhcyBwYXJhbWV0ZXIuXG5cdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXApIHtcblx0XHRpZiAodG9vbHRpcCkge1xuXHRcdFx0dGhpcy5yZW1vdmVMYXllcih0b29sdGlwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufSk7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIExheWVyXG4gKiBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHMgZXhhbXBsZVxuICpcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHRvb2x0aXBzIHRvIGl0LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFRvb2x0aXAoJ0hpIFRoZXJlIScpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5vcGVuVG9vbHRpcCgpO1xuICogbGF5ZXIuY2xvc2VUb29sdGlwKCk7XG4gKiBgYGBcbiAqL1xuXG4vLyBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHNcbkxheWVyLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2QgYmluZFRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFRvb2x0aXAsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIEJpbmRzIGEgdG9vbHRpcCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcblx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG5cdGJpbmRUb29sdGlwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXG5cdFx0aWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBUb29sdGlwKSB7XG5cdFx0XHRVdGlsLnNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gY29udGVudDtcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCBvcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBuZXcgVG9vbHRpcChvcHRpb25zLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKCk7XG5cblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCAmJiB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpKSB7XG5cdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB1bmJpbmRUb29sdGlwKCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgdG9vbHRpcCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRUb29sdGlwYC5cblx0dW5iaW5kVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyh0cnVlKTtcblx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0aWYgKCFyZW1vdmUgJiYgdGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gJ29mZicgOiAnb24nLFxuXHRcdCAgICBldmVudHMgPSB7XG5cdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VUb29sdGlwLFxuXHRcdFx0bW92ZTogdGhpcy5fbW92ZVRvb2x0aXBcblx0XHQgICAgfTtcblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5tb3VzZW92ZXIgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdGV2ZW50cy5tb3VzZW91dCA9IHRoaXMuY2xvc2VUb29sdGlwO1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kpIHtcblx0XHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSA9IHRoaXMuX21vdmVUb29sdGlwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKEJyb3dzZXIudG91Y2gpIHtcblx0XHRcdFx0ZXZlbnRzLmNsaWNrID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHR9XG5cdFx0dGhpc1tvbk9mZl0oZXZlbnRzKTtcblx0XHR0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCA9ICFyZW1vdmU7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBib3VuZCB0b29sdGlwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgdG9vbHRpcCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKGxheWVyLCBsYXRsbmcpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCAmJiB0aGlzLl9tYXApIHtcblx0XHRcdGxhdGxuZyA9IHRoaXMuX3Rvb2x0aXAuX3ByZXBhcmVPcGVuKHRoaXMsIGxheWVyLCBsYXRsbmcpO1xuXG5cdFx0XHQvLyBvcGVuIHRoZSB0b29sdGlwIG9uIHRoZSBtYXBcblx0XHRcdHRoaXMuX21hcC5vcGVuVG9vbHRpcCh0aGlzLl90b29sdGlwLCBsYXRsbmcpO1xuXG5cdFx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBtYXkgbm90IGJlIGRlZmluZWQgaWYgbm90IHBlcm1hbmVudCBhbmQgbmV2ZXJcblx0XHRcdC8vIG9wZW5lZC5cblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuX2Nsb3NlKCk7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLmludGVyYWN0aXZlICYmIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcikge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB0b2dnbGVUb29sdGlwKCk6IHRoaXNcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxuXHR0b2dnbGVUb29sdGlwOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLl9tYXApIHtcblx0XHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMub3BlblRvb2x0aXAodGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc1Rvb2x0aXBPcGVuKCk6IGJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cblx0aXNUb29sdGlwT3BlbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0VG9vbHRpcENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFRvb2x0aXApOiB0aGlzXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0c2V0VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRUb29sdGlwKCk6IFRvb2x0aXBcblx0Ly8gUmV0dXJucyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRnZXRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG5cdH0sXG5cblx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XG5cblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLm9wZW5Ub29sdGlwKGxheWVyLCB0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ID8gZS5sYXRsbmcgOiB1bmRlZmluZWQpO1xuXHR9LFxuXG5cdF9tb3ZlVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF0bG5nID0gZS5sYXRsbmcsIGNvbnRhaW5lclBvaW50LCBsYXllclBvaW50O1xuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ICYmIGUub3JpZ2luYWxFdmVudCkge1xuXHRcdFx0Y29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50KTtcblx0XHRcdGxheWVyUG9pbnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpO1xuXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcblx0XHR9XG5cdFx0dGhpcy5fdG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7ZW1wdHl9IGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBjbGFzcyBEaXZJY29uXG4gKiBAYWthIEwuRGl2SWNvblxuICogQGluaGVyaXRzIEljb25cbiAqXG4gKiBSZXByZXNlbnRzIGEgbGlnaHR3ZWlnaHQgaWNvbiBmb3IgbWFya2VycyB0aGF0IHVzZXMgYSBzaW1wbGUgYDxkaXY+YFxuICogZWxlbWVudCBpbnN0ZWFkIG9mIGFuIGltYWdlLiBJbmhlcml0cyBmcm9tIGBJY29uYCBidXQgaWdub3JlcyB0aGUgYGljb25VcmxgIGFuZCBzaGFkb3cgb3B0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBteUljb24gPSBMLmRpdkljb24oe2NsYXNzTmFtZTogJ215LWRpdi1pY29uJ30pO1xuICogLy8geW91IGNhbiBzZXQgLm15LWRpdi1pY29uIHN0eWxlcyBpbiBDU1NcbiAqXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKlxuICogQnkgZGVmYXVsdCwgaXQgaGFzIGEgJ2xlYWZsZXQtZGl2LWljb24nIENTUyBjbGFzcyBhbmQgaXMgc3R5bGVkIGFzIGEgbGl0dGxlIHdoaXRlIHNxdWFyZSB3aXRoIGEgc2hhZG93LlxuICovXG5cbmV4cG9ydCB2YXIgRGl2SWNvbiA9IEljb24uZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBEaXZJY29uIG9wdGlvbnNcblx0XHRpY29uU2l6ZTogWzEyLCAxMl0sIC8vIGFsc28gY2FuIGJlIHNldCB0aHJvdWdoIENTU1xuXG5cdFx0Ly8gaWNvbkFuY2hvcjogKFBvaW50KSxcblx0XHQvLyBwb3B1cEFuY2hvcjogKFBvaW50KSxcblxuXHRcdC8vIEBvcHRpb24gaHRtbDogU3RyaW5nfEhUTUxFbGVtZW50ID0gJydcblx0XHQvLyBDdXN0b20gSFRNTCBjb2RlIHRvIHB1dCBpbnNpZGUgdGhlIGRpdiBlbGVtZW50LCBlbXB0eSBieSBkZWZhdWx0LiBBbHRlcm5hdGl2ZWx5LFxuXHRcdC8vIGFuIGluc3RhbmNlIG9mIGBIVE1MRWxlbWVudGAuXG5cdFx0aHRtbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGJnUG9zOiBQb2ludCA9IFswLCAwXVxuXHRcdC8vIE9wdGlvbmFsIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBiYWNrZ3JvdW5kLCBpbiBwaXhlbHNcblx0XHRiZ1BvczogbnVsbCxcblxuXHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nXG5cdH0sXG5cblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcblx0XHR2YXIgZGl2ID0gKG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnRElWJykgPyBvbGRJY29uIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0aW9ucy5odG1sIGluc3RhbmNlb2YgRWxlbWVudCkge1xuXHRcdFx0ZW1wdHkoZGl2KTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZChvcHRpb25zLmh0bWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sICE9PSBmYWxzZSA/IG9wdGlvbnMuaHRtbCA6ICcnO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmJnUG9zKSB7XG5cdFx0XHR2YXIgYmdQb3MgPSBwb2ludChvcHRpb25zLmJnUG9zKTtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4Jztcblx0XHR9XG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cblx0XHRyZXR1cm4gZGl2O1xuXHR9LFxuXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBgRGl2SWNvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBkaXZJY29uKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBEaXZJY29uKG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuZXhwb3J0IHtpY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0IHtJY29uRGVmYXVsdH0gZnJvbSAnLi9JY29uLkRlZmF1bHQnO1xuSWNvbi5EZWZhdWx0ID0gSWNvbkRlZmF1bHQ7XG5leHBvcnQge0ljb259O1xuXG5leHBvcnQge0Rpdkljb24sIGRpdkljb259IGZyb20gJy4vRGl2SWNvbic7XG5leHBvcnQge01hcmtlciwgbWFya2VyfSBmcm9tICcuL01hcmtlcic7XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHMsIHRvTGF0TG5nQm91bmRzIGFzIGxhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5cbi8qXG4gKiBAY2xhc3MgR3JpZExheWVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5HcmlkTGF5ZXJcbiAqXG4gKiBHZW5lcmljIGNsYXNzIGZvciBoYW5kbGluZyBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cy4gVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIHRpbGUgbGF5ZXJzIGFuZCByZXBsYWNlcyBgVGlsZUxheWVyLkNhbnZhc2AuXG4gKiBHcmlkTGF5ZXIgY2FuIGJlIGV4dGVuZGVkIHRvIGNyZWF0ZSBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cyBsaWtlIGA8Y2FudmFzPmAsIGA8aW1nPmAgb3IgYDxkaXY+YC4gR3JpZExheWVyIHdpbGwgaGFuZGxlIGNyZWF0aW5nIGFuZCBhbmltYXRpbmcgdGhlc2UgRE9NIGVsZW1lbnRzIGZvciB5b3UuXG4gKlxuICpcbiAqIEBzZWN0aW9uIFN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBsYXllciwgZXh0ZW5kIEdyaWRMYXllciBhbmQgaW1wbGVtZW50IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGEgYFBvaW50YCBvYmplY3Qgd2l0aCB0aGUgYHhgLCBgeWAsIGFuZCBgemAgKHpvb20gbGV2ZWwpIGNvb3JkaW5hdGVzIHRvIGRyYXcgeW91ciB0aWxlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3Jkcyl7XG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGdldCBhIGNhbnZhcyBjb250ZXh0IGFuZCBkcmF3IHNvbWV0aGluZyBvbiBpdCB1c2luZyBjb29yZHMueCwgY29vcmRzLnkgYW5kIGNvb3Jkcy56XG4gKiAgICAgICAgIHZhciBjdHggPSB0aWxlLmdldENvbnRleHQoJzJkJyk7XG4gKlxuICogICAgICAgICAvLyByZXR1cm4gdGhlIHRpbGUgc28gaXQgY2FuIGJlIHJlbmRlcmVkIG9uIHNjcmVlblxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uIEFzeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUaWxlIGNyZWF0aW9uIGNhbiBhbHNvIGJlIGFzeW5jaHJvbm91cywgdGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBhIHRoaXJkLXBhcnR5IGRyYXdpbmcgbGlicmFyeS4gT25jZSB0aGUgdGlsZSBpcyBmaW5pc2hlZCBkcmF3aW5nIGl0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGBkb25lKClgIGNhbGxiYWNrLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgZG9uZSl7XG4gKiAgICAgICAgIHZhciBlcnJvcjtcbiAqXG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGRyYXcgc29tZXRoaW5nIGFzeW5jaHJvbm91c2x5IGFuZCBwYXNzIHRoZSB0aWxlIHRvIHRoZSBkb25lKCkgY2FsbGJhY2tcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGRvbmUoZXJyb3IsIHRpbGUpO1xuICogICAgICAgICB9LCAxMDAwKTtcbiAqXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb25cbiAqL1xuXG5cbmV4cG9ydCB2YXIgR3JpZExheWVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIEdyaWRMYXllciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHRpbGVTaXplOiBOdW1iZXJ8UG9pbnQgPSAyNTZcblx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRpbGVzIGluIHRoZSBncmlkLiBVc2UgYSBudW1iZXIgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZXF1YWwsIG9yIGBMLnBvaW50KHdpZHRoLCBoZWlnaHQpYCBvdGhlcndpc2UuXG5cdFx0dGlsZVNpemU6IDI1NixcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gT3BhY2l0eSBvZiB0aGUgdGlsZXMuIENhbiBiZSB1c2VkIGluIHRoZSBgY3JlYXRlVGlsZSgpYCBmdW5jdGlvbi5cblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IChkZXBlbmRzKVxuXHRcdC8vIExvYWQgbmV3IHRpbGVzIG9ubHkgd2hlbiBwYW5uaW5nIGVuZHMuXG5cdFx0Ly8gYHRydWVgIGJ5IGRlZmF1bHQgb24gbW9iaWxlIGJyb3dzZXJzLCBpbiBvcmRlciB0byBhdm9pZCB0b28gbWFueSByZXF1ZXN0cyBhbmQga2VlcCBzbW9vdGggbmF2aWdhdGlvbi5cblx0XHQvLyBgZmFsc2VgIG90aGVyd2lzZSBpbiBvcmRlciB0byBkaXNwbGF5IG5ldyB0aWxlcyBfZHVyaW5nXyBwYW5uaW5nLCBzaW5jZSBpdCBpcyBlYXN5IHRvIHBhbiBvdXRzaWRlIHRoZVxuXHRcdC8vIFtga2VlcEJ1ZmZlcmBdKCNncmlkbGF5ZXIta2VlcGJ1ZmZlcikgb3B0aW9uIGluIGRlc2t0b3AgYnJvd3NlcnMuXG5cdFx0dXBkYXRlV2hlbklkbGU6IEJyb3dzZXIubW9iaWxlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuWm9vbWluZzogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBCeSBkZWZhdWx0LCBhIHNtb290aCB6b29tIGFuaW1hdGlvbiAoZHVyaW5nIGEgW3RvdWNoIHpvb21dKCNtYXAtdG91Y2h6b29tKSBvciBhIFtgZmx5VG8oKWBdKCNtYXAtZmx5dG8pKSB3aWxsIHVwZGF0ZSBncmlkIGxheWVycyBldmVyeSBpbnRlZ2VyIHpvb20gbGV2ZWwuIFNldHRpbmcgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB3aWxsIHVwZGF0ZSB0aGUgZ3JpZCBsYXllciBvbmx5IHdoZW4gdGhlIHNtb290aCBhbmltYXRpb24gZW5kcy5cblx0XHR1cGRhdGVXaGVuWm9vbWluZzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlSW50ZXJ2YWw6IE51bWJlciA9IDIwMFxuXHRcdC8vIFRpbGVzIHdpbGwgbm90IHVwZGF0ZSBtb3JlIHRoYW4gb25jZSBldmVyeSBgdXBkYXRlSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyB3aGVuIHBhbm5pbmcuXG5cdFx0dXBkYXRlSW50ZXJ2YWw6IDIwMCxcblxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IHpJbmRleCBvZiB0aGUgdGlsZSBsYXllci5cblx0XHR6SW5kZXg6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGJvdW5kczogTGF0TG5nQm91bmRzID0gdW5kZWZpbmVkXG5cdFx0Ly8gSWYgc2V0LCB0aWxlcyB3aWxsIG9ubHkgYmUgbG9hZGVkIGluc2lkZSB0aGUgc2V0IGBMYXRMbmdCb3VuZHNgLlxuXHRcdGJvdW5kczogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuXHRcdG1pblpvb206IDAsXG5cblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cblx0XHRtYXhab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG1heE5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIE1heGltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGhpZ2hlciB0aGFuIGBtYXhOYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuXHRcdC8vIGZyb20gYG1heE5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cblx0XHRtYXhOYXRpdmVab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG1pbk5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIE1pbmltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGxvd2VyIHRoYW4gYG1pbk5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG5cdFx0Ly8gZnJvbSBgbWluTmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuXHRcdG1pbk5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbm9XcmFwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRoZSBsYXllciBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgYW50aW1lcmlkaWFuLiBJZiBgdHJ1ZWAsIHRoZVxuXHRcdC8vIEdyaWRMYXllciB3aWxsIG9ubHkgYmUgZGlzcGxheWVkIG9uY2UgYXQgbG93IHpvb20gbGV2ZWxzLiBIYXMgbm9cblx0XHQvLyBlZmZlY3Qgd2hlbiB0aGUgW21hcCBDUlNdKCNtYXAtY3JzKSBkb2Vzbid0IHdyYXAgYXJvdW5kLiBDYW4gYmUgdXNlZFxuXHRcdC8vIGluIGNvbWJpbmF0aW9uIHdpdGggW2Bib3VuZHNgXSgjZ3JpZGxheWVyLWJvdW5kcykgdG8gcHJldmVudCByZXF1ZXN0aW5nXG5cdFx0Ly8gdGlsZXMgb3V0c2lkZSB0aGUgQ1JTIGxpbWl0cy5cblx0XHRub1dyYXA6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndGlsZVBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgZ3JpZCBsYXllciB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0aWxlUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcblx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgdGlsZSBsYXllci4gRW1wdHkgYnkgZGVmYXVsdC5cblx0XHRjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gQG9wdGlvbiBrZWVwQnVmZmVyOiBOdW1iZXIgPSAyXG5cdFx0Ly8gV2hlbiBwYW5uaW5nIHRoZSBtYXAsIGtlZXAgdGhpcyBtYW55IHJvd3MgYW5kIGNvbHVtbnMgb2YgdGlsZXMgYmVmb3JlIHVubG9hZGluZyB0aGVtLlxuXHRcdGtlZXBCdWZmZXI6IDJcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2luaXRDb250YWluZXIoKTtcblxuXHRcdHRoaXMuX2xldmVscyA9IHt9O1xuXHRcdHRoaXMuX3RpbGVzID0ge307XG5cblx0XHR0aGlzLl9yZXNldFZpZXcoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAuX2FkZFpvb21MaW1pdCh0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRtYXAuX3JlbW92ZVpvb21MaW1pdCh0aGlzKTtcblx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0RG9tVXRpbC50b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWF4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgdGlsZSBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5taW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHRpbGVzIGZvciB0aGlzIGxheWVyLlxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIFtvcGFjaXR5XSgjZ3JpZGxheWVyLW9wYWNpdHkpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNncmlkbGF5ZXItemluZGV4KSBvZiB0aGUgZ3JpZCBsYXllci5cblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHpJbmRleDtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNMb2FkaW5nOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGFueSB0aWxlIGluIHRoZSBncmlkIGxheWVyIGhhcyBub3QgZmluaXNoZWQgbG9hZGluZy5cblx0aXNMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRpbmc7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXc6IHRoaXNcblx0Ly8gQ2F1c2VzIHRoZSBsYXllciB0byBjbGVhciBhbGwgdGhlIHRpbGVzIGFuZCByZXF1ZXN0IHRoZW0gYWdhaW4uXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHtcblx0XHRcdHZpZXdwcmVyZXNldDogdGhpcy5faW52YWxpZGF0ZUFsbCxcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRWaWV3LFxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXRWaWV3LFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fb25Nb3ZlRW5kXG5cdFx0fTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlKSB7XG5cdFx0XHQvLyB1cGRhdGUgdGlsZXMgb24gbW92ZSwgYnV0IG5vdCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgZ2l2ZW4gaW50ZXJ2YWxcblx0XHRcdGlmICghdGhpcy5fb25Nb3ZlKSB7XG5cdFx0XHRcdHRoaXMuX29uTW92ZSA9IFV0aWwudGhyb3R0bGUodGhpcy5fb25Nb3ZlRW5kLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRldmVudHMubW92ZSA9IHRoaXMuX29uTW92ZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIExheWVycyBleHRlbmRpbmcgYEdyaWRMYXllcmAgc2hhbGwgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgbXVzdCBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGBjb29yZHNgLiBJZiB0aGUgYGRvbmVgIGNhbGxiYWNrXG5cdC8vIGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgZmluaXNoZWQgbG9hZGluZyBhbmQgZHJhd2luZy5cblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0fSxcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAbWV0aG9kIGdldFRpbGVTaXplOiBQb2ludFxuXHQvLyBOb3JtYWxpemVzIHRoZSBbdGlsZVNpemUgb3B0aW9uXSgjZ3JpZGxheWVyLXRpbGVzaXplKSBpbnRvIGEgcG9pbnQuIFVzZWQgYnkgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZC5cblx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcyA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcblx0XHRyZXR1cm4gcyBpbnN0YW5jZW9mIFBvaW50ID8gcyA6IG5ldyBQb2ludChzLCBzKTtcblx0fSxcblxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRBdXRvWkluZGV4OiBmdW5jdGlvbiAoY29tcGFyZSkge1xuXHRcdC8vIGdvIHRocm91Z2ggYWxsIG90aGVyIGxheWVycyBvZiB0aGUgc2FtZSBwYW5lLCBzZXQgekluZGV4IHRvIG1heCArIDEgKGZyb250KSBvciBtaW4gLSAxIChiYWNrKVxuXG5cdFx0dmFyIGxheWVycyA9IHRoaXMuZ2V0UGFuZSgpLmNoaWxkcmVuLFxuXHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoLUluZmluaXR5LCBJbmZpbml0eSk7IC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aCwgekluZGV4OyBpIDwgbGVuOyBpKyspIHtcblxuXHRcdFx0ekluZGV4ID0gbGF5ZXJzW2ldLnN0eWxlLnpJbmRleDtcblxuXHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyICYmIHpJbmRleCkge1xuXHRcdFx0XHRlZGdlWkluZGV4ID0gY29tcGFyZShlZGdlWkluZGV4LCArekluZGV4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNGaW5pdGUoZWRnZVpJbmRleCkpIHtcblx0XHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSBlZGdlWkluZGV4ICsgY29tcGFyZSgtMSwgMSk7XG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdC8vIElFIGRvZXNuJ3QgaW5oZXJpdCBmaWx0ZXIgb3BhY2l0eSBwcm9wZXJseSwgc28gd2UncmUgZm9yY2VkIHRvIHNldCBpdCBvbiB0aWxlc1xuXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7IHJldHVybjsgfVxuXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0dmFyIG5vdyA9ICtuZXcgRGF0ZSgpLFxuXHRcdCAgICBuZXh0RnJhbWUgPSBmYWxzZSxcblx0XHQgICAgd2lsbFBydW5lID0gZmFsc2U7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdGlmICghdGlsZS5jdXJyZW50IHx8ICF0aWxlLmxvYWRlZCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHR2YXIgZmFkZSA9IE1hdGgubWluKDEsIChub3cgLSB0aWxlLmxvYWRlZCkgLyAyMDApO1xuXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgZmFkZSk7XG5cdFx0XHRpZiAoZmFkZSA8IDEpIHtcblx0XHRcdFx0bmV4dEZyYW1lID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHdpbGxQcnVuZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fb25PcGFxdWVUaWxlKHRpbGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAod2lsbFBydW5lICYmICF0aGlzLl9ub1BydW5lKSB7IHRoaXMuX3BydW5lVGlsZXMoKTsgfVxuXG5cdFx0aWYgKG5leHRGcmFtZSkge1xuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X29uT3BhcXVlVGlsZTogVXRpbC5mYWxzZUZuLFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1sYXllciAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVMZXZlbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG5cdFx0ICAgIG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcblxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcblx0XHRcdFx0dGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG5cdFx0XHRcdHRoaXMuX29uVXBkYXRlTGV2ZWwoeik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlc0F0Wm9vbSh6KTtcblx0XHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0sXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdGlmICghbGV2ZWwpIHtcblx0XHRcdGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dID0ge307XG5cblx0XHRcdGxldmVsLmVsID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXRpbGUtY29udGFpbmVyIGxlYWZsZXQtem9vbS1hbmltYXRlZCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRsZXZlbC5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tO1xuXG5cdFx0XHRsZXZlbC5vcmlnaW4gPSBtYXAucHJvamVjdChtYXAudW5wcm9qZWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKSwgem9vbSkucm91bmQoKTtcblx0XHRcdGxldmVsLnpvb20gPSB6b29tO1xuXG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKGxldmVsLCBtYXAuZ2V0Q2VudGVyKCksIG1hcC5nZXRab29tKCkpO1xuXG5cdFx0XHQvLyBmb3JjZSB0aGUgYnJvd3NlciB0byBjb25zaWRlciB0aGUgbmV3bHkgYWRkZWQgZWxlbWVudCBmb3IgdHJhbnNpdGlvblxuXHRcdFx0VXRpbC5mYWxzZUZuKGxldmVsLmVsLm9mZnNldFdpZHRoKTtcblxuXHRcdFx0dGhpcy5fb25DcmVhdGVMZXZlbChsZXZlbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGV2ZWwgPSBsZXZlbDtcblxuXHRcdHJldHVybiBsZXZlbDtcblx0fSxcblxuXHRfb25VcGRhdGVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9vblJlbW92ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X29uQ3JlYXRlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfcHJ1bmVUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGtleSwgdGlsZTtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8XG5cdFx0XHR6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0aWxlLmN1cnJlbnQ7XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKHRpbGUuY3VycmVudCAmJiAhdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0dmFyIGNvb3JkcyA9IHRpbGUuY29vcmRzO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldGFpblBhcmVudChjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiAtIDUpKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogKyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ucmV0YWluKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVRpbGVzQXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2tleV0uY29vcmRzLnogIT09IHpvb20pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVBbGxUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdH1cblx0fSxcblxuXHRfaW52YWxpZGF0ZUFsbDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0fVxuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cblx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRfcmV0YWluUGFyZW50OiBmdW5jdGlvbiAoeCwgeSwgeiwgbWluWm9vbSkge1xuXHRcdHZhciB4MiA9IE1hdGguZmxvb3IoeCAvIDIpLFxuXHRcdCAgICB5MiA9IE1hdGguZmxvb3IoeSAvIDIpLFxuXHRcdCAgICB6MiA9IHogLSAxLFxuXHRcdCAgICBjb29yZHMyID0gbmV3IFBvaW50KCt4MiwgK3kyKTtcblx0XHRjb29yZHMyLnogPSArejI7XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkczIpLFxuXHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICh6MiA+IG1pblpvb20pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXRhaW5QYXJlbnQoeDIsIHkyLCB6MiwgbWluWm9vbSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9yZXRhaW5DaGlsZHJlbjogZnVuY3Rpb24gKHgsIHksIHosIG1heFpvb20pIHtcblxuXHRcdGZvciAodmFyIGkgPSAyICogeDsgaSA8IDIgKiB4ICsgMjsgaSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMiAqIHk7IGogPCAyICogeSArIDI7IGorKykge1xuXG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0geiArIDE7XG5cblx0XHRcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpLFxuXHRcdFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRcdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHogKyAxIDwgbWF4Wm9vbSkge1xuXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGksIGosIHogKyAxLCBtYXhab29tKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBhbmltYXRpbmcgPSBlICYmIChlLnBpbmNoIHx8IGUuZmx5VG8pO1xuXHRcdHRoaXMuX3NldFZpZXcodGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpLCBhbmltYXRpbmcsIGFuaW1hdGluZyk7XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX3NldFZpZXcoZS5jZW50ZXIsIGUuem9vbSwgdHJ1ZSwgZS5ub1VwZGF0ZSk7XG5cdH0sXG5cblx0X2NsYW1wWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWluTmF0aXZlWm9vbSAmJiB6b29tIDwgb3B0aW9ucy5taW5OYXRpdmVab29tKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5taW5OYXRpdmVab29tO1xuXHRcdH1cblxuXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWF4TmF0aXZlWm9vbSAmJiBvcHRpb25zLm1heE5hdGl2ZVpvb20gPCB6b29tKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5tYXhOYXRpdmVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiB6b29tO1xuXHR9LFxuXG5cdF9zZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBub1BydW5lLCBub1VwZGF0ZSkge1xuXHRcdHZhciB0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbShNYXRoLnJvdW5kKHpvb20pKTtcblx0XHRpZiAoKHRoaXMub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkgfHxcblx0XHQgICAgKHRoaXMub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRpbGVab29tID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHZhciB0aWxlWm9vbUNoYW5nZWQgPSB0aGlzLm9wdGlvbnMudXBkYXRlV2hlblpvb21pbmcgJiYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSk7XG5cblx0XHRpZiAoIW5vVXBkYXRlIHx8IHRpbGVab29tQ2hhbmdlZCkge1xuXG5cdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXG5cdFx0XHRpZiAodGhpcy5fYWJvcnRMb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2Fib3J0TG9hZGluZygpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcblx0XHRcdHRoaXMuX3Jlc2V0R3JpZCgpO1xuXG5cdFx0XHRpZiAodGlsZVpvb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl91cGRhdGUoY2VudGVyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFub1BydW5lKSB7XG5cdFx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmxhZyB0byBwcmV2ZW50IF91cGRhdGVPcGFjaXR5IGZyb20gcHJ1bmluZyB0aWxlcyBkdXJpbmdcblx0XHRcdC8vIGEgem9vbSBhbmltIG9yIGEgcGluY2ggZ2VzdHVyZVxuXHRcdFx0dGhpcy5fbm9QcnVuZSA9ICEhbm9QcnVuZTtcblx0XHR9XG5cblx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtcyhjZW50ZXIsIHpvb20pO1xuXHR9LFxuXG5cdF9zZXRab29tVHJhbnNmb3JtczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKHRoaXMuX2xldmVsc1tpXSwgY2VudGVyLCB6b29tKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm06IGZ1bmN0aW9uIChsZXZlbCwgY2VudGVyLCB6b29tKSB7XG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCBsZXZlbC56b29tKSxcblx0XHQgICAgdHJhbnNsYXRlID0gbGV2ZWwub3JpZ2luLm11bHRpcGx5Qnkoc2NhbGUpXG5cdFx0ICAgICAgICAuc3VidHJhY3QodGhpcy5fbWFwLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pKS5yb3VuZCgpO1xuXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKGxldmVsLmVsLCB0cmFuc2xhdGUsIHNjYWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihsZXZlbC5lbCwgdHJhbnNsYXRlKTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0R3JpZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycyxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLl90aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblx0XHQgICAgdGlsZVpvb20gPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcyh0aGlzLl90aWxlWm9vbSk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dGhpcy5fZ2xvYmFsVGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShib3VuZHMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3dyYXBYID0gY3JzLndyYXBMbmcgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMF1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1sxXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHRcdHRoaXMuX3dyYXBZID0gY3JzLndyYXBMYXQgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMF0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLngpLFxuXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFsxXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueSlcblx0XHRdO1xuXHR9LFxuXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfZ2V0VGlsZWRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG1hcFpvb20gPSBtYXAuX2FuaW1hdGluZ1pvb20gPyBNYXRoLm1heChtYXAuX2FuaW1hdGVUb1pvb20sIG1hcC5nZXRab29tKCkpIDogbWFwLmdldFpvb20oKSxcblx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKG1hcFpvb20sIHRoaXMuX3RpbGVab29tKSxcblx0XHQgICAgcGl4ZWxDZW50ZXIgPSBtYXAucHJvamVjdChjZW50ZXIsIHRoaXMuX3RpbGVab29tKS5mbG9vcigpLFxuXHRcdCAgICBoYWxmU2l6ZSA9IG1hcC5nZXRTaXplKCkuZGl2aWRlQnkoc2NhbGUgKiAyKTtcblxuXHRcdHJldHVybiBuZXcgQm91bmRzKHBpeGVsQ2VudGVyLnN1YnRyYWN0KGhhbGZTaXplKSwgcGl4ZWxDZW50ZXIuYWRkKGhhbGZTaXplKSk7XG5cdH0sXG5cblx0Ly8gUHJpdmF0ZSBtZXRob2QgdG8gbG9hZCB0aWxlcyBpbiB0aGUgZ3JpZCdzIGFjdGl2ZSB6b29tIGxldmVsIGFjY29yZGluZyB0byBtYXAgYm91bmRzXG5cdF91cGRhdGU6IGZ1bmN0aW9uIChjZW50ZXIpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxuXHRcdHZhciB6b29tID0gdGhpcy5fY2xhbXBab29tKG1hcC5nZXRab29tKCkpO1xuXG5cdFx0aWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSB7IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTsgfVxuXHRcdGlmICh0aGlzLl90aWxlWm9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfVx0Ly8gaWYgb3V0IG9mIG1pbnpvb20vbWF4em9vbVxuXG5cdFx0dmFyIHBpeGVsQm91bmRzID0gdGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyhjZW50ZXIpLFxuXHRcdCAgICB0aWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKHBpeGVsQm91bmRzKSxcblx0XHQgICAgdGlsZUNlbnRlciA9IHRpbGVSYW5nZS5nZXRDZW50ZXIoKSxcblx0XHQgICAgcXVldWUgPSBbXSxcblx0XHQgICAgbWFyZ2luID0gdGhpcy5vcHRpb25zLmtlZXBCdWZmZXIsXG5cdFx0ICAgIG5vUHJ1bmVSYW5nZSA9IG5ldyBCb3VuZHModGlsZVJhbmdlLmdldEJvdHRvbUxlZnQoKS5zdWJ0cmFjdChbbWFyZ2luLCAtbWFyZ2luXSksXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVJhbmdlLmdldFRvcFJpZ2h0KCkuYWRkKFttYXJnaW4sIC1tYXJnaW5dKSk7XG5cblx0XHQvLyBTYW5pdHkgY2hlY2s6IHBhbmljIGlmIHRoZSB0aWxlIHJhbmdlIGNvbnRhaW5zIEluZmluaXR5IHNvbWV3aGVyZS5cblx0XHRpZiAoIShpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLngpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1pbi55KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LnkpKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBsb2FkIGFuIGluZmluaXRlIG51bWJlciBvZiB0aWxlcycpOyB9XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciBjID0gdGhpcy5fdGlsZXNba2V5XS5jb29yZHM7XG5cdFx0XHRpZiAoYy56ICE9PSB0aGlzLl90aWxlWm9vbSB8fCAhbm9QcnVuZVJhbmdlLmNvbnRhaW5zKG5ldyBQb2ludChjLngsIGMueSkpKSB7XG5cdFx0XHRcdHRoaXMuX3RpbGVzW2tleV0uY3VycmVudCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIF91cGRhdGUganVzdCBsb2FkcyBtb3JlIHRpbGVzLiBJZiB0aGUgdGlsZSB6b29tIGxldmVsIGRpZmZlcnMgdG9vIG11Y2hcblx0XHQvLyBmcm9tIHRoZSBtYXAncywgbGV0IF9zZXRWaWV3IHJlc2V0IGxldmVscyBhbmQgcHJ1bmUgb2xkIHRpbGVzLlxuXHRcdGlmIChNYXRoLmFicyh6b29tIC0gdGhpcy5fdGlsZVpvb20pID4gMSkgeyB0aGlzLl9zZXRWaWV3KGNlbnRlciwgem9vbSk7IHJldHVybjsgfVxuXG5cdFx0Ly8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCB0aWxlcyBmcm9tXG5cdFx0Zm9yICh2YXIgaiA9IHRpbGVSYW5nZS5taW4ueTsgaiA8PSB0aWxlUmFuZ2UubWF4Lnk7IGorKykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRpbGVSYW5nZS5taW4ueDsgaSA8PSB0aWxlUmFuZ2UubWF4Lng7IGkrKykge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuXHRcdFx0XHRjb29yZHMueiA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0XHRcdGlmICghdGhpcy5faXNWYWxpZFRpbGUoY29vcmRzKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyldO1xuXHRcdFx0XHRpZiAodGlsZSkge1xuXHRcdFx0XHRcdHRpbGUuY3VycmVudCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaChjb29yZHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc29ydCB0aWxlIHF1ZXVlIHRvIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG5cdFx0cXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0cmV0dXJuIGEuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKSAtIGIuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKTtcblx0XHR9KTtcblxuXHRcdGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcblx0XHRcdC8vIGlmIGl0J3MgdGhlIGZpcnN0IGJhdGNoIG9mIHRpbGVzIHRvIGxvYWRcblx0XHRcdGlmICghdGhpcy5fbG9hZGluZykge1xuXHRcdFx0XHR0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0Ly8gQGV2ZW50IGxvYWRpbmc6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgc3RhcnRzIGxvYWRpbmcgdGlsZXMuXG5cdFx0XHRcdHRoaXMuZmlyZSgnbG9hZGluZycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjcmVhdGUgRE9NIGZyYWdtZW50IHRvIGFwcGVuZCB0aWxlcyBpbiBvbmUgYmF0Y2hcblx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX2FkZFRpbGUocXVldWVbaV0sIGZyYWdtZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGV2ZWwuZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuXHRcdH1cblx0fSxcblxuXHRfaXNWYWxpZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKCFjcnMuaW5maW5pdGUpIHtcblx0XHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCdzIG91dCBvZiBib3VuZHMgYW5kIG5vdCB3cmFwcGVkXG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlO1xuXHRcdFx0aWYgKCghY3JzLndyYXBMbmcgJiYgKGNvb3Jkcy54IDwgYm91bmRzLm1pbi54IHx8IGNvb3Jkcy54ID4gYm91bmRzLm1heC54KSkgfHxcblx0XHRcdCAgICAoIWNycy53cmFwTGF0ICYmIChjb29yZHMueSA8IGJvdW5kcy5taW4ueSB8fCBjb29yZHMueSA+IGJvdW5kcy5tYXgueSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5vcHRpb25zLmJvdW5kcykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3VuZHMgaW4gb3B0aW9uc1xuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3Jkcyk7XG5cdFx0cmV0dXJuIGxhdExuZ0JvdW5kcyh0aGlzLm9wdGlvbnMuYm91bmRzKS5vdmVybGFwcyh0aWxlQm91bmRzKTtcblx0fSxcblxuXHRfa2V5VG9Cb3VuZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpKTtcblx0fSxcblxuXHRfdGlsZUNvb3Jkc1RvTndTZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICBud1BvaW50ID0gY29vcmRzLnNjYWxlQnkodGlsZVNpemUpLFxuXHRcdCAgICBzZVBvaW50ID0gbndQb2ludC5hZGQodGlsZVNpemUpLFxuXHRcdCAgICBudyA9IG1hcC51bnByb2plY3QobndQb2ludCwgY29vcmRzLnopLFxuXHRcdCAgICBzZSA9IG1hcC51bnByb2plY3Qoc2VQb2ludCwgY29vcmRzLnopO1xuXHRcdHJldHVybiBbbncsIHNlXTtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGl0cyBnZW9ncmFwaGljYWwgYm91bmRzXG5cdF90aWxlQ29vcmRzVG9Cb3VuZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgYnAgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoYnBbMF0sIGJwWzFdKTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLm5vV3JhcCkge1xuXHRcdFx0Ym91bmRzID0gdGhpcy5fbWFwLndyYXBMYXRMbmdCb3VuZHMoYm91bmRzKTtcblx0XHR9XG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fSxcblx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBrZXkgZm9yIHRoZSB0aWxlIGNhY2hlXG5cdF90aWxlQ29vcmRzVG9LZXk6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnggKyAnOicgKyBjb29yZHMueSArICc6JyArIGNvb3Jkcy56O1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY2FjaGUga2V5IHRvIGNvb3JkaW5hdGVzXG5cdF9rZXlUb1RpbGVDb29yZHM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgayA9IGtleS5zcGxpdCgnOicpLFxuXHRcdCAgICBjb29yZHMgPSBuZXcgUG9pbnQoK2tbMF0sICtrWzFdKTtcblx0XHRjb29yZHMueiA9ICtrWzJdO1xuXHRcdHJldHVybiBjb29yZHM7XG5cdH0sXG5cblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG5cdFx0RG9tVXRpbC5yZW1vdmUodGlsZS5lbCk7XG5cblx0XHRkZWxldGUgdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdC8vIEBldmVudCB0aWxldW5sb2FkOiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZW1vdmVkIChlLmcuIHdoZW4gYSB0aWxlIGdvZXMgb2ZmIHRoZSBzY3JlZW4pLlxuXHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHtcblx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRjb29yZHM6IHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpXG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGlsZSwgJ2xlYWZsZXQtdGlsZScpO1xuXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHRpbGUuc3R5bGUud2lkdGggPSB0aWxlU2l6ZS54ICsgJ3B4Jztcblx0XHR0aWxlLnN0eWxlLmhlaWdodCA9IHRpbGVTaXplLnkgKyAncHgnO1xuXG5cdFx0dGlsZS5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xuXHRcdHRpbGUub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XG5cblx0XHQvLyB1cGRhdGUgb3BhY2l0eSBvbiB0aWxlcyBpbiBJRTctOCBiZWNhdXNlIG9mIGZpbHRlciBpbmhlcml0YW5jZSBwcm9ibGVtc1xuXHRcdGlmIChCcm93c2VyLmllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblx0XHR9XG5cblx0XHQvLyB3aXRob3V0IHRoaXMgaGFjaywgdGlsZXMgZGlzYXBwZWFyIGFmdGVyIHpvb20gb24gQ2hyb21lIGZvciBBbmRyb2lkXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjA3OFxuXHRcdGlmIChCcm93c2VyLmFuZHJvaWQgJiYgIUJyb3dzZXIuYW5kcm9pZDIzKSB7XG5cdFx0XHR0aWxlLnN0eWxlLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgY29udGFpbmVyKSB7XG5cdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKGNvb3JkcyksXG5cdFx0ICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpLCBVdGlsLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMpKTtcblxuXHRcdHRoaXMuX2luaXRUaWxlKHRpbGUpO1xuXG5cdFx0Ly8gaWYgY3JlYXRlVGlsZSBpcyBkZWZpbmVkIHdpdGggYSBzZWNvbmQgYXJndW1lbnQgKFwiZG9uZVwiIGNhbGxiYWNrKSxcblx0XHQvLyB3ZSBrbm93IHRoYXQgdGlsZSBpcyBhc3luYyBhbmQgd2lsbCBiZSByZWFkeSBsYXRlcjsgb3RoZXJ3aXNlXG5cdFx0aWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG5cdFx0XHQvLyBtYXJrIHRpbGUgYXMgcmVhZHksIGJ1dCBkZWxheSBvbmUgZnJhbWUgZm9yIG9wYWNpdHkgYW5pbWF0aW9uIHRvIGhhcHBlblxuXHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFV0aWwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcywgbnVsbCwgdGlsZSkpO1xuXHRcdH1cblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGlsZSwgdGlsZVBvcyk7XG5cblx0XHQvLyBzYXZlIHRpbGUgaW4gY2FjaGVcblx0XHR0aGlzLl90aWxlc1trZXldID0ge1xuXHRcdFx0ZWw6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkcyxcblx0XHRcdGN1cnJlbnQ6IHRydWVcblx0XHR9O1xuXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRpbGUpO1xuXHRcdC8vIEBldmVudCB0aWxlbG9hZHN0YXJ0OiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZXF1ZXN0ZWQgYW5kIHN0YXJ0cyBsb2FkaW5nLlxuXHRcdHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcblx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdH0pO1xuXHR9LFxuXG5cdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgdGlsZSkge1xuXHRcdGlmIChlcnIpIHtcblx0XHRcdC8vIEBldmVudCB0aWxlZXJyb3I6IFRpbGVFcnJvckV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGxvYWRpbmcgYSB0aWxlLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlZXJyb3InLCB7XG5cdFx0XHRcdGVycm9yOiBlcnIsXG5cdFx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHR0aWxlLmxvYWRlZCA9ICtuZXcgRGF0ZSgpO1xuXHRcdGlmICh0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIDApO1xuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdH1cblxuXHRcdGlmICghZXJyKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRpbGUuZWwsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XG5cblx0XHRcdC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBsb2Fkcy5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWxvYWQnLCB7XG5cdFx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG5cdFx0XHR0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG5cdFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XG5cblx0XHRcdGlmIChCcm93c2VyLmllbHQ5IHx8ICF0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXYWl0IGEgYml0IG1vcmUgdGhhbiAwLjIgc2VjcyAodGhlIGR1cmF0aW9uIG9mIHRoZSB0aWxlIGZhZGUtaW4pXG5cdFx0XHRcdC8vIHRvIHRyaWdnZXIgYSBwcnVuaW5nLlxuXHRcdFx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKSwgMjUwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKS5zdWJ0cmFjdCh0aGlzLl9sZXZlbC5vcmlnaW4pO1xuXHR9LFxuXG5cdF93cmFwQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG5ld0Nvb3JkcyA9IG5ldyBQb2ludChcblx0XHRcdHRoaXMuX3dyYXBYID8gVXRpbC53cmFwTnVtKGNvb3Jkcy54LCB0aGlzLl93cmFwWCkgOiBjb29yZHMueCxcblx0XHRcdHRoaXMuX3dyYXBZID8gVXRpbC53cmFwTnVtKGNvb3Jkcy55LCB0aGlzLl93cmFwWSkgOiBjb29yZHMueSk7XG5cdFx0bmV3Q29vcmRzLnogPSBjb29yZHMuejtcblx0XHRyZXR1cm4gbmV3Q29vcmRzO1xuXHR9LFxuXG5cdF9weEJvdW5kc1RvVGlsZVJhbmdlOiBmdW5jdGlvbiAoYm91bmRzKSB7XG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHJldHVybiBuZXcgQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi51bnNjYWxlQnkodGlsZVNpemUpLmZsb29yKCksXG5cdFx0XHRib3VuZHMubWF4LnVuc2NhbGVCeSh0aWxlU2l6ZSkuY2VpbCgpLnN1YnRyYWN0KFsxLCAxXSkpO1xuXHR9LFxuXG5cdF9ub1RpbGVzVG9Mb2FkOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ubG9hZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuZ3JpZExheWVyKG9wdGlvbnM/OiBHcmlkTGF5ZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgR3JpZExheWVyIHdpdGggdGhlIHN1cHBsaWVkIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gZ3JpZExheWVyKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBHcmlkTGF5ZXIob3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0dyaWRMYXllcn0gZnJvbSAnLi9HcmlkTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XHJcblxyXG5cclxuLypcclxuICogQGNsYXNzIFRpbGVMYXllclxyXG4gKiBAaW5oZXJpdHMgR3JpZExheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXJcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIE5vdGUgdGhhdCBtb3N0IHRpbGUgc2VydmVycyByZXF1aXJlIGF0dHJpYnV0aW9uLCB3aGljaCB5b3UgY2FuIHNldCB1bmRlciBgTGF5ZXJgLiBFeHRlbmRzIGBHcmlkTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLnRpbGVMYXllcignaHR0cHM6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmc/e2Zvb30nLCB7Zm9vOiAnYmFyJywgYXR0cmlidXRpb246ICdNYXAgZGF0YSAmY29weTsgPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL1wiPk9wZW5TdHJlZXRNYXA8L2E+IGNvbnRyaWJ1dG9ycywgPGEgaHJlZj1cImh0dHBzOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1zYS8yLjAvXCI+Q0MtQlktU0E8L2E+J30pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAc2VjdGlvbiBVUkwgdGVtcGxhdGVcclxuICogQGV4YW1wbGVcclxuICpcclxuICogQSBzdHJpbmcgb2YgdGhlIGZvbGxvd2luZyBmb3JtOlxyXG4gKlxyXG4gKiBgYGBcclxuICogJ2h0dHA6Ly97c30uc29tZWRvbWFpbi5jb20vYmxhYmxhL3t6fS97eH0ve3l9e3J9LnBuZydcclxuICogYGBgXHJcbiAqXHJcbiAqIGB7c31gIG1lYW5zIG9uZSBvZiB0aGUgYXZhaWxhYmxlIHN1YmRvbWFpbnMgKHVzZWQgc2VxdWVudGlhbGx5IHRvIGhlbHAgd2l0aCBicm93c2VyIHBhcmFsbGVsIHJlcXVlc3RzIHBlciBkb21haW4gbGltaXRhdGlvbjsgc3ViZG9tYWluIHZhbHVlcyBhcmUgc3BlY2lmaWVkIGluIG9wdGlvbnM7IGBhYCwgYGJgIG9yIGBjYCBieSBkZWZhdWx0LCBjYW4gYmUgb21pdHRlZCksIGB7en1gIOKAlCB6b29tIGxldmVsLCBge3h9YCBhbmQgYHt5fWAg4oCUIHRpbGUgY29vcmRpbmF0ZXMuIGB7cn1gIGNhbiBiZSB1c2VkIHRvIGFkZCBcIiZjb21tYXQ7MnhcIiB0byB0aGUgVVJMIHRvIGxvYWQgcmV0aW5hIHRpbGVzLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHVzZSBjdXN0b20ga2V5cyBpbiB0aGUgdGVtcGxhdGUsIHdoaWNoIHdpbGwgYmUgW2V2YWx1YXRlZF0oI3V0aWwtdGVtcGxhdGUpIGZyb20gVGlsZUxheWVyIG9wdGlvbnMsIGxpa2UgdGhpczpcclxuICpcclxuICogYGBgXHJcbiAqIEwudGlsZUxheWVyKCdodHRwOi8ve3N9LnNvbWVkb21haW4uY29tL3tmb299L3t6fS97eH0ve3l9LnBuZycsIHtmb286ICdiYXInfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG5leHBvcnQgdmFyIFRpbGVMYXllciA9IEdyaWRMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcclxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWluWm9vbTogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IDE4XHJcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcblx0XHRtYXhab29tOiAxOCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN1YmRvbWFpbnM6IFN0cmluZ3xTdHJpbmdbXSA9ICdhYmMnXHJcblx0XHQvLyBTdWJkb21haW5zIG9mIHRoZSB0aWxlIHNlcnZpY2UuIENhbiBiZSBwYXNzZWQgaW4gdGhlIGZvcm0gb2Ygb25lIHN0cmluZyAod2hlcmUgZWFjaCBsZXR0ZXIgaXMgYSBzdWJkb21haW4gbmFtZSkgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuXHRcdHN1YmRvbWFpbnM6ICdhYmMnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZXJyb3JUaWxlVXJsOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVVJMIHRvIHRoZSB0aWxlIGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIHRpbGUgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuXHRcdGVycm9yVGlsZVVybDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSBvZmZzZXQgd2l0aCB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbU9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRtczogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIGludmVyc2VzIFkgYXhpcyBudW1iZXJpbmcgZm9yIHRpbGVzICh0dXJuIHRoaXMgb24gZm9yIFtUTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS5cclxuXHRcdHRtczogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tUmV2ZXJzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgcmV2ZXJzZWQgKGBtYXhab29tIC0gem9vbWAgaW5zdGVhZCBvZiBgem9vbWApXHJcblx0XHR6b29tUmV2ZXJzZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBkZXRlY3RSZXRpbmE6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgIGFuZCB1c2VyIGlzIG9uIGEgcmV0aW5hIGRpc3BsYXksIGl0IHdpbGwgcmVxdWVzdCBmb3VyIHRpbGVzIG9mIGhhbGYgdGhlIHNwZWNpZmllZCBzaXplIGFuZCBhIGJpZ2dlciB6b29tIGxldmVsIGluIHBsYWNlIG9mIG9uZSB0byB1dGlsaXplIHRoZSBoaWdoIHJlc29sdXRpb24uXHJcblx0XHRkZXRlY3RSZXRpbmE6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdG9wdGlvbnMgPSBVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Ly8gZGV0ZWN0aW5nIHJldGluYSBkaXNwbGF5cywgYWRqdXN0aW5nIHRpbGVTaXplIGFuZCB6b29tIGxldmVsc1xyXG5cdFx0aWYgKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEJyb3dzZXIucmV0aW5hICYmIG9wdGlvbnMubWF4Wm9vbSA+IDApIHtcclxuXHJcblx0XHRcdG9wdGlvbnMudGlsZVNpemUgPSBNYXRoLmZsb29yKG9wdGlvbnMudGlsZVNpemUgLyAyKTtcclxuXHJcblx0XHRcdGlmICghb3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldCsrO1xyXG5cdFx0XHRcdG9wdGlvbnMubWF4Wm9vbS0tO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldC0tO1xyXG5cdFx0XHRcdG9wdGlvbnMubWluWm9vbSsrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5zdWJkb21haW5zID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRvcHRpb25zLnN1YmRvbWFpbnMgPSBvcHRpb25zLnN1YmRvbWFpbnMuc3BsaXQoJycpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xMzdcclxuXHRcdGlmICghQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdHRoaXMub24oJ3RpbGV1bmxvYWQnLCB0aGlzLl9vblRpbGVSZW1vdmUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nLCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gVXBkYXRlcyB0aGUgbGF5ZXIncyBVUkwgdGVtcGxhdGUgYW5kIHJlZHJhd3MgaXQgKHVubGVzcyBgbm9SZWRyYXdgIGlzIHNldCB0byBgdHJ1ZWApLlxyXG5cdC8vIElmIHRoZSBVUkwgZG9lcyBub3QgY2hhbmdlLCB0aGUgbGF5ZXIgd2lsbCBub3QgYmUgcmVkcmF3biB1bmxlc3NcclxuXHQvLyB0aGUgbm9SZWRyYXcgcGFyYW1ldGVyIGlzIHNldCB0byBmYWxzZS5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwsIG5vUmVkcmF3KSB7XHJcblx0XHRpZiAodGhpcy5fdXJsID09PSB1cmwgJiYgbm9SZWRyYXcgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRub1JlZHJhdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBvdmVycmlkZXMgR3JpZExheWVyJ3MgW2BjcmVhdGVUaWxlKClgXSgjZ3JpZGxheWVyLWNyZWF0ZXRpbGUpXHJcblx0Ly8gdG8gcmV0dXJuIGFuIGA8aW1nPmAgSFRNTCBlbGVtZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIGltYWdlIFVSTCBnaXZlbiBgY29vcmRzYC4gVGhlIGBkb25lYFxyXG5cdC8vIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBiZWVuIGxvYWRlZC5cclxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBkb25lKSB7XHJcblx0XHR2YXIgdGlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKHRpbGUsICdsb2FkJywgVXRpbC5iaW5kKHRoaXMuX3RpbGVPbkxvYWQsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHRcdERvbUV2ZW50Lm9uKHRpbGUsICdlcnJvcicsIFV0aWwuYmluZCh0aGlzLl90aWxlT25FcnJvciwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG5cdFx0XHR0aWxlLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcblx0XHR9XHJcblxyXG5cdFx0LypcclxuXHRcdCBBbHQgdGFnIGlzIHNldCB0byBlbXB0eSBzdHJpbmcgdG8ga2VlcCBzY3JlZW4gcmVhZGVycyBmcm9tIHJlYWRpbmcgVVJMIGFuZCBmb3IgY29tcGxpYW5jZSByZWFzb25zXHJcblx0XHQgaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0g2N1xyXG5cdFx0Ki9cclxuXHRcdHRpbGUuYWx0ID0gJyc7XHJcblxyXG5cdFx0LypcclxuXHRcdCBTZXQgcm9sZT1cInByZXNlbnRhdGlvblwiIHRvIGZvcmNlIHNjcmVlbiByZWFkZXJzIHRvIGlnbm9yZSB0aGlzXHJcblx0XHQgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhL3JvbGVzI3RleHRhbHRlcm5hdGl2ZWNvbXB1dGF0aW9uXHJcblx0XHQqL1xyXG5cdFx0dGlsZS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XHJcblxyXG5cdFx0dGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGlsZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG5cdC8vIEB1bmluaGVyaXRhYmxlXHJcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBtaWdodCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cclxuXHQvLyBAbWV0aG9kIGdldFRpbGVVcmwoY29vcmRzOiBPYmplY3QpOiBTdHJpbmdcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCByZXR1cm5zIHRoZSBVUkwgZm9yIGEgdGlsZSBnaXZlbiBpdHMgY29vcmRpbmF0ZXMuXHJcblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYFRpbGVMYXllcmAgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gcHJvdmlkZSBjdXN0b20gdGlsZSBVUkwgbmFtaW5nIHNjaGVtZXMuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdHI6IEJyb3dzZXIucmV0aW5hID8gJ0AyeCcgOiAnJyxcclxuXHRcdFx0czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXHJcblx0XHRcdHg6IGNvb3Jkcy54LFxyXG5cdFx0XHR5OiBjb29yZHMueSxcclxuXHRcdFx0ejogdGhpcy5fZ2V0Wm9vbUZvclVybCgpXHJcblx0XHR9O1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLm9wdGlvbnMuY3JzLmluZmluaXRlKSB7XHJcblx0XHRcdHZhciBpbnZlcnRlZFkgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2UubWF4LnkgLSBjb29yZHMueTtcclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy50bXMpIHtcclxuXHRcdFx0XHRkYXRhWyd5J10gPSBpbnZlcnRlZFk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0YVsnLXknXSA9IGludmVydGVkWTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gVXRpbC50ZW1wbGF0ZSh0aGlzLl91cmwsIFV0aWwuZXh0ZW5kKGRhdGEsIHRoaXMub3B0aW9ucykpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSkge1xyXG5cdFx0Ly8gRm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzMzMzJcclxuXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7XHJcblx0XHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKGRvbmUsIHRoaXMsIG51bGwsIHRpbGUpLCAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRvbmUobnVsbCwgdGlsZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkVycm9yOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSwgZSkge1xyXG5cdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yVGlsZVVybDtcclxuXHRcdGlmIChlcnJvclVybCAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgIT09IGVycm9yVXJsKSB7XHJcblx0XHRcdHRpbGUuc3JjID0gZXJyb3JVcmw7XHJcblx0XHR9XHJcblx0XHRkb25lKGUsIHRpbGUpO1xyXG5cdH0sXHJcblxyXG5cdF9vblRpbGVSZW1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRlLnRpbGUub25sb2FkID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbUZvclVybDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcclxuXHRcdG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbSxcclxuXHRcdHpvb21SZXZlcnNlID0gdGhpcy5vcHRpb25zLnpvb21SZXZlcnNlLFxyXG5cdFx0em9vbU9mZnNldCA9IHRoaXMub3B0aW9ucy56b29tT2Zmc2V0O1xyXG5cclxuXHRcdGlmICh6b29tUmV2ZXJzZSkge1xyXG5cdFx0XHR6b29tID0gbWF4Wm9vbSAtIHpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHpvb20gKyB6b29tT2Zmc2V0O1xyXG5cdH0sXHJcblxyXG5cdF9nZXRTdWJkb21haW46IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHRcdHZhciBpbmRleCA9IE1hdGguYWJzKHRpbGVQb2ludC54ICsgdGlsZVBvaW50LnkpICUgdGhpcy5vcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zdWJkb21haW5zW2luZGV4XTtcclxuXHR9LFxyXG5cclxuXHQvLyBzdG9wcyBsb2FkaW5nIGFsbCB0aWxlcyBpbiB0aGUgYmFja2dyb3VuZCBsYXllclxyXG5cdF9hYm9ydExvYWRpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpLCB0aWxlO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX3RpbGVzKSB7XHJcblx0XHRcdGlmICh0aGlzLl90aWxlc1tpXS5jb29yZHMueiAhPT0gdGhpcy5fdGlsZVpvb20pIHtcclxuXHRcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNbaV0uZWw7XHJcblxyXG5cdFx0XHRcdHRpbGUub25sb2FkID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0XHRcdHRpbGUub25lcnJvciA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0aWYgKCF0aWxlLmNvbXBsZXRlKSB7XHJcblx0XHRcdFx0XHR0aWxlLnNyYyA9IFV0aWwuZW1wdHlJbWFnZVVybDtcclxuXHRcdFx0XHRcdERvbVV0aWwucmVtb3ZlKHRpbGUpO1xyXG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2ldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XHJcblx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XHJcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gQ2FuY2VscyBhbnkgcGVuZGluZyBodHRwIHJlcXVlc3RzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdGlsZVxyXG5cdFx0Ly8gdW5sZXNzIHdlJ3JlIG9uIEFuZHJvaWQncyBzdG9jayBicm93c2VyLFxyXG5cdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xyXG5cdFx0aWYgKCFCcm93c2VyLmFuZHJvaWRTdG9jaykge1xyXG5cdFx0XHR0aWxlLmVsLnNldEF0dHJpYnV0ZSgnc3JjJywgVXRpbC5lbXB0eUltYWdlVXJsKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gR3JpZExheWVyLnByb3RvdHlwZS5fcmVtb3ZlVGlsZS5jYWxsKHRoaXMsIGtleSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCB8fCAodGlsZSAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgPT09IFV0aWwuZW1wdHlJbWFnZVVybCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl90aWxlUmVhZHkuY2FsbCh0aGlzLCBjb29yZHMsIGVyciwgdGlsZSk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYFVSTCB0ZW1wbGF0ZWAgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGlsZUxheWVyKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtUaWxlTGF5ZXJ9IGZyb20gJy4vVGlsZUxheWVyJztcclxuaW1wb3J0IHtleHRlbmQsIHNldE9wdGlvbnMsIGdldFBhcmFtU3RyaW5nfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3JldGluYX0gZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHtFUFNHNDMyNn0gZnJvbSAnLi4vLi4vZ2VvL2Nycy9DUlMuRVBTRzQzMjYnO1xyXG5pbXBvcnQge3RvQm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFRpbGVMYXllci5XTVNcclxuICogQGluaGVyaXRzIFRpbGVMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyLldNU1xyXG4gKiBVc2VkIHRvIGRpc3BsYXkgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcyBhcyB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBUaWxlTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbmV4cmFkID0gTC50aWxlTGF5ZXIud21zKFwiaHR0cDovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci5jZ2lcIiwge1xyXG4gKiBcdGxheWVyczogJ25leHJhZC1uMHItOTAwOTEzJyxcclxuICogXHRmb3JtYXQ6ICdpbWFnZS9wbmcnLFxyXG4gKiBcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gKiBcdGF0dHJpYnV0aW9uOiBcIldlYXRoZXIgZGF0YSDCqSAyMDEyIElFTSBOZXhyYWRcIlxyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBUaWxlTGF5ZXJXTVMgPSBUaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllci5XTVMgb3B0aW9uc1xyXG5cdC8vIElmIGFueSBjdXN0b20gb3B0aW9ucyBub3QgZG9jdW1lbnRlZCBoZXJlIGFyZSB1c2VkLCB0aGV5IHdpbGwgYmUgc2VudCB0byB0aGVcclxuXHQvLyBXTVMgc2VydmVyIGFzIGV4dHJhIHBhcmFtZXRlcnMgaW4gZWFjaCByZXF1ZXN0IFVSTC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxyXG5cdC8vIFtub24tc3RhbmRhcmQgdmVuZG9yIFdNUyBwYXJhbWV0ZXJzXShodHRwOi8vZG9jcy5nZW9zZXJ2ZXIub3JnL3N0YWJsZS9lbi91c2VyL3NlcnZpY2VzL3dtcy92ZW5kb3IuaHRtbCkuXHJcblx0ZGVmYXVsdFdtc1BhcmFtczoge1xyXG5cdFx0c2VydmljZTogJ1dNUycsXHJcblx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogU3RyaW5nID0gJydcclxuXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuXHRcdGxheWVyczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdHlsZXM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG5cdFx0c3R5bGVzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZvcm1hdDogU3RyaW5nID0gJ2ltYWdlL2pwZWcnXHJcblx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuXHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNwYXJlbnQ6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG5cdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdmVyc2lvbjogU3RyaW5nID0gJzEuMS4xJ1xyXG5cdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcblx0XHR2ZXJzaW9uOiAnMS4xLjEnXHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IG51bGxcclxuXHRcdC8vIENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbSB0byB1c2UgZm9yIHRoZSBXTVMgcmVxdWVzdHMsIGRlZmF1bHRzIHRvXHJcblx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHVwcGVyY2FzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG5cdFx0dXBwZXJjYXNlOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHdtc1BhcmFtcyA9IGV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtcclxuXHJcblx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdGlmICghKGkgaW4gdGhpcy5vcHRpb25zKSkge1xyXG5cdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgcmVhbFJldGluYSA9IG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIHJldGluYSA/IDIgOiAxO1xyXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xyXG5cdFx0d21zUGFyYW1zLndpZHRoID0gdGlsZVNpemUueCAqIHJlYWxSZXRpbmE7XHJcblx0XHR3bXNQYXJhbXMuaGVpZ2h0ID0gdGlsZVNpemUueSAqIHJlYWxSZXRpbmE7XHJcblxyXG5cdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHJcblx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuXHRcdHRoaXMuX3dtc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHRoaXMud21zUGFyYW1zLnZlcnNpb24pO1xyXG5cclxuXHRcdHZhciBwcm9qZWN0aW9uS2V5ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xyXG5cdFx0dGhpcy53bXNQYXJhbXNbcHJvamVjdGlvbktleV0gPSB0aGlzLl9jcnMuY29kZTtcclxuXHJcblx0XHRUaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblxyXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXHJcblx0XHQgICAgY3JzID0gdGhpcy5fY3JzLFxyXG5cdFx0ICAgIGJvdW5kcyA9IHRvQm91bmRzKGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMF0pLCBjcnMucHJvamVjdCh0aWxlQm91bmRzWzFdKSksXHJcblx0XHQgICAgbWluID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIGJib3ggPSAodGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBFUFNHNDMyNiA/XHJcblx0XHQgICAgW21pbi55LCBtaW4ueCwgbWF4LnksIG1heC54XSA6XHJcblx0XHQgICAgW21pbi54LCBtaW4ueSwgbWF4LngsIG1heC55XSkuam9pbignLCcpLFxyXG5cdFx0ICAgIHVybCA9IFRpbGVMYXllci5wcm90b3R5cGUuZ2V0VGlsZVVybC5jYWxsKHRoaXMsIGNvb3Jkcyk7XHJcblx0XHRyZXR1cm4gdXJsICtcclxuXHRcdFx0Z2V0UGFyYW1TdHJpbmcodGhpcy53bXNQYXJhbXMsIHVybCwgdGhpcy5vcHRpb25zLnVwcGVyY2FzZSkgK1xyXG5cdFx0XHQodGhpcy5vcHRpb25zLnVwcGVyY2FzZSA/ICcmQkJPWD0nIDogJyZiYm94PScpICsgYmJveDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBhcmFtcyhwYXJhbXM6IE9iamVjdCwgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIE1lcmdlcyBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IHBhcmFtZXRlcnMgYW5kIHJlLXJlcXVlc3RzIHRpbGVzIG9uIHRoZSBjdXJyZW50IHNjcmVlbiAodW5sZXNzIGBub1JlZHJhd2Agd2FzIHNldCB0byB0cnVlKS5cclxuXHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChwYXJhbXMsIG5vUmVkcmF3KSB7XHJcblxyXG5cdFx0ZXh0ZW5kKHRoaXMud21zUGFyYW1zLCBwYXJhbXMpO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZUxheWVyLndtcyhiYXNlVXJsOiBTdHJpbmcsIG9wdGlvbnM6IFRpbGVMYXllci5XTVMgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgV01TIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYmFzZSBVUkwgb2YgdGhlIFdNUyBzZXJ2aWNlIGFuZCBhIFdNUyBwYXJhbWV0ZXJzL29wdGlvbnMgb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gdGlsZUxheWVyV01TKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVGlsZUxheWVyV01TKHVybCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiZXhwb3J0IHtHcmlkTGF5ZXIsIGdyaWRMYXllcn0gZnJvbSAnLi9HcmlkTGF5ZXInO1xuaW1wb3J0IHtUaWxlTGF5ZXIsIHRpbGVMYXllcn0gZnJvbSAnLi9UaWxlTGF5ZXInO1xuaW1wb3J0IHtUaWxlTGF5ZXJXTVMsIHRpbGVMYXllcldNU30gZnJvbSAnLi9UaWxlTGF5ZXIuV01TJztcblRpbGVMYXllci5XTVMgPSBUaWxlTGF5ZXJXTVM7XG50aWxlTGF5ZXIud21zID0gdGlsZUxheWVyV01TO1xuZXhwb3J0IHtUaWxlTGF5ZXIsIHRpbGVMYXllcn07XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG5cblxuLypcbiAqIEBjbGFzcyBSZW5kZXJlclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuUmVuZGVyZXJcbiAqXG4gKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICogRE9NIGNvbnRhaW5lciBvZiB0aGUgcmVuZGVyZXIsIGl0cyBib3VuZHMsIGFuZCBpdHMgem9vbSBhbmltYXRpb24uXG4gKlxuICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICogaXRzZWxmIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkIHRvIHRoZSBtYXAuIEFsbCBwYXRocyB1c2UgYSByZW5kZXJlciwgd2hpY2ggY2FuXG4gKiBiZSBpbXBsaWNpdCAodGhlIG1hcCB3aWxsIGRlY2lkZSB0aGUgdHlwZSBvZiByZW5kZXJlciBhbmQgdXNlIGl0IGF1dG9tYXRpY2FsbHkpXG4gKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAqXG4gKiBEbyBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBgU1ZHYCBhbmQgYENhbnZhc2AgaW5zdGVhZC5cbiAqXG4gKiBAZXZlbnQgdXBkYXRlOiBFdmVudFxuICogRmlyZWQgd2hlbiB0aGUgcmVuZGVyZXIgdXBkYXRlcyBpdHMgYm91bmRzLCBjZW50ZXIgYW5kIHpvb20sIGZvciBleGFtcGxlIHdoZW5cbiAqIGl0cyBtYXAgaGFzIG1vdmVkXG4gKi9cblxuZXhwb3J0IHZhciBSZW5kZXJlciA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBSZW5kZXJlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhZGRpbmc6IE51bWJlciA9IDAuMVxuXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpcCBhcmVhIGFyb3VuZCB0aGUgbWFwIHZpZXcgKHJlbGF0aXZlIHRvIGl0cyBzaXplKVxuXHRcdC8vIGUuZy4gMC4xIHdvdWxkIGJlIDEwJSBvZiBtYXAgdmlldyBpbiBlYWNoIGRpcmVjdGlvblxuXHRcdHBhZGRpbmc6IDAuMSxcblxuXHRcdC8vIEBvcHRpb24gdG9sZXJhbmNlOiBOdW1iZXIgPSAwXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIGNsaWNrIHRvbGVyYW5jZSByb3VuZCBhIHBhdGgvb2JqZWN0IG9uIHRoZSBtYXBcblx0XHR0b2xlcmFuY2UgOiAwXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0VXRpbC5zdGFtcCh0aGlzKTtcblx0XHR0aGlzLl9sYXllcnMgPSB0aGlzLl9sYXllcnMgfHwge307XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0dGhpcy5faW5pdENvbnRhaW5lcigpOyAvLyBkZWZpbmVkIGJ5IHJlbmRlcmVyIGltcGxlbWVudGF0aW9uc1xuXG5cdFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR0aGlzLm9uKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLm9mZigndXBkYXRlJywgdGhpcy5fdXBkYXRlUGF0aHMsIHRoaXMpO1xuXHRcdHRoaXMuX2Rlc3Ryb3lDb250YWluZXIoKTtcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcblx0XHRcdHpvb206IHRoaXMuX29uWm9vbSxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZSxcblx0XHRcdHpvb21lbmQ6IHRoaXMuX29uWm9vbUVuZFxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcblx0XHR9XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25BbmltWm9vbTogZnVuY3Rpb24gKGV2KSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKGV2LmNlbnRlciwgZXYuem9vbSk7XG5cdH0sXG5cblx0X29uWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHR9LFxuXG5cdF91cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIHRoaXMuX3pvb20pLFxuXHRcdCAgICBwb3NpdGlvbiA9IERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSxcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkoMC41ICsgdGhpcy5vcHRpb25zLnBhZGRpbmcpLFxuXHRcdCAgICBjdXJyZW50Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9jZW50ZXIsIHpvb20pLFxuXHRcdCAgICBkZXN0Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdChjZW50ZXIsIHpvb20pLFxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBkZXN0Q2VudGVyUG9pbnQuc3VidHJhY3QoY3VycmVudENlbnRlclBvaW50KSxcblxuXHRcdCAgICB0b3BMZWZ0T2Zmc2V0ID0gdmlld0hhbGYubXVsdGlwbHlCeSgtc2NhbGUpLmFkZChwb3NpdGlvbikuYWRkKHZpZXdIYWxmKS5zdWJ0cmFjdChjZW50ZXJPZmZzZXQpO1xuXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20pO1xuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9yZXNldCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9wcm9qZWN0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fdXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBVcGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcblx0XHQvLyBTdWJjbGFzc2VzIGFyZSByZXNwb25zaWJsZSBvZiBmaXJpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuXHRcdHZhciBwID0gdGhpcy5vcHRpb25zLnBhZGRpbmcsXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMobWluLCBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpKS5yb3VuZCgpKTtcblxuXHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcblx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG4vKlxuICogQGNsYXNzIENhbnZhc1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuQ2FudmFzXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPWNhbnZhcyksIENhbnZhcyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IElFOCwgYW5kIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMgbWlnaHRcbiAqIG5vdCBkaXNwbGF5IHByb3Blcmx5IGluIHNvbWUgZWRnZSBjYXNlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBDYW52YXMgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5jYW52YXMoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5jYW52YXMoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgQ2FudmFzID0gUmVuZGVyZXIuZXh0ZW5kKHtcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMudmlld3ByZXJlc2V0ID0gdGhpcy5fb25WaWV3UHJlUmVzZXQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25WaWV3UHJlUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBTZXQgYSBmbGFnIHNvIHRoYXQgYSB2aWV3cHJlcmVzZXQrbW92ZWVuZCt2aWV3cmVzZXQgb25seSB1cGRhdGVzJnJlZHJhd3Mgb25jZVxuXHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSB0cnVlO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcyk7XG5cblx0XHQvLyBSZWRyYXcgdmVjdG9ycyBzaW5jZSBjYW52YXMgaXMgY2xlYXJlZCB1cG9uIHJlbW92YWwsXG5cdFx0Ly8gaW4gY2FzZSBvZiByZW1vdmluZyB0aGUgcmVuZGVyZXIgaXRzZWxmIGZyb20gdGhlIG1hcC5cblx0XHR0aGlzLl9kcmF3KCk7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnUnLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW91dCcsIHRoaXMuX2hhbmRsZU1vdXNlT3V0LCB0aGlzKTtcblxuXHRcdHRoaXMuX2N0eCA9IGNvbnRhaW5lci5nZXRDb250ZXh0KCcyZCcpO1xuXHR9LFxuXG5cdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVkcmF3UmVxdWVzdCk7XG5cdFx0ZGVsZXRlIHRoaXMuX2N0eDtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbGF5ZXI7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHR9XG5cdFx0dGhpcy5fcmVkcmF3KCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHQgICAgbSA9IEJyb3dzZXIucmV0aW5hID8gMiA6IDE7XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG5cdFx0Ly8gc2V0IGNhbnZhcyBzaXplIChhbHNvIGNsZWFyaW5nIGl0KTsgdXNlIGRvdWJsZSBzaXplIG9uIHJldGluYVxuXHRcdGNvbnRhaW5lci53aWR0aCA9IG0gKiBzaXplLng7XG5cdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG5cdFx0Y29udGFpbmVyLnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4Jztcblx0XHRjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcblxuXHRcdGlmIChCcm93c2VyLnJldGluYSkge1xuXHRcdFx0dGhpcy5fY3R4LnNjYWxlKDIsIDIpO1xuXHRcdH1cblxuXHRcdC8vIHRyYW5zbGF0ZSBzbyB3ZSB1c2UgdGhlIHNhbWUgcGF0aCBjb29yZGluYXRlcyBhZnRlciBjYW52YXMgZWxlbWVudCBtb3Zlc1xuXHRcdHRoaXMuX2N0eC50cmFuc2xhdGUoLWIubWluLngsIC1iLm1pbi55KTtcblxuXHRcdC8vIFRlbGwgcGF0aHMgdG8gcmVkcmF3IHRoZW1zZWx2ZXNcblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fcmVzZXQuY2FsbCh0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7XG5cdFx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gZmFsc2U7XG5cdFx0XHR0aGlzLl91cGRhdGVQYXRocygpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyID0ge1xuXHRcdFx0bGF5ZXI6IGxheWVyLFxuXHRcdFx0cHJldjogdGhpcy5fZHJhd0xhc3QsXG5cdFx0XHRuZXh0OiBudWxsXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fZHJhd0xhc3QpIHsgdGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyOyB9XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblx0XHR0aGlzLl9kcmF3Rmlyc3QgPSB0aGlzLl9kcmF3Rmlyc3QgfHwgdGhpcy5fZHJhd0xhc3Q7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBuZXh0O1xuXHRcdH1cblxuXHRcdGRlbGV0ZSBsYXllci5fb3JkZXI7XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXTtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHQvLyBSZWRyYXcgdGhlIHVuaW9uIG9mIHRoZSBsYXllcidzIG9sZCBwaXhlbFxuXHRcdC8vIGJvdW5kcyBhbmQgdGhlIG5ldyBwaXhlbCBib3VuZHMuXG5cdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHQvLyBUaGUgcmVkcmF3IHdpbGwgZXh0ZW5kIHRoZSByZWRyYXcgYm91bmRzXG5cdFx0Ly8gd2l0aCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZURhc2hBcnJheTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKHR5cGVvZiBsYXllci5vcHRpb25zLmRhc2hBcnJheSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhciBwYXJ0cyA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5LnNwbGl0KC9bLCBdKy8pLFxuXHRcdFx0ICAgIGRhc2hBcnJheSA9IFtdLFxuXHRcdFx0ICAgIGRhc2hWYWx1ZSxcblx0XHRcdCAgICBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRhc2hWYWx1ZSA9IE51bWJlcihwYXJ0c1tpXSk7XG5cdFx0XHRcdC8vIElnbm9yZSBkYXNoIGFycmF5IGNvbnRhaW5pbmcgaW52YWxpZCBsZW5ndGhzXG5cdFx0XHRcdGlmIChpc05hTihkYXNoVmFsdWUpKSB7IHJldHVybjsgfVxuXHRcdFx0XHRkYXNoQXJyYXkucHVzaChkYXNoVmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheTtcblx0XHR9XG5cdH0sXG5cblx0X3JlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcblx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gdGhpcy5fcmVkcmF3UmVxdWVzdCB8fCBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcmVkcmF3LCB0aGlzKTtcblx0fSxcblxuXHRfZXh0ZW5kUmVkcmF3Qm91bmRzOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAobGF5ZXIuX3B4Qm91bmRzKSB7XG5cdFx0XHR2YXIgcGFkZGluZyA9IChsYXllci5vcHRpb25zLndlaWdodCB8fCAwKSArIDE7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHMgfHwgbmV3IEJvdW5kcygpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWluLnN1YnRyYWN0KFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWF4LmFkZChbcGFkZGluZywgcGFkZGluZ10pKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSBudWxsO1xuXG5cdFx0aWYgKHRoaXMuX3JlZHJhd0JvdW5kcykge1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1pbi5fZmxvb3IoKTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5tYXguX2NlaWwoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9jbGVhcigpOyAvLyBjbGVhciBsYXllcnMgaW4gcmVkcmF3IGJvdW5kc1xuXHRcdHRoaXMuX2RyYXcoKTsgLy8gZHJhdyBsYXllcnNcblxuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdH0sXG5cblx0X2NsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY29udGFpbmVyLndpZHRoLCB0aGlzLl9jb250YWluZXIuaGVpZ2h0KTtcblx0XHR9XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbGF5ZXIsIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcblx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcblx0XHRcdHRoaXMuX2N0eC5yZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG5cdFx0XHR0aGlzLl9jdHguY2xpcCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYXdpbmcgPSB0cnVlO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAoIWJvdW5kcyB8fCAobGF5ZXIuX3B4Qm91bmRzICYmIGxheWVyLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpKSB7XG5cdFx0XHRcdGxheWVyLl91cGRhdGVQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTsgIC8vIFJlc3RvcmUgc3RhdGUgYmVmb3JlIGNsaXBwaW5nLlxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXHRcdGlmICghdGhpcy5fZHJhd2luZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBpLCBqLCBsZW4yLCBwLFxuXHRcdCAgICBwYXJ0cyA9IGxheWVyLl9wYXJ0cyxcblx0XHQgICAgbGVuID0gcGFydHMubGVuZ3RoLFxuXHRcdCAgICBjdHggPSB0aGlzLl9jdHg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm47IH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnRzW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0XHRwID0gcGFydHNbaV1bal07XG5cdFx0XHRcdGN0eFtqID8gJ2xpbmVUbycgOiAnbW92ZVRvJ10ocC54LCBwLnkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblxuXHRcdC8vIFRPRE8gb3B0aW1pemF0aW9uOiAxIGZpbGwvc3Ryb2tlIGZvciBhbGwgZmVhdHVyZXMgd2l0aCBlcXVhbCBzdHlsZSBpbnN0ZWFkIG9mIDEgZm9yIGVhY2ggZmVhdHVyZVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nIHx8IGxheWVyLl9lbXB0eSgpKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eCxcblx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuXHRcdCAgICBzID0gKE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByKSAvIHI7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zY2FsZSgxLCBzKTtcblx0XHR9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyhwLngsIHAueSAvIHMsIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXHR9LFxuXG5cdF9maWxsU3Ryb2tlOiBmdW5jdGlvbiAoY3R4LCBsYXllcikge1xuXHRcdHZhciBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5maWxsKG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy53ZWlnaHQgIT09IDApIHtcblx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxheWVyLm9wdGlvbnMgJiYgbGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5IHx8IFtdKTtcblx0XHRcdH1cblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMub3BhY2l0eTtcblx0XHRcdGN0eC5saW5lV2lkdGggPSBvcHRpb25zLndlaWdodDtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRjdHgubGluZUNhcCA9IG9wdGlvbnMubGluZUNhcDtcblx0XHRcdGN0eC5saW5lSm9pbiA9IG9wdGlvbnMubGluZUpvaW47XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENhbnZhcyBvYnZpb3VzbHkgZG9lc24ndCBoYXZlIG1vdXNlIGV2ZW50cyBmb3IgaW5kaXZpZHVhbCBkcmF3biBvYmplY3RzLFxuXHQvLyBzbyB3ZSBlbXVsYXRlIHRoYXQgYnkgY2FsY3VsYXRpbmcgd2hhdCdzIHVuZGVyIHRoZSBtb3VzZSBvbiBtb3VzZW1vdmUvY2xpY2sgbWFudWFsbHlcblxuXHRfb25DbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSwgbGF5ZXIsIGNsaWNrZWRMYXllcjtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpICYmICF0aGlzLl9tYXAuX2RyYWdnYWJsZU1vdmVkKGxheWVyKSkge1xuXHRcdFx0XHRjbGlja2VkTGF5ZXIgPSBsYXllcjtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNsaWNrZWRMYXllcikgIHtcblx0XHRcdERvbUV2ZW50LmZha2VTdG9wKGUpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtjbGlja2VkTGF5ZXJdLCBlKTtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZpbmcoKSB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKTtcblx0XHR0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKGUsIHBvaW50KTtcblx0fSxcblxuXG5cdF9oYW5kbGVNb3VzZU91dDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9ob3ZlcmVkTGF5ZXI7XG5cdFx0aWYgKGxheWVyKSB7XG5cdFx0XHQvLyBpZiB3ZSdyZSBsZWF2aW5nIHRoZSBsYXllciwgZmlyZSBtb3VzZW91dFxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW2xheWVyXSwgZSwgJ21vdXNlb3V0Jyk7XG5cdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBudWxsO1xuXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlTW91c2VIb3ZlcjogZnVuY3Rpb24gKGUsIHBvaW50KSB7XG5cdFx0aWYgKHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbGF5ZXIsIGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG5cdFx0XHRcdGNhbmRpZGF0ZUhvdmVyZWRMYXllciA9IGxheWVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIgIT09IHRoaXMuX2hvdmVyZWRMYXllcikge1xuXHRcdFx0dGhpcy5faGFuZGxlTW91c2VPdXQoZSk7XG5cblx0XHRcdGlmIChjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIpIHtcblx0XHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7IC8vIGNoYW5nZSBjdXJzb3Jcblx0XHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtjYW5kaWRhdGVIb3ZlcmVkTGF5ZXJdLCBlLCAnbW91c2VvdmVyJyk7XG5cdFx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW3RoaXMuX2hvdmVyZWRMYXllcl0sIGUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSB0cnVlO1xuXHRcdHNldFRpbWVvdXQoTC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcblx0XHR9LCB0aGlzKSwgMzIpO1xuXHR9LFxuXG5cdF9maXJlRXZlbnQ6IGZ1bmN0aW9uIChsYXllcnMsIGUsIHR5cGUpIHtcblx0XHR0aGlzLl9tYXAuX2ZpcmVET01FdmVudChlLCB0eXBlIHx8IGUudHlwZSwgbGF5ZXJzKTtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cblx0XHRpZiAoIW9yZGVyKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBBbHJlYWR5IGxhc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIGlmIChuZXh0KSB7XG5cdFx0XHQvLyBVcGRhdGUgZmlyc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG5cdFx0XHQvLyBzaW5nbGUgZW50cnlcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IHRoaXMuX2RyYXdMYXN0O1xuXHRcdHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjtcblxuXHRcdG9yZGVyLm5leHQgPSBudWxsO1xuXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgZmlyc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIGlmIChwcmV2KSB7XG5cdFx0XHQvLyBVcGRhdGUgbGFzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuXHRcdH1cblxuXHRcdG9yZGVyLnByZXYgPSBudWxsO1xuXG5cdFx0b3JkZXIubmV4dCA9IHRoaXMuX2RyYXdGaXJzdDtcblx0XHR0aGlzLl9kcmF3Rmlyc3QucHJldiA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IG9yZGVyO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNhbnZhcyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBjYW52YXMob3B0aW9ucykge1xuXHRyZXR1cm4gQnJvd3Nlci5jYW52YXMgPyBuZXcgQ2FudmFzKG9wdGlvbnMpIDogbnVsbDtcbn1cbiIsImltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5cbi8qXG4gKiBUaGFua3MgdG8gRG1pdHJ5IEJhcmFub3Zza3kgYW5kIGhpcyBSYXBoYWVsIGxpYnJhcnkgZm9yIGluc3BpcmF0aW9uIVxuICovXG5cblxuZXhwb3J0IHZhciB2bWxDcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuXHR0cnkge1xuXHRcdGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKCdsdm1sJywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGx2bWw6JyArIG5hbWUgKyAnIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdH07XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8JyArIG5hbWUgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cImx2bWxcIj4nKTtcblx0XHR9O1xuXHR9XG59KSgpO1xuXG5cbi8qXG4gKiBAY2xhc3MgU1ZHXG4gKlxuICpcbiAqIFZNTCB3YXMgZGVwcmVjYXRlZCBpbiAyMDEyLCB3aGljaCBtZWFucyBWTUwgZnVuY3Rpb25hbGl0eSBleGlzdHMgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqIHdpdGggb2xkIHZlcnNpb25zIG9mIEludGVybmV0IEV4cGxvcmVyLlxuICovXG5cbi8vIG1peGluIHRvIHJlZGVmaW5lIHNvbWUgU1ZHIG1ldGhvZHMgdG8gaGFuZGxlIFZNTCBzeW50YXggd2hpY2ggaXMgc2ltaWxhciBidXQgd2l0aCBzb21lIGRpZmZlcmVuY2VzXG5leHBvcnQgdmFyIHZtbE1peGluID0ge1xuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXZtbC1jb250YWluZXInKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lciA9IHZtbENyZWF0ZSgnc2hhcGUnKTtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC12bWwtc2hhcGUgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cblx0XHRjb250YWluZXIuY29vcmRzaXplID0gJzEgMSc7XG5cblx0XHRsYXllci5fcGF0aCA9IHZtbENyZWF0ZSgncGF0aCcpO1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0RG9tVXRpbC5yZW1vdmUoY29udGFpbmVyKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHN0cm9rZSA9IGxheWVyLl9zdHJva2UsXG5cdFx0ICAgIGZpbGwgPSBsYXllci5fZmlsbCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cblx0XHRjb250YWluZXIuc3Ryb2tlZCA9ICEhb3B0aW9ucy5zdHJva2U7XG5cdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRpZiAoIXN0cm9rZSkge1xuXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gdm1sQ3JlYXRlKCdzdHJva2UnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHJva2UpO1xuXHRcdFx0c3Ryb2tlLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0ICsgJ3B4Jztcblx0XHRcdHN0cm9rZS5jb2xvciA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRzdHJva2Uub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSBVdGlsLmlzQXJyYXkob3B0aW9ucy5kYXNoQXJyYXkpID9cblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LmpvaW4oJyAnKSA6XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5yZXBsYWNlKC8oICosICopL2csICcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gJyc7XG5cdFx0XHR9XG5cdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xuXHRcdFx0c3Ryb2tlLmpvaW5zdHlsZSA9IG9wdGlvbnMubGluZUpvaW47XG5cblx0XHR9IGVsc2UgaWYgKHN0cm9rZSkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKHN0cm9rZSk7XG5cdFx0XHRsYXllci5fc3Ryb2tlID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRpZiAoIWZpbGwpIHtcblx0XHRcdFx0ZmlsbCA9IGxheWVyLl9maWxsID0gdm1sQ3JlYXRlKCdmaWxsJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsbCk7XG5cdFx0XHRmaWxsLmNvbG9yID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGZpbGwub3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cblx0XHR9IGVsc2UgaWYgKGZpbGwpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChmaWxsKTtcblx0XHRcdGxheWVyLl9maWxsID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQucm91bmQoKSxcblx0XHQgICAgciA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksXG5cdFx0ICAgIHIyID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSB8fCByKTtcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdCdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgciArICcsJyArIHIyICsgJyAwLCcgKyAoNjU1MzUgKiAzNjApKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGgudiA9IHBhdGg7XG5cdH0sXG5cblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0Zyb250KGxheWVyLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0JhY2sobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH1cbn07XG4iLCJpbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7c3RhbXB9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3N2Z0NyZWF0ZSwgcG9pbnRzVG9QYXRofSBmcm9tICcuL1NWRy5VdGlsJztcbmV4cG9ydCB7cG9pbnRzVG9QYXRofTtcbmltcG9ydCB7dm1sTWl4aW4sIHZtbENyZWF0ZX0gZnJvbSAnLi9TVkcuVk1MJztcblxuZXhwb3J0IHZhciBjcmVhdGUgPSBCcm93c2VyLnZtbCA/IHZtbENyZWF0ZSA6IHN2Z0NyZWF0ZTtcblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLlNWR1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zdmcpLCBTVkcgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBBbmRyb2lkIDIueCBhbmQgMy54LlxuICpcbiAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0XG4gKiBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKVxuICogKGEgbm93IGRlcHJlY2F0ZWQgdGVjaG5vbG9neSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpblxuICogdGhpcyBjYXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIFNWRyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLnN2ZygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIFNWRyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLnN2Zyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTVkcgPSBSZW5kZXJlci5leHRlbmQoe1xuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBSZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cdFx0ZXZlbnRzLnpvb21zdGFydCA9IHRoaXMuX29uWm9vbVN0YXJ0O1xuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUoJ3N2ZycpO1xuXG5cdFx0Ly8gbWFrZXMgaXQgcG9zc2libGUgdG8gY2xpY2sgdGhyb3VnaCBzdmcgcm9vdDsgd2UnbGwgcmVzZXQgaXQgYmFjayBpbiBpbmRpdmlkdWFsIHBhdGhzXG5cdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuXG5cdFx0dGhpcy5fcm9vdEdyb3VwID0gY3JlYXRlKCdnJyk7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3Jvb3RHcm91cCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG5cdFx0ZGVsZXRlIHRoaXMuX3Jvb3RHcm91cDtcblx0XHRkZWxldGUgdGhpcy5fc3ZnU2l6ZTtcblx0fSxcblxuXHRfb25ab29tU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBEcmFnLXRoZW4tcGluY2ggaW50ZXJhY3Rpb25zIG1pZ2h0IG1lc3MgdXAgdGhlIGNlbnRlciBhbmQgem9vbS5cblx0XHQvLyBJbiB0aGlzIGNhc2UsIHRoZSBlYXNpZXN0IHdheSB0byBwcmV2ZW50IHRoaXMgaXMgcmUtZG8gdGhlIHJlbmRlcmVyXG5cdFx0Ly8gICBib3VuZHMgYW5kIHBhZGRpbmcgd2hlbiB0aGUgem9vbWluZyBzdGFydHMuXG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuXHRcdC8vIHNldCBzaXplIG9mIHN2Zy1jb250YWluZXIgaWYgY2hhbmdlZFxuXHRcdGlmICghdGhpcy5fc3ZnU2l6ZSB8fCAhdGhpcy5fc3ZnU2l6ZS5lcXVhbHMoc2l6ZSkpIHtcblx0XHRcdHRoaXMuX3N2Z1NpemUgPSBzaXplO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLngpO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS55KTtcblx0XHR9XG5cblx0XHQvLyBtb3ZlbWVudDogdXBkYXRlIGNvbnRhaW5lciB2aWV3Qm94IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgY29vcmRpbmF0ZXMgb2YgaW5kaXZpZHVhbCBsYXllcnNcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbYi5taW4ueCwgYi5taW4ueSwgc2l6ZS54LCBzaXplLnldLmpvaW4oJyAnKSk7XG5cblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdC8vIG1ldGhvZHMgYmVsb3cgYXJlIGNhbGxlZCBieSB2ZWN0b3IgbGF5ZXJzIGltcGxlbWVudGF0aW9uc1xuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCA9IGNyZWF0ZSgncGF0aCcpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9IG51bGxcblx0XHQvLyBDdXN0b20gY2xhc3MgbmFtZSBzZXQgb24gYW4gZWxlbWVudC4gT25seSBmb3IgU1ZHIHJlbmRlcmVyLlxuXHRcdGlmIChsYXllci5vcHRpb25zLmNsYXNzTmFtZSkge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYXRoLCBsYXllci5vcHRpb25zLmNsYXNzTmFtZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGF0aCwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9yb290R3JvdXApIHsgdGhpcy5faW5pdENvbnRhaW5lcigpOyB9XG5cdFx0dGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwucmVtb3ZlKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGgsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKCFwYXRoKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCBvcHRpb25zLm9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIG9wdGlvbnMud2VpZ2h0KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIG9wdGlvbnMubGluZUNhcCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgb3B0aW9ucy5saW5lSm9pbik7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIG9wdGlvbnMuZGFzaEFycmF5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hPZmZzZXQpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jywgb3B0aW9ucy5kYXNoT2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIG9wdGlvbnMuZmlsbE9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsIG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBwb2ludHNUb1BhdGgobGF5ZXIuX3BhcnRzLCBjbG9zZWQpKTtcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuXHRcdCAgICByMiA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByLFxuXHRcdCAgICBhcmMgPSAnYScgKyByICsgJywnICsgcjIgKyAnIDAgMSwwICc7XG5cblx0XHQvLyBkcmF3aW5nIGEgY2lyY2xlIHdpdGggdHdvIGhhbGYtYXJjc1xuXHRcdHZhciBkID0gbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0J00nICsgKHAueCAtIHIpICsgJywnICsgcC55ICtcblx0XHRcdGFyYyArIChyICogMikgKyAnLDAgJyArXG5cdFx0XHRhcmMgKyAoLXIgKiAyKSArICcsMCAnO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgZCk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuXHR9LFxuXG5cdC8vIFNWRyBkb2VzIG5vdCBoYXZlIHRoZSBjb25jZXB0IG9mIHpJbmRleCBzbyB3ZSByZXNvcnQgdG8gY2hhbmdpbmcgdGhlIERPTSBvcmRlciBvZiBlbGVtZW50c1xuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvRnJvbnQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0JhY2sobGF5ZXIuX3BhdGgpO1xuXHR9XG59KTtcblxuaWYgKEJyb3dzZXIudm1sKSB7XG5cdFNWRy5pbmNsdWRlKHZtbE1peGluKTtcbn1cblxuLy8gQG5hbWVzcGFjZSBTVkdcbi8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIFNWRyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIHN2ZyhvcHRpb25zKSB7XG5cdHJldHVybiBCcm93c2VyLnN2ZyB8fCBCcm93c2VyLnZtbCA/IG5ldyBTVkcob3B0aW9ucykgOiBudWxsO1xufVxuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uLy4uL21hcC9NYXAnO1xuaW1wb3J0IHtjYW52YXN9IGZyb20gJy4vQ2FudmFzJztcbmltcG9ydCB7c3ZnfSBmcm9tICcuL1NWRyc7XG5cbk1hcC5pbmNsdWRlKHtcblx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBtZXRob2QgZ2V0UmVuZGVyZXIobGF5ZXI6IFBhdGgpOiBSZW5kZXJlclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlblxuXHQvLyBgUGF0aGAuIEl0IHdpbGwgZW5zdXJlIHRoYXQgdGhlIGByZW5kZXJlcmAgb3B0aW9ucyBvZiB0aGUgbWFwIGFuZCBwYXRoc1xuXHQvLyBhcmUgcmVzcGVjdGVkLCBhbmQgdGhhdCB0aGUgcmVuZGVyZXJzIGRvIGV4aXN0IG9uIHRoZSBtYXAuXG5cdGdldFJlbmRlcmVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHQvLyBAbmFtZXNwYWNlIFBhdGg7IEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyXG5cdFx0Ly8gVXNlIHRoaXMgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCBmb3IgdGhpcyBwYXRoLiBUYWtlc1xuXHRcdC8vIHByZWNlZGVuY2Ugb3ZlciB0aGUgbWFwJ3MgW2RlZmF1bHQgcmVuZGVyZXJdKCNtYXAtcmVuZGVyZXIpLlxuXHRcdHZhciByZW5kZXJlciA9IGxheWVyLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fZ2V0UGFuZVJlbmRlcmVyKGxheWVyLm9wdGlvbnMucGFuZSkgfHwgdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX3JlbmRlcmVyO1xuXG5cdFx0aWYgKCFyZW5kZXJlcikge1xuXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKHJlbmRlcmVyKSkge1xuXHRcdFx0dGhpcy5hZGRMYXllcihyZW5kZXJlcik7XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fSxcblxuXHRfZ2V0UGFuZVJlbmRlcmVyOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmIChuYW1lID09PSAnb3ZlcmxheVBhbmUnIHx8IG5hbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciByZW5kZXJlciA9IHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV07XG5cdFx0aWYgKHJlbmRlcmVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoe3BhbmU6IG5hbWV9KTtcblx0XHRcdHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV0gPSByZW5kZXJlcjtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9LFxuXG5cdF9jcmVhdGVSZW5kZXJlcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHQvLyBAbmFtZXNwYWNlIE1hcDsgQG9wdGlvbiBwcmVmZXJDYW52YXM6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgYFBhdGhgcyBzaG91bGQgYmUgcmVuZGVyZWQgb24gYSBgQ2FudmFzYCByZW5kZXJlci5cblx0XHQvLyBCeSBkZWZhdWx0LCBhbGwgYFBhdGhgcyBhcmUgcmVuZGVyZWQgaW4gYSBgU1ZHYCByZW5kZXJlci5cblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5wcmVmZXJDYW52YXMgJiYgY2FudmFzKG9wdGlvbnMpKSB8fCBzdmcob3B0aW9ucyk7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtQb2x5Z29ufSBmcm9tICcuL1BvbHlnb24nO1xuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5cbi8qXG4gKiBMLlJlY3RhbmdsZSBleHRlbmRzIFBvbHlnb24gYW5kIGNyZWF0ZXMgYSByZWN0YW5nbGUgd2hlbiBwYXNzZWQgYSBMYXRMbmdCb3VuZHMgb2JqZWN0LlxuICovXG5cbi8qXG4gKiBAY2xhc3MgUmVjdGFuZ2xlXG4gKiBAYWthIEwuUmVjdGFuZ2xlXG4gKiBAaW5oZXJpdHMgUG9seWdvblxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcmVjdGFuZ2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5Z29uYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWZpbmUgcmVjdGFuZ2xlIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAqIHZhciBib3VuZHMgPSBbWzU0LjU1OTMyMiwgLTUuNzY3ODIyXSwgWzU2LjEyMTA2MDQsIC0zLjAyMTI0MF1dO1xuICpcbiAqIC8vIGNyZWF0ZSBhbiBvcmFuZ2UgcmVjdGFuZ2xlXG4gKiBMLnJlY3RhbmdsZShib3VuZHMsIHtjb2xvcjogXCIjZmY3ODAwXCIsIHdlaWdodDogMX0pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSByZWN0YW5nbGUgYm91bmRzXG4gKiBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gKiBgYGBcbiAqXG4gKi9cblxuXG5leHBvcnQgdmFyIFJlY3RhbmdsZSA9IFBvbHlnb24uZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRcdFBvbHlnb24ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSwgb3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIHJlY3RhbmdsZSB3aXRoIHRoZSBwYXNzZWQgYm91bmRzLlxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRMYXRMbmdzKHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpKTtcblx0fSxcblxuXHRfYm91bmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0bGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0TG5nQm91bmRzKTtcblx0XHRyZXR1cm4gW1xuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpXG5cdFx0XTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5yZWN0YW5nbGUobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuZXhwb3J0IGZ1bmN0aW9uIHJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKTtcbn1cbiIsImV4cG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuZXhwb3J0IHtDYW52YXMsIGNhbnZhc30gZnJvbSAnLi9DYW52YXMnO1xuaW1wb3J0IHtTVkcsIGNyZWF0ZSwgcG9pbnRzVG9QYXRoLCBzdmd9IGZyb20gJy4vU1ZHJztcblNWRy5jcmVhdGUgPSBjcmVhdGU7XG5TVkcucG9pbnRzVG9QYXRoID0gcG9pbnRzVG9QYXRoO1xuZXhwb3J0IHtTVkcsIHN2Z307XG5pbXBvcnQgJy4vUmVuZGVyZXIuZ2V0UmVuZGVyZXInO1x0Ly8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2ssIGJ1dCBuZWVkZWQgYmVjYXVzZSBjaXJjdWxhciBkZXBlbmRlbmNpZXNcblxuZXhwb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuZXhwb3J0IHtDaXJjbGVNYXJrZXIsIGNpcmNsZU1hcmtlcn0gZnJvbSAnLi9DaXJjbGVNYXJrZXInO1xuZXhwb3J0IHtDaXJjbGUsIGNpcmNsZX0gZnJvbSAnLi9DaXJjbGUnO1xuZXhwb3J0IHtQb2x5bGluZSwgcG9seWxpbmV9IGZyb20gJy4vUG9seWxpbmUnO1xuZXhwb3J0IHtQb2x5Z29uLCBwb2x5Z29ufSBmcm9tICcuL1BvbHlnb24nO1xuZXhwb3J0IHtSZWN0YW5nbGUsIHJlY3RhbmdsZX0gZnJvbSAnLi9SZWN0YW5nbGUnO1xuIiwiZXhwb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XG5leHBvcnQge0xheWVyR3JvdXAsIGxheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XG5leHBvcnQge0ZlYXR1cmVHcm91cCwgZmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XG5pbXBvcnQge0dlb0pTT04sIGdlb0pTT04sIGdlb0pzb24sIGdlb21ldHJ5VG9MYXllciwgY29vcmRzVG9MYXRMbmcsIGNvb3Jkc1RvTGF0TG5ncywgbGF0TG5nVG9Db29yZHMsIGxhdExuZ3NUb0Nvb3JkcywgZ2V0RmVhdHVyZSwgYXNGZWF0dXJlfSBmcm9tICcuL0dlb0pTT04nO1xuR2VvSlNPTi5nZW9tZXRyeVRvTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXI7XG5HZW9KU09OLmNvb3Jkc1RvTGF0TG5nID0gY29vcmRzVG9MYXRMbmc7XG5HZW9KU09OLmNvb3Jkc1RvTGF0TG5ncyA9IGNvb3Jkc1RvTGF0TG5ncztcbkdlb0pTT04ubGF0TG5nVG9Db29yZHMgPSBsYXRMbmdUb0Nvb3Jkcztcbkdlb0pTT04ubGF0TG5nc1RvQ29vcmRzID0gbGF0TG5nc1RvQ29vcmRzO1xuR2VvSlNPTi5nZXRGZWF0dXJlID0gZ2V0RmVhdHVyZTtcbkdlb0pTT04uYXNGZWF0dXJlID0gYXNGZWF0dXJlO1xuZXhwb3J0IHtHZW9KU09OLCBnZW9KU09OLCBnZW9Kc29ufTtcblxuZXhwb3J0IHtJbWFnZU92ZXJsYXksIGltYWdlT3ZlcmxheX0gZnJvbSAnLi9JbWFnZU92ZXJsYXknO1xuZXhwb3J0IHtWaWRlb092ZXJsYXksIHZpZGVvT3ZlcmxheX0gZnJvbSAnLi9WaWRlb092ZXJsYXknO1xuZXhwb3J0IHtTVkdPdmVybGF5LCBzdmdPdmVybGF5fSBmcm9tICcuL1NWR092ZXJsYXknO1xuXG5leHBvcnQge0Rpdk92ZXJsYXl9IGZyb20gJy4vRGl2T3ZlcmxheSc7XG5leHBvcnQge1BvcHVwLCBwb3B1cH0gZnJvbSAnLi9Qb3B1cCc7XG5leHBvcnQge1Rvb2x0aXAsIHRvb2x0aXB9IGZyb20gJy4vVG9vbHRpcCc7XG5cbmV4cG9ydCAqIGZyb20gJy4vbWFya2VyL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdGlsZS9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3ZlY3Rvci9pbmRleCc7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG4vKlxuICogTC5IYW5kbGVyLkJveFpvb20gaXMgdXNlZCB0byBhZGQgc2hpZnQtZHJhZyB6b29tIGludGVyYWN0aW9uIHRvIHRoZSBtYXBcbiAqICh6b29tIHRvIGEgc2VsZWN0ZWQgYm91bmRpbmcgYm94KSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBib3hab29tOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCB0byBhIHJlY3Rhbmd1bGFyIGFyZWEgc3BlY2lmaWVkIGJ5XG5cdC8vIGRyYWdnaW5nIHRoZSBtb3VzZSB3aGlsZSBwcmVzc2luZyB0aGUgc2hpZnQga2V5LlxuXHRib3hab29tOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBCb3hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5fY29udGFpbmVyO1xuXHRcdHRoaXMuX3BhbmUgPSBtYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHRtYXAub24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3ksIHRoaXMpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3BhbmUpO1xuXHRcdGRlbGV0ZSB0aGlzLl9wYW5lO1xuXHR9LFxuXG5cdF9yZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdH0sXG5cblx0X2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ICE9PSAwKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQpO1xuXHRcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyBDbGVhciB0aGUgZGVmZXJyZWQgcmVzZXRTdGF0ZSBpZiBpdCBoYXNuJ3QgZXhlY3V0ZWQgeWV0LCBvdGhlcndpc2UgaXRcblx0XHQvLyB3aWxsIGludGVycnVwdCB0aGUgaW50ZXJhY3Rpb24gYW5kIG9ycGhhbiBhIGJveCBlbGVtZW50IGluIHRoZSBjb250YWluZXIuXG5cdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG5cblx0XHREb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0RG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHR0aGlzLl9zdGFydFBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBEb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JveCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC16b29tLWJveCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cblx0XHRcdHRoaXMuX21hcC5maXJlKCdib3h6b29tc3RhcnQnKTtcblx0XHR9XG5cblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdHZhciBib3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LCB0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2JveCwgYm91bmRzLm1pbik7XG5cblx0XHR0aGlzLl9ib3guc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4Jztcblx0XHR0aGlzLl9ib3guc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4Jztcblx0fSxcblxuXHRfZmluaXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21vdmVkKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9ib3gpO1xuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXHRcdH1cblxuXHRcdERvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdERvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBEb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZmluaXNoKCk7XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7IHJldHVybjsgfVxuXHRcdC8vIFBvc3Rwb25lIHRvIG5leHQgSlMgdGljayBzbyBpbnRlcm5hbCBjbGljayBldmVudCBoYW5kbGluZ1xuXHRcdC8vIHN0aWxsIHNlZSBpdCBhcyBcIm1vdmVkXCIuXG5cdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3Jlc2V0U3RhdGUsIHRoaXMpLCAwKTtcblxuXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludCkpO1xuXG5cdFx0dGhpcy5fbWFwXG5cdFx0XHQuZml0Qm91bmRzKGJvdW5kcylcblx0XHRcdC5maXJlKCdib3h6b29tZW5kJywge2JveFpvb21Cb3VuZHM6IGJvdW5kc30pO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdHRoaXMuX2ZpbmlzaCgpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgYm94Wm9vbTogSGFuZGxlclxuLy8gQm94IChzaGlmdC1kcmFnIHdpdGggbW91c2UpIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdib3hab29tJywgQm94Wm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcblxuLypcbiAqIEwuSGFuZGxlci5Eb3VibGVDbGlja1pvb20gaXMgdXNlZCB0byBoYW5kbGUgZG91YmxlLWNsaWNrIHpvb20gb24gdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5cbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRvdWJsZUNsaWNrWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGluIGJ5IGRvdWJsZSBjbGlja2luZyBvbiBpdCBhbmRcblx0Ly8gem9vbWVkIG91dCBieSBkb3VibGUgY2xpY2tpbmcgd2hpbGUgaG9sZGluZyBzaGlmdC4gSWYgcGFzc2VkXG5cdC8vIGAnY2VudGVyJ2AsIGRvdWJsZS1jbGljayB6b29tIHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZVxuXHQvLyAgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdGRvdWJsZUNsaWNrWm9vbTogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgRG91YmxlQ2xpY2tab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcC5vbignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcC5vZmYoJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0X29uRG91YmxlQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb2xkWm9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIGRlbHRhID0gbWFwLm9wdGlvbnMuem9vbURlbHRhLFxuXHRcdCAgICB6b29tID0gZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5ID8gb2xkWm9vbSAtIGRlbHRhIDogb2xkWm9vbSArIGRlbHRhO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmRvdWJsZUNsaWNrWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZChlLmNvbnRhaW5lclBvaW50LCB6b29tKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy9cbi8vIE1hcCBwcm9wZXJ0aWVzIGluY2x1ZGUgaW50ZXJhY3Rpb24gaGFuZGxlcnMgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbFxuLy8gaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaFxuLy8gYXMgZHJhZ2dpbmcgb3IgdG91Y2ggem9vbSAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRm9yIGV4YW1wbGU6XG4vL1xuLy8gYGBganNcbi8vIG1hcC5kb3VibGVDbGlja1pvb20uZGlzYWJsZSgpO1xuLy8gYGBgXG4vL1xuLy8gQHByb3BlcnR5IGRvdWJsZUNsaWNrWm9vbTogSGFuZGxlclxuLy8gRG91YmxlIGNsaWNrIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkb3VibGVDbGlja1pvb20nLCBEb3VibGVDbGlja1pvb20pO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQge0RyYWdnYWJsZX0gZnJvbSAnLi4vLi4vZG9tL0RyYWdnYWJsZSc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHMgYXMgbGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFwRHJhZyBpcyB1c2VkIHRvIG1ha2UgdGhlIG1hcCBkcmFnZ2FibGUgKHdpdGggcGFubmluZyBpbmVydGlhKSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBkcmFnZ2luZzogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGJlIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cblx0ZHJhZ2dpbmc6IHRydWUsXG5cblx0Ly8gQHNlY3Rpb24gUGFubmluZyBJbmVydGlhIE9wdGlvbnNcblx0Ly8gQG9wdGlvbiBpbmVydGlhOiBCb29sZWFuID0gKlxuXHQvLyBJZiBlbmFibGVkLCBwYW5uaW5nIG9mIHRoZSBtYXAgd2lsbCBoYXZlIGFuIGluZXJ0aWEgZWZmZWN0IHdoZXJlXG5cdC8vIHRoZSBtYXAgYnVpbGRzIG1vbWVudHVtIHdoaWxlIGRyYWdnaW5nIGFuZCBjb250aW51ZXMgbW92aW5nIGluXG5cdC8vIHRoZSBzYW1lIGRpcmVjdGlvbiBmb3Igc29tZSB0aW1lLiBGZWVscyBlc3BlY2lhbGx5IG5pY2Ugb24gdG91Y2hcblx0Ly8gZGV2aWNlcy4gRW5hYmxlZCBieSBkZWZhdWx0IHVubGVzcyBydW5uaW5nIG9uIG9sZCBBbmRyb2lkIGRldmljZXMuXG5cdGluZXJ0aWE6ICFCcm93c2VyLmFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFEZWNlbGVyYXRpb246IE51bWJlciA9IDMwMDBcblx0Ly8gVGhlIHJhdGUgd2l0aCB3aGljaCB0aGUgaW5lcnRpYWwgbW92ZW1lbnQgc2xvd3MgZG93biwgaW4gcGl4ZWxzL3NlY29uZMKyLlxuXHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcblxuXHQvLyBAb3B0aW9uIGluZXJ0aWFNYXhTcGVlZDogTnVtYmVyID0gSW5maW5pdHlcblx0Ly8gTWF4IHNwZWVkIG9mIHRoZSBpbmVydGlhbCBtb3ZlbWVudCwgaW4gcGl4ZWxzL3NlY29uZC5cblx0aW5lcnRpYU1heFNwZWVkOiBJbmZpbml0eSwgLy8gcHgvc1xuXG5cdC8vIEBvcHRpb24gZWFzZUxpbmVhcml0eTogTnVtYmVyID0gMC4yXG5cdGVhc2VMaW5lYXJpdHk6IDAuMixcblxuXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuXHQvLyBAb3B0aW9uIHdvcmxkQ29weUp1bXA6IEJvb2xlYW4gPSBmYWxzZVxuXHQvLyBXaXRoIHRoaXMgb3B0aW9uIGVuYWJsZWQsIHRoZSBtYXAgdHJhY2tzIHdoZW4geW91IHBhbiB0byBhbm90aGVyIFwiY29weVwiXG5cdC8vIG9mIHRoZSB3b3JsZCBhbmQgc2VhbWxlc3NseSBqdW1wcyB0byB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgYWxsIG92ZXJsYXlzXG5cdC8vIGxpa2UgbWFya2VycyBhbmQgdmVjdG9yIGxheWVycyBhcmUgc3RpbGwgdmlzaWJsZS5cblx0d29ybGRDb3B5SnVtcDogZmFsc2UsXG5cblx0Ly8gQG9wdGlvbiBtYXhCb3VuZHNWaXNjb3NpdHk6IE51bWJlciA9IDAuMFxuXHQvLyBJZiBgbWF4Qm91bmRzYCBpcyBzZXQsIHRoaXMgb3B0aW9uIHdpbGwgY29udHJvbCBob3cgc29saWQgdGhlIGJvdW5kc1xuXHQvLyBhcmUgd2hlbiBkcmFnZ2luZyB0aGUgbWFwIGFyb3VuZC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgYDAuMGAgYWxsb3dzIHRoZVxuXHQvLyB1c2VyIHRvIGRyYWcgb3V0c2lkZSB0aGUgYm91bmRzIGF0IG5vcm1hbCBzcGVlZCwgaGlnaGVyIHZhbHVlcyB3aWxsXG5cdC8vIHNsb3cgZG93biBtYXAgZHJhZ2dpbmcgb3V0c2lkZSBib3VuZHMsIGFuZCBgMS4wYCBtYWtlcyB0aGUgYm91bmRzIGZ1bGx5XG5cdC8vIHNvbGlkLCBwcmV2ZW50aW5nIHRoZSB1c2VyIGZyb20gZHJhZ2dpbmcgb3V0c2lkZSB0aGUgYm91bmRzLlxuXHRtYXhCb3VuZHNWaXNjb3NpdHk6IDAuMFxufSk7XG5cbmV4cG9ydCB2YXIgRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZShtYXAuX21hcFBhbmUsIG1hcC5fY29udGFpbmVyKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdMaW1pdCwgdGhpcyk7XG5cdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xuXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdXcmFwLCB0aGlzKTtcblx0XHRcdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblxuXHRcdFx0XHRtYXAud2hlblJlYWR5KHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWIgbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmVuYWJsZSgpO1xuXHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdHRoaXMuX3RpbWVzID0gW107XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiJyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtZHJhZycpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5kaXNhYmxlKCk7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG5cdH0sXG5cblx0bW92aW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmluZztcblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0bWFwLl9zdG9wKCk7XG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyAmJiB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpIHtcblx0XHRcdHZhciBib3VuZHMgPSBsYXRMbmdCb3VuZHModGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSB0b0JvdW5kcyhcblx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoYm91bmRzLmdldE5vcnRoV2VzdCgpKS5tdWx0aXBseUJ5KC0xKSxcblx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoYm91bmRzLmdldFNvdXRoRWFzdCgpKS5tdWx0aXBseUJ5KC0xKVxuXHRcdFx0XHRcdC5hZGQodGhpcy5fbWFwLmdldFNpemUoKSkpO1xuXG5cdFx0XHR0aGlzLl92aXNjb3NpdHkgPSBNYXRoLm1pbigxLjAsIE1hdGgubWF4KDAuMCwgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gbnVsbDtcblx0XHR9XG5cblx0XHRtYXBcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcblxuXHRcdGlmIChtYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHRcdHRoaXMuX3RpbWVzID0gW107XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHZhciB0aW1lID0gdGhpcy5fbGFzdFRpbWUgPSArbmV3IERhdGUoKSxcblx0XHRcdCAgICBwb3MgPSB0aGlzLl9sYXN0UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgfHwgdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3M7XG5cblx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5wdXNoKHBvcyk7XG5cdFx0XHR0aGlzLl90aW1lcy5wdXNoKHRpbWUpO1xuXG5cdFx0XHR0aGlzLl9wcnVuZVBvc2l0aW9ucyh0aW1lKTtcblx0XHR9XG5cblx0XHR0aGlzLl9tYXBcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9wcnVuZVBvc2l0aW9uczogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR3aGlsZSAodGhpcy5fcG9zaXRpb25zLmxlbmd0aCA+IDEgJiYgdGltZSAtIHRoaXMuX3RpbWVzWzBdID4gNTApIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpO1xuXHRcdFx0dGhpcy5fdGltZXMuc2hpZnQoKTtcblx0XHR9XG5cdH0sXG5cblx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweENlbnRlciA9IHRoaXMuX21hcC5nZXRTaXplKCkuZGl2aWRlQnkoMiksXG5cdFx0ICAgIHB4V29ybGRDZW50ZXIgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLCAwXSk7XG5cblx0XHR0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQgPSBweFdvcmxkQ2VudGVyLnN1YnRyYWN0KHB4Q2VudGVyKS54O1xuXHRcdHRoaXMuX3dvcmxkV2lkdGggPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcygpLmdldFNpemUoKS54O1xuXHR9LFxuXG5cdF92aXNjb3VzTGltaXQ6IGZ1bmN0aW9uICh2YWx1ZSwgdGhyZXNob2xkKSB7XG5cdFx0cmV0dXJuIHZhbHVlIC0gKHZhbHVlIC0gdGhyZXNob2xkKSAqIHRoaXMuX3Zpc2Nvc2l0eTtcblx0fSxcblxuXHRfb25QcmVEcmFnTGltaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX3Zpc2Nvc2l0eSB8fCAhdGhpcy5fb2Zmc2V0TGltaXQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3Muc3VidHJhY3QodGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcyk7XG5cblx0XHR2YXIgbGltaXQgPSB0aGlzLl9vZmZzZXRMaW1pdDtcblx0XHRpZiAob2Zmc2V0LnggPCBsaW1pdC5taW4ueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWluLngpOyB9XG5cdFx0aWYgKG9mZnNldC55IDwgbGltaXQubWluLnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1pbi55KTsgfVxuXHRcdGlmIChvZmZzZXQueCA+IGxpbWl0Lm1heC54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5tYXgueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPiBsaW1pdC5tYXgueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWF4LnkpOyB9XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ1dyYXA6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cblx0XHR2YXIgd29ybGRXaWR0aCA9IHRoaXMuX3dvcmxkV2lkdGgsXG5cdFx0ICAgIGhhbGZXaWR0aCA9IE1hdGgucm91bmQod29ybGRXaWR0aCAvIDIpLFxuXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcblx0XHQgICAgeCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLngsXG5cdFx0ICAgIG5ld1gxID0gKHggLSBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoICsgaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1ggPSBNYXRoLmFicyhuZXdYMSArIGR4KSA8IE1hdGguYWJzKG5ld1gyICsgZHgpID8gbmV3WDEgOiBuZXdYMjtcblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuY2xvbmUoKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54ID0gbmV3WDtcblx0fSxcblxuXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9wdGlvbnMgPSBtYXAub3B0aW9ucyxcblxuXHRcdCAgICBub0luZXJ0aWEgPSAhb3B0aW9ucy5pbmVydGlhIHx8IHRoaXMuX3RpbWVzLmxlbmd0aCA8IDI7XG5cblx0XHRtYXAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXG5cdFx0aWYgKG5vSW5lcnRpYSkge1xuXHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9wcnVuZVBvc2l0aW9ucygrbmV3IERhdGUoKSk7XG5cblx0XHRcdHZhciBkaXJlY3Rpb24gPSB0aGlzLl9sYXN0UG9zLnN1YnRyYWN0KHRoaXMuX3Bvc2l0aW9uc1swXSksXG5cdFx0XHQgICAgZHVyYXRpb24gPSAodGhpcy5fbGFzdFRpbWUgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxuXHRcdFx0ICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cblx0XHRcdCAgICBzcGVlZFZlY3RvciA9IGRpcmVjdGlvbi5tdWx0aXBseUJ5KGVhc2UgLyBkdXJhdGlvbiksXG5cdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cblx0XHRcdCAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZFZlY3RvciA9IHNwZWVkVmVjdG9yLm11bHRpcGx5QnkobGltaXRlZFNwZWVkIC8gc3BlZWQpLFxuXG5cdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXG5cdFx0XHQgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuXHRcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcblx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldChvZmZzZXQsIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0LCB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogZGVjZWxlcmF0aW9uRHVyYXRpb24sXG5cdFx0XHRcdFx0XHRlYXNlTGluZWFyaXR5OiBlYXNlLFxuXHRcdFx0XHRcdFx0bm9Nb3ZlU3RhcnQ6IHRydWUsXG5cdFx0XHRcdFx0XHRhbmltYXRlOiB0cnVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbi8vIE1hcCBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZHJhZ2dpbmcnLCBEcmFnKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0IHtvbiwgb2ZmLCBzdG9wfSBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5cblxuLypcbiAqIEwuTWFwLktleWJvYXJkIGlzIGhhbmRsaW5nIGtleWJvYXJkIGludGVyYWN0aW9uIHdpdGggdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBLZXlib2FyZCBOYXZpZ2F0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBNYWtlcyB0aGUgbWFwIGZvY3VzYWJsZSBhbmQgYWxsb3dzIHVzZXJzIHRvIG5hdmlnYXRlIHRoZSBtYXAgd2l0aCBrZXlib2FyZFxuXHQvLyBhcnJvd3MgYW5kIGArYC9gLWAga2V5cy5cblx0a2V5Ym9hcmQ6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiBrZXlib2FyZFBhbkRlbHRhOiBOdW1iZXIgPSA4MFxuXHQvLyBBbW91bnQgb2YgcGl4ZWxzIHRvIHBhbiB3aGVuIHByZXNzaW5nIGFuIGFycm93IGtleS5cblx0a2V5Ym9hcmRQYW5EZWx0YTogODBcbn0pO1xuXG5leHBvcnQgdmFyIEtleWJvYXJkID0gSGFuZGxlci5leHRlbmQoe1xuXG5cdGtleUNvZGVzOiB7XG5cdFx0bGVmdDogICAgWzM3XSxcblx0XHRyaWdodDogICBbMzldLFxuXHRcdGRvd246ICAgIFs0MF0sXG5cdFx0dXA6ICAgICAgWzM4XSxcblx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuXHRcdHpvb21PdXQ6IFsxODksIDEwOSwgNTQsIDE3M11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXG5cdFx0dGhpcy5fc2V0UGFuRGVsdGEobWFwLm9wdGlvbnMua2V5Ym9hcmRQYW5EZWx0YSk7XG5cdFx0dGhpcy5fc2V0Wm9vbURlbHRhKG1hcC5vcHRpb25zLnpvb21EZWx0YSk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cblx0XHQvLyBtYWtlIHRoZSBjb250YWluZXIgZm9jdXNhYmxlIGJ5IHRhYmJpbmdcblx0XHRpZiAoY29udGFpbmVyLnRhYkluZGV4IDw9IDApIHtcblx0XHRcdGNvbnRhaW5lci50YWJJbmRleCA9ICcwJztcblx0XHR9XG5cblx0XHRvbihjb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9uKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW1vdmVIb29rcygpO1xuXG5cdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCB7XG5cdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5vZmYoe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZm9jdXNlZCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSxcblx0XHQgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdFx0ICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8IGRvY0VsLnNjcm9sbFRvcCxcblx0XHQgICAgbGVmdCA9IGJvZHkuc2Nyb2xsTGVmdCB8fCBkb2NFbC5zY3JvbGxMZWZ0O1xuXG5cdFx0dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKTtcblxuXHRcdHdpbmRvdy5zY3JvbGxUbyhsZWZ0LCB0b3ApO1xuXHR9LFxuXG5cdF9vbkZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IHRydWU7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2ZvY3VzJyk7XG5cdH0sXG5cblx0X29uQmx1cjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnYmx1cicpO1xuXHR9LFxuXG5cdF9zZXRQYW5EZWx0YTogZnVuY3Rpb24gKHBhbkRlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl9wYW5LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMubGVmdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5sZWZ0W2ldXSA9IFstMSAqIHBhbkRlbHRhLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMucmlnaHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMucmlnaHRbaV1dID0gW3BhbkRlbHRhLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuZG93bi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5kb3duW2ldXSA9IFswLCBwYW5EZWx0YV07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnVwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnVwW2ldXSA9IFswLCAtMSAqIHBhbkRlbHRhXTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21EZWx0YTogZnVuY3Rpb24gKHpvb21EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fem9vbUtleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tSW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbUluW2ldXSA9IHpvb21EZWx0YTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbU91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tT3V0W2ldXSA9IC16b29tRGVsdGE7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X3JlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBrZXkgPSBlLmtleUNvZGUsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb2Zmc2V0O1xuXG5cdFx0aWYgKGtleSBpbiB0aGlzLl9wYW5LZXlzKSB7XG5cdFx0XHRpZiAoIW1hcC5fcGFuQW5pbSB8fCAhbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSB7XG5cdFx0XHRcdG9mZnNldCA9IHRoaXMuX3BhbktleXNba2V5XTtcblx0XHRcdFx0aWYgKGUuc2hpZnRLZXkpIHtcblx0XHRcdFx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkubXVsdGlwbHlCeSgzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQpO1xuXG5cdFx0XHRcdGlmIChtYXAub3B0aW9ucy5tYXhCb3VuZHMpIHtcblx0XHRcdFx0XHRtYXAucGFuSW5zaWRlQm91bmRzKG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl96b29tS2V5cykge1xuXHRcdFx0bWFwLnNldFpvb20obWFwLmdldFpvb20oKSArIChlLnNoaWZ0S2V5ID8gMyA6IDEpICogdGhpcy5fem9vbUtleXNba2V5XSk7XG5cblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gMjcgJiYgbWFwLl9wb3B1cCAmJiBtYXAuX3BvcHVwLm9wdGlvbnMuY2xvc2VPbkVzY2FwZUtleSkge1xuXHRcdFx0bWFwLmNsb3NlUG9wdXAoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c3RvcChlKTtcblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGtleWJvYXJkOiBIYW5kbGVyXG4vLyBLZXlib2FyZCBuYXZpZ2F0aW9uIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAna2V5Ym9hcmQnLCBLZXlib2FyZCk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuU2Nyb2xsV2hlZWxab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gZW5hYmxlIG1vdXNlIHNjcm9sbCB3aGVlbCB6b29tIG9uIHRoZSBtYXAuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBNb3VzZXdoZWVsIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiBzY3JvbGxXaGVlbFpvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB1c2luZyB0aGUgbW91c2Ugd2hlZWwuIElmIHBhc3NlZCBgJ2NlbnRlcidgLFxuXHQvLyBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdHNjcm9sbFdoZWVsWm9vbTogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHdoZWVsRGVib3VuY2VUaW1lOiBOdW1iZXIgPSA0MFxuXHQvLyBMaW1pdHMgdGhlIHJhdGUgYXQgd2hpY2ggYSB3aGVlbCBjYW4gZmlyZSAoaW4gbWlsbGlzZWNvbmRzKS4gQnkgZGVmYXVsdFxuXHQvLyB1c2VyIGNhbid0IHpvb20gdmlhIHdoZWVsIG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciA0MCBtcy5cblx0d2hlZWxEZWJvdW5jZVRpbWU6IDQwLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxQeFBlclpvb21MZXZlbDogTnVtYmVyID0gNjBcblx0Ly8gSG93IG1hbnkgc2Nyb2xsIHBpeGVscyAoYXMgcmVwb3J0ZWQgYnkgW0wuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YV0oI2RvbWV2ZW50LWdldHdoZWVsZGVsdGEpKVxuXHQvLyBtZWFuIGEgY2hhbmdlIG9mIG9uZSBmdWxsIHpvb20gbGV2ZWwuIFNtYWxsZXIgdmFsdWVzIHdpbGwgbWFrZSB3aGVlbC16b29taW5nXG5cdC8vIGZhc3RlciAoYW5kIHZpY2UgdmVyc2EpLlxuXHR3aGVlbFB4UGVyWm9vbUxldmVsOiA2MFxufSk7XG5cbmV4cG9ydCB2YXIgU2Nyb2xsV2hlZWxab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXHR9LFxuXG5cdF9vbldoZWVsU2Nyb2xsOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBkZWx0YSA9IERvbUV2ZW50LmdldFdoZWVsRGVsdGEoZSk7XG5cblx0XHR2YXIgZGVib3VuY2UgPSB0aGlzLl9tYXAub3B0aW9ucy53aGVlbERlYm91bmNlVGltZTtcblxuXHRcdHRoaXMuX2RlbHRhICs9IGRlbHRhO1xuXHRcdHRoaXMuX2xhc3RNb3VzZVBvcyA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdGlmICghdGhpcy5fc3RhcnRUaW1lKSB7XG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblx0XHR9XG5cblx0XHR2YXIgbGVmdCA9IE1hdGgubWF4KGRlYm91bmNlIC0gKCtuZXcgRGF0ZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSwgMCk7XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuXHRcdHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fcGVyZm9ybVpvb20sIHRoaXMpLCBsZWZ0KTtcblxuXHRcdERvbUV2ZW50LnN0b3AoZSk7XG5cdH0sXG5cblx0X3BlcmZvcm1ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIHNuYXAgPSB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCB8fCAwO1xuXG5cdFx0bWFwLl9zdG9wKCk7IC8vIHN0b3AgcGFubmluZyBhbmQgZmx5IGFuaW1hdGlvbnMgaWYgYW55XG5cblx0XHQvLyBtYXAgdGhlIGRlbHRhIHdpdGggYSBzaWdtb2lkIGZ1bmN0aW9uIHRvIC00Li40IHJhbmdlIGxlYW5pbmcgb24gLTEuLjFcblx0XHR2YXIgZDIgPSB0aGlzLl9kZWx0YSAvICh0aGlzLl9tYXAub3B0aW9ucy53aGVlbFB4UGVyWm9vbUxldmVsICogNCksXG5cdFx0ICAgIGQzID0gNCAqIE1hdGgubG9nKDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkMikpKSkgLyBNYXRoLkxOMixcblx0XHQgICAgZDQgPSBzbmFwID8gTWF0aC5jZWlsKGQzIC8gc25hcCkgKiBzbmFwIDogZDMsXG5cdFx0ICAgIGRlbHRhID0gbWFwLl9saW1pdFpvb20oem9vbSArICh0aGlzLl9kZWx0YSA+IDAgPyBkNCA6IC1kNCkpIC0gem9vbTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG5cdFx0aWYgKCFkZWx0YSkgeyByZXR1cm47IH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tICsgZGVsdGEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZCh0aGlzLl9sYXN0TW91c2VQb3MsIHpvb20gKyBkZWx0YSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBzY3JvbGxXaGVlbFpvb206IEhhbmRsZXJcbi8vIFNjcm9sbCB3aGVlbCB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnc2Nyb2xsV2hlZWxab29tJywgU2Nyb2xsV2hlZWxab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG5cbi8qXG4gKiBMLk1hcC5UYXAgaXMgdXNlZCB0byBlbmFibGUgbW9iaWxlIGhhY2tzIGxpa2UgcXVpY2sgdGFwcyBhbmQgbG9uZyBob2xkLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHRhcDogQm9vbGVhbiA9IHRydWVcblx0Ly8gRW5hYmxlcyBtb2JpbGUgaGFja3MgZm9yIHN1cHBvcnRpbmcgaW5zdGFudCB0YXBzIChmaXhpbmcgMjAwbXMgY2xpY2tcblx0Ly8gZGVsYXkgb24gaU9TL0FuZHJvaWQpIGFuZCB0b3VjaCBob2xkcyAoZmlyZWQgYXMgYGNvbnRleHRtZW51YCBldmVudHMpLlxuXHR0YXA6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiB0YXBUb2xlcmFuY2U6IE51bWJlciA9IDE1XG5cdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IGhpcyBmaW5nZXIgZHVyaW5nIHRvdWNoXG5cdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgdGFwLlxuXHR0YXBUb2xlcmFuY2U6IDE1XG59KTtcblxuZXhwb3J0IHZhciBUYXAgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMpIHsgcmV0dXJuOyB9XG5cblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblxuXHRcdHRoaXMuX2ZpcmVDbGljayA9IHRydWU7XG5cblx0XHQvLyBkb24ndCBzaW11bGF0ZSBjbGljayBvciB0cmFjayBsb25ncHJlc3MgaWYgbW9yZSB0aGFuIDEgdG91Y2hcblx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF0sXG5cdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cblx0XHQvLyBpZiB0b3VjaGluZyBhIGxpbmssIGhpZ2hsaWdodCBpdFxuXHRcdGlmIChlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHR9XG5cblx0XHQvLyBzaW11bGF0ZSBsb25nIGhvbGQgYnV0IHNldHRpbmcgYSB0aW1lb3V0XG5cdFx0dGhpcy5faG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9vblVwKCk7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NvbnRleHRtZW51JywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpLCAxMDAwKTtcblxuXHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNlZG93bicsIGZpcnN0KTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCB7XG5cdFx0XHR0b3VjaG1vdmU6IHRoaXMuX29uTW92ZSxcblx0XHRcdHRvdWNoZW5kOiB0aGlzLl9vblVwXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwge1xuXHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG5cdFx0XHR0b3VjaGVuZDogdGhpcy5fb25VcFxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX2ZpcmVDbGljayAmJiBlICYmIGUuY2hhbmdlZFRvdWNoZXMpIHtcblxuXHRcdFx0dmFyIGZpcnN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXSxcblx0XHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcblxuXHRcdFx0aWYgKGVsICYmIGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcblx0XHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNldXAnLCBmaXJzdCk7XG5cblx0XHRcdC8vIHNpbXVsYXRlIGNsaWNrIGlmIHRoZSB0b3VjaCBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjbGljaycsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0fSxcblxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vtb3ZlJywgZmlyc3QpO1xuXHR9LFxuXG5cdF9zaW11bGF0ZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuXHRcdHZhciBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuX3NpbXVsYXRlZCA9IHRydWU7XG5cdFx0ZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrID0gdHJ1ZTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KFxuXHRcdCAgICAgICAgdHlwZSwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAxLFxuXHRcdCAgICAgICAgZS5zY3JlZW5YLCBlLnNjcmVlblksXG5cdFx0ICAgICAgICBlLmNsaWVudFgsIGUuY2xpZW50WSxcblx0XHQgICAgICAgIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblxuXHRcdGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0YXA6IEhhbmRsZXJcbi8vIE1vYmlsZSB0b3VjaCBoYWNrcyAocXVpY2sgdGFwIGFuZCB0b3VjaCBob2xkKSBoYW5kbGVyLlxuaWYgKEJyb3dzZXIudG91Y2ggJiYgIUJyb3dzZXIucG9pbnRlcikge1xuXHRNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndGFwJywgVGFwKTtcbn1cbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG4vKlxuICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdG91Y2hab29tOiBCb29sZWFufFN0cmluZyA9ICpcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdG91Y2gtZHJhZ2dpbmcgd2l0aCB0d28gZmluZ2Vycy4gSWZcblx0Ly8gcGFzc2VkIGAnY2VudGVyJ2AsIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Zcblx0Ly8gd2hlcmUgdGhlIHRvdWNoIGV2ZW50cyAoZmluZ2Vycykgd2VyZS4gRW5hYmxlZCBmb3IgdG91Y2gtY2FwYWJsZSB3ZWJcblx0Ly8gYnJvd3NlcnMgZXhjZXB0IGZvciBvbGQgQW5kcm9pZHMuXG5cdHRvdWNoWm9vbTogQnJvd3Nlci50b3VjaCAmJiAhQnJvd3Nlci5hbmRyb2lkMjMsXG5cblx0Ly8gQG9wdGlvbiBib3VuY2VBdFpvb21MaW1pdHM6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFNldCBpdCB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIHpvb20gYmV5b25kIG1pbi9tYXggem9vbVxuXHQvLyBhbmQgdGhlbiBib3VuY2UgYmFjayB3aGVuIHBpbmNoLXpvb21pbmcuXG5cdGJvdW5jZUF0Wm9vbUxpbWl0czogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgVG91Y2hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcblx0XHREb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IG1hcC5fYW5pbWF0aW5nWm9vbSB8fCB0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSk7XG5cblx0XHR0aGlzLl9jZW50ZXJQb2ludCA9IG1hcC5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xuXHRcdHRoaXMuX3N0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gIT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9waW5jaFN0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocDEuYWRkKHAyKS5fZGl2aWRlQnkoMikpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdHRoaXMuX3N0YXJ0Wm9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3pvb21pbmcgPSB0cnVlO1xuXG5cdFx0bWFwLl9zdG9wKCk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCAhdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSksXG5cdFx0ICAgIHNjYWxlID0gcDEuZGlzdGFuY2VUbyhwMikgLyB0aGlzLl9zdGFydERpc3Q7XG5cblx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuXHRcdGlmICghbWFwLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzICYmIChcblx0XHRcdCh0aGlzLl96b29tIDwgbWFwLmdldE1pblpvb20oKSAmJiBzY2FsZSA8IDEpIHx8XG5cdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcblx0XHRcdHRoaXMuX3pvb20gPSBtYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRMYXRMbmc7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCBkZWx0YSBmcm9tIHBpbmNoIHRvIGNlbnRlciwgc28gY2VudGVyTGF0TG5nIGlzIGRlbHRhIGFwcGxpZWQgdG8gaW5pdGlhbCBwaW5jaExhdExuZ1xuXHRcdFx0dmFyIGRlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuXHRcdFx0dGhpcy5fY2VudGVyID0gbWFwLnVucHJvamVjdChtYXAucHJvamVjdCh0aGlzLl9waW5jaFN0YXJ0TGF0TG5nLCB0aGlzLl96b29tKS5zdWJ0cmFjdChkZWx0YSksIHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdG1hcC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKTtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHR2YXIgbW92ZUZuID0gVXRpbC5iaW5kKG1hcC5fbW92ZSwgbWFwLCB0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20sIHtwaW5jaDogdHJ1ZSwgcm91bmQ6IGZhbHNlfSk7XG5cdFx0dGhpcy5fYW5pbVJlcXVlc3QgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCB8fCAhdGhpcy5fem9vbWluZykge1xuXHRcdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kKTtcblxuXHRcdC8vIFBpbmNoIHVwZGF0ZXMgR3JpZExheWVycycgbGV2ZWxzIG9ubHkgd2hlbiB6b29tU25hcCBpcyBvZmYsIHNvIHpvb21TbmFwIGJlY29tZXMgbm9VcGRhdGUuXG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcblx0XHRcdHRoaXMuX21hcC5fYW5pbWF0ZVpvb20odGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSwgdHJ1ZSwgdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRvdWNoWm9vbTogSGFuZGxlclxuLy8gVG91Y2ggem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RvdWNoWm9vbScsIFRvdWNoWm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi9NYXAnO1xuaW1wb3J0IHtCb3hab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLkJveFpvb20nO1xuTWFwLkJveFpvb20gPSBCb3hab29tO1xuaW1wb3J0IHtEb3VibGVDbGlja1pvb219IGZyb20gJy4vaGFuZGxlci9NYXAuRG91YmxlQ2xpY2tab29tJztcbk1hcC5Eb3VibGVDbGlja1pvb20gPSBEb3VibGVDbGlja1pvb207XG5pbXBvcnQge0RyYWd9IGZyb20gJy4vaGFuZGxlci9NYXAuRHJhZyc7XG5NYXAuRHJhZyA9IERyYWc7XG5pbXBvcnQge0tleWJvYXJkfSBmcm9tICcuL2hhbmRsZXIvTWFwLktleWJvYXJkJztcbk1hcC5LZXlib2FyZCA9IEtleWJvYXJkO1xuaW1wb3J0IHtTY3JvbGxXaGVlbFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuU2Nyb2xsV2hlZWxab29tJztcbk1hcC5TY3JvbGxXaGVlbFpvb20gPSBTY3JvbGxXaGVlbFpvb207XG5pbXBvcnQge1RhcH0gZnJvbSAnLi9oYW5kbGVyL01hcC5UYXAnO1xuTWFwLlRhcCA9IFRhcDtcbmltcG9ydCB7VG91Y2hab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLlRvdWNoWm9vbSc7XG5NYXAuVG91Y2hab29tID0gVG91Y2hab29tO1xuXG5leHBvcnQge01hcCwgY3JlYXRlTWFwIGFzIG1hcH0gZnJvbSAnLi9NYXAnO1xuIiwiXHJcbmltcG9ydCB7dmVyc2lvbn0gZnJvbSAnLi4vcGFja2FnZS5qc29uJztcclxuZXhwb3J0IHt2ZXJzaW9ufTtcclxuXHJcbi8vIGNvbnRyb2xcclxuZXhwb3J0ICogZnJvbSAnLi9jb250cm9sL2luZGV4JztcclxuXHJcbi8vIGNvcmVcclxuZXhwb3J0ICogZnJvbSAnLi9jb3JlL2luZGV4JztcclxuXHJcbi8vIGRvbVxyXG5leHBvcnQgKiBmcm9tICcuL2RvbS9pbmRleCc7XHJcblxyXG4vLyBnZW9tZXRyeVxyXG5leHBvcnQgKiBmcm9tICcuL2dlb21ldHJ5L2luZGV4JztcclxuXHJcbi8vIGdlb1xyXG5leHBvcnQgKiBmcm9tICcuL2dlby9pbmRleCc7XHJcblxyXG4vLyBsYXllclxyXG5leHBvcnQgKiBmcm9tICcuL2xheWVyL2luZGV4JztcclxuXHJcbi8vIG1hcFxyXG5leHBvcnQgKiBmcm9tICcuL21hcC9pbmRleCc7XHJcblxyXG5pbXBvcnQge2ZyZWV6ZX0gZnJvbSAnLi9jb3JlL1V0aWwnO1xyXG5PYmplY3QuZnJlZXplID0gZnJlZXplO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")},,,function(module,exports,__webpack_require__){"use strict";eval('\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], " {").concat(content, "}");\n      }\n\n      return content;\n    }).join(\'\');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \'string\') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \'\']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\'; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot || \'\').concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n  return "/*# ".concat(data, " */");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVzZVNvdXJjZU1hcCIsImxpc3QiLCJ0b1N0cmluZyIsIm1hcCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsImNvbmNhdCIsImpvaW4iLCJpIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJkZWR1cGUiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwibGVuZ3RoIiwiaWQiLCJfaSIsInB1c2giLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIl0sIm1hcHBpbmdzIjoiQUFBYTtBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQUEsTUFBTSxDQUFDQyxPQUFQLEdBQWlCLFVBQVVDLFlBQVYsRUFBd0I7RUFDdkMsSUFBSUMsSUFBSSxHQUFHLEVBQVgsQ0FEdUMsQ0FDeEI7O0VBRWZBLElBQUksQ0FBQ0MsUUFBTCxHQUFnQixTQUFTQSxRQUFULEdBQW9CO0lBQ2xDLE9BQU8sS0FBS0MsR0FBTCxDQUFTLFVBQVVDLElBQVYsRUFBZ0I7TUFDOUIsSUFBSUMsT0FBTyxHQUFHQyxzQkFBc0IsQ0FBQ0YsSUFBRCxFQUFPSixZQUFQLENBQXBDOztNQUVBLElBQUlJLElBQUksQ0FBQyxDQUFELENBQVIsRUFBYTtRQUNYLE9BQU8sVUFBVUcsTUFBVixDQUFpQkgsSUFBSSxDQUFDLENBQUQsQ0FBckIsRUFBMEIsSUFBMUIsRUFBZ0NHLE1BQWhDLENBQXVDRixPQUF2QyxFQUFnRCxHQUFoRCxDQUFQO01BQ0Q7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LFNBQVQsQ0FBbUJLLFNBQW5CLEVBQThCO0VBQzVCO0VBQ0EsSUFBSUMsTUFBTSxHQUFHUixJQUFJLENBQUNTLFFBQVEsQ0FBQ0Msa0JBQWtCLENBQUNDLElBQUksQ0FBQ0MsU0FBTCxDQUFlTCxTQUFmLENBQUQsQ0FBbkIsQ0FBVCxDQUFqQjtFQUNBLElBQUlNLElBQUksR0FBRywrREFBK0R6QixNQUEvRCxDQUFzRW9CLE1BQXRFLENBQVg7RUFDQSxPQUFPLE9BQU9wQixNQUFQLENBQWN5QixJQUFkLEVBQW9CLEtBQXBCLENBQVA7QUFDRCIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"default\", function() { return /* binding */ addStylesClient; });\n\n// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js\n/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nfunction listToStyles(parentId, list) {\n  var styles = [];\n  var newStyles = {};\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = item[0];\n    var css = item[1];\n    var media = item[2];\n    var sourceMap = item[3];\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    };\n\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = {\n        id: id,\n        parts: [part]\n      });\n    } else {\n      newStyles[id].parts.push(part);\n    }\n  }\n\n  return styles;\n}\n// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesClient.js\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\n\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nfunction addStylesClient (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzPzliYmMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qcz80OTllIl0sIm5hbWVzIjpbImxpc3RUb1N0eWxlcyIsInBhcmVudElkIiwibGlzdCIsInN0eWxlcyIsIm5ld1N0eWxlcyIsImkiLCJsZW5ndGgiLCJpdGVtIiwiaWQiLCJjc3MiLCJtZWRpYSIsInNvdXJjZU1hcCIsInBhcnQiLCJwdXNoIiwicGFydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLFNBQVNBLFlBQVQsQ0FBdUJDLFFBQXZCLEVBQWlDQyxJQUFqQyxFQUF1QztFQUNwRCxJQUFJQyxNQUFNLEdBQUcsRUFBYjtFQUNBLElBQUlDLFNBQVMsR0FBRyxFQUFoQjs7RUFDQSxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdILElBQUksQ0FBQ0ksTUFBekIsRUFBaUNELENBQUMsRUFBbEMsRUFBc0M7SUFDcEMsSUFBSUUsSUFBSSxHQUFHTCxJQUFJLENBQUNHLENBQUQsQ0FBZjtJQUNBLElBQUlHLEVBQUUsR0FBR0QsSUFBSSxDQUFDLENBQUQsQ0FBYjtJQUNBLElBQUlFLEdBQUcsR0FBR0YsSUFBSSxDQUFDLENBQUQsQ0FBZDtJQUNBLElBQUlHLEtBQUssR0FBR0gsSUFBSSxDQUFDLENBQUQsQ0FBaEI7SUFDQSxJQUFJSSxTQUFTLEdBQUdKLElBQUksQ0FBQyxDQUFELENBQXBCO0lBQ0EsSUFBSUssSUFBSSxHQUFHO01BQ1RKLEVBQUUsRUFBRVAsUUFBUSxHQUFHLEdBQVgsR0FBaUJJLENBRFo7TUFFVEksR0FBRyxFQUFFQSxHQUZJO01BR1RDLEtBQUssRUFBRUEsS0FIRTtNQUlUQyxTQUFTLEVBQUVBO0lBSkYsQ0FBWDs7SUFNQSxJQUFJLENBQUNQLFNBQVMsQ0FBQ0ksRUFBRCxDQUFkLEVBQW9CO01BQ2xCTCxNQUFNLENBQUNVLElBQVAsQ0FBWVQsU0FBUyxDQUFDSSxFQUFELENBQVQsR0FBZ0I7UUFBRUEsRUFBRSxFQUFFQSxFQUFOO1FBQVVNLEtBQUssRUFBRSxDQUFDRixJQUFEO01BQWpCLENBQTVCO0lBQ0QsQ0FGRCxNQUVPO01BQ0xSLFNBQVMsQ0FBQ0ksRUFBRCxDQUFULENBQWNNLEtBQWQsQ0FBb0JELElBQXBCLENBQXlCRCxJQUF6QjtJQUNEO0VBQ0Y7O0VBQ0QsT0FBT1QsTUFBUDtBQUNELEM7O0FDMUJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlDOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjs7QUFFQTs7QUFFQSxlQUFlLFlBQVk7QUFDM0I7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuIiwiLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG5pbXBvcnQgbGlzdFRvU3R5bGVzIGZyb20gJy4vbGlzdFRvU3R5bGVzJ1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cbnZhciBvcHRpb25zID0gbnVsbFxudmFyIHNzcklkS2V5ID0gJ2RhdGEtdnVlLXNzci1pZCdcblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkU3R5bGVzQ2xpZW50IChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbiwgX29wdGlvbnMpIHtcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxuXG4gIG9wdGlvbnMgPSBfb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG4gICAgdmFyIG1heVJlbW92ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgICAgZG9tU3R5bGUucmVmcy0tXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcbiAgICB9XG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcbiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW11cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxuICAgICAgaWYgKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUucmVmcysrXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXG4gICAgICB9XG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsgaWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0cyB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcbiAgcmV0dXJuIHN0eWxlRWxlbWVudFxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICB2YXIgdXBkYXRlLCByZW1vdmVcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlWycgKyBzc3JJZEtleSArICd+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuICBpZiAob3B0aW9ucy5zc3JJZCkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoc3NySWRLZXksIG9iai5pZClcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n")},,function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functional component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzPzI4NzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHsgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgdGhpcy4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290KSB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n")},,,function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(40);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(5).default\nvar update = add(\"fd0daf26\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWRpYWxvZy1kcmFnL2Rpc3QvdnVlLWRpYWxvZy1kcmFnLmNzcz9kYzYxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQXVJO0FBQzdKO0FBQ0EsNENBQTRDLFFBQVM7QUFDckQ7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxDQUFnRDtBQUNsRSwrQ0FBK0M7QUFDL0M7QUFDQSxHQUFHLEtBQVUsRUFBRSIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vdnVlLWRpYWxvZy1kcmFnLmNzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlwiKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcImZkMGRhZjI2XCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vdnVlLWRpYWxvZy1kcmFnLmNzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vdnVlLWRpYWxvZy1kcmFnLmNzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlwiKTtcbiAgICAgaWYobmV3Q29udGVudC5fX2VzTW9kdWxlKSBuZXdDb250ZW50ID0gbmV3Q29udGVudC5kZWZhdWx0O1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n")},,,,,,function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.6.11\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n\n/*  */\nvar emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\n\nfunction isUndef(v) {\n  return v === undefined || v === null;\n}\n\nfunction isDef(v) {\n  return v !== undefined && v !== null;\n}\n\nfunction isTrue(v) {\n  return v === true;\n}\n\nfunction isFalse(v) {\n  return v === false;\n}\n/**\n * Check if value is primitive.\n */\n\n\nfunction isPrimitive(value) {\n  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line\n  typeof value === 'symbol' || typeof value === 'boolean';\n}\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\n\n\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n}\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\n\n\nvar _toString = Object.prototype.toString;\n\nfunction toRawType(value) {\n  return _toString.call(value).slice(8, -1);\n}\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\n\n\nfunction isPlainObject(obj) {\n  return _toString.call(obj) === '[object Object]';\n}\n\nfunction isRegExp(v) {\n  return _toString.call(v) === '[object RegExp]';\n}\n/**\n * Check if val is a valid array index.\n */\n\n\nfunction isValidArrayIndex(val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val);\n}\n\nfunction isPromise(val) {\n  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';\n}\n/**\n * Convert a value to a string that is actually rendered.\n */\n\n\nfunction toString(val) {\n  return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);\n}\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\n\n\nfunction toNumber(val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n;\n}\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\n\n\nfunction makeMap(str, expectsLowerCase) {\n  var map = Object.create(null);\n  var list = str.split(',');\n\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n\n  return expectsLowerCase ? function (val) {\n    return map[val.toLowerCase()];\n  } : function (val) {\n    return map[val];\n  };\n}\n/**\n * Check if a tag is a built-in tag.\n */\n\n\nvar isBuiltInTag = makeMap('slot,component', true);\n/**\n * Check if an attribute is a reserved attribute.\n */\n\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n/**\n * Remove an item from an array.\n */\n\nfunction remove(arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n\n    if (index > -1) {\n      return arr.splice(index, 1);\n    }\n  }\n}\n/**\n * Check whether an object has the property.\n */\n\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n/**\n * Create a cached version of a pure function.\n */\n\n\nfunction cached(fn) {\n  var cache = Object.create(null);\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\n/**\n * Camelize a hyphen-delimited string.\n */\n\n\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) {\n    return c ? c.toUpperCase() : '';\n  });\n});\n/**\n * Capitalize a string.\n */\n\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\n/**\n * Hyphenate a camelCase string.\n */\n\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase();\n});\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n\n/* istanbul ignore next */\n\nfunction polyfillBind(fn, ctx) {\n  function boundFn(a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  }\n\n  boundFn._length = fn.length;\n  return boundFn;\n}\n\nfunction nativeBind(fn, ctx) {\n  return fn.bind(ctx);\n}\n\nvar bind = Function.prototype.bind ? nativeBind : polyfillBind;\n/**\n * Convert an Array-like object to a real Array.\n */\n\nfunction toArray(list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n\n  return ret;\n}\n/**\n * Mix properties into target object.\n */\n\n\nfunction extend(to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n\n  return to;\n}\n/**\n * Merge an Array of Objects into a single Object.\n */\n\n\nfunction toObject(arr) {\n  var res = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n\n  return res;\n}\n/* eslint-disable no-unused-vars */\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\n\n\nfunction noop(a, b, c) {}\n/**\n * Always return false.\n */\n\n\nvar no = function (a, b, c) {\n  return false;\n};\n/* eslint-enable no-unused-vars */\n\n/**\n * Return the same value.\n */\n\n\nvar identity = function (_) {\n  return _;\n};\n/**\n * Generate a string containing static keys from compiler modules.\n */\n\n\nfunction genStaticKeys(modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || []);\n  }, []).join(',');\n}\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\n\n\nfunction looseEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i]);\n        });\n      } else if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime();\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key]);\n        });\n      } else {\n        /* istanbul ignore next */\n        return false;\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false;\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b);\n  } else {\n    return false;\n  }\n}\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\n\n\nfunction looseIndexOf(arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * Ensure a function is called only once.\n */\n\n\nfunction once(fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  };\n}\n\nvar SSR_ATTR = 'data-server-rendered';\nvar ASSET_TYPES = ['component', 'directive', 'filter'];\nvar LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"production\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"production\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\n   * This will significantly reduce performance if set to false.\n   */\n  async: true,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n};\n/*  */\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\n\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n/**\n * Check if a string starts with $ or _\n */\n\nfunction isReserved(str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F;\n}\n/**\n * Define a property.\n */\n\n\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n/**\n * Parse simple path.\n */\n\n\nvar bailRE = new RegExp(\"[^\" + unicodeRegExp.source + \".$_\\\\d]\");\n\nfunction parsePath(path) {\n  if (bailRE.test(path)) {\n    return;\n  }\n\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) {\n        return;\n      }\n\n      obj = obj[segments[i]];\n    }\n\n    return obj;\n  };\n}\n/*  */\n// can we use __proto__?\n\n\nvar hasProto = ('__proto__' in {}); // Browser environment sniffing\n\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\nvar isPhantomJS = UA && /phantomjs/.test(UA);\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/); // Firefox has a \"watch\" function on Object.prototype...\n\nvar nativeWatch = {}.watch;\nvar supportsPassive = false;\n\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', {\n      get: function get() {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    }); // https://github.com/facebook/flow/issues/285\n\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n} // this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\n\n\nvar _isServer;\n\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n\n  return _isServer;\n}; // detect devtools\n\n\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n/* istanbul ignore next */\n\nfunction isNative(Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n}\n\nvar hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */\n// $flow-disable-line\n\n\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = /*@__PURE__*/function () {\n    function Set() {\n      this.set = Object.create(null);\n    }\n\n    Set.prototype.has = function has(key) {\n      return this.set[key] === true;\n    };\n\n    Set.prototype.add = function add(key) {\n      this.set[key] = true;\n    };\n\n    Set.prototype.clear = function clear() {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }();\n}\n/*  */\n\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = noop; // work around flow check\n\nvar formatComponentName = noop;\n\nif (false) { var repeat, classify, classifyRE, hasConsole; }\n/*  */\n\n\nvar uid = 0;\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\n\nvar Dep = function Dep() {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub(sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub(sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend() {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify() {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n\n  if (false) {}\n\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n}; // The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\n\n\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget(target) {\n  targetStack.push(target);\n  Dep.target = target;\n}\n\nfunction popTarget() {\n  targetStack.pop();\n  Dep.target = targetStack[targetStack.length - 1];\n}\n/*  */\n\n\nvar VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = {\n  child: {\n    configurable: true\n  }\n}; // DEPRECATED: alias for componentInstance for backwards compat.\n\n/* istanbul ignore next */\n\nprototypeAccessors.child.get = function () {\n  return this.componentInstance;\n};\n\nObject.defineProperties(VNode.prototype, prototypeAccessors);\n\nvar createEmptyVNode = function (text) {\n  if (text === void 0) text = '';\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node;\n};\n\nfunction createTextVNode(val) {\n  return new VNode(undefined, undefined, undefined, String(val));\n} // optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\n\n\nfunction cloneVNode(vnode) {\n  var cloned = new VNode(vnode.tag, vnode.data, // #7975\n  // clone children array to avoid mutating original in case of cloning\n  // a child.\n  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.asyncMeta = vnode.asyncMeta;\n  cloned.isCloned = true;\n  return cloned;\n}\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\nvar methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n/**\n * Intercept mutating methods and emit events\n */\n\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break;\n\n      case 'splice':\n        inserted = args.slice(2);\n        break;\n    }\n\n    if (inserted) {\n      ob.observeArray(inserted);\n    } // notify change\n\n\n    ob.dep.notify();\n    return result;\n  });\n});\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\n\nvar shouldObserve = true;\n\nfunction toggleObserving(value) {\n  shouldObserve = value;\n}\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\n\n\nvar Observer = function Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n\n  if (Array.isArray(value)) {\n    if (hasProto) {\n      protoAugment(value, arrayMethods);\n    } else {\n      copyAugment(value, arrayMethods, arrayKeys);\n    }\n\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n/**\n * Walk through all properties and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\n\n\nObserver.prototype.walk = function walk(obj) {\n  var keys = Object.keys(obj);\n\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i]);\n  }\n};\n/**\n * Observe a list of Array items.\n */\n\n\nObserver.prototype.observeArray = function observeArray(items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n}; // helpers\n\n/**\n * Augment a target Object or Array by intercepting\n * the prototype chain using __proto__\n */\n\n\nfunction protoAugment(target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n/**\n * Augment a target Object or Array by defining\n * hidden properties.\n */\n\n/* istanbul ignore next */\n\n\nfunction copyAugment(target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\n\n\nfunction observe(value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return;\n  }\n\n  var ob;\n\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n    ob = new Observer(value);\n  }\n\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n\n  return ob;\n}\n/**\n * Define a reactive property on an Object.\n */\n\n\nfunction defineReactive$$1(obj, key, val, customSetter, shallow) {\n  var dep = new Dep();\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n\n  if (property && property.configurable === false) {\n    return;\n  } // cater for pre-defined getter/setters\n\n\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key];\n  }\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n\n      if (Dep.target) {\n        dep.depend();\n\n        if (childOb) {\n          childOb.dep.depend();\n\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n\n      if (newVal === value || newVal !== newVal && value !== value) {\n        return;\n      }\n      /* eslint-enable no-self-compare */\n\n\n      if (false) {} // #7981: for accessor properties without setter\n\n\n      if (getter && !setter) {\n        return;\n      }\n\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\n\n\nfunction set(target, key, val) {\n  if (false) {}\n\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val;\n  }\n\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val;\n  }\n\n  var ob = target.__ob__;\n\n  if (target._isVue || ob && ob.vmCount) {\n     false && false;\n    return val;\n  }\n\n  if (!ob) {\n    target[key] = val;\n    return val;\n  }\n\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val;\n}\n/**\n * Delete a property and trigger change if necessary.\n */\n\n\nfunction del(target, key) {\n  if (false) {}\n\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return;\n  }\n\n  var ob = target.__ob__;\n\n  if (target._isVue || ob && ob.vmCount) {\n     false && false;\n    return;\n  }\n\n  if (!hasOwn(target, key)) {\n    return;\n  }\n\n  delete target[key];\n\n  if (!ob) {\n    return;\n  }\n\n  ob.dep.notify();\n}\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\n\n\nfunction dependArray(value) {\n  for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\n\n\nvar strats = config.optionMergeStrategies;\n/**\n * Options with restrictions\n */\n\nif (false) {}\n/**\n * Helper that recursively merges two data objects together.\n */\n\n\nfunction mergeData(to, from) {\n  if (!from) {\n    return to;\n  }\n\n  var key, toVal, fromVal;\n  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i]; // in case the object is already observed...\n\n    if (key === '__ob__') {\n      continue;\n    }\n\n    toVal = to[key];\n    fromVal = from[key];\n\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n\n  return to;\n}\n/**\n * Data\n */\n\n\nfunction mergeDataOrFn(parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal;\n    }\n\n    if (!parentVal) {\n      return childVal;\n    } // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n\n\n    return function mergedDataFn() {\n      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);\n    };\n  } else {\n    return function mergedInstanceDataFn() {\n      // instance merge\n      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;\n      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;\n\n      if (instanceData) {\n        return mergeData(instanceData, defaultData);\n      } else {\n        return defaultData;\n      }\n    };\n  }\n}\n\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n       false && false;\n      return parentVal;\n    }\n\n    return mergeDataOrFn(parentVal, childVal);\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm);\n};\n/**\n * Hooks and props are merged as arrays.\n */\n\n\nfunction mergeHook(parentVal, childVal) {\n  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n  return res ? dedupeHooks(res) : res;\n}\n\nfunction dedupeHooks(hooks) {\n  var res = [];\n\n  for (var i = 0; i < hooks.length; i++) {\n    if (res.indexOf(hooks[i]) === -1) {\n      res.push(hooks[i]);\n    }\n  }\n\n  return res;\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\n\nfunction mergeAssets(parentVal, childVal, vm, key) {\n  var res = Object.create(parentVal || null);\n\n  if (childVal) {\n     false && false;\n    return extend(res, childVal);\n  } else {\n    return res;\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\n\nstrats.watch = function (parentVal, childVal, vm, key) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) {\n    parentVal = undefined;\n  }\n\n  if (childVal === nativeWatch) {\n    childVal = undefined;\n  }\n  /* istanbul ignore if */\n\n\n  if (!childVal) {\n    return Object.create(parentVal || null);\n  }\n\n  if (false) {}\n\n  if (!parentVal) {\n    return childVal;\n  }\n\n  var ret = {};\n  extend(ret, parentVal);\n\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n\n    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n  }\n\n  return ret;\n};\n/**\n * Other object hashes.\n */\n\n\nstrats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {\n  if (childVal && \"production\" !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n\n  if (!parentVal) {\n    return childVal;\n  }\n\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n\n  if (childVal) {\n    extend(ret, childVal);\n  }\n\n  return ret;\n};\n\nstrats.provide = mergeDataOrFn;\n/**\n * Default strategy.\n */\n\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined ? parentVal : childVal;\n};\n/**\n * Validate component names\n */\n\n\nfunction checkComponents(options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName(name) {\n  if (!new RegExp(\"^[a-zA-Z][\\\\-\\\\.0-9_\" + unicodeRegExp.source + \"]*$\").test(name)) {\n    warn('Invalid component name: \"' + name + '\". Component names ' + 'should conform to valid custom element name in html5 specification.');\n  }\n\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);\n  }\n}\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\n\n\nfunction normalizeProps(options, vm) {\n  var props = options.props;\n\n  if (!props) {\n    return;\n  }\n\n  var res = {};\n  var i, val, name;\n\n  if (Array.isArray(props)) {\n    i = props.length;\n\n    while (i--) {\n      val = props[i];\n\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = {\n          type: null\n        };\n      } else if (false) {}\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val) ? val : {\n        type: val\n      };\n    }\n  } else if (false) {}\n\n  options.props = res;\n}\n/**\n * Normalize all injections into Object-based format\n */\n\n\nfunction normalizeInject(options, vm) {\n  var inject = options.inject;\n\n  if (!inject) {\n    return;\n  }\n\n  var normalized = options.inject = {};\n\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = {\n        from: inject[i]\n      };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val) ? extend({\n        from: key\n      }, val) : {\n        from: val\n      };\n    }\n  } else if (false) {}\n}\n/**\n * Normalize raw function directives into object format.\n */\n\n\nfunction normalizeDirectives(options) {\n  var dirs = options.directives;\n\n  if (dirs) {\n    for (var key in dirs) {\n      var def$$1 = dirs[key];\n\n      if (typeof def$$1 === 'function') {\n        dirs[key] = {\n          bind: def$$1,\n          update: def$$1\n        };\n      }\n    }\n  }\n}\n\nfunction assertObjectType(name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" + \"but got \" + toRawType(value) + \".\", vm);\n  }\n}\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\n\n\nfunction mergeOptions(parent, child, vm) {\n  if (false) {}\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child); // Apply extends and mixins on the child options,\n  // but only if it is a raw options object that isn't\n  // the result of another mergeOptions call.\n  // Only merged options has the _base property.\n\n  if (!child._base) {\n    if (child.extends) {\n      parent = mergeOptions(parent, child.extends, vm);\n    }\n\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n  }\n\n  var options = {};\n  var key;\n\n  for (key in parent) {\n    mergeField(key);\n  }\n\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n\n  function mergeField(key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n\n  return options;\n}\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\n\n\nfunction resolveAsset(options, type, id, warnMissing) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return;\n  }\n\n  var assets = options[type]; // check local registration variations first\n\n  if (hasOwn(assets, id)) {\n    return assets[id];\n  }\n\n  var camelizedId = camelize(id);\n\n  if (hasOwn(assets, camelizedId)) {\n    return assets[camelizedId];\n  }\n\n  var PascalCaseId = capitalize(camelizedId);\n\n  if (hasOwn(assets, PascalCaseId)) {\n    return assets[PascalCaseId];\n  } // fallback to prototype chain\n\n\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\n  if (false) {}\n\n  return res;\n}\n/*  */\n\n\nfunction validateProp(key, propOptions, propsData, vm) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key]; // boolean casting\n\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  } // check default value\n\n\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,\n    // make sure to observe it.\n\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n\n  if (false) {}\n\n  return value;\n}\n/**\n * Get the default value of a prop.\n */\n\n\nfunction getPropDefaultValue(vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined;\n  }\n\n  var def = prop.default; // warn against non-factory defaults for Object & Array\n\n  if (false) {} // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n\n\n  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n    return vm._props[key];\n  } // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n\n\n  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n}\n/**\n * Assert whether a prop is valid.\n */\n\n\nfunction assertProp(prop, name, value, vm, absent) {\n  if (prop.required && absent) {\n    warn('Missing required prop: \"' + name + '\"', vm);\n    return;\n  }\n\n  if (value == null && !prop.required) {\n    return;\n  }\n\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n\n  if (!valid) {\n    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);\n    return;\n  }\n\n  var validator = prop.validator;\n\n  if (validator) {\n    if (!validator(value)) {\n      warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType(value, type) {\n  var valid;\n  var expectedType = getType(type);\n\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects\n\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n\n  return {\n    valid: valid,\n    expectedType: expectedType\n  };\n}\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\n\n\nfunction getType(fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : '';\n}\n\nfunction isSameType(a, b) {\n  return getType(a) === getType(b);\n}\n\nfunction getTypeIndex(type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1;\n  }\n\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n  var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" + \" Expected \" + expectedTypes.map(capitalize).join(', ');\n  var expectedType = expectedTypes[0];\n  var receivedType = toRawType(value);\n  var expectedValue = styleValue(value, expectedType);\n  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value\n\n  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {\n    message += \" with value \" + expectedValue;\n  }\n\n  message += \", got \" + receivedType + \" \"; // check if we need to specify received value\n\n  if (isExplicable(receivedType)) {\n    message += \"with value \" + receivedValue + \".\";\n  }\n\n  return message;\n}\n\nfunction styleValue(value, type) {\n  if (type === 'String') {\n    return \"\\\"\" + value + \"\\\"\";\n  } else if (type === 'Number') {\n    return \"\" + Number(value);\n  } else {\n    return \"\" + value;\n  }\n}\n\nfunction isExplicable(value) {\n  var explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(function (elem) {\n    return value.toLowerCase() === elem;\n  });\n}\n\nfunction isBoolean() {\n  var args = [],\n      len = arguments.length;\n\n  while (len--) args[len] = arguments[len];\n\n  return args.some(function (elem) {\n    return elem.toLowerCase() === 'boolean';\n  });\n}\n/*  */\n\n\nfunction handleError(err, vm, info) {\n  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n  // See: https://github.com/vuejs/vuex/issues/1505\n  pushTarget();\n\n  try {\n    if (vm) {\n      var cur = vm;\n\n      while (cur = cur.$parent) {\n        var hooks = cur.$options.errorCaptured;\n\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n\n              if (capture) {\n                return;\n              }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n\n    globalHandleError(err, vm, info);\n  } finally {\n    popTarget();\n  }\n}\n\nfunction invokeWithErrorHandling(handler, context, args, vm, info) {\n  var res;\n\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context);\n\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res.catch(function (e) {\n        return handleError(e, vm, info + \" (Promise/async)\");\n      }); // issue #9511\n      // avoid catch triggering multiple times when nested calls\n\n      res._handled = true;\n    }\n  } catch (e) {\n    handleError(e, vm, info);\n  }\n\n  return res;\n}\n\nfunction globalHandleError(err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info);\n    } catch (e) {\n      // if the user intentionally throws the original error in the handler,\n      // do not log it twice\n      if (e !== err) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n  }\n\n  logError(err, vm, info);\n}\n\nfunction logError(err, vm, info) {\n  if (false) {}\n  /* istanbul ignore else */\n\n\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err;\n  }\n}\n/*  */\n\n\nvar isUsingMicroTask = false;\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks() {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n} // Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\n\n\nvar timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n\n/* istanbul ignore next, $flow-disable-line */\n\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n\n  timerFunc = function () {\n    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n\n    if (isIOS) {\n      setTimeout(noop);\n    }\n  };\n\n  isUsingMicroTask = true;\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x\nMutationObserver.toString() === '[object MutationObserverConstructor]')) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  var counter = 1;\n  var observer = new MutationObserver(flushCallbacks);\n  var textNode = document.createTextNode(String(counter));\n  observer.observe(textNode, {\n    characterData: true\n  });\n\n  timerFunc = function () {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n\n  isUsingMicroTask = true;\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Technically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // Fallback to setTimeout.\n  timerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\nfunction nextTick(cb, ctx) {\n  var _resolve;\n\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  } // $flow-disable-line\n\n\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    });\n  }\n}\n/*  */\n\n\nvar mark;\nvar measure;\n\nif (false) { var perf; }\n/* not type checking this file because flow doesn't play well with Proxy */\n\n\nvar initProxy;\n\nif (false) { var getHandler, hasHandler, isBuiltInModifier, hasProxy, warnReservedPrefix, warnNonPresent, allowedGlobals; }\n/*  */\n\n\nvar seenObjects = new _Set();\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\n\nfunction traverse(val) {\n  _traverse(val, seenObjects);\n\n  seenObjects.clear();\n}\n\nfunction _traverse(val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n\n  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {\n    return;\n  }\n\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n\n    if (seen.has(depId)) {\n      return;\n    }\n\n    seen.add(depId);\n  }\n\n  if (isA) {\n    i = val.length;\n\n    while (i--) {\n      _traverse(val[i], seen);\n    }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n\n    while (i--) {\n      _traverse(val[keys[i]], seen);\n    }\n  }\n}\n/*  */\n\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  };\n});\n\nfunction createFnInvoker(fns, vm) {\n  function invoker() {\n    var arguments$1 = arguments;\n    var fns = invoker.fns;\n\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n\n      for (var i = 0; i < cloned.length; i++) {\n        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n      }\n    } else {\n      // return handler return value for single handlers\n      return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\");\n    }\n  }\n\n  invoker.fns = fns;\n  return invoker;\n}\n\nfunction updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {\n  var name, def$$1, cur, old, event;\n\n  for (name in on) {\n    def$$1 = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n\n    if (isUndef(cur)) {\n       false && false;\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur, vm);\n      }\n\n      if (isTrue(event.once)) {\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n      }\n\n      add(event.name, cur, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n/*  */\n\n\nfunction mergeVNodeHook(def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook() {\n    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n/*  */\n\n\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n\n  if (isUndef(propOptions)) {\n    return;\n  }\n\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n\n      if (false) { var keyInLowerCase; }\n\n      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n    }\n  }\n\n  return res;\n}\n\nfunction checkProp(res, hash, key, altKey, preserve) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n\n      if (!preserve) {\n        delete hash[key];\n      }\n\n      return true;\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n\n      if (!preserve) {\n        delete hash[altKey];\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n/*  */\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\n\n\nfunction simpleNormalizeChildren(children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children);\n    }\n  }\n\n  return children;\n} // 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\n\n\nfunction normalizeChildren(children) {\n  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n}\n\nfunction isTextNode(node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n}\n\nfunction normalizeArrayChildren(children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n\n    if (isUndef(c) || typeof c === 'boolean') {\n      continue;\n    }\n\n    lastIndex = res.length - 1;\n    last = res[lastIndex]; //  nested\n\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i); // merge adjacent text nodes\n\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + c[0].text);\n          c.shift();\n        }\n\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n\n        res.push(c);\n      }\n    }\n  }\n\n  return res;\n}\n/*  */\n\n\nfunction initProvide(vm) {\n  var provide = vm.$options.provide;\n\n  if (provide) {\n    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n  }\n}\n\nfunction initInjections(vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (false) {} else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject(inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]; // #6574 in case the inject object is observed...\n\n      if (key === '__ob__') {\n        continue;\n      }\n\n      var provideKey = inject[key].from;\n      var source = vm;\n\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break;\n        }\n\n        source = source.$parent;\n      }\n\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;\n        } else if (false) {}\n      }\n    }\n\n    return result;\n  }\n}\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\n\n\nfunction resolveSlots(children, context) {\n  if (!children || !children.length) {\n    return {};\n  }\n\n  var slots = {};\n\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node\n\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    } // named slots should only be respected if the vnode was rendered in the\n    // same context.\n\n\n    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {\n      var name = data.slot;\n      var slot = slots[name] || (slots[name] = []);\n\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  } // ignore slots that contains only whitespace\n\n\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n\n  return slots;\n}\n\nfunction isWhitespace(node) {\n  return node.isComment && !node.asyncFactory || node.text === ' ';\n}\n/*  */\n\n\nfunction normalizeScopedSlots(slots, normalSlots, prevSlots) {\n  var res;\n  var hasNormalSlots = Object.keys(normalSlots).length > 0;\n  var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n  var key = slots && slots.$key;\n\n  if (!slots) {\n    res = {};\n  } else if (slots._normalized) {\n    // fast path 1: child component re-render only, parent did not change\n    return slots._normalized;\n  } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {\n    // fast path 2: stable scoped slots w/ no normal slots to proxy,\n    // only need to normalize once\n    return prevSlots;\n  } else {\n    res = {};\n\n    for (var key$1 in slots) {\n      if (slots[key$1] && key$1[0] !== '$') {\n        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n      }\n    }\n  } // expose normal slots on scopedSlots\n\n\n  for (var key$2 in normalSlots) {\n    if (!(key$2 in res)) {\n      res[key$2] = proxyNormalSlot(normalSlots, key$2);\n    }\n  } // avoriaz seems to mock a non-extensible $scopedSlots object\n  // and when that is passed down this would cause an error\n\n\n  if (slots && Object.isExtensible(slots)) {\n    slots._normalized = res;\n  }\n\n  def(res, '$stable', isStable);\n  def(res, '$key', key);\n  def(res, '$hasNormal', hasNormalSlots);\n  return res;\n}\n\nfunction normalizeScopedSlot(normalSlots, key, fn) {\n  var normalized = function () {\n    var res = arguments.length ? fn.apply(null, arguments) : fn({});\n    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode\n    : normalizeChildren(res);\n    return res && (res.length === 0 || res.length === 1 && res[0].isComment // #9658\n    ) ? undefined : res;\n  }; // this is a slot using the new v-slot syntax without scope. although it is\n  // compiled as a scoped slot, render fn users would expect it to be present\n  // on this.$slots because the usage is semantically a normal slot.\n\n\n  if (fn.proxy) {\n    Object.defineProperty(normalSlots, key, {\n      get: normalized,\n      enumerable: true,\n      configurable: true\n    });\n  }\n\n  return normalized;\n}\n\nfunction proxyNormalSlot(slots, key) {\n  return function () {\n    return slots[key];\n  };\n}\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\n\n\nfunction renderList(val, render) {\n  var ret, i, l, keys, key;\n\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    if (hasSymbol && val[Symbol.iterator]) {\n      ret = [];\n      var iterator = val[Symbol.iterator]();\n      var result = iterator.next();\n\n      while (!result.done) {\n        ret.push(render(result.value, ret.length));\n        result = iterator.next();\n      }\n    } else {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n  }\n\n  if (!isDef(ret)) {\n    ret = [];\n  }\n\n  ret._isVList = true;\n  return ret;\n}\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\n\n\nfunction renderSlot(name, fallback, props, bindObject) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n\n  if (scopedSlotFn) {\n    // scoped slot\n    props = props || {};\n\n    if (bindObject) {\n      if (false) {}\n\n      props = extend(extend({}, bindObject), props);\n    }\n\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    nodes = this.$slots[name] || fallback;\n  }\n\n  var target = props && props.slot;\n\n  if (target) {\n    return this.$createElement('template', {\n      slot: target\n    }, nodes);\n  } else {\n    return nodes;\n  }\n}\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\n\n\nfunction resolveFilter(id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity;\n}\n/*  */\n\n\nfunction isKeyNotMatch(expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1;\n  } else {\n    return expect !== actual;\n  }\n}\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\n\n\nfunction checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName);\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key;\n  }\n}\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\n\n\nfunction bindObjectProps(data, tag, value, asProp, isSync) {\n  if (value) {\n    if (!isObject(value)) {\n       false && false;\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n\n      var hash;\n\n      var loop = function (key) {\n        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n        }\n\n        var camelizedKey = camelize(key);\n        var hyphenatedKey = hyphenate(key);\n\n        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n\n            on[\"update:\" + key] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop(key);\n    }\n  }\n\n  return data;\n}\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\n\n\nfunction renderStatic(index, isInFor) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n\n  if (tree && !isInFor) {\n    return tree;\n  } // otherwise, render a fresh tree.\n\n\n  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates\n  );\n  markStatic(tree, \"__static__\" + index, false);\n  return tree;\n}\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\n\n\nfunction markOnce(tree, index, key) {\n  markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n  return tree;\n}\n\nfunction markStatic(tree, key, isOnce) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], key + \"_\" + i, isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode(node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n/*  */\n\n\nfunction bindObjectListeners(data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n       false && false;\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n\n  return data;\n}\n/*  */\n\n\nfunction resolveScopedSlots(fns, // see flow/vnode\nres, // the following are added in 2.6\nhasDynamicKeys, contentHashKey) {\n  res = res || {\n    $stable: !hasDynamicKeys\n  };\n\n  for (var i = 0; i < fns.length; i++) {\n    var slot = fns[i];\n\n    if (Array.isArray(slot)) {\n      resolveScopedSlots(slot, res, hasDynamicKeys);\n    } else if (slot) {\n      // marker for reverse proxying v-slot without scope on this.$slots\n      if (slot.proxy) {\n        slot.fn.proxy = true;\n      }\n\n      res[slot.key] = slot.fn;\n    }\n  }\n\n  if (contentHashKey) {\n    res.$key = contentHashKey;\n  }\n\n  return res;\n}\n/*  */\n\n\nfunction bindDynamicKeys(baseObj, values) {\n  for (var i = 0; i < values.length; i += 2) {\n    var key = values[i];\n\n    if (typeof key === 'string' && key) {\n      baseObj[values[i]] = values[i + 1];\n    } else if (false) {}\n  }\n\n  return baseObj;\n} // helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\n\n\nfunction prependModifier(value, symbol) {\n  return typeof value === 'string' ? symbol + value : value;\n}\n/*  */\n\n\nfunction installRenderHelpers(target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n  target._d = bindDynamicKeys;\n  target._p = prependModifier;\n}\n/*  */\n\n\nfunction FunctionalRenderContext(data, props, children, parent, Ctor) {\n  var this$1 = this;\n  var options = Ctor.options; // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n\n  var contextVm;\n\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent); // $flow-disable-line\n\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent; // $flow-disable-line\n\n    parent = parent._original;\n  }\n\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n\n  this.slots = function () {\n    if (!this$1.$slots) {\n      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));\n    }\n\n    return this$1.$slots;\n  };\n\n  Object.defineProperty(this, 'scopedSlots', {\n    enumerable: true,\n    get: function get() {\n      return normalizeScopedSlots(data.scopedSlots, this.slots());\n    }\n  }); // support for compiled functional template\n\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options; // pre-resolve slots for renderSlot()\n\n    this.$slots = this.slots();\n    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n\n      return vnode;\n    };\n  } else {\n    this._c = function (a, b, c, d) {\n      return createElement(contextVm, a, b, c, d, needNormalization);\n    };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) {\n      mergeProps(props, data.attrs);\n    }\n\n    if (isDef(data.props)) {\n      mergeProps(props, data.props);\n    }\n  }\n\n  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n    }\n\n    return res;\n  }\n}\n\nfunction cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n\n  if (false) {}\n\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n\n  return clone;\n}\n\nfunction mergeProps(to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n// inline hooks to be invoked on component VNodes during patch\n\n\nvar componentVNodeHooks = {\n  init: function init(vnode, hydrating) {\n    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n  prepatch: function prepatch(oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(child, options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n    );\n  },\n  insert: function insert(vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true\n        /* direct */\n        );\n      }\n    }\n  },\n  destroy: function destroy(vnode) {\n    var componentInstance = vnode.componentInstance;\n\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true\n        /* direct */\n        );\n      }\n    }\n  }\n};\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent(Ctor, data, context, children, tag) {\n  if (isUndef(Ctor)) {\n    return;\n  }\n\n  var baseCtor = context.$options._base; // plain options object: turn it into a constructor\n\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  } // if at this stage it's not a constructor or an async component factory,\n  // reject.\n\n\n  if (typeof Ctor !== 'function') {\n    if (false) {}\n\n    return;\n  } // async component\n\n\n  var asyncFactory;\n\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n    }\n  }\n\n  data = data || {}; // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n\n  resolveConstructorOptions(Ctor); // transform component v-model data into props & events\n\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  } // extract props\n\n\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component\n\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children);\n  } // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n\n\n  var listeners = data.on; // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n    // work around flow\n    var slot = data.slot;\n    data = {};\n\n    if (slot) {\n      data.slot = slot;\n    }\n  } // install component management hooks onto the placeholder node\n\n\n  installComponentHooks(data); // return a placeholder vnode\n\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, {\n    Ctor: Ctor,\n    propsData: propsData,\n    listeners: listeners,\n    tag: tag,\n    children: children\n  }, asyncFactory);\n  return vnode;\n}\n\nfunction createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\nparent // activeInstance in lifecycle state\n) {\n  var options = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent: parent\n  }; // check inline-template render functions\n\n  var inlineTemplate = vnode.data.inlineTemplate;\n\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n\n  return new vnode.componentOptions.Ctor(options);\n}\n\nfunction installComponentHooks(data) {\n  var hooks = data.hook || (data.hook = {});\n\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var existing = hooks[key];\n    var toMerge = componentVNodeHooks[key];\n\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n    }\n  }\n}\n\nfunction mergeHook$1(f1, f2) {\n  var merged = function (a, b) {\n    // flow complains about extra args which is why we use any\n    f1(a, b);\n    f2(a, b);\n  };\n\n  merged._merged = true;\n  return merged;\n} // transform component v-model info (value and callback) into\n// prop and event handler respectively.\n\n\nfunction transformModel(options, data) {\n  var prop = options.model && options.model.prop || 'value';\n  var event = options.model && options.model.event || 'input';\n  (data.attrs || (data.attrs = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  var existing = on[event];\n  var callback = data.model.callback;\n\n  if (isDef(existing)) {\n    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {\n      on[event] = [callback].concat(existing);\n    }\n  } else {\n    on[event] = callback;\n  }\n}\n/*  */\n\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface\n// without getting yelled at by flow\n\nfunction createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n\n  return _createElement(context, tag, data, children, normalizationType);\n}\n\nfunction _createElement(context, tag, data, children, normalizationType) {\n  if (isDef(data) && isDef(data.__ob__)) {\n     false && false;\n    return createEmptyVNode();\n  } // object syntax in v-bind\n\n\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode();\n  } // warn against non-primitive key\n\n\n  if (false) {} // support single function children as default scoped slot\n\n\n  if (Array.isArray(children) && typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = {\n      default: children[0]\n    };\n    children.length = 0;\n  }\n\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n\n  var vnode, ns;\n\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);\n\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      if (false) {}\n\n      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(tag, data, children, undefined, undefined, context);\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n\n  if (Array.isArray(vnode)) {\n    return vnode;\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) {\n      applyNS(vnode, ns);\n    }\n\n    if (isDef(data)) {\n      registerDeepBindings(data);\n    }\n\n    return vnode;\n  } else {\n    return createEmptyVNode();\n  }\n}\n\nfunction applyNS(vnode, ns, force) {\n  vnode.ns = ns;\n\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n\n      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n} // ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\n\n\nfunction registerDeepBindings(data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n/*  */\n\n\nfunction initRender(vm) {\n  vm._vnode = null; // the root of the child tree\n\n  vm._staticTrees = null; // v-once cached trees\n\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n\n  vm._c = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, false);\n  }; // normalization is always applied for the public version, used in\n  // user-written render functions.\n\n\n  vm.$createElement = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, true);\n  }; // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n\n\n  var parentData = parentVnode && parentVnode.data;\n  /* istanbul ignore else */\n\n  if (false) {} else {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, null, true);\n  }\n}\n\nvar currentRenderingInstance = null;\n\nfunction renderMixin(Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this);\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\n    } // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n\n\n    vm.$vnode = _parentVnode; // render self\n\n    var vnode;\n\n    try {\n      // There's no need to maintain a stack because all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm;\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\"); // return error render result,\n      // or previous vnode to prevent render error causing blank component\n\n      /* istanbul ignore else */\n\n      if (false) {} else {\n        vnode = vm._vnode;\n      }\n    } finally {\n      currentRenderingInstance = null;\n    } // if the returned array contains only a single node, allow it\n\n\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0];\n    } // return empty vnode in case the render function errored out\n\n\n    if (!(vnode instanceof VNode)) {\n      if (false) {}\n\n      vnode = createEmptyVNode();\n    } // set parent\n\n\n    vnode.parent = _parentVnode;\n    return vnode;\n  };\n}\n/*  */\n\n\nfunction ensureCtor(comp, base) {\n  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {\n    comp = comp.default;\n  }\n\n  return isObject(comp) ? base.extend(comp) : comp;\n}\n\nfunction createAsyncPlaceholder(factory, data, context, children, tag) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = {\n    data: data,\n    context: context,\n    children: children,\n    tag: tag\n  };\n  return node;\n}\n\nfunction resolveAsyncComponent(factory, baseCtor) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp;\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved;\n  }\n\n  var owner = currentRenderingInstance;\n\n  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n    // already pending\n    factory.owners.push(owner);\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp;\n  }\n\n  if (owner && !isDef(factory.owners)) {\n    var owners = factory.owners = [owner];\n    var sync = true;\n    var timerLoading = null;\n    var timerTimeout = null;\n    owner.$on('hook:destroyed', function () {\n      return remove(owners, owner);\n    });\n\n    var forceRender = function (renderCompleted) {\n      for (var i = 0, l = owners.length; i < l; i++) {\n        owners[i].$forceUpdate();\n      }\n\n      if (renderCompleted) {\n        owners.length = 0;\n\n        if (timerLoading !== null) {\n          clearTimeout(timerLoading);\n          timerLoading = null;\n        }\n\n        if (timerTimeout !== null) {\n          clearTimeout(timerTimeout);\n          timerTimeout = null;\n        }\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n\n      if (!sync) {\n        forceRender(true);\n      } else {\n        owners.length = 0;\n      }\n    });\n    var reject = once(function (reason) {\n       false && false;\n\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender(true);\n      }\n    });\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (isPromise(res)) {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isPromise(res.component)) {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            timerLoading = setTimeout(function () {\n              timerLoading = null;\n\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender(false);\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          timerTimeout = setTimeout(function () {\n            timerTimeout = null;\n\n            if (isUndef(factory.resolved)) {\n              reject( false ? undefined : null);\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false; // return in case resolved synchronously\n\n    return factory.loading ? factory.loadingComp : factory.resolved;\n  }\n}\n/*  */\n\n\nfunction isAsyncPlaceholder(node) {\n  return node.isComment && node.asyncFactory;\n}\n/*  */\n\n\nfunction getFirstComponentChild(children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c;\n      }\n    }\n  }\n}\n/*  */\n\n/*  */\n\n\nfunction initEvents(vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false; // init parent attached events\n\n  var listeners = vm.$options._parentListeners;\n\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add(event, fn) {\n  target.$on(event, fn);\n}\n\nfunction remove$1(event, fn) {\n  target.$off(event, fn);\n}\n\nfunction createOnceHandler(event, fn) {\n  var _target = target;\n  return function onceHandler() {\n    var res = fn.apply(null, arguments);\n\n    if (res !== null) {\n      _target.$off(event, onceHandler);\n    }\n  };\n}\n\nfunction updateComponentListeners(vm, listeners, oldListeners) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n  target = undefined;\n}\n\nfunction eventsMixin(Vue) {\n  var hookRE = /^hook:/;\n\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;\n\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        vm.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n\n    return vm;\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n\n    function on() {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm;\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this; // all\n\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm;\n    } // array of events\n\n\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        vm.$off(event[i$1], fn);\n      }\n\n      return vm;\n    } // specific event\n\n\n    var cbs = vm._events[event];\n\n    if (!cbs) {\n      return vm;\n    }\n\n    if (!fn) {\n      vm._events[event] = null;\n      return vm;\n    } // specific handler\n\n\n    var cb;\n    var i = cbs.length;\n\n    while (i--) {\n      cb = cbs[i];\n\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break;\n      }\n    }\n\n    return vm;\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n\n    if (false) { var lowerCaseEvent; }\n\n    var cbs = vm._events[event];\n\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      var info = \"event handler for \\\"\" + event + \"\\\"\";\n\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n      }\n    }\n\n    return vm;\n  };\n}\n/*  */\n\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction setActiveInstance(vm) {\n  var prevActiveInstance = activeInstance;\n  activeInstance = vm;\n  return function () {\n    activeInstance = prevActiveInstance;\n  };\n}\n\nfunction initLifecycle(vm) {\n  var options = vm.$options; // locate first non-abstract parent\n\n  var parent = options.parent;\n\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n  vm.$children = [];\n  vm.$refs = {};\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var restoreActiveInstance = setActiveInstance(vm);\n    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false\n      /* removeOnly */\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n\n    restoreActiveInstance(); // update __vue__ reference\n\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    } // if parent is an HOC, update its $el as well\n\n\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    } // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n\n    if (vm._isBeingDestroyed) {\n      return;\n    }\n\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true; // remove self from parent\n\n    var parent = vm.$parent;\n\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    } // teardown watchers\n\n\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n\n    var i = vm._watchers.length;\n\n    while (i--) {\n      vm._watchers[i].teardown();\n    } // remove reference from data ob\n    // frozen object may not have observer.\n\n\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    } // call the last hook...\n\n\n    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree\n\n    vm.__patch__(vm._vnode, null); // fire destroyed hook\n\n\n    callHook(vm, 'destroyed'); // turn off all instance listeners.\n\n    vm.$off(); // remove __vue__ reference\n\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    } // release circular reference (#6759)\n\n\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent(vm, el, hydrating) {\n  vm.$el = el;\n\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n\n    if (false) {}\n  }\n\n  callHook(vm, 'beforeMount');\n  var updateComponent;\n  /* istanbul ignore if */\n\n  if (false) {} else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  } // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n\n\n  new Watcher(vm, updateComponent, noop, {\n    before: function before() {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate');\n      }\n    }\n  }, true\n  /* isRenderWatcher */\n  );\n  hydrating = false; // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n\n  return vm;\n}\n\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n  if (false) {} // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren.\n  // check if there are dynamic scopedSlots (hand-written or compiled but with\n  // dynamic slot names). Static scoped slots compiled from template has the\n  // \"$stable\" marker.\n\n\n  var newScopedSlots = parentVnode.data.scopedSlots;\n  var oldScopedSlots = vm.$scopedSlots;\n  var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key); // Any static slot children from the parent may have changed during parent's\n  // update. Dynamic scoped slots may also have changed. In such cases, a forced\n  // update is necessary to ensure correctness.\n\n  var needsForceUpdate = !!(renderChildren || // has new static slots\n  vm.$options._renderChildren || // has old static slots\n  hasDynamicScopedSlot);\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) {\n    // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n\n  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject; // update props\n\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n\n    toggleObserving(true); // keep a copy of raw propsData\n\n    vm.$options.propsData = propsData;\n  } // update listeners\n\n\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children\n\n  if (needsForceUpdate) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (false) {}\n}\n\nfunction isInInactiveTree(vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction activateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  } else if (vm._directInactive) {\n    return;\n  }\n\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  }\n\n  if (!vm._inactive) {\n    vm._inactive = true;\n\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook(vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  var info = hook + \" hook\";\n\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n    }\n  }\n\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n\n  popTarget();\n}\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n/**\n * Reset the scheduler's state.\n */\n\nfunction resetSchedulerState() {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n\n  if (false) {}\n\n  waiting = flushing = false;\n} // Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\n\n\nvar currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.\n\nvar getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\n\nif (inBrowser && !isIE) {\n  var performance = window.performance;\n\n  if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {\n    // if the event timestamp, although evaluated AFTER the Date.now(), is\n    // smaller than it, it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listener timestamps as\n    // well.\n    getNow = function () {\n      return performance.now();\n    };\n  }\n}\n/**\n * Flush both queues and run the watchers.\n */\n\n\nfunction flushSchedulerQueue() {\n  currentFlushTimestamp = getNow();\n  flushing = true;\n  var watcher, id; // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n\n  queue.sort(function (a, b) {\n    return a.id - b.id;\n  }); // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n\n    if (watcher.before) {\n      watcher.before();\n    }\n\n    id = watcher.id;\n    has[id] = null;\n    watcher.run(); // in dev build, check and stop circular updates.\n\n    if (false) {}\n  } // keep copies of post queues before resetting state\n\n\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n  resetSchedulerState(); // call component updated and activated hooks\n\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue); // devtool hook\n\n  /* istanbul ignore if */\n\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks(queue) {\n  var i = queue.length;\n\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n\n    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\n\n\nfunction queueActivatedComponent(vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true\n    /* true */\n    );\n  }\n}\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\n\n\nfunction queueWatcher(watcher) {\n  var id = watcher.id;\n\n  if (has[id] == null) {\n    has[id] = true;\n\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n\n      queue.splice(i + 1, 0, watcher);\n    } // queue the flush\n\n\n    if (!waiting) {\n      waiting = true;\n\n      if (false) {}\n\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n/*  */\n\n\nvar uid$2 = 0;\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\n\nvar Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n  this.vm = vm;\n\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n\n  vm._watchers.push(this); // options\n\n\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n    this.before = options.before;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  false ? undefined : ''; // parse expression for getter\n\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n\n    if (!this.getter) {\n      this.getter = noop;\n       false && false;\n    }\n  }\n\n  this.value = this.lazy ? undefined : this.get();\n};\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\n\n\nWatcher.prototype.get = function get() {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n    } else {\n      throw e;\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n\n    popTarget();\n    this.cleanupDeps();\n  }\n\n  return value;\n};\n/**\n * Add a dependency to this directive.\n */\n\n\nWatcher.prototype.addDep = function addDep(dep) {\n  var id = dep.id;\n\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n/**\n * Clean up for dependency collection.\n */\n\n\nWatcher.prototype.cleanupDeps = function cleanupDeps() {\n  var i = this.deps.length;\n\n  while (i--) {\n    var dep = this.deps[i];\n\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\n\n\nWatcher.prototype.update = function update() {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\n\n\nWatcher.prototype.run = function run() {\n  if (this.active) {\n    var value = this.get();\n\n    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even\n    // when the value is the same, because the value may\n    // have mutated.\n    isObject(value) || this.deep) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\n\n\nWatcher.prototype.evaluate = function evaluate() {\n  this.value = this.get();\n  this.dirty = false;\n};\n/**\n * Depend on all deps collected by this watcher.\n */\n\n\nWatcher.prototype.depend = function depend() {\n  var i = this.deps.length;\n\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n/**\n * Remove self from all dependencies' subscriber list.\n */\n\n\nWatcher.prototype.teardown = function teardown() {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n\n    var i = this.deps.length;\n\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n\n    this.active = false;\n  }\n};\n/*  */\n\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy(target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter() {\n    return this[sourceKey][key];\n  };\n\n  sharedPropertyDefinition.set = function proxySetter(val) {\n    this[sourceKey][key] = val;\n  };\n\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState(vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n\n  if (opts.props) {\n    initProps(vm, opts.props);\n  }\n\n  if (opts.methods) {\n    initMethods(vm, opts.methods);\n  }\n\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true\n    /* asRootData */\n    );\n  }\n\n  if (opts.computed) {\n    initComputed(vm, opts.computed);\n  }\n\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps(vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent; // root instance props should be converted\n\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n\n  var loop = function (key) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n\n    if (false) { var hyphenatedKey; } else {\n      defineReactive$$1(props, key, value);\n    } // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n\n\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop(key);\n\n  toggleObserving(true);\n}\n\nfunction initData(vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n\n  if (!isPlainObject(data)) {\n    data = {};\n     false && false;\n  } // proxy data on instance\n\n\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n\n  while (i--) {\n    var key = keys[i];\n\n    if (false) {}\n\n    if (props && hasOwn(props, key)) {\n       false && false;\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  } // observe data\n\n\n  observe(data, true\n  /* asRootData */\n  );\n}\n\nfunction getData(data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n\n  try {\n    return data.call(vm, vm);\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {};\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = {\n  lazy: true\n};\n\nfunction initComputed(vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR\n\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n\n    if (false) {}\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n    } // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n\n\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (false) {}\n  }\n}\n\nfunction defineComputed(target, key, userDef) {\n  var shouldCache = !isServerRendering();\n\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;\n    sharedPropertyDefinition.set = userDef.set || noop;\n  }\n\n  if (false) {}\n\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter(key) {\n  return function computedGetter() {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n\n      if (Dep.target) {\n        watcher.depend();\n      }\n\n      return watcher.value;\n    }\n  };\n}\n\nfunction createGetterInvoker(fn) {\n  return function computedGetter() {\n    return fn.call(this, this);\n  };\n}\n\nfunction initMethods(vm, methods) {\n  var props = vm.$options.props;\n\n  for (var key in methods) {\n    if (false) {}\n\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch(vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher(vm, expOrFn, handler, options) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n\n  return vm.$watch(expOrFn, handler, options);\n}\n\nfunction stateMixin(Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n\n  dataDef.get = function () {\n    return this._data;\n  };\n\n  var propsDef = {};\n\n  propsDef.get = function () {\n    return this._props;\n  };\n\n  if (false) {}\n\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (expOrFn, cb, options) {\n    var vm = this;\n\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options);\n    }\n\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value);\n      } catch (error) {\n        handleError(error, vm, \"callback for immediate watcher \\\"\" + watcher.expression + \"\\\"\");\n      }\n    }\n\n    return function unwatchFn() {\n      watcher.teardown();\n    };\n  };\n}\n/*  */\n\n\nvar uid$3 = 0;\n\nfunction initMixin(Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this; // a uid\n\n    vm._uid = uid$3++;\n    var startTag, endTag;\n    /* istanbul ignore if */\n\n    if (false) {} // a flag to avoid this being observed\n\n\n    vm._isVue = true; // merge options\n\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n    }\n    /* istanbul ignore else */\n\n\n    if (false) {} else {\n      vm._renderProxy = vm;\n    } // expose real self\n\n\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n\n    callHook(vm, 'created');\n    /* istanbul ignore if */\n\n    if (false) {}\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent(vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.\n\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions(Ctor) {\n  var options = Ctor.options;\n\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)\n\n      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options\n\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n\n  return options;\n}\n\nfunction resolveModifiedOptions(Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) {\n        modified = {};\n      }\n\n      modified[key] = latest[key];\n    }\n  }\n\n  return modified;\n}\n\nfunction Vue(options) {\n  if (false) {}\n\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n/*  */\n\nfunction initUse(Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this;\n    } // additional parameters\n\n\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n\n    installedPlugins.push(plugin);\n    return this;\n  };\n}\n/*  */\n\n\nfunction initMixin$1(Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this;\n  };\n}\n/*  */\n\n\nfunction initExtend(Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n  /**\n   * Class inheritance\n   */\n\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId];\n    }\n\n    var name = extendOptions.name || Super.options.name;\n\n    if (false) {}\n\n    var Sub = function VueComponent(options) {\n      this._init(options);\n    };\n\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(Super.options, extendOptions);\n    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    } // allow further extension/mixin/plugin usage\n\n\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use; // create asset registers, so extended classes\n    // can have their private assets too.\n\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    }); // enable recursive self-lookup\n\n    if (name) {\n      Sub.options.components[name] = Sub;\n    } // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n\n\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options); // cache constructor\n\n    cachedCtors[SuperId] = Sub;\n    return Sub;\n  };\n}\n\nfunction initProps$1(Comp) {\n  var props = Comp.options.props;\n\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1(Comp) {\n  var computed = Comp.options.computed;\n\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n/*  */\n\n\nfunction initAssetRegisters(Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (id, definition) {\n      if (!definition) {\n        return this.options[type + 's'][id];\n      } else {\n        /* istanbul ignore if */\n        if (false) {}\n\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = {\n            bind: definition,\n            update: definition\n          };\n        }\n\n        this.options[type + 's'][id] = definition;\n        return definition;\n      }\n    };\n  });\n}\n/*  */\n\n\nfunction getComponentName(opts) {\n  return opts && (opts.Ctor.options.name || opts.tag);\n}\n\nfunction matches(pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1;\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1;\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name);\n  }\n  /* istanbul ignore next */\n\n\n  return false;\n}\n\nfunction pruneCache(keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n\n  for (var key in cache) {\n    var cachedNode = cache[key];\n\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry(cache, key, keys, current) {\n  var cached$$1 = cache[key];\n\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n  created: function created() {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n  destroyed: function destroyed() {\n    for (var key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys);\n    }\n  },\n  mounted: function mounted() {\n    var this$1 = this;\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) {\n        return matches(val, name);\n      });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) {\n        return !matches(val, name);\n      });\n    });\n  },\n  render: function render() {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n\n      if ( // not included\n      include && (!name || !matches(include, name)) || // excluded\n      exclude && name && matches(exclude, name)) {\n        return vnode;\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null // same constructor may get registered as different local components\n      // so cid alone is not enough (#3269)\n      ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance; // make current key freshest\n\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key); // prune oldest entry\n\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n\n    return vnode || slot && slot[0];\n  }\n};\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n/*  */\n\nfunction initGlobalAPI(Vue) {\n  // config\n  var configDef = {};\n\n  configDef.get = function () {\n    return config;\n  };\n\n  if (false) {}\n\n  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick; // 2.6 explicit observable API\n\n  Vue.observable = function (obj) {\n    observe(obj);\n    return obj;\n  };\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  }); // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n\n  Vue.options._base = Vue;\n  extend(Vue.options.components, builtInComponents);\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get() {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext;\n  }\n}); // expose FunctionalRenderContext for ssr runtime helper installation\n\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\nVue.version = '2.6.11';\n/*  */\n// these are reserved for web because they are directly compiled away\n// during template compilation\n\nvar isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding\n\nvar acceptValue = makeMap('input,textarea,option,select,progress');\n\nvar mustUseProp = function (tag, type, attr) {\n  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\nvar convertEnumeratedValue = function (key, value) {\n  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable\n  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';\n};\n\nvar isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : '';\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false;\n};\n/*  */\n\n\nfunction genClassForVnode(vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n\n  return renderClass(data.staticClass, data.class);\n}\n\nfunction mergeClassData(child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class) ? [child.class, parent.class] : parent.class\n  };\n}\n\nfunction renderClass(staticClass, dynamicClass) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass));\n  }\n  /* istanbul ignore next */\n\n\n  return '';\n}\n\nfunction concat(a, b) {\n  return a ? b ? a + ' ' + b : a : b || '';\n}\n\nfunction stringifyClass(value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value);\n  }\n\n  if (isObject(value)) {\n    return stringifyObject(value);\n  }\n\n  if (typeof value === 'string') {\n    return value;\n  }\n  /* istanbul ignore next */\n\n\n  return '';\n}\n\nfunction stringifyArray(value) {\n  var res = '';\n  var stringified;\n\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) {\n        res += ' ';\n      }\n\n      res += stringified;\n    }\n  }\n\n  return res;\n}\n\nfunction stringifyObject(value) {\n  var res = '';\n\n  for (var key in value) {\n    if (value[key]) {\n      if (res) {\n        res += ' ';\n      }\n\n      res += key;\n    }\n  }\n\n  return res;\n}\n/*  */\n\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\nvar isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\n\nvar isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\nvar isPreTag = function (tag) {\n  return tag === 'pre';\n};\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag);\n};\n\nfunction getTagNamespace(tag) {\n  if (isSVG(tag)) {\n    return 'svg';\n  } // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n\n\n  if (tag === 'math') {\n    return 'math';\n  }\n}\n\nvar unknownElementCache = Object.create(null);\n\nfunction isUnknownElement(tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true;\n  }\n\n  if (isReservedTag(tag)) {\n    return false;\n  }\n\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag];\n  }\n\n  var el = document.createElement(tag);\n\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n  } else {\n    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\n\nfunction query(el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n\n    if (!selected) {\n       false && false;\n      return document.createElement('div');\n    }\n\n    return selected;\n  } else {\n    return el;\n  }\n}\n/*  */\n\n\nfunction createElement$1(tagName, vnode) {\n  var elm = document.createElement(tagName);\n\n  if (tagName !== 'select') {\n    return elm;\n  } // false or null will remove the attribute but undefined will not\n\n\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n\n  return elm;\n}\n\nfunction createElementNS(namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName);\n}\n\nfunction createTextNode(text) {\n  return document.createTextNode(text);\n}\n\nfunction createComment(text) {\n  return document.createComment(text);\n}\n\nfunction insertBefore(parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild(node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild(node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode(node) {\n  return node.parentNode;\n}\n\nfunction nextSibling(node) {\n  return node.nextSibling;\n}\n\nfunction tagName(node) {\n  return node.tagName;\n}\n\nfunction setTextContent(node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope(node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n/*  */\n\nvar ref = {\n  create: function create(_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update(oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy(vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef(vnode, isRemoval) {\n  var key = vnode.data.ref;\n\n  if (!isDef(key)) {\n    return;\n  }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\n\nvar emptyNode = new VNode('', {}, []);\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode(a, b) {\n  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));\n}\n\nfunction sameInputType(a, b) {\n  if (a.tag !== 'input') {\n    return true;\n  }\n\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n\n    if (isDef(key)) {\n      map[key] = i;\n    }\n  }\n\n  return map;\n}\n\nfunction createPatchFunction(backend) {\n  var i, j;\n  var cbs = {};\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt(elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n  }\n\n  function createRmCb(childElm, listeners) {\n    function remove$$1() {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n\n    remove$$1.listeners = listeners;\n    return remove$$1;\n  }\n\n  function removeNode(el) {\n    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text\n\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1(vnode, inVPre) {\n    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {\n      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;\n    })) && config.isUnknownElement(vnode.tag);\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return;\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n\n    if (isDef(tag)) {\n      if (false) {}\n\n      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n      /* istanbul ignore if */\n\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (false) {}\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false\n        /* hydrating */\n        );\n      } // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n\n\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        insert(parentElm, vnode.elm, refElm);\n\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n\n        return true;\n      }\n    }\n  }\n\n  function initComponent(vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n\n    vnode.elm = vnode.componentInstance.$el;\n\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode); // make sure to invoke the insert hook\n\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i; // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n\n    var innerNode = vnode;\n\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n\n        insertedVnodeQueue.push(innerNode);\n        break;\n      }\n    } // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n\n\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert(parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (nodeOps.parentNode(ref$$1) === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren(vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (false) {}\n\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable(vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n\n    return isDef(vnode.tag);\n  }\n\n  function invokeCreateHooks(vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n\n    i = vnode.data.hook; // Reuse variable\n\n    if (isDef(i)) {\n      if (isDef(i.create)) {\n        i.create(emptyNode, vnode);\n      }\n\n      if (isDef(i.insert)) {\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n  } // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n\n\n  function setScope(vnode) {\n    var i;\n\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n\n        ancestor = ancestor.parent;\n      }\n    } // for slot content they should also get the scopeId from the host instance.\n\n\n    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook(vnode) {\n    var i, j;\n    var data = vnode.data;\n\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n        i(vnode);\n      }\n\n      for (i = 0; i < cbs.destroy.length; ++i) {\n        cbs.destroy[i](vnode);\n      }\n    }\n\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes(vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else {\n          // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook(vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      } // recursively invoke hooks on child component root node\n\n\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n\n    var canMove = !removeOnly;\n\n    if (false) {}\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        }\n\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n\n        if (isUndef(idxInOld)) {\n          // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys(children) {\n    var seenKeys = {};\n\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\", vnode.context);\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld(node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n\n      if (isDef(c) && sameVnode(node, c)) {\n        return i;\n      }\n    }\n  }\n\n  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\n    if (oldVnode === vnode) {\n      return;\n    }\n\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n\n      return;\n    } // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n\n\n    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return;\n    }\n\n    var i;\n    var data = vnode.data;\n\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) {\n        cbs.update[i](oldVnode, vnode);\n      }\n\n      if (isDef(i = data.hook) && isDef(i = i.update)) {\n        i(oldVnode, vnode);\n      }\n    }\n\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) {\n          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n        }\n      } else if (isDef(ch)) {\n        if (false) {}\n\n        if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n        i(oldVnode, vnode);\n      }\n    }\n  }\n\n  function invokeInsertHook(vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.\n\n  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || data && data.pre;\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true;\n    } // assert node match\n\n\n    if (false) {}\n\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) {\n        i(vnode, true\n        /* hydrating */\n        );\n      }\n\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true;\n      }\n    }\n\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (false) {}\n\n              return false;\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break;\n              }\n\n              childNode = childNode.nextSibling;\n            } // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n\n\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (false) {}\n\n              return false;\n            }\n          }\n        }\n      }\n\n      if (isDef(data)) {\n        var fullInvoke = false;\n\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break;\n          }\n        }\n\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n\n    return true;\n  }\n\n  function assertNodeMatch(node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3);\n    }\n  }\n\n  return function patch(oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) {\n        invokeDestroyHook(oldVnode);\n      }\n\n      return;\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode;\n            } else if (false) {}\n          } // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n\n\n          oldVnode = emptyNodeAt(oldVnode);\n        } // replacing existing element\n\n\n        var oldElm = oldVnode.elm;\n        var parentElm = nodeOps.parentNode(oldElm); // create new node\n\n        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a\n        // leaving transition. Only happens when combining transition +\n        // keep-alive + HOCs. (#4590)\n        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively\n\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n\n            ancestor.elm = vnode.elm;\n\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              } // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n\n\n              var insert = ancestor.data.hook.insert;\n\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n\n            ancestor = ancestor.parent;\n          }\n        } // destroy old node\n\n\n        if (isDef(parentElm)) {\n          removeVnodes([oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm;\n  };\n}\n/*  */\n\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives(vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives(oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update(oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n  var key, oldDir, dir;\n\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      dir.oldArg = oldDir.arg;\n      callHook$1(dir, 'update', vnode, oldVnode);\n\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1(dirs, vm) {\n  var res = Object.create(null);\n\n  if (!dirs) {\n    // $flow-disable-line\n    return res;\n  }\n\n  var i, dir;\n\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  } // $flow-disable-line\n\n\n  return res;\n}\n\nfunction getRawDirName(dir) {\n  return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n}\n\nfunction callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n    }\n  }\n}\n\nvar baseModules = [ref, directives];\n/*  */\n\nfunction updateAttrs(oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return;\n  }\n\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return;\n  }\n\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it\n\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  } // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n\n  /* istanbul ignore if */\n\n\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr(el, key, value) {\n  if (el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, convertEnumeratedValue(key, value));\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr(el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n\n    /* istanbul ignore if */\n    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n\n      el.addEventListener('input', blocker); // $flow-disable-line\n\n      el.__ieph = true;\n      /* IE placeholder patched */\n    }\n\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n/*  */\n\nfunction updateClass(oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n    return;\n  }\n\n  var cls = genClassForVnode(vnode); // handle transition classes\n\n  var transitionClass = el._transitionClasses;\n\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  } // set the class\n\n\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters(exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) {\n        inSingle = false;\n      }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) {\n        inDouble = false;\n      }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) {\n        inTemplateString = false;\n      }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) {\n        inRegex = false;\n      }\n    } else if (c === 0x7C && // pipe\n    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22:\n          inDouble = true;\n          break;\n        // \"\n\n        case 0x27:\n          inSingle = true;\n          break;\n        // '\n\n        case 0x60:\n          inTemplateString = true;\n          break;\n        // `\n\n        case 0x28:\n          paren++;\n          break;\n        // (\n\n        case 0x29:\n          paren--;\n          break;\n        // )\n\n        case 0x5B:\n          square++;\n          break;\n        // [\n\n        case 0x5D:\n          square--;\n          break;\n        // ]\n\n        case 0x7B:\n          curly++;\n          break;\n        // {\n\n        case 0x7D:\n          curly--;\n          break;\n        // }\n      }\n\n      if (c === 0x2f) {\n        // /\n        var j = i - 1;\n        var p = void 0; // find first non-whitespace prev char\n\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n\n          if (p !== ' ') {\n            break;\n          }\n        }\n\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter() {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression;\n}\n\nfunction wrapFilter(exp, filter) {\n  var i = filter.indexOf('(');\n\n  if (i < 0) {\n    // _f: resolveFilter\n    return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return \"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args);\n  }\n}\n/*  */\n\n/* eslint-disable no-unused-vars */\n\n\nfunction baseWarn(msg, range) {\n  console.error(\"[Vue compiler]: \" + msg);\n}\n/* eslint-enable no-unused-vars */\n\n\nfunction pluckModuleFunction(modules, key) {\n  return modules ? modules.map(function (m) {\n    return m[key];\n  }).filter(function (_) {\n    return _;\n  }) : [];\n}\n\nfunction addProp(el, name, value, range, dynamic) {\n  (el.props || (el.props = [])).push(rangeSetItem({\n    name: name,\n    value: value,\n    dynamic: dynamic\n  }, range));\n  el.plain = false;\n}\n\nfunction addAttr(el, name, value, range, dynamic) {\n  var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);\n  attrs.push(rangeSetItem({\n    name: name,\n    value: value,\n    dynamic: dynamic\n  }, range));\n  el.plain = false;\n} // add a raw attr (use this in preTransforms)\n\n\nfunction addRawAttr(el, name, value, range) {\n  el.attrsMap[name] = value;\n  el.attrsList.push(rangeSetItem({\n    name: name,\n    value: value\n  }, range));\n}\n\nfunction addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {\n  (el.directives || (el.directives = [])).push(rangeSetItem({\n    name: name,\n    rawName: rawName,\n    value: value,\n    arg: arg,\n    isDynamicArg: isDynamicArg,\n    modifiers: modifiers\n  }, range));\n  el.plain = false;\n}\n\nfunction prependModifierMarker(symbol, name, dynamic) {\n  return dynamic ? \"_p(\" + name + \",\\\"\" + symbol + \"\\\")\" : symbol + name; // mark the event as captured\n}\n\nfunction addHandler(el, name, value, modifiers, important, warn, range, dynamic) {\n  modifiers = modifiers || emptyObject; // warn prevent and passive modifier\n\n  /* istanbul ignore if */\n\n  if (false) {} // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n\n\n  if (modifiers.right) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'contextmenu';\n      delete modifiers.right;\n    }\n  } else if (modifiers.middle) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'mouseup';\n    }\n  } // check capture modifier\n\n\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = prependModifierMarker('!', name, dynamic);\n  }\n\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = prependModifierMarker('~', name, dynamic);\n  }\n  /* istanbul ignore if */\n\n\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = prependModifierMarker('&', name, dynamic);\n  }\n\n  var events;\n\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = rangeSetItem({\n    value: value.trim(),\n    dynamic: dynamic\n  }, range);\n\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n\n  el.plain = false;\n}\n\nfunction getRawBindingAttr(el, name) {\n  return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];\n}\n\nfunction getBindingAttr(el, name, getStatic) {\n  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue);\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n\n    if (staticValue != null) {\n      return JSON.stringify(staticValue);\n    }\n  }\n} // note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\n\n\nfunction getAndRemoveAttr(el, name, removeFromMap) {\n  var val;\n\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n\n  return val;\n}\n\nfunction getAndRemoveAttrByRegex(el, name) {\n  var list = el.attrsList;\n\n  for (var i = 0, l = list.length; i < l; i++) {\n    var attr = list[i];\n\n    if (name.test(attr.name)) {\n      list.splice(i, 1);\n      return attr;\n    }\n  }\n}\n\nfunction rangeSetItem(item, range) {\n  if (range) {\n    if (range.start != null) {\n      item.start = range.start;\n    }\n\n    if (range.end != null) {\n      item.end = range.end;\n    }\n  }\n\n  return item;\n}\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\n\n\nfunction genComponentModel(el, value, modifiers) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n\n  if (trim) {\n    valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n  }\n\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var assignment = genAssignmentCode(value, valueExpression);\n  el.model = {\n    value: \"(\" + value + \")\",\n    expression: JSON.stringify(value),\n    callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n  };\n}\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\n\n\nfunction genAssignmentCode(value, assignment) {\n  var res = parseModel(value);\n\n  if (res.key === null) {\n    return value + \"=\" + assignment;\n  } else {\n    return \"$set(\" + res.exp + \", \" + res.key + \", \" + assignment + \")\";\n  }\n}\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\n\nvar len, str, chr, index$1, expressionPos, expressionEndPos;\n\nfunction parseModel(val) {\n  // Fix https://github.com/vuejs/vue/pull/7730\n  // allow v-model=\"obj.val \" (trailing whitespace)\n  val = val.trim();\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      };\n    } else {\n      return {\n        exp: val,\n        key: null\n      };\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  };\n}\n\nfunction next() {\n  return str.charCodeAt(++index$1);\n}\n\nfunction eof() {\n  return index$1 >= len;\n}\n\nfunction isStringStart(chr) {\n  return chr === 0x22 || chr === 0x27;\n}\n\nfunction parseBracket(chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n\n  while (!eof()) {\n    chr = next();\n\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue;\n    }\n\n    if (chr === 0x5B) {\n      inBracket++;\n    }\n\n    if (chr === 0x5D) {\n      inBracket--;\n    }\n\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break;\n    }\n  }\n}\n\nfunction parseString(chr) {\n  var stringQuote = chr;\n\n  while (!eof()) {\n    chr = next();\n\n    if (chr === stringQuote) {\n      break;\n    }\n  }\n}\n/*  */\n\n\nvar warn$1; // in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\n\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model(el, dir, _warn) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (false) {}\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n    return false;\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n    return false;\n  } else if (false) {} // ensure runtime directive metadata\n\n\n  return true;\n}\n\nfunction genCheckboxModel(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n  addHandler(el, 'change', \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$el.checked){$$i<0&&(\" + genAssignmentCode(value, '$$a.concat([$$v])') + \")}\" + \"else{$$i>-1&&(\" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + \")}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n}\n\nfunction genRadioModel(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n  addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + genAssignmentCode(value, assignment);\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel(el, value, modifiers) {\n  var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model\n  // except for inputs with v-bind:type\n\n  if (false) { var binding, typeBinding, value$1; }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n  var valueExpression = '$event.target.value';\n\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', \"(\" + value + \")\");\n  addHandler(el, event, code, null, true);\n\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n/*  */\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\n\n\nfunction normalizeEvents(on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  } // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n\n  /* istanbul ignore if */\n\n\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler$1(event, handler, capture) {\n  var _target = target$1; // save current target element in closure\n\n  return function onceHandler() {\n    var res = handler.apply(null, arguments);\n\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  };\n} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\n\n\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\nfunction add$1(name, handler, capture, passive) {\n  // async edge case #6566: inner click event triggers patch, event handler\n  // attached to outer element during patch, and triggered again. This\n  // happens because browsers fire microtask ticks between event propagation.\n  // the solution is simple: we save the timestamp when a handler is attached,\n  // and the handler would only fire if the event passed to it was fired\n  // AFTER it was attached.\n  if (useMicrotaskFix) {\n    var attachedTimestamp = currentFlushTimestamp;\n    var original = handler;\n\n    handler = original._wrapper = function (e) {\n      if ( // no bubbling, should always fire.\n      // this is just a safety net in case event.timeStamp is unreliable in\n      // certain weird environments...\n      e.target === e.currentTarget || // event is fired after handler attachment\n      e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations\n      // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n      // #9681 QtWebEngine event.timeStamp is negative value\n      e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page\n      // electron/nw.js app, since event.timeStamp will be using a different\n      // starting reference\n      e.target.ownerDocument !== document) {\n        return original.apply(this, arguments);\n      }\n    };\n  }\n\n  target$1.addEventListener(name, handler, supportsPassive ? {\n    capture: capture,\n    passive: passive\n  } : capture);\n}\n\nfunction remove$2(name, handler, capture, _target) {\n  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);\n}\n\nfunction updateDOMListeners(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return;\n  }\n\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n/*  */\n\nvar svgContainer;\n\nfunction updateDOMProps(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return;\n  }\n\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it\n\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (!(key in props)) {\n      elm[key] = '';\n    }\n  }\n\n  for (key in props) {\n    cur = props[key]; // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) {\n        vnode.children.length = 0;\n      }\n\n      if (cur === oldProps[key]) {\n        continue;\n      } // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n\n\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value' && elm.tagName !== 'PROGRESS') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur; // avoid resetting cursor position when value is the same\n\n      var strCur = isUndef(cur) ? '' : String(cur);\n\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n      // IE doesn't support innerHTML for SVG elements\n      svgContainer = svgContainer || document.createElement('div');\n      svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n      var svg = svgContainer.firstChild;\n\n      while (elm.firstChild) {\n        elm.removeChild(elm.firstChild);\n      }\n\n      while (svg.firstChild) {\n        elm.appendChild(svg.firstChild);\n      }\n    } else if ( // skip the update if old and new VDOM state is the same.\n    // `value` is handled separately because the DOM value may be temporarily\n    // out of sync with VDOM state due to focus, composition and modifiers.\n    // This  #4521 by skipping the unnecesarry `checked` update.\n    cur !== oldProps[key]) {\n      // some property updates can throw\n      // e.g. `value` on <progress> w/ non-finite value\n      try {\n        elm[key] = cur;\n      } catch (e) {}\n    }\n  }\n} // check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue(elm, checkVal) {\n  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));\n}\n\nfunction isNotInFocusAndDirty(elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true; // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n\n  try {\n    notInFocus = document.activeElement !== elm;\n  } catch (e) {}\n\n  return notInFocus && elm.value !== checkVal;\n}\n\nfunction isDirtyWithModifiers(elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n\n  if (isDef(modifiers)) {\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal);\n    }\n\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim();\n    }\n  }\n\n  return value !== newVal;\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res;\n}); // merge static and dynamic style data on the same vnode\n\nfunction normalizeStyleData(data) {\n  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n\n  return data.staticStyle ? extend(data.staticStyle, style) : style;\n} // normalize possible array / string values into Object\n\n\nfunction normalizeStyleBinding(bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle);\n  }\n\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle);\n  }\n\n  return bindingStyle;\n}\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\n\n\nfunction getStyle(vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n\n      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if (styleData = normalizeStyleData(vnode.data)) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n\n  while (parentNode = parentNode.parent) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n\n  return res;\n}\n/*  */\n\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\n\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n\n  if (prop !== 'filter' && prop in emptyStyle) {\n    return prop;\n  }\n\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n\n    if (name in emptyStyle) {\n      return name;\n    }\n  }\n});\n\nfunction updateStyle(oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n    return;\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n\n  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n\n  for (name in newStyle) {\n    cur = newStyle[name];\n\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n/*  */\n\nvar whitespaceRE = /\\s+/;\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\n\nfunction addClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) {\n        return el.classList.add(c);\n      });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\n\n\nfunction removeClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) {\n        return el.classList.remove(c);\n      });\n    } else {\n      el.classList.remove(cls);\n    }\n\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n\n    cur = cur.trim();\n\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n/*  */\n\n\nfunction resolveTransition(def$$1) {\n  if (!def$$1) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (typeof def$$1 === 'object') {\n    var res = {};\n\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n\n    extend(res, def$$1);\n    return res;\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1);\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: name + \"-enter\",\n    enterToClass: name + \"-enter-to\",\n    enterActiveClass: name + \"-enter-active\",\n    leaveClass: name + \"-leave\",\n    leaveToClass: name + \"-leave-to\",\n    leaveActiveClass: name + \"-leave-active\"\n  };\n});\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation'; // Transition property/event sniffing\n\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\n\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n\n  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n} // binding to window is necessary to make hot reload work in IE in strict mode\n\n\nvar raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :\n/* istanbul ignore next */\nfunction (fn) {\n  return fn();\n};\n\nfunction nextFrame(fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass(el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass(el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds(el, expectedType, cb) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n\n  if (!type) {\n    return cb();\n  }\n\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo(el, expectedType) {\n  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties\n\n  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n\n  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  };\n}\n\nfunction getTimeout(delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i]);\n  }));\n} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\n\n\nfunction toMs(s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n}\n/*  */\n\n\nfunction enter(vnode, toggleDisplay) {\n  var el = vnode.elm; // call leave callback now\n\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n\n  if (isUndef(data)) {\n    return;\n  }\n  /* istanbul ignore if */\n\n\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration; // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n\n  while (transitionNode && transitionNode.parent) {\n    context = transitionNode.context;\n    transitionNode = transitionNode.parent;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return;\n  }\n\n  var startClass = isAppear && appearClass ? appearClass : enterClass;\n  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n  if (false) {}\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\n      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n\n      enterHook && enterHook(el, cb);\n    });\n  } // start enter transition\n\n\n  beforeEnterHook && beforeEnterHook(el);\n\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave(vnode, rm) {\n  var el = vnode.elm; // call enter callback now\n\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm();\n  }\n  /* istanbul ignore if */\n\n\n  if (isDef(el._leaveCb)) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n  if (false) {}\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave() {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return;\n    } // record leaving element\n\n\n    if (!vnode.data.show && el.parentNode) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n\n    beforeLeave && beforeLeave(el);\n\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    leave && leave(el, cb);\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n} // only used in dev mode\n\n\nfunction checkDuration(val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n  } else if (isNaN(val)) {\n    warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n  }\n}\n\nfunction isValidDuration(val) {\n  return typeof val === 'number' && !isNaN(val);\n}\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\n\n\nfunction getHookArgumentsLength(fn) {\n  if (isUndef(fn)) {\n    return false;\n  }\n\n  var invokerFns = fn.fns;\n\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n  } else {\n    return (fn._length || fn.length) > 1;\n  }\n}\n\nfunction _enter(_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1(vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\nvar platformModules = [attrs, klass, events, domProps, style, transition];\n/*  */\n// the directive module should be applied last, after all\n// built-in modules have been applied.\n\nvar modules = platformModules.concat(baseModules);\nvar patch = createPatchFunction({\n  nodeOps: nodeOps,\n  modules: modules\n});\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\n\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted(el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated(el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n\n      if (curOptions.some(function (o, i) {\n        return !looseEqual(o, prevOptions[i]);\n      })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple ? binding.value.some(function (v) {\n          return hasNoMatchingOption(v, curOptions);\n        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected(el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected(el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n\n  if (isMultiple && !Array.isArray(value)) {\n     false && false;\n    return;\n  }\n\n  var selected, option;\n\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n\n        return;\n      }\n    }\n  }\n\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption(value, options) {\n  return options.every(function (o) {\n    return !looseEqual(o, value);\n  });\n}\n\nfunction getValue(option) {\n  return '_value' in option ? option._value : option.value;\n}\n\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd(e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) {\n    return;\n  }\n\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger(el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n/*  */\n// recursively search for possible transition defined inside the component root\n\n\nfunction locateNode(vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n}\n\nvar show = {\n  bind: function bind(el, ref, vnode) {\n    var value = ref.value;\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n  update: function update(el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n    /* istanbul ignore if */\n\n    if (!value === !oldValue) {\n      return;\n    }\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n\n    if (transition$$1) {\n      vnode.data.show = true;\n\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n/*  */\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n}; // in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\n\nfunction getRealChild(vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children));\n  } else {\n    return vnode;\n  }\n}\n\nfunction extractTransitionData(comp) {\n  var data = {};\n  var options = comp.$options; // props\n\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  } // events.\n  // extract listeners and pass them directly to the transition methods\n\n\n  var listeners = options._parentListeners;\n\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n\n  return data;\n}\n\nfunction placeholder(h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    });\n  }\n}\n\nfunction hasParentTransition(vnode) {\n  while (vnode = vnode.parent) {\n    if (vnode.data.transition) {\n      return true;\n    }\n  }\n}\n\nfunction isSameChild(child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag;\n}\n\nvar isNotTextNode = function (c) {\n  return c.tag || isAsyncPlaceholder(c);\n};\n\nvar isVShowDirective = function (d) {\n  return d.name === 'show';\n};\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n  render: function render(h) {\n    var this$1 = this;\n    var children = this.$slots.default;\n\n    if (!children) {\n      return;\n    } // filter out text nodes (possible whitespaces)\n\n\n    children = children.filter(isNotTextNode);\n    /* istanbul ignore if */\n\n    if (!children.length) {\n      return;\n    } // warn multiple elements\n\n\n    if (false) {}\n\n    var mode = this.mode; // warn invalid mode\n\n    if (false) {}\n\n    var rawChild = children[0]; // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild;\n    } // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n\n\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n\n    if (!child) {\n      return rawChild;\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild);\n    } // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n\n\n    var id = \"__transition-\" + this._uid + \"-\";\n    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild); // mark v-show\n    // so that the transition module can hand over the control to the directive\n\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node\n    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode\n\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild);\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild;\n        }\n\n        var delayedLeave;\n\n        var performLeave = function () {\n          delayedLeave();\n        };\n\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        });\n      }\n    }\n\n    return rawChild;\n  }\n};\n/*  */\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\ndelete props.mode;\nvar TransitionGroup = {\n  props: props,\n  beforeMount: function beforeMount() {\n    var this$1 = this;\n    var update = this._update;\n\n    this._update = function (vnode, hydrating) {\n      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass\n\n      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n      );\n\n      this$1._vnode = this$1.kept;\n      restoreActiveInstance();\n      update.call(this$1, vnode, hydrating);\n    };\n  },\n  render: function render(h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c;\n          (c.data || (c.data = {})).transition = transitionData;\n        } else if (false) { var name, opts; }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children);\n  },\n  updated: function updated() {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || (this.name || 'v') + '-move';\n\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return;\n    } // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n\n\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation); // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n\n    this._reflow = document.body.offsetHeight;\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n          if (e && e.target !== el) {\n            return;\n          }\n\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n  methods: {\n    hasMove: function hasMove(el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false;\n      }\n      /* istanbul ignore if */\n\n\n      if (this._hasMove) {\n        return this._hasMove;\n      } // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n\n\n      var clone = el.cloneNode();\n\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) {\n          removeClass(clone, cls);\n        });\n      }\n\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return this._hasMove = info.hasTransform;\n    }\n  }\n};\n\nfunction callPendingCbs(c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n\n\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition(c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation(c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n/*  */\n// install platform specific utils\n\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components\n\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents); // install platform patch function\n\nVue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method\n\nVue.prototype.$mount = function (el, hydrating) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating);\n}; // devtools global hook\n\n/* istanbul ignore next */\n\n\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (false) {}\n    }\n\n    if (false) {}\n  }, 0);\n}\n/*  */\n\n\nvar defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n});\n\nfunction parseText(text, delimiters) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n\n  if (!tagRE.test(text)) {\n    return;\n  }\n\n  var tokens = [];\n  var rawTokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, tokenValue;\n\n  while (match = tagRE.exec(text)) {\n    index = match.index; // push text token\n\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\n      tokens.push(JSON.stringify(tokenValue));\n    } // tag token\n\n\n    var exp = parseFilters(match[1].trim());\n    tokens.push(\"_s(\" + exp + \")\");\n    rawTokens.push({\n      '@binding': exp\n    });\n    lastIndex = index + match[0].length;\n  }\n\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex));\n    tokens.push(JSON.stringify(tokenValue));\n  }\n\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  };\n}\n/*  */\n\n\nfunction transformNode(el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n\n  if (false) { var res; }\n\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n\n  var classBinding = getBindingAttr(el, 'class', false\n  /* getStatic */\n  );\n\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData(el) {\n  var data = '';\n\n  if (el.staticClass) {\n    data += \"staticClass:\" + el.staticClass + \",\";\n  }\n\n  if (el.classBinding) {\n    data += \"class:\" + el.classBinding + \",\";\n  }\n\n  return data;\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n/*  */\n\nfunction transformNode$1(el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (false) { var res; }\n\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false\n  /* getStatic */\n  );\n\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1(el) {\n  var data = '';\n\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + el.staticStyle + \",\";\n  }\n\n  if (el.styleBinding) {\n    data += \"style:(\" + el.styleBinding + \"),\";\n  }\n\n  return data;\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n/*  */\n\nvar decoder;\nvar he = {\n  decode: function decode(html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent;\n  }\n};\n/*  */\n\nvar isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open\n// (and which close themselves)\n\nvar canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n\nvar isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n// Regular Expressions for parsing tags and attributes\n\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + unicodeRegExp.source + \"]*\";\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp(\"^<\" + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\nvar doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being passed as HTML comment when inlined in page\n\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/; // Special Elements (can contain anything)\n\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t',\n  '&#39;': \"'\"\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992\n\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\n\nvar shouldIgnoreFirstNewline = function (tag, html) {\n  return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\n};\n\nfunction decodeAttr(value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) {\n    return decodingMap[match];\n  });\n}\n\nfunction parseHTML(html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n\n  while (html) {\n    last = html; // Make sure we're not in a plaintext content element like script/style\n\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('--\x3e');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n            }\n\n            advance(commentEnd + 3);\n            continue;\n          }\n        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n\n\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue;\n          }\n        } // Doctype:\n\n\n        var doctypeMatch = html.match(doctype);\n\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue;\n        } // End tag:\n\n\n        var endTagMatch = html.match(endTag);\n\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue;\n        } // Start tag:\n\n\n        var startTagMatch = parseStartTag();\n\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n\n          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n            advance(1);\n          }\n\n          continue;\n        }\n      }\n\n      var text = void 0,\n          rest = void 0,\n          next = void 0;\n\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n\n        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n\n          if (next < 0) {\n            break;\n          }\n\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n\n        text = html.substring(0, textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n      }\n\n      if (text) {\n        advance(text.length);\n      }\n\n      if (options.chars && text) {\n        options.chars(text, index - text.length, index);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text.replace(/<!\\--([\\s\\S]*?)--\x3e/g, '$1') // #7298\n          .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n\n        if (options.chars) {\n          options.chars(text);\n        }\n\n        return '';\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n\n      if (false) {}\n\n      break;\n    }\n  } // Clean up any remaining tags\n\n\n  parseEndTag();\n\n  function advance(n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag() {\n    var start = html.match(startTagOpen);\n\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n\n      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n        attr.start = index;\n        advance(attr[0].length);\n        attr.end = index;\n        match.attrs.push(attr);\n      }\n\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match;\n      }\n    }\n  }\n\n  function handleStartTag(match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n\n      if (false) {}\n    }\n\n    if (!unary) {\n      stack.push({\n        tag: tagName,\n        lowerCasedTag: tagName.toLowerCase(),\n        attrs: attrs,\n        start: match.start,\n        end: match.end\n      });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag(tagName, start, end) {\n    var pos, lowerCasedTagName;\n\n    if (start == null) {\n      start = index;\n    }\n\n    if (end == null) {\n      end = index;\n    } // Find the closest opened tag of the same type\n\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break;\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (false) {}\n\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      } // Remove the open elements from the stack\n\n\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n/*  */\n\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:|^#/;\nvar forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\nvar dynamicArgRE = /^\\[.*\\]$/;\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^\\.|^v-bind:/;\nvar modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\nvar slotRE = /^v-slot(:|$)|^#/;\nvar lineBreakRE = /[\\r\\n]/;\nvar whitespaceRE$1 = /\\s+/g;\nvar invalidAttributeRE = /[\\s\"'<>\\/=]/;\nvar decodeHTMLCached = cached(he.decode);\nvar emptySlotScopeToken = \"_empty_\"; // configurable state\n\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\nvar maybeComponent;\n\nfunction createASTElement(tag, attrs, parent) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    rawAttrsMap: {},\n    parent: parent,\n    children: []\n  };\n}\n/**\n * Convert HTML string to AST.\n */\n\n\nfunction parse(template, options) {\n  warn$2 = options.warn || baseWarn;\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  var isReservedTag = options.isReservedTag || no;\n\n  maybeComponent = function (el) {\n    return !!el.component || !isReservedTag(el.tag);\n  };\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var whitespaceOption = options.whitespace;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce(msg, range) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg, range);\n    }\n  }\n\n  function closeElement(element) {\n    trimEndingWhitespace(element);\n\n    if (!inVPre && !element.processed) {\n      element = processElement(element, options);\n    } // tree management\n\n\n    if (!stack.length && element !== root) {\n      // allow root elements with v-if, v-else-if and v-else\n      if (root.if && (element.elseif || element.else)) {\n        if (false) {}\n\n        addIfCondition(root, {\n          exp: element.elseif,\n          block: element\n        });\n      } else if (false) {}\n    }\n\n    if (currentParent && !element.forbidden) {\n      if (element.elseif || element.else) {\n        processIfConditions(element, currentParent);\n      } else {\n        if (element.slotScope) {\n          // scoped slot\n          // keep it in the children list so that v-else(-if) conditions can\n          // find it as the prev node.\n          var name = element.slotTarget || '\"default\"';\n          (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        }\n\n        currentParent.children.push(element);\n        element.parent = currentParent;\n      }\n    } // final children cleanup\n    // filter out scoped slots\n\n\n    element.children = element.children.filter(function (c) {\n      return !c.slotScope;\n    }); // remove trailing whitespace node again\n\n    trimEndingWhitespace(element); // check pre state\n\n    if (element.pre) {\n      inVPre = false;\n    }\n\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    } // apply post-transforms\n\n\n    for (var i = 0; i < postTransforms.length; i++) {\n      postTransforms[i](element, options);\n    }\n  }\n\n  function trimEndingWhitespace(el) {\n    // remove trailing whitespace node\n    if (!inPre) {\n      var lastNode;\n\n      while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {\n        el.children.pop();\n      }\n    }\n  }\n\n  function checkRootConstraints(el) {\n    if (el.tag === 'slot' || el.tag === 'template') {\n      warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.', {\n        start: el.start\n      });\n    }\n\n    if (el.attrsMap.hasOwnProperty('v-for')) {\n      warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    outputSourceRange: options.outputSourceRange,\n    start: function start(tag, attrs, unary, start$1, end) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug\n\n      /* istanbul ignore if */\n\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (false) {}\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n         false && false;\n      } // apply pre-transforms\n\n\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n      }\n\n      if (!root) {\n        root = element;\n\n        if (false) {}\n      }\n\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        closeElement(element);\n      }\n    },\n    end: function end(tag, start, end$1) {\n      var element = stack[stack.length - 1]; // pop stack\n\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n\n      if (false) {}\n\n      closeElement(element);\n    },\n    chars: function chars(text, start, end) {\n      if (!currentParent) {\n        if (false) {}\n\n        return;\n      } // IE textarea placeholder bug\n\n      /* istanbul ignore if */\n\n\n      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n        return;\n      }\n\n      var children = currentParent.children;\n\n      if (inPre || text.trim()) {\n        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n      } else if (!children.length) {\n        // remove the whitespace-only node right after an opening tag\n        text = '';\n      } else if (whitespaceOption) {\n        if (whitespaceOption === 'condense') {\n          // in condense mode, remove the whitespace node if it contains\n          // line break, otherwise condense to a single space\n          text = lineBreakRE.test(text) ? '' : ' ';\n        } else {\n          text = ' ';\n        }\n      } else {\n        text = preserveWhitespace ? ' ' : '';\n      }\n\n      if (text) {\n        if (!inPre && whitespaceOption === 'condense') {\n          // condense consecutive whitespaces into single space\n          text = text.replace(whitespaceRE$1, ' ');\n        }\n\n        var res;\n        var child;\n\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n          child = {\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text: text\n          };\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          child = {\n            type: 3,\n            text: text\n          };\n        }\n\n        if (child) {\n          if (false) {}\n\n          children.push(child);\n        }\n      }\n    },\n    comment: function comment(text, start, end) {\n      // adding anyting as a sibling to the root node is forbidden\n      // comments should still be allowed, but ignored\n      if (currentParent) {\n        var child = {\n          type: 3,\n          text: text,\n          isComment: true\n        };\n\n        if (false) {}\n\n        currentParent.children.push(child);\n      }\n    }\n  });\n  return root;\n}\n\nfunction processPre(el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs(el) {\n  var list = el.attrsList;\n  var len = list.length;\n\n  if (len) {\n    var attrs = el.attrs = new Array(len);\n\n    for (var i = 0; i < len; i++) {\n      attrs[i] = {\n        name: list[i].name,\n        value: JSON.stringify(list[i].value)\n      };\n\n      if (list[i].start != null) {\n        attrs[i].start = list[i].start;\n        attrs[i].end = list[i].end;\n      }\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement(element, options) {\n  processKey(element); // determine whether this is a plain element after\n  // removing structural attributes\n\n  element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;\n  processRef(element);\n  processSlotContent(element);\n  processSlotOutlet(element);\n  processComponent(element);\n\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n\n  processAttrs(element);\n  return element;\n}\n\nfunction processKey(el) {\n  var exp = getBindingAttr(el, 'key');\n\n  if (exp) {\n    if (false) { var parent, iterator; }\n\n    el.key = exp;\n  }\n}\n\nfunction processRef(el) {\n  var ref = getBindingAttr(el, 'ref');\n\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor(el) {\n  var exp;\n\n  if (exp = getAndRemoveAttr(el, 'v-for')) {\n    var res = parseFor(exp);\n\n    if (res) {\n      extend(el, res);\n    } else if (false) {}\n  }\n}\n\nfunction parseFor(exp) {\n  var inMatch = exp.match(forAliasRE);\n\n  if (!inMatch) {\n    return;\n  }\n\n  var res = {};\n  res.for = inMatch[2].trim();\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\n  var iteratorMatch = alias.match(forIteratorRE);\n\n  if (iteratorMatch) {\n    res.alias = alias.replace(forIteratorRE, '').trim();\n    res.iterator1 = iteratorMatch[1].trim();\n\n    if (iteratorMatch[2]) {\n      res.iterator2 = iteratorMatch[2].trim();\n    }\n  } else {\n    res.alias = alias;\n  }\n\n  return res;\n}\n\nfunction processIf(el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions(el, parent) {\n  var prev = findPrevElement(parent.children);\n\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (false) {}\n}\n\nfunction findPrevElement(children) {\n  var i = children.length;\n\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i];\n    } else {\n      if (false) {}\n\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition(el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce(el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n\n  if (once$$1 != null) {\n    el.once = true;\n  }\n} // handle content being passed to a component as slot,\n// e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\n\n\nfunction processSlotContent(el) {\n  var slotScope;\n\n  if (el.tag === 'template') {\n    slotScope = getAndRemoveAttr(el, 'scope');\n    /* istanbul ignore if */\n\n    if (false) {}\n\n    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n  } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {\n    /* istanbul ignore if */\n    if (false) {}\n\n    el.slotScope = slotScope;\n  } // slot=\"xxx\"\n\n\n  var slotTarget = getBindingAttr(el, 'slot');\n\n  if (slotTarget) {\n    el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat\n    // only for non-scoped slots.\n\n    if (el.tag !== 'template' && !el.slotScope) {\n      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n    }\n  } // 2.6 v-slot syntax\n\n\n  {\n    if (el.tag === 'template') {\n      // v-slot on <template>\n      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n\n      if (slotBinding) {\n        if (false) {}\n\n        var ref = getSlotName(slotBinding);\n        var name = ref.name;\n        var dynamic = ref.dynamic;\n        el.slotTarget = name;\n        el.slotTargetDynamic = dynamic;\n        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n      }\n    } else {\n      // v-slot on component, denotes default slot\n      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n\n      if (slotBinding$1) {\n        if (false) {} // add the component's children to its default slot\n\n\n        var slots = el.scopedSlots || (el.scopedSlots = {});\n        var ref$1 = getSlotName(slotBinding$1);\n        var name$1 = ref$1.name;\n        var dynamic$1 = ref$1.dynamic;\n        var slotContainer = slots[name$1] = createASTElement('template', [], el);\n        slotContainer.slotTarget = name$1;\n        slotContainer.slotTargetDynamic = dynamic$1;\n        slotContainer.children = el.children.filter(function (c) {\n          if (!c.slotScope) {\n            c.parent = slotContainer;\n            return true;\n          }\n        });\n        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now\n\n        el.children = []; // mark el non-plain so data gets generated\n\n        el.plain = false;\n      }\n    }\n  }\n}\n\nfunction getSlotName(binding) {\n  var name = binding.name.replace(slotRE, '');\n\n  if (!name) {\n    if (binding.name[0] !== '#') {\n      name = 'default';\n    } else if (false) {}\n  }\n\n  return dynamicArgRE.test(name) // dynamic [name]\n  ? {\n    name: name.slice(1, -1),\n    dynamic: true\n  } // static name\n  : {\n    name: \"\\\"\" + name + \"\\\"\",\n    dynamic: false\n  };\n} // handle <slot/> outlets\n\n\nfunction processSlotOutlet(el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n\n    if (false) {}\n  }\n}\n\nfunction processComponent(el) {\n  var binding;\n\n  if (binding = getBindingAttr(el, 'is')) {\n    el.component = binding;\n  }\n\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs(el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true; // modifiers\n\n      modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier\n\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n\n      if (bindRE.test(name)) {\n        // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isDynamic = dynamicArgRE.test(name);\n\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n\n        if (false) {}\n\n        if (modifiers) {\n          if (modifiers.prop && !isDynamic) {\n            name = camelize(name);\n\n            if (name === 'innerHtml') {\n              name = 'innerHTML';\n            }\n          }\n\n          if (modifiers.camel && !isDynamic) {\n            name = camelize(name);\n          }\n\n          if (modifiers.sync) {\n            syncGen = genAssignmentCode(value, \"$event\");\n\n            if (!isDynamic) {\n              addHandler(el, \"update:\" + camelize(name), syncGen, null, false, warn$2, list[i]);\n\n              if (hyphenate(name) !== camelize(name)) {\n                addHandler(el, \"update:\" + hyphenate(name), syncGen, null, false, warn$2, list[i]);\n              }\n            } else {\n              // handler w/ dynamic event name\n              addHandler(el, \"\\\"update:\\\"+(\" + name + \")\", syncGen, null, false, warn$2, list[i], true // dynamic\n              );\n            }\n          }\n        }\n\n        if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value, list[i], isDynamic);\n        } else {\n          addAttr(el, name, value, list[i], isDynamic);\n        }\n      } else if (onRE.test(name)) {\n        // v-on\n        name = name.replace(onRE, '');\n        isDynamic = dynamicArgRE.test(name);\n\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n\n        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n      } else {\n        // normal directives\n        name = name.replace(dirRE, ''); // parse arg\n\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        isDynamic = false;\n\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n\n          if (dynamicArgRE.test(arg)) {\n            arg = arg.slice(1, -1);\n            isDynamic = true;\n          }\n        }\n\n        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n\n        if (false) {}\n      }\n    } else {\n      // literal attribute\n      if (false) { var res; }\n\n      addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n\n      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true', list[i]);\n      }\n    }\n  }\n}\n\nfunction checkInFor(el) {\n  var parent = el;\n\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true;\n    }\n\n    parent = parent.parent;\n  }\n\n  return false;\n}\n\nfunction parseModifiers(name) {\n  var match = name.match(modifierRE);\n\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) {\n      ret[m.slice(1)] = true;\n    });\n    return ret;\n  }\n}\n\nfunction makeAttrsMap(attrs) {\n  var map = {};\n\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (false) {}\n\n    map[attrs[i].name] = attrs[i].value;\n  }\n\n  return map;\n} // for script (e.g. type=\"x/template\") or style, do not decode content\n\n\nfunction isTextTag(el) {\n  return el.tag === 'script' || el.tag === 'style';\n}\n\nfunction isForbiddenTag(el) {\n  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n/* istanbul ignore next */\n\nfunction guardIESVGBug(attrs) {\n  var res = [];\n\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n\n  return res;\n}\n\nfunction checkForAliasModel(el, value) {\n  var _el = el;\n\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\", el.rawAttrsMap['v-model']);\n    }\n\n    _el = _el.parent;\n  }\n}\n/*  */\n\n\nfunction preTransformNode(el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n\n    if (!map['v-model']) {\n      return;\n    }\n\n    var typeBinding;\n\n    if (map[':type'] || map['v-bind:type']) {\n      typeBinding = getBindingAttr(el, 'type');\n    }\n\n    if (!map.type && !typeBinding && map['v-bind']) {\n      typeBinding = \"(\" + map['v-bind'] + \").type\";\n    }\n\n    if (typeBinding) {\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? \"&&(\" + ifCondition + \")\" : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox\n\n      var branch0 = cloneASTElement(el); // process for on the main node\n\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      }); // 2. add radio else-if condition\n\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      }); // 3. other\n\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0;\n    }\n  }\n}\n\nfunction cloneASTElement(el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent);\n}\n\nvar model$1 = {\n  preTransformNode: preTransformNode\n};\nvar modules$1 = [klass$1, style$1, model$1];\n/*  */\n\nfunction text(el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', \"_s(\" + dir.value + \")\", dir);\n  }\n}\n/*  */\n\n\nfunction html(el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\", dir);\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\nvar genStaticKeysCached = cached(genStaticKeys$1);\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\n\nfunction optimize(root, options) {\n  if (!root) {\n    return;\n  }\n\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.\n\n  markStatic$1(root); // second pass: mark static roots.\n\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1(keys) {\n  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));\n}\n\nfunction markStatic$1(node) {\n  node.static = isStatic(node);\n\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n      return;\n    }\n\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots(node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    } // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n\n\n    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n      node.staticRoot = true;\n      return;\n    } else {\n      node.staticRoot = false;\n    }\n\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic(node) {\n  if (node.type === 2) {\n    // expression\n    return false;\n  }\n\n  if (node.type === 3) {\n    // text\n    return true;\n  }\n\n  return !!(node.pre || !node.hasBindings && // no dynamic bindings\n  !node.if && !node.for && // not v-if or v-for or v-else\n  !isBuiltInTag(node.tag) && // not a built-in\n  isPlatformReservedTag(node.tag) && // not a component\n  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n}\n\nfunction isDirectChildOfTemplateFor(node) {\n  while (node.parent) {\n    node = node.parent;\n\n    if (node.tag !== 'template') {\n      return false;\n    }\n\n    if (node.for) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/*  */\n\n\nvar fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function(?:\\s+[\\w$]+)?\\s*\\(/;\nvar fnInvokeRE = /\\([^)]*?\\);*$/;\nvar simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/; // KeyboardEvent.keyCode aliases\n\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n}; // KeyboardEvent.key aliases\n\nvar keyNames = {\n  // #7880: IE11 and Edge use `Esc` for Escape key name.\n  esc: ['Esc', 'Escape'],\n  tab: 'Tab',\n  enter: 'Enter',\n  // #9112: IE11 uses `Spacebar` for Space key name.\n  space: [' ', 'Spacebar'],\n  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n  up: ['Up', 'ArrowUp'],\n  left: ['Left', 'ArrowLeft'],\n  right: ['Right', 'ArrowRight'],\n  down: ['Down', 'ArrowDown'],\n  // #9112: IE11 uses `Del` for Delete key name.\n  'delete': ['Backspace', 'Delete', 'Del']\n}; // #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\n\nvar genGuard = function (condition) {\n  return \"if(\" + condition + \")return null;\";\n};\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers(events, isNative) {\n  var prefix = isNative ? 'nativeOn:' : 'on:';\n  var staticHandlers = \"\";\n  var dynamicHandlers = \"\";\n\n  for (var name in events) {\n    var handlerCode = genHandler(events[name]);\n\n    if (events[name] && events[name].dynamic) {\n      dynamicHandlers += name + \",\" + handlerCode + \",\";\n    } else {\n      staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n    }\n  }\n\n  staticHandlers = \"{\" + staticHandlers.slice(0, -1) + \"}\";\n\n  if (dynamicHandlers) {\n    return prefix + \"_d(\" + staticHandlers + \",[\" + dynamicHandlers.slice(0, -1) + \"])\";\n  } else {\n    return prefix + staticHandlers;\n  }\n}\n\nfunction genHandler(handler) {\n  if (!handler) {\n    return 'function(){}';\n  }\n\n  if (Array.isArray(handler)) {\n    return \"[\" + handler.map(function (handler) {\n      return genHandler(handler);\n    }).join(',') + \"]\";\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n  if (!handler.modifiers) {\n    if (isMethodPath || isFunctionExpression) {\n      return handler.value;\n    }\n\n    return \"function($event){\" + (isFunctionInvocation ? \"return \" + handler.value : handler.value) + \"}\"; // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key]; // left/right\n\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = handler.modifiers;\n        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {\n          return !modifiers[keyModifier];\n        }).map(function (keyModifier) {\n          return \"$event.\" + keyModifier + \"Key\";\n        }).join('||'));\n      } else {\n        keys.push(key);\n      }\n    }\n\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    } // Make sure modifiers like prevent and stop get executed after key filtering\n\n\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n\n    var handlerCode = isMethodPath ? \"return \" + handler.value + \"($event)\" : isFunctionExpression ? \"return (\" + handler.value + \")($event)\" : isFunctionInvocation ? \"return \" + handler.value : handler.value;\n    return \"function($event){\" + code + handlerCode + \"}\";\n  }\n}\n\nfunction genKeyFilter(keys) {\n  return (// make sure the key filters only apply to KeyboardEvents\n    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n    // key events that do not have keyCode property...\n    \"if(!$event.type.indexOf('key')&&\" + keys.map(genFilterCode).join('&&') + \")return null;\"\n  );\n}\n\nfunction genFilterCode(key) {\n  var keyVal = parseInt(key, 10);\n\n  if (keyVal) {\n    return \"$event.keyCode!==\" + keyVal;\n  }\n\n  var keyCode = keyCodes[key];\n  var keyName = keyNames[key];\n  return \"_k($event.keyCode,\" + JSON.stringify(key) + \",\" + JSON.stringify(keyCode) + \",\" + \"$event.key,\" + \"\" + JSON.stringify(keyName) + \")\";\n}\n/*  */\n\n\nfunction on(el, dir) {\n  if (false) {}\n\n  el.wrapListeners = function (code) {\n    return \"_g(\" + code + \",\" + dir.value + \")\";\n  };\n}\n/*  */\n\n\nfunction bind$1(el, dir) {\n  el.wrapData = function (code) {\n    return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\";\n  };\n}\n/*  */\n\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n/*  */\n\nvar CodegenState = function CodegenState(options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n\n  this.maybeComponent = function (el) {\n    return !!el.component || !isReservedTag(el.tag);\n  };\n\n  this.onceId = 0;\n  this.staticRenderFns = [];\n  this.pre = false;\n};\n\nfunction generate(ast, options) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: \"with(this){return \" + code + \"}\",\n    staticRenderFns: state.staticRenderFns\n  };\n}\n\nfunction genElement(el, state) {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre;\n  }\n\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state);\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state);\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state);\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state);\n  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n    return genChildren(el, state) || 'void 0';\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state);\n  } else {\n    // component or element\n    var code;\n\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data;\n\n      if (!el.plain || el.pre && state.maybeComponent(el)) {\n        data = genData$2(el, state);\n      }\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n    } // module transforms\n\n\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n\n    return code;\n  }\n} // hoist static sub-trees out\n\n\nfunction genStatic(el, state) {\n  el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre\n  // node.  All pre nodes are static roots, so we can use this as a location to\n  // wrap a state change and reset it upon exiting the pre node.\n\n  var originalPreState = state.pre;\n\n  if (el.pre) {\n    state.pre = el.pre;\n  }\n\n  state.staticRenderFns.push(\"with(this){return \" + genElement(el, state) + \"}\");\n  state.pre = originalPreState;\n  return \"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n} // v-once\n\n\nfunction genOnce(el, state) {\n  el.onceProcessed = true;\n\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state);\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break;\n      }\n\n      parent = parent.parent;\n    }\n\n    if (!key) {\n       false && false;\n      return genElement(el, state);\n    }\n\n    return \"_o(\" + genElement(el, state) + \",\" + state.onceId++ + \",\" + key + \")\";\n  } else {\n    return genStatic(el, state);\n  }\n}\n\nfunction genIf(el, state, altGen, altEmpty) {\n  el.ifProcessed = true; // avoid recursion\n\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n}\n\nfunction genIfConditions(conditions, state, altGen, altEmpty) {\n  if (!conditions.length) {\n    return altEmpty || '_e()';\n  }\n\n  var condition = conditions.shift();\n\n  if (condition.exp) {\n    return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions, state, altGen, altEmpty);\n  } else {\n    return \"\" + genTernaryExp(condition.block);\n  } // v-if with v-once should generate code like (a)?_m(0):_m(1)\n\n\n  function genTernaryExp(el) {\n    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);\n  }\n}\n\nfunction genFor(el, state, altGen, altHelper) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n  var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n  if (false) {}\n\n  el.forProcessed = true; // avoid recursion\n\n  return (altHelper || '_l') + \"((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + (altGen || genElement)(el, state) + '})';\n}\n\nfunction genData$2(el, state) {\n  var data = '{'; // directives first.\n  // directives may mutate the el's other properties before they are generated.\n\n  var dirs = genDirectives(el, state);\n\n  if (dirs) {\n    data += dirs + ',';\n  } // key\n\n\n  if (el.key) {\n    data += \"key:\" + el.key + \",\";\n  } // ref\n\n\n  if (el.ref) {\n    data += \"ref:\" + el.ref + \",\";\n  }\n\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  } // pre\n\n\n  if (el.pre) {\n    data += \"pre:true,\";\n  } // record original tag name for components using \"is\" attribute\n\n\n  if (el.component) {\n    data += \"tag:\\\"\" + el.tag + \"\\\",\";\n  } // module data generation functions\n\n\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  } // attributes\n\n\n  if (el.attrs) {\n    data += \"attrs:\" + genProps(el.attrs) + \",\";\n  } // DOM props\n\n\n  if (el.props) {\n    data += \"domProps:\" + genProps(el.props) + \",\";\n  } // event handlers\n\n\n  if (el.events) {\n    data += genHandlers(el.events, false) + \",\";\n  }\n\n  if (el.nativeEvents) {\n    data += genHandlers(el.nativeEvents, true) + \",\";\n  } // slot target\n  // only for non-scoped slots\n\n\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + el.slotTarget + \",\";\n  } // scoped slots\n\n\n  if (el.scopedSlots) {\n    data += genScopedSlots(el, el.scopedSlots, state) + \",\";\n  } // component v-model\n\n\n  if (el.model) {\n    data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n  } // inline-template\n\n\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n\n  data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap\n  // v-bind with dynamic arguments must be applied using the same v-bind object\n  // merge helper so that class/style/mustUseProp attrs are handled correctly.\n\n  if (el.dynamicAttrs) {\n    data = \"_b(\" + data + \",\\\"\" + el.tag + \"\\\",\" + genProps(el.dynamicAttrs) + \")\";\n  } // v-bind data wrap\n\n\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  } // v-on data wrap\n\n\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n\n  return data;\n}\n\nfunction genDirectives(el, state) {\n  var dirs = el.directives;\n\n  if (!dirs) {\n    return;\n  }\n\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\" + (dir.isDynamicArg ? dir.arg : \"\\\"\" + dir.arg + \"\\\"\") : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n    }\n  }\n\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']';\n  }\n}\n\nfunction genInlineTemplate(el, state) {\n  var ast = el.children[0];\n\n  if (false) {}\n\n  if (ast && ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n      return \"function(){\" + code + \"}\";\n    }).join(',') + \"]}\";\n  }\n}\n\nfunction genScopedSlots(el, slots, state) {\n  // by default scoped slots are considered \"stable\", this allows child\n  // components with only scoped slots to skip forced updates from parent.\n  // but in some cases we have to bail-out of this optimization\n  // for example if the slot contains dynamic names, has v-if or v-for on them...\n  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n    var slot = slots[key];\n    return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n    ;\n  }); // #9534: if a component with scoped slots is inside a conditional branch,\n  // it's possible for the same component to be reused but with different\n  // compiled slot content. To avoid that, we generate a unique key based on\n  // the generated code of all the slot contents.\n\n  var needsKey = !!el.if; // OR when it is inside another scoped slot or v-for (the reactivity may be\n  // disconnected due to the intermediate scope variable)\n  // #9438, #9506\n  // TODO: this can be further optimized by properly analyzing in-scope bindings\n  // and skip force updating ones that do not actually use scope variables.\n\n  if (!needsForceUpdate) {\n    var parent = el.parent;\n\n    while (parent) {\n      if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent.for) {\n        needsForceUpdate = true;\n        break;\n      }\n\n      if (parent.if) {\n        needsKey = true;\n      }\n\n      parent = parent.parent;\n    }\n  }\n\n  var generatedSlots = Object.keys(slots).map(function (key) {\n    return genScopedSlot(slots[key], state);\n  }).join(',');\n  return \"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? \",null,false,\" + hash(generatedSlots) : \"\") + \")\";\n}\n\nfunction hash(str) {\n  var hash = 5381;\n  var i = str.length;\n\n  while (i) {\n    hash = hash * 33 ^ str.charCodeAt(--i);\n  }\n\n  return hash >>> 0;\n}\n\nfunction containsSlotChild(el) {\n  if (el.type === 1) {\n    if (el.tag === 'slot') {\n      return true;\n    }\n\n    return el.children.some(containsSlotChild);\n  }\n\n  return false;\n}\n\nfunction genScopedSlot(el, state) {\n  var isLegacySyntax = el.attrsMap['slot-scope'];\n\n  if (el.if && !el.ifProcessed && !isLegacySyntax) {\n    return genIf(el, state, genScopedSlot, \"null\");\n  }\n\n  if (el.for && !el.forProcessed) {\n    return genFor(el, state, genScopedSlot);\n  }\n\n  var slotScope = el.slotScope === emptySlotScopeToken ? \"\" : String(el.slotScope);\n  var fn = \"function(\" + slotScope + \"){\" + \"return \" + (el.tag === 'template' ? el.if && isLegacySyntax ? \"(\" + el.if + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\" : genChildren(el, state) || 'undefined' : genElement(el, state)) + \"}\"; // reverse proxy v-slot without scope on this.$slots\n\n  var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n  return \"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\";\n}\n\nfunction genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n  var children = el.children;\n\n  if (children.length) {\n    var el$1 = children[0]; // optimize single v-for\n\n    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n      var normalizationType = checkSkip ? state.maybeComponent(el$1) ? \",1\" : \",0\" : \"\";\n      return \"\" + (altGenElement || genElement)(el$1, state) + normalizationType;\n    }\n\n    var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;\n    var gen = altGenNode || genNode;\n    return \"[\" + children.map(function (c) {\n      return gen(c, state);\n    }).join(',') + \"]\" + (normalizationType$1 ? \",\" + normalizationType$1 : '');\n  }\n} // determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\n\n\nfunction getNormalizationType(children, maybeComponent) {\n  var res = 0;\n\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n\n    if (el.type !== 1) {\n      continue;\n    }\n\n    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n      return needsNormalization(c.block);\n    })) {\n      res = 2;\n      break;\n    }\n\n    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n      return maybeComponent(c.block);\n    })) {\n      res = 1;\n    }\n  }\n\n  return res;\n}\n\nfunction needsNormalization(el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n}\n\nfunction genNode(node, state) {\n  if (node.type === 1) {\n    return genElement(node, state);\n  } else if (node.type === 3 && node.isComment) {\n    return genComment(node);\n  } else {\n    return genText(node);\n  }\n}\n\nfunction genText(text) {\n  return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n  : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n}\n\nfunction genComment(comment) {\n  return \"_e(\" + JSON.stringify(comment.text) + \")\";\n}\n\nfunction genSlot(el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? \",\" + children : '');\n  var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {\n    return {\n      // slot props are camelized\n      name: camelize(attr.name),\n      value: attr.value,\n      dynamic: attr.dynamic\n    };\n  })) : null;\n  var bind$$1 = el.attrsMap['v-bind'];\n\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n\n  return res + ')';\n} // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n\n\nfunction genComponent(componentName, el, state) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return \"_c(\" + componentName + \",\" + genData$2(el, state) + (children ? \",\" + children : '') + \")\";\n}\n\nfunction genProps(props) {\n  var staticProps = \"\";\n  var dynamicProps = \"\";\n\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    var value = transformSpecialNewlines(prop.value);\n\n    if (prop.dynamic) {\n      dynamicProps += prop.name + \",\" + value + \",\";\n    } else {\n      staticProps += \"\\\"\" + prop.name + \"\\\":\" + value + \",\";\n    }\n  }\n\n  staticProps = \"{\" + staticProps.slice(0, -1) + \"}\";\n\n  if (dynamicProps) {\n    return \"_d(\" + staticProps + \",[\" + dynamicProps.slice(0, -1) + \"])\";\n  } else {\n    return staticProps;\n  }\n} // #3895, #4268\n\n\nfunction transformSpecialNewlines(text) {\n  return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n}\n/*  */\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\n\n\nvar prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b'); // these unary operators should not be used as property/method names\n\nvar unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)'); // strip strings in expressions\n\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g; // detect problematic expressions in a template\n\nfunction detectErrors(ast, warn) {\n  if (ast) {\n    checkNode(ast, warn);\n  }\n}\n\nfunction checkNode(node, warn) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n\n        if (value) {\n          var range = node.rawAttrsMap[name];\n\n          if (name === 'v-for') {\n            checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", warn, range);\n          } else if (name === 'v-slot' || name[0] === '#') {\n            checkFunctionParameterExpression(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n          } else if (onRE.test(name)) {\n            checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n          } else {\n            checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n          }\n        }\n      }\n    }\n\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], warn);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, warn, node);\n  }\n}\n\nfunction checkEvent(exp, text, warn, range) {\n  var stripped = exp.replace(stripStringRE, '');\n  var keywordMatch = stripped.match(unaryOperatorsRE);\n\n  if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {\n    warn(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim(), range);\n  }\n\n  checkExpression(exp, text, warn, range);\n}\n\nfunction checkFor(node, text, warn, range) {\n  checkExpression(node.for || '', text, warn, range);\n  checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n}\n\nfunction checkIdentifier(ident, type, text, warn, range) {\n  if (typeof ident === 'string') {\n    try {\n      new Function(\"var \" + ident + \"=_\");\n    } catch (e) {\n      warn(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim(), range);\n    }\n  }\n}\n\nfunction checkExpression(exp, text, warn, range) {\n  try {\n    new Function(\"return \" + exp);\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n\n    if (keywordMatch) {\n      warn(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\"\\n  Raw expression: \" + text.trim(), range);\n    } else {\n      warn(\"invalid expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\", range);\n    }\n  }\n}\n\nfunction checkFunctionParameterExpression(exp, text, warn, range) {\n  try {\n    new Function(exp, '');\n  } catch (e) {\n    warn(\"invalid function parameter expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\", range);\n  }\n}\n/*  */\n\n\nvar range = 2;\n\nfunction generateCodeFrame(source, start, end) {\n  if (start === void 0) start = 0;\n  if (end === void 0) end = source.length;\n  var lines = source.split(/\\r?\\n/);\n  var count = 0;\n  var res = [];\n\n  for (var i = 0; i < lines.length; i++) {\n    count += lines[i].length + 1;\n\n    if (count >= start) {\n      for (var j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) {\n          continue;\n        }\n\n        res.push(\"\" + (j + 1) + repeat$1(\" \", 3 - String(j + 1).length) + \"|  \" + lines[j]);\n        var lineLength = lines[j].length;\n\n        if (j === i) {\n          // push underline\n          var pad = start - (count - lineLength) + 1;\n          var length = end > count ? lineLength - pad : end - start;\n          res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n        } else if (j > i) {\n          if (end > count) {\n            var length$1 = Math.min(end - count, lineLength);\n            res.push(\"   |  \" + repeat$1(\"^\", length$1));\n          }\n\n          count += lineLength + 1;\n        }\n      }\n\n      break;\n    }\n  }\n\n  return res.join('\\n');\n}\n\nfunction repeat$1(str, n) {\n  var result = '';\n\n  if (n > 0) {\n    while (true) {\n      // eslint-disable-line\n      if (n & 1) {\n        result += str;\n      }\n\n      n >>>= 1;\n\n      if (n <= 0) {\n        break;\n      }\n\n      str += str;\n    }\n  }\n\n  return result;\n}\n/*  */\n\n\nfunction createFunction(code, errors) {\n  try {\n    return new Function(code);\n  } catch (err) {\n    errors.push({\n      err: err,\n      code: code\n    });\n    return noop;\n  }\n}\n\nfunction createCompileToFunctionFn(compile) {\n  var cache = Object.create(null);\n  return function compileToFunctions(template, options, vm) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n    /* istanbul ignore if */\n\n    if (false) {} // check cache\n\n\n    var key = options.delimiters ? String(options.delimiters) + template : template;\n\n    if (cache[key]) {\n      return cache[key];\n    } // compile\n\n\n    var compiled = compile(template, options); // check compilation errors/tips\n\n    if (false) {} // turn code into functions\n\n\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors);\n    }); // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n\n    /* istanbul ignore if */\n\n    if (false) {}\n\n    return cache[key] = res;\n  };\n}\n/*  */\n\n\nfunction createCompilerCreator(baseCompile) {\n  return function createCompiler(baseOptions) {\n    function compile(template, options) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n\n      var warn = function (msg, range, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        if (false) { var leadingSpaceLength; } // merge custom modules\n\n\n        if (options.modules) {\n          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n        } // merge custom directives\n\n\n        if (options.directives) {\n          finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\n        } // copy other options\n\n\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      finalOptions.warn = warn;\n      var compiled = baseCompile(template.trim(), finalOptions);\n\n      if (false) {}\n\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled;\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    };\n  };\n}\n/*  */\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\n\n\nvar createCompiler = createCompilerCreator(function baseCompile(template, options) {\n  var ast = parse(template.trim(), options);\n\n  if (options.optimize !== false) {\n    optimize(ast, options);\n  }\n\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  };\n});\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compile = ref$1.compile;\nvar compileToFunctions = ref$1.compileToFunctions;\n/*  */\n// check whether current browser encodes a char inside attribute values\n\nvar div;\n\nfunction getShouldDecode(href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0;\n} // #3663: IE encodes newlines inside attribute values while other browsers don't\n\n\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]\n\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML;\n});\nvar mount = Vue.prototype.$mount;\n\nVue.prototype.$mount = function (el, hydrating) {\n  el = el && query(el);\n  /* istanbul ignore if */\n\n  if (el === document.body || el === document.documentElement) {\n     false && false;\n    return this;\n  }\n\n  var options = this.$options; // resolve template/el and convert to render function\n\n  if (!options.render) {\n    var template = options.template;\n\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n\n          if (false) {}\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (false) {}\n\n        return this;\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n\n    if (template) {\n      /* istanbul ignore if */\n      if (false) {}\n\n      var ref = compileToFunctions(template, {\n        outputSourceRange: \"production\" !== 'production',\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n      /* istanbul ignore if */\n\n      if (false) {}\n    }\n  }\n\n  return mount.call(this, el, hydrating);\n};\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\n\n\nfunction getOuterHTML(el) {\n  if (el.outerHTML) {\n    return el.outerHTML;\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML;\n  }\n}\n\nVue.compile = compileToFunctions;\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vue);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17), __webpack_require__(47).setImmediate))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcz9hMDI2Il0sIm5hbWVzIjpbImVtcHR5T2JqZWN0IiwiT2JqZWN0IiwiZnJlZXplIiwiaXNVbmRlZiIsInYiLCJ1bmRlZmluZWQiLCJpc0RlZiIsImlzVHJ1ZSIsImlzRmFsc2UiLCJpc1ByaW1pdGl2ZSIsInZhbHVlIiwiaXNPYmplY3QiLCJvYmoiLCJfdG9TdHJpbmciLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsInRvUmF3VHlwZSIsImNhbGwiLCJzbGljZSIsImlzUGxhaW5PYmplY3QiLCJpc1JlZ0V4cCIsImlzVmFsaWRBcnJheUluZGV4IiwidmFsIiwibiIsInBhcnNlRmxvYXQiLCJTdHJpbmciLCJNYXRoIiwiZmxvb3IiLCJpc0Zpbml0ZSIsImlzUHJvbWlzZSIsInRoZW4iLCJjYXRjaCIsIkFycmF5IiwiaXNBcnJheSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0b051bWJlciIsImlzTmFOIiwibWFrZU1hcCIsInN0ciIsImV4cGVjdHNMb3dlckNhc2UiLCJtYXAiLCJjcmVhdGUiLCJsaXN0Iiwic3BsaXQiLCJpIiwibGVuZ3RoIiwidG9Mb3dlckNhc2UiLCJpc0J1aWx0SW5UYWciLCJpc1Jlc2VydmVkQXR0cmlidXRlIiwicmVtb3ZlIiwiYXJyIiwiaXRlbSIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsImhhc093blByb3BlcnR5IiwiaGFzT3duIiwia2V5IiwiY2FjaGVkIiwiZm4iLCJjYWNoZSIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwicmVwbGFjZSIsIl8iLCJjIiwidG9VcHBlckNhc2UiLCJjYXBpdGFsaXplIiwiY2hhckF0IiwiaHlwaGVuYXRlUkUiLCJoeXBoZW5hdGUiLCJwb2x5ZmlsbEJpbmQiLCJjdHgiLCJib3VuZEZuIiwiYSIsImwiLCJhcmd1bWVudHMiLCJhcHBseSIsIl9sZW5ndGgiLCJuYXRpdmVCaW5kIiwiYmluZCIsIkZ1bmN0aW9uIiwidG9BcnJheSIsInN0YXJ0IiwicmV0IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwicmVzIiwibm9vcCIsImIiLCJubyIsImlkZW50aXR5IiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJrZXlzIiwibSIsImNvbmNhdCIsInN0YXRpY0tleXMiLCJqb2luIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImlzQXJyYXlBIiwiaXNBcnJheUIiLCJldmVyeSIsImUiLCJEYXRlIiwiZ2V0VGltZSIsImtleXNBIiwia2V5c0IiLCJsb29zZUluZGV4T2YiLCJvbmNlIiwiY2FsbGVkIiwiU1NSX0FUVFIiLCJBU1NFVF9UWVBFUyIsIkxJRkVDWUNMRV9IT09LUyIsImNvbmZpZyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJwcm9jZXNzIiwiZGV2dG9vbHMiLCJwZXJmb3JtYW5jZSIsImVycm9ySGFuZGxlciIsIndhcm5IYW5kbGVyIiwiaWdub3JlZEVsZW1lbnRzIiwia2V5Q29kZXMiLCJpc1Jlc2VydmVkVGFnIiwiaXNSZXNlcnZlZEF0dHIiLCJpc1Vua25vd25FbGVtZW50IiwiZ2V0VGFnTmFtZXNwYWNlIiwicGFyc2VQbGF0Zm9ybVRhZ05hbWUiLCJtdXN0VXNlUHJvcCIsImFzeW5jIiwiX2xpZmVjeWNsZUhvb2tzIiwidW5pY29kZVJlZ0V4cCIsImlzUmVzZXJ2ZWQiLCJjaGFyQ29kZUF0IiwiZGVmIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJiYWlsUkUiLCJSZWdFeHAiLCJzb3VyY2UiLCJwYXJzZVBhdGgiLCJwYXRoIiwidGVzdCIsInNlZ21lbnRzIiwiaGFzUHJvdG8iLCJpbkJyb3dzZXIiLCJ3aW5kb3ciLCJpbldlZXgiLCJXWEVudmlyb25tZW50IiwicGxhdGZvcm0iLCJ3ZWV4UGxhdGZvcm0iLCJVQSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzSUUiLCJpc0lFOSIsImlzRWRnZSIsImlzQW5kcm9pZCIsImlzSU9TIiwiaXNDaHJvbWUiLCJpc1BoYW50b21KUyIsImlzRkYiLCJtYXRjaCIsIm5hdGl2ZVdhdGNoIiwid2F0Y2giLCJzdXBwb3J0c1Bhc3NpdmUiLCJvcHRzIiwiZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9pc1NlcnZlciIsImlzU2VydmVyUmVuZGVyaW5nIiwiZ2xvYmFsIiwiZW52IiwiVlVFX0VOViIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpc05hdGl2ZSIsIkN0b3IiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsIl9TZXQiLCJTZXQiLCJzZXQiLCJoYXMiLCJhZGQiLCJjbGVhciIsIndhcm4iLCJ0aXAiLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsInVpZCIsIkRlcCIsImlkIiwic3VicyIsImFkZFN1YiIsInN1YiIsInB1c2giLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJ0YXJnZXQiLCJhZGREZXAiLCJub3RpZnkiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJwb3BUYXJnZXQiLCJwb3AiLCJWTm9kZSIsInRhZyIsImRhdGEiLCJjaGlsZHJlbiIsInRleHQiLCJlbG0iLCJjb250ZXh0IiwiY29tcG9uZW50T3B0aW9ucyIsImFzeW5jRmFjdG9yeSIsIm5zIiwiZm5Db250ZXh0IiwiZm5PcHRpb25zIiwiZm5TY29wZUlkIiwiY29tcG9uZW50SW5zdGFuY2UiLCJwYXJlbnQiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiY2hpbGQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY3JlYXRlRW1wdHlWTm9kZSIsIm5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwidm5vZGUiLCJjbG9uZWQiLCJhcnJheVByb3RvIiwiYXJyYXlNZXRob2RzIiwibWV0aG9kc1RvUGF0Y2giLCJmb3JFYWNoIiwibWV0aG9kIiwib3JpZ2luYWwiLCJtdXRhdG9yIiwiYXJncyIsImxlbiIsInJlc3VsdCIsIm9iIiwiX19vYl9fIiwiaW5zZXJ0ZWQiLCJvYnNlcnZlQXJyYXkiLCJkZXAiLCJhcnJheUtleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwic2hvdWxkT2JzZXJ2ZSIsInRvZ2dsZU9ic2VydmluZyIsIk9ic2VydmVyIiwidm1Db3VudCIsInByb3RvQXVnbWVudCIsImNvcHlBdWdtZW50Iiwid2FsayIsImRlZmluZVJlYWN0aXZlJCQxIiwiaXRlbXMiLCJvYnNlcnZlIiwic3JjIiwiX19wcm90b19fIiwiYXNSb290RGF0YSIsImlzRXh0ZW5zaWJsZSIsIl9pc1Z1ZSIsImN1c3RvbVNldHRlciIsInNoYWxsb3ciLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJtYXgiLCJkZWwiLCJzdHJhdHMiLCJtZXJnZURhdGEiLCJmcm9tIiwidG9WYWwiLCJmcm9tVmFsIiwibWVyZ2VEYXRhT3JGbiIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwidm0iLCJtZXJnZWREYXRhRm4iLCJtZXJnZWRJbnN0YW5jZURhdGFGbiIsImluc3RhbmNlRGF0YSIsImRlZmF1bHREYXRhIiwibWVyZ2VIb29rIiwiZGVkdXBlSG9va3MiLCJob29rcyIsImhvb2siLCJtZXJnZUFzc2V0cyIsImFzc2VydE9iamVjdFR5cGUiLCJ0eXBlIiwia2V5JDEiLCJwcm9wcyIsIm1ldGhvZHMiLCJpbmplY3QiLCJjb21wdXRlZCIsInByb3ZpZGUiLCJkZWZhdWx0U3RyYXQiLCJjaGVja0NvbXBvbmVudHMiLCJvcHRpb25zIiwiY29tcG9uZW50cyIsInZhbGlkYXRlQ29tcG9uZW50TmFtZSIsIm5hbWUiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZUluamVjdCIsIm5vcm1hbGl6ZWQiLCJub3JtYWxpemVEaXJlY3RpdmVzIiwiZGlycyIsImRpcmVjdGl2ZXMiLCJkZWYkJDEiLCJtZXJnZU9wdGlvbnMiLCJfYmFzZSIsImV4dGVuZHMiLCJtaXhpbnMiLCJtZXJnZUZpZWxkIiwic3RyYXQiLCJyZXNvbHZlQXNzZXQiLCJ3YXJuTWlzc2luZyIsImFzc2V0cyIsImNhbWVsaXplZElkIiwiUGFzY2FsQ2FzZUlkIiwidmFsaWRhdGVQcm9wIiwicHJvcE9wdGlvbnMiLCJwcm9wc0RhdGEiLCJwcm9wIiwiYWJzZW50IiwiYm9vbGVhbkluZGV4IiwiZ2V0VHlwZUluZGV4IiwiQm9vbGVhbiIsInN0cmluZ0luZGV4IiwiZ2V0UHJvcERlZmF1bHRWYWx1ZSIsInByZXZTaG91bGRPYnNlcnZlIiwiZGVmYXVsdCIsIiRvcHRpb25zIiwiX3Byb3BzIiwiZ2V0VHlwZSIsImFzc2VydFByb3AiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJnZXRJbnZhbGlkVHlwZU1lc3NhZ2UiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwidCIsImlzU2FtZVR5cGUiLCJtZXNzYWdlIiwicmVjZWl2ZWRUeXBlIiwiZXhwZWN0ZWRWYWx1ZSIsInN0eWxlVmFsdWUiLCJyZWNlaXZlZFZhbHVlIiwiaXNFeHBsaWNhYmxlIiwiaXNCb29sZWFuIiwiTnVtYmVyIiwiZXhwbGljaXRUeXBlcyIsInNvbWUiLCJlbGVtIiwiaGFuZGxlRXJyb3IiLCJlcnIiLCJpbmZvIiwiY3VyIiwiJHBhcmVudCIsImVycm9yQ2FwdHVyZWQiLCJjYXB0dXJlIiwiZ2xvYmFsSGFuZGxlRXJyb3IiLCJpbnZva2VXaXRoRXJyb3JIYW5kbGluZyIsImhhbmRsZXIiLCJfaGFuZGxlZCIsImxvZ0Vycm9yIiwiY29uc29sZSIsImVycm9yIiwiaXNVc2luZ01pY3JvVGFzayIsImNhbGxiYWNrcyIsInBlbmRpbmciLCJmbHVzaENhbGxiYWNrcyIsImNvcGllcyIsInRpbWVyRnVuYyIsIlByb21pc2UiLCJwIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJNdXRhdGlvbk9ic2VydmVyIiwiY291bnRlciIsIm9ic2VydmVyIiwidGV4dE5vZGUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwiY2hhcmFjdGVyRGF0YSIsInNldEltbWVkaWF0ZSIsIm5leHRUaWNrIiwiY2IiLCJfcmVzb2x2ZSIsIm1hcmsiLCJtZWFzdXJlIiwiaW5pdFByb3h5Iiwic2Vlbk9iamVjdHMiLCJ0cmF2ZXJzZSIsIl90cmF2ZXJzZSIsInNlZW4iLCJpc0EiLCJpc0Zyb3plbiIsImRlcElkIiwibm9ybWFsaXplRXZlbnQiLCJwYXNzaXZlIiwib25jZSQkMSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJhcmd1bWVudHMkMSIsInVwZGF0ZUxpc3RlbmVycyIsIm9uIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjcmVhdGVPbmNlSGFuZGxlciIsIm9sZCIsImV2ZW50IiwicGFyYW1zIiwibWVyZ2VWTm9kZUhvb2siLCJob29rS2V5Iiwib2xkSG9vayIsIndyYXBwZWRIb29rIiwibWVyZ2VkIiwiZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSIsImF0dHJzIiwiYWx0S2V5IiwiY2hlY2tQcm9wIiwiaGFzaCIsInByZXNlcnZlIiwic2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4iLCJpc1RleHROb2RlIiwibmVzdGVkSW5kZXgiLCJsYXN0SW5kZXgiLCJsYXN0Iiwic2hpZnQiLCJfaXNWTGlzdCIsImluaXRQcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJyZXNvbHZlSW5qZWN0IiwicHJvdmlkZUtleSIsInByb3ZpZGVEZWZhdWx0IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJzbG90IiwibmFtZSQxIiwiaXNXaGl0ZXNwYWNlIiwibm9ybWFsaXplU2NvcGVkU2xvdHMiLCJub3JtYWxTbG90cyIsInByZXZTbG90cyIsImhhc05vcm1hbFNsb3RzIiwiaXNTdGFibGUiLCIkc3RhYmxlIiwiJGtleSIsIl9ub3JtYWxpemVkIiwiJGhhc05vcm1hbCIsIm5vcm1hbGl6ZVNjb3BlZFNsb3QiLCJrZXkkMiIsInByb3h5Tm9ybWFsU2xvdCIsInByb3h5IiwicmVuZGVyTGlzdCIsInJlbmRlciIsIml0ZXJhdG9yIiwibmV4dCIsImRvbmUiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwiJHNjb3BlZFNsb3RzIiwibm9kZXMiLCIkc2xvdHMiLCIkY3JlYXRlRWxlbWVudCIsInJlc29sdmVGaWx0ZXIiLCJpc0tleU5vdE1hdGNoIiwiZXhwZWN0IiwiYWN0dWFsIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5LZXlDb2RlIiwiZXZlbnRLZXlOYW1lIiwiYnVpbHRJbktleU5hbWUiLCJtYXBwZWRLZXlDb2RlIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwibG9vcCIsImRvbVByb3BzIiwiY2FtZWxpemVkS2V5IiwiaHlwaGVuYXRlZEtleSIsIiRldmVudCIsInJlbmRlclN0YXRpYyIsImlzSW5Gb3IiLCJfc3RhdGljVHJlZXMiLCJ0cmVlIiwic3RhdGljUmVuZGVyRm5zIiwiX3JlbmRlclByb3h5IiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiaGFzRHluYW1pY0tleXMiLCJjb250ZW50SGFzaEtleSIsImJpbmREeW5hbWljS2V5cyIsImJhc2VPYmoiLCJ2YWx1ZXMiLCJwcmVwZW5kTW9kaWZpZXIiLCJzeW1ib2wiLCJpbnN0YWxsUmVuZGVySGVscGVycyIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsIl9kIiwiX3AiLCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCIsInRoaXMkMSIsImNvbnRleHRWbSIsIl9vcmlnaW5hbCIsImlzQ29tcGlsZWQiLCJfY29tcGlsZWQiLCJuZWVkTm9ybWFsaXphdGlvbiIsImxpc3RlbmVycyIsImluamVjdGlvbnMiLCJzY29wZWRTbG90cyIsIl9zY29wZUlkIiwiX2MiLCJkIiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJtZXJnZVByb3BzIiwicmVuZGVyQ29udGV4dCIsImNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQiLCJ2bm9kZXMiLCJjbG9uZSIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJpbml0IiwiaHlkcmF0aW5nIiwiX2lzRGVzdHJveWVkIiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUiLCJhY3RpdmVJbnN0YW5jZSIsIiRtb3VudCIsIm9sZFZub2RlIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJpbnNlcnQiLCJfaXNNb3VudGVkIiwiY2FsbEhvb2siLCJxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkZXN0cm95IiwiJGRlc3Ryb3kiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJiYXNlQ3RvciIsImNpZCIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImZ1bmN0aW9uYWwiLCJuYXRpdmVPbiIsImFic3RyYWN0IiwiaW5zdGFsbENvbXBvbmVudEhvb2tzIiwiX2lzQ29tcG9uZW50IiwiX3BhcmVudFZub2RlIiwiaW5saW5lVGVtcGxhdGUiLCJ0b01lcmdlIiwiX21lcmdlZCIsIm1lcmdlSG9vayQxIiwiZjEiLCJmMiIsImNhbGxiYWNrIiwiU0lNUExFX05PUk1BTElaRSIsIkFMV0FZU19OT1JNQUxJWkUiLCJub3JtYWxpemF0aW9uVHlwZSIsImFsd2F5c05vcm1hbGl6ZSIsIl9jcmVhdGVFbGVtZW50IiwiaXMiLCIkdm5vZGUiLCJwcmUiLCJhcHBseU5TIiwicmVnaXN0ZXJEZWVwQmluZGluZ3MiLCJmb3JjZSIsInN0eWxlIiwiY2xhc3MiLCJpbml0UmVuZGVyIiwiX3Zub2RlIiwicGFyZW50Vm5vZGUiLCJfcmVuZGVyQ2hpbGRyZW4iLCJwYXJlbnREYXRhIiwiX3BhcmVudExpc3RlbmVycyIsImN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSIsInJlbmRlck1peGluIiwiVnVlIiwiJG5leHRUaWNrIiwiX3JlbmRlciIsInJlZiIsImVuc3VyZUN0b3IiLCJjb21wIiwiYmFzZSIsIl9fZXNNb2R1bGUiLCJ0b1N0cmluZ1RhZyIsImZhY3RvcnkiLCJlcnJvckNvbXAiLCJyZXNvbHZlZCIsIm93bmVyIiwib3duZXJzIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwic3luYyIsInRpbWVyTG9hZGluZyIsInRpbWVyVGltZW91dCIsIiRvbiIsImZvcmNlUmVuZGVyIiwicmVuZGVyQ29tcGxldGVkIiwiJGZvcmNlVXBkYXRlIiwiY2xlYXJUaW1lb3V0IiwicmVqZWN0IiwicmVhc29uIiwiY29tcG9uZW50IiwiZGVsYXkiLCJ0aW1lb3V0IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsInJlbW92ZSQxIiwiJG9mZiIsIl90YXJnZXQiLCJvbmNlSGFuZGxlciIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiaG9va1JFIiwiJG9uY2UiLCJpJDEiLCJjYnMiLCIkZW1pdCIsImlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCIsInNldEFjdGl2ZUluc3RhbmNlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiaW5pdExpZmVjeWNsZSIsIiRjaGlsZHJlbiIsIiRyb290IiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwicmVzdG9yZUFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX192dWVfXyIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsImVsIiwidXBkYXRlQ29tcG9uZW50IiwiV2F0Y2hlciIsImJlZm9yZSIsInJlbmRlckNoaWxkcmVuIiwibmV3U2NvcGVkU2xvdHMiLCJvbGRTY29wZWRTbG90cyIsImhhc0R5bmFtaWNTY29wZWRTbG90IiwibmVlZHNGb3JjZVVwZGF0ZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJkaXJlY3QiLCJoYW5kbGVycyIsImoiLCJNQVhfVVBEQVRFX0NPVU5UIiwicXVldWUiLCJhY3RpdmF0ZWRDaGlsZHJlbiIsImNpcmN1bGFyIiwid2FpdGluZyIsImZsdXNoaW5nIiwicmVzZXRTY2hlZHVsZXJTdGF0ZSIsImN1cnJlbnRGbHVzaFRpbWVzdGFtcCIsImdldE5vdyIsIm5vdyIsImNyZWF0ZUV2ZW50IiwidGltZVN0YW1wIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJzb3J0IiwicnVuIiwiYWN0aXZhdGVkUXVldWUiLCJ1cGRhdGVkUXVldWUiLCJjYWxsQWN0aXZhdGVkSG9va3MiLCJjYWxsVXBkYXRlZEhvb2tzIiwiZW1pdCIsInF1ZXVlV2F0Y2hlciIsInVpZCQyIiwiZXhwT3JGbiIsImlzUmVuZGVyV2F0Y2hlciIsImRlZXAiLCJ1c2VyIiwibGF6eSIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJleHByZXNzaW9uIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsImV2YWx1YXRlIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwic291cmNlS2V5IiwicHJveHlHZXR0ZXIiLCJwcm94eVNldHRlciIsImluaXRTdGF0ZSIsImluaXRQcm9wcyIsImluaXRNZXRob2RzIiwiaW5pdERhdGEiLCJpbml0Q29tcHV0ZWQiLCJpbml0V2F0Y2giLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJpc1NTUiIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsInNob3VsZENhY2hlIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVHZXR0ZXJJbnZva2VyIiwiY29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVXYXRjaGVyIiwiJHdhdGNoIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwidWlkJDMiLCJpbml0TWl4aW4iLCJfaW5pdCIsIl91aWQiLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRJbnRlcm5hbENvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwiX3NlbGYiLCJ2bm9kZUNvbXBvbmVudE9wdGlvbnMiLCJfY29tcG9uZW50VGFnIiwic3VwZXIiLCJzdXBlck9wdGlvbnMiLCJjYWNoZWRTdXBlck9wdGlvbnMiLCJtb2RpZmllZE9wdGlvbnMiLCJyZXNvbHZlTW9kaWZpZWRPcHRpb25zIiwiZXh0ZW5kT3B0aW9ucyIsIm1vZGlmaWVkIiwibGF0ZXN0Iiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImluaXRVc2UiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsZWRQbHVnaW5zIiwiX2luc3RhbGxlZFBsdWdpbnMiLCJ1bnNoaWZ0IiwiaW5zdGFsbCIsImluaXRNaXhpbiQxIiwibWl4aW4iLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsImdldENvbXBvbmVudE5hbWUiLCJtYXRjaGVzIiwicGF0dGVybiIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImZpbHRlciIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwiY2FjaGVkJCQxIiwicGF0dGVyblR5cGVzIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwibW91bnRlZCIsInJlZiQxIiwicGFyc2VJbnQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVmaW5lUmVhY3RpdmUiLCJkZWxldGUiLCJvYnNlcnZhYmxlIiwic3NyQ29udGV4dCIsInZlcnNpb24iLCJhY2NlcHRWYWx1ZSIsImF0dHIiLCJpc0VudW1lcmF0ZWRBdHRyIiwiaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlIiwiY29udmVydEVudW1lcmF0ZWRWYWx1ZSIsImlzRmFsc3lBdHRyVmFsdWUiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNUZXh0SW5wdXRUeXBlIiwicXVlcnkiLCJzZWxlY3RlZCIsInF1ZXJ5U2VsZWN0b3IiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJuYW1lc3BhY2UiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwibmV4dFNpYmxpbmciLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50Iiwic2V0U3R5bGVTY29wZSIsInNjb3BlSWQiLCJub2RlT3BzIiwicmVnaXN0ZXJSZWYiLCJpc1JlbW92YWwiLCJyZWZzIiwicmVmSW5Gb3IiLCJlbXB0eU5vZGUiLCJzYW1lVm5vZGUiLCJzYW1lSW5wdXRUeXBlIiwidHlwZUEiLCJ0eXBlQiIsImNyZWF0ZUtleVRvT2xkSWR4IiwiYmVnaW5JZHgiLCJlbmRJZHgiLCJjcmVhdGVQYXRjaEZ1bmN0aW9uIiwiYmFja2VuZCIsImVtcHR5Tm9kZUF0IiwiY3JlYXRlUm1DYiIsImNoaWxkRWxtIiwicmVtb3ZlTm9kZSIsImlzVW5rbm93bkVsZW1lbnQkJDEiLCJpblZQcmUiLCJpZ25vcmUiLCJjcmVhdGluZ0VsbUluVlByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsInBhcmVudEVsbSIsInJlZkVsbSIsIm5lc3RlZCIsIm93bmVyQXJyYXkiLCJzZXRTY29wZSIsImNyZWF0ZUNoaWxkcmVuIiwiaW52b2tlQ3JlYXRlSG9va3MiLCJpc1JlYWN0aXZhdGVkIiwiaW5pdENvbXBvbmVudCIsInJlYWN0aXZhdGVDb21wb25lbnQiLCJwZW5kaW5nSW5zZXJ0IiwiaXNQYXRjaGFibGUiLCJpbm5lck5vZGUiLCJ0cmFuc2l0aW9uIiwiYWN0aXZhdGUiLCJyZWYkJDEiLCJhbmNlc3RvciIsImFkZFZub2RlcyIsInN0YXJ0SWR4IiwiaW52b2tlRGVzdHJveUhvb2siLCJyZW1vdmVWbm9kZXMiLCJjaCIsInJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2siLCJybSIsInVwZGF0ZUNoaWxkcmVuIiwib2xkQ2giLCJuZXdDaCIsInJlbW92ZU9ubHkiLCJvbGRTdGFydElkeCIsIm5ld1N0YXJ0SWR4Iiwib2xkRW5kSWR4Iiwib2xkU3RhcnRWbm9kZSIsIm9sZEVuZFZub2RlIiwibmV3RW5kSWR4IiwibmV3U3RhcnRWbm9kZSIsIm5ld0VuZFZub2RlIiwib2xkS2V5VG9JZHgiLCJpZHhJbk9sZCIsInZub2RlVG9Nb3ZlIiwiY2FuTW92ZSIsInBhdGNoVm5vZGUiLCJmaW5kSWR4SW5PbGQiLCJjaGVja0R1cGxpY2F0ZUtleXMiLCJzZWVuS2V5cyIsImVuZCIsImh5ZHJhdGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImh5ZHJhdGlvbkJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJoYXNDaGlsZE5vZGVzIiwiaW5uZXJIVE1MIiwiY2hpbGRyZW5NYXRjaCIsImZpcnN0Q2hpbGQiLCJmdWxsSW52b2tlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwibm9kZVR5cGUiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsIl9sZWF2ZUNiIiwicGF0Y2hhYmxlIiwiaSQyIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImRpciIsImNhbGxIb29rJDEiLCJvbGRBcmciLCJhcmciLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwiaW5oZXJpdEF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJiYXNlU2V0QXR0ciIsInNldEF0dHJpYnV0ZU5TIiwiX19pZXBoIiwiYmxvY2tlciIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1cGRhdGVDbGFzcyIsIm9sZERhdGEiLCJjbHMiLCJ0cmFuc2l0aW9uQ2xhc3MiLCJfdHJhbnNpdGlvbkNsYXNzZXMiLCJfcHJldkNsYXNzIiwia2xhc3MiLCJ2YWxpZERpdmlzaW9uQ2hhclJFIiwicGFyc2VGaWx0ZXJzIiwiZXhwIiwiaW5TaW5nbGUiLCJpbkRvdWJsZSIsImluVGVtcGxhdGVTdHJpbmciLCJpblJlZ2V4IiwiY3VybHkiLCJzcXVhcmUiLCJwYXJlbiIsImxhc3RGaWx0ZXJJbmRleCIsInByZXYiLCJmaWx0ZXJzIiwidHJpbSIsInB1c2hGaWx0ZXIiLCJ3cmFwRmlsdGVyIiwiYmFzZVdhcm4iLCJtc2ciLCJyYW5nZSIsInBsdWNrTW9kdWxlRnVuY3Rpb24iLCJhZGRQcm9wIiwiZHluYW1pYyIsInJhbmdlU2V0SXRlbSIsInBsYWluIiwiYWRkQXR0ciIsImR5bmFtaWNBdHRycyIsImFkZFJhd0F0dHIiLCJhdHRyc01hcCIsImF0dHJzTGlzdCIsImFkZERpcmVjdGl2ZSIsImlzRHluYW1pY0FyZyIsInByZXBlbmRNb2RpZmllck1hcmtlciIsImFkZEhhbmRsZXIiLCJpbXBvcnRhbnQiLCJyaWdodCIsIm1pZGRsZSIsImV2ZW50cyIsIm5hdGl2ZSIsIm5hdGl2ZUV2ZW50cyIsIm5ld0hhbmRsZXIiLCJnZXRSYXdCaW5kaW5nQXR0ciIsInJhd0F0dHJzTWFwIiwiZ2V0QmluZGluZ0F0dHIiLCJnZXRTdGF0aWMiLCJkeW5hbWljVmFsdWUiLCJnZXRBbmRSZW1vdmVBdHRyIiwic3RhdGljVmFsdWUiLCJyZW1vdmVGcm9tTWFwIiwiZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgiLCJnZW5Db21wb25lbnRNb2RlbCIsIm51bWJlciIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJwYXJzZU1vZGVsIiwiY2hyIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJpc1N0cmluZ1N0YXJ0IiwicGFyc2VTdHJpbmciLCJwYXJzZUJyYWNrZXQiLCJpbkJyYWNrZXQiLCJzdHJpbmdRdW90ZSIsIndhcm4kMSIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJfd2FybiIsImdlblNlbGVjdCIsImdlbkNoZWNrYm94TW9kZWwiLCJnZW5SYWRpb01vZGVsIiwiZ2VuRGVmYXVsdE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwic2VsZWN0ZWRWYWwiLCJjb2RlIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJjaGFuZ2UiLCJ0YXJnZXQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyJDEiLCJyZW1vdmUkMiIsInVzZU1pY3JvdGFza0ZpeCIsImFkZCQxIiwiYXR0YWNoZWRUaW1lc3RhbXAiLCJfd3JhcHBlciIsImN1cnJlbnRUYXJnZXQiLCJvd25lckRvY3VtZW50IiwidXBkYXRlRE9NTGlzdGVuZXJzIiwic3ZnQ29udGFpbmVyIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsImNoaWxkTm9kZXMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNOb3RJbkZvY3VzQW5kRGlydHkiLCJpc0RpcnR5V2l0aE1vZGlmaWVycyIsIm5vdEluRm9jdXMiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsIndoaXRlc3BhY2VSRSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiZXhwZWN0c0NTUyIsInVzZXJXYW50c0NvbnRyb2wiLCJnZXRIb29rQXJndW1lbnRzTGVuZ3RoIiwic2hvdyIsInBlbmRpbmdOb2RlIiwiX3BlbmRpbmciLCJpc1ZhbGlkRHVyYXRpb24iLCJsZWF2ZSIsImJlZm9yZUxlYXZlIiwiYWZ0ZXJMZWF2ZSIsImxlYXZlQ2FuY2VsbGVkIiwiZGVsYXlMZWF2ZSIsImV4cGxpY2l0TGVhdmVEdXJhdGlvbiIsInBlcmZvcm1MZWF2ZSIsImNoZWNrRHVyYXRpb24iLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwidHJpZ2dlciIsImRpcmVjdGl2ZSIsImJpbmRpbmciLCJfdk9wdGlvbnMiLCJzZXRTZWxlY3RlZCIsImdldFZhbHVlIiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvbkVuZCIsInByZXZPcHRpb25zIiwiY3VyT3B0aW9ucyIsIm8iLCJuZWVkUmVzZXQiLCJoYXNOb01hdGNoaW5nT3B0aW9uIiwiYWN0dWFsbHlTZXRTZWxlY3RlZCIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJzZWxlY3RlZEluZGV4IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImxvY2F0ZU5vZGUiLCJ0cmFuc2l0aW9uJCQxIiwib3JpZ2luYWxEaXNwbGF5IiwiX192T3JpZ2luYWxEaXNwbGF5IiwiZGlzcGxheSIsInVuYmluZCIsInBsYXRmb3JtRGlyZWN0aXZlcyIsInRyYW5zaXRpb25Qcm9wcyIsIm1vZGUiLCJnZXRSZWFsQ2hpbGQiLCJjb21wT3B0aW9ucyIsImV4dHJhY3RUcmFuc2l0aW9uRGF0YSIsInBsYWNlaG9sZGVyIiwiaCIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJpc05vdFRleHROb2RlIiwiaXNWU2hvd0RpcmVjdGl2ZSIsIlRyYW5zaXRpb24iLCJfbGVhdmluZyIsIm9sZFJhd0NoaWxkIiwiZGVsYXllZExlYXZlIiwibW92ZUNsYXNzIiwiVHJhbnNpdGlvbkdyb3VwIiwiYmVmb3JlTW91bnQiLCJrZXB0IiwicHJldkNoaWxkcmVuIiwicmF3Q2hpbGRyZW4iLCJ0cmFuc2l0aW9uRGF0YSIsInJlbW92ZWQiLCJjJDEiLCJwb3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ1cGRhdGVkIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiX3JlZmxvdyIsImJvZHkiLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwibGVmdCIsImR5IiwidG9wIiwicGxhdGZvcm1Db21wb25lbnRzIiwiZGVmYXVsdFRhZ1JFIiwicmVnZXhFc2NhcGVSRSIsImJ1aWxkUmVnZXgiLCJkZWxpbWl0ZXJzIiwib3BlbiIsImNsb3NlIiwicGFyc2VUZXh0IiwidGFnUkUiLCJ0b2tlbnMiLCJyYXdUb2tlbnMiLCJ0b2tlblZhbHVlIiwiZXhlYyIsInRyYW5zZm9ybU5vZGUiLCJjbGFzc0JpbmRpbmciLCJnZW5EYXRhIiwia2xhc3MkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMSIsInN0eWxlJDEiLCJkZWNvZGVyIiwiaGUiLCJkZWNvZGUiLCJodG1sIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwiYXR0cmlidXRlIiwiZHluYW1pY0FyZ0F0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsImlzUGxhaW5UZXh0RWxlbWVudCIsInJlQ2FjaGUiLCJkZWNvZGluZ01hcCIsImVuY29kZWRBdHRyIiwiZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMiLCJpc0lnbm9yZU5ld2xpbmVUYWciLCJzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUiLCJkZWNvZGVBdHRyIiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJyZSIsInBhcnNlSFRNTCIsInN0YWNrIiwiZXhwZWN0SFRNTCIsImlzVW5hcnlUYWckJDEiLCJjYW5CZUxlZnRPcGVuVGFnJCQxIiwibGFzdFRhZyIsInRleHRFbmQiLCJjb21tZW50RW5kIiwic2hvdWxkS2VlcENvbW1lbnQiLCJzdWJzdHJpbmciLCJhZHZhbmNlIiwiY29uZGl0aW9uYWxFbmQiLCJkb2N0eXBlTWF0Y2giLCJlbmRUYWdNYXRjaCIsImN1ckluZGV4IiwicGFyc2VFbmRUYWciLCJzdGFydFRhZ01hdGNoIiwicGFyc2VTdGFydFRhZyIsImhhbmRsZVN0YXJ0VGFnIiwicmVzdCIsImNoYXJzIiwiZW5kVGFnTGVuZ3RoIiwic3RhY2tlZFRhZyIsInJlU3RhY2tlZFRhZyIsInJlc3QkMSIsImFsbCIsInVuYXJ5U2xhc2giLCJ1bmFyeSIsInNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiIsImxvd2VyQ2FzZWRUYWciLCJsb3dlckNhc2VkVGFnTmFtZSIsIm9uUkUiLCJkaXJSRSIsImZvckFsaWFzUkUiLCJmb3JJdGVyYXRvclJFIiwic3RyaXBQYXJlbnNSRSIsImR5bmFtaWNBcmdSRSIsImFyZ1JFIiwiYmluZFJFIiwibW9kaWZpZXJSRSIsInNsb3RSRSIsImxpbmVCcmVha1JFIiwid2hpdGVzcGFjZVJFJDEiLCJpbnZhbGlkQXR0cmlidXRlUkUiLCJkZWNvZGVIVE1MQ2FjaGVkIiwiZW1wdHlTbG90U2NvcGVUb2tlbiIsIndhcm4kMiIsInRyYW5zZm9ybXMiLCJwcmVUcmFuc2Zvcm1zIiwicG9zdFRyYW5zZm9ybXMiLCJwbGF0Zm9ybUlzUHJlVGFnIiwicGxhdGZvcm1NdXN0VXNlUHJvcCIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwibWF5YmVDb21wb25lbnQiLCJjcmVhdGVBU1RFbGVtZW50IiwibWFrZUF0dHJzTWFwIiwicGFyc2UiLCJ0ZW1wbGF0ZSIsInByZXNlcnZlV2hpdGVzcGFjZSIsIndoaXRlc3BhY2VPcHRpb24iLCJ3aGl0ZXNwYWNlIiwicm9vdCIsImN1cnJlbnRQYXJlbnQiLCJpblByZSIsIndhcm5lZCIsIndhcm5PbmNlIiwiY2xvc2VFbGVtZW50IiwiZWxlbWVudCIsInRyaW1FbmRpbmdXaGl0ZXNwYWNlIiwicHJvY2Vzc2VkIiwicHJvY2Vzc0VsZW1lbnQiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwiZm9yYmlkZGVuIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJsYXN0Tm9kZSIsImNoZWNrUm9vdENvbnN0cmFpbnRzIiwiY29tbWVudHMiLCJvdXRwdXRTb3VyY2VSYW5nZSIsInN0YXJ0JDEiLCJndWFyZElFU1ZHQnVnIiwiaXNGb3JiaWRkZW5UYWciLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc0ZvciIsInByb2Nlc3NJZiIsInByb2Nlc3NPbmNlIiwiZW5kJDEiLCJpc1RleHRUYWciLCJwcm9jZXNzS2V5IiwicHJvY2Vzc1JlZiIsInByb2Nlc3NTbG90Q29udGVudCIsInByb2Nlc3NTbG90T3V0bGV0IiwicHJvY2Vzc0NvbXBvbmVudCIsInByb2Nlc3NBdHRycyIsImNoZWNrSW5Gb3IiLCJwYXJzZUZvciIsImluTWF0Y2giLCJmb3IiLCJhbGlhcyIsIml0ZXJhdG9yTWF0Y2giLCJpdGVyYXRvcjEiLCJpdGVyYXRvcjIiLCJmaW5kUHJldkVsZW1lbnQiLCJjb25kaXRpb24iLCJpZkNvbmRpdGlvbnMiLCJzbG90VGFyZ2V0RHluYW1pYyIsInNsb3RCaW5kaW5nIiwiZ2V0U2xvdE5hbWUiLCJzbG90QmluZGluZyQxIiwiZHluYW1pYyQxIiwic2xvdENvbnRhaW5lciIsInNsb3ROYW1lIiwic3luY0dlbiIsImlzRHluYW1pYyIsImhhc0JpbmRpbmdzIiwicGFyc2VNb2RpZmllcnMiLCJjYW1lbCIsImFyZ01hdGNoIiwiaWVOU0J1ZyIsImllTlNQcmVmaXgiLCJjaGVja0ZvckFsaWFzTW9kZWwiLCJfZWwiLCJwcmVUcmFuc2Zvcm1Ob2RlIiwidHlwZUJpbmRpbmciLCJpZkNvbmRpdGlvbiIsImlmQ29uZGl0aW9uRXh0cmEiLCJoYXNFbHNlIiwiZWxzZUlmQ29uZGl0aW9uIiwiYnJhbmNoMCIsImNsb25lQVNURWxlbWVudCIsImJyYW5jaDEiLCJicmFuY2gyIiwibW9kZWwkMSIsIm1vZHVsZXMkMSIsImRpcmVjdGl2ZXMkMSIsImJhc2VPcHRpb25zIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJsJDEiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJmbkludm9rZVJFIiwic2ltcGxlUGF0aFJFIiwiZXNjIiwidGFiIiwic3BhY2UiLCJ1cCIsImRvd24iLCJrZXlOYW1lcyIsImdlbkd1YXJkIiwibW9kaWZpZXJDb2RlIiwic3RvcCIsInByZXZlbnQiLCJzZWxmIiwiY3RybCIsImFsdCIsIm1ldGEiLCJnZW5IYW5kbGVycyIsInByZWZpeCIsInN0YXRpY0hhbmRsZXJzIiwiZHluYW1pY0hhbmRsZXJzIiwiaGFuZGxlckNvZGUiLCJnZW5IYW5kbGVyIiwiaXNNZXRob2RQYXRoIiwiaXNGdW5jdGlvbkV4cHJlc3Npb24iLCJpc0Z1bmN0aW9uSW52b2NhdGlvbiIsImdlbk1vZGlmaWVyQ29kZSIsImtleU1vZGlmaWVyIiwiZ2VuS2V5RmlsdGVyIiwiZ2VuRmlsdGVyQ29kZSIsImtleVZhbCIsImtleUNvZGUiLCJrZXlOYW1lIiwid3JhcExpc3RlbmVycyIsImJpbmQkMSIsIndyYXBEYXRhIiwiYmFzZURpcmVjdGl2ZXMiLCJjbG9hayIsIkNvZGVnZW5TdGF0ZSIsImRhdGFHZW5GbnMiLCJvbmNlSWQiLCJnZW5lcmF0ZSIsImFzdCIsInN0YXRlIiwiZ2VuRWxlbWVudCIsInN0YXRpY1Byb2Nlc3NlZCIsImdlblN0YXRpYyIsIm9uY2VQcm9jZXNzZWQiLCJnZW5PbmNlIiwiZm9yUHJvY2Vzc2VkIiwiZ2VuRm9yIiwiaWZQcm9jZXNzZWQiLCJnZW5JZiIsImdlbkNoaWxkcmVuIiwiZ2VuU2xvdCIsImdlbkNvbXBvbmVudCIsImdlbkRhdGEkMiIsIm9yaWdpbmFsUHJlU3RhdGUiLCJhbHRHZW4iLCJhbHRFbXB0eSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwiYWx0SGVscGVyIiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImNvbnRhaW5zU2xvdENoaWxkIiwibmVlZHNLZXkiLCJnZW5lcmF0ZWRTbG90cyIsImdlblNjb3BlZFNsb3QiLCJpc0xlZ2FjeVN5bnRheCIsInJldmVyc2VQcm94eSIsImNoZWNrU2tpcCIsImFsdEdlbkVsZW1lbnQiLCJhbHRHZW5Ob2RlIiwiZWwkMSIsIm5vcm1hbGl6YXRpb25UeXBlJDEiLCJnZXROb3JtYWxpemF0aW9uVHlwZSIsImdlbk5vZGUiLCJuZWVkc05vcm1hbGl6YXRpb24iLCJnZW5Db21tZW50IiwiZ2VuVGV4dCIsInRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyIsImJpbmQkJDEiLCJjb21wb25lbnROYW1lIiwic3RhdGljUHJvcHMiLCJkeW5hbWljUHJvcHMiLCJwcm9oaWJpdGVkS2V5d29yZFJFIiwidW5hcnlPcGVyYXRvcnNSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0cmlwcGVkIiwia2V5d29yZE1hdGNoIiwiY2hlY2tJZGVudGlmaWVyIiwiaWRlbnQiLCJnZW5lcmF0ZUNvZGVGcmFtZSIsImxpbmVzIiwiY291bnQiLCJyZXBlYXQkMSIsImxpbmVMZW5ndGgiLCJwYWQiLCJsZW5ndGgkMSIsIm1pbiIsImNyZWF0ZUZ1bmN0aW9uIiwiZXJyb3JzIiwiY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiIsImNvbXBpbGUiLCJjb21waWxlVG9GdW5jdGlvbnMiLCJ3YXJuJCQxIiwiY29tcGlsZWQiLCJmbkdlbkVycm9ycyIsImNyZWF0ZUNvbXBpbGVyQ3JlYXRvciIsImJhc2VDb21waWxlIiwiY3JlYXRlQ29tcGlsZXIiLCJmaW5hbE9wdGlvbnMiLCJ0aXBzIiwiZGl2IiwiZ2V0U2hvdWxkRGVjb2RlIiwiaHJlZiIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiY29udGFpbmVyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUEsSUFBSUEsV0FBVyxHQUFHQyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLENBQWxCLEMsQ0FFQTtBQUNBOztBQUNBLFNBQVNDLE9BQVQsQ0FBa0JDLENBQWxCLEVBQXFCO0VBQ25CLE9BQU9BLENBQUMsS0FBS0MsU0FBTixJQUFtQkQsQ0FBQyxLQUFLLElBQWhDO0FBQ0Q7O0FBRUQsU0FBU0UsS0FBVCxDQUFnQkYsQ0FBaEIsRUFBbUI7RUFDakIsT0FBT0EsQ0FBQyxLQUFLQyxTQUFOLElBQW1CRCxDQUFDLEtBQUssSUFBaEM7QUFDRDs7QUFFRCxTQUFTRyxNQUFULENBQWlCSCxDQUFqQixFQUFvQjtFQUNsQixPQUFPQSxDQUFDLEtBQUssSUFBYjtBQUNEOztBQUVELFNBQVNJLE9BQVQsQ0FBa0JKLENBQWxCLEVBQXFCO0VBQ25CLE9BQU9BLENBQUMsS0FBSyxLQUFiO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7OztBQUNBLFNBQVNLLFdBQVQsQ0FBc0JDLEtBQXRCLEVBQTZCO0VBQzNCLE9BQ0UsT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUNBLE9BQU9BLEtB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Q285QixTQUFWO0VBQ0QsQ0FGRCxNQUVPO0lBQ0wsSUFBSUMsU0FBUyxHQUFHN3ZDLFFBQVEsQ0FBQzhKLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7SUFDQStsQyxTQUFTLENBQUMxd0IsV0FBVixDQUFzQjNNLEVBQUUsQ0FBQzhuQixTQUFILENBQWEsSUFBYixDQUF0QjtJQUNBLE9BQU91VixTQUFTLENBQUN2ckIsU0FBakI7RUFDRDtBQUNGOztBQUVEbFcsR0FBRyxDQUFDdWdDLE9BQUosR0FBY0Msa0JBQWQ7QUFFZXhnQyw0REFBZixFIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuNi4xMVxuICogKGMpIDIwMTQtMjAxOSBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIFRoZXNlIGhlbHBlcnMgcHJvZHVjZSBiZXR0ZXIgVk0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZy5cbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSwgZS5nLiwgW29iamVjdCBPYmplY3RdLlxuICovXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiAoXG4gICAgaXNEZWYodmFsKSAmJlxuICAgIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWwuY2F0Y2ggPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IEFycmF5LmlzQXJyYXkodmFsKSB8fCAoaXNQbGFpbk9iamVjdCh2YWwpICYmIHZhbC50b1N0cmluZyA9PT0gX3RvU3RyaW5nKVxuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LFxuICogZS5nLiwgUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHksIHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlXG4gKiBzaW5jZSBuYXRpdmUgYmluZCBpcyBub3cgcGVyZm9ybWFudCBlbm91Z2ggaW4gbW9zdCBicm93c2Vycy5cbiAqIEJ1dCByZW1vdmluZyBpdCB3b3VsZCBtZWFuIGJyZWFraW5nIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW5cbiAqIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBwb2x5ZmlsbEJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICByZXR1cm4gZm4uYmluZChjdHgpXG59XG5cbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgPyBuYXRpdmVCaW5kXG4gIDogcG9seWZpbGxCaW5kO1xuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKS5cbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmcgc3RhdGljIGtleXMgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBsb29zZWx5IGVxdWFsIHZhbHVlIGNhbiBiZVxuICogZm91bmQgaW4gdGhlIGFycmF5IChpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgdGhlIGFycmF5IG11c3RcbiAqIGNvbnRhaW4gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHNoYXBlKSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gKi9cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJyxcbiAgJ2Vycm9yQ2FwdHVyZWQnLFxuICAnc2VydmVyUHJlZmV0Y2gnXG5dO1xuXG4vKiAgKi9cblxuXG5cbnZhciBjb25maWcgPSAoe1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdXBkYXRlcyBhc3luY2hyb25vdXNseS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBieSBWdWUgVGVzdCBVdGlsc1xuICAgKiBUaGlzIHdpbGwgc2lnbmlmaWNhbnRseSByZWR1Y2UgcGVyZm9ybWFuY2UgaWYgc2V0IHRvIGZhbHNlLlxuICAgKi9cbiAgYXN5bmM6IHRydWUsXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG4vKipcbiAqIHVuaWNvZGUgbGV0dGVycyB1c2VkIGZvciBwYXJzaW5nIGh0bWwgdGFncywgY29tcG9uZW50IG5hbWVzIGFuZCBwcm9wZXJ0eSBwYXRocy5cbiAqIHVzaW5nIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc2VtYW50aWNzLXNjcmlwdGluZy5odG1sI3BvdGVudGlhbGN1c3RvbWVsZW1lbnRuYW1lXG4gKiBza2lwcGluZyBcXHUxMDAwMC1cXHVFRkZGRiBkdWUgdG8gaXQgZnJlZXppbmcgdXAgUGhhbnRvbUpTXG4gKi9cbnZhciB1bmljb2RlUmVnRXhwID0gL2EtekEtWlxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDNGLVxcdTIwNDBcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkQvO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IG5ldyBSZWdFeHAoKFwiW15cIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIi4kX1xcXFxkXVwiKSk7XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBpbldlZXggPSB0eXBlb2YgV1hFbnZpcm9ubWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgISFXWEVudmlyb25tZW50LnBsYXRmb3JtO1xudmFyIHdlZXhQbGF0Zm9ybSA9IGluV2VleCAmJiBXWEVudmlyb25tZW50LnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSAoVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMCkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbnZhciBpc0lPUyA9IChVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpKSB8fCAod2VleFBsYXRmb3JtID09PSAnaW9zJyk7XG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcbnZhciBpc1BoYW50b21KUyA9IFVBICYmIC9waGFudG9tanMvLnRlc3QoVUEpO1xudmFyIGlzRkYgPSBVQSAmJiBVQS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pO1xuXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgIWluV2VleCAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXSAmJiBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLmNpZCAhPSBudWxsXG4gICAgICA/IHZtLm9wdGlvbnNcbiAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9uc1xuICAgICAgICA6IHZtO1xuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgICB2YXIgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgdmFyIHRyZWUgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7IHJldHVybiAoXCJcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XG4gICAgLy8gc3VicyBhcmVuJ3Qgc29ydGVkIGluIHNjaGVkdWxlciBpZiBub3QgcnVubmluZyBhc3luY1xuICAgIC8vIHdlIG5lZWQgdG8gc29ydCB0aGVtIG5vdyB0byBtYWtlIHN1cmUgdGhleSBmaXJlIGluIGNvcnJlY3RcbiAgICAvLyBvcmRlclxuICAgIHN1YnMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyBUaGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyBUaGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIG9ubHkgb25lIHdhdGNoZXJcbi8vIGNhbiBiZSBldmFsdWF0ZWQgYXQgYSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAodGFyZ2V0KSB7XG4gIHRhcmdldFN0YWNrLnB1c2godGFyZ2V0KTtcbiAgRGVwLnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgdGFyZ2V0U3RhY2sucG9wKCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFja1t0YXJnZXRTdGFjay5sZW5ndGggLSAxXTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zLFxuICBhc3luY0ZhY3Rvcnlcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICAvLyAjNzk3NVxuICAgIC8vIGNsb25lIGNoaWxkcmVuIGFycmF5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGluIGNhc2Ugb2YgY2xvbmluZ1xuICAgIC8vIGEgY2hpbGQuXG4gICAgdm5vZGUuY2hpbGRyZW4gJiYgdm5vZGUuY2hpbGRyZW4uc2xpY2UoKSxcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmFzeW5jTWV0YSA9IHZub2RlLmFzeW5jTWV0YTtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1xuXG52YXIgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dO1xuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAqL1xudmFyIHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgIHByb3RvQXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29weUF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIHNob3VsZE9ic2VydmUgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG4gIGlmICgoIWdldHRlciB8fCBzZXR0ZXIpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YWwgPSBvYmpba2V5XTtcbiAgfVxuXG4gIHZhciBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgLy8gIzc5ODE6IGZvciBhY2Nlc3NvciBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVyXG4gICAgICBpZiAoZ2V0dGVyICYmICFzZXR0ZXIpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBzZXQgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuXG4gIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgPyBSZWZsZWN0Lm93bktleXMoZnJvbSlcbiAgICA6IE9iamVjdC5rZXlzKGZyb20pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgLy8gaW4gY2FzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgb2JzZXJ2ZWQuLi5cbiAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdG9WYWwgIT09IGZyb21WYWwgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QodG9WYWwpICYmXG4gICAgICBpc1BsYWluT2JqZWN0KGZyb21WYWwpXG4gICAgKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICB2YXIgcmVzID0gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsO1xuICByZXR1cm4gcmVzXG4gICAgPyBkZWR1cGVIb29rcyhyZXMpXG4gICAgOiByZXNcbn1cblxuZnVuY3Rpb24gZGVkdXBlSG9va3MgKGhvb2tzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyZXMuaW5kZXhPZihob29rc1tpXSkgPT09IC0xKSB7XG4gICAgICByZXMucHVzaChob29rc1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgaWYgKGNoaWxkVmFsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICByZXR1cm4gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbkFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cbiAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgcGFyZW50VmFsID0gdW5kZWZpbmVkOyB9XG4gIGlmIChjaGlsZFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgY2hpbGRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSQxIGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXkkMV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5JDFdO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXkkMV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmluamVjdCA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICBpZiAoY2hpbGRWYWwgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBpZiAoY2hpbGRWYWwpIHsgZXh0ZW5kKHJldCwgY2hpbGRWYWwpOyB9XG4gIHJldHVybiByZXRcbn07XG5zdHJhdHMucHJvdmlkZSA9IG1lcmdlRGF0YU9yRm47XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZSAobmFtZSkge1xuICBpZiAoIW5ldyBSZWdFeHAoKFwiXlthLXpBLVpdW1xcXFwtXFxcXC4wLTlfXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCJdKiRcIikpLnRlc3QobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICdzaG91bGQgY29uZm9ybSB0byB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lIGluIGh0bWw1IHNwZWNpZmljYXRpb24uJ1xuICAgICk7XG4gIH1cbiAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICdpZDogJyArIG5hbWVcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucywgdm0pIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInByb3BzXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gIGlmICghaW5qZWN0KSB7IHJldHVybiB9XG4gIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxuICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcImluamVjdFxcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShpbmplY3QpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiQkMSA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmJCQxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmJCQxLCB1cGRhdGU6IGRlZiQkMSB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlIChuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiOiBleHBlY3RlZCBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuXG4gIC8vIEFwcGx5IGV4dGVuZHMgYW5kIG1peGlucyBvbiB0aGUgY2hpbGQgb3B0aW9ucyxcbiAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxuICAvLyB0aGUgcmVzdWx0IG9mIGFub3RoZXIgbWVyZ2VPcHRpb25zIGNhbGwuXG4gIC8vIE9ubHkgbWVyZ2VkIG9wdGlvbnMgaGFzIHRoZSBfYmFzZSBwcm9wZXJ0eS5cbiAgaWYgKCFjaGlsZC5fYmFzZSkge1xuICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgfVxuICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gYm9vbGVhbiBjYXN0aW5nXG4gIHZhciBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgaWYgKGJvb2xlYW5JbmRleCA+IC0xKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XG4gICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcbiAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgdmFyIHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICB9XG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgLy8gc2tpcCB2YWxpZGF0aW9uIGZvciB3ZWV4IHJlY3ljbGUtbGlzdCBjaGlsZCBjb21wb25lbnQgcHJvcHNcbiAgICAhKGZhbHNlKVxuICApIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZSAobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgdmFyIG1lc3NhZ2UgPSBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSk7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICB2YXIgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgdmFyIGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxuICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gXCIgd2l0aCB2YWx1ZSBcIiArIGV4cGVjdGVkVmFsdWU7XG4gIH1cbiAgbWVzc2FnZSArPSBcIiwgZ290IFwiICsgcmVjZWl2ZWRUeXBlICsgXCIgXCI7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IFwid2l0aCB2YWx1ZSBcIiArIHJlY2VpdmVkVmFsdWUgKyBcIi5cIjtcbiAgfVxuICByZXR1cm4gbWVzc2FnZVxufVxuXG5mdW5jdGlvbiBzdHlsZVZhbHVlICh2YWx1ZSwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICByZXR1cm4gKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIilcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xuICAgIHJldHVybiAoXCJcIiArIChOdW1iZXIodmFsdWUpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUgKHZhbHVlKSB7XG4gIHZhciBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbiAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbTsgfSlcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuICgpIHtcbiAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICByZXR1cm4gYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJzsgfSlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIC8vIERlYWN0aXZhdGUgZGVwcyB0cmFja2luZyB3aGlsZSBwcm9jZXNzaW5nIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgcG9zc2libGUgaW5maW5pdGUgcmVuZGVyaW5nLlxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWV4L2lzc3Vlcy8xNTA1XG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICBpZiAodm0pIHtcbiAgICAgIHZhciBjdXIgPSB2bTtcbiAgICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICAgIHZhciBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyAoXG4gIGhhbmRsZXIsXG4gIGNvbnRleHQsXG4gIGFyZ3MsXG4gIHZtLFxuICBpbmZvXG4pIHtcbiAgdmFyIHJlcztcbiAgdHJ5IHtcbiAgICByZXMgPSBhcmdzID8gaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKSA6IGhhbmRsZXIuY2FsbChjb250ZXh0KTtcbiAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpICYmICFyZXMuX2hhbmRsZWQpIHtcbiAgICAgIHJlcy5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBcIiAoUHJvbWlzZS9hc3luYylcIik7IH0pO1xuICAgICAgLy8gaXNzdWUgIzk1MTFcbiAgICAgIC8vIGF2b2lkIGNhdGNoIHRyaWdnZXJpbmcgbXVsdGlwbGUgdGltZXMgd2hlbiBuZXN0ZWQgY2FsbHNcbiAgICAgIHJlcy5faGFuZGxlZCA9IHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgIGlmIChlICE9PSBlcnIpIHtcbiAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaXNVc2luZ01pY3JvVGFzayA9IGZhbHNlO1xuXG52YXIgY2FsbGJhY2tzID0gW107XG52YXIgcGVuZGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxuLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XG4vLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXG4vLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXG4vLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Ncbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxuLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG52YXIgdGltZXJGdW5jO1xuXG4vLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbi8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4vLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4vLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIEluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKCFpc0lFICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gIC8vIGUuZy4gUGhhbnRvbUpTLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAvLyAoIzY0NjYgTXV0YXRpb25PYnNlcnZlciBpcyB1bnJlbGlhYmxlIGluIElFMTEpXG4gIHZhciBjb3VudGVyID0gMTtcbiAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICB9KTtcbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICB9O1xuICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbn0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICAvLyBGYWxsYmFjayB0byBzZXRJbW1lZGlhdGUuXG4gIC8vIFRlY2huaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxuICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKCk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgLy8gcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpXG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXG4gICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIHdhcm5SZXNlcnZlZFByZWZpeCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBtdXN0IGJlIGFjY2Vzc2VkIHdpdGggXFxcIiRkYXRhLlwiICsga2V5ICsgXCJcXFwiIGJlY2F1c2UgXCIgK1xuICAgICAgJ3Byb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCBcIiRcIiBvciBcIl9cIiBhcmUgbm90IHByb3hpZWQgaW4gdGhlIFZ1ZSBpbnN0YW5jZSB0byAnICtcbiAgICAgICdwcmV2ZW50IGNvbmZsaWN0cyB3aXRoIFZ1ZSBpbnRlcm5hbHMuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvYXBpLyNkYXRhJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb3h5KTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fFxuICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5LmNoYXJBdCgwKSA9PT0gJ18nICYmICEoa2V5IGluIHRhcmdldC4kZGF0YSkpO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKSB7IHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8IE9iamVjdC5pc0Zyb3plbih2YWwpIHx8IHZhbCBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucywgdm0pIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNsb25lZFtpXSwgbnVsbCwgYXJndW1lbnRzJDEsIHZtLCBcInYtb24gaGFuZGxlclwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhmbnMsIG51bGwsIGFyZ3VtZW50cywgdm0sIFwidi1vbiBoYW5kbGVyXCIpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICBjcmVhdGVPbmNlSGFuZGxlcixcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgZGVmJCQxLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGRlZiQkMSA9IGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgaGFzT3duKHNvdXJjZS5fcHJvdmlkZWQsIHByb3ZpZGVLZXkpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuICB2YXIgc2xvdHMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgIH1cbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXG4gIGZvciAodmFyIG5hbWUkMSBpbiBzbG90cykge1xuICAgIGlmIChzbG90c1tuYW1lJDFdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgIGRlbGV0ZSBzbG90c1tuYW1lJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgbm9ybWFsU2xvdHMsXG4gIHByZXZTbG90c1xuKSB7XG4gIHZhciByZXM7XG4gIHZhciBoYXNOb3JtYWxTbG90cyA9IE9iamVjdC5rZXlzKG5vcm1hbFNsb3RzKS5sZW5ndGggPiAwO1xuICB2YXIgaXNTdGFibGUgPSBzbG90cyA/ICEhc2xvdHMuJHN0YWJsZSA6ICFoYXNOb3JtYWxTbG90cztcbiAgdmFyIGtleSA9IHNsb3RzICYmIHNsb3RzLiRrZXk7XG4gIGlmICghc2xvdHMpIHtcbiAgICByZXMgPSB7fTtcbiAgfSBlbHNlIGlmIChzbG90cy5fbm9ybWFsaXplZCkge1xuICAgIC8vIGZhc3QgcGF0aCAxOiBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVyIG9ubHksIHBhcmVudCBkaWQgbm90IGNoYW5nZVxuICAgIHJldHVybiBzbG90cy5fbm9ybWFsaXplZFxuICB9IGVsc2UgaWYgKFxuICAgIGlzU3RhYmxlICYmXG4gICAgcHJldlNsb3RzICYmXG4gICAgcHJldlNsb3RzICE9PSBlbXB0eU9iamVjdCAmJlxuICAgIGtleSA9PT0gcHJldlNsb3RzLiRrZXkgJiZcbiAgICAhaGFzTm9ybWFsU2xvdHMgJiZcbiAgICAhcHJldlNsb3RzLiRoYXNOb3JtYWxcbiAgKSB7XG4gICAgLy8gZmFzdCBwYXRoIDI6IHN0YWJsZSBzY29wZWQgc2xvdHMgdy8gbm8gbm9ybWFsIHNsb3RzIHRvIHByb3h5LFxuICAgIC8vIG9ubHkgbmVlZCB0byBub3JtYWxpemUgb25jZVxuICAgIHJldHVybiBwcmV2U2xvdHNcbiAgfSBlbHNlIHtcbiAgICByZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkkMSBpbiBzbG90cykge1xuICAgICAgaWYgKHNsb3RzW2tleSQxXSAmJiBrZXkkMVswXSAhPT0gJyQnKSB7XG4gICAgICAgIHJlc1trZXkkMV0gPSBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXkkMSwgc2xvdHNba2V5JDFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZXhwb3NlIG5vcm1hbCBzbG90cyBvbiBzY29wZWRTbG90c1xuICBmb3IgKHZhciBrZXkkMiBpbiBub3JtYWxTbG90cykge1xuICAgIGlmICghKGtleSQyIGluIHJlcykpIHtcbiAgICAgIHJlc1trZXkkMl0gPSBwcm94eU5vcm1hbFNsb3Qobm9ybWFsU2xvdHMsIGtleSQyKTtcbiAgICB9XG4gIH1cbiAgLy8gYXZvcmlheiBzZWVtcyB0byBtb2NrIGEgbm9uLWV4dGVuc2libGUgJHNjb3BlZFNsb3RzIG9iamVjdFxuICAvLyBhbmQgd2hlbiB0aGF0IGlzIHBhc3NlZCBkb3duIHRoaXMgd291bGQgY2F1c2UgYW4gZXJyb3JcbiAgaWYgKHNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2xvdHMpKSB7XG4gICAgKHNsb3RzKS5fbm9ybWFsaXplZCA9IHJlcztcbiAgfVxuICBkZWYocmVzLCAnJHN0YWJsZScsIGlzU3RhYmxlKTtcbiAgZGVmKHJlcywgJyRrZXknLCBrZXkpO1xuICBkZWYocmVzLCAnJGhhc05vcm1hbCcsIGhhc05vcm1hbFNsb3RzKTtcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXksIGZuKSB7XG4gIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID8gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSA6IGZuKHt9KTtcbiAgICByZXMgPSByZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVzKVxuICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcbiAgICAgIDogbm9ybWFsaXplQ2hpbGRyZW4ocmVzKTtcbiAgICByZXR1cm4gcmVzICYmIChcbiAgICAgIHJlcy5sZW5ndGggPT09IDAgfHxcbiAgICAgIChyZXMubGVuZ3RoID09PSAxICYmIHJlc1swXS5pc0NvbW1lbnQpIC8vICM5NjU4XG4gICAgKSA/IHVuZGVmaW5lZFxuICAgICAgOiByZXNcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgaWYgKGZuLnByb3h5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFxufVxuXG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2xvdHNba2V5XTsgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzRGVmKHJldCkpIHtcbiAgICByZXQgPSBbXTtcbiAgfVxuICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIG5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV0gfHwgZmFsbGJhY2s7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIGlmICghKGNhbWVsaXplZEtleSBpbiBoYXNoKSAmJiAhKGh5cGhlbmF0ZWRLZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uWyhcInVwZGF0ZTpcIiArIGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiB0cmVlXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxuICAgIG51bGwsXG4gICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICApO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlcyxcbiAgLy8gdGhlIGZvbGxvd2luZyBhcmUgYWRkZWQgaW4gMi42XG4gIGhhc0R5bmFtaWNLZXlzLFxuICBjb250ZW50SGFzaEtleVxuKSB7XG4gIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzbG90ID0gZm5zW2ldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNsb3QpKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoc2xvdCwgcmVzLCBoYXNEeW5hbWljS2V5cyk7XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICAvLyBtYXJrZXIgZm9yIHJldmVyc2UgcHJveHlpbmcgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICAgIGlmIChzbG90LnByb3h5KSB7XG4gICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmVzW3Nsb3Qua2V5XSA9IHNsb3QuZm47XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50SGFzaEtleSkge1xuICAgIChyZXMpLiRrZXkgPSBjb250ZW50SGFzaEtleTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMgKGJhc2VPYmosIHZhbHVlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBrZXkgPSB2YWx1ZXNbaV07XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleSkge1xuICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYga2V5ICE9PSAnJyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIC8vIG51bGwgaXMgYSBzcGVjaWFsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xuICAgICAgd2FybihcbiAgICAgICAgKFwiSW52YWxpZCB2YWx1ZSBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgKGV4cGVjdGVkIHN0cmluZyBvciBudWxsKTogXCIgKyBrZXkpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmFzZU9ialxufVxuXG4vLyBoZWxwZXIgdG8gZHluYW1pY2FsbHkgYXBwZW5kIG1vZGlmaWVyIHJ1bnRpbWUgbWFya2VycyB0byBldmVudCBuYW1lcy5cbi8vIGVuc3VyZSBvbmx5IGFwcGVuZCB3aGVuIHZhbHVlIGlzIGFscmVhZHkgc3RyaW5nLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjYXN0XG4vLyB0byBzdHJpbmcgYW5kIGNhdXNlIHRoZSB0eXBlIGNoZWNrIHRvIG1pc3MuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXIgKHZhbHVlLCBzeW1ib2wpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBzeW1ib2wgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XG4gIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICB0YXJnZXQuX24gPSB0b051bWJlcjtcbiAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XG4gIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XG4gIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XG4gIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xuICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xuICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xuICB0YXJnZXQuX2QgPSBiaW5kRHluYW1pY0tleXM7XG4gIHRhcmdldC5fcCA9IHByZXBlbmRNb2RpZmllcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgZGF0YSxcbiAgcHJvcHMsXG4gIGNoaWxkcmVuLFxuICBwYXJlbnQsXG4gIEN0b3Jcbikge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBjb250ZXh0Vm07XG4gIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XG4gICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgLy8gcmVhbCBjb250ZXh0IGluc3RhbmNlLlxuICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xuICB9XG4gIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzJDEuJHNsb3RzKSB7XG4gICAgICBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdGhpcyQxLiRzbG90cyA9IHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMkMS4kc2xvdHNcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Njb3BlZFNsb3RzJywgKHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLnNsb3RzKCkpXG4gICAgfVxuICB9KSk7XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuJHNsb3RzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICAgICAgaWYgKHZub2RlICYmICFBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG5cbiAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zLCByZW5kZXJDb250ZXh0KSB7XG4gIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAoY2xvbmUuZGV2dG9vbHNNZXRhID0gY2xvbmUuZGV2dG9vbHNNZXRhIHx8IHt9KS5yZW5kZXJDb250ZXh0ID0gcmVuZGVyQ29udGV4dDtcbiAgfVxuICBpZiAoZGF0YS5zbG90KSB7XG4gICAgKGNsb25lLmRhdGEgfHwgKGNsb25lLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIGlmIChcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgdmFyIGFzeW5jRmFjdG9yeTtcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IpO1xuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgZGF0YSA9IHt9O1xuICAgIGlmIChzbG90KSB7XG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50IC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIHBhcmVudDogcGFyZW50XG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZXhpc3RpbmcgPSBob29rc1trZXldO1xuICAgIHZhciB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGlmIChleGlzdGluZyAhPT0gdG9NZXJnZSAmJiAhKGV4aXN0aW5nICYmIGV4aXN0aW5nLl9tZXJnZWQpKSB7XG4gICAgICBob29rc1trZXldID0gZXhpc3RpbmcgPyBtZXJnZUhvb2skMSh0b01lcmdlLCBleGlzdGluZykgOiB0b01lcmdlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAoZjEsIGYyKSB7XG4gIHZhciBtZXJnZWQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIGZsb3cgY29tcGxhaW5zIGFib3V0IGV4dHJhIGFyZ3Mgd2hpY2ggaXMgd2h5IHdlIHVzZSBhbnlcbiAgICBmMShhLCBiKTtcbiAgICBmMihhLCBiKTtcbiAgfTtcbiAgbWVyZ2VkLl9tZXJnZWQgPSB0cnVlO1xuICByZXR1cm4gbWVyZ2VkXG59XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCdcbiAgOyhkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIHZhciBleGlzdGluZyA9IG9uW2V2ZW50XTtcbiAgdmFyIGNhbGxiYWNrID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xuICAgIGlmIChcbiAgICAgIEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpXG4gICAgICAgID8gZXhpc3RpbmcuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xXG4gICAgICAgIDogZXhpc3RpbmcgIT09IGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEubmF0aXZlT24pKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiVGhlIC5uYXRpdmUgbW9kaWZpZXIgZm9yIHYtb24gaXMgb25seSB2YWxpZCBvbiBjb21wb25lbnRzIGJ1dCBpdCB3YXMgdXNlZCBvbiA8XCIgKyB0YWcgKyBcIj4uXCIpLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoKCFkYXRhIHx8ICFkYXRhLnByZSkgJiYgaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgIGlmIChpc0RlZihucykpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7IHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXG4gICAgICAgIGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyByZWYgIzUzMThcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4vLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MgKGRhdGEpIHtcbiAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5zdHlsZSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG52YXIgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xuICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcblxuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICBpZiAoX3BhcmVudFZub2RlKSB7XG4gICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHZtLiRzbG90cyxcbiAgICAgICAgdm0uJHNjb3BlZFNsb3RzXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBtYWludGFpbiBhIHN0YWNrIGJlY2F1c2UgYWxsIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIG9uZSBhbm90aGVyLiBOZXN0ZWQgY29tcG9uZW50J3MgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyB3aGVuIHBhcmVudCBjb21wb25lbnQgaXMgcGF0Y2hlZC5cbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHZtO1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpICYmIHZub2RlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICBpZiAoXG4gICAgY29tcC5fX2VzTW9kdWxlIHx8XG4gICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICApIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvclxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgdmFyIG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAob3duZXIgJiYgaXNEZWYoZmFjdG9yeS5vd25lcnMpICYmIGZhY3Rvcnkub3duZXJzLmluZGV4T2Yob3duZXIpID09PSAtMSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3Rvcnkub3duZXJzLnB1c2gob3duZXIpO1xuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChvd25lciAmJiAhaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgdmFyIG93bmVycyA9IGZhY3Rvcnkub3duZXJzID0gW293bmVyXTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG4gICAgdmFyIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgdmFyIHRpbWVyVGltZW91dCA9IG51bGxcblxuICAgIDsob3duZXIpLiRvbignaG9vazpkZXN0cm95ZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1vdmUob3duZXJzLCBvd25lcik7IH0pO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIChvd25lcnNbaV0pLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAodGltZXJMb2FkaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyTG9hZGluZyk7XG4gICAgICAgICAgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyVGltZW91dCk7XG4gICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICB0aW1lclRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChldmVudCwgZm4pIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQ7XG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgX3RhcmdldC4kb2ZmKGV2ZW50LCBvbmNlSGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIGNyZWF0ZU9uY2VIYW5kbGVyLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkkMSA8IGw7IGkkMSsrKSB7XG4gICAgICAgIHZtLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKCFmbikge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICB2YXIgaW5mbyA9IFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYnNbaV0sIHZtLCBhcmdzLCB2bSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gc2V0QWN0aXZlSW5zdGFuY2Uodm0pIHtcbiAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2Uodm0pO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCB7XG4gICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUgKCkge1xuICAgICAgaWYgKHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbi5cblxuICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgZHluYW1pYyBzY29wZWRTbG90cyAoaGFuZC13cml0dGVuIG9yIGNvbXBpbGVkIGJ1dCB3aXRoXG4gIC8vIGR5bmFtaWMgc2xvdCBuYW1lcykuIFN0YXRpYyBzY29wZWQgc2xvdHMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBoYXMgdGhlXG4gIC8vIFwiJHN0YWJsZVwiIG1hcmtlci5cbiAgdmFyIG5ld1Njb3BlZFNsb3RzID0gcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cztcbiAgdmFyIG9sZFNjb3BlZFNsb3RzID0gdm0uJHNjb3BlZFNsb3RzO1xuICB2YXIgaGFzRHluYW1pY1Njb3BlZFNsb3QgPSAhIShcbiAgICAobmV3U2NvcGVkU2xvdHMgJiYgIW5ld1Njb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgKG9sZFNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJiAhb2xkU2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAobmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkgIT09IG5ld1Njb3BlZFNsb3RzLiRrZXkpXG4gICk7XG5cbiAgLy8gQW55IHN0YXRpYyBzbG90IGNoaWxkcmVuIGZyb20gdGhlIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyBwYXJlbnQnc1xuICAvLyB1cGRhdGUuIER5bmFtaWMgc2NvcGVkIHNsb3RzIG1heSBhbHNvIGhhdmUgY2hhbmdlZC4gSW4gc3VjaCBjYXNlcywgYSBmb3JjZWRcbiAgLy8gdXBkYXRlIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdG5lc3MuXG4gIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBoYXNEeW5hbWljU2NvcGVkU2xvdFxuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICB2YXIgaW5mbyA9IGhvb2sgKyBcIiBob29rXCI7XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIG51bGwsIHZtLCBpbmZvKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG59XG5cbi8qICAqL1xuXG52YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxudmFyIHF1ZXVlID0gW107XG52YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbi8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG52YXIgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cbnZhciBnZXROb3cgPSBEYXRlLm5vdztcblxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcbi8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXG4vLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cbi8vIEFsbCBJRSB2ZXJzaW9ucyB1c2UgbG93LXJlcyBldmVudCB0aW1lc3RhbXBzLCBhbmQgaGF2ZSBwcm9ibGVtYXRpYyBjbG9ja1xuLy8gaW1wbGVtZW50YXRpb25zICgjOTYzMilcbmlmIChpbkJyb3dzZXIgJiYgIWlzSUUpIHtcbiAgdmFyIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlO1xuICBpZiAoXG4gICAgcGVyZm9ybWFuY2UgJiZcbiAgICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nICYmXG4gICAgZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXBcbiAgKSB7XG4gICAgLy8gaWYgdGhlIGV2ZW50IHRpbWVzdGFtcCwgYWx0aG91Z2ggZXZhbHVhdGVkIEFGVEVSIHRoZSBEYXRlLm5vdygpLCBpc1xuICAgIC8vIHNtYWxsZXIgdGhhbiBpdCwgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lciB0aW1lc3RhbXBzIGFzXG4gICAgLy8gd2VsbC5cbiAgICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcbiAgfVxufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgIH1cbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25maWcuYXN5bmMpIHtcbiAgICAgICAgZmx1c2hTY2hlZHVsZXJRdWV1ZSgpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9ucyxcbiAgaXNSZW5kZXJXYXRjaGVyXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICB9XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gICAgdGhpcy5iZWZvcmUgPSBvcHRpb25zLmJlZm9yZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IG5vb3A7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBpZiAoIWlzUm9vdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gIH1cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxuICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGh5cGhlbmF0ZWRLZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jvb3QgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9IGZpbmFsbHkge1xuICAgIHBvcFRhcmdldCgpO1xuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gIHZhciBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNTU1IpIHtcbiAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIoXG4gICAgICAgIHZtLFxuICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgbm9vcCxcbiAgICAgICAgY29tcHV0ZWRXYXRjaGVyT3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXG4gIHRhcmdldCxcbiAga2V5LFxuICB1c2VyRGVmXG4pIHtcbiAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZik7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZi5nZXQpXG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0IHx8IG5vb3A7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHRoaXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgdHlwZSBcXFwiXCIgKyAodHlwZW9mIG1ldGhvZHNba2V5XSkgKyBcIlxcXCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIiArXG4gICAgICAgICAgXCJBdm9pZCBkZWZpbmluZyBjb21wb25lbnQgbWV0aG9kcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtW2tleV0gPSB0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBoYW5kbGVyLFxuICBvcHRpb25zXG4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnJvciwgdm0sIChcImNhbGxiYWNrIGZvciBpbW1lZGlhdGUgd2F0Y2hlciBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciB1aWQkMyA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDMrKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcblxuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcblxuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBsYXRlc3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUpO1xuc3RhdGVNaXhpbihWdWUpO1xuZXZlbnRzTWl4aW4oVnVlKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG5yZW5kZXJNaXhpbihWdWUpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzLmNhY2hlLCBrZXksIHRoaXMua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIC8vIDIuNiBleHBsaWNpdCBvYnNlcnZhYmxlIEFQSVxuICBWdWUub2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBvYnNlcnZlKG9iaik7XG4gICAgcmV0dXJuIG9ialxuICB9O1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnRnVuY3Rpb25hbFJlbmRlckNvbnRleHQnLCB7XG4gIHZhbHVlOiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFxufSk7XG5cblZ1ZS52ZXJzaW9uID0gJzIuNi4xMSc7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUgPSBtYWtlTWFwKCdldmVudHMsY2FyZXQsdHlwaW5nLHBsYWludGV4dC1vbmx5Jyk7XG5cbnZhciBjb252ZXJ0RW51bWVyYXRlZFZhbHVlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnXG4gICAgPyAnZmFsc2UnXG4gICAgLy8gYWxsb3cgYXJiaXRyYXJ5IHN0cmluZyB2YWx1ZSBmb3IgY29udGVudGVkaXRhYmxlXG4gICAgOiBrZXkgPT09ICdjb250ZW50ZWRpdGFibGUnICYmIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSh2YWx1ZSlcbiAgICAgID8gdmFsdWVcbiAgICAgIDogJ3RydWUnXG59O1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlU2NvcGUgKG5vZGUsIHNjb3BlSWQpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoc2NvcGVJZCwgJycpO1xufVxuXG52YXIgbm9kZU9wcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICBjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG4gIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgdGFnTmFtZTogdGFnTmFtZSxcbiAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuICBzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICghaXNEZWYoa2V5KSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWluVlByZSAmJlxuICAgICAgIXZub2RlLm5zICYmXG4gICAgICAhKFxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYkJDEpID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIiArIGtleSArIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAoXG4gICAgb2xkVm5vZGUsXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXgsXG4gICAgcmVtb3ZlT25seVxuICApIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gY2xvbmUgcmV1c2VkIHZub2RlXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtKSkge1xuICAgICAgICAgIHJlbW92ZVZub2Rlcyhbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBkaXIub2xkQXJnID0gb2xkRGlyLmFyZztcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZywgcmFuZ2UpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgdmFyIGF0dHJzID0gZHluYW1pY1xuICAgID8gKGVsLmR5bmFtaWNBdHRycyB8fCAoZWwuZHluYW1pY0F0dHJzID0gW10pKVxuICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gIGF0dHJzLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSwgcmFuZ2UpKTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIGlzRHluYW1pY0FyZyxcbiAgbW9kaWZpZXJzLFxuICByYW5nZVxuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7XG4gICAgbmFtZTogbmFtZSxcbiAgICByYXdOYW1lOiByYXdOYW1lLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBhcmc6IGFyZyxcbiAgICBpc0R5bmFtaWNBcmc6IGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnM6IG1vZGlmaWVyc1xuICB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXJNYXJrZXIgKHN5bWJvbCwgbmFtZSwgZHluYW1pYykge1xuICByZXR1cm4gZHluYW1pY1xuICAgID8gKFwiX3AoXCIgKyBuYW1lICsgXCIsXFxcIlwiICsgc3ltYm9sICsgXCJcXFwiKVwiKVxuICAgIDogc3ltYm9sICsgbmFtZSAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FybixcbiAgcmFuZ2UsXG4gIGR5bmFtaWNcbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG5cbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICBpZiAobW9kaWZpZXJzLnJpZ2h0KSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydjb250ZXh0bWVudSc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIik9PT0nY2xpY2snPydtb3VzZXVwJzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBuYW1lID0gJ21vdXNldXAnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyEnLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignficsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignJicsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG5cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuXG4gIHZhciBuZXdIYW5kbGVyID0gcmFuZ2VTZXRJdGVtKHsgdmFsdWU6IHZhbHVlLnRyaW0oKSwgZHluYW1pYzogZHluYW1pYyB9LCByYW5nZSk7XG4gIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XG4gICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gIH1cblxuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cblxuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRSYXdCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgcmV0dXJuIGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFtuYW1lXVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICByZW1vdmVGcm9tTWFwXG4pIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWxcbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXggKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBsaXN0W2ldO1xuICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gYXR0clxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByYW5nZVNldEl0ZW0gKFxuICBpdGVtLFxuICByYW5nZVxuKSB7XG4gIGlmIChyYW5nZSkge1xuICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IEpTT04uc3RyaW5naWZ5KHZhbHVlKSxcbiAgICBjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG4gIH07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcbiAgdmFsdWUsXG4gIGFzc2lnbm1lbnRcbikge1xuICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChyZXMuZXhwKSArIFwiLCBcIiArIChyZXMua2V5KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxudmFyIGxlbiwgc3RyLCBjaHIsIGluZGV4JDEsIGV4cHJlc3Npb25Qb3MsIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXG4gIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICB2YWwgPSB2YWwudHJpbSgpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4JDEgPiAtMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXG4gICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCQxICsgMSkgKyAnXCInXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLFxuICAgICAgICBrZXk6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHIgPSB2YWw7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRlbC5jaGVja2VkKXskJGk8MCYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLmNvbmNhdChbJCR2XSknKSkgKyBcIil9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcIil9XCIgK1xuICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXG4gIC8vIGV4Y2VwdCBmb3IgaW5wdXRzIHdpdGggdi1iaW5kOnR5cGVcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgdmFsdWUkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHZhbHVlJDEgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGJpbmRpbmcgKyBcIj1cXFwiXCIgKyB2YWx1ZSQxICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBcIiArXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5JyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbYmluZGluZ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIkMSAoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbi8vICM5NDQ2OiBGaXJlZm94IDw9IDUzIChpbiBwYXJ0aWN1bGFyLCBFU1IgNTIpIGhhcyBpbmNvcnJlY3QgRXZlbnQudGltZVN0YW1wXG4vLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4vLyBzYWZlIHRvIGV4Y2x1ZGUuXG52YXIgdXNlTWljcm90YXNrRml4ID0gaXNVc2luZ01pY3JvVGFzayAmJiAhKGlzRkYgJiYgTnVtYmVyKGlzRkZbMV0pIDw9IDUzKTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBuYW1lLFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xuICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cbiAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXG4gIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cbiAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xuICAgIHZhciBhdHRhY2hlZFRpbWVzdGFtcCA9IGN1cnJlbnRGbHVzaFRpbWVzdGFtcDtcbiAgICB2YXIgb3JpZ2luYWwgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vIGJ1YmJsaW5nLCBzaG91bGQgYWx3YXlzIGZpcmUuXG4gICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAvLyBjZXJ0YWluIHdlaXJkIGVudmlyb25tZW50cy4uLlxuICAgICAgICBlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0IHx8XG4gICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICBlLnRpbWVTdGFtcCA+PSBhdHRhY2hlZFRpbWVzdGFtcCB8fFxuICAgICAgICAvLyBiYWlsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBoYXZlIGJ1Z2d5IGV2ZW50LnRpbWVTdGFtcCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgLy8gIzk0NjIgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICAvLyAjOTY4MSBRdFdlYkVuZ2luZSBldmVudC50aW1lU3RhbXAgaXMgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgZS50aW1lU3RhbXAgPD0gMCB8fFxuICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXG4gICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgLy8gc3RhcnRpbmcgcmVmZXJlbmNlXG4gICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIGNyZWF0ZU9uY2VIYW5kbGVyJDEsIHZub2RlLmNvbnRleHQpO1xuICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxudmFyIHN2Z0NvbnRhaW5lcjtcblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cblxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmIGVsbS50YWdOYW1lICE9PSAnUFJPR1JFU1MnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgJiYgaXNTVkcoZWxtLnRhZ05hbWUpICYmIGlzVW5kZWYoZWxtLmlubmVySFRNTCkpIHtcbiAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xuICAgICAgc3ZnQ29udGFpbmVyID0gc3ZnQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IFwiPHN2Zz5cIiArIGN1ciArIFwiPC9zdmc+XCI7XG4gICAgICB2YXIgc3ZnID0gc3ZnQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoZWxtLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzdmcuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoc3ZnLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cbiAgICAgIC8vIGB2YWx1ZWAgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGJlY2F1c2UgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcbiAgICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXG4gICAgICAvLyBUaGlzICAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc2FycnkgYGNoZWNrZWRgIHVwZGF0ZS5cbiAgICAgIGN1ciAhPT0gb2xkUHJvcHNba2V5XVxuICAgICkge1xuICAgICAgLy8gc29tZSBwcm9wZXJ0eSB1cGRhdGVzIGNhbiB0aHJvd1xuICAgICAgLy8gZS5nLiBgdmFsdWVgIG9uIDxwcm9ncmVzcz4gdy8gbm9uLWZpbml0ZSB2YWx1ZVxuICAgICAgdHJ5IHtcbiAgICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKFxuICAgICAgICBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEgJiZcbiAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICApIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShuYW1lKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG52YXIgd2hpdGVzcGFjZVJFID0gL1xccysvO1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyIG51bWJlcnNcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd24gKGkuZS4gYWN0aW5nXG4vLyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIGlzTm90VGV4dE5vZGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9O1xuXG52YXIgaXNWU2hvd0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfTtcblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihpc05vdFRleHROb2RlKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShpc1ZTaG93RGlyZWN0aXZlKSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2UodGhpcyQxKTtcbiAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgIHRoaXMkMS5fX3BhdGNoX18oXG4gICAgICAgIHRoaXMkMS5fdm5vZGUsXG4gICAgICAgIHRoaXMkMS5rZXB0LFxuICAgICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICAgKTtcbiAgICAgIHRoaXMkMS5fdm5vZGUgPSB0aGlzJDEua2VwdDtcbiAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgICAgdXBkYXRlLmNhbGwodGhpcyQxLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaW5Ccm93c2VyKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0J1xuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgKTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgcmF3VG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKHJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnY2xhc3MnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJyxcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsnc3R5bGUnXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbnZhciBkeW5hbWljQXJnQXR0cmlidXRlID0gL15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XStcXF1bXlxcc1wiJzw+XFwvPV0qKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xudmFyIG5jbmFtZSA9IFwiW2EtekEtWl9dW1xcXFwtXFxcXC4wLTlfYS16QS1aXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCJdKlwiO1xudmFyIHFuYW1lQ2FwdHVyZSA9IFwiKCg/OlwiICsgbmNuYW1lICsgXCJcXFxcOik/XCIgKyBuY25hbWUgKyBcIilcIjtcbnZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKChcIl48XCIgKyBxbmFtZUNhcHR1cmUpKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgoXCJePFxcXFwvXCIgKyBxbmFtZUNhcHR1cmUgKyBcIltePl0qPlwiKSk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xuLy8gIzcyOTg6IGVzY2FwZSAtIHRvIGF2b2lkIGJlaW5nIHBhc3NlZCBhcyBIVE1MIGNvbW1lbnQgd2hlbiBpbmxpbmVkIGluIHBhZ2VcbnZhciBjb21tZW50ID0gL148IVxcLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJyxcbiAgJyYjOTsnOiAnXFx0JyxcbiAgJyYjMzk7JzogXCInXCJcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOSk7L2c7XG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOXwjMTB8IzkpOy9nO1xuXG4vLyAjNTk5MlxudmFyIGlzSWdub3JlTmV3bGluZVRhZyA9IG1ha2VNYXAoJ3ByZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHNob3VsZElnbm9yZUZpcnN0TmV3bGluZSA9IGZ1bmN0aW9uICh0YWcsIGh0bWwpIHsgcmV0dXJuIHRhZyAmJiBpc0lnbm9yZU5ld2xpbmVUYWcodGFnKSAmJiBodG1sWzBdID09PSAnXFxuJzsgfTtcblxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gIHZhciByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gZGVjb2RpbmdNYXBbbWF0Y2hdOyB9KVxufVxuXG5mdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICB2YXIgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgdmFyIGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xuXG4gICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGNvbW1lbnRFbmQpLCBpbmRleCwgaW5kZXggKyBjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XG4gICAgICAgICAgICBhZHZhbmNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdC5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEVuZCA8IDApIHtcbiAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGFkdmFuY2UodGV4dC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCwgaW5kZXggLSB0ZXh0Lmxlbmd0aCwgaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJykgLy8gIzcyOThcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdCQxLmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0JDE7XG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XG4gICAgICBvcHRpb25zLmNoYXJzICYmIG9wdGlvbnMuY2hhcnMoaHRtbCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpLCB7IHN0YXJ0OiBpbmRleCArIGh0bWwubGVuZ3RoIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goZHluYW1pY0FyZ0F0dHJpYnV0ZSkgfHwgaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICBhdHRyLnN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICBhdHRyLmVuZCA9IGluZGV4O1xuICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgIGlmIChleHBlY3RIVE1MKSB7XG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmFyeSA9IGlzVW5hcnlUYWckJDEodGFnTmFtZSkgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSB0YWdOYW1lID09PSAnYScgJiYgYXJnc1sxXSA9PT0gJ2hyZWYnXG4gICAgICAgID8gb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWZcbiAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgIH07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gYXJncy5zdGFydCArIGFyZ3NbMF0ubWF0Y2goL15cXHMqLykubGVuZ3RoO1xuICAgICAgICBhdHRyc1tpXS5lbmQgPSBhcmdzLmVuZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycywgc3RhcnQ6IG1hdGNoLnN0YXJ0LCBlbmQ6IG1hdGNoLmVuZCB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7IGVuZCA9IGluZGV4OyB9XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxuICAgICAgICAgIG9wdGlvbnMud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpLFxuICAgICAgICAgICAgeyBzdGFydDogc3RhY2tbaV0uc3RhcnQsIGVuZDogc3RhY2tbaV0uZW5kIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBvblJFID0gL15AfF52LW9uOi87XG52YXIgZGlyUkUgPSAvXnYtfF5AfF46fF4jLztcbnZhciBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvO1xudmFyIGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG52YXIgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcbnZhciBkeW5hbWljQXJnUkUgPSAvXlxcWy4qXFxdJC87XG5cbnZhciBhcmdSRSA9IC86KC4qKSQvO1xudmFyIGJpbmRSRSA9IC9eOnxeXFwufF52LWJpbmQ6LztcbnZhciBtb2RpZmllclJFID0gL1xcLlteLlxcXV0rKD89W15cXF1dKiQpL2c7XG5cbnZhciBzbG90UkUgPSAvXnYtc2xvdCg6fCQpfF4jLztcblxudmFyIGxpbmVCcmVha1JFID0gL1tcXHJcXG5dLztcbnZhciB3aGl0ZXNwYWNlUkUkMSA9IC9cXHMrL2c7XG5cbnZhciBpbnZhbGlkQXR0cmlidXRlUkUgPSAvW1xcc1wiJzw+XFwvPV0vO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xuXG52YXIgZW1wdHlTbG90U2NvcGVUb2tlbiA9IFwiX2VtcHR5X1wiO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDI7XG52YXIgZGVsaW1pdGVycztcbnZhciB0cmFuc2Zvcm1zO1xudmFyIHByZVRyYW5zZm9ybXM7XG52YXIgcG9zdFRyYW5zZm9ybXM7XG52YXIgcGxhdGZvcm1Jc1ByZVRhZztcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xudmFyIG1heWJlQ29tcG9uZW50O1xuXG5mdW5jdGlvbiBjcmVhdGVBU1RFbGVtZW50IChcbiAgdGFnLFxuICBhdHRycyxcbiAgcGFyZW50XG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxLFxuICAgIHRhZzogdGFnLFxuICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgcmF3QXR0cnNNYXA6IHt9LFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIGNoaWxkcmVuOiBbXVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgbWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICEhZWwuY29tcG9uZW50IHx8ICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7IH07XG5cbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuXG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG4gIHZhciB3aGl0ZXNwYWNlT3B0aW9uID0gb3B0aW9ucy53aGl0ZXNwYWNlO1xuICB2YXIgcm9vdDtcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgdmFyIGluUHJlID0gZmFsc2U7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnLCByYW5nZSkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgd2FybiQyKG1zZywgcmFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlRWxlbWVudCAoZWxlbWVudCkge1xuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuICAgIGlmICghaW5WUHJlICYmICFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgZWxlbWVudCA9IHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBlbGVtZW50ICE9PSByb290KSB7XG4gICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiLFxuICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbGVtZW50LnNsb3RTY29wZSkge1xuICAgICAgICAgIC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgLy8ga2VlcCBpdCBpbiB0aGUgY2hpbGRyZW4gbGlzdCBzbyB0aGF0IHYtZWxzZSgtaWYpIGNvbmRpdGlvbnMgY2FuXG4gICAgICAgICAgLy8gZmluZCBpdCBhcyB0aGUgcHJldiBub2RlLlxuICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIidcbiAgICAgICAgICA7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaW5hbCBjaGlsZHJlbiBjbGVhbnVwXG4gICAgLy8gZmlsdGVyIG91dCBzY29wZWQgc2xvdHNcbiAgICBlbGVtZW50LmNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuICEoYykuc2xvdFNjb3BlOyB9KTtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlIGFnYWluXG4gICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG5cbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvc3RUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaW1FbmRpbmdXaGl0ZXNwYWNlIChlbCkge1xuICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGVcbiAgICBpZiAoIWluUHJlKSB7XG4gICAgICB2YXIgbGFzdE5vZGU7XG4gICAgICB3aGlsZSAoXG4gICAgICAgIChsYXN0Tm9kZSA9IGVsLmNoaWxkcmVuW2VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdKSAmJlxuICAgICAgICBsYXN0Tm9kZS50eXBlID09PSAzICYmXG4gICAgICAgIGxhc3ROb2RlLnRleHQgPT09ICcgJ1xuICAgICAgKSB7XG4gICAgICAgIGVsLmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLicsXG4gICAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgb3V0cHV0U291cmNlUmFuZ2U6IG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSwgc3RhcnQkMSwgZW5kKSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGVsZW1lbnQuc3RhcnQgPSBzdGFydCQxO1xuICAgICAgICAgIGVsZW1lbnQuZW5kID0gZW5kO1xuICAgICAgICAgIGVsZW1lbnQucmF3QXR0cnNNYXAgPSBlbGVtZW50LmF0dHJzTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKGN1bXVsYXRlZCwgYXR0cikge1xuICAgICAgICAgICAgY3VtdWxhdGVkW2F0dHIubmFtZV0gPSBhdHRyO1xuICAgICAgICAgICAgcmV0dXJuIGN1bXVsYXRlZFxuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgaWYgKGludmFsaWRBdHRyaWJ1dGVSRS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGR5bmFtaWMgYXJndW1lbnQgZXhwcmVzc2lvbjogYXR0cmlidXRlIG5hbWVzIGNhbm5vdCBjb250YWluIFwiICtcbiAgICAgICAgICAgICAgXCJzcGFjZXMsIHF1b3RlcywgPCwgPiwgLyBvciA9LlwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUuaW5kZXhPZihcIltcIiksXG4gICAgICAgICAgICAgICAgZW5kOiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmxlbmd0aFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJyxcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICh0YWcsIHN0YXJ0LCBlbmQkMSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgIGVsZW1lbnQuZW5kID0gZW5kJDE7XG4gICAgICB9XG4gICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LicsXG4gICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YXJ0IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpLFxuICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgaWYgKGluUHJlIHx8IHRleHQudHJpbSgpKSB7XG4gICAgICAgIHRleHQgPSBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAvLyByZW1vdmUgdGhlIHdoaXRlc3BhY2Utb25seSBub2RlIHJpZ2h0IGFmdGVyIGFuIG9wZW5pbmcgdGFnXG4gICAgICAgIHRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAod2hpdGVzcGFjZU9wdGlvbikge1xuICAgICAgICBpZiAod2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xuICAgICAgICAgIC8vIGluIGNvbmRlbnNlIG1vZGUsIHJlbW92ZSB0aGUgd2hpdGVzcGFjZSBub2RlIGlmIGl0IGNvbnRhaW5zXG4gICAgICAgICAgLy8gbGluZSBicmVhaywgb3RoZXJ3aXNlIGNvbmRlbnNlIHRvIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgICAgdGV4dCA9IGxpbmVCcmVha1JFLnRlc3QodGV4dCkgPyAnJyA6ICcgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gJyAnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gcHJlc2VydmVXaGl0ZXNwYWNlID8gJyAnIDogJyc7XG4gICAgICB9XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBpZiAoIWluUHJlICYmIHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAvLyBjb25kZW5zZSBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlcyBpbnRvIHNpbmdsZSBzcGFjZVxuICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2Uod2hpdGVzcGFjZVJFJDEsICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKHJlcyA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiByZXMuZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRva2VuczogcmVzLnRva2VucyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIGNoaWxkID0ge1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAvLyBhZGRpbmcgYW55dGluZyBhcyBhIHNpYmxpbmcgdG8gdGhlIHJvb3Qgbm9kZSBpcyBmb3JiaWRkZW5cbiAgICAgIC8vIGNvbW1lbnRzIHNob3VsZCBzdGlsbCBiZSBhbGxvd2VkLCBidXQgaWdub3JlZFxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgdmFyIGNoaWxkID0ge1xuICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvb3Rcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcbiAgICBlbC5wcmUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSYXdBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgaWYgKGxlbikge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGxpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGxpc3RbaV0udmFsdWUpXG4gICAgICB9O1xuICAgICAgaWYgKGxpc3RbaV0uc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGxpc3RbaV0uc3RhcnQ7XG4gICAgICAgIGF0dHJzW2ldLmVuZCA9IGxpc3RbaV0uZW5kO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgIGVsLnBsYWluID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRWxlbWVudCAoXG4gIGVsZW1lbnQsXG4gIG9wdGlvbnNcbikge1xuICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICBlbGVtZW50LnBsYWluID0gKFxuICAgICFlbGVtZW50LmtleSAmJlxuICAgICFlbGVtZW50LnNjb3BlZFNsb3RzICYmXG4gICAgIWVsZW1lbnQuYXR0cnNMaXN0Lmxlbmd0aFxuICApO1xuXG4gIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90Q29udGVudChlbGVtZW50KTtcbiAgcHJvY2Vzc1Nsb3RPdXRsZXQoZWxlbWVudCk7XG4gIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgIGVsZW1lbnQgPSB0cmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gIH1cbiAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xuICByZXR1cm4gZWxlbWVudFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xuICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgaWYgKGV4cCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIixcbiAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZWwuZm9yKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGVsLml0ZXJhdG9yMiB8fCBlbC5pdGVyYXRvcjE7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgICAgIGlmIChpdGVyYXRvciAmJiBpdGVyYXRvciA9PT0gZXhwICYmIHBhcmVudCAmJiBwYXJlbnQudGFnID09PSAndHJhbnNpdGlvbi1ncm91cCcpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBcIkRvIG5vdCB1c2Ugdi1mb3IgaW5kZXggYXMga2V5IG9uIDx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiwgXCIgK1xuICAgICAgICAgICAgXCJ0aGlzIGlzIHRoZSBzYW1lIGFzIG5vdCB1c2luZyBrZXlzLlwiLFxuICAgICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKSxcbiAgICAgICAgICAgIHRydWUgLyogdGlwICovXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGV4dGVuZChlbCwgcmVzKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cCksXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5cblxuZnVuY3Rpb24gcGFyc2VGb3IgKGV4cCkge1xuICB2YXIgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgaWYgKCFpbk1hdGNoKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgcmVzLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKTtcbiAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcy5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKS50cmltKCk7XG4gICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICByZXMuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgaWYgKGVsc2VpZikge1xuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDIoXG4gICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiLFxuICAgICAgZWwucmF3QXR0cnNNYXBbZWwuZWxzZWlmID8gJ3YtZWxzZS1pZicgOiAndi1lbHNlJ11cbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCIsXG4gICAgICAgICAgY2hpbGRyZW5baV1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbi8vIGhhbmRsZSBjb250ZW50IGJlaW5nIHBhc3NlZCB0byBhIGNvbXBvbmVudCBhcyBzbG90LFxuLy8gZS5nLiA8dGVtcGxhdGUgc2xvdD1cInh4eFwiPiwgPGRpdiBzbG90LXNjb3BlPVwieHh4XCI+XG5mdW5jdGlvbiBwcm9jZXNzU2xvdENvbnRlbnQgKGVsKSB7XG4gIHZhciBzbG90U2NvcGU7XG4gIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICBzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzbG90U2NvcGUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJ0aGUgXFxcInNjb3BlXFxcIiBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBzbG90cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgXCIgK1xuICAgICAgICBcInJlcGxhY2VkIGJ5IFxcXCJzbG90LXNjb3BlXFxcIiBzaW5jZSAyLjUuIFRoZSBuZXcgXFxcInNsb3Qtc2NvcGVcXFwiIGF0dHJpYnV0ZSBcIiArXG4gICAgICAgIFwiY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIFwiICtcbiAgICAgICAgXCJkZW5vdGUgc2NvcGVkIHNsb3RzLlwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnc2NvcGUnXSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlIHx8IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJyk7XG4gIH0gZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwuYXR0cnNNYXBbJ3YtZm9yJ10pIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJBbWJpZ3VvdXMgY29tYmluZWQgdXNhZ2Ugb2Ygc2xvdC1zY29wZSBhbmQgdi1mb3Igb24gPFwiICsgKGVsLnRhZykgKyBcIj4gXCIgK1xuICAgICAgICBcIih2LWZvciB0YWtlcyBoaWdoZXIgcHJpb3JpdHkpLiBVc2UgYSB3cmFwcGVyIDx0ZW1wbGF0ZT4gZm9yIHRoZSBcIiArXG4gICAgICAgIFwic2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLlwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnc2xvdC1zY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGU7XG4gIH1cblxuICAvLyBzbG90PVwieHh4XCJcbiAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSAhIShlbC5hdHRyc01hcFsnOnNsb3QnXSB8fCBlbC5hdHRyc01hcFsndi1iaW5kOnNsb3QnXSk7XG4gICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHMuXG4gICAgaWYgKGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAnc2xvdCcpKTtcbiAgICB9XG4gIH1cblxuICAvLyAyLjYgdi1zbG90IHN5bnRheFxuICB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgLy8gdi1zbG90IG9uIDx0ZW1wbGF0ZT5cbiAgICAgIHZhciBzbG90QmluZGluZyA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgaWYgKHNsb3RCaW5kaW5nKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGVsLnNsb3RUYXJnZXQgfHwgZWwuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cIixcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5wYXJlbnQgJiYgIW1heWJlQ29tcG9uZW50KGVsLnBhcmVudCkpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCI8dGVtcGxhdGUgdi1zbG90PiBjYW4gb25seSBhcHBlYXIgYXQgdGhlIHJvb3QgbGV2ZWwgaW5zaWRlIFwiICtcbiAgICAgICAgICAgICAgXCJ0aGUgcmVjZWl2aW5nIGNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZiA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nKTtcbiAgICAgICAgdmFyIG5hbWUgPSByZWYubmFtZTtcbiAgICAgICAgdmFyIGR5bmFtaWMgPSByZWYuZHluYW1pYztcbiAgICAgICAgZWwuc2xvdFRhcmdldCA9IG5hbWU7XG4gICAgICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYztcbiAgICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmcudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjsgLy8gZm9yY2UgaXQgaW50byBhIHNjb3BlZCBzbG90IGZvciBwZXJmXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHYtc2xvdCBvbiBjb21wb25lbnQsIGRlbm90ZXMgZGVmYXVsdCBzbG90XG4gICAgICB2YXIgc2xvdEJpbmRpbmckMSA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgaWYgKHNsb3RCaW5kaW5nJDEpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIW1heWJlQ29tcG9uZW50KGVsKSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcInYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPi5cIixcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmckMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNsb3RTY29wZSB8fCBlbC5zbG90VGFyZ2V0KSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cIixcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIlRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eSwgdGhlIGRlZmF1bHQgc2xvdCBzaG91bGQgYWxzbyB1c2UgXCIgK1xuICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZT4gc3ludGF4IHdoZW4gdGhlcmUgYXJlIG90aGVyIG5hbWVkIHNsb3RzLlwiLFxuICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCdzIGNoaWxkcmVuIHRvIGl0cyBkZWZhdWx0IHNsb3RcbiAgICAgICAgdmFyIHNsb3RzID0gZWwuc2NvcGVkU2xvdHMgfHwgKGVsLnNjb3BlZFNsb3RzID0ge30pO1xuICAgICAgICB2YXIgcmVmJDEgPSBnZXRTbG90TmFtZShzbG90QmluZGluZyQxKTtcbiAgICAgICAgdmFyIG5hbWUkMSA9IHJlZiQxLm5hbWU7XG4gICAgICAgIHZhciBkeW5hbWljJDEgPSByZWYkMS5keW5hbWljO1xuICAgICAgICB2YXIgc2xvdENvbnRhaW5lciA9IHNsb3RzW25hbWUkMV0gPSBjcmVhdGVBU1RFbGVtZW50KCd0ZW1wbGF0ZScsIFtdLCBlbCk7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldCA9IG5hbWUkMTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWMkMTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5jaGlsZHJlbiA9IGVsLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGlmICghYy5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIGMucGFyZW50ID0gc2xvdENvbnRhaW5lcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90U2NvcGUgPSBzbG90QmluZGluZyQxLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47XG4gICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlbiBhcyB0aGV5IGFyZSByZXR1cm5lZCBmcm9tIHNjb3BlZFNsb3RzIG5vd1xuICAgICAgICBlbC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAvLyBtYXJrIGVsIG5vbi1wbGFpbiBzbyBkYXRhIGdldHMgZ2VuZXJhdGVkXG4gICAgICAgIGVsLnBsYWluID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNsb3ROYW1lIChiaW5kaW5nKSB7XG4gIHZhciBuYW1lID0gYmluZGluZy5uYW1lLnJlcGxhY2Uoc2xvdFJFLCAnJyk7XG4gIGlmICghbmFtZSkge1xuICAgIGlmIChiaW5kaW5nLm5hbWVbMF0gIT09ICcjJykge1xuICAgICAgbmFtZSA9ICdkZWZhdWx0JztcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJ2LXNsb3Qgc2hvcnRoYW5kIHN5bnRheCByZXF1aXJlcyBhIHNsb3QgbmFtZS5cIixcbiAgICAgICAgYmluZGluZ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpXG4gICAgLy8gZHluYW1pYyBbbmFtZV1cbiAgICA/IHsgbmFtZTogbmFtZS5zbGljZSgxLCAtMSksIGR5bmFtaWM6IHRydWUgfVxuICAgIC8vIHN0YXRpYyBuYW1lXG4gICAgOiB7IG5hbWU6IChcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIiksIGR5bmFtaWM6IGZhbHNlIH1cbn1cblxuLy8gaGFuZGxlIDxzbG90Lz4gb3V0bGV0c1xuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPdXRsZXQgKGVsKSB7XG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiLFxuICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBzeW5jR2VuLCBpc0R5bmFtaWM7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZS5yZXBsYWNlKGRpclJFLCAnJykpO1xuICAgICAgLy8gc3VwcG9ydCAuZm9vIHNob3J0aGFuZCBzeW50YXggZm9yIHRoZSAucHJvcCBtb2RpZmllclxuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIHZhbHVlLnRyaW0oKS5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgKFwiVGhlIHZhbHVlIGZvciBhIHYtYmluZCBleHByZXNzaW9uIGNhbm5vdCBiZSBlbXB0eS4gRm91bmQgaW4gXFxcInYtYmluZDpcIiArIG5hbWUgKyBcIlxcXCJcIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3AgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBzeW5jR2VuID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFwiJGV2ZW50XCIpO1xuICAgICAgICAgICAgaWYgKCFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoY2FtZWxpemUobmFtZSkpKSxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGh5cGhlbmF0ZShuYW1lKSAhPT0gY2FtZWxpemUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoaHlwaGVuYXRlKG5hbWUpKSksXG4gICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGhhbmRsZXIgdy8gZHluYW1pYyBldmVudCBuYW1lXG4gICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgKFwiXFxcInVwZGF0ZTpcXFwiKyhcIiArIG5hbWUgKyBcIilcIiksXG4gICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICBsaXN0W2ldLFxuICAgICAgICAgICAgICAgIHRydWUgLy8gZHluYW1pY1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKG1vZGlmaWVycyAmJiBtb2RpZmllcnMucHJvcCkgfHwgKFxuICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgaXNEeW5hbWljID0gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSk7XG4gICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMiwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICAgIGlmIChkeW5hbWljQXJnUkUudGVzdChhcmcpKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgaXNEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBpc0R5bmFtaWMsIG1vZGlmaWVycywgbGlzdFtpXSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJyxcbiAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSksIGxpc3RbaV0pO1xuICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxuICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXG4gICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcbiAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnLCBsaXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lLCBhdHRyc1tpXSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICB2YXIgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcHJlVHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ2lucHV0Jykge1xuICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICBpZiAoIW1hcFsndi1tb2RlbCddKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgdHlwZUJpbmRpbmc7XG4gICAgaWYgKG1hcFsnOnR5cGUnXSB8fCBtYXBbJ3YtYmluZDp0eXBlJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgfVxuICAgIGlmICghbWFwLnR5cGUgJiYgIXR5cGVCaW5kaW5nICYmIG1hcFsndi1iaW5kJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gXCIoXCIgKyAobWFwWyd2LWJpbmQnXSkgKyBcIikudHlwZVwiO1xuICAgIH1cblxuICAgIGlmICh0eXBlQmluZGluZykge1xuICAgICAgdmFyIGlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnLCB0cnVlKTtcbiAgICAgIHZhciBpZkNvbmRpdGlvbkV4dHJhID0gaWZDb25kaXRpb24gPyAoXCImJihcIiArIGlmQ29uZGl0aW9uICsgXCIpXCIpIDogXCJcIjtcbiAgICAgIHZhciBoYXNFbHNlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScsIHRydWUpICE9IG51bGw7XG4gICAgICB2YXIgZWxzZUlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicsIHRydWUpO1xuICAgICAgLy8gMS4gY2hlY2tib3hcbiAgICAgIHZhciBicmFuY2gwID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIC8vIHByb2Nlc3MgZm9yIG9uIHRoZSBtYWluIG5vZGVcbiAgICAgIHByb2Nlc3NGb3IoYnJhbmNoMCk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDAsICd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gwLCBvcHRpb25zKTtcbiAgICAgIGJyYW5jaDAucHJvY2Vzc2VkID0gdHJ1ZTsgLy8gcHJldmVudCBpdCBmcm9tIGRvdWJsZS1wcm9jZXNzZWRcbiAgICAgIGJyYW5jaDAuaWYgPSBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J2NoZWNrYm94J1wiICsgaWZDb25kaXRpb25FeHRyYTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBicmFuY2gwLmlmLFxuICAgICAgICBibG9jazogYnJhbmNoMFxuICAgICAgfSk7XG4gICAgICAvLyAyLiBhZGQgcmFkaW8gZWxzZS1pZiBjb25kaXRpb25cbiAgICAgIHZhciBicmFuY2gxID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDEsICd0eXBlJywgJ3JhZGlvJyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gxLCBvcHRpb25zKTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J3JhZGlvJ1wiICsgaWZDb25kaXRpb25FeHRyYSxcbiAgICAgICAgYmxvY2s6IGJyYW5jaDFcbiAgICAgIH0pO1xuICAgICAgLy8gMy4gb3RoZXJcbiAgICAgIHZhciBicmFuY2gyID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDIsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxuICAgICAgICBibG9jazogYnJhbmNoMlxuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNFbHNlKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xuICAgICAgICBicmFuY2gwLmVsc2VpZiA9IGVsc2VJZkNvbmRpdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJyYW5jaDBcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xuICByZXR1cm4gY3JlYXRlQVNURWxlbWVudChlbC50YWcsIGVsLmF0dHJzTGlzdC5zbGljZSgpLCBlbC5wYXJlbnQpXG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBwcmVUcmFuc2Zvcm1Ob2RlOiBwcmVUcmFuc2Zvcm1Ob2RlXG59O1xuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxLFxuICBtb2RlbCQxXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIiksIGRpcik7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGJhc2VPcHRpb25zID0ge1xuICBleHBlY3RIVE1MOiB0cnVlLFxuICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNQcmVUYWc6IGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnOiBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWc6IGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbi8qICAqL1xuXG52YXIgaXNTdGF0aWNLZXk7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICByZXR1cm4gbWFrZU1hcChcbiAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycyxzdGFydCxlbmQscmF3QXR0cnNNYXAnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uKD86XFxzK1tcXHckXSspP1xccypcXCgvO1xudmFyIGZuSW52b2tlUkUgPSAvXFwoW14pXSo/XFwpOyokLztcbnZhciBzaW1wbGVQYXRoUkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJ1teJ10qPyddfFxcW1wiW15cIl0qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKiQvO1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwLFxuICAnZGVsZXRlJzogWzgsIDQ2XVxufTtcblxuLy8gS2V5Ym9hcmRFdmVudC5rZXkgYWxpYXNlc1xudmFyIGtleU5hbWVzID0ge1xuICAvLyAjNzg4MDogSUUxMSBhbmQgRWRnZSB1c2UgYEVzY2AgZm9yIEVzY2FwZSBrZXkgbmFtZS5cbiAgZXNjOiBbJ0VzYycsICdFc2NhcGUnXSxcbiAgdGFiOiAnVGFiJyxcbiAgZW50ZXI6ICdFbnRlcicsXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYFNwYWNlYmFyYCBmb3IgU3BhY2Uga2V5IG5hbWUuXG4gIHNwYWNlOiBbJyAnLCAnU3BhY2ViYXInXSxcbiAgLy8gIzc4MDY6IElFMTEgdXNlcyBrZXkgbmFtZXMgd2l0aG91dCBgQXJyb3dgIHByZWZpeCBmb3IgYXJyb3cga2V5cy5cbiAgdXA6IFsnVXAnLCAnQXJyb3dVcCddLFxuICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXG4gIHJpZ2h0OiBbJ1JpZ2h0JywgJ0Fycm93UmlnaHQnXSxcbiAgZG93bjogWydEb3duJywgJ0Fycm93RG93biddLFxuICAvLyAjOTExMjogSUUxMSB1c2VzIGBEZWxgIGZvciBEZWxldGUga2V5IG5hbWUuXG4gICdkZWxldGUnOiBbJ0JhY2tzcGFjZScsICdEZWxldGUnLCAnRGVsJ11cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChcbiAgZXZlbnRzLFxuICBpc05hdGl2ZVxuKSB7XG4gIHZhciBwcmVmaXggPSBpc05hdGl2ZSA/ICduYXRpdmVPbjonIDogJ29uOic7XG4gIHZhciBzdGF0aWNIYW5kbGVycyA9IFwiXCI7XG4gIHZhciBkeW5hbWljSGFuZGxlcnMgPSBcIlwiO1xuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgIHZhciBoYW5kbGVyQ29kZSA9IGdlbkhhbmRsZXIoZXZlbnRzW25hbWVdKTtcbiAgICBpZiAoZXZlbnRzW25hbWVdICYmIGV2ZW50c1tuYW1lXS5keW5hbWljKSB7XG4gICAgICBkeW5hbWljSGFuZGxlcnMgKz0gbmFtZSArIFwiLFwiICsgaGFuZGxlckNvZGUgKyBcIixcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGljSGFuZGxlcnMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgaGFuZGxlckNvZGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgc3RhdGljSGFuZGxlcnMgPSBcIntcIiArIChzdGF0aWNIYW5kbGVycy5zbGljZSgwLCAtMSkpICsgXCJ9XCI7XG4gIGlmIChkeW5hbWljSGFuZGxlcnMpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgXCJfZChcIiArIHN0YXRpY0hhbmRsZXJzICsgXCIsW1wiICsgKGR5bmFtaWNIYW5kbGVycy5zbGljZSgwLCAtMSkpICsgXCJdKVwiXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeCArIHN0YXRpY0hhbmRsZXJzXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoaGFuZGxlcikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIChcIltcIiArIChoYW5kbGVyLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZ2VuSGFuZGxlcihoYW5kbGVyKTsgfSkuam9pbignLCcpKSArIFwiXVwiKVxuICB9XG5cbiAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICB2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uSW52b2NhdGlvbiA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUucmVwbGFjZShmbkludm9rZVJFLCAnJykpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICBpZiAoaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci52YWx1ZVxuICAgIH1cbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChpc0Z1bmN0aW9uSW52b2NhdGlvbiA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSkgOiBoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvZGUgPSAnJztcbiAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdleGFjdCcpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IChoYW5kbGVyLm1vZGlmaWVycyk7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBnZW5HdWFyZChcbiAgICAgICAgICBbJ2N0cmwnLCAnc2hpZnQnLCAnYWx0JywgJ21ldGEnXVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuICFtb2RpZmllcnNba2V5TW9kaWZpZXJdOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuIChcIiRldmVudC5cIiArIGtleU1vZGlmaWVyICsgXCJLZXlcIik7IH0pXG4gICAgICAgICAgICAuam9pbignfHwnKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIigkZXZlbnQpXCIpXG4gICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgID8gKFwicmV0dXJuIChcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgIDogaXNGdW5jdGlvbkludm9jYXRpb25cbiAgICAgICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSlcbiAgICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBtYWtlIHN1cmUgdGhlIGtleSBmaWx0ZXJzIG9ubHkgYXBwbHkgdG8gS2V5Ym9hcmRFdmVudHNcbiAgICAvLyAjOTQ0MTogY2FuJ3QgdXNlICdrZXlDb2RlJyBpbiAkZXZlbnQgYmVjYXVzZSBDaHJvbWUgYXV0b2ZpbGwgZmlyZXMgZmFrZVxuICAgIC8vIGtleSBldmVudHMgdGhhdCBkbyBub3QgaGF2ZSBrZXlDb2RlIHByb3BlcnR5Li4uXG4gICAgXCJpZighJGV2ZW50LnR5cGUuaW5kZXhPZigna2V5JykmJlwiICtcbiAgICAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIlxuICApXG59XG5cbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICB2YXIga2V5VmFsID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIGlmIChrZXlWYWwpIHtcbiAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcbiAgfVxuICB2YXIga2V5Q29kZSA9IGtleUNvZGVzW2tleV07XG4gIHZhciBrZXlOYW1lID0ga2V5TmFtZXNba2V5XTtcbiAgcmV0dXJuIChcbiAgICBcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyBcIixcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGtleUNvZGUpKSArIFwiLFwiICtcbiAgICBcIiRldmVudC5rZXksXCIgK1xuICAgIFwiXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5TmFtZSkpICtcbiAgICBcIilcIlxuICApXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBvbiAoZWwsIGRpcikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkaXIubW9kaWZpZXJzKSB7XG4gICAgd2FybihcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XG4gIH1cbiAgZWwud3JhcExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJfZyhcIiArIGNvZGUgKyBcIixcIiArIChkaXIudmFsdWUpICsgXCIpXCIpOyB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIFwiLFwiICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJ3RydWUnIDogJ2ZhbHNlJykgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnN5bmMgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gIG9uOiBvbixcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cblxuXG5cblxudmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZSAob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLndhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgdGhpcy5kaXJlY3RpdmVzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZURpcmVjdGl2ZXMpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xuICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcbiAgdGhpcy5vbmNlSWQgPSAwO1xuICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xuICB0aGlzLnByZSA9IGZhbHNlO1xufTtcblxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgdmFyIGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCwgc3RhdGUpIDogJ19jKFwiZGl2XCIpJztcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsLCBzdGF0ZSkge1xuICBpZiAoZWwucGFyZW50KSB7XG4gICAgZWwucHJlID0gZWwucHJlIHx8IGVsLnBhcmVudC5wcmU7XG4gIH1cblxuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0ICYmICFzdGF0ZS5wcmUpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwsIHN0YXRlKVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgdmFyIGNvZGU7XG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhO1xuICAgICAgaWYgKCFlbC5wbGFpbiB8fCAoZWwucHJlICYmIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSkpIHtcbiAgICAgICAgZGF0YSA9IGdlbkRhdGEkMihlbCwgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS50cmFuc2Zvcm1zW2ldKGVsLCBjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxuZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgLy8gU29tZSBlbGVtZW50cyAodGVtcGxhdGVzKSBuZWVkIHRvIGJlaGF2ZSBkaWZmZXJlbnRseSBpbnNpZGUgb2YgYSB2LXByZVxuICAvLyBub2RlLiAgQWxsIHByZSBub2RlcyBhcmUgc3RhdGljIHJvb3RzLCBzbyB3ZSBjYW4gdXNlIHRoaXMgYXMgYSBsb2NhdGlvbiB0b1xuICAvLyB3cmFwIGEgc3RhdGUgY2hhbmdlIGFuZCByZXNldCBpdCB1cG9uIGV4aXRpbmcgdGhlIHByZSBub2RlLlxuICB2YXIgb3JpZ2luYWxQcmVTdGF0ZSA9IHN0YXRlLnByZTtcbiAgaWYgKGVsLnByZSkge1xuICAgIHN0YXRlLnByZSA9IGVsLnByZTtcbiAgfVxuICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCIpKTtcbiAgc3RhdGUucHJlID0gb3JpZ2luYWxQcmVTdGF0ZTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRlLnN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCwgc3RhdGUpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgdmFyIGtleSA9ICcnO1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAga2V5ID0gcGFyZW50LmtleTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICgha2V5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRlLndhcm4oXG4gICAgICAgIFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1vbmNlJ11cbiAgICAgICk7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCIsXCIgKyAoc3RhdGUub25jZUlkKyspICsgXCIsXCIgKyBrZXkgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxufVxuXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKFxuICBjb25kaXRpb25zLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBhbHRHZW5cbiAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcbiAgICAgIDogZWwub25jZVxuICAgICAgICA/IGdlbk9uY2UoZWwsIHN0YXRlKVxuICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRIZWxwZXJcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICFlbC5rZXlcbiAgKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXSxcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKChhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOlwiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIixcIjtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBcImRvbVByb3BzOlwiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIixcIjtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSkpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2xvdFRhcmdldCAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwsIGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGR5bmFtaWMgYXJndW1lbnQgd3JhcFxuICAvLyB2LWJpbmQgd2l0aCBkeW5hbWljIGFyZ3VtZW50cyBtdXN0IGJlIGFwcGxpZWQgdXNpbmcgdGhlIHNhbWUgdi1iaW5kIG9iamVjdFxuICAvLyBtZXJnZSBoZWxwZXIgc28gdGhhdCBjbGFzcy9zdHlsZS9tdXN0VXNlUHJvcCBhdHRycyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG4gIGlmIChlbC5keW5hbWljQXR0cnMpIHtcbiAgICBkYXRhID0gXCJfYihcIiArIGRhdGEgKyBcIixcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIiArIChnZW5Qcm9wcyhlbC5keW5hbWljQXR0cnMpKSArIFwiKVwiO1xuICB9XG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICB9XG4gIC8vIHYtb24gZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XG4gICAgZGF0YSA9IGVsLndyYXBMaXN0ZW5lcnMoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwsIHN0YXRlKSB7XG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIHZhciBnZW4gPSBzdGF0ZS5kaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCBzdGF0ZS53YXJuKTtcbiAgICB9XG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlwiICsgKGRpci5pc0R5bmFtaWNBcmcgPyBkaXIuYXJnIDogKFwiXFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpKSkgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoXG4gICAgZWwuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGFzdC50eXBlICE9PSAxXG4gICkpIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicsXG4gICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgKTtcbiAgfVxuICBpZiAoYXN0ICYmIGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXG4gIGVsLFxuICBzbG90cyxcbiAgc3RhdGVcbikge1xuICAvLyBieSBkZWZhdWx0IHNjb3BlZCBzbG90cyBhcmUgY29uc2lkZXJlZCBcInN0YWJsZVwiLCB0aGlzIGFsbG93cyBjaGlsZFxuICAvLyBjb21wb25lbnRzIHdpdGggb25seSBzY29wZWQgc2xvdHMgdG8gc2tpcCBmb3JjZWQgdXBkYXRlcyBmcm9tIHBhcmVudC5cbiAgLy8gYnV0IGluIHNvbWUgY2FzZXMgd2UgaGF2ZSB0byBiYWlsLW91dCBvZiB0aGlzIG9wdGltaXphdGlvblxuICAvLyBmb3IgZXhhbXBsZSBpZiB0aGUgc2xvdCBjb250YWlucyBkeW5hbWljIG5hbWVzLCBoYXMgdi1pZiBvciB2LWZvciBvbiB0aGVtLi4uXG4gIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gZWwuZm9yIHx8IE9iamVjdC5rZXlzKHNsb3RzKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgc2xvdCA9IHNsb3RzW2tleV07XG4gICAgcmV0dXJuIChcbiAgICAgIHNsb3Quc2xvdFRhcmdldER5bmFtaWMgfHxcbiAgICAgIHNsb3QuaWYgfHxcbiAgICAgIHNsb3QuZm9yIHx8XG4gICAgICBjb250YWluc1Nsb3RDaGlsZChzbG90KSAvLyBpcyBwYXNzaW5nIGRvd24gc2xvdCBmcm9tIHBhcmVudCB3aGljaCBtYXkgYmUgZHluYW1pY1xuICAgIClcbiAgfSk7XG5cbiAgLy8gIzk1MzQ6IGlmIGEgY29tcG9uZW50IHdpdGggc2NvcGVkIHNsb3RzIGlzIGluc2lkZSBhIGNvbmRpdGlvbmFsIGJyYW5jaCxcbiAgLy8gaXQncyBwb3NzaWJsZSBmb3IgdGhlIHNhbWUgY29tcG9uZW50IHRvIGJlIHJldXNlZCBidXQgd2l0aCBkaWZmZXJlbnRcbiAgLy8gY29tcGlsZWQgc2xvdCBjb250ZW50LiBUbyBhdm9pZCB0aGF0LCB3ZSBnZW5lcmF0ZSBhIHVuaXF1ZSBrZXkgYmFzZWQgb25cbiAgLy8gdGhlIGdlbmVyYXRlZCBjb2RlIG9mIGFsbCB0aGUgc2xvdCBjb250ZW50cy5cbiAgdmFyIG5lZWRzS2V5ID0gISFlbC5pZjtcblxuICAvLyBPUiB3aGVuIGl0IGlzIGluc2lkZSBhbm90aGVyIHNjb3BlZCBzbG90IG9yIHYtZm9yICh0aGUgcmVhY3Rpdml0eSBtYXkgYmVcbiAgLy8gZGlzY29ubmVjdGVkIGR1ZSB0byB0aGUgaW50ZXJtZWRpYXRlIHNjb3BlIHZhcmlhYmxlKVxuICAvLyAjOTQzOCwgIzk1MDZcbiAgLy8gVE9ETzogdGhpcyBjYW4gYmUgZnVydGhlciBvcHRpbWl6ZWQgYnkgcHJvcGVybHkgYW5hbHl6aW5nIGluLXNjb3BlIGJpbmRpbmdzXG4gIC8vIGFuZCBza2lwIGZvcmNlIHVwZGF0aW5nIG9uZXMgdGhhdCBkbyBub3QgYWN0dWFsbHkgdXNlIHNjb3BlIHZhcmlhYmxlcy5cbiAgaWYgKCFuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAoXG4gICAgICAgIChwYXJlbnQuc2xvdFNjb3BlICYmIHBhcmVudC5zbG90U2NvcGUgIT09IGVtcHR5U2xvdFNjb3BlVG9rZW4pIHx8XG4gICAgICAgIHBhcmVudC5mb3JcbiAgICAgICkge1xuICAgICAgICBuZWVkc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQuaWYpIHtcbiAgICAgICAgbmVlZHNLZXkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gIH1cblxuICB2YXIgZ2VuZXJhdGVkU2xvdHMgPSBPYmplY3Qua2V5cyhzbG90cylcbiAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGdlblNjb3BlZFNsb3Qoc2xvdHNba2V5XSwgc3RhdGUpOyB9KVxuICAgIC5qb2luKCcsJyk7XG5cbiAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIGdlbmVyYXRlZFNsb3RzICsgXCJdXCIgKyAobmVlZHNGb3JjZVVwZGF0ZSA/IFwiLG51bGwsdHJ1ZVwiIDogXCJcIikgKyAoIW5lZWRzRm9yY2VVcGRhdGUgJiYgbmVlZHNLZXkgPyAoXCIsbnVsbCxmYWxzZSxcIiArIChoYXNoKGdlbmVyYXRlZFNsb3RzKSkpIDogXCJcIikgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gaGFzaChzdHIpIHtcbiAgdmFyIGhhc2ggPSA1MzgxO1xuICB2YXIgaSA9IHN0ci5sZW5ndGg7XG4gIHdoaWxlKGkpIHtcbiAgICBoYXNoID0gKGhhc2ggKiAzMykgXiBzdHIuY2hhckNvZGVBdCgtLWkpO1xuICB9XG4gIHJldHVybiBoYXNoID4+PiAwXG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zU2xvdENoaWxkIChlbCkge1xuICBpZiAoZWwudHlwZSA9PT0gMSkge1xuICAgIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGVsLmNoaWxkcmVuLnNvbWUoY29udGFpbnNTbG90Q2hpbGQpXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgaXNMZWdhY3lTeW50YXggPSBlbC5hdHRyc01hcFsnc2xvdC1zY29wZSddO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkICYmICFpc0xlZ2FjeVN5bnRheCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QsIFwibnVsbFwiKVxuICB9XG4gIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90KVxuICB9XG4gIHZhciBzbG90U2NvcGUgPSBlbC5zbG90U2NvcGUgPT09IGVtcHR5U2xvdFNjb3BlVG9rZW5cbiAgICA/IFwiXCJcbiAgICA6IFN0cmluZyhlbC5zbG90U2NvcGUpO1xuICB2YXIgZm4gPSBcImZ1bmN0aW9uKFwiICsgc2xvdFNjb3BlICsgXCIpe1wiICtcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgID8gZWwuaWYgJiYgaXNMZWdhY3lTeW50YXhcbiAgICAgICAgPyAoXCIoXCIgKyAoZWwuaWYpICsgXCIpP1wiICsgKGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCcpICsgXCI6dW5kZWZpbmVkXCIpXG4gICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCI7XG4gIC8vIHJldmVyc2UgcHJveHkgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgdmFyIHJldmVyc2VQcm94eSA9IHNsb3RTY29wZSA/IFwiXCIgOiBcIixwcm94eTp0cnVlXCI7XG4gIHJldHVybiAoXCJ7a2V5OlwiICsgKGVsLnNsb3RUYXJnZXQgfHwgXCJcXFwiZGVmYXVsdFxcXCJcIikgKyBcIixmbjpcIiArIGZuICsgcmV2ZXJzZVByb3h5ICsgXCJ9XCIpXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChcbiAgZWwsXG4gIHN0YXRlLFxuICBjaGVja1NraXAsXG4gIGFsdEdlbkVsZW1lbnQsXG4gIGFsdEdlbk5vZGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgZWwkMS5mb3IgJiZcbiAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXG4gICAgKSB7XG4gICAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcbiAgICAgICAgPyBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCQxKSA/IFwiLDFcIiA6IFwiLDBcIlxuICAgICAgICA6IFwiXCI7XG4gICAgICByZXR1cm4gKFwiXCIgKyAoKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpKSArIG5vcm1hbGl6YXRpb25UeXBlKVxuICAgIH1cbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUkMSA9IGNoZWNrU2tpcFxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICA6IDA7XG4gICAgdmFyIGdlbiA9IGFsdEdlbk5vZGUgfHwgZ2VuTm9kZTtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZ2VuKGMsIHN0YXRlKTsgfSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlJDEgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSQxKSA6ICcnKSlcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxuICBjaGlsZHJlbixcbiAgbWF5YmVDb21wb25lbnRcbikge1xuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSwgc3RhdGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUsIHN0YXRlKVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcbiAgcmV0dXJuIChcIl9lKFwiICsgKEpTT04uc3RyaW5naWZ5KGNvbW1lbnQudGV4dCkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyB8fCBlbC5keW5hbWljQXR0cnNcbiAgICA/IGdlblByb3BzKChlbC5hdHRycyB8fCBbXSkuY29uY2F0KGVsLmR5bmFtaWNBdHRycyB8fCBbXSkubWFwKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiAoe1xuICAgICAgICAvLyBzbG90IHByb3BzIGFyZSBjYW1lbGl6ZWRcbiAgICAgICAgbmFtZTogY2FtZWxpemUoYXR0ci5uYW1lKSxcbiAgICAgICAgdmFsdWU6IGF0dHIudmFsdWUsXG4gICAgICAgIGR5bmFtaWM6IGF0dHIuZHluYW1pY1xuICAgICAgfSk7IH0pKVxuICAgIDogbnVsbDtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChcbiAgY29tcG9uZW50TmFtZSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEkMihlbCwgc3RhdGUpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgdmFyIHN0YXRpY1Byb3BzID0gXCJcIjtcbiAgdmFyIGR5bmFtaWNQcm9wcyA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICBkeW5hbWljUHJvcHMgKz0gKHByb3AubmFtZSkgKyBcIixcIiArIHZhbHVlICsgXCIsXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY1Byb3BzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBzdGF0aWNQcm9wcyA9IFwie1wiICsgKHN0YXRpY1Byb3BzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgaWYgKGR5bmFtaWNQcm9wcykge1xuICAgIHJldHVybiAoXCJfZChcIiArIHN0YXRpY1Byb3BzICsgXCIsW1wiICsgKGR5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXCJdKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0aWNQcm9wc1xuICB9XG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG5cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0LCB3YXJuKSB7XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCB3YXJuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIHdhcm4pIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gbm9kZS5yYXdBdHRyc01hcFtuYW1lXTtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2LXNsb3QnIHx8IG5hbWVbMF0gPT09ICcjJykge1xuICAgICAgICAgICAgY2hlY2tGdW5jdGlvblBhcmFtZXRlckV4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgd2Fybik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgd2Fybiwgbm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICB2YXIgc3RyaXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBzdHJpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdHJpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIHdhcm4oXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKFxuICBpZGVudCxcbiAgdHlwZSxcbiAgdGV4dCxcbiAgd2FybixcbiAgcmFuZ2Vcbikge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRnVuY3Rpb24oKFwidmFyIFwiICsgaWRlbnQgKyBcIj1fXCIpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSwgcmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIlxcbiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArIChlLm1lc3NhZ2UpICsgXCIgaW5cXG5cXG5cIiArXG4gICAgICAgIFwiICAgIFwiICsgZXhwICsgXCJcXG5cXG5cIiArXG4gICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIixcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uIChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKGV4cCwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgd2FybihcbiAgICAgIFwiaW52YWxpZCBmdW5jdGlvbiBwYXJhbWV0ZXIgZXhwcmVzc2lvbjogXCIgKyAoZS5tZXNzYWdlKSArIFwiIGluXFxuXFxuXCIgK1xuICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIixcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHJhbmdlID0gMjtcblxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUgKFxuICBzb3VyY2UsXG4gIHN0YXJ0LFxuICBlbmRcbikge1xuICBpZiAoIHN0YXJ0ID09PSB2b2lkIDAgKSBzdGFydCA9IDA7XG4gIGlmICggZW5kID09PSB2b2lkIDAgKSBlbmQgPSBzb3VyY2UubGVuZ3RoO1xuXG4gIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyP1xcbi8pO1xuICB2YXIgY291bnQgPSAwO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIHsgY29udGludWUgfVxuICAgICAgICByZXMucHVzaCgoXCJcIiArIChqICsgMSkgKyAocmVwZWF0JDEoXCIgXCIsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCkpICsgXCJ8ICBcIiArIChsaW5lc1tqXSkpKTtcbiAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgLy8gcHVzaCB1bmRlcmxpbmVcbiAgICAgICAgICB2YXIgcGFkID0gc3RhcnQgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQkMShcIiBcIiwgcGFkKSArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCQxID0gTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgcmVzLnB1c2goXCIgICB8ICBcIiArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgkMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKVxufVxuXG5mdW5jdGlvbiByZXBlYXQkMSAoc3RyLCBuKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKG4gPiAwKSB7XG4gICAgd2hpbGUgKHRydWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaWYgKG4gJiAxKSB7IHJlc3VsdCArPSBzdHI7IH1cbiAgICAgIG4gPj4+PSAxO1xuICAgICAgaWYgKG4gPD0gMCkgeyBicmVhayB9XG4gICAgICBzdHIgKz0gc3RyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICAgIHZhciB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgZGVsZXRlIG9wdGlvbnMud2FybjtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gY2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIChlLm1zZykgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgICAgZ2VuZXJhdGVDb2RlRnJhbWUodGVtcGxhdGUsIGUuc3RhcnQsIGUuZW5kKSxcbiAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRpcChlLm1zZywgdm0pOyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgdGlwcyA9IFtdO1xuXG4gICAgICB2YXIgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICB2YXIgbGVhZGluZ1NwYWNlTGVuZ3RoID0gdGVtcGxhdGUubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0geyBtc2c6IG1zZyB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5zdGFydCA9IHJhbmdlLnN0YXJ0ICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZW5kID0gcmFuZ2UuZW5kICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmaW5hbE9wdGlvbnMud2FybiA9IHdhcm47XG5cbiAgICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLnRyaW0oKSwgZmluYWxPcHRpb25zKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QsIHdhcm4pO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZSA9IHJlZiQxLmNvbXBpbGU7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbnZhciBkaXY7XG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUgKGhyZWYpIHtcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IFwiPGEgaHJlZj1cXFwiXFxuXFxcIi8+XCIgOiBcIjxkaXYgYT1cXFwiXFxuXFxcIi8+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwXG59XG5cbi8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBvdXRwdXRTb3VyY2VSYW5nZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZS5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBWdWU7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16\n")},function(module,exports){eval('var g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function("return this")();\n} catch (e) {\n  // This works if the window reference is available\n  if (typeof window === "object") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZSIsIndpbmRvdyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBLElBQUlBLENBQUosQyxDQUVBOztBQUNBQSxDQUFDLEdBQUksWUFBVztFQUNmLE9BQU8sSUFBUDtBQUNBLENBRkcsRUFBSjs7QUFJQSxJQUFJO0VBQ0g7RUFDQUEsQ0FBQyxHQUFHQSxDQUFDLElBQUksSUFBSUMsUUFBSixDQUFhLGFBQWIsR0FBVDtBQUNBLENBSEQsQ0FHRSxPQUFPQyxDQUFQLEVBQVU7RUFDWDtFQUNBLElBQUksT0FBT0MsTUFBUCxLQUFrQixRQUF0QixFQUFnQ0gsQ0FBQyxHQUFHRyxNQUFKO0FBQ2hDLEMsQ0FFRDtBQUNBO0FBQ0E7OztBQUVBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJMLENBQWpCIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n')},,,function(module,exports,__webpack_require__){eval('(function webpackUniversalModuleDefinition(root, factory) {\n  if (true) module.exports = factory();else {}\n})(typeof self !== \'undefined\' ? self : this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __webpack_require__.r = function (exports) {\n        /******/\n        if (typeof Symbol !== \'undefined\' && Symbol.toStringTag) {\n          /******/\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: \'Module\'\n          });\n          /******/\n        }\n        /******/\n\n\n        Object.defineProperty(exports, \'__esModule\', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // create a fake namespace object\n\n      /******/\n      // mode & 1: value is a module id, require it\n\n      /******/\n      // mode & 2: merge all properties of value into the ns\n\n      /******/\n      // mode & 4: return value when already ns object\n\n      /******/\n      // mode & 8|1: behave like require\n\n      /******/\n\n\n      __webpack_require__.t = function (value, mode) {\n        /******/\n        if (mode & 1) value = __webpack_require__(value);\n        /******/\n\n        if (mode & 8) return value;\n        /******/\n\n        if (mode & 4 && typeof value === \'object\' && value && value.__esModule) return value;\n        /******/\n\n        var ns = Object.create(null);\n        /******/\n\n        __webpack_require__.r(ns);\n        /******/\n\n\n        Object.defineProperty(ns, \'default\', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n\n        if (mode & 2 && typeof value != \'string\') for (var key in value) __webpack_require__.d(ns, key, function (key) {\n          return value[key];\n        }.bind(null, key));\n        /******/\n\n        return ns;\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module[\'default\'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, \'a\', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = "";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = "+xUi");\n      /******/\n    }\n    /************************************************************************/\n\n    /******/\n    ({\n      /***/\n      "+rLv":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var document = __webpack_require__("dyZX").document;\n\n        module.exports = document && document.documentElement;\n        /***/\n      },\n\n      /***/\n      "+xUi":\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        "use strict";\n\n        __webpack_require__.r(__webpack_exports__); // EXTERNAL MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js\n\n\n        var setPublicPath = __webpack_require__("HrLf"); // CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"/var/share/vue-dialog-drag/node_modules/.cache/vue-loader","cacheIdentifier":"847cbeee-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/pug-plain-loader!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/vue-dialog-drag.vue?vue&type=template&id=1c049c8d&lang=pug&\n\n\n        var render = function () {\n          var _vm = this;\n\n          var _h = _vm.$createElement;\n\n          var _c = _vm._self._c || _h;\n\n          return _c(\'div\', {\n            staticClass: "dialog-drag",\n            class: !_vm.drag ? "fixed" : "",\n            style: _vm.dialogStyle,\n            attrs: {\n              "id": _vm.id,\n              "draggable": _vm.drag\n            },\n            on: {\n              "mousedown": _vm.mouseDown,\n              "touchstart": function ($event) {\n                $event.preventDefault();\n                return _vm.touchStart($event);\n              },\n              "&touchmove": function ($event) {\n                return _vm.touchMove($event);\n              },\n              "touchend": function ($event) {\n                $event.stopPropagation();\n                return _vm.touchEnd($event);\n              }\n            }\n          }, [_c(\'div\', {\n            staticClass: "dialog-header",\n            on: {\n              "dragstart": function ($event) {\n                $event.stopPropagation();\n              }\n            }\n          }, [_c(\'div\', {\n            staticClass: "title"\n          }, [_vm._t("title", [_vm.title ? _c(\'span\', [_vm._v(_vm._s(_vm.title))]) : _c(\'span\', [_vm._v(" ")])])], 2), _c(\'div\', {\n            staticClass: "buttons"\n          }, [_vm.buttonPin ? _c(\'button\', {\n            staticClass: "pin",\n            on: {\n              "click": _vm.setDrag,\n              "touchstart": _vm.setDrag\n            }\n          }, [_vm.drag ? _vm._t("button-pin") : _vm._e(), !_vm.drag ? _vm._t("button-pinned", [!_vm.drag ? _vm._t("button-pin") : _vm._e()]) : _vm._e()], 2) : _vm._e(), _vm.buttonClose ? _c(\'button\', {\n            staticClass: "close",\n            on: {\n              "click": function ($event) {\n                $event.stopPropagation();\n                return _vm.close($event);\n              },\n              "&touchstart": function ($event) {\n                return _vm.close($event);\n              }\n            }\n          }, [_vm._t("button-close")], 2) : _vm._e()])]), _c(\'div\', {\n            staticClass: "dialog-body",\n            on: {\n              "dragstart": function ($event) {\n                $event.stopPropagation();\n              }\n            }\n          }, [_vm._t("default", [_c(\'div\', {\n            staticClass: "blank-body"\n          })])], 2)]);\n        };\n\n        var staticRenderFns = []; // CONCATENATED MODULE: ./src/components/vue-dialog-drag.vue?vue&type=template&id=1c049c8d&lang=pug&\n        // EXTERNAL MODULE: ./node_modules/core-js/modules/es7.symbol.async-iterator.js\n\n        var es7_symbol_async_iterator = __webpack_require__("rE2o"); // EXTERNAL MODULE: ./node_modules/core-js/modules/es6.symbol.js\n\n\n        var es6_symbol = __webpack_require__("ioFf"); // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js\n\n\n        var web_dom_iterable = __webpack_require__("rGqo"); // CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/components/vue-dialog-drag.vue?vue&type=script&lang=js&\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n        //\n\n        /* harmony default export */\n\n\n        var vue_dialog_dragvue_type_script_lang_js_ = {\n          name: \'dialog-drag\',\n          props: [\'id\', \'title\', \'options\', \'eventCb\'],\n          data: function data() {\n            return {\n              width: 0,\n              height: 0,\n              zIndex: 0,\n              offset: {\n                x: 0,\n                y: 0\n              },\n              left: 0,\n              top: 0,\n              buttonClose: true,\n              buttonPin: true,\n              dragEnabled: true,\n              drag: true,\n              touch: null,\n              overEvent: null,\n              centered: false,\n              dropEnabled: true,\n              dragCursor: \'default\',\n              dragging: false,\n              clickButton: false,\n              pX: 0,\n              pY: 0,\n              availableOptions: [\'left\', \'top\', \'width\', \'height\', \'buttonPin\', \'buttonClose\', \'centered\', \'dropEnabled\', \'dragCursor\', \'zIndex\']\n            };\n          },\n          created: function created() {\n            this.setOptions(this.options);\n          },\n          mounted: function mounted() {\n            if (this.dropEnabled) {\n              this.$el.addEventListener(\'dragstart\', this.dragStart);\n              this.$el.addEventListener(\'dragend\', this.dragEnd);\n              window.addEventListener(\'dragover\', this.dragOver);\n            } else {\n              document.addEventListener(\'mousemove\', this.mouseMove, {\n                passive: true\n              });\n              document.addEventListener(\'mouseup\', this.mouseUp);\n            }\n\n            if (this.centered) {\n              var vm = this;\n              this.$nextTick(function () {\n                vm.center();\n                vm.emit(\'load\');\n              });\n            } else {\n              this.emit(\'load\');\n            }\n          },\n          beforeDestroy: function beforeDestroy() {\n            if (this.dropEnabled) {\n              window.removeEventListener(\'dragover\', this.dragOver);\n            } else {\n              document.removeEventListener(\'mousemove\', this.mouseMove);\n              document.removeEventListener(\'mouseup\', this.mouseUp);\n            }\n          },\n          watch: {\n            options: function options(newValue) {\n              this.setOptions(newValue);\n              if (newValue.centered) this.center();\n            }\n          },\n          computed: {\n            dialogStyle: function dialogStyle() {\n              var style = {\n                left: this.left + \'px\',\n                top: this.top + \'px\'\n              };\n              if (this.width) style.width = this.width + \'px\';\n              if (this.height) style.height = this.height + \'px\';\n              if (this.zIndex) style.zIndex = this.zIndex;\n\n              if (this.drag) {\n                style[\'user-select\'] = \'none\';\n                style.cursor = this.dragCursor;\n              }\n\n              return style;\n            }\n          },\n          methods: {\n            mouseOut: function mouseOut(event) {\n              if (!this.dragEnabled && this.dragging) {\n                this.move(event);\n              }\n            },\n            dragOver: function dragOver(event) {\n              if (this.dropEnabled) {\n                this.overEvent = event;\n                this.emit(\'move\');\n              }\n            },\n            mouseOver: function mouseOver(event) {\n              setTimeout(this.mouseMove(event), 50);\n            },\n            close: function close() {\n              this.clickButton = \'close\';\n              this.emit(\'close\');\n            },\n            setDrag: function setDrag() {\n              if (this.dragEnabled) {\n                this.drag = !this.drag;\n                this.emit(\'pin\');\n              }\n            },\n            dragStart: function dragStart(event) {\n              event.stopPropagation();\n\n              if (this.drag && this.dragEnabled && this.dropEnabled) {\n                event.dataTransfer.setData(\'text\', event.target.id);\n                this.startMove(event);\n              }\n            },\n            dragEnd: function dragEnd(event) {\n              event.preventDefault();\n\n              if (this.dropEnabled) {\n                this.move(event);\n                this.emit(\'drag-end\');\n              }\n            },\n            mouseDown: function mouseDown(event) {\n              if (!this.dragging) this.focus();\n\n              if (!this.dropEnabled) {\n                if (this.drag) event.preventDefault();\n                this.startMove(event);\n              }\n            },\n            mouseMove: function mouseMove(event) {\n              // event.preventDefault()\n              if (!this.dropEnabled && this.dragging && this.drag) {\n                // event.stopPropagation()\n                setTimeout(this.move(event), 50);\n              }\n            },\n            mouseUp: function mouseUp(event) {\n              event.preventDefault();\n\n              if (!this.dropEnabled) {\n                this.stopMove();\n                this.emit(\'dragEnd\');\n              }\n            },\n            touchStart: function touchStart(event) {\n              this.emit(\'focus\');\n              this.startMove(event.targetTouches[0]);\n            },\n            touchMove: function touchMove(event) {\n              this.move(event.targetTouches[0]);\n            },\n            touchEnd: function touchEnd(event) {\n              this.emit(\'dragEnd\');\n              this.stopMove();\n            },\n            stopMove: function stopMove() {\n              this.dragging = false;\n              this.pX = 0;\n              this.pY = 0;\n            },\n            emit: function emit(eventName, data) {\n              data = data || {\n                id: this.id,\n                left: this.left,\n                top: this.top,\n                x: this.left,\n                y: this.top,\n                z: this.zIndex,\n                pinned: !this.drag,\n                width: this.$el.clientWidth,\n                height: this.$el.clientHeight\n              };\n\n              if (this.eventCb) {\n                var ef = this.eventCb;\n\n                if (ef && typeof ef === \'function\') {\n                  data = ef(data);\n                }\n              }\n\n              this.$emit(eventName, data);\n            },\n            move: function move(event) {\n              if (this.drag && this.dragEnabled) {\n                if (event.clientX === 0) event = this.overEvent; // for firefox\n\n                if (event && event.clientX && event.clientY) {\n                  var x = event.clientX;\n                  var y = event.clientY;\n                  this.left = x + this.offset.x;\n                  this.top = y + this.offset.y;\n                  this.dragging++;\n                  this.emit(\'move\');\n                }\n              }\n            },\n            clearSelection: function clearSelection() {\n              if (document.selection) {\n                document.selection.empty();\n              } else if (window.getSelection) {\n                window.getSelection().removeAllRanges();\n              }\n            },\n            startMove: function startMove(event) {\n              var x = this.left - event.clientX;\n              var y = this.top - event.clientY;\n              this.offset = {\n                x: x,\n                y: y\n              };\n              this.dragging = 1;\n              this.emit(\'drag-start\');\n            },\n            focus: function focus(event) {\n              if (this.drag) this.clearSelection();\n              var vm = this;\n              setTimeout(function () {\n                if (!vm.clickButton) vm.emit(\'focus\');\n              }, 200);\n            },\n            center: function center() {\n              var ww, wh;\n\n              if (this.centered === \'window\') {\n                ww = window.innerWidth;\n                wh = window.innerHeight;\n              }\n\n              if (this.centered === \'viewport\') {\n                var body = document.body;\n                ww = body.clientWidth + body.scrollLeft;\n                wh = body.clientHeight + body.scrollTop;\n              }\n\n              ww = ww || this.$parent.$el.clientWidth;\n              wh = wh || this.$parent.$el.clientHeight;\n              this.left = ww / 2 - this.$el.clientWidth / 2;\n              this.top = wh / 2 - this.$el.clientHeight / 2;\n            },\n            setOptions: function setOptions(options) {\n              if (options) {\n                if (options.x) options.left = options.x;\n                if (options.y) options.top = options.y;\n                if (options.z) options.zIndex = options.z;\n                this.drag = this.options.pinned ? false : this.drag; // available options\n\n                var ops = this.availableOptions;\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                  for (var _iterator = ops[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var op = _step.value;\n\n                    if (this.options.hasOwnProperty(op)) {\n                      this.$set(this, op, this.options[op]);\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError = true;\n                  _iteratorError = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion && _iterator.return != null) {\n                      _iterator.return();\n                    }\n                  } finally {\n                    if (_didIteratorError) {\n                      throw _iteratorError;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }; // CONCATENATED MODULE: ./src/components/vue-dialog-drag.vue?vue&type=script&lang=js&\n\n        /* harmony default export */\n\n        var components_vue_dialog_dragvue_type_script_lang_js_ = vue_dialog_dragvue_type_script_lang_js_; // EXTERNAL MODULE: ./src/components/vue-dialog-drag.vue?vue&type=style&index=0&lang=stylus&\n\n        var vue_dialog_dragvue_type_style_index_0_lang_stylus_ = __webpack_require__("r8ud"); // CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\n\n        /* globals __VUE_SSR_CONTEXT__ */\n        // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n        // This module is a runtime utility for cleaner component module output and will\n        // be included in the final webpack user bundle.\n\n\n        function normalizeComponent(scriptExports, render, staticRenderFns, functionalTemplate, injectStyles, scopeId, moduleIdentifier,\n        /* server only */\n        shadowMode\n        /* vue-cli only */\n        ) {\n          // Vue.extend constructor export interop\n          var options = typeof scriptExports === \'function\' ? scriptExports.options : scriptExports; // render functions\n\n          if (render) {\n            options.render = render;\n            options.staticRenderFns = staticRenderFns;\n            options._compiled = true;\n          } // functional template\n\n\n          if (functionalTemplate) {\n            options.functional = true;\n          } // scopedId\n\n\n          if (scopeId) {\n            options._scopeId = \'data-v-\' + scopeId;\n          }\n\n          var hook;\n\n          if (moduleIdentifier) {\n            // server build\n            hook = function (context) {\n              // 2.3 injection\n              context = context || // cached call\n              this.$vnode && this.$vnode.ssrContext || // stateful\n              this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional\n              // 2.2 with runInNewContext: true\n\n              if (!context && typeof __VUE_SSR_CONTEXT__ !== \'undefined\') {\n                context = __VUE_SSR_CONTEXT__;\n              } // inject component styles\n\n\n              if (injectStyles) {\n                injectStyles.call(this, context);\n              } // register component module identifier for async chunk inferrence\n\n\n              if (context && context._registeredComponents) {\n                context._registeredComponents.add(moduleIdentifier);\n              }\n            }; // used by ssr in case component is cached and beforeCreate\n            // never gets called\n\n\n            options._ssrRegister = hook;\n          } else if (injectStyles) {\n            hook = shadowMode ? function () {\n              injectStyles.call(this, this.$root.$options.shadowRoot);\n            } : injectStyles;\n          }\n\n          if (hook) {\n            if (options.functional) {\n              // for template-only hot-reload because in that case the render fn doesn\'t\n              // go through the normalizer\n              options._injectStyles = hook; // register for functioal component in vue file\n\n              var originalRender = options.render;\n\n              options.render = function renderWithStyleInjection(h, context) {\n                hook.call(context);\n                return originalRender(h, context);\n              };\n            } else {\n              // inject component registration as beforeCreate hook\n              var existing = options.beforeCreate;\n              options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n            }\n          }\n\n          return {\n            exports: scriptExports,\n            options: options\n          };\n        } // CONCATENATED MODULE: ./src/components/vue-dialog-drag.vue\n\n        /* normalize component */\n\n\n        var component = normalizeComponent(components_vue_dialog_dragvue_type_script_lang_js_, render, staticRenderFns, false, null, null, null);\n        /* harmony default export */\n\n        var vue_dialog_drag = component.exports; // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js\n\n        /* harmony default export */\n\n        var entry_lib = __webpack_exports__["default"] = vue_dialog_drag;\n        /***/\n      },\n\n      /***/\n      "0/R4":\n      /***/\n      function (module, exports) {\n        module.exports = function (it) {\n          return typeof it === \'object\' ? it !== null : typeof it === \'function\';\n        };\n        /***/\n\n      },\n\n      /***/\n      "1MBn":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // all enumerable object keys, includes symbols\n        var getKeys = __webpack_require__("DVgA");\n\n        var gOPS = __webpack_require__("JiEa");\n\n        var pIE = __webpack_require__("UqcF");\n\n        module.exports = function (it) {\n          var result = getKeys(it);\n          var getSymbols = gOPS.f;\n\n          if (getSymbols) {\n            var symbols = getSymbols(it);\n            var isEnum = pIE.f;\n            var i = 0;\n            var key;\n\n            while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n          }\n\n          return result;\n        };\n        /***/\n\n      },\n\n      /***/\n      "1TsA":\n      /***/\n      function (module, exports) {\n        module.exports = function (done, value) {\n          return {\n            value: value,\n            done: !!done\n          };\n        };\n        /***/\n\n      },\n\n      /***/\n      "2OiF":\n      /***/\n      function (module, exports) {\n        module.exports = function (it) {\n          if (typeof it != \'function\') throw TypeError(it + \' is not a function!\');\n          return it;\n        };\n        /***/\n\n      },\n\n      /***/\n      "4R4u":\n      /***/\n      function (module, exports) {\n        // IE 8- don\'t enum bug keys\n        module.exports = \'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf\'.split(\',\');\n        /***/\n      },\n\n      /***/\n      "Afnz":\n      /***/\n      function (module, exports, __webpack_require__) {\n        "use strict";\n\n        var LIBRARY = __webpack_require__("LQAc");\n\n        var $export = __webpack_require__("XKFU");\n\n        var redefine = __webpack_require__("KroJ");\n\n        var hide = __webpack_require__("Mukb");\n\n        var Iterators = __webpack_require__("hPIQ");\n\n        var $iterCreate = __webpack_require__("QaDb");\n\n        var setToStringTag = __webpack_require__("fyDq");\n\n        var getPrototypeOf = __webpack_require__("OP3Y");\n\n        var ITERATOR = __webpack_require__("K0xU")(\'iterator\');\n\n        var BUGGY = !([].keys && \'next\' in [].keys()); // Safari has buggy iterators w/o `next`\n\n        var FF_ITERATOR = \'@@iterator\';\n        var KEYS = \'keys\';\n        var VALUES = \'values\';\n\n        var returnThis = function () {\n          return this;\n        };\n\n        module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n          $iterCreate(Constructor, NAME, next);\n\n          var getMethod = function (kind) {\n            if (!BUGGY && kind in proto) return proto[kind];\n\n            switch (kind) {\n              case KEYS:\n                return function keys() {\n                  return new Constructor(this, kind);\n                };\n\n              case VALUES:\n                return function values() {\n                  return new Constructor(this, kind);\n                };\n            }\n\n            return function entries() {\n              return new Constructor(this, kind);\n            };\n          };\n\n          var TAG = NAME + \' Iterator\';\n          var DEF_VALUES = DEFAULT == VALUES;\n          var VALUES_BUG = false;\n          var proto = Base.prototype;\n          var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n          var $default = $native || getMethod(DEFAULT);\n          var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod(\'entries\') : undefined;\n          var $anyNative = NAME == \'Array\' ? proto.entries || $native : $native;\n          var methods, key, IteratorPrototype; // Fix native\n\n          if ($anyNative) {\n            IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n\n            if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n              // Set @@toStringTag to native iterators\n              setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines\n\n              if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != \'function\') hide(IteratorPrototype, ITERATOR, returnThis);\n            }\n          } // fix Array#{values, @@iterator}.name in V8 / FF\n\n\n          if (DEF_VALUES && $native && $native.name !== VALUES) {\n            VALUES_BUG = true;\n\n            $default = function values() {\n              return $native.call(this);\n            };\n          } // Define iterator\n\n\n          if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n            hide(proto, ITERATOR, $default);\n          } // Plug for library\n\n\n          Iterators[NAME] = $default;\n          Iterators[TAG] = returnThis;\n\n          if (DEFAULT) {\n            methods = {\n              values: DEF_VALUES ? $default : getMethod(VALUES),\n              keys: IS_SET ? $default : getMethod(KEYS),\n              entries: $entries\n            };\n            if (FORCED) for (key in methods) {\n              if (!(key in proto)) redefine(proto, key, methods[key]);\n            } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n          }\n\n          return methods;\n        };\n        /***/\n\n      },\n\n      /***/\n      "Ayid":\n      /***/\n      function (module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin\n\n        /***/\n      },\n\n      /***/\n      "DVgA":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // 19.1.2.14 / 15.2.3.14 Object.keys(O)\n        var $keys = __webpack_require__("zhAb");\n\n        var enumBugKeys = __webpack_require__("4R4u");\n\n        module.exports = Object.keys || function keys(O) {\n          return $keys(O, enumBugKeys);\n        };\n        /***/\n\n      },\n\n      /***/\n      "EWmC":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // 7.2.2 IsArray(argument)\n        var cof = __webpack_require__("LZWt");\n\n        module.exports = Array.isArray || function isArray(arg) {\n          return cof(arg) == \'Array\';\n        };\n        /***/\n\n      },\n\n      /***/\n      "EemH":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var pIE = __webpack_require__("UqcF");\n\n        var createDesc = __webpack_require__("RjD/");\n\n        var toIObject = __webpack_require__("aCFj");\n\n        var toPrimitive = __webpack_require__("apmT");\n\n        var has = __webpack_require__("aagx");\n\n        var IE8_DOM_DEFINE = __webpack_require__("xpql");\n\n        var gOPD = Object.getOwnPropertyDescriptor;\n        exports.f = __webpack_require__("nh4g") ? gOPD : function getOwnPropertyDescriptor(O, P) {\n          O = toIObject(O);\n          P = toPrimitive(P, true);\n          if (IE8_DOM_DEFINE) try {\n            return gOPD(O, P);\n          } catch (e) {\n            /* empty */\n          }\n          if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n        };\n        /***/\n      },\n\n      /***/\n      "FJW5":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var dP = __webpack_require__("hswa");\n\n        var anObject = __webpack_require__("y3w9");\n\n        var getKeys = __webpack_require__("DVgA");\n\n        module.exports = __webpack_require__("nh4g") ? Object.defineProperties : function defineProperties(O, Properties) {\n          anObject(O);\n          var keys = getKeys(Properties);\n          var length = keys.length;\n          var i = 0;\n          var P;\n\n          while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n\n          return O;\n        };\n        /***/\n      },\n\n      /***/\n      "HrLf":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // This file is imported into lib/wc client bundles.\n        if (typeof window !== \'undefined\') {\n          var i;\n\n          if ((i = window.document.currentScript) && (i = i.src.match(/(.+\\/)[^/]+\\.js$/))) {\n            __webpack_require__.p = i[1]; // eslint-disable-line\n          }\n        }\n        /***/\n\n      },\n\n      /***/\n      "Iw71":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var isObject = __webpack_require__("0/R4");\n\n        var document = __webpack_require__("dyZX").document; // typeof document.createElement is \'object\' in old IE\n\n\n        var is = isObject(document) && isObject(document.createElement);\n\n        module.exports = function (it) {\n          return is ? document.createElement(it) : {};\n        };\n        /***/\n\n      },\n\n      /***/\n      "JiEa":\n      /***/\n      function (module, exports) {\n        exports.f = Object.getOwnPropertySymbols;\n        /***/\n      },\n\n      /***/\n      "K0xU":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var store = __webpack_require__("VTer")(\'wks\');\n\n        var uid = __webpack_require__("ylqs");\n\n        var Symbol = __webpack_require__("dyZX").Symbol;\n\n        var USE_SYMBOL = typeof Symbol == \'function\';\n\n        var $exports = module.exports = function (name) {\n          return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)(\'Symbol.\' + name));\n        };\n\n        $exports.store = store;\n        /***/\n      },\n\n      /***/\n      "KroJ":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var global = __webpack_require__("dyZX");\n\n        var hide = __webpack_require__("Mukb");\n\n        var has = __webpack_require__("aagx");\n\n        var SRC = __webpack_require__("ylqs")(\'src\');\n\n        var TO_STRING = \'toString\';\n        var $toString = Function[TO_STRING];\n        var TPL = (\'\' + $toString).split(TO_STRING);\n\n        __webpack_require__("g3g5").inspectSource = function (it) {\n          return $toString.call(it);\n        };\n\n        (module.exports = function (O, key, val, safe) {\n          var isFunction = typeof val == \'function\';\n          if (isFunction) has(val, \'name\') || hide(val, \'name\', key);\n          if (O[key] === val) return;\n          if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? \'\' + O[key] : TPL.join(String(key)));\n\n          if (O === global) {\n            O[key] = val;\n          } else if (!safe) {\n            delete O[key];\n            hide(O, key, val);\n          } else if (O[key]) {\n            O[key] = val;\n          } else {\n            hide(O, key, val);\n          } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n\n        })(Function.prototype, TO_STRING, function toString() {\n          return typeof this == \'function\' && this[SRC] || $toString.call(this);\n        });\n        /***/\n      },\n\n      /***/\n      "Kuth":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n        var anObject = __webpack_require__("y3w9");\n\n        var dPs = __webpack_require__("FJW5");\n\n        var enumBugKeys = __webpack_require__("4R4u");\n\n        var IE_PROTO = __webpack_require__("YTvA")(\'IE_PROTO\');\n\n        var Empty = function () {\n          /* empty */\n        };\n\n        var PROTOTYPE = \'prototype\'; // Create object with fake `null` prototype: use iframe Object with cleared prototype\n\n        var createDict = function () {\n          // Thrash, waste and sodomy: IE GC bug\n          var iframe = __webpack_require__("Iw71")(\'iframe\');\n\n          var i = enumBugKeys.length;\n          var lt = \'<\';\n          var gt = \'>\';\n          var iframeDocument;\n          iframe.style.display = \'none\';\n\n          __webpack_require__("+rLv").appendChild(iframe);\n\n          iframe.src = \'javascript:\'; // eslint-disable-line no-script-url\n          // createDict = iframe.contentWindow.Object;\n          // html.removeChild(iframe);\n\n          iframeDocument = iframe.contentWindow.document;\n          iframeDocument.open();\n          iframeDocument.write(lt + \'script\' + gt + \'document.F=Object\' + lt + \'/script\' + gt);\n          iframeDocument.close();\n          createDict = iframeDocument.F;\n\n          while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n\n          return createDict();\n        };\n\n        module.exports = Object.create || function create(O, Properties) {\n          var result;\n\n          if (O !== null) {\n            Empty[PROTOTYPE] = anObject(O);\n            result = new Empty();\n            Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill\n\n            result[IE_PROTO] = O;\n          } else result = createDict();\n\n          return Properties === undefined ? result : dPs(result, Properties);\n        };\n        /***/\n\n      },\n\n      /***/\n      "LQAc":\n      /***/\n      function (module, exports) {\n        module.exports = false;\n        /***/\n      },\n\n      /***/\n      "LZWt":\n      /***/\n      function (module, exports) {\n        var toString = {}.toString;\n\n        module.exports = function (it) {\n          return toString.call(it).slice(8, -1);\n        };\n        /***/\n\n      },\n\n      /***/\n      "Mukb":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var dP = __webpack_require__("hswa");\n\n        var createDesc = __webpack_require__("RjD/");\n\n        module.exports = __webpack_require__("nh4g") ? function (object, key, value) {\n          return dP.f(object, key, createDesc(1, value));\n        } : function (object, key, value) {\n          object[key] = value;\n          return object;\n        };\n        /***/\n      },\n\n      /***/\n      "N8g3":\n      /***/\n      function (module, exports, __webpack_require__) {\n        exports.f = __webpack_require__("K0xU");\n        /***/\n      },\n\n      /***/\n      "OP3Y":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\n        var has = __webpack_require__("aagx");\n\n        var toObject = __webpack_require__("S/j/");\n\n        var IE_PROTO = __webpack_require__("YTvA")(\'IE_PROTO\');\n\n        var ObjectProto = Object.prototype;\n\n        module.exports = Object.getPrototypeOf || function (O) {\n          O = toObject(O);\n          if (has(O, IE_PROTO)) return O[IE_PROTO];\n\n          if (typeof O.constructor == \'function\' && O instanceof O.constructor) {\n            return O.constructor.prototype;\n          }\n\n          return O instanceof Object ? ObjectProto : null;\n        };\n        /***/\n\n      },\n\n      /***/\n      "OnI7":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var global = __webpack_require__("dyZX");\n\n        var core = __webpack_require__("g3g5");\n\n        var LIBRARY = __webpack_require__("LQAc");\n\n        var wksExt = __webpack_require__("N8g3");\n\n        var defineProperty = __webpack_require__("hswa").f;\n\n        module.exports = function (name) {\n          var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n          if (name.charAt(0) != \'_\' && !(name in $Symbol)) defineProperty($Symbol, name, {\n            value: wksExt.f(name)\n          });\n        };\n        /***/\n\n      },\n\n      /***/\n      "QaDb":\n      /***/\n      function (module, exports, __webpack_require__) {\n        "use strict";\n\n        var create = __webpack_require__("Kuth");\n\n        var descriptor = __webpack_require__("RjD/");\n\n        var setToStringTag = __webpack_require__("fyDq");\n\n        var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\n        __webpack_require__("Mukb")(IteratorPrototype, __webpack_require__("K0xU")(\'iterator\'), function () {\n          return this;\n        });\n\n        module.exports = function (Constructor, NAME, next) {\n          Constructor.prototype = create(IteratorPrototype, {\n            next: descriptor(1, next)\n          });\n          setToStringTag(Constructor, NAME + \' Iterator\');\n        };\n        /***/\n\n      },\n\n      /***/\n      "RYi7":\n      /***/\n      function (module, exports) {\n        // 7.1.4 ToInteger\n        var ceil = Math.ceil;\n        var floor = Math.floor;\n\n        module.exports = function (it) {\n          return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n        };\n        /***/\n\n      },\n\n      /***/\n      "RjD/":\n      /***/\n      function (module, exports) {\n        module.exports = function (bitmap, value) {\n          return {\n            enumerable: !(bitmap & 1),\n            configurable: !(bitmap & 2),\n            writable: !(bitmap & 4),\n            value: value\n          };\n        };\n        /***/\n\n      },\n\n      /***/\n      "S/j/":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // 7.1.13 ToObject(argument)\n        var defined = __webpack_require__("vhPU");\n\n        module.exports = function (it) {\n          return Object(defined(it));\n        };\n        /***/\n\n      },\n\n      /***/\n      "UqcF":\n      /***/\n      function (module, exports) {\n        exports.f = {}.propertyIsEnumerable;\n        /***/\n      },\n\n      /***/\n      "VTer":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var core = __webpack_require__("g3g5");\n\n        var global = __webpack_require__("dyZX");\n\n        var SHARED = \'__core-js_shared__\';\n        var store = global[SHARED] || (global[SHARED] = {});\n        (module.exports = function (key, value) {\n          return store[key] || (store[key] = value !== undefined ? value : {});\n        })(\'versions\', []).push({\n          version: core.version,\n          mode: __webpack_require__("LQAc") ? \'pure\' : \'global\',\n          copyright: \'© 2018 Denis Pushkarev (zloirock.ru)\'\n        });\n        /***/\n      },\n\n      /***/\n      "XKFU":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var global = __webpack_require__("dyZX");\n\n        var core = __webpack_require__("g3g5");\n\n        var hide = __webpack_require__("Mukb");\n\n        var redefine = __webpack_require__("KroJ");\n\n        var ctx = __webpack_require__("m0Pp");\n\n        var PROTOTYPE = \'prototype\';\n\n        var $export = function (type, name, source) {\n          var IS_FORCED = type & $export.F;\n          var IS_GLOBAL = type & $export.G;\n          var IS_STATIC = type & $export.S;\n          var IS_PROTO = type & $export.P;\n          var IS_BIND = type & $export.B;\n          var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n          var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n          var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n          var key, own, out, exp;\n          if (IS_GLOBAL) source = name;\n\n          for (key in source) {\n            // contains in native\n            own = !IS_FORCED && target && target[key] !== undefined; // export native or passed\n\n            out = (own ? target : source)[key]; // bind timers to global for call from export context\n\n            exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == \'function\' ? ctx(Function.call, out) : out; // extend global\n\n            if (target) redefine(target, key, out, type & $export.U); // export\n\n            if (exports[key] != out) hide(exports, key, exp);\n            if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n          }\n        };\n\n        global.core = core; // type bitmap\n\n        $export.F = 1; // forced\n\n        $export.G = 2; // global\n\n        $export.S = 4; // static\n\n        $export.P = 8; // proto\n\n        $export.B = 16; // bind\n\n        $export.W = 32; // wrap\n\n        $export.U = 64; // safe\n\n        $export.R = 128; // real proto method for `library`\n\n        module.exports = $export;\n        /***/\n      },\n\n      /***/\n      "YTvA":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var shared = __webpack_require__("VTer")(\'keys\');\n\n        var uid = __webpack_require__("ylqs");\n\n        module.exports = function (key) {\n          return shared[key] || (shared[key] = uid(key));\n        };\n        /***/\n\n      },\n\n      /***/\n      "Ymqv":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // fallback for non-array-like ES3 and non-enumerable old V8 strings\n        var cof = __webpack_require__("LZWt"); // eslint-disable-next-line no-prototype-builtins\n\n\n        module.exports = Object(\'z\').propertyIsEnumerable(0) ? Object : function (it) {\n          return cof(it) == \'String\' ? it.split(\'\') : Object(it);\n        };\n        /***/\n      },\n\n      /***/\n      "Z6vF":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var META = __webpack_require__("ylqs")(\'meta\');\n\n        var isObject = __webpack_require__("0/R4");\n\n        var has = __webpack_require__("aagx");\n\n        var setDesc = __webpack_require__("hswa").f;\n\n        var id = 0;\n\n        var isExtensible = Object.isExtensible || function () {\n          return true;\n        };\n\n        var FREEZE = !__webpack_require__("eeVq")(function () {\n          return isExtensible(Object.preventExtensions({}));\n        });\n\n        var setMeta = function (it) {\n          setDesc(it, META, {\n            value: {\n              i: \'O\' + ++id,\n              // object ID\n              w: {} // weak collections IDs\n\n            }\n          });\n        };\n\n        var fastKey = function (it, create) {\n          // return primitive with prefix\n          if (!isObject(it)) return typeof it == \'symbol\' ? it : (typeof it == \'string\' ? \'S\' : \'P\') + it;\n\n          if (!has(it, META)) {\n            // can\'t set metadata to uncaught frozen object\n            if (!isExtensible(it)) return \'F\'; // not necessary to add metadata\n\n            if (!create) return \'E\'; // add missing metadata\n\n            setMeta(it); // return object ID\n          }\n\n          return it[META].i;\n        };\n\n        var getWeak = function (it, create) {\n          if (!has(it, META)) {\n            // can\'t set metadata to uncaught frozen object\n            if (!isExtensible(it)) return true; // not necessary to add metadata\n\n            if (!create) return false; // add missing metadata\n\n            setMeta(it); // return hash weak collections IDs\n          }\n\n          return it[META].w;\n        }; // add metadata on freeze-family methods calling\n\n\n        var onFreeze = function (it) {\n          if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n          return it;\n        };\n\n        var meta = module.exports = {\n          KEY: META,\n          NEED: false,\n          fastKey: fastKey,\n          getWeak: getWeak,\n          onFreeze: onFreeze\n        };\n        /***/\n      },\n\n      /***/\n      "aCFj":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // to indexed object, toObject with fallback for non-array-like ES3 strings\n        var IObject = __webpack_require__("Ymqv");\n\n        var defined = __webpack_require__("vhPU");\n\n        module.exports = function (it) {\n          return IObject(defined(it));\n        };\n        /***/\n\n      },\n\n      /***/\n      "aagx":\n      /***/\n      function (module, exports) {\n        var hasOwnProperty = {}.hasOwnProperty;\n\n        module.exports = function (it, key) {\n          return hasOwnProperty.call(it, key);\n        };\n        /***/\n\n      },\n\n      /***/\n      "apmT":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // 7.1.1 ToPrimitive(input [, PreferredType])\n        var isObject = __webpack_require__("0/R4"); // instead of the ES6 spec version, we didn\'t implement @@toPrimitive case\n        // and the second argument - flag - preferred type is a string\n\n\n        module.exports = function (it, S) {\n          if (!isObject(it)) return it;\n          var fn, val;\n          if (S && typeof (fn = it.toString) == \'function\' && !isObject(val = fn.call(it))) return val;\n          if (typeof (fn = it.valueOf) == \'function\' && !isObject(val = fn.call(it))) return val;\n          if (!S && typeof (fn = it.toString) == \'function\' && !isObject(val = fn.call(it))) return val;\n          throw TypeError("Can\'t convert object to primitive value");\n        };\n        /***/\n\n      },\n\n      /***/\n      "d/Gc":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var toInteger = __webpack_require__("RYi7");\n\n        var max = Math.max;\n        var min = Math.min;\n\n        module.exports = function (index, length) {\n          index = toInteger(index);\n          return index < 0 ? max(index + length, 0) : min(index, length);\n        };\n        /***/\n\n      },\n\n      /***/\n      "dyZX":\n      /***/\n      function (module, exports) {\n        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n        var global = module.exports = typeof window != \'undefined\' && window.Math == Math ? window : typeof self != \'undefined\' && self.Math == Math ? self // eslint-disable-next-line no-new-func\n        : Function(\'return this\')();\n        if (typeof __g == \'number\') __g = global; // eslint-disable-line no-undef\n\n        /***/\n      },\n\n      /***/\n      "e7yV":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n        var toIObject = __webpack_require__("aCFj");\n\n        var gOPN = __webpack_require__("kJMx").f;\n\n        var toString = {}.toString;\n        var windowNames = typeof window == \'object\' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];\n\n        var getWindowNames = function (it) {\n          try {\n            return gOPN(it);\n          } catch (e) {\n            return windowNames.slice();\n          }\n        };\n\n        module.exports.f = function getOwnPropertyNames(it) {\n          return windowNames && toString.call(it) == \'[object Window]\' ? getWindowNames(it) : gOPN(toIObject(it));\n        };\n        /***/\n\n      },\n\n      /***/\n      "eeVq":\n      /***/\n      function (module, exports) {\n        module.exports = function (exec) {\n          try {\n            return !!exec();\n          } catch (e) {\n            return true;\n          }\n        };\n        /***/\n\n      },\n\n      /***/\n      "fyDq":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var def = __webpack_require__("hswa").f;\n\n        var has = __webpack_require__("aagx");\n\n        var TAG = __webpack_require__("K0xU")(\'toStringTag\');\n\n        module.exports = function (it, tag, stat) {\n          if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {\n            configurable: true,\n            value: tag\n          });\n        };\n        /***/\n\n      },\n\n      /***/\n      "g3g5":\n      /***/\n      function (module, exports) {\n        var core = module.exports = {\n          version: \'2.5.7\'\n        };\n        if (typeof __e == \'number\') __e = core; // eslint-disable-line no-undef\n\n        /***/\n      },\n\n      /***/\n      "hPIQ":\n      /***/\n      function (module, exports) {\n        module.exports = {};\n        /***/\n      },\n\n      /***/\n      "hswa":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var anObject = __webpack_require__("y3w9");\n\n        var IE8_DOM_DEFINE = __webpack_require__("xpql");\n\n        var toPrimitive = __webpack_require__("apmT");\n\n        var dP = Object.defineProperty;\n        exports.f = __webpack_require__("nh4g") ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n          anObject(O);\n          P = toPrimitive(P, true);\n          anObject(Attributes);\n          if (IE8_DOM_DEFINE) try {\n            return dP(O, P, Attributes);\n          } catch (e) {\n            /* empty */\n          }\n          if (\'get\' in Attributes || \'set\' in Attributes) throw TypeError(\'Accessors not supported!\');\n          if (\'value\' in Attributes) O[P] = Attributes.value;\n          return O;\n        };\n        /***/\n      },\n\n      /***/\n      "ioFf":\n      /***/\n      function (module, exports, __webpack_require__) {\n        "use strict"; // ECMAScript 6 symbols shim\n\n        var global = __webpack_require__("dyZX");\n\n        var has = __webpack_require__("aagx");\n\n        var DESCRIPTORS = __webpack_require__("nh4g");\n\n        var $export = __webpack_require__("XKFU");\n\n        var redefine = __webpack_require__("KroJ");\n\n        var META = __webpack_require__("Z6vF").KEY;\n\n        var $fails = __webpack_require__("eeVq");\n\n        var shared = __webpack_require__("VTer");\n\n        var setToStringTag = __webpack_require__("fyDq");\n\n        var uid = __webpack_require__("ylqs");\n\n        var wks = __webpack_require__("K0xU");\n\n        var wksExt = __webpack_require__("N8g3");\n\n        var wksDefine = __webpack_require__("OnI7");\n\n        var enumKeys = __webpack_require__("1MBn");\n\n        var isArray = __webpack_require__("EWmC");\n\n        var anObject = __webpack_require__("y3w9");\n\n        var isObject = __webpack_require__("0/R4");\n\n        var toIObject = __webpack_require__("aCFj");\n\n        var toPrimitive = __webpack_require__("apmT");\n\n        var createDesc = __webpack_require__("RjD/");\n\n        var _create = __webpack_require__("Kuth");\n\n        var gOPNExt = __webpack_require__("e7yV");\n\n        var $GOPD = __webpack_require__("EemH");\n\n        var $DP = __webpack_require__("hswa");\n\n        var $keys = __webpack_require__("DVgA");\n\n        var gOPD = $GOPD.f;\n        var dP = $DP.f;\n        var gOPN = gOPNExt.f;\n        var $Symbol = global.Symbol;\n        var $JSON = global.JSON;\n\n        var _stringify = $JSON && $JSON.stringify;\n\n        var PROTOTYPE = \'prototype\';\n        var HIDDEN = wks(\'_hidden\');\n        var TO_PRIMITIVE = wks(\'toPrimitive\');\n        var isEnum = {}.propertyIsEnumerable;\n        var SymbolRegistry = shared(\'symbol-registry\');\n        var AllSymbols = shared(\'symbols\');\n        var OPSymbols = shared(\'op-symbols\');\n        var ObjectProto = Object[PROTOTYPE];\n        var USE_NATIVE = typeof $Symbol == \'function\';\n        var QObject = global.QObject; // Don\'t use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n\n        var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\n        var setSymbolDesc = DESCRIPTORS && $fails(function () {\n          return _create(dP({}, \'a\', {\n            get: function () {\n              return dP(this, \'a\', {\n                value: 7\n              }).a;\n            }\n          })).a != 7;\n        }) ? function (it, key, D) {\n          var protoDesc = gOPD(ObjectProto, key);\n          if (protoDesc) delete ObjectProto[key];\n          dP(it, key, D);\n          if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n        } : dP;\n\n        var wrap = function (tag) {\n          var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n\n          sym._k = tag;\n          return sym;\n        };\n\n        var isSymbol = USE_NATIVE && typeof $Symbol.iterator == \'symbol\' ? function (it) {\n          return typeof it == \'symbol\';\n        } : function (it) {\n          return it instanceof $Symbol;\n        };\n\n        var $defineProperty = function defineProperty(it, key, D) {\n          if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n          anObject(it);\n          key = toPrimitive(key, true);\n          anObject(D);\n\n          if (has(AllSymbols, key)) {\n            if (!D.enumerable) {\n              if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n              it[HIDDEN][key] = true;\n            } else {\n              if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n              D = _create(D, {\n                enumerable: createDesc(0, false)\n              });\n            }\n\n            return setSymbolDesc(it, key, D);\n          }\n\n          return dP(it, key, D);\n        };\n\n        var $defineProperties = function defineProperties(it, P) {\n          anObject(it);\n          var keys = enumKeys(P = toIObject(P));\n          var i = 0;\n          var l = keys.length;\n          var key;\n\n          while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n\n          return it;\n        };\n\n        var $create = function create(it, P) {\n          return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n        };\n\n        var $propertyIsEnumerable = function propertyIsEnumerable(key) {\n          var E = isEnum.call(this, key = toPrimitive(key, true));\n          if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n          return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n        };\n\n        var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n          it = toIObject(it);\n          key = toPrimitive(key, true);\n          if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n          var D = gOPD(it, key);\n          if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n          return D;\n        };\n\n        var $getOwnPropertyNames = function getOwnPropertyNames(it) {\n          var names = gOPN(toIObject(it));\n          var result = [];\n          var i = 0;\n          var key;\n\n          while (names.length > i) {\n            if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n          }\n\n          return result;\n        };\n\n        var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n          var IS_OP = it === ObjectProto;\n          var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n          var result = [];\n          var i = 0;\n          var key;\n\n          while (names.length > i) {\n            if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n          }\n\n          return result;\n        }; // 19.4.1.1 Symbol([description])\n\n\n        if (!USE_NATIVE) {\n          $Symbol = function Symbol() {\n            if (this instanceof $Symbol) throw TypeError(\'Symbol is not a constructor!\');\n            var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n\n            var $set = function (value) {\n              if (this === ObjectProto) $set.call(OPSymbols, value);\n              if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n              setSymbolDesc(this, tag, createDesc(1, value));\n            };\n\n            if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {\n              configurable: true,\n              set: $set\n            });\n            return wrap(tag);\n          };\n\n          redefine($Symbol[PROTOTYPE], \'toString\', function toString() {\n            return this._k;\n          });\n          $GOPD.f = $getOwnPropertyDescriptor;\n          $DP.f = $defineProperty;\n          __webpack_require__("kJMx").f = gOPNExt.f = $getOwnPropertyNames;\n          __webpack_require__("UqcF").f = $propertyIsEnumerable;\n          __webpack_require__("JiEa").f = $getOwnPropertySymbols;\n\n          if (DESCRIPTORS && !__webpack_require__("LQAc")) {\n            redefine(ObjectProto, \'propertyIsEnumerable\', $propertyIsEnumerable, true);\n          }\n\n          wksExt.f = function (name) {\n            return wrap(wks(name));\n          };\n        }\n\n        $export($export.G + $export.W + $export.F * !USE_NATIVE, {\n          Symbol: $Symbol\n        });\n\n        for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n        \'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables\'.split(\',\'), j = 0; es6Symbols.length > j;) wks(es6Symbols[j++]);\n\n        for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\n\n        $export($export.S + $export.F * !USE_NATIVE, \'Symbol\', {\n          // 19.4.2.1 Symbol.for(key)\n          \'for\': function (key) {\n            return has(SymbolRegistry, key += \'\') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);\n          },\n          // 19.4.2.5 Symbol.keyFor(sym)\n          keyFor: function keyFor(sym) {\n            if (!isSymbol(sym)) throw TypeError(sym + \' is not a symbol!\');\n\n            for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n          },\n          useSetter: function () {\n            setter = true;\n          },\n          useSimple: function () {\n            setter = false;\n          }\n        });\n        $export($export.S + $export.F * !USE_NATIVE, \'Object\', {\n          // 19.1.2.2 Object.create(O [, Properties])\n          create: $create,\n          // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n          defineProperty: $defineProperty,\n          // 19.1.2.3 Object.defineProperties(O, Properties)\n          defineProperties: $defineProperties,\n          // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n          getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n          // 19.1.2.7 Object.getOwnPropertyNames(O)\n          getOwnPropertyNames: $getOwnPropertyNames,\n          // 19.1.2.8 Object.getOwnPropertySymbols(O)\n          getOwnPropertySymbols: $getOwnPropertySymbols\n        }); // 24.3.2 JSON.stringify(value [, replacer [, space]])\n\n        $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\n          var S = $Symbol(); // MS Edge converts symbol values to JSON as {}\n          // WebKit converts symbol values to JSON as null\n          // V8 throws on boxed symbols\n\n          return _stringify([S]) != \'[null]\' || _stringify({\n            a: S\n          }) != \'{}\' || _stringify(Object(S)) != \'{}\';\n        })), \'JSON\', {\n          stringify: function stringify(it) {\n            var args = [it];\n            var i = 1;\n            var replacer, $replacer;\n\n            while (arguments.length > i) args.push(arguments[i++]);\n\n            $replacer = replacer = args[1];\n            if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n\n            if (!isArray(replacer)) replacer = function (key, value) {\n              if (typeof $replacer == \'function\') value = $replacer.call(this, key, value);\n              if (!isSymbol(value)) return value;\n            };\n            args[1] = replacer;\n            return _stringify.apply($JSON, args);\n          }\n        }); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n\n        $Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__("Mukb")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]\n\n        setToStringTag($Symbol, \'Symbol\'); // 20.2.1.9 Math[@@toStringTag]\n\n        setToStringTag(Math, \'Math\', true); // 24.3.3 JSON[@@toStringTag]\n\n        setToStringTag(global.JSON, \'JSON\', true);\n        /***/\n      },\n\n      /***/\n      "kJMx":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\n        var $keys = __webpack_require__("zhAb");\n\n        var hiddenKeys = __webpack_require__("4R4u").concat(\'length\', \'prototype\');\n\n        exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n          return $keys(O, hiddenKeys);\n        };\n        /***/\n\n      },\n\n      /***/\n      "m0Pp":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // optional / simple context binding\n        var aFunction = __webpack_require__("2OiF");\n\n        module.exports = function (fn, that, length) {\n          aFunction(fn);\n          if (that === undefined) return fn;\n\n          switch (length) {\n            case 1:\n              return function (a) {\n                return fn.call(that, a);\n              };\n\n            case 2:\n              return function (a, b) {\n                return fn.call(that, a, b);\n              };\n\n            case 3:\n              return function (a, b, c) {\n                return fn.call(that, a, b, c);\n              };\n          }\n\n          return function\n            /* ...args */\n          () {\n            return fn.apply(that, arguments);\n          };\n        };\n        /***/\n\n      },\n\n      /***/\n      "nGyu":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // 22.1.3.31 Array.prototype[@@unscopables]\n        var UNSCOPABLES = __webpack_require__("K0xU")(\'unscopables\');\n\n        var ArrayProto = Array.prototype;\n        if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__("Mukb")(ArrayProto, UNSCOPABLES, {});\n\n        module.exports = function (key) {\n          ArrayProto[UNSCOPABLES][key] = true;\n        };\n        /***/\n\n      },\n\n      /***/\n      "ne8i":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // 7.1.15 ToLength\n        var toInteger = __webpack_require__("RYi7");\n\n        var min = Math.min;\n\n        module.exports = function (it) {\n          return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n        };\n        /***/\n\n      },\n\n      /***/\n      "nh4g":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // Thank\'s IE8 for his funny defineProperty\n        module.exports = !__webpack_require__("eeVq")(function () {\n          return Object.defineProperty({}, \'a\', {\n            get: function () {\n              return 7;\n            }\n          }).a != 7;\n        });\n        /***/\n      },\n\n      /***/\n      "r8ud":\n      /***/\n      function (module, __webpack_exports__, __webpack_require__) {\n        "use strict";\n        /* harmony import */\n\n        var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_lib_index_js_ref_11_oneOf_1_2_node_modules_stylus_loader_index_js_ref_11_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_vue_dialog_drag_vue_vue_type_style_index_0_lang_stylus___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("Ayid");\n        /* harmony import */\n\n\n        var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_lib_index_js_ref_11_oneOf_1_2_node_modules_stylus_loader_index_js_ref_11_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_vue_dialog_drag_vue_vue_type_style_index_0_lang_stylus___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_lib_index_js_ref_11_oneOf_1_2_node_modules_stylus_loader_index_js_ref_11_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_vue_dialog_drag_vue_vue_type_style_index_0_lang_stylus___WEBPACK_IMPORTED_MODULE_0__);\n        /* unused harmony reexport * */\n\n        /* unused harmony default export */\n\n\n        var _unused_webpack_default_export = _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_11_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_lib_index_js_ref_11_oneOf_1_2_node_modules_stylus_loader_index_js_ref_11_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_vue_dialog_drag_vue_vue_type_style_index_0_lang_stylus___WEBPACK_IMPORTED_MODULE_0___default.a;\n        /***/\n      },\n\n      /***/\n      "rE2o":\n      /***/\n      function (module, exports, __webpack_require__) {\n        __webpack_require__("OnI7")(\'asyncIterator\');\n        /***/\n\n      },\n\n      /***/\n      "rGqo":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var $iterators = __webpack_require__("yt8O");\n\n        var getKeys = __webpack_require__("DVgA");\n\n        var redefine = __webpack_require__("KroJ");\n\n        var global = __webpack_require__("dyZX");\n\n        var hide = __webpack_require__("Mukb");\n\n        var Iterators = __webpack_require__("hPIQ");\n\n        var wks = __webpack_require__("K0xU");\n\n        var ITERATOR = wks(\'iterator\');\n        var TO_STRING_TAG = wks(\'toStringTag\');\n        var ArrayValues = Iterators.Array;\n        var DOMIterables = {\n          CSSRuleList: true,\n          // TODO: Not spec compliant, should be false.\n          CSSStyleDeclaration: false,\n          CSSValueList: false,\n          ClientRectList: false,\n          DOMRectList: false,\n          DOMStringList: false,\n          DOMTokenList: true,\n          DataTransferItemList: false,\n          FileList: false,\n          HTMLAllCollection: false,\n          HTMLCollection: false,\n          HTMLFormElement: false,\n          HTMLSelectElement: false,\n          MediaList: true,\n          // TODO: Not spec compliant, should be false.\n          MimeTypeArray: false,\n          NamedNodeMap: false,\n          NodeList: true,\n          PaintRequestList: false,\n          Plugin: false,\n          PluginArray: false,\n          SVGLengthList: false,\n          SVGNumberList: false,\n          SVGPathSegList: false,\n          SVGPointList: false,\n          SVGStringList: false,\n          SVGTransformList: false,\n          SourceBufferList: false,\n          StyleSheetList: true,\n          // TODO: Not spec compliant, should be false.\n          TextTrackCueList: false,\n          TextTrackList: false,\n          TouchList: false\n        };\n\n        for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {\n          var NAME = collections[i];\n          var explicit = DOMIterables[NAME];\n          var Collection = global[NAME];\n          var proto = Collection && Collection.prototype;\n          var key;\n\n          if (proto) {\n            if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\n            if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n            Iterators[NAME] = ArrayValues;\n            if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);\n          }\n        }\n        /***/\n\n      },\n\n      /***/\n      "vhPU":\n      /***/\n      function (module, exports) {\n        // 7.2.1 RequireObjectCoercible(argument)\n        module.exports = function (it) {\n          if (it == undefined) throw TypeError("Can\'t call method on  " + it);\n          return it;\n        };\n        /***/\n\n      },\n\n      /***/\n      "w2a5":\n      /***/\n      function (module, exports, __webpack_require__) {\n        // false -> Array#indexOf\n        // true  -> Array#includes\n        var toIObject = __webpack_require__("aCFj");\n\n        var toLength = __webpack_require__("ne8i");\n\n        var toAbsoluteIndex = __webpack_require__("d/Gc");\n\n        module.exports = function (IS_INCLUDES) {\n          return function ($this, el, fromIndex) {\n            var O = toIObject($this);\n            var length = toLength(O.length);\n            var index = toAbsoluteIndex(fromIndex, length);\n            var value; // Array#includes uses SameValueZero equality algorithm\n            // eslint-disable-next-line no-self-compare\n\n            if (IS_INCLUDES && el != el) while (length > index) {\n              value = O[index++]; // eslint-disable-next-line no-self-compare\n\n              if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not\n            } else for (; length > index; index++) if (IS_INCLUDES || index in O) {\n              if (O[index] === el) return IS_INCLUDES || index || 0;\n            }\n            return !IS_INCLUDES && -1;\n          };\n        };\n        /***/\n\n      },\n\n      /***/\n      "xpql":\n      /***/\n      function (module, exports, __webpack_require__) {\n        module.exports = !__webpack_require__("nh4g") && !__webpack_require__("eeVq")(function () {\n          return Object.defineProperty(__webpack_require__("Iw71")(\'div\'), \'a\', {\n            get: function () {\n              return 7;\n            }\n          }).a != 7;\n        });\n        /***/\n      },\n\n      /***/\n      "y3w9":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var isObject = __webpack_require__("0/R4");\n\n        module.exports = function (it) {\n          if (!isObject(it)) throw TypeError(it + \' is not an object!\');\n          return it;\n        };\n        /***/\n\n      },\n\n      /***/\n      "ylqs":\n      /***/\n      function (module, exports) {\n        var id = 0;\n        var px = Math.random();\n\n        module.exports = function (key) {\n          return \'Symbol(\'.concat(key === undefined ? \'\' : key, \')_\', (++id + px).toString(36));\n        };\n        /***/\n\n      },\n\n      /***/\n      "yt8O":\n      /***/\n      function (module, exports, __webpack_require__) {\n        "use strict";\n\n        var addToUnscopables = __webpack_require__("nGyu");\n\n        var step = __webpack_require__("1TsA");\n\n        var Iterators = __webpack_require__("hPIQ");\n\n        var toIObject = __webpack_require__("aCFj"); // 22.1.3.4 Array.prototype.entries()\n        // 22.1.3.13 Array.prototype.keys()\n        // 22.1.3.29 Array.prototype.values()\n        // 22.1.3.30 Array.prototype[@@iterator]()\n\n\n        module.exports = __webpack_require__("Afnz")(Array, \'Array\', function (iterated, kind) {\n          this._t = toIObject(iterated); // target\n\n          this._i = 0; // next index\n\n          this._k = kind; // kind\n          // 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n        }, function () {\n          var O = this._t;\n          var kind = this._k;\n          var index = this._i++;\n\n          if (!O || index >= O.length) {\n            this._t = undefined;\n            return step(1);\n          }\n\n          if (kind == \'keys\') return step(0, index);\n          if (kind == \'values\') return step(0, O[index]);\n          return step(0, [index, O[index]]);\n        }, \'values\'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\n        Iterators.Arguments = Iterators.Array;\n        addToUnscopables(\'keys\');\n        addToUnscopables(\'values\');\n        addToUnscopables(\'entries\');\n        /***/\n      },\n\n      /***/\n      "zhAb":\n      /***/\n      function (module, exports, __webpack_require__) {\n        var has = __webpack_require__("aagx");\n\n        var toIObject = __webpack_require__("aCFj");\n\n        var arrayIndexOf = __webpack_require__("w2a5")(false);\n\n        var IE_PROTO = __webpack_require__("YTvA")(\'IE_PROTO\');\n\n        module.exports = function (object, names) {\n          var O = toIObject(object);\n          var i = 0;\n          var result = [];\n          var key;\n\n          for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don\'t enum bug & hidden keys\n\n\n          while (names.length > i) if (has(O, key = names[i++])) {\n            ~arrayIndexOf(result, key) || result.push(key);\n          }\n\n          return result;\n        };\n        /***/\n\n      }\n      /******/\n\n    })["default"]\n  );\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbj80N2M4Iiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvd2VicGFjay9ib290c3RyYXA/MDdhMiIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanM/YWJmZiIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL3NyYy9jb21wb25lbnRzL3Z1ZS1kaWFsb2ctZHJhZy52dWU/MzA2ZiIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL3NyYy9jb21wb25lbnRzL3Z1ZS1kaWFsb2ctZHJhZy52dWU/YmE2MCIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL3NyYy9jb21wb25lbnRzL3Z1ZS1kaWFsb2ctZHJhZy52dWU/ZDA5ZSIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanM/NzFmMiIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9AdnVlL2NsaS1zZXJ2aWNlL2xpYi9jb21tYW5kcy9idWlsZC9lbnRyeS1saWIuanM/NTM2MiIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcz9hY2ViIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzPzEwOGYiLCJ3ZWJwYWNrOi8vL3Z1ZS1kaWFsb2ctZHJhZy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanM/ZjE5MCIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanM/YzY2MiIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanM/N2Q3NyIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzPzQ5ZTMiLCJ3ZWJwYWNrOi8vL3Z1ZS1kaWFsb2ctZHJhZy9zcmMvY29tcG9uZW50cy92dWUtZGlhbG9nLWRyYWcudnVlPzBhZDgiLCJ3ZWJwYWNrOi8vL3Z1ZS1kaWFsb2ctZHJhZy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcz85YTdlIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanM/MzE5YyIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzPzg2NTciLCJ3ZWJwYWNrOi8vL3Z1ZS1kaWFsb2ctZHJhZy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzPzVkYWQiLCJ3ZWJwYWNrOi8vL3Z1ZS1kaWFsb2ctZHJhZy9ub2RlX21vZHVsZXMvQHZ1ZS9jbGktc2VydmljZS9saWIvY29tbWFuZHMvYnVpbGQvc2V0UHVibGljUGF0aC5qcz8xYmEyIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcz80MTAwIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanM/MTViMSIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcz9lMjZjIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanM/Yjg2NyIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanM/N2YyOSIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanM/Zjk3MSIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcz9hYjRjIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcz81NGU0Iiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcz9lODVhIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcz81NGNlIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qcz8yZmFhIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanM/MTkzZiIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanM/ZDZhNiIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanM/NTgyNyIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcz9hYTE5Iiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcz81MWJkIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzP2FkNzkiLCJ3ZWJwYWNrOi8vL3Z1ZS1kaWFsb2ctZHJhZy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanM/NGMxMyIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanM/YTNlNCIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanM/ZDU5MCIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGEuanM/ZTNkNyIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanM/MGZkYSIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcz9kNjkyIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzP2ZiZGIiLCJ3ZWJwYWNrOi8vL3Z1ZS1kaWFsb2ctZHJhZy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcz9kYzc3Iiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzP2I3N2UiLCJ3ZWJwYWNrOi8vL3Z1ZS1kaWFsb2ctZHJhZy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanM/ZmNhMCIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzPzA1MDQiLCJ3ZWJwYWNrOi8vL3Z1ZS1kaWFsb2ctZHJhZy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcz8wOTE1Iiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcz9iMWVjIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzP2Q1MGYiLCJ3ZWJwYWNrOi8vL3Z1ZS1kaWFsb2ctZHJhZy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanM/ZTQxNyIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcz9hYWZhIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanM/MTU5YSIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcz84MjBhIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzP2U1YzEiLCJ3ZWJwYWNrOi8vL3Z1ZS1kaWFsb2ctZHJhZy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanM/MjE5OCIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzP2ZlYTEiLCJ3ZWJwYWNrOi8vL3Z1ZS1kaWFsb2ctZHJhZy9zcmMvY29tcG9uZW50cy92dWUtZGlhbG9nLWRyYWcudnVlP2QzM2QiLCJ3ZWJwYWNrOi8vL3Z1ZS1kaWFsb2ctZHJhZy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanM/YzNlYiIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcz8yODFmIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcz85ZTNmIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanM/NzBjMCIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzPzc0NzIiLCJ3ZWJwYWNrOi8vL3Z1ZS1kaWFsb2ctZHJhZy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanM/ODNkNiIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcz8yZGZiIiwid2VicGFjazovLy92dWUtZGlhbG9nLWRyYWcvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanM/Mzc2OSIsIndlYnBhY2s6Ly8vdnVlLWRpYWxvZy1kcmFnL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzP2EwOGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDQSxVQUNBLDJCQURBLEtBRUEsRUFLQTtBQUNDLENBVEQsRUFTQyx5Q0FURCxFQVNDO0VBQ0Q7Ozs7O01DVkE7TUFBQTs7TUFDQTtNQUFB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QUNBO1VBQ0E7UUFDQSxDQUhBOzs7Ozs7Ozs7UUNEQTtRQUNBOztRQUNBO1VBQ0E7UUFDQSxDQUZBOzs7Ozs7Ozs7OztRQ0RBOztRQUNBOztRQUNBOztRQUNBLDRDLENBRUE7UUFDQTtRQUNBO1FBQ0E7OztRQUNBO1VBQ0EsOEJBREEsQ0FDZ0M7O1VBQ2hDLFlBRkEsQ0FFYzs7VUFDZCxlQUhBLENBR2lCO1VBQ2pCO1FBQ0MsQ0FMRCxFQUtDO1VBQ0Q7VUFDQTtVQUNBOztVQUNBO1lBQ0E7WUFDQTtVQUNBOztVQUNBO1VBQ0E7VUFDQTtRQUNDLENBaEJELEVBZ0JDLFFBaEJELEUsQ0FrQkE7O1FBQ0E7UUFFQTtRQUNBO1FBQ0E7Ozs7Ozs7O1FDakNBOztRQUNBOztRQUNBOztRQUNBOztRQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBQ0Esb0VBTEEsQ0FNQTs7O1VBQ0E7WUFDQTtVQUNBOztVQUNBO1FBQ0EsQ0FYQTs7Ozs7OztFbkVLQTtDQVZBIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widnVlLWRpYWxvZy1kcmFnXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInZ1ZS1kaWFsb2ctZHJhZ1wiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIreFVpXCIpO1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImRpYWxvZy1kcmFnXCIsY2xhc3M6KCFfdm0uZHJhZykgPyBcImZpeGVkXCI6XCJcIixzdHlsZTooX3ZtLmRpYWxvZ1N0eWxlKSxhdHRyczp7XCJpZFwiOl92bS5pZCxcImRyYWdnYWJsZVwiOl92bS5kcmFnfSxvbjp7XCJtb3VzZWRvd25cIjpfdm0ubW91c2VEb3duLFwidG91Y2hzdGFydFwiOmZ1bmN0aW9uKCRldmVudCl7JGV2ZW50LnByZXZlbnREZWZhdWx0KCk7cmV0dXJuIF92bS50b3VjaFN0YXJ0KCRldmVudCl9LFwiJnRvdWNobW92ZVwiOmZ1bmN0aW9uKCRldmVudCl7cmV0dXJuIF92bS50b3VjaE1vdmUoJGV2ZW50KX0sXCJ0b3VjaGVuZFwiOmZ1bmN0aW9uKCRldmVudCl7JGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO3JldHVybiBfdm0udG91Y2hFbmQoJGV2ZW50KX19fSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiZGlhbG9nLWhlYWRlclwiLG9uOntcImRyYWdzdGFydFwiOmZ1bmN0aW9uKCRldmVudCl7JGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO319fSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidGl0bGVcIn0sW192bS5fdChcInRpdGxlXCIsWyhfdm0udGl0bGUpP19jKCdzcGFuJyxbX3ZtLl92KF92bS5fcyhfdm0udGl0bGUpKV0pOl9jKCdzcGFuJyxbX3ZtLl92KFwiwqBcIildKV0pXSwyKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJidXR0b25zXCJ9LFsoX3ZtLmJ1dHRvblBpbik/X2MoJ2J1dHRvbicse3N0YXRpY0NsYXNzOlwicGluXCIsb246e1wiY2xpY2tcIjpfdm0uc2V0RHJhZyxcInRvdWNoc3RhcnRcIjpfdm0uc2V0RHJhZ319LFsoX3ZtLmRyYWcpP192bS5fdChcImJ1dHRvbi1waW5cIik6X3ZtLl9lKCksKCFfdm0uZHJhZyk/X3ZtLl90KFwiYnV0dG9uLXBpbm5lZFwiLFsoIV92bS5kcmFnKT9fdm0uX3QoXCJidXR0b24tcGluXCIpOl92bS5fZSgpXSk6X3ZtLl9lKCldLDIpOl92bS5fZSgpLChfdm0uYnV0dG9uQ2xvc2UpP19jKCdidXR0b24nLHtzdGF0aWNDbGFzczpcImNsb3NlXCIsb246e1wiY2xpY2tcIjpmdW5jdGlvbigkZXZlbnQpeyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtyZXR1cm4gX3ZtLmNsb3NlKCRldmVudCl9LFwiJnRvdWNoc3RhcnRcIjpmdW5jdGlvbigkZXZlbnQpe3JldHVybiBfdm0uY2xvc2UoJGV2ZW50KX19fSxbX3ZtLl90KFwiYnV0dG9uLWNsb3NlXCIpXSwyKTpfdm0uX2UoKV0pXSksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiZGlhbG9nLWJvZHlcIixvbjp7XCJkcmFnc3RhcnRcIjpmdW5jdGlvbigkZXZlbnQpeyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTt9fX0sW192bS5fdChcImRlZmF1bHRcIixbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiYmxhbmstYm9keVwifSldKV0sMildKX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiPHRlbXBsYXRlIGxhbmc9XCJwdWdcIj5cbiAgLmRpYWxvZy1kcmFnKFxuICAgIDppZD0naWQnXG4gICAgOmRyYWdnYWJsZT0nZHJhZydcbiAgICA6Y2xhc3M9JyghZHJhZykgPyBcImZpeGVkXCI6XCJcIidcbiAgICA6c3R5bGU9J2RpYWxvZ1N0eWxlJ1xuICAgIEBtb3VzZWRvd249J21vdXNlRG93bidcbiAgICBAdG91Y2hzdGFydC5wcmV2ZW50PSd0b3VjaFN0YXJ0J1xuICAgIEB0b3VjaG1vdmUucGFzc2l2ZT0ndG91Y2hNb3ZlJ1xuICAgIEB0b3VjaGVuZC5zdG9wPSd0b3VjaEVuZCdcbiAgICApXG4gICAgLmRpYWxvZy1oZWFkZXIoQGRyYWdzdGFydC5zdG9wPScnKVxuICAgICAgLnRpdGxlXG4gICAgICAgIC8vLSBUaXRsZSBzbG90XG4gICAgICAgIHNsb3QobmFtZT0ndGl0bGUnKVxuICAgICAgICAgIC8vLSByZW5kZXIgdGl0bGUgcHJvcCwgaWYgdGl0bGUgc2xvdCBpcyBlbXB0eVxuICAgICAgICAgIHNwYW4odi1pZj0ndGl0bGUnKSB7e3RpdGxlfX1cbiAgICAgICAgICBzcGFuKHYtZWxzZSkgJm5ic3BcbiAgICAgIC5idXR0b25zXG4gICAgICAgIC8vLSBQaW4gQnV0dG9uXG4gICAgICAgIGJ1dHRvbi5waW4odi1pZj0nYnV0dG9uUGluJyBAY2xpY2s9J3NldERyYWcnIEB0b3VjaHN0YXJ0PSdzZXREcmFnJylcbiAgICAgICAgICAvLy0gQnV0dG9uIHBpbiBzbG90XG4gICAgICAgICAgc2xvdChuYW1lPVwiYnV0dG9uLXBpblwiIHYtaWY9J2RyYWcnKVxuICAgICAgICAgIC8vLSBCdXRvbiBwaW5uZWQgc2xvdFxuICAgICAgICAgIHNsb3QobmFtZT1cImJ1dHRvbi1waW5uZWRcIiB2LWlmPSchZHJhZycpXG4gICAgICAgICAgICAgLy8tIFJlbmRlciBidXR0b24tcGluIHNsb3QgaWYgYnV0dG9uLXBpbm5lZCBzbG90IGlzIGVtcHR5XG4gICAgICAgICAgICAgc2xvdChuYW1lPVwiYnV0dG9uLXBpblwiIHYtaWY9JyFkcmFnJylcbiAgICAgICAgLy8tIENsb3NlIEJ1dHRvblxuICAgICAgICBidXR0b24uY2xvc2Uodi1pZj0nYnV0dG9uQ2xvc2UnIEBjbGljay5zdG9wPSdjbG9zZScgQHRvdWNoc3RhcnQucGFzc2l2ZT0nY2xvc2UnKVxuICAgICAgICAgIHNsb3QobmFtZT1cImJ1dHRvbi1jbG9zZVwiKVxuICAgIC8vLSBkZWZhdWx0IHNsb3RcbiAgICAuZGlhbG9nLWJvZHkoQGRyYWdzdGFydC5zdG9wPScnKVxuICAgICAgc2xvdFxuICAgICAgICAuYmxhbmstYm9keVxuXG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2RpYWxvZy1kcmFnJyxcbiAgcHJvcHM6IFsnaWQnLCAndGl0bGUnLCAnb3B0aW9ucycsICdldmVudENiJ10sXG4gIGRhdGEgKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIHpJbmRleDogMCxcbiAgICAgIG9mZnNldDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJ1dHRvbkNsb3NlOiB0cnVlLFxuICAgICAgYnV0dG9uUGluOiB0cnVlLFxuICAgICAgZHJhZ0VuYWJsZWQ6IHRydWUsXG4gICAgICBkcmFnOiB0cnVlLFxuICAgICAgdG91Y2g6IG51bGwsXG4gICAgICBvdmVyRXZlbnQ6IG51bGwsXG4gICAgICBjZW50ZXJlZDogZmFsc2UsXG4gICAgICBkcm9wRW5hYmxlZDogdHJ1ZSxcbiAgICAgIGRyYWdDdXJzb3I6ICdkZWZhdWx0JyxcbiAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgIGNsaWNrQnV0dG9uOiBmYWxzZSxcbiAgICAgIHBYOiAwLFxuICAgICAgcFk6IDAsXG4gICAgICBhdmFpbGFibGVPcHRpb25zOiBbXG4gICAgICAgICdsZWZ0JyxcbiAgICAgICAgJ3RvcCcsXG4gICAgICAgICd3aWR0aCcsXG4gICAgICAgICdoZWlnaHQnLFxuICAgICAgICAnYnV0dG9uUGluJyxcbiAgICAgICAgJ2J1dHRvbkNsb3NlJyxcbiAgICAgICAgJ2NlbnRlcmVkJyxcbiAgICAgICAgJ2Ryb3BFbmFibGVkJyxcbiAgICAgICAgJ2RyYWdDdXJzb3InLFxuICAgICAgICAnekluZGV4J1xuICAgICAgXVxuICAgIH1cbiAgfSxcbiAgY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5zZXRPcHRpb25zKHRoaXMub3B0aW9ucylcbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgaWYgKHRoaXMuZHJvcEVuYWJsZWQpIHtcbiAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuZHJhZ1N0YXJ0KVxuICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIHRoaXMuZHJhZ0VuZClcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXMuZHJhZ092ZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlLCB7IHBhc3NpdmU6IHRydWUgfSlcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNlVXApXG4gICAgfVxuICAgIGlmICh0aGlzLmNlbnRlcmVkKSB7XG4gICAgICBsZXQgdm0gPSB0aGlzXG4gICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHZtLmNlbnRlcigpXG4gICAgICAgIHZtLmVtaXQoJ2xvYWQnKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdsb2FkJylcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xuICAgIGlmICh0aGlzLmRyb3BFbmFibGVkKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzLmRyYWdPdmVyKVxuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlTW92ZSlcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNlVXApXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIG9wdGlvbnMgKG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLnNldE9wdGlvbnMobmV3VmFsdWUpXG4gICAgICBpZiAobmV3VmFsdWUuY2VudGVyZWQpIHRoaXMuY2VudGVyKClcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgZGlhbG9nU3R5bGUgKCkge1xuICAgICAgbGV0IHN0eWxlID0geyBsZWZ0OiB0aGlzLmxlZnQgKyAncHgnLCB0b3A6IHRoaXMudG9wICsgJ3B4JyB9XG4gICAgICBpZiAodGhpcy53aWR0aCkgc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4J1xuICAgICAgaWYgKHRoaXMuaGVpZ2h0KSBzdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCdcbiAgICAgIGlmICh0aGlzLnpJbmRleCkgc3R5bGUuekluZGV4ID0gdGhpcy56SW5kZXhcbiAgICAgIGlmICh0aGlzLmRyYWcpIHtcbiAgICAgICAgc3R5bGVbJ3VzZXItc2VsZWN0J10gPSAnbm9uZSdcbiAgICAgICAgc3R5bGUuY3Vyc29yID0gdGhpcy5kcmFnQ3Vyc29yXG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGVcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBtb3VzZU91dCAoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5kcmFnRW5hYmxlZCAmJiB0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgIHRoaXMubW92ZShldmVudClcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyIChldmVudCkge1xuICAgICAgaWYgKHRoaXMuZHJvcEVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5vdmVyRXZlbnQgPSBldmVudFxuICAgICAgICB0aGlzLmVtaXQoJ21vdmUnKVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91c2VPdmVyIChldmVudCkge1xuICAgICAgc2V0VGltZW91dCh0aGlzLm1vdXNlTW92ZShldmVudCksIDUwKVxuICAgIH0sXG4gICAgY2xvc2UgKCkge1xuICAgICAgdGhpcy5jbGlja0J1dHRvbiA9ICdjbG9zZSdcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKVxuICAgIH0sXG4gICAgc2V0RHJhZyAoKSB7XG4gICAgICBpZiAodGhpcy5kcmFnRW5hYmxlZCkge1xuICAgICAgICB0aGlzLmRyYWcgPSAhdGhpcy5kcmFnXG4gICAgICAgIHRoaXMuZW1pdCgncGluJylcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdTdGFydCAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICBpZiAodGhpcy5kcmFnICYmIHRoaXMuZHJhZ0VuYWJsZWQgJiYgdGhpcy5kcm9wRW5hYmxlZCkge1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YSgndGV4dCcsIGV2ZW50LnRhcmdldC5pZClcbiAgICAgICAgdGhpcy5zdGFydE1vdmUoZXZlbnQpXG4gICAgICB9XG4gICAgfSxcbiAgICBkcmFnRW5kIChldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgaWYgKHRoaXMuZHJvcEVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlKGV2ZW50KVxuICAgICAgICB0aGlzLmVtaXQoJ2RyYWctZW5kJylcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdXNlRG93biAoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5kcmFnZ2luZykgdGhpcy5mb2N1cygpXG4gICAgICBpZiAoIXRoaXMuZHJvcEVuYWJsZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZykgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB0aGlzLnN0YXJ0TW92ZShldmVudClcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdXNlTW92ZSAoZXZlbnQpIHtcbiAgICAgIC8vIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIGlmICghdGhpcy5kcm9wRW5hYmxlZCAmJiB0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZykge1xuICAgICAgICAvLyBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMubW92ZShldmVudCksIDUwKVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91c2VVcCAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIGlmICghdGhpcy5kcm9wRW5hYmxlZCkge1xuICAgICAgICB0aGlzLnN0b3BNb3ZlKClcbiAgICAgICAgdGhpcy5lbWl0KCdkcmFnRW5kJylcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvdWNoU3RhcnQgKGV2ZW50KSB7XG4gICAgICB0aGlzLmVtaXQoJ2ZvY3VzJylcbiAgICAgIHRoaXMuc3RhcnRNb3ZlKGV2ZW50LnRhcmdldFRvdWNoZXNbMF0pXG4gICAgfSxcbiAgICB0b3VjaE1vdmUgKGV2ZW50KSB7XG4gICAgICB0aGlzLm1vdmUoZXZlbnQudGFyZ2V0VG91Y2hlc1swXSlcbiAgICB9LFxuICAgIHRvdWNoRW5kIChldmVudCkge1xuICAgICAgdGhpcy5lbWl0KCdkcmFnRW5kJylcbiAgICAgIHRoaXMuc3RvcE1vdmUoKVxuICAgIH0sXG4gICAgc3RvcE1vdmUgKCkge1xuICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlXG4gICAgICB0aGlzLnBYID0gMFxuICAgICAgdGhpcy5wWSA9IDBcbiAgICB9LFxuICAgIGVtaXQgKGV2ZW50TmFtZSwgZGF0YSkge1xuICAgICAgZGF0YSA9IGRhdGEgfHwge1xuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgbGVmdDogdGhpcy5sZWZ0LFxuICAgICAgICB0b3A6IHRoaXMudG9wLFxuICAgICAgICB4OiB0aGlzLmxlZnQsXG4gICAgICAgIHk6IHRoaXMudG9wLFxuICAgICAgICB6OiB0aGlzLnpJbmRleCxcbiAgICAgICAgcGlubmVkOiAhdGhpcy5kcmFnLFxuICAgICAgICB3aWR0aDogdGhpcy4kZWwuY2xpZW50V2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy4kZWwuY2xpZW50SGVpZ2h0XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ldmVudENiKSB7XG4gICAgICAgIGxldCBlZiA9IHRoaXMuZXZlbnRDYlxuICAgICAgICBpZiAoZWYgJiYgdHlwZW9mIChlZikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkYXRhID0gZWYoZGF0YSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy4kZW1pdChldmVudE5hbWUsIGRhdGEpXG4gICAgfSxcbiAgICBtb3ZlIChldmVudCkge1xuICAgICAgaWYgKHRoaXMuZHJhZyAmJiB0aGlzLmRyYWdFbmFibGVkKSB7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRYID09PSAwKSBldmVudCA9IHRoaXMub3ZlckV2ZW50IC8vIGZvciBmaXJlZm94XG4gICAgICAgIGlmIChldmVudCAmJiBldmVudC5jbGllbnRYICYmIGV2ZW50LmNsaWVudFkpIHtcbiAgICAgICAgICBsZXQgeCA9IGV2ZW50LmNsaWVudFhcbiAgICAgICAgICBsZXQgeSA9IGV2ZW50LmNsaWVudFlcbiAgICAgICAgICB0aGlzLmxlZnQgPSAoeCArIHRoaXMub2Zmc2V0LngpXG4gICAgICAgICAgdGhpcy50b3AgPSAoeSArIHRoaXMub2Zmc2V0LnkpXG4gICAgICAgICAgdGhpcy5kcmFnZ2luZysrXG4gICAgICAgICAgdGhpcy5lbWl0KCdtb3ZlJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2xlYXJTZWxlY3Rpb24gKCkge1xuICAgICAgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgICAgICBkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKVxuICAgICAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKVxuICAgICAgfVxuICAgIH0sXG4gICAgc3RhcnRNb3ZlIChldmVudCkge1xuICAgICAgbGV0IHggPSB0aGlzLmxlZnQgLSBldmVudC5jbGllbnRYXG4gICAgICBsZXQgeSA9IHRoaXMudG9wIC0gZXZlbnQuY2xpZW50WVxuICAgICAgdGhpcy5vZmZzZXQgPSB7IHgsIHkgfVxuICAgICAgdGhpcy5kcmFnZ2luZyA9IDFcbiAgICAgIHRoaXMuZW1pdCgnZHJhZy1zdGFydCcpXG4gICAgfSxcbiAgICBmb2N1cyAoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLmRyYWcpIHRoaXMuY2xlYXJTZWxlY3Rpb24oKVxuICAgICAgbGV0IHZtID0gdGhpc1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghdm0uY2xpY2tCdXR0b24pIHZtLmVtaXQoJ2ZvY3VzJylcbiAgICAgIH0sIDIwMClcbiAgICB9LFxuICAgIGNlbnRlciAoKSB7XG4gICAgICBsZXQgd3csIHdoXG4gICAgICBpZiAodGhpcy5jZW50ZXJlZCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgd3cgPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgICB3aCA9IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2VudGVyZWQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICAgICAgbGV0IGJvZHkgPSBkb2N1bWVudC5ib2R5XG4gICAgICAgIHd3ID0gYm9keS5jbGllbnRXaWR0aCArIGJvZHkuc2Nyb2xsTGVmdFxuICAgICAgICB3aCA9IGJvZHkuY2xpZW50SGVpZ2h0ICsgYm9keS5zY3JvbGxUb3BcbiAgICAgIH1cbiAgICAgIHd3ID0gd3cgfHwgdGhpcy4kcGFyZW50LiRlbC5jbGllbnRXaWR0aFxuICAgICAgd2ggPSB3aCB8fCB0aGlzLiRwYXJlbnQuJGVsLmNsaWVudEhlaWdodFxuICAgICAgdGhpcy5sZWZ0ID0gKHd3IC8gMikgLSAodGhpcy4kZWwuY2xpZW50V2lkdGggLyAyKVxuICAgICAgdGhpcy50b3AgPSAod2ggLyAyKSAtICh0aGlzLiRlbC5jbGllbnRIZWlnaHQgLyAyKVxuICAgIH0sXG4gICAgc2V0T3B0aW9ucyAob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMueCkgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy54XG4gICAgICAgIGlmIChvcHRpb25zLnkpIG9wdGlvbnMudG9wID0gb3B0aW9ucy55XG4gICAgICAgIGlmIChvcHRpb25zLnopIG9wdGlvbnMuekluZGV4ID0gb3B0aW9ucy56XG4gICAgICAgIHRoaXMuZHJhZyA9ICh0aGlzLm9wdGlvbnMucGlubmVkKSA/IGZhbHNlIDogdGhpcy5kcmFnXG4gICAgICAgIC8vIGF2YWlsYWJsZSBvcHRpb25zXG4gICAgICAgIGxldCBvcHMgPSB0aGlzLmF2YWlsYWJsZU9wdGlvbnNcbiAgICAgICAgZm9yIChsZXQgb3Agb2Ygb3BzKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcCkpIHtcbiAgICAgICAgICAgIHRoaXMuJHNldCh0aGlzLCBvcCwgdGhpcy5vcHRpb25zW29wXSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cInN0eWx1c1wiPlxuICBAaW1wb3J0ICcuLi9saWIvc3R5bC92YXJzLnN0eWwnXG5cbiAgLmRpYWxvZy1kcmFnXG4gICAgei1pbmRleCAxMDFcbiAgICB3aWR0aCBhdXRvXG4gICAgcG9zaXRpb24gYWJzb2x1dGVcbiAgICBib3JkZXIgJGNvbG9yIHNvbGlkIDJweFxuICAgIGJhY2tncm91bmQtY29sb3Igd2hpdGVcbiAgICBib3gtc2hhZG93ICRzaFxuICAgIGhlaWdodCBhdXRvXG4gICAgYW5pbWF0aW9uLWR1cmF0aW9uIDAuMnNcbiAgICBhbmltYXRpb24tbmFtZSBkaWFsb2ctYW5pbVxuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24gZWFzZS1pblxuXG4gICAgLmRpYWxvZy1oZWFkZXJcbiAgICAgIHBvc2l0aW9uIHJlbGF0aXZlXG4gICAgICB0ZXh0LWFsaWduIGxlZnRcbiAgICAgIHBhZGRpbmcgMC4yNWVtIDNlbSAwLjI1ZW0gMWVtXG4gICAgICB3aWR0aCBhdXRvXG4gICAgICBmb250LXNpemUgMC45ZW1cbiAgICAgIGJhY2tncm91bmQtY29sb3IgJGNvbG9yXG4gICAgICBjb2xvciB3aGl0ZVxuXG4gICAgICAuYnV0dG9uc1xuICAgICAgICBwb3NpdGlvbiBhYnNvbHV0ZVxuICAgICAgICByaWdodCAwXG4gICAgICAgIHRvcCAwXG4gICAgICAgIG1hcmdpbiAwLjI1ZW0gMC4yNWVtIDAgMFxuICAgICAgICB6LWluZGV4IDEwNVxuXG4gICAgICBidXR0b24uY2xvc2UsIGJ1dHRvbi5waW5cbiAgICAgICAgYmFja2dyb3VuZCB0cmFuc3BhcmVudFxuICAgICAgICBib3gtc2hhZG93IG5vbmVcbiAgICAgICAgYm9yZGVyIG5vbmVcbiAgICAgICAgY29sb3Igd2hpdGVcblxuICAgICAgICAmOmhvdmVyXG4gICAgICAgICAgY29sb3IgJGNvbG9yMlxuXG4gICAgICBidXR0b24uY2xvc2VcbiAgICAgICAgJjphZnRlclxuICAgICAgICAgIGNvbnRlbnQgJ+KclidcblxuICAgICAgYnV0dG9uLnBpblxuICAgICAgICAmOmFmdGVyXG4gICAgICAgICAgY29udGVudCAn8J+UkydcblxuICAgIC5kaWFsb2ctYm9keVxuICAgICAgcGFkZGluZyAxZW1cblxuICAuZGlhbG9nLWRyYWcuZml4ZWRcbiAgICBib3JkZXItY29sb3IgJGNvbG9yMlxuICAgIHVzZXItc2VsZWN0IGF1dG9cblxuICAgIGJ1dHRvbi5waW5cbiAgICAgIGZvbnQtd2VpZ2h0IGJvbGRcblxuICAgICAgJjphZnRlclxuICAgICAgICBjb250ZW50ICfwn5SSJ1xuXG4gIEBrZXlmcmFtZXMgZGlhbG9nLWFuaW1cbiAgICAwJVxuICAgICAgb3BhY2l0eSAwXG4gICAgICB0cmFuc2Zvcm0gc2NhbGVYKDAuMSlcblxuICAgIDUwJVxuICAgICAgdHJhbnNmb3JtIHJvdGF0ZSgxZGVnKVxuXG4gICAgMTAwJVxuICAgICAgb3BhY2l0eSAxXG48L3N0eWxlPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEyLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi92dWUtZGlhbG9nLWRyYWcudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3Z1ZS1kaWFsb2ctZHJhZy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHNjcmlwdEV4cG9ydHMsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciwgLyogc2VydmVyIG9ubHkgKi9cbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cbikge1xuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gc2hhZG93TW9kZVxuICAgICAgPyBmdW5jdGlvbiAoKSB7IGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIHRoaXMuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdCkgfVxuICAgICAgOiBpbmplY3RTdHlsZXNcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG5vcm1hbGl6ZXJcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuIiwiaW1wb3J0ICcuL3NldFB1YmxpY1BhdGgnXG5pbXBvcnQgbW9kIGZyb20gJ35lbnRyeSdcbmV4cG9ydCBkZWZhdWx0IG1vZFxuZXhwb3J0ICogZnJvbSAnfmVudHJ5J1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSBnZXRLZXlzKGl0KTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmIChnZXRTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KTtcbiAgICB2YXIgaXNFbnVtID0gcElFLmY7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKHN5bWJvbHMubGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG4iLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsIi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBpbnRvIGxpYi93YyBjbGllbnQgYnVuZGxlcy5cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHZhciBpXG4gIGlmICgoaSA9IHdpbmRvdy5kb2N1bWVudC5jdXJyZW50U2NyaXB0KSAmJiAoaSA9IGkuc3JjLm1hdGNoKC8oLitcXC8pW14vXStcXC5qcyQvKSkpIHtcbiAgICBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyA9IGlbMV0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB9XG59XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBTUkMgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSBGdW5jdGlvbltUT19TVFJJTkddO1xudmFyIFRQTCA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIGlmICghc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH0gZWxzZSBpZiAoT1trZXldKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiByZXF1aXJlKCcuL19saWJyYXJ5JykgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pO1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZiAodGFyZ2V0KSByZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZiAoZXhwb3J0c1trZXldICE9IG91dCkgaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYgKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KSBleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjcnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgTUVUQSA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIHdrc0RlZmluZSA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcbiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMTEtb25lT2YtMS0xIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTExLW9uZU9mLTEtMiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bHVzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xMS1vbmVPZi0xLTMhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi92dWUtZGlhbG9nLWRyYWcudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1zdHlsdXMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvbG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTExLW9uZU9mLTEtMSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0xMS1vbmVPZi0xLTIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWx1cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMTEtb25lT2YtMS0zIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vdnVlLWRpYWxvZy1kcmFnLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9c3R5bHVzJlwiIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG4iLCJ2YXIgJGl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cbiIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n')},,,,,function(module,__webpack_exports__,__webpack_require__){"use strict";eval("const LoadScript = {\n  install: function (Vue) {\n    Vue.loadScript = Vue.prototype.$loadScript = function (src) {\n      // eslint-disable-line no-param-reassign\n      return new Promise(function (resolve, reject) {\n        let shouldAppend = false;\n        let el = document.querySelector('script[src=\"' + src + '\"]');\n\n        if (!el) {\n          el = document.createElement('script');\n          el.type = 'text/javascript';\n          el.async = true;\n          el.src = src;\n          shouldAppend = true;\n        } else if (el.hasAttribute('data-loaded')) {\n          resolve(el);\n          return;\n        }\n\n        el.addEventListener('error', reject);\n        el.addEventListener('abort', reject);\n        el.addEventListener('load', function loadScriptHandler() {\n          el.setAttribute('data-loaded', true);\n          resolve(el);\n        });\n        if (shouldAppend) document.head.appendChild(el);\n      });\n    };\n\n    Vue.unloadScript = Vue.prototype.$unloadScript = function (src) {\n      // eslint-disable-line no-param-reassign\n      return new Promise(function (resolve, reject) {\n        const el = document.querySelector('script[src=\"' + src + '\"]');\n\n        if (!el) {\n          reject();\n          return;\n        }\n\n        document.head.removeChild(el);\n        resolve();\n      });\n    };\n  }\n};\n/* harmony default export */ __webpack_exports__[\"a\"] = (LoadScript);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXBsdWdpbi1sb2FkLXNjcmlwdC9pbmRleC5qcz82N2IwIl0sIm5hbWVzIjpbIkxvYWRTY3JpcHQiLCJpbnN0YWxsIiwiVnVlIiwibG9hZFNjcmlwdCIsInByb3RvdHlwZSIsIiRsb2FkU2NyaXB0Iiwic3JjIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzaG91bGRBcHBlbmQiLCJlbCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImNyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwiYXN5bmMiLCJoYXNBdHRyaWJ1dGUiLCJhZGRFdmVudExpc3RlbmVyIiwibG9hZFNjcmlwdEhhbmRsZXIiLCJzZXRBdHRyaWJ1dGUiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJ1bmxvYWRTY3JpcHQiLCIkdW5sb2FkU2NyaXB0IiwicmVtb3ZlQ2hpbGQiXSwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFVBQVUsR0FBRztFQUNqQkMsT0FBTyxFQUFFLFVBQVVDLEdBQVYsRUFBZTtJQUN0QkEsR0FBRyxDQUFDQyxVQUFKLEdBQWlCRCxHQUFHLENBQUNFLFNBQUosQ0FBY0MsV0FBZCxHQUE0QixVQUFVQyxHQUFWLEVBQWU7TUFBRTtNQUM1RCxPQUFPLElBQUlDLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CQyxNQUFuQixFQUEyQjtRQUM1QyxJQUFJQyxZQUFZLEdBQUcsS0FBbkI7UUFDQSxJQUFJQyxFQUFFLEdBQUdDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixpQkFBaUJQLEdBQWpCLEdBQXVCLElBQTlDLENBQVQ7O1FBQ0EsSUFBSSxDQUFDSyxFQUFMLEVBQVM7VUFDUEEsRUFBRSxHQUFHQyxRQUFRLENBQUNFLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBTDtVQUNBSCxFQUFFLENBQUNJLElBQUgsR0FBVSxpQkFBVjtVQUNBSixFQUFFLENBQUNLLEtBQUgsR0FBVyxJQUFYO1VBQ0FMLEVBQUUsQ0FBQ0wsR0FBSCxHQUFTQSxHQUFUO1VBQ0FJLFlBQVksR0FBRyxJQUFmO1FBQ0QsQ0FORCxNQU9LLElBQUlDLEVBQUUsQ0FBQ00sWUFBSCxDQUFnQixhQUFoQixDQUFKLEVBQW9DO1VBQ3ZDVCxPQUFPLENBQUNHLEVBQUQsQ0FBUDtVQUNBO1FBQ0Q7O1FBRURBLEVBQUUsQ0FBQ08sZ0JBQUgsQ0FBb0IsT0FBcEIsRUFBNkJULE1BQTdCO1FBQ0FFLEVBQUUsQ0FBQ08sZ0JBQUgsQ0FBb0IsT0FBcEIsRUFBNkJULE1BQTdCO1FBQ0FFLEVBQUUsQ0FBQ08sZ0JBQUgsQ0FBb0IsTUFBcEIsRUFBNEIsU0FBU0MsaUJBQVQsR0FBNkI7VUFDdkRSLEVBQUUsQ0FBQ1MsWUFBSCxDQUFnQixhQUFoQixFQUErQixJQUEvQjtVQUNBWixPQUFPLENBQUNHLEVBQUQsQ0FBUDtRQUNELENBSEQ7UUFLQSxJQUFJRCxZQUFKLEVBQWtCRSxRQUFRLENBQUNTLElBQVQsQ0FBY0MsV0FBZCxDQUEwQlgsRUFBMUI7TUFDbkIsQ0F2Qk0sQ0FBUDtJQXdCRCxDQXpCRDs7SUEyQkFULEdBQUcsQ0FBQ3FCLFlBQUosR0FBbUJyQixHQUFHLENBQUNFLFNBQUosQ0FBY29CLGFBQWQsR0FBOEIsVUFBVWxCLEdBQVYsRUFBZTtNQUFFO01BQ2hFLE9BQU8sSUFBSUMsT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJDLE1BQW5CLEVBQTJCO1FBQzVDLE1BQU1FLEVBQUUsR0FBR0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLGlCQUFpQlAsR0FBakIsR0FBdUIsSUFBOUMsQ0FBWDs7UUFFQSxJQUFJLENBQUNLLEVBQUwsRUFBUztVQUNQRixNQUFNO1VBQ047UUFDRDs7UUFFREcsUUFBUSxDQUFDUyxJQUFULENBQWNJLFdBQWQsQ0FBMEJkLEVBQTFCO1FBRUFILE9BQU87TUFDUixDQVhNLENBQVA7SUFZRCxDQWJEO0VBY0Q7QUEzQ2dCLENBQW5CO0FBOENlUixtRUFBZiIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IExvYWRTY3JpcHQgPSB7XG4gIGluc3RhbGw6IGZ1bmN0aW9uIChWdWUpIHtcbiAgICBWdWUubG9hZFNjcmlwdCA9IFZ1ZS5wcm90b3R5cGUuJGxvYWRTY3JpcHQgPSBmdW5jdGlvbiAoc3JjKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxldCBzaG91bGRBcHBlbmQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W3NyYz1cIicgKyBzcmMgKyAnXCJdJyk7XG4gICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgIGVsLnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgICBlbC5hc3luYyA9IHRydWU7XG4gICAgICAgICAgZWwuc3JjID0gc3JjO1xuICAgICAgICAgIHNob3VsZEFwcGVuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWwuaGFzQXR0cmlidXRlKCdkYXRhLWxvYWRlZCcpKSB7XG4gICAgICAgICAgcmVzb2x2ZShlbCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCByZWplY3QpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIHJlamVjdCk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiBsb2FkU2NyaXB0SGFuZGxlcigpIHtcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbG9hZGVkJywgdHJ1ZSk7XG4gICAgICAgICAgcmVzb2x2ZShlbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzaG91bGRBcHBlbmQpIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFZ1ZS51bmxvYWRTY3JpcHQgPSBWdWUucHJvdG90eXBlLiR1bmxvYWRTY3JpcHQgPSBmdW5jdGlvbiAoc3JjKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W3NyYz1cIicgKyBzcmMgKyAnXCJdJyk7XG5cbiAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoZWwpO1xuXG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBMb2FkU2NyaXB0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n")},,,,function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(30);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(5).default\nvar update = add(\"52f15586\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzP2U1ZWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsRUFBOEM7QUFDcEU7QUFDQSw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLENBQWdEO0FBQ2xFLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9sZWFmbGV0LmNzc1wiKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjUyZjE1NTg2XCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbGVhZmxldC5jc3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2xlYWZsZXQuY3NzXCIpO1xuICAgICBpZihuZXdDb250ZW50Ll9fZXNNb2R1bGUpIG5ld0NvbnRlbnQgPSBuZXdDb250ZW50LmRlZmF1bHQ7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n")},function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(4);\nvar ___CSS_LOADER_GET_URL_IMPORT___ = __webpack_require__(31);\nvar ___CSS_LOADER_URL_IMPORT_0___ = __webpack_require__(32);\nvar ___CSS_LOADER_URL_IMPORT_1___ = __webpack_require__(33);\nvar ___CSS_LOADER_URL_IMPORT_2___ = __webpack_require__(34);\nexports = ___CSS_LOADER_API_IMPORT___(false);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);\n// Module\nexports.push([module.i, "/* required styles */\\r\\n\\r\\n.leaflet-pane,\\r\\n.leaflet-tile,\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow,\\r\\n.leaflet-tile-container,\\r\\n.leaflet-pane > svg,\\r\\n.leaflet-pane > canvas,\\r\\n.leaflet-zoom-box,\\r\\n.leaflet-image-layer,\\r\\n.leaflet-layer {\\r\\n\\tposition: absolute;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n\\t}\\r\\n.leaflet-container {\\r\\n\\toverflow: hidden;\\r\\n\\t}\\r\\n.leaflet-tile,\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow {\\r\\n\\t-webkit-user-select: none;\\r\\n\\t   -moz-user-select: none;\\r\\n\\t        user-select: none;\\r\\n\\t  -webkit-user-drag: none;\\r\\n\\t}\\r\\n/* Prevents IE11 from highlighting tiles in blue */\\r\\n.leaflet-tile::selection {\\r\\n\\tbackground: transparent;\\r\\n}\\r\\n/* Safari renders non-retina tile on retina better with this, but Chrome is worse */\\r\\n.leaflet-safari .leaflet-tile {\\r\\n\\timage-rendering: -webkit-optimize-contrast;\\r\\n\\t}\\r\\n/* hack that prevents hw layers \\"stretching\\" when loading new tiles */\\r\\n.leaflet-safari .leaflet-tile-container {\\r\\n\\twidth: 1600px;\\r\\n\\theight: 1600px;\\r\\n\\t-webkit-transform-origin: 0 0;\\r\\n\\t}\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow {\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */\\r\\n/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */\\r\\n.leaflet-container .leaflet-overlay-pane svg,\\r\\n.leaflet-container .leaflet-marker-pane img,\\r\\n.leaflet-container .leaflet-shadow-pane img,\\r\\n.leaflet-container .leaflet-tile-pane img,\\r\\n.leaflet-container img.leaflet-image-layer,\\r\\n.leaflet-container .leaflet-tile {\\r\\n\\tmax-width: none !important;\\r\\n\\tmax-height: none !important;\\r\\n\\t}\\r\\n\\r\\n.leaflet-container.leaflet-touch-zoom {\\r\\n\\t-ms-touch-action: pan-x pan-y;\\r\\n\\ttouch-action: pan-x pan-y;\\r\\n\\t}\\r\\n.leaflet-container.leaflet-touch-drag {\\r\\n\\t-ms-touch-action: pinch-zoom;\\r\\n\\t/* Fallback for FF which doesn\'t support pinch-zoom */\\r\\n\\ttouch-action: none;\\r\\n\\ttouch-action: pinch-zoom;\\r\\n}\\r\\n.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {\\r\\n\\t-ms-touch-action: none;\\r\\n\\ttouch-action: none;\\r\\n}\\r\\n.leaflet-container {\\r\\n\\t-webkit-tap-highlight-color: transparent;\\r\\n}\\r\\n.leaflet-container a {\\r\\n\\t-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);\\r\\n}\\r\\n.leaflet-tile {\\r\\n\\tfilter: inherit;\\r\\n\\tvisibility: hidden;\\r\\n\\t}\\r\\n.leaflet-tile-loaded {\\r\\n\\tvisibility: inherit;\\r\\n\\t}\\r\\n.leaflet-zoom-box {\\r\\n\\twidth: 0;\\r\\n\\theight: 0;\\r\\n\\t-moz-box-sizing: border-box;\\r\\n\\t     box-sizing: border-box;\\r\\n\\tz-index: 800;\\r\\n\\t}\\r\\n/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */\\r\\n.leaflet-overlay-pane svg {\\r\\n\\t-moz-user-select: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-pane         { z-index: 400; }\\r\\n\\r\\n.leaflet-tile-pane    { z-index: 200; }\\r\\n.leaflet-overlay-pane { z-index: 400; }\\r\\n.leaflet-shadow-pane  { z-index: 500; }\\r\\n.leaflet-marker-pane  { z-index: 600; }\\r\\n.leaflet-tooltip-pane   { z-index: 650; }\\r\\n.leaflet-popup-pane   { z-index: 700; }\\r\\n\\r\\n.leaflet-map-pane canvas { z-index: 100; }\\r\\n.leaflet-map-pane svg    { z-index: 200; }\\r\\n\\r\\n.leaflet-vml-shape {\\r\\n\\twidth: 1px;\\r\\n\\theight: 1px;\\r\\n\\t}\\r\\n.lvml {\\r\\n\\tbehavior: url(#default#VML);\\r\\n\\tdisplay: inline-block;\\r\\n\\tposition: absolute;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* control positioning */\\r\\n\\r\\n.leaflet-control {\\r\\n\\tposition: relative;\\r\\n\\tz-index: 800;\\r\\n\\tpointer-events: visiblePainted; /* IE 9-10 doesn\'t have auto */\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n.leaflet-top,\\r\\n.leaflet-bottom {\\r\\n\\tposition: absolute;\\r\\n\\tz-index: 1000;\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n.leaflet-top {\\r\\n\\ttop: 0;\\r\\n\\t}\\r\\n.leaflet-right {\\r\\n\\tright: 0;\\r\\n\\t}\\r\\n.leaflet-bottom {\\r\\n\\tbottom: 0;\\r\\n\\t}\\r\\n.leaflet-left {\\r\\n\\tleft: 0;\\r\\n\\t}\\r\\n.leaflet-control {\\r\\n\\tfloat: left;\\r\\n\\tclear: both;\\r\\n\\t}\\r\\n.leaflet-right .leaflet-control {\\r\\n\\tfloat: right;\\r\\n\\t}\\r\\n.leaflet-top .leaflet-control {\\r\\n\\tmargin-top: 10px;\\r\\n\\t}\\r\\n.leaflet-bottom .leaflet-control {\\r\\n\\tmargin-bottom: 10px;\\r\\n\\t}\\r\\n.leaflet-left .leaflet-control {\\r\\n\\tmargin-left: 10px;\\r\\n\\t}\\r\\n.leaflet-right .leaflet-control {\\r\\n\\tmargin-right: 10px;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* zoom and fade animations */\\r\\n\\r\\n.leaflet-fade-anim .leaflet-tile {\\r\\n\\twill-change: opacity;\\r\\n\\t}\\r\\n.leaflet-fade-anim .leaflet-popup {\\r\\n\\topacity: 0;\\r\\n\\t-webkit-transition: opacity 0.2s linear;\\r\\n\\t   -moz-transition: opacity 0.2s linear;\\r\\n\\t        transition: opacity 0.2s linear;\\r\\n\\t}\\r\\n.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {\\r\\n\\topacity: 1;\\r\\n\\t}\\r\\n.leaflet-zoom-animated {\\r\\n\\t-webkit-transform-origin: 0 0;\\r\\n\\t    -ms-transform-origin: 0 0;\\r\\n\\t        transform-origin: 0 0;\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-zoom-animated {\\r\\n\\twill-change: transform;\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-zoom-animated {\\r\\n\\t-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t   -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t        transition:         transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-tile,\\r\\n.leaflet-pan-anim .leaflet-tile {\\r\\n\\t-webkit-transition: none;\\r\\n\\t   -moz-transition: none;\\r\\n\\t        transition: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-zoom-anim .leaflet-zoom-hide {\\r\\n\\tvisibility: hidden;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* cursors */\\r\\n\\r\\n.leaflet-interactive {\\r\\n\\tcursor: pointer;\\r\\n\\t}\\r\\n.leaflet-grab {\\r\\n\\tcursor: -webkit-grab;\\r\\n\\tcursor:    -moz-grab;\\r\\n\\tcursor:         grab;\\r\\n\\t}\\r\\n.leaflet-crosshair,\\r\\n.leaflet-crosshair .leaflet-interactive {\\r\\n\\tcursor: crosshair;\\r\\n\\t}\\r\\n.leaflet-popup-pane,\\r\\n.leaflet-control {\\r\\n\\tcursor: auto;\\r\\n\\t}\\r\\n.leaflet-dragging .leaflet-grab,\\r\\n.leaflet-dragging .leaflet-grab .leaflet-interactive,\\r\\n.leaflet-dragging .leaflet-marker-draggable {\\r\\n\\tcursor: move;\\r\\n\\tcursor: -webkit-grabbing;\\r\\n\\tcursor:    -moz-grabbing;\\r\\n\\tcursor:         grabbing;\\r\\n\\t}\\r\\n\\r\\n/* marker & overlays interactivity */\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow,\\r\\n.leaflet-image-layer,\\r\\n.leaflet-pane > svg path,\\r\\n.leaflet-tile-container {\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-marker-icon.leaflet-interactive,\\r\\n.leaflet-image-layer.leaflet-interactive,\\r\\n.leaflet-pane > svg path.leaflet-interactive,\\r\\nsvg.leaflet-image-layer.leaflet-interactive path {\\r\\n\\tpointer-events: visiblePainted; /* IE 9-10 doesn\'t have auto */\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n\\r\\n/* visual tweaks */\\r\\n\\r\\n.leaflet-container {\\r\\n\\tbackground: #ddd;\\r\\n\\toutline: 0;\\r\\n\\t}\\r\\n.leaflet-container a {\\r\\n\\tcolor: #0078A8;\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-active {\\r\\n\\toutline: 2px solid orange;\\r\\n\\t}\\r\\n.leaflet-zoom-box {\\r\\n\\tborder: 2px dotted #38f;\\r\\n\\tbackground: rgba(255,255,255,0.5);\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* general typography */\\r\\n.leaflet-container {\\r\\n\\tfont: 12px/1.5 \\"Helvetica Neue\\", Arial, Helvetica, sans-serif;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* general toolbar styles */\\r\\n\\r\\n.leaflet-bar {\\r\\n\\tbox-shadow: 0 1px 5px rgba(0,0,0,0.65);\\r\\n\\tborder-radius: 4px;\\r\\n\\t}\\r\\n.leaflet-bar a,\\r\\n.leaflet-bar a:hover {\\r\\n\\tbackground-color: #fff;\\r\\n\\tborder-bottom: 1px solid #ccc;\\r\\n\\twidth: 26px;\\r\\n\\theight: 26px;\\r\\n\\tline-height: 26px;\\r\\n\\tdisplay: block;\\r\\n\\ttext-align: center;\\r\\n\\ttext-decoration: none;\\r\\n\\tcolor: black;\\r\\n\\t}\\r\\n.leaflet-bar a,\\r\\n.leaflet-control-layers-toggle {\\r\\n\\tbackground-position: 50% 50%;\\r\\n\\tbackground-repeat: no-repeat;\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n.leaflet-bar a:hover {\\r\\n\\tbackground-color: #f4f4f4;\\r\\n\\t}\\r\\n.leaflet-bar a:first-child {\\r\\n\\tborder-top-left-radius: 4px;\\r\\n\\tborder-top-right-radius: 4px;\\r\\n\\t}\\r\\n.leaflet-bar a:last-child {\\r\\n\\tborder-bottom-left-radius: 4px;\\r\\n\\tborder-bottom-right-radius: 4px;\\r\\n\\tborder-bottom: none;\\r\\n\\t}\\r\\n.leaflet-bar a.leaflet-disabled {\\r\\n\\tcursor: default;\\r\\n\\tbackground-color: #f4f4f4;\\r\\n\\tcolor: #bbb;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-bar a {\\r\\n\\twidth: 30px;\\r\\n\\theight: 30px;\\r\\n\\tline-height: 30px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-bar a:first-child {\\r\\n\\tborder-top-left-radius: 2px;\\r\\n\\tborder-top-right-radius: 2px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-bar a:last-child {\\r\\n\\tborder-bottom-left-radius: 2px;\\r\\n\\tborder-bottom-right-radius: 2px;\\r\\n\\t}\\r\\n\\r\\n/* zoom control */\\r\\n\\r\\n.leaflet-control-zoom-in,\\r\\n.leaflet-control-zoom-out {\\r\\n\\tfont: bold 18px \'Lucida Console\', Monaco, monospace;\\r\\n\\ttext-indent: 1px;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {\\r\\n\\tfont-size: 22px;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* layers control */\\r\\n\\r\\n.leaflet-control-layers {\\r\\n\\tbox-shadow: 0 1px 5px rgba(0,0,0,0.4);\\r\\n\\tbackground: #fff;\\r\\n\\tborder-radius: 5px;\\r\\n\\t}\\r\\n.leaflet-control-layers-toggle {\\r\\n\\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\\r\\n\\twidth: 36px;\\r\\n\\theight: 36px;\\r\\n\\t}\\r\\n.leaflet-retina .leaflet-control-layers-toggle {\\r\\n\\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ");\\r\\n\\tbackground-size: 26px 26px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-control-layers-toggle {\\r\\n\\twidth: 44px;\\r\\n\\theight: 44px;\\r\\n\\t}\\r\\n.leaflet-control-layers .leaflet-control-layers-list,\\r\\n.leaflet-control-layers-expanded .leaflet-control-layers-toggle {\\r\\n\\tdisplay: none;\\r\\n\\t}\\r\\n.leaflet-control-layers-expanded .leaflet-control-layers-list {\\r\\n\\tdisplay: block;\\r\\n\\tposition: relative;\\r\\n\\t}\\r\\n.leaflet-control-layers-expanded {\\r\\n\\tpadding: 6px 10px 6px 6px;\\r\\n\\tcolor: #333;\\r\\n\\tbackground: #fff;\\r\\n\\t}\\r\\n.leaflet-control-layers-scrollbar {\\r\\n\\toverflow-y: scroll;\\r\\n\\toverflow-x: hidden;\\r\\n\\tpadding-right: 5px;\\r\\n\\t}\\r\\n.leaflet-control-layers-selector {\\r\\n\\tmargin-top: 2px;\\r\\n\\tposition: relative;\\r\\n\\ttop: 1px;\\r\\n\\t}\\r\\n.leaflet-control-layers label {\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n.leaflet-control-layers-separator {\\r\\n\\theight: 0;\\r\\n\\tborder-top: 1px solid #ddd;\\r\\n\\tmargin: 5px -10px 5px -6px;\\r\\n\\t}\\r\\n\\r\\n/* Default icon URLs */\\r\\n.leaflet-default-icon-path {\\r\\n\\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ");\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* attribution and scale controls */\\r\\n\\r\\n.leaflet-container .leaflet-control-attribution {\\r\\n\\tbackground: #fff;\\r\\n\\tbackground: rgba(255, 255, 255, 0.7);\\r\\n\\tmargin: 0;\\r\\n\\t}\\r\\n.leaflet-control-attribution,\\r\\n.leaflet-control-scale-line {\\r\\n\\tpadding: 0 5px;\\r\\n\\tcolor: #333;\\r\\n\\t}\\r\\n.leaflet-control-attribution a {\\r\\n\\ttext-decoration: none;\\r\\n\\t}\\r\\n.leaflet-control-attribution a:hover {\\r\\n\\ttext-decoration: underline;\\r\\n\\t}\\r\\n.leaflet-container .leaflet-control-attribution,\\r\\n.leaflet-container .leaflet-control-scale {\\r\\n\\tfont-size: 11px;\\r\\n\\t}\\r\\n.leaflet-left .leaflet-control-scale {\\r\\n\\tmargin-left: 5px;\\r\\n\\t}\\r\\n.leaflet-bottom .leaflet-control-scale {\\r\\n\\tmargin-bottom: 5px;\\r\\n\\t}\\r\\n.leaflet-control-scale-line {\\r\\n\\tborder: 2px solid #777;\\r\\n\\tborder-top: none;\\r\\n\\tline-height: 1.1;\\r\\n\\tpadding: 2px 5px 1px;\\r\\n\\tfont-size: 11px;\\r\\n\\twhite-space: nowrap;\\r\\n\\toverflow: hidden;\\r\\n\\t-moz-box-sizing: border-box;\\r\\n\\t     box-sizing: border-box;\\r\\n\\r\\n\\tbackground: #fff;\\r\\n\\tbackground: rgba(255, 255, 255, 0.5);\\r\\n\\t}\\r\\n.leaflet-control-scale-line:not(:first-child) {\\r\\n\\tborder-top: 2px solid #777;\\r\\n\\tborder-bottom: none;\\r\\n\\tmargin-top: -2px;\\r\\n\\t}\\r\\n.leaflet-control-scale-line:not(:first-child):not(:last-child) {\\r\\n\\tborder-bottom: 2px solid #777;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-control-attribution,\\r\\n.leaflet-touch .leaflet-control-layers,\\r\\n.leaflet-touch .leaflet-bar {\\r\\n\\tbox-shadow: none;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-control-layers,\\r\\n.leaflet-touch .leaflet-bar {\\r\\n\\tborder: 2px solid rgba(0,0,0,0.2);\\r\\n\\tbackground-clip: padding-box;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* popup */\\r\\n\\r\\n.leaflet-popup {\\r\\n\\tposition: absolute;\\r\\n\\ttext-align: center;\\r\\n\\tmargin-bottom: 20px;\\r\\n\\t}\\r\\n.leaflet-popup-content-wrapper {\\r\\n\\tpadding: 1px;\\r\\n\\ttext-align: left;\\r\\n\\tborder-radius: 12px;\\r\\n\\t}\\r\\n.leaflet-popup-content {\\r\\n\\tmargin: 13px 19px;\\r\\n\\tline-height: 1.4;\\r\\n\\t}\\r\\n.leaflet-popup-content p {\\r\\n\\tmargin: 18px 0;\\r\\n\\t}\\r\\n.leaflet-popup-tip-container {\\r\\n\\twidth: 40px;\\r\\n\\theight: 20px;\\r\\n\\tposition: absolute;\\r\\n\\tleft: 50%;\\r\\n\\tmargin-left: -20px;\\r\\n\\toverflow: hidden;\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n.leaflet-popup-tip {\\r\\n\\twidth: 17px;\\r\\n\\theight: 17px;\\r\\n\\tpadding: 1px;\\r\\n\\r\\n\\tmargin: -10px auto 0;\\r\\n\\r\\n\\t-webkit-transform: rotate(45deg);\\r\\n\\t   -moz-transform: rotate(45deg);\\r\\n\\t    -ms-transform: rotate(45deg);\\r\\n\\t        transform: rotate(45deg);\\r\\n\\t}\\r\\n.leaflet-popup-content-wrapper,\\r\\n.leaflet-popup-tip {\\r\\n\\tbackground: white;\\r\\n\\tcolor: #333;\\r\\n\\tbox-shadow: 0 3px 14px rgba(0,0,0,0.4);\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-popup-close-button {\\r\\n\\tposition: absolute;\\r\\n\\ttop: 0;\\r\\n\\tright: 0;\\r\\n\\tpadding: 4px 4px 0 0;\\r\\n\\tborder: none;\\r\\n\\ttext-align: center;\\r\\n\\twidth: 18px;\\r\\n\\theight: 14px;\\r\\n\\tfont: 16px/14px Tahoma, Verdana, sans-serif;\\r\\n\\tcolor: #c3c3c3;\\r\\n\\ttext-decoration: none;\\r\\n\\tfont-weight: bold;\\r\\n\\tbackground: transparent;\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-popup-close-button:hover {\\r\\n\\tcolor: #999;\\r\\n\\t}\\r\\n.leaflet-popup-scrolled {\\r\\n\\toverflow: auto;\\r\\n\\tborder-bottom: 1px solid #ddd;\\r\\n\\tborder-top: 1px solid #ddd;\\r\\n\\t}\\r\\n\\r\\n.leaflet-oldie .leaflet-popup-content-wrapper {\\r\\n\\tzoom: 1;\\r\\n\\t}\\r\\n.leaflet-oldie .leaflet-popup-tip {\\r\\n\\twidth: 24px;\\r\\n\\tmargin: 0 auto;\\r\\n\\r\\n\\t-ms-filter: \\"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)\\";\\r\\n\\tfilter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);\\r\\n\\t}\\r\\n.leaflet-oldie .leaflet-popup-tip-container {\\r\\n\\tmargin-top: -1px;\\r\\n\\t}\\r\\n\\r\\n.leaflet-oldie .leaflet-control-zoom,\\r\\n.leaflet-oldie .leaflet-control-layers,\\r\\n.leaflet-oldie .leaflet-popup-content-wrapper,\\r\\n.leaflet-oldie .leaflet-popup-tip {\\r\\n\\tborder: 1px solid #999;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* div icon */\\r\\n\\r\\n.leaflet-div-icon {\\r\\n\\tbackground: #fff;\\r\\n\\tborder: 1px solid #666;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* Tooltip */\\r\\n/* Base styles for the element that has a tooltip */\\r\\n.leaflet-tooltip {\\r\\n\\tposition: absolute;\\r\\n\\tpadding: 6px;\\r\\n\\tbackground-color: #fff;\\r\\n\\tborder: 1px solid #fff;\\r\\n\\tborder-radius: 3px;\\r\\n\\tcolor: #222;\\r\\n\\twhite-space: nowrap;\\r\\n\\t-webkit-user-select: none;\\r\\n\\t-moz-user-select: none;\\r\\n\\t-ms-user-select: none;\\r\\n\\tuser-select: none;\\r\\n\\tpointer-events: none;\\r\\n\\tbox-shadow: 0 1px 3px rgba(0,0,0,0.4);\\r\\n\\t}\\r\\n.leaflet-tooltip.leaflet-clickable {\\r\\n\\tcursor: pointer;\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n.leaflet-tooltip-top:before,\\r\\n.leaflet-tooltip-bottom:before,\\r\\n.leaflet-tooltip-left:before,\\r\\n.leaflet-tooltip-right:before {\\r\\n\\tposition: absolute;\\r\\n\\tpointer-events: none;\\r\\n\\tborder: 6px solid transparent;\\r\\n\\tbackground: transparent;\\r\\n\\tcontent: \\"\\";\\r\\n\\t}\\r\\n\\r\\n/* Directions */\\r\\n\\r\\n.leaflet-tooltip-bottom {\\r\\n\\tmargin-top: 6px;\\r\\n}\\r\\n.leaflet-tooltip-top {\\r\\n\\tmargin-top: -6px;\\r\\n}\\r\\n.leaflet-tooltip-bottom:before,\\r\\n.leaflet-tooltip-top:before {\\r\\n\\tleft: 50%;\\r\\n\\tmargin-left: -6px;\\r\\n\\t}\\r\\n.leaflet-tooltip-top:before {\\r\\n\\tbottom: 0;\\r\\n\\tmargin-bottom: -12px;\\r\\n\\tborder-top-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-bottom:before {\\r\\n\\ttop: 0;\\r\\n\\tmargin-top: -12px;\\r\\n\\tmargin-left: -6px;\\r\\n\\tborder-bottom-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-left {\\r\\n\\tmargin-left: -6px;\\r\\n}\\r\\n.leaflet-tooltip-right {\\r\\n\\tmargin-left: 6px;\\r\\n}\\r\\n.leaflet-tooltip-left:before,\\r\\n.leaflet-tooltip-right:before {\\r\\n\\ttop: 50%;\\r\\n\\tmargin-top: -6px;\\r\\n\\t}\\r\\n.leaflet-tooltip-left:before {\\r\\n\\tright: 0;\\r\\n\\tmargin-right: -12px;\\r\\n\\tborder-left-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-right:before {\\r\\n\\tleft: 0;\\r\\n\\tmargin-left: -12px;\\r\\n\\tborder-right-color: #fff;\\r\\n\\t}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzPzRmODMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxDQUFzQztBQUNoRixzQ0FBc0MsbUJBQU8sQ0FBQyxFQUF5QztBQUN2RixvQ0FBb0MsbUJBQU8sQ0FBQyxFQUFxQjtBQUNqRSxvQ0FBb0MsbUJBQU8sQ0FBQyxFQUF3QjtBQUNwRSxvQ0FBb0MsbUJBQU8sQ0FBQyxFQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFTLHNRQUFzUSx5QkFBeUIsY0FBYyxhQUFhLE9BQU8sd0JBQXdCLHVCQUF1QixPQUFPLHVFQUF1RSxnQ0FBZ0MsZ0NBQWdDLGdDQUFnQyxnQ0FBZ0MsT0FBTyxxRkFBcUYsOEJBQThCLEtBQUssMkhBQTJILGlEQUFpRCxPQUFPLHlIQUF5SCxvQkFBb0IscUJBQXFCLG9DQUFvQyxPQUFPLHFEQUFxRCxxQkFBcUIsT0FBTyxtZEFBbWQsaUNBQWlDLGtDQUFrQyxPQUFPLCtDQUErQyxvQ0FBb0MsZ0NBQWdDLE9BQU8sMkNBQTJDLG1DQUFtQyxxRkFBcUYsK0JBQStCLEtBQUssOERBQThELDZCQUE2Qix5QkFBeUIsS0FBSyx3QkFBd0IsK0NBQStDLEtBQUssMEJBQTBCLDJEQUEyRCxLQUFLLG1CQUFtQixzQkFBc0IseUJBQXlCLE9BQU8sMEJBQTBCLDBCQUEwQixPQUFPLHVCQUF1QixlQUFlLGdCQUFnQixrQ0FBa0Msa0NBQWtDLG1CQUFtQixPQUFPLDJHQUEyRyw2QkFBNkIsT0FBTywrQkFBK0IsY0FBYyxFQUFFLCtCQUErQixjQUFjLEVBQUUsMkJBQTJCLGNBQWMsRUFBRSwyQkFBMkIsY0FBYyxFQUFFLDJCQUEyQixjQUFjLEVBQUUsNkJBQTZCLGNBQWMsRUFBRSwyQkFBMkIsY0FBYyxFQUFFLGtDQUFrQyxjQUFjLEVBQUUsOEJBQThCLGNBQWMsRUFBRSw0QkFBNEIsaUJB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Z0NBQWdDLE9BQU8sMkJBQTJCLHdCQUF3QixLQUFLLDRCQUE0Qix1QkFBdUIsS0FBSyxvRUFBb0UsZUFBZSx1QkFBdUIsT0FBTyxrQ0FBa0MsZUFBZSwwQkFBMEIsOEJBQThCLE9BQU8sbUNBQW1DLGNBQWMseUJBQXlCLCtCQUErQixPQUFPO0FBQzVwZjtBQUNBIiwiZmlsZSI6IjMwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9nZXRVcmwuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18gPSByZXF1aXJlKFwiLi9pbWFnZXMvbGF5ZXJzLnBuZ1wiKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyA9IHJlcXVpcmUoXCIuL2ltYWdlcy9sYXllcnMtMngucG5nXCIpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8yX19fID0gcmVxdWlyZShcIi4vaW1hZ2VzL21hcmtlci1pY29uLnBuZ1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMl9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzJfX18pO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiByZXF1aXJlZCBzdHlsZXMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1wYW5lLFxcclxcbi5sZWFmbGV0LXRpbGUsXFxyXFxuLmxlYWZsZXQtbWFya2VyLWljb24sXFxyXFxuLmxlYWZsZXQtbWFya2VyLXNoYWRvdyxcXHJcXG4ubGVhZmxldC10aWxlLWNvbnRhaW5lcixcXHJcXG4ubGVhZmxldC1wYW5lID4gc3ZnLFxcclxcbi5sZWFmbGV0LXBhbmUgPiBjYW52YXMsXFxyXFxuLmxlYWZsZXQtem9vbS1ib3gsXFxyXFxuLmxlYWZsZXQtaW1hZ2UtbGF5ZXIsXFxyXFxuLmxlYWZsZXQtbGF5ZXIge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHRsZWZ0OiAwO1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10aWxlLFxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3cge1xcclxcblxcdC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0ICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdCAgLXdlYmtpdC11c2VyLWRyYWc6IG5vbmU7XFxyXFxuXFx0fVxcclxcbi8qIFByZXZlbnRzIElFMTEgZnJvbSBoaWdobGlnaHRpbmcgdGlsZXMgaW4gYmx1ZSAqL1xcclxcbi5sZWFmbGV0LXRpbGU6OnNlbGVjdGlvbiB7XFxyXFxuXFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcbi8qIFNhZmFyaSByZW5kZXJzIG5vbi1yZXRpbmEgdGlsZSBvbiByZXRpbmEgYmV0dGVyIHdpdGggdGhpcywgYnV0IENocm9tZSBpcyB3b3JzZSAqL1xcclxcbi5sZWFmbGV0LXNhZmFyaSAubGVhZmxldC10aWxlIHtcXHJcXG5cXHRpbWFnZS1yZW5kZXJpbmc6IC13ZWJraXQtb3B0aW1pemUtY29udHJhc3Q7XFxyXFxuXFx0fVxcclxcbi8qIGhhY2sgdGhhdCBwcmV2ZW50cyBodyBsYXllcnMgXFxcInN0cmV0Y2hpbmdcXFwiIHdoZW4gbG9hZGluZyBuZXcgdGlsZXMgKi9cXHJcXG4ubGVhZmxldC1zYWZhcmkgLmxlYWZsZXQtdGlsZS1jb250YWluZXIge1xcclxcblxcdHdpZHRoOiAxNjAwcHg7XFxyXFxuXFx0aGVpZ2h0OiAxNjAwcHg7XFxyXFxuXFx0LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiAwIDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3cge1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdH1cXHJcXG4vKiAubGVhZmxldC1jb250YWluZXIgc3ZnOiByZXNldCBzdmcgbWF4LXdpZHRoIGRlY2xlcmF0aW9uIHNoaXBwZWQgaW4gSm9vbWxhISAoam9vbWxhLm9yZykgMy54ICovXFxyXFxuLyogLmxlYWZsZXQtY29udGFpbmVyIGltZzogbWFwIGlzIGJyb2tlbiBpbiBGRiBpZiB5b3UgaGF2ZSBtYXgtd2lkdGg6IDEwMCUgb24gdGlsZXMgKi9cXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2ZyxcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtbWFya2VyLXBhbmUgaW1nLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1zaGFkb3ctcGFuZSBpbWcsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LXRpbGUtcGFuZSBpbWcsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGltZy5sZWFmbGV0LWltYWdlLWxheWVyLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC10aWxlIHtcXHJcXG5cXHRtYXgtd2lkdGg6IG5vbmUgIWltcG9ydGFudDtcXHJcXG5cXHRtYXgtaGVpZ2h0OiBub25lICFpbXBvcnRhbnQ7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLXpvb20ge1xcclxcblxcdC1tcy10b3VjaC1hY3Rpb246IHBhbi14IHBhbi15O1xcclxcblxcdHRvdWNoLWFjdGlvbjogcGFuLXggcGFuLXk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLWRyYWcge1xcclxcblxcdC1tcy10b3VjaC1hY3Rpb246IHBpbmNoLXpvb207XFxyXFxuXFx0LyogRmFsbGJhY2sgZm9yIEZGIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwaW5jaC16b29tICovXFxyXFxuXFx0dG91Y2gtYWN0aW9uOiBub25lO1xcclxcblxcdHRvdWNoLWFjdGlvbjogcGluY2gtem9vbTtcXHJcXG59XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyLmxlYWZsZXQtdG91Y2gtZHJhZy5sZWFmbGV0LXRvdWNoLXpvb20ge1xcclxcblxcdC1tcy10b3VjaC1hY3Rpb246IG5vbmU7XFxyXFxuXFx0dG91Y2gtYWN0aW9uOiBub25lO1xcclxcbn1cXHJcXG4ubGVhZmxldC1jb250YWluZXIge1xcclxcblxcdC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhIHtcXHJcXG5cXHQtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoNTEsIDE4MSwgMjI5LCAwLjQpO1xcclxcbn1cXHJcXG4ubGVhZmxldC10aWxlIHtcXHJcXG5cXHRmaWx0ZXI6IGluaGVyaXQ7XFxyXFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10aWxlLWxvYWRlZCB7XFxyXFxuXFx0dmlzaWJpbGl0eTogaW5oZXJpdDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1ib3gge1xcclxcblxcdHdpZHRoOiAwO1xcclxcblxcdGhlaWdodDogMDtcXHJcXG5cXHQtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuXFx0ICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcdHotaW5kZXg6IDgwMDtcXHJcXG5cXHR9XFxyXFxuLyogd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg4MzE5ICovXFxyXFxuLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2ZyB7XFxyXFxuXFx0LW1vei11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtcGFuZSAgICAgICAgIHsgei1pbmRleDogNDAwOyB9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdGlsZS1wYW5lICAgIHsgei1pbmRleDogMjAwOyB9XFxyXFxuLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHsgei1pbmRleDogNDAwOyB9XFxyXFxuLmxlYWZsZXQtc2hhZG93LXBhbmUgIHsgei1pbmRleDogNTAwOyB9XFxyXFxuLmxlYWZsZXQtbWFya2VyLXBhbmUgIHsgei1pbmRleDogNjAwOyB9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1wYW5lICAgeyB6LWluZGV4OiA2NTA7IH1cXHJcXG4ubGVhZmxldC1wb3B1cC1wYW5lICAgeyB6LWluZGV4OiA3MDA7IH1cXHJcXG5cXHJcXG4ubGVhZmxldC1tYXAtcGFuZSBjYW52YXMgeyB6LWluZGV4OiAxMDA7IH1cXHJcXG4ubGVhZmxldC1tYXAtcGFuZSBzdmcgICAgeyB6LWluZGV4OiAyMDA7IH1cXHJcXG5cXHJcXG4ubGVhZmxldC12bWwtc2hhcGUge1xcclxcblxcdHdpZHRoOiAxcHg7XFxyXFxuXFx0aGVpZ2h0OiAxcHg7XFxyXFxuXFx0fVxcclxcbi5sdm1sIHtcXHJcXG5cXHRiZWhhdmlvcjogdXJsKCNkZWZhdWx0I1ZNTCk7XFxyXFxuXFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogY29udHJvbCBwb3NpdGlvbmluZyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG5cXHR6LWluZGV4OiA4MDA7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IHZpc2libGVQYWludGVkOyAvKiBJRSA5LTEwIGRvZXNuJ3QgaGF2ZSBhdXRvICovXFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvcCxcXHJcXG4ubGVhZmxldC1ib3R0b20ge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR6LWluZGV4OiAxMDAwO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3Age1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmlnaHQge1xcclxcblxcdHJpZ2h0OiAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1ib3R0b20ge1xcclxcblxcdGJvdHRvbTogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtbGVmdCB7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0ZmxvYXQ6IGxlZnQ7XFxyXFxuXFx0Y2xlYXI6IGJvdGg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJpZ2h0IC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGZsb2F0OiByaWdodDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9wIC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdG1hcmdpbi10b3A6IDEwcHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJvdHRvbSAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1sZWZ0IC5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdG1hcmdpbi1sZWZ0OiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1yaWdodCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tcmlnaHQ6IDEwcHg7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIHpvb20gYW5kIGZhZGUgYW5pbWF0aW9ucyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWZhZGUtYW5pbSAubGVhZmxldC10aWxlIHtcXHJcXG5cXHR3aWxsLWNoYW5nZTogb3BhY2l0eTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZmFkZS1hbmltIC5sZWFmbGV0LXBvcHVwIHtcXHJcXG5cXHRvcGFjaXR5OiAwO1xcclxcblxcdC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGxpbmVhcjtcXHJcXG5cXHQgICAtbW96LXRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBsaW5lYXI7XFxyXFxuXFx0ICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgbGluZWFyO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtbWFwLXBhbmUgLmxlYWZsZXQtcG9wdXAge1xcclxcblxcdG9wYWNpdHk6IDE7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYW5pbWF0ZWQge1xcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdCAgICAtbXMtdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdCAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWFuaW0gLmxlYWZsZXQtem9vbS1hbmltYXRlZCB7XFxyXFxuXFx0d2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20tYW5pbWF0ZWQge1xcclxcblxcdC13ZWJraXQtdHJhbnNpdGlvbjogLXdlYmtpdC10cmFuc2Zvcm0gMC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwwLjI1LDEpO1xcclxcblxcdCAgIC1tb3otdHJhbnNpdGlvbjogICAgLW1vei10cmFuc2Zvcm0gMC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwwLjI1LDEpO1xcclxcblxcdCAgICAgICAgdHJhbnNpdGlvbjogICAgICAgICB0cmFuc2Zvcm0gMC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwwLjI1LDEpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWFuaW0gLmxlYWZsZXQtdGlsZSxcXHJcXG4ubGVhZmxldC1wYW4tYW5pbSAubGVhZmxldC10aWxlIHtcXHJcXG5cXHQtd2Via2l0LXRyYW5zaXRpb246IG5vbmU7XFxyXFxuXFx0ICAgLW1vei10cmFuc2l0aW9uOiBub25lO1xcclxcblxcdCAgICAgICAgdHJhbnNpdGlvbjogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20taGlkZSB7XFxyXFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBjdXJzb3JzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtaW50ZXJhY3RpdmUge1xcclxcblxcdGN1cnNvcjogcG9pbnRlcjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZ3JhYiB7XFxyXFxuXFx0Y3Vyc29yOiAtd2Via2l0LWdyYWI7XFxyXFxuXFx0Y3Vyc29yOiAgICAtbW96LWdyYWI7XFxyXFxuXFx0Y3Vyc29yOiAgICAgICAgIGdyYWI7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNyb3NzaGFpcixcXHJcXG4ubGVhZmxldC1jcm9zc2hhaXIgLmxlYWZsZXQtaW50ZXJhY3RpdmUge1xcclxcblxcdGN1cnNvcjogY3Jvc3NoYWlyO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1wYW5lLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGN1cnNvcjogYXV0bztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtZ3JhYixcXHJcXG4ubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1ncmFiIC5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbi5sZWFmbGV0LWRyYWdnaW5nIC5sZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUge1xcclxcblxcdGN1cnNvcjogbW92ZTtcXHJcXG5cXHRjdXJzb3I6IC13ZWJraXQtZ3JhYmJpbmc7XFxyXFxuXFx0Y3Vyc29yOiAgICAtbW96LWdyYWJiaW5nO1xcclxcblxcdGN1cnNvcjogICAgICAgICBncmFiYmluZztcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogbWFya2VyICYgb3ZlcmxheXMgaW50ZXJhY3Rpdml0eSAqL1xcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3csXFxyXFxuLmxlYWZsZXQtaW1hZ2UtbGF5ZXIsXFxyXFxuLmxlYWZsZXQtcGFuZSA+IHN2ZyBwYXRoLFxcclxcbi5sZWFmbGV0LXRpbGUtY29udGFpbmVyIHtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtbWFya2VyLWljb24ubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG4ubGVhZmxldC1pbWFnZS1sYXllci5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbi5sZWFmbGV0LXBhbmUgPiBzdmcgcGF0aC5sZWFmbGV0LWludGVyYWN0aXZlLFxcclxcbnN2Zy5sZWFmbGV0LWltYWdlLWxheWVyLmxlYWZsZXQtaW50ZXJhY3RpdmUgcGF0aCB7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IHZpc2libGVQYWludGVkOyAvKiBJRSA5LTEwIGRvZXNuJ3QgaGF2ZSBhdXRvICovXFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIHZpc3VhbCB0d2Vha3MgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250YWluZXIge1xcclxcblxcdGJhY2tncm91bmQ6ICNkZGQ7XFxyXFxuXFx0b3V0bGluZTogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEge1xcclxcblxcdGNvbG9yOiAjMDA3OEE4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LWFjdGl2ZSB7XFxyXFxuXFx0b3V0bGluZTogMnB4IHNvbGlkIG9yYW5nZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1ib3gge1xcclxcblxcdGJvcmRlcjogMnB4IGRvdHRlZCAjMzhmO1xcclxcblxcdGJhY2tncm91bmQ6IHJnYmEoMjU1LDI1NSwyNTUsMC41KTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogZ2VuZXJhbCB0eXBvZ3JhcGh5ICovXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHRmb250OiAxMnB4LzEuNSBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBnZW5lcmFsIHRvb2xiYXIgc3R5bGVzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtYmFyIHtcXHJcXG5cXHRib3gtc2hhZG93OiAwIDFweCA1cHggcmdiYSgwLDAsMCwwLjY1KTtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiA0cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhLFxcclxcbi5sZWFmbGV0LWJhciBhOmhvdmVyIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcclxcblxcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjO1xcclxcblxcdHdpZHRoOiAyNnB4O1xcclxcblxcdGhlaWdodDogMjZweDtcXHJcXG5cXHRsaW5lLWhlaWdodDogMjZweDtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcblxcdGNvbG9yOiBibGFjaztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYmFyIGEsXFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiA1MCUgNTAlO1xcclxcblxcdGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhOmhvdmVyIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYTpmaXJzdC1jaGlsZCB7XFxyXFxuXFx0Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNHB4O1xcclxcblxcdGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhOmxhc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDRweDtcXHJcXG5cXHRib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNHB4O1xcclxcblxcdGJvcmRlci1ib3R0b206IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhLmxlYWZsZXQtZGlzYWJsZWQge1xcclxcblxcdGN1cnNvcjogZGVmYXVsdDtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xcclxcblxcdGNvbG9yOiAjYmJiO1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYSB7XFxyXFxuXFx0d2lkdGg6IDMwcHg7XFxyXFxuXFx0aGVpZ2h0OiAzMHB4O1xcclxcblxcdGxpbmUtaGVpZ2h0OiAzMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYTpmaXJzdC1jaGlsZCB7XFxyXFxuXFx0Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMnB4O1xcclxcblxcdGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAycHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciBhOmxhc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDJweDtcXHJcXG5cXHRib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMnB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiB6b29tIGNvbnRyb2wgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250cm9sLXpvb20taW4sXFxyXFxuLmxlYWZsZXQtY29udHJvbC16b29tLW91dCB7XFxyXFxuXFx0Zm9udDogYm9sZCAxOHB4ICdMdWNpZGEgQ29uc29sZScsIE1vbmFjbywgbW9ub3NwYWNlO1xcclxcblxcdHRleHQtaW5kZW50OiAxcHg7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtem9vbS1pbiwgLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC16b29tLW91dCAge1xcclxcblxcdGZvbnQtc2l6ZTogMjJweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogbGF5ZXJzIGNvbnRyb2wgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycyB7XFxyXFxuXFx0Ym94LXNoYWRvdzogMCAxcHggNXB4IHJnYmEoMCwwLDAsMC40KTtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdGJvcmRlci1yYWRpdXM6IDVweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8wX19fICsgXCIpO1xcclxcblxcdHdpZHRoOiAzNnB4O1xcclxcblxcdGhlaWdodDogMzZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmV0aW5hIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMV9fXyArIFwiKTtcXHJcXG5cXHRiYWNrZ3JvdW5kLXNpemU6IDI2cHggMjZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHR3aWR0aDogNDRweDtcXHJcXG5cXHRoZWlnaHQ6IDQ0cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWxpc3QsXFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xlIHtcXHJcXG5cXHRkaXNwbGF5OiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCAubGVhZmxldC1jb250cm9sLWxheWVycy1saXN0IHtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkIHtcXHJcXG5cXHRwYWRkaW5nOiA2cHggMTBweCA2cHggNnB4O1xcclxcblxcdGNvbG9yOiAjMzMzO1xcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhciB7XFxyXFxuXFx0b3ZlcmZsb3cteTogc2Nyb2xsO1xcclxcblxcdG92ZXJmbG93LXg6IGhpZGRlbjtcXHJcXG5cXHRwYWRkaW5nLXJpZ2h0OiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiAycHg7XFxyXFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcclxcblxcdHRvcDogMXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycyBsYWJlbCB7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlcGFyYXRvciB7XFxyXFxuXFx0aGVpZ2h0OiAwO1xcclxcblxcdGJvcmRlci10b3A6IDFweCBzb2xpZCAjZGRkO1xcclxcblxcdG1hcmdpbjogNXB4IC0xMHB4IDVweCAtNnB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiBEZWZhdWx0IGljb24gVVJMcyAqL1xcclxcbi5sZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoIHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8yX19fICsgXCIpO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBhdHRyaWJ1dGlvbiBhbmQgc2NhbGUgY29udHJvbHMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiB7XFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHRiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyk7XFxyXFxuXFx0bWFyZ2luOiAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZSB7XFxyXFxuXFx0cGFkZGluZzogMCA1cHg7XFxyXFxuXFx0Y29sb3I6ICMzMzM7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24gYSB7XFxyXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uIGE6aG92ZXIge1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbixcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtY29udHJvbC1zY2FsZSB7XFxyXFxuXFx0Zm9udC1zaXplOiAxMXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1sZWZ0IC5sZWFmbGV0LWNvbnRyb2wtc2NhbGUge1xcclxcblxcdG1hcmdpbi1sZWZ0OiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJvdHRvbSAubGVhZmxldC1jb250cm9sLXNjYWxlIHtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZSB7XFxyXFxuXFx0Ym9yZGVyOiAycHggc29saWQgIzc3NztcXHJcXG5cXHRib3JkZXItdG9wOiBub25lO1xcclxcblxcdGxpbmUtaGVpZ2h0OiAxLjE7XFxyXFxuXFx0cGFkZGluZzogMnB4IDVweCAxcHg7XFxyXFxuXFx0Zm9udC1zaXplOiAxMXB4O1xcclxcblxcdHdoaXRlLXNwYWNlOiBub3dyYXA7XFxyXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG5cXHQtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuXFx0ICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0YmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmU6bm90KDpmaXJzdC1jaGlsZCkge1xcclxcblxcdGJvcmRlci10b3A6IDJweCBzb2xpZCAjNzc3O1xcclxcblxcdGJvcmRlci1ib3R0b206IG5vbmU7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTJweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1zY2FsZS1saW5lOm5vdCg6Zmlyc3QtY2hpbGQpOm5vdCg6bGFzdC1jaGlsZCkge1xcclxcblxcdGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAjNzc3O1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uLFxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLFxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciB7XFxyXFxuXFx0Ym94LXNoYWRvdzogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMsXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIHtcXHJcXG5cXHRib3JkZXI6IDJweCBzb2xpZCByZ2JhKDAsMCwwLDAuMik7XFxyXFxuXFx0YmFja2dyb3VuZC1jbGlwOiBwYWRkaW5nLWJveDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogcG9wdXAgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1wb3B1cCB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAyMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXIge1xcclxcblxcdHBhZGRpbmc6IDFweDtcXHJcXG5cXHR0ZXh0LWFsaWduOiBsZWZ0O1xcclxcblxcdGJvcmRlci1yYWRpdXM6IDEycHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQge1xcclxcblxcdG1hcmdpbjogMTNweCAxOXB4O1xcclxcblxcdGxpbmUtaGVpZ2h0OiAxLjQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQgcCB7XFxyXFxuXFx0bWFyZ2luOiAxOHB4IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXIge1xcclxcblxcdHdpZHRoOiA0MHB4O1xcclxcblxcdGhlaWdodDogMjBweDtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0bGVmdDogNTAlO1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtMjBweDtcXHJcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC10aXAge1xcclxcblxcdHdpZHRoOiAxN3B4O1xcclxcblxcdGhlaWdodDogMTdweDtcXHJcXG5cXHRwYWRkaW5nOiAxcHg7XFxyXFxuXFxyXFxuXFx0bWFyZ2luOiAtMTBweCBhdXRvIDA7XFxyXFxuXFxyXFxuXFx0LXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0ICAgLW1vei10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0ICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0ICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlcixcXHJcXG4ubGVhZmxldC1wb3B1cC10aXAge1xcclxcblxcdGJhY2tncm91bmQ6IHdoaXRlO1xcclxcblxcdGNvbG9yOiAjMzMzO1xcclxcblxcdGJveC1zaGFkb3c6IDAgM3B4IDE0cHggcmdiYSgwLDAsMCwwLjQpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LXBvcHVwLWNsb3NlLWJ1dHRvbiB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHRyaWdodDogMDtcXHJcXG5cXHRwYWRkaW5nOiA0cHggNHB4IDAgMDtcXHJcXG5cXHRib3JkZXI6IG5vbmU7XFxyXFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcclxcblxcdHdpZHRoOiAxOHB4O1xcclxcblxcdGhlaWdodDogMTRweDtcXHJcXG5cXHRmb250OiAxNnB4LzE0cHggVGFob21hLCBWZXJkYW5hLCBzYW5zLXNlcmlmO1xcclxcblxcdGNvbG9yOiAjYzNjM2MzO1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG5cXHRmb250LXdlaWdodDogYm9sZDtcXHJcXG5cXHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b246aG92ZXIge1xcclxcblxcdGNvbG9yOiAjOTk5O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1zY3JvbGxlZCB7XFxyXFxuXFx0b3ZlcmZsb3c6IGF1dG87XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkZGQ7XFxyXFxuXFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkICNkZGQ7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlciB7XFxyXFxuXFx0em9vbTogMTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtdGlwIHtcXHJcXG5cXHR3aWR0aDogMjRweDtcXHJcXG5cXHRtYXJnaW46IDAgYXV0bztcXHJcXG5cXHJcXG5cXHQtbXMtZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9MC43MDcxMDY3OCwgTTEyPTAuNzA3MTA2NzgsIE0yMT0tMC43MDcxMDY3OCwgTTIyPTAuNzA3MTA2NzgpXFxcIjtcXHJcXG5cXHRmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPTAuNzA3MTA2NzgsIE0xMj0wLjcwNzEwNjc4LCBNMjE9LTAuNzA3MTA2NzgsIE0yMj0wLjcwNzEwNjc4KTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtdGlwLWNvbnRhaW5lciB7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTFweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtY29udHJvbC16b29tLFxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLFxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlcixcXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC10aXAge1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICM5OTk7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGRpdiBpY29uICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtZGl2LWljb24ge1xcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgIzY2NjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogVG9vbHRpcCAqL1xcclxcbi8qIEJhc2Ugc3R5bGVzIGZvciB0aGUgZWxlbWVudCB0aGF0IGhhcyBhIHRvb2x0aXAgKi9cXHJcXG4ubGVhZmxldC10b29sdGlwIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0cGFkZGluZzogNnB4O1xcclxcblxcdGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxyXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgI2ZmZjtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiAzcHg7XFxyXFxuXFx0Y29sb3I6ICMyMjI7XFxyXFxuXFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcXHJcXG5cXHQtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0LW1zLXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdHVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdGJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsMCwwLDAuNCk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAubGVhZmxldC1jbGlja2FibGUge1xcclxcblxcdGN1cnNvcjogcG9pbnRlcjtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogYXV0bztcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtYm90dG9tOmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQ6YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcmlnaHQ6YmVmb3JlIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0Ym9yZGVyOiA2cHggc29saWQgdHJhbnNwYXJlbnQ7XFxyXFxuXFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxuXFx0Y29udGVudDogXFxcIlxcXCI7XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIERpcmVjdGlvbnMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC10b29sdGlwLWJvdHRvbSB7XFxyXFxuXFx0bWFyZ2luLXRvcDogNnB4O1xcclxcbn1cXHJcXG4ubGVhZmxldC10b29sdGlwLXRvcCB7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1ib3R0b206YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtdG9wOmJlZm9yZSB7XFxyXFxuXFx0bGVmdDogNTAlO1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtNnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLXRvcDpiZWZvcmUge1xcclxcblxcdGJvdHRvbTogMDtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAtMTJweDtcXHJcXG5cXHRib3JkZXItdG9wLWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLWJvdHRvbTpiZWZvcmUge1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtMTJweDtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTZweDtcXHJcXG5cXHRib3JkZXItYm90dG9tLWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQge1xcclxcblxcdG1hcmdpbi1sZWZ0OiAtNnB4O1xcclxcbn1cXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0IHtcXHJcXG5cXHRtYXJnaW4tbGVmdDogNnB4O1xcclxcbn1cXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQ6YmVmb3JlLFxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcmlnaHQ6YmVmb3JlIHtcXHJcXG5cXHR0b3A6IDUwJTtcXHJcXG5cXHRtYXJnaW4tdG9wOiAtNnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLWxlZnQ6YmVmb3JlIHtcXHJcXG5cXHRyaWdodDogMDtcXHJcXG5cXHRtYXJnaW4tcmlnaHQ6IC0xMnB4O1xcclxcblxcdGJvcmRlci1sZWZ0LWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0OmJlZm9yZSB7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTEycHg7XFxyXFxuXFx0Ym9yZGVyLXJpZ2h0LWNvbG9yOiAjZmZmO1xcclxcblxcdH1cXHJcXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///30\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n\n\n  url = url && url.__esModule ? url.default : url;\n\n  if (typeof url !== \'string\') {\n    return url;\n  } // If url is already wrapped in quotes, remove them\n\n\n  if (/^[\'"].*[\'"]$/.test(url)) {\n    // eslint-disable-next-line no-param-reassign\n    url = url.slice(1, -1);\n  }\n\n  if (options.hash) {\n    // eslint-disable-next-line no-param-reassign\n    url += options.hash;\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/["\'() \\t\\n]/.test(url) || options.needQuotes) {\n    return "\\"".concat(url.replace(/"/g, \'\\\\"\').replace(/\\n/g, \'\\\\n\'), "\\"");\n  }\n\n  return url;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzPzFkZTUiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVybCIsIm9wdGlvbnMiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsInRlc3QiLCJzbGljZSIsImhhc2giLCJuZWVkUXVvdGVzIiwiY29uY2F0IiwicmVwbGFjZSJdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWJBLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixVQUFVQyxHQUFWLEVBQWVDLE9BQWYsRUFBd0I7RUFDdkMsSUFBSSxDQUFDQSxPQUFMLEVBQWM7SUFDWjtJQUNBQSxPQUFPLEdBQUcsRUFBVjtFQUNELENBSnNDLENBSXJDOzs7RUFHRkQsR0FBRyxHQUFHQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0UsVUFBWCxHQUF3QkYsR0FBRyxDQUFDRyxPQUE1QixHQUFzQ0gsR0FBNUM7O0VBRUEsSUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7SUFDM0IsT0FBT0EsR0FBUDtFQUNELENBWHNDLENBV3JDOzs7RUFHRixJQUFJLGVBQWVJLElBQWYsQ0FBb0JKLEdBQXBCLENBQUosRUFBOEI7SUFDNUI7SUFDQUEsR0FBRyxHQUFHQSxHQUFHLENBQUNLLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBQyxDQUFkLENBQU47RUFDRDs7RUFFRCxJQUFJSixPQUFPLENBQUNLLElBQVosRUFBa0I7SUFDaEI7SUFDQU4sR0FBRyxJQUFJQyxPQUFPLENBQUNLLElBQWY7RUFDRCxDQXRCc0MsQ0FzQnJDO0VBQ0Y7OztFQUdBLElBQUksY0FBY0YsSUFBZCxDQUFtQkosR0FBbkIsS0FBMkJDLE9BQU8sQ0FBQ00sVUFBdkMsRUFBbUQ7SUFDakQsT0FBTyxLQUFLQyxNQUFMLENBQVlSLEdBQUcsQ0FBQ1MsT0FBSixDQUFZLElBQVosRUFBa0IsS0FBbEIsRUFBeUJBLE9BQXpCLENBQWlDLEtBQWpDLEVBQXdDLEtBQXhDLENBQVosRUFBNEQsSUFBNUQsQ0FBUDtFQUNEOztFQUVELE9BQU9ULEdBQVA7QUFDRCxDQS9CRCIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgb3B0aW9ucyA9IHt9O1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tcGFyYW0tcmVhc3NpZ25cblxuXG4gIHVybCA9IHVybCAmJiB1cmwuX19lc01vZHVsZSA/IHVybC5kZWZhdWx0IDogdXJsO1xuXG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB1cmw7XG4gIH0gLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXG5cblxuICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGFzaCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHVybCArPSBvcHRpb25zLmhhc2g7XG4gIH0gLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuXG5cbiAgaWYgKC9bXCInKCkgXFx0XFxuXS8udGVzdCh1cmwpIHx8IG9wdGlvbnMubmVlZFF1b3Rlcykge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQodXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJyksIFwiXFxcIlwiKTtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "layers.png?416d91365b44e4b4f4777663e6f009f3");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9sYXllcnMucG5nP2YwYzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBZSxvRkFBdUIsZ0RBQWdEIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImxheWVycy5wbmc/NDE2ZDkxMzY1YjQ0ZTRiNGY0Nzc3NjYzZTZmMDA5ZjNcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///32\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "layers-2x.png?8f2c4d11474275fbc1614b9098334eae");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9sYXllcnMtMngucG5nP2UxMjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBZSxvRkFBdUIsbURBQW1EIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImxheWVycy0yeC5wbmc/OGYyYzRkMTE0NzQyNzVmYmMxNjE0YjkwOTgzMzRlYWVcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///33\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "marker-icon.png?2b3e1faf89f94a4835397e7a43b4f77d");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi5wbmc/NWM4ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFlLG9GQUF1QixxREFBcUQiLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwibWFya2VyLWljb24ucG5nPzJiM2UxZmFmODlmOTRhNDgzNTM5N2U3YTQzYjRmNzdkXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34\n')},,,,,function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _vue_style_loader_index_js_css_loader_dist_cjs_js_vue_loader_lib_loaders_stylePostLoader_js_vue_dialog_drag_css_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);\n/* harmony import */ var _vue_style_loader_index_js_css_loader_dist_cjs_js_vue_loader_lib_loaders_stylePostLoader_js_vue_dialog_drag_css_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vue_style_loader_index_js_css_loader_dist_cjs_js_vue_loader_lib_loaders_stylePostLoader_js_vue_dialog_drag_css_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_vue_style_loader_index_js_css_loader_dist_cjs_js_vue_loader_lib_loaders_stylePostLoader_js_vue_dialog_drag_css_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWRpYWxvZy1kcmFnL2Rpc3QvdnVlLWRpYWxvZy1kcmFnLmNzcz9kZTk2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUF3TCxDQUFnQixpUUFBRyxFQUFDIiwiZmlsZSI6IjM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi92dWUtZGlhbG9nLWRyYWcuY3NzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vdnVlLWRpYWxvZy1kcmFnLmNzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzJlwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///39\n")},function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(4);\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, ".dialog-drag{-webkit-animation-duration:.2s;-webkit-animation-name:dialog-anim;-webkit-animation-timing-function:ease-in;-webkit-box-shadow:1px 1px 1px rgba(0,0,0,.5);animation-duration:.2s;animation-name:dialog-anim;animation-timing-function:ease-in;background-color:#fff;border:2px solid #1aad8d;box-shadow:1px 1px 1px rgba(0,0,0,.5);height:auto;position:absolute;width:auto;z-index:101}.dialog-drag .dialog-header{background-color:#1aad8d;color:#fff;font-size:.9em;padding:.25em 3em .25em 1em;position:relative;text-align:left;width:auto}.dialog-drag .dialog-header .buttons{margin:.25em .25em 0 0;position:absolute;right:0;top:0;z-index:105}.dialog-drag .dialog-header button.close,.dialog-drag .dialog-header button.pin{-webkit-box-shadow:none;background:transparent;border:none;box-shadow:none;color:#fff}.dialog-drag .dialog-header button.close:hover,.dialog-drag .dialog-header button.pin:hover{color:#e3a826}.dialog-drag .dialog-header button.close:after{content:\\"\\\\2716\\"}.dialog-drag .dialog-header button.pin:after{content:\\"\\\\1F513\\"}.dialog-drag .dialog-body{padding:1em}.dialog-drag.fixed{-moz-user-select:auto;-ms-user-select:auto;-webkit-user-select:auto;border-color:#e3a826;user-select:auto}.dialog-drag.fixed button.pin{font-weight:700}.dialog-drag.fixed button.pin:after{content:\\"\\\\1F512\\"}@-webkit-keyframes dialog-anim{0%{-webkit-transform:scaleX(.1);opacity:0;transform:scaleX(.1)}50%{-webkit-transform:rotate(1deg);transform:rotate(1deg)}to{opacity:1}}@keyframes dialog-anim{0%{-webkit-transform:scaleX(.1);opacity:0;transform:scaleX(.1)}50%{-webkit-transform:rotate(1deg);transform:rotate(1deg)}to{opacity:1}}", ""]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWRpYWxvZy1kcmFnL2Rpc3QvdnVlLWRpYWxvZy1kcmFnLmNzcz8wOGYxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsQ0FBc0M7QUFDaEY7QUFDQTtBQUNBLGNBQWMsUUFBUyxnQkFBZ0IsK0JBQStCLG1DQUFtQywwQ0FBMEMsOENBQThDLHVCQUF1QiwyQkFBMkIsa0NBQWtDLHNCQUFzQix5QkFBeUIsc0NBQXNDLFlBQVksa0JBQWtCLFdBQVcsWUFBWSw0QkFBNEIseUJBQXlCLFdBQVcsZUFBZSw0QkFBNEIsa0JBQWtCLGdCQUFnQixXQUFXLHFDQUFxQyx1QkFBdUIsa0JBQWtCLFFBQVEsTUFBTSxZQUFZLGdGQUFnRix3QkFBd0IsdUJBQXVCLFlBQVksZ0JBQWdCLFdBQVcsNEZBQTRGLGNBQWMsK0NBQStDLG1CQUFtQiw2Q0FBNkMsb0JBQW9CLDBCQUEwQixZQUFZLG1CQUFtQixzQkFBc0IscUJBQXFCLHlCQUF5QixxQkFBcUIsaUJBQWlCLDhCQUE4QixnQkFBZ0Isb0NBQW9DLG9CQUFvQiwrQkFBK0IsR0FBRyw2QkFBNkIsVUFBVSxxQkFBcUIsSUFBSSwrQkFBK0IsdUJBQXVCLEdBQUcsV0FBVyx1QkFBdUIsR0FBRyw2QkFBNkIsVUFBVSxxQkFBcUIsSUFBSSwrQkFBK0IsdUJBQXVCLEdBQUcsV0FBVztBQUMvbkQ7QUFDQSIsImZpbGUiOiI0MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5kaWFsb2ctZHJhZ3std2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjouMnM7LXdlYmtpdC1hbmltYXRpb24tbmFtZTpkaWFsb2ctYW5pbTstd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbjstd2Via2l0LWJveC1zaGFkb3c6MXB4IDFweCAxcHggcmdiYSgwLDAsMCwuNSk7YW5pbWF0aW9uLWR1cmF0aW9uOi4yczthbmltYXRpb24tbmFtZTpkaWFsb2ctYW5pbTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW47YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoycHggc29saWQgIzFhYWQ4ZDtib3gtc2hhZG93OjFweCAxcHggMXB4IHJnYmEoMCwwLDAsLjUpO2hlaWdodDphdXRvO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOmF1dG87ei1pbmRleDoxMDF9LmRpYWxvZy1kcmFnIC5kaWFsb2ctaGVhZGVye2JhY2tncm91bmQtY29sb3I6IzFhYWQ4ZDtjb2xvcjojZmZmO2ZvbnQtc2l6ZTouOWVtO3BhZGRpbmc6LjI1ZW0gM2VtIC4yNWVtIDFlbTtwb3NpdGlvbjpyZWxhdGl2ZTt0ZXh0LWFsaWduOmxlZnQ7d2lkdGg6YXV0b30uZGlhbG9nLWRyYWcgLmRpYWxvZy1oZWFkZXIgLmJ1dHRvbnN7bWFyZ2luOi4yNWVtIC4yNWVtIDAgMDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowO3otaW5kZXg6MTA1fS5kaWFsb2ctZHJhZyAuZGlhbG9nLWhlYWRlciBidXR0b24uY2xvc2UsLmRpYWxvZy1kcmFnIC5kaWFsb2ctaGVhZGVyIGJ1dHRvbi5waW57LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7YmFja2dyb3VuZDp0cmFuc3BhcmVudDtib3JkZXI6bm9uZTtib3gtc2hhZG93Om5vbmU7Y29sb3I6I2ZmZn0uZGlhbG9nLWRyYWcgLmRpYWxvZy1oZWFkZXIgYnV0dG9uLmNsb3NlOmhvdmVyLC5kaWFsb2ctZHJhZyAuZGlhbG9nLWhlYWRlciBidXR0b24ucGluOmhvdmVye2NvbG9yOiNlM2E4MjZ9LmRpYWxvZy1kcmFnIC5kaWFsb2ctaGVhZGVyIGJ1dHRvbi5jbG9zZTphZnRlcntjb250ZW50OlxcXCJcXFxcMjcxNlxcXCJ9LmRpYWxvZy1kcmFnIC5kaWFsb2ctaGVhZGVyIGJ1dHRvbi5waW46YWZ0ZXJ7Y29udGVudDpcXFwiXFxcXDFGNTEzXFxcIn0uZGlhbG9nLWRyYWcgLmRpYWxvZy1ib2R5e3BhZGRpbmc6MWVtfS5kaWFsb2ctZHJhZy5maXhlZHstbW96LXVzZXItc2VsZWN0OmF1dG87LW1zLXVzZXItc2VsZWN0OmF1dG87LXdlYmtpdC11c2VyLXNlbGVjdDphdXRvO2JvcmRlci1jb2xvcjojZTNhODI2O3VzZXItc2VsZWN0OmF1dG99LmRpYWxvZy1kcmFnLmZpeGVkIGJ1dHRvbi5waW57Zm9udC13ZWlnaHQ6NzAwfS5kaWFsb2ctZHJhZy5maXhlZCBidXR0b24ucGluOmFmdGVye2NvbnRlbnQ6XFxcIlxcXFwxRjUxMlxcXCJ9QC13ZWJraXQta2V5ZnJhbWVzIGRpYWxvZy1hbmltezAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlWCguMSk7b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZVgoLjEpfTUwJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMWRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgxZGVnKX10b3tvcGFjaXR5OjF9fUBrZXlmcmFtZXMgZGlhbG9nLWFuaW17MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGVYKC4xKTtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlWCguMSl9NTAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgxZGVnKTt0cmFuc2Zvcm06cm90YXRlKDFkZWcpfXRve29wYWNpdHk6MX19XCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///40\n')},,,,,,,function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;\nvar apply = Function.prototype.apply; // DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\n\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\n\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\n\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\n\nTimeout.prototype.close = function () {\n  this._clearFn.call(scope, this._id);\n}; // Does not start the time, just sets up the members needed.\n\n\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  var msecs = item._idleTimeout;\n\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n}; // setimmediate attaches itself to the global object\n\n\n__webpack_require__(48); // On some exotic environments, it\'s not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\n\n\nexports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;\nexports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz81MTE4Il0sIm5hbWVzIjpbInNjb3BlIiwiZ2xvYmFsIiwic2VsZiIsIndpbmRvdyIsImFwcGx5IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJleHBvcnRzIiwic2V0VGltZW91dCIsIlRpbWVvdXQiLCJjYWxsIiwiYXJndW1lbnRzIiwiY2xlYXJUaW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwidGltZW91dCIsImNsb3NlIiwiaWQiLCJjbGVhckZuIiwiX2lkIiwiX2NsZWFyRm4iLCJ1bnJlZiIsInJlZiIsImVucm9sbCIsIml0ZW0iLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJhY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwicmVxdWlyZSIsInNldEltbWVkaWF0ZSIsImNsZWFySW1tZWRpYXRlIl0sIm1hcHBpbmdzIjoiQUFBQSxrREFBSUEsS0FBSyxHQUFJLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNBLE1BQWxDLElBQ0MsT0FBT0MsSUFBUCxLQUFnQixXQUFoQixJQUErQkEsSUFEaEMsSUFFQUMsTUFGWjtBQUdBLElBQUlDLEtBQUssR0FBR0MsUUFBUSxDQUFDQyxTQUFULENBQW1CRixLQUEvQixDLENBRUE7O0FBRUFHLE9BQU8sQ0FBQ0MsVUFBUixHQUFxQixZQUFXO0VBQzlCLE9BQU8sSUFBSUMsT0FBSixDQUFZTCxLQUFLLENBQUNNLElBQU4sQ0FBV0YsVUFBWCxFQUF1QlIsS0FBdkIsRUFBOEJXLFNBQTlCLENBQVosRUFBc0RDLFlBQXRELENBQVA7QUFDRCxDQUZEOztBQUdBTCxPQUFPLENBQUNNLFdBQVIsR0FBc0IsWUFBVztFQUMvQixPQUFPLElBQUlKLE9BQUosQ0FBWUwsS0FBSyxDQUFDTSxJQUFOLENBQVdHLFdBQVgsRUFBd0JiLEtBQXhCLEVBQStCVyxTQUEvQixDQUFaLEVBQXVERyxhQUF2RCxDQUFQO0FBQ0QsQ0FGRDs7QUFHQVAsT0FBTyxDQUFDSyxZQUFSLEdBQ0FMLE9BQU8sQ0FBQ08sYUFBUixHQUF3QixVQUFTQyxPQUFULEVBQWtCO0VBQ3hDLElBQUlBLE9BQUosRUFBYTtJQUNYQSxPQUFPLENBQUNDLEtBQVI7RUFDRDtBQUNGLENBTEQ7O0FBT0EsU0FBU1AsT0FBVCxDQUFpQlEsRUFBakIsRUFBcUJDLE9BQXJCLEVBQThCO0VBQzVCLEtBQUtDLEdBQUwsR0FBV0YsRUFBWDtFQUNBLEtBQUtHLFFBQUwsR0FBZ0JGLE9BQWhCO0FBQ0Q7O0FBQ0RULE9BQU8sQ0FBQ0gsU0FBUixDQUFrQmUsS0FBbEIsR0FBMEJaLE9BQU8sQ0FBQ0gsU0FBUixDQUFrQmdCLEdBQWxCLEdBQXdCLFlBQVcsQ0FBRSxDQUEvRDs7QUFDQWIsT0FBTyxDQUFDSCxTQUFSLENBQWtCVSxLQUFsQixHQUEwQixZQUFXO0VBQ25DLEtBQUtJLFFBQUwsQ0FBY1YsSUFBZCxDQUFtQlYsS0FBbkIsRUFBMEIsS0FBS21CLEdBQS9CO0FBQ0QsQ0FGRCxDLENBSUE7OztBQUNBWixPQUFPLENBQUNnQixNQUFSLEdBQWlCLFVBQVNDLElBQVQsRUFBZUMsS0FBZixFQUFzQjtFQUNyQ2IsWUFBWSxDQUFDWSxJQUFJLENBQUNFLGNBQU4sQ0FBWjtFQUNBRixJQUFJLENBQUNHLFlBQUwsR0FBb0JGLEtBQXBCO0FBQ0QsQ0FIRDs7QUFLQWxCLE9BQU8sQ0FBQ3FCLFFBQVIsR0FBbUIsVUFBU0osSUFBVCxFQUFlO0VBQ2hDWixZQUFZLENBQUNZLElBQUksQ0FBQ0UsY0FBTixDQUFaO0VBQ0FGLElBQUksQ0FBQ0csWUFBTCxHQUFvQixDQUFDLENBQXJCO0FBQ0QsQ0FIRDs7QUFLQXBCLE9BQU8sQ0FBQ3NCLFlBQVIsR0FBdUJ0QixPQUFPLENBQUN1QixNQUFSLEdBQWlCLFVBQVNOLElBQVQsRUFBZTtFQUNyRFosWUFBWSxDQUFDWSxJQUFJLENBQUNFLGNBQU4sQ0FBWjtFQUVBLElBQUlELEtBQUssR0FBR0QsSUFBSSxDQUFDRyxZQUFqQjs7RUFDQSxJQUFJRixLQUFLLElBQUksQ0FBYixFQUFnQjtJQUNkRCxJQUFJLENBQUNFLGNBQUwsR0FBc0JsQixVQUFVLENBQUMsU0FBU3VCLFNBQVQsR0FBcUI7TUFDcEQsSUFBSVAsSUFBSSxDQUFDUSxVQUFULEVBQ0VSLElBQUksQ0FBQ1EsVUFBTDtJQUNILENBSCtCLEVBRzdCUCxLQUg2QixDQUFoQztFQUlEO0FBQ0YsQ0FWRCxDLENBWUE7OztBQUNBUSxtQkFBTyxDQUFDLEVBQUQsQ0FBUCxDLENBQ0E7QUFDQTtBQUNBOzs7QUFDQTFCLE9BQU8sQ0FBQzJCLFlBQVIsR0FBd0IsT0FBT2hDLElBQVAsS0FBZ0IsV0FBaEIsSUFBK0JBLElBQUksQ0FBQ2dDLFlBQXJDLElBQ0MsT0FBT2pDLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNBLE1BQU0sQ0FBQ2lDLFlBRHpDLElBRUMsUUFBUSxLQUFLQSxZQUZyQztBQUdBM0IsT0FBTyxDQUFDNEIsY0FBUixHQUEwQixPQUFPakMsSUFBUCxLQUFnQixXQUFoQixJQUErQkEsSUFBSSxDQUFDaUMsY0FBckMsSUFDQyxPQUFPbEMsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsTUFBTSxDQUFDa0MsY0FEekMsSUFFQyxRQUFRLEtBQUtBLGNBRnZDLEMiLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///47\n')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n  "use strict";\n\n  if (global.setImmediate) {\n    return;\n  }\n\n  var nextHandle = 1; // Spec says greater than zero\n\n  var tasksByHandle = {};\n  var currentlyRunningATask = false;\n  var doc = global.document;\n  var registerImmediate;\n\n  function setImmediate(callback) {\n    // Callback can either be a function or a string\n    if (typeof callback !== "function") {\n      callback = new Function("" + callback);\n    } // Copy function arguments\n\n\n    var args = new Array(arguments.length - 1);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 1];\n    } // Store and register the task\n\n\n    var task = {\n      callback: callback,\n      args: args\n    };\n    tasksByHandle[nextHandle] = task;\n    registerImmediate(nextHandle);\n    return nextHandle++;\n  }\n\n  function clearImmediate(handle) {\n    delete tasksByHandle[handle];\n  }\n\n  function run(task) {\n    var callback = task.callback;\n    var args = task.args;\n\n    switch (args.length) {\n      case 0:\n        callback();\n        break;\n\n      case 1:\n        callback(args[0]);\n        break;\n\n      case 2:\n        callback(args[0], args[1]);\n        break;\n\n      case 3:\n        callback(args[0], args[1], args[2]);\n        break;\n\n      default:\n        callback.apply(undefined, args);\n        break;\n    }\n  }\n\n  function runIfPresent(handle) {\n    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n    // So if we\'re currently running a task, we\'ll need to delay this invocation.\n    if (currentlyRunningATask) {\n      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n      // "too much recursion" error.\n      setTimeout(runIfPresent, 0, handle);\n    } else {\n      var task = tasksByHandle[handle];\n\n      if (task) {\n        currentlyRunningATask = true;\n\n        try {\n          run(task);\n        } finally {\n          clearImmediate(handle);\n          currentlyRunningATask = false;\n        }\n      }\n    }\n  }\n\n  function installNextTickImplementation() {\n    registerImmediate = function (handle) {\n      process.nextTick(function () {\n        runIfPresent(handle);\n      });\n    };\n  }\n\n  function canUsePostMessage() {\n    // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n    // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n    if (global.postMessage && !global.importScripts) {\n      var postMessageIsAsynchronous = true;\n      var oldOnMessage = global.onmessage;\n\n      global.onmessage = function () {\n        postMessageIsAsynchronous = false;\n      };\n\n      global.postMessage("", "*");\n      global.onmessage = oldOnMessage;\n      return postMessageIsAsynchronous;\n    }\n  }\n\n  function installPostMessageImplementation() {\n    // Installs an event handler on `global` for the `message` event: see\n    // * https://developer.mozilla.org/en/DOM/window.postMessage\n    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n    var messagePrefix = "setImmediate$" + Math.random() + "$";\n\n    var onGlobalMessage = function (event) {\n      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {\n        runIfPresent(+event.data.slice(messagePrefix.length));\n      }\n    };\n\n    if (global.addEventListener) {\n      global.addEventListener("message", onGlobalMessage, false);\n    } else {\n      global.attachEvent("onmessage", onGlobalMessage);\n    }\n\n    registerImmediate = function (handle) {\n      global.postMessage(messagePrefix + handle, "*");\n    };\n  }\n\n  function installMessageChannelImplementation() {\n    var channel = new MessageChannel();\n\n    channel.port1.onmessage = function (event) {\n      var handle = event.data;\n      runIfPresent(handle);\n    };\n\n    registerImmediate = function (handle) {\n      channel.port2.postMessage(handle);\n    };\n  }\n\n  function installReadyStateChangeImplementation() {\n    var html = doc.documentElement;\n\n    registerImmediate = function (handle) {\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n      var script = doc.createElement("script");\n\n      script.onreadystatechange = function () {\n        runIfPresent(handle);\n        script.onreadystatechange = null;\n        html.removeChild(script);\n        script = null;\n      };\n\n      html.appendChild(script);\n    };\n  }\n\n  function installSetTimeoutImplementation() {\n    registerImmediate = function (handle) {\n      setTimeout(runIfPresent, 0, handle);\n    };\n  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\n\n  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don\'t get fooled by e.g. browserify environments.\n\n  if ({}.toString.call(global.process) === "[object process]") {\n    // For Node.js before 0.9\n    installNextTickImplementation();\n  } else if (canUsePostMessage()) {\n    // For non-IE10 modern browsers\n    installPostMessageImplementation();\n  } else if (global.MessageChannel) {\n    // For web workers, where supported\n    installMessageChannelImplementation();\n  } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n    // For IE 6–8\n    installReadyStateChangeImplementation();\n  } else {\n    // For older browsers\n    installSetTimeoutImplementation();\n  }\n\n  attachTo.setImmediate = setImmediate;\n  attachTo.clearImmediate = clearImmediate;\n})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17), __webpack_require__(49)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz82MDE3Il0sIm5hbWVzIjpbImdsb2JhbCIsInVuZGVmaW5lZCIsInNldEltbWVkaWF0ZSIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwiZG9jIiwiZG9jdW1lbnQiLCJyZWdpc3RlckltbWVkaWF0ZSIsImNhbGxiYWNrIiwiRnVuY3Rpb24iLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJpIiwidGFzayIsImNsZWFySW1tZWRpYXRlIiwiaGFuZGxlIiwicnVuIiwiYXBwbHkiLCJydW5JZlByZXNlbnQiLCJzZXRUaW1lb3V0IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjYW5Vc2VQb3N0TWVzc2FnZSIsInBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJNYXRoIiwicmFuZG9tIiwib25HbG9iYWxNZXNzYWdlIiwiZXZlbnQiLCJzb3VyY2UiLCJkYXRhIiwiaW5kZXhPZiIsInNsaWNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwidG9TdHJpbmciLCJjYWxsIiwic2VsZiJdLCJtYXBwaW5ncyI6IkFBQUMsa0VBQVVBLE1BQVYsRUFBa0JDLFNBQWxCLEVBQTZCO0VBQzFCOztFQUVBLElBQUlELE1BQU0sQ0FBQ0UsWUFBWCxFQUF5QjtJQUNyQjtFQUNIOztFQUVELElBQUlDLFVBQVUsR0FBRyxDQUFqQixDQVAwQixDQU9OOztFQUNwQixJQUFJQyxhQUFhLEdBQUcsRUFBcEI7RUFDQSxJQUFJQyxxQkFBcUIsR0FBRyxLQUE1QjtFQUNBLElBQUlDLEdBQUcsR0FBR04sTUFBTSxDQUFDTyxRQUFqQjtFQUNBLElBQUlDLGlCQUFKOztFQUVBLFNBQVNOLFlBQVQsQ0FBc0JPLFFBQXRCLEVBQWdDO0lBQzlCO0lBQ0EsSUFBSSxPQUFPQSxRQUFQLEtBQW9CLFVBQXhCLEVBQW9DO01BQ2xDQSxRQUFRLEdBQUcsSUFBSUMsUUFBSixDQUFhLEtBQUtELFFBQWxCLENBQVg7SUFDRCxDQUo2QixDQUs5Qjs7O0lBQ0EsSUFBSUUsSUFBSSxHQUFHLElBQUlDLEtBQUosQ0FBVUMsU0FBUyxDQUFDQyxNQUFWLEdBQW1CLENBQTdCLENBQVg7O0lBQ0EsS0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHSixJQUFJLENBQUNHLE1BQXpCLEVBQWlDQyxDQUFDLEVBQWxDLEVBQXNDO01BQ2xDSixJQUFJLENBQUNJLENBQUQsQ0FBSixHQUFVRixTQUFTLENBQUNFLENBQUMsR0FBRyxDQUFMLENBQW5CO0lBQ0gsQ0FUNkIsQ0FVOUI7OztJQUNBLElBQUlDLElBQUksR0FBRztNQUFFUCxRQUFRLEVBQUVBLFFBQVo7TUFBc0JFLElBQUksRUFBRUE7SUFBNUIsQ0FBWDtJQUNBUCxhQUFhLENBQUNELFVBQUQsQ0FBYixHQUE0QmEsSUFBNUI7SUFDQVIsaUJBQWlCLENBQUNMLFVBQUQsQ0FBakI7SUFDQSxPQUFPQSxVQUFV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QVAsS0FBZ0IsV0FBaEIsR0FBOEIsT0FBTy9ELE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0MsSUFBaEMsR0FBdUNBLE1BQXJFLEdBQThFK0QsSUF6TC9FLENBQUQsQyIsImZpbGUiOiI0OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///48\n')},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImxlbmd0aCIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJpIiwicHVzaCIsIkl0ZW0iLCJhcnJheSIsInByb3RvdHlwZSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJuYW1lIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSUEsT0FBTyxHQUFHQyxNQUFNLENBQUNDLE9BQVAsR0FBaUIsRUFBL0IsQyxDQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUlDLGdCQUFKO0FBQ0EsSUFBSUMsa0JBQUo7O0FBRUEsU0FBU0MsZ0JBQVQsR0FBNEI7RUFDeEIsTUFBTSxJQUFJQyxLQUFKLENBQVUs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QVIsR0FBY0osSUFBZDtBQUNBM0MsT0FBTyxDQUFDZ0QsY0FBUixHQUF5QkwsSUFBekI7QUFDQTNDLE9BQU8sQ0FBQ2lELGtCQUFSLEdBQTZCTixJQUE3QjtBQUNBM0MsT0FBTyxDQUFDa0QsSUFBUixHQUFlUCxJQUFmO0FBQ0EzQyxPQUFPLENBQUNtRCxlQUFSLEdBQTBCUixJQUExQjtBQUNBM0MsT0FBTyxDQUFDb0QsbUJBQVIsR0FBOEJULElBQTlCOztBQUVBM0MsT0FBTyxDQUFDcUQsU0FBUixHQUFvQixVQUFVQyxJQUFWLEVBQWdCO0VBQUUsT0FBTyxFQUFQO0FBQVcsQ0FBakQ7O0FBRUF0RCxPQUFPLENBQUN1RCxPQUFSLEdBQWtCLFVBQVVELElBQVYsRUFBZ0I7RUFDOUIsTUFBTSxJQUFJaEQsS0FBSixDQUFVLGtDQUFWLENBQU47QUFDSCxDQUZEOztBQUlBTixPQUFPLENBQUN3RCxHQUFSLEdBQWMsWUFBWTtFQUFFLE9BQU8sR0FBUDtBQUFZLENBQXhDOztBQUNBeEQsT0FBTyxDQUFDeUQsS0FBUixHQUFnQixVQUFVQyxHQUFWLEVBQWU7RUFDM0IsTUFBTSxJQUFJcEQsS0FBSixDQUFVLGdDQUFWLENBQU47QUFDSCxDQUZEOztBQUdBTixPQUFPLENBQUMyRCxLQUFSLEdBQWdCLFlBQVc7RUFBRSxPQUFPLENBQVA7QUFBVyxDQUF4QyIsImZpbGUiOiI0OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///49\n")}]]);