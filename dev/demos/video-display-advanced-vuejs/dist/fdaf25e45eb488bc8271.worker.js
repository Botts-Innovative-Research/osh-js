!function(Q){var B={};function F(I){if(B[I])return B[I].exports;var U=B[I]={i:I,l:!1,exports:{}};return Q[I].call(U.exports,U,U.exports,F),U.l=!0,U.exports}F.m=Q,F.c=B,F.d=function(Q,B,I){F.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:I})},F.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},F.t=function(Q,B){if(1&B&&(Q=F(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var I=Object.create(null);if(F.r(I),Object.defineProperty(I,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var U in Q)F.d(I,U,function(B){return Q[B]}.bind(null,U));return I},F.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return F.d(B,"a",B),B},F.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},F.p="",F(F.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH2/github/osh-js/source/core/Constants.js\nconst DATA_SYNCHRONIZER_TOPIC = 'data-synchronizer-';\nconst TIME_SYNCHRONIZER_TOPIC = 'data-synchronizer-time-';\nconst DATASOURCE_DATA_TOPIC = 'datasource-data-';\nconst DATASOURCE_TIME_TOPIC = 'datasource-time-';\nconst FFMPEG_VIEW_DECODE_TOPIC = 'ffmpeg-decode-';\nconst MAGIC_END_PACKET = 'magic-packet';\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH2/github/osh-js/source/core/event/EventType.js\nconst EventType = {\n  DATA: 'data',\n  LAST_TIME: 'last-time',\n  MASTER_TIME: 'master-time',\n  STATUS: 'status',\n  TIME_CHANGED: 'time-changed',\n  CLOSED: 'closed'\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH2/github/osh-js/source/core/utils/Utils.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n/** * @module Utils */\n\n/** Maximum value of a long */\nconst MAX_LONG = Math.pow(2, 53) + 1;\n/**\n * Global helper method to test if a letiable or object attribute is defined\n */\n\nfunction isDefined(v) {\n  return typeof v !== 'undefined' && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute has a value,\n that is it is defined and non null\n */\n\nfunction hasValue(v) {\n  return isDefined(v) && v !== null;\n}\n/**\n Global helper method to transform hex color into RGB\n */\n\nfunction hex2rgb(hex) {\n  const [r, g, b] = hex.match(/\\w\\w/g).map(x => parseInt(x, 16));\n  return [r, g, b];\n}\nfunction hex2rgba(hex) {\n  return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16), parseInt(hex.slice(7, 9), 16) / 255];\n}\n/**\n Global helper method to test if a letiable or object attribute is of a particular type\n */\n\nfunction hasType(v, expectedType) {\n  let hasVal = hasValue(v);\n  return hasVal && typeof v === expectedType;\n}\n/**\n Global helper method to test if a letiable or object attribute is an object\n */\n\nfunction isObject(v, letName) {\n  return hasType(v, 'object', letName);\n}\n/**\n Global helper method to test if a letiable or object attribute is an array\n */\n\nfunction isArray(v) {\n  return isDefined(v) && Array.isArray(v);\n}\n/**\n Global helper method to test if a letiable or object attribute is a function\n */\n\nfunction isFunction(v, letName) {\n  return hasType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined\n **/\n\nfunction assertDefined(v, letName = 'letiable') {\n  if (!isDefined(v)) {\n    throw letName + \" must be defined\";\n  }\n\n  return v;\n}\nfunction assertTrue(v, letName = 'letiable') {\n  if (!isDefined(v) || !v) {\n    throw letName;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertType(v, expectedType, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (typeof v !== expectedType) {\n    throw letName + \" must be of type \" + expectedType;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertBoolean(v, letName) {\n  return assertType(v, 'boolean', letName);\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertString(v, letName) {\n  return assertType(v, 'string', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertNumber(v, letName) {\n  return assertType(v, 'number', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertPositive(v, letName) {\n  assertNumber(v, letName);\n\n  if (v <= 0) {\n    throw letName + \" must be a positive number\";\n  }\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertObject(v, letName) {\n  return assertType(v, 'object', letName);\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertArray(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!Array.isArray(v)) {\n    throw letName + \" must be an array\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a function\n **/\n\nfunction assertFunction(v, letName) {\n  return assertType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertHasValue(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!hasValue(v)) {\n    throw letName + \" must not be null\";\n  }\n\n  return v;\n}\n/**\n *\n * @return {String}\n */\n\nfunction randomUUID() {\n  return 'xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * This function stamps/embeds a UUID into an object and returns the UUID generated for it\n * @return {String}\n */\n\nfunction stampUUID(obj) {\n  obj._osh_id = obj._osh_id || randomUUID();\n  return obj._osh_id;\n} //buffer is an ArrayBuffer object, the offset if specified in bytes, and the type is a string\n//corresponding to an OGC data type.\n//See http://def.seegrid.csiro.au/sissvoc/ogc-def/resource?uri=http://www.opengis.net/def/dataType/OGC/0/\n\n/**\n *\n * @param buffer\n * @param offset\n * @param type\n * @return {*}\n */\n\nfunction ParseBytes(buffer, offset, type) {\n  let view = new DataView(buffer); //Note: There exist types not listed in the map below that have OGC definitions, but no appropriate\n  //methods or corresponding types available for parsing in javascript. They are float128, float16, signedLong,\n  //and unsignedLong\n\n  let typeMap = {\n    double: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float64: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float32: function (offset) {\n      return {\n        val: view.getFloat32(offset),\n        bytes: 4\n      };\n    },\n    signedByte: function (offset) {\n      return {\n        val: view.getInt8(offset),\n        bytes: 1\n      };\n    },\n    signedInt: function (offset) {\n      return {\n        val: view.getInt32(offset),\n        bytes: 4\n      };\n    },\n    signedShort: function (offset) {\n      return {\n        val: view.getInt16(offset),\n        bytes: 2\n      };\n    },\n    unsignedByte: function (offset) {\n      return {\n        val: view.getUint8(offset),\n        bytes: 1\n      };\n    },\n    unsignedInt: function (offset) {\n      return {\n        val: view.getUint32(offset),\n        bytes: 4\n      };\n    },\n    unsignedShort: function (offset) {\n      return {\n        val: view.getUint16(offset),\n        bytes: 2\n      };\n    } //TODO: string-utf-8:\n\n  };\n  return typeMap[type](offset);\n} //This function recursivley iterates over the resultStructure to fill in\n//values read from data which should be an ArrayBuffer containing the payload from a websocket\n\n/**\n *\n * @param struct\n * @param data\n * @param offsetBytes\n * @return {*}\n */\n\nfunction ReadData(struct, data, offsetBytes) {\n  let offset = offsetBytes;\n\n  for (let i = 0; i < struct.fields.length; i++) {\n    let currFieldStruct = struct.fields[i];\n\n    if (isDefined(currFieldStruct.type) && currFieldStruct.type !== null) {\n      let ret = ParseBytes(data, offset, currFieldStruct.type);\n      currFieldStruct.val = ret.val;\n      offset += ret.bytes;\n    } else if (isDefined(currFieldStruct.count) && currFieldStruct.count !== null) {\n      //check if count is a reference to another letiable\n      if (isNaN(currFieldStruct.count)) {\n        let id = currFieldStruct.count;\n        let fieldName = struct.id2FieldMap[id];\n        currFieldStruct.count = struct.findFieldByName(fieldName).val;\n      }\n\n      for (let c = 0; c < currFieldStruct.count; c++) {\n        for (let j = 0; j < currFieldStruct.fields.length; j++) {\n          let field = JSON.parse(JSON.stringify(currFieldStruct.fields[j]));\n          offset = ReadData(field, data, offset);\n          currFieldStruct.val.push(field);\n        }\n      }\n    }\n  }\n\n  return offset;\n}\n/**\n *\n * @param resultStructure\n * @return {{}}\n */\n\nfunction GetResultObject(resultStructure) {\n  //TODO: handle cases for nested arrays / matrix data types\n  let result = {};\n\n  for (let i = 0; i < resultStructure.fields.length; i++) {\n    if (isDefined(resultStructure.fields[i].count)) {\n      result[resultStructure.fields[i].name] = [];\n\n      for (let c = 0; c < resultStructure.fields[i].count; c++) {\n        let item = {};\n\n        for (let k = 0; k < resultStructure.fields[i].val[c].fields.length; k++) {\n          item[resultStructure.fields[i].val[c].fields[k].name] = resultStructure.fields[i].val[c].fields[k].val;\n        }\n\n        result[resultStructure.fields[i].name].push(item);\n      }\n    } else {\n      result[resultStructure.fields[i].name] = resultStructure.fields[i].val;\n    }\n  }\n\n  return result;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isOpera() {\n  return !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isFirefox() {\n  return typeof InstallTrigger !== 'undefined';\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isSafari() {\n  return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isChrome() {\n  return !!window.chrome && !!window.chrome.webstore;\n}\n/**\n *\n * @return {*|boolean}\n */\n\nfunction isBlink() {\n  return (isChrome || isOpera) && !!window.CSS;\n}\n/**\n *\n * @param a\n * @param b\n * @return {boolean}\n */\n\nfunction isArrayIntersect(a, b) {\n  return a.filter(function (element) {\n    return b.indexOf(element) > -1;\n  }).length > 0;\n}\n/**\n *\n * @param o\n * @return {boolean}\n */\n\nfunction isElement(o) {\n  return typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n  o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n}\n/**\n *\n * @return {*}\n */\n\nfunction isWebWorker() {\n  return isDefined(Worker);\n}\n/**\n *\n * @param div\n */\n\nfunction takeScreenShot(div) {}\n/**\n * Remove a css class from a the div given as argument.\n * @param div the div to remove the class from\n * @param css the css class to remove\n */\n\nfunction removeCss(div, css) {\n  let divCss = div.className;\n  css = divCss.replace(css, \"\");\n  div.className = css;\n}\n/**\n * Add a css class to a the div given as argument.\n * @param div the div to add the class to\n * @param css the css class to add\n */\n\nfunction addCss(div, css) {\n  div.setAttribute(\"class\", div.className + \" \" + css);\n}\n/**\n * Removes the last character of a {string} object.\n * @param {string} value - The input {string}\n * @return {string} The value without the last character\n */\n\nfunction removeLastCharIfExist(value) {\n  if (!isDefined(undefined) || value === null || value.length === 0 || !value.endsWith(\"/\")) {\n    return value;\n  }\n\n  return value.substring(0, value.length - 1);\n}\n/**\n * Capitalize the first letter of a given string\n * @param {String} str - the input string\n * @returns {String} the result\n */\n\nfunction capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n/**\n * Round off number to nearest 0.5\n * @param {Number} num - The number to round off\n * @return {number} The rounded number\n */\n\nfunction roundHalf(num) {\n  return Math.round(num * 2) / 2;\n}\n/**\n * Returns a function that, as long as it continues to be invoked,\n * will not be executed. The function will only be executed when\n * it will stop being called for more than N milliseconds.\n * If the `immediate` parameter is true, then the function\n * will be executed at the first call instead of the last.\n * Parameters :\n * - func: the function to `debouncer`.\n * - wait: the number of milliseconds (N) to wait before\n * call func()\n * - immediate (optional): Call func() at the first invocation\n * instead of the last one (Default false)\n * - context (optional): the context in which to call func()\n * (this by default)\n */\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n\nfunction debounce(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n\n  var later = function () {\n    var now = new Date().getTime(),\n        last = now - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = new Date().getTime();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n}\n;\nfunction throttle(func, wait, leading, trailing, context) {\n  var ctx, args, result;\n  var timeout = null;\n  var previous = 0;\n\n  var later = function () {\n    previous = new Date();\n    timeout = null;\n    result = func.apply(ctx, args);\n  };\n\n  return function () {\n    var now = new Date();\n    if (!previous && !leading) previous = now;\n    var remaining = wait - (now - previous);\n    ctx = context || this;\n    args = arguments;\n\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(ctx, args);\n    } else if (!timeout && trailing) {\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n;\nfunction merge(target, source) {\n  // Iterate through `source` properties and if an `Object` set property to merge of `target` and `source` properties\n  for (const key of Object.keys(source)) {\n    if (source[key] instanceof Object && key in target) Object.assign(source[key], merge(target[key], source[key]));\n  } // Join `target` and modified `source`\n\n\n  Object.assign(target || {}, source);\n  return target;\n}\n;\nfunction rgbaToArray(str) {\n  let startIdxValue = str.indexOf('(') + 1;\n  let endIdxValue = str.indexOf(')');\n  let values = str.substr(startIdxValue, endIdxValue - startIdxValue);\n  return values.split(',').map(Number);\n}\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH2/github/osh-js/source/core/connector/Status.js\n/**\n * Enum for connection status.\n * @readonly\n * @enum {{name: string}}\n */\nconst Status = {\n  CONNECTING: \"connecting\",\n  CONNECTED: \"connected\",\n  DISCONNECTED: \"disconnected\",\n  FETCH_STARTED: 'fetch-start',\n  FETCH_ENDED: 'fetch-end',\n  CLOSED: \"closed\",\n  CLOSED_ERROR: \"closed-error\"\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH2/github/osh-js/source/core/timesync/DataSynchronizerAlgo.js\n\n\n\nclass DataSynchronizerAlgo_DataSynchronizerAlgo {\n  constructor(dataSources, timerResolution = 5) {\n    this.dataSourceMap = {};\n    this.tsRun = undefined;\n    this.timerResolution = timerResolution;\n    this.interval = null;\n    this.datasources = [];\n\n    for (let ds of dataSources) {\n      this.addDataSource(ds);\n    }\n  }\n\n  removeDataSource(dataSourceId) {\n    this.datasources = this.datasources.filter(elt => elt.id !== dataSourceId);\n    delete this.dataSourceMap[dataSourceId];\n  }\n\n  push(dataSourceId, dataBlocks) {}\n\n  getCurrentTimestamp() {\n    return this.tsRun;\n  }\n\n  processData() {\n    let tsRef = -1;\n    let clockTimeRef = performance.now(); // get reference start timestamp\n    // the reference start timestamp should the oldest one\n\n    let currentDs;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.dataBuffer.length > 0) {\n        tsRef = tsRef === -1 || currentDs.dataBuffer[0].data.timestamp < tsRef ? currentDs.dataBuffer[0].data.timestamp : tsRef;\n      }\n    }\n\n    this.interval = setInterval(() => {\n      // 1) return the oldest data if any\n      while (this.computeNextData(tsRef, clockTimeRef));\n    }, this.timerResolution);\n    console.warn(`Started Algorithm ${this.constructor.name} with  tsRef=${new Date(tsRef).toISOString()}`);\n  }\n  /**\n   * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,\n   * we return only the oldest one.\n   * @param tsRef - the timestamp of the first data\n   * @param refClockTime - the absolute diff time really spent\n   */\n\n\n  computeNextData(tsRef, refClockTime) {\n    throw Error('Should be overridden');\n  }\n  /**\n   * Add dataSource to be synchronized\n   * @param {Datasource} dataSource - the dataSource to synchronize\n   */\n\n\n  addDataSource(dataSource) {\n    throw Error('Should be overridden');\n  }\n\n  checkVersion(datasource, dataBlock) {\n    throw Error('Should be overridden');\n  }\n\n  onData(dataSourceId, dataBlock) {}\n\n  checkStart() {}\n  /**\n   * Change the dataSource status\n   * @param {Status} status - the new status\n   * @param {String} dataSourceId - the corresponding dataSource id\n   */\n\n\n  setStatus(dataSourceId, status) {\n    throw Error('Should be overridden');\n  }\n\n  close() {\n    if (isDefined(this.interval)) {\n      clearInterval(this.interval);\n      this.interval = undefined;\n    }\n\n    console.log(\"Data synchronizer terminated successfully\");\n    this.onClose();\n  }\n\n  onStart() {}\n\n  onClose() {}\n\n}\n\n/* harmony default export */ var timesync_DataSynchronizerAlgo = (DataSynchronizerAlgo_DataSynchronizerAlgo);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH2/github/osh-js/source/core/timesync/rt/DataSynchronizerAlgo.realtime.js\n\n\n\n\nclass DataSynchronizerAlgo_realtime_DataSynchronizerAlgoRealtime extends timesync_DataSynchronizerAlgo {\n  push(dataSourceId, dataBlocks) {\n    if (dataBlocks.length === 0) {\n      return;\n    }\n\n    const ds = this.dataSourceMap[dataSourceId];\n    const lastData = dataBlocks[dataBlocks.length - 1];\n\n    if (!this.checkVersion(ds, lastData)) {\n      return;\n    }\n\n    let latency = 0;\n\n    if (this.tsRun > 0) {\n      latency = this.tsRun - lastData.data.timestamp;\n    }\n\n    ds.latency = latency > ds.latency ? latency : (ds.latency + latency) / 2;\n    ds.dataBuffer.push(...dataBlocks);\n\n    if (!isDefined(this.interval)) {\n      this.processData();\n    }\n  }\n  /**\n   * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,\n   * we return only the oldest one.\n   * @param tsRef - the timestamp of the first data\n   * @param refClockTime - the absolute diff time really spent\n   */\n\n\n  computeNextData(tsRef, refClockTime) {\n    let currentDs;\n    let currentDsToShift = null; // compute max latency\n\n    let maxLatency = 0;\n    let minLatency = 0;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.latency > 0) {\n        let latency = Math.min(currentDs.latency, currentDs.timeOut);\n        maxLatency = latency > maxLatency ? latency : maxLatency;\n        minLatency = currentDs.latency < minLatency ? currentDs.latency : minLatency;\n      }\n    }\n\n    const dClock = performance.now() - refClockTime; // compute next data to return\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n      this.tsRun = tsRef + dClock;\n\n      if (currentDs.dataBuffer.length > 0) {\n        const dTs = currentDs.dataBuffer[0].data.timestamp - tsRef;\n        const dClockAdj = dClock - maxLatency; // we use an intermediate object to store the data to shift because we want to return the oldest one\n        // only\n\n        if (dTs <= dClockAdj) {\n          // no other one to compare\n          if (currentDsToShift === null) {\n            currentDsToShift = currentDs;\n          } else {\n            // take the oldest data\n            currentDsToShift = currentDsToShift.dataBuffer[0].data.timestamp < currentDs.dataBuffer[0].data.timestamp ? currentDsToShift : currentDs;\n          }\n        }\n      }\n    } // finally pop the data from DS queue\n\n\n    if (currentDsToShift !== null) {\n      let rec = currentDsToShift.dataBuffer.shift(); // add latency flag to data record before we dispatch it\n      // this is relative latency in millis compared to the DS with the lowest latency\n      // so it is accurate even if local device time is not set properly\n\n      rec['@latency'] = currentDs.latency - minLatency;\n      this.onData(currentDsToShift.id, rec);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Add dataSource to be synchronized\n   * @param {Datasource} dataSource - the dataSource to synchronize\n   */\n\n\n  addDataSource(dataSource) {\n    this.dataSourceMap[dataSource.id] = {\n      timeOut: dataSource.timeOut || 0,\n      dataBuffer: [],\n      id: dataSource.id,\n      timedOut: false,\n      name: dataSource.name || dataSource.id,\n      latency: 0,\n      status: Status.DISCONNECTED,\n      //MEANING Enabled, 0 = Disabled\n      version: undefined\n    };\n    this.datasources.push(dataSource);\n  }\n\n  checkVersion(datasource, dataBlock) {\n    if (datasource.status !== Status.DISCONNECTED) {\n      return true;\n    } else if (datasource.status === Status.DISCONNECTED && datasource.version !== dataBlock.version) {\n      return false;\n    }\n  }\n  /**\n   * Change the dataSource status\n   * @param {Status} status - the new status\n   * @param {String} dataSourceId - the corresponding dataSource id\n   */\n\n\n  setStatus(dataSourceId, status) {\n    if (dataSourceId in this.dataSourceMap) {\n      this.dataSourceMap[dataSourceId].status = status;\n      console.warn(status + ' DataSource ' + dataSourceId + ' from the synchronizer ');\n    }\n  }\n\n  reset() {\n    this.tsRun = undefined;\n    console.log('reset synchronizer algo');\n    this.close();\n\n    for (let currentDsId in this.dataSourceMap) {\n      this.resetDataSource(currentDsId);\n    }\n  }\n\n  resetDataSource(datasourceId) {\n    const currentDs = this.dataSourceMap[datasourceId];\n    currentDs.dataBuffer = [];\n    currentDs.startBufferingTime = -1;\n    currentDs.latency = 0;\n    currentDs.status = Status.DISCONNECTED;\n    currentDs.version = undefined;\n  }\n\n}\n\n/* harmony default export */ var DataSynchronizerAlgo_realtime = (DataSynchronizerAlgo_realtime_DataSynchronizerAlgoRealtime);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH2/github/osh-js/source/core/timesync/rt/DataSynchronizer.realtime.worker.js\n\n\n\n\n\nconst bcChannels = {};\nlet dataSynchronizerAlgo;\n\nlet init = false;\nlet dataSynchronizerBroadCastChannel = null;\nlet DataSynchronizer_realtime_worker_lastData = undefined;\nconst dataSources = {};\nlet timeBroadcastChannel = null;\nlet topicTime;\nlet topicData;\nlet masterTimeInterval = undefined;\nlet cTime;\nlet cId;\nlet lastTime = -1;\nlet version = -1;\nlet promise;\nlet DataSynchronizer_realtime_worker_masterTimeRefreshRate;\n\nself.onmessage = async (event) => {\n    handleMessage(event);\n}\n\nasync function handleMessage(event) {\n    let resp = {};\n    if (event.data.ackId) {\n        resp.ackId = event.data.ackId;\n    }\n\n    let data = undefined;\n    try {\n        if (event.data.message === 'init') {\n            version = event.data.version;\n\n            dataSynchronizerAlgo = new DataSynchronizerAlgo_realtime(\n                event.data.dataSources,\n                event.data.replaySpeed,\n                event.data.timerResolution\n            );\n            dataSynchronizerAlgo.onData = onData;\n            init = true;\n            addDataSources(event.data.dataSources);\n            topicData = event.data.topics.data;\n            topicTime = event.data.topics.time;\n            initBroadcastChannel(topicData, topicTime);\n            DataSynchronizer_realtime_worker_masterTimeRefreshRate = event.data.masterTimeRefreshRate;\n        } else if (event.data.message === 'add' && event.data.dataSources) {\n            console.log('Add datasource to synchronizer..')\n            addDataSources(event.data.dataSources);\n        } else if (event.data.message === 'connect') {\n            startMasterTimeInterval(DataSynchronizer_realtime_worker_masterTimeRefreshRate);\n            dataSynchronizerAlgo.checkStart();\n            version = event.data.version;\n        } else if (event.data.message === 'is-connected') {\n            data = {\n                message: 'is-connected',\n                data: isDefined(masterTimeInterval)\n            };\n        } else if (event.data.message === 'remove' && event.data.dataSourceIds) {\n            console.log('Remove datasource from synchronizer..')\n            await removeDataSources(event.data.dataSourceIds);\n        } else if (event.data.message === 'current-time') {\n            data = {\n                message: 'current-time',\n                data: dataSynchronizerAlgo.getCurrentTimestamp()\n            };\n        } else if (event.data.message === 'reset') {\n            DataSynchronizer_realtime_worker_reset();\n        } else if (event.data.message === 'replay-speed') {\n            if (dataSynchronizerAlgo !== null) {\n                DataSynchronizer_realtime_worker_reset();\n            }\n        } else if (event.data.message === 'data') {\n            checkMasterTime();\n            if (dataSynchronizerAlgo !== null) {\n                dataSynchronizerAlgo.push(event.data.dataSourceId, event.data.data);\n            }\n        }\n    } catch (ex) {\n        console.error(ex);\n        resp.error = ex;\n    } finally {\n        resp.data = data;\n        self.postMessage(resp);\n    }\n\n}\n\nfunction DataSynchronizer_realtime_worker_reset() {\n    clearInterval(masterTimeInterval);\n    masterTimeInterval = undefined;\n    if (dataSynchronizerAlgo !== null) {\n        dataSynchronizerAlgo.reset();\n    }\n    timeBroadcastChannel.postMessage({\n        type: EventType.TIME_CHANGED\n    });\n    timeBroadcastChannel.postMessage({\n        type: EventType.CLOSED\n    });\n    dataSynchronizerBroadCastChannel.postMessage({\n        type: EventType.STATUS,\n        status: 'not_running',\n    });\n}\n\nfunction initBroadcastChannel(dataTopic, timeTopic) {\n    console.log('listen on topic ', dataTopic)\n\n    dataSynchronizerBroadCastChannel = new BroadcastChannel(dataTopic);\n    dataSynchronizerBroadCastChannel.onmessage = (event) => {\n        checkMasterTime();\n        if (event.data.type === EventType.DATA) {\n            dataSynchronizerAlgo.push(event.data.dataSourceId, event.data.values);\n        } else if (event.data.type === EventType.STATUS) {\n            const dataSourceId = event.data.dataSourceId;\n            dataSynchronizerAlgo.setStatus(dataSourceId, event.data.status);\n            // bubble the message\n            if (dataSourceId in bcChannels) {\n                console.log(dataSources[dataSourceId].name + \": status=\" + event.data.status);\n                bcChannels[dataSourceId].postMessage(event.data);\n            }\n        }\n    }\n\n    timeBroadcastChannel = new BroadcastChannel(timeTopic);\n\n}\n\n/**\n *\n * @param dataSources\n */\nfunction addDataSources(dataSources) {\n    for (let dataSource of dataSources) {\n        addDataSource(dataSource);\n    }\n}\n\nfunction addDataSource(dataSource) {\n    dataSynchronizerAlgo.addDataSource(dataSource);\n    // create a BC to push back the synchronized data into the DATA Stream.\n    bcChannels[dataSource.id] = new BroadcastChannel(DATASOURCE_DATA_TOPIC + dataSource.id);\n\n    if (!(dataSource.id in dataSources)) {\n        dataSources[dataSource.id] = dataSource;\n    }\n}\n\n/**\n *\n * @param dataSourceIds\n */\nasync function removeDataSources(dataSourceIds) {\n    for (let dataSourceId of dataSourceIds) {\n        await removeDataSource(dataSourceId);\n    }\n}\n\nasync function removeDataSource(dataSourceId) {\n    await dataSynchronizerAlgo.removeDataSource(dataSourceId);\n    // create a BC to push back the synchronized data into the DATA Stream.\n    console.log('deleting BC for datasource ' + dataSourceId);\n    delete bcChannels[dataSourceId];\n    delete dataSources[dataSourceId];\n}\n\nfunction checkMasterTime() {\n    if (!isDefined(masterTimeInterval)) {\n        startMasterTimeInterval(DataSynchronizer_realtime_worker_masterTimeRefreshRate);\n    }\n}\n\nasync function onEnd() {\n    const masterTime = dataSynchronizerAlgo.getCurrentTimestamp();\n    clearInterval(masterTimeInterval);\n    masterTimeInterval = undefined;\n    // end at this time\n    timeBroadcastChannel.postMessage({\n        timestamp: masterTime,\n        type: EventType.MASTER_TIME\n    });\n}\n\nasync function onStart() {\n    checkMasterTime();\n}\n\nfunction onClose() {\n    timeBroadcastChannel.postMessage({\n        type: EventType.CLOSED\n    });\n}\n\nasync function onData(dataSourceId, dataBlock) {\n    if (dataBlock.version !== version) {\n        console.error('version are different:', dataBlock.version, version);\n        return;\n    }\n    DataSynchronizer_realtime_worker_lastData = {\n        dataSourceId: dataSourceId,\n        dataBlock: dataBlock,\n    };\n    bcChannels[dataSourceId].postMessage({\n            values: [dataBlock],\n            dataSourceId: dataSourceId,\n            type: EventType.DATA\n        }\n    );\n}\n\nself.onclose = function () {\n    dataSynchronizerAlgo.close();\n    console.log(\"Data Synchronizer has been terminated successfully\");\n}\n\nlet DataSynchronizer_realtime_worker_masterTime;\n\nfunction startMasterTimeInterval(masterTimeRefreshRate) {\n    if (!isDefined(masterTimeInterval)) {\n        masterTimeInterval = setInterval(() => {\n            DataSynchronizer_realtime_worker_masterTime = dataSynchronizerAlgo.getCurrentTimestamp();\n            if (isDefined(DataSynchronizer_realtime_worker_masterTime)) {\n                timeBroadcastChannel.postMessage({\n                    timestamp: DataSynchronizer_realtime_worker_masterTime,\n                    type: EventType.MASTER_TIME\n                });\n            }\n\n            if (isDefined(DataSynchronizer_realtime_worker_lastData)) {\n                cTime = DataSynchronizer_realtime_worker_lastData.dataBlock.data.timestamp;\n                cId = DataSynchronizer_realtime_worker_lastData.dataSourceId;\n\n                if ((cTime !== -1 && lastTime === -1) || (lastTime !== -1 && cTime !== lastTime)) { // does not send the same data twice\n                    timeBroadcastChannel.postMessage({\n                        timestamp: cTime,\n                        dataSourceId: cId,\n                        type: EventType.LAST_TIME\n                    });\n                }\n                lastTime = cTime;\n            }\n        }, masterTimeRefreshRate);\n        dataSynchronizerBroadCastChannel.postMessage({\n            type: EventType.STATUS,\n            status: 'running',\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIMi9naXRodWIvb3NoLWpzL3NvdXJjZS9jb3JlL0NvbnN0YW50cy5qcz9hZjFiIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gyL2dpdGh1Yi9vc2gtanMvc291cmNlL2NvcmUvZXZlbnQvRXZlbnRUeXBlLmpzPzQwMDIiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSDIvZ2l0aHViL29zaC1qcy9zb3VyY2UvY29yZS91dGlscy9VdGlscy5qcz83MGEwIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gyL2dpdGh1Yi9vc2gtanMvc291cmNlL2NvcmUvY29ubmVjdG9yL1N0YXR1cy5qcz9jZjE5Iiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gyL2dpdGh1Yi9vc2gtanMvc291cmNlL2NvcmUvdGltZXN5bmMvRGF0YVN5bmNocm9uaXplckFsZ28uanM/OWE3YSIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIMi9naXRodWIvb3NoLWpzL3NvdXJjZS9jb3JlL3RpbWVzeW5jL3J0L0RhdGFTeW5jaHJvbml6ZXJBbGdvLnJlYWx0aW1lLmpzPzg3NGEiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSDIvZ2l0aHViL29zaC1qcy9zb3VyY2UvY29yZS90aW1lc3luYy9ydC9EYXRhU3luY2hyb25pemVyLnJlYWx0aW1lLndvcmtlci5qcz9iMmViIl0sIm5hbWVzIjpbIkRBVEFfU1lOQ0hST05JWkVSX1RPUElDIiwiVElNRV9TWU5DSFJPTklaRVJfVE9QSUMiLCJEQVRBU09VUkNFX0RBVEFfVE9QSUMiLCJEQVRBU09VUkNFX1RJTUVfVE9QSUMiLCJGRk1QRUdfVklFV19ERUNPREVfVE9QSUMiLCJNQUdJQ19FTkRfUEFDS0VUIiwiRXZlbnRUeXBlIiwiREFUQSIsIkxBU1RfVElNRSIsIk1BU1RFUl9USU1FIiwiU1RBVFVTIiwiVElNRV9DSEFOR0VEIiwiQ0xPU0VEIiwiTUFYX0xPTkciLCJNYXRoIiwicG93IiwiaXNEZWZpbmVkIiwidiIsImhhc1ZhbHVlIiwiaGV4MnJnYiIsImhleCIsInIiLCJnIiwiYiIsIm1hdGNoIiwibWFwIiwieCIsInBhcnNlSW50IiwiaGV4MnJnYmEiLCJzbGljZSIsImhhc1R5cGUiLCJleHBlY3RlZFR5cGUiLCJoYXNWYWwiLCJpc09iamVjdCIsImxldE5hbWUiLCJpc0FycmF5IiwiQXJyYXkiLCJpc0Z1bmN0aW9uIiwiYXNzZXJ0RGVmaW5lZCIsImFzc2VydFRydWUiLCJhc3NlcnRUeXBlIiwiYXNzZXJ0Qm9vbGVhbiIsImFzc2VydFN0cmluZyIsImFzc2VydE51bWJlciIsImFzc2VydFBvc2l0aXZlIiwiYXNzZXJ0T2JqZWN0IiwiYXNzZXJ0QXJyYXkiLCJhc3NlcnRGdW5jdGlvbiIsImFzc2VydEhhc1ZhbHVlIiwicmFuZG9tVVVJRCIsInJlcGxhY2UiLCJjIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdGFtcFVVSUQiLCJvYmoiLCJfb3NoX2lkIiwiUGFyc2VCeXRlcyIsImJ1ZmZlciIsIm9mZnNldCIsInR5cGUiLCJ2aWV3IiwiRGF0YVZpZXciLCJ0eXBlTWFwIiwiZG91YmxlIiwidmFsIiwiZ2V0RmxvYXQ2NCIsImJ5dGVzIiwiZmxvYXQ2NCIsImZsb2F0MzIiLCJnZXRGbG9hdDMyIiwic2lnbmVkQnl0ZSIsImdldEludDgiLCJzaWduZWRJbnQiLCJnZXRJbnQzMiIsInNpZ25lZFNob3J0IiwiZ2V0SW50MTYiLCJ1bnNpZ25lZEJ5dGUiLCJnZXRVaW50OCIsInVuc2lnbmVkSW50IiwiZ2V0VWludDMyIiwidW5zaWduZWRTaG9ydCIsImdldFVpbnQxNiIsIlJlYWREYXRhIiwic3RydWN0IiwiZGF0YSIsIm9mZnNldEJ5dGVzIiwiaSIsImZpZWxkcyIsImxlbmd0aCIsImN1cnJGaWVsZFN0cnVjdCIsInJldCIsImNvdW50IiwiaXNOYU4iLCJpZCIsImZpZWxkTmFtZSIsImlkMkZpZWxkTWFwIiwiZmluZEZpZWxkQnlOYW1lIiwiaiIsImZpZWxkIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwicHVzaCIsIkdldFJlc3VsdE9iamVjdCIsInJlc3VsdFN0cnVjdHVyZSIsInJlc3VsdCIsIm5hbWUiLCJpdGVtIiwiayIsImlzT3BlcmEiLCJ3aW5kb3ciLCJvcHIiLCJhZGRvbnMiLCJvcGVyYSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluZGV4T2YiLCJpc0ZpcmVmb3giLCJJbnN0YWxsVHJpZ2dlciIsImlzU2FmYXJpIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiY2FsbCIsIkhUTUxFbGVtZW50IiwiaXNDaHJvbWUiLCJjaHJvbWUiLCJ3ZWJzdG9yZSIsImlzQmxpbmsiLCJDU1MiLCJpc0FycmF5SW50ZXJzZWN0IiwiYSIsImZpbHRlciIsImVsZW1lbnQiLCJpc0VsZW1lbnQiLCJvIiwibm9kZVR5cGUiLCJub2RlTmFtZSIsImlzV2ViV29ya2VyIiwiV29ya2VyIiwidGFrZVNjcmVlblNob3QiLCJkaXYiLCJyZW1vdmVDc3MiLCJjc3MiLCJkaXZDc3MiLCJjbGFzc05hbWUiLCJhZGRDc3MiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVMYXN0Q2hhcklmRXhpc3QiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImVuZHNXaXRoIiwic3Vic3RyaW5nIiwiY2FwaXRhbGl6ZUZpcnN0TGV0dGVyIiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJyb3VuZEhhbGYiLCJudW0iLCJyb3VuZCIsImRlYm91bmNlIiwiZnVuYyIsIndhaXQiLCJpbW1lZGlhdGUiLCJ0aW1lb3V0IiwiYXJncyIsImNvbnRleHQiLCJ0aW1lc3RhbXAiLCJsYXRlciIsIm5vdyIsIkRhdGUiLCJnZXRUaW1lIiwibGFzdCIsInNldFRpbWVvdXQiLCJhcHBseSIsImFyZ3VtZW50cyIsImNhbGxOb3ciLCJ0aHJvdHRsZSIsImxlYWRpbmciLCJ0cmFpbGluZyIsImN0eCIsInByZXZpb3VzIiwicmVtYWluaW5nIiwiY2xlYXJUaW1lb3V0IiwibWVyZ2UiLCJ0YXJnZXQiLCJzb3VyY2UiLCJrZXkiLCJrZXlzIiwiYXNzaWduIiwicmdiYVRvQXJyYXkiLCJzdGFydElkeFZhbHVlIiwiZW5kSWR4VmFsdWUiLCJ2YWx1ZXMiLCJzdWJzdHIiLCJzcGxpdCIsIk51bWJlciIsIlN0YXR1cyIsIkNPTk5FQ1RJTkciLCJDT05ORUNURUQiLCJESVNDT05ORUNURUQiLCJGRVRDSF9TVEFSVEVEIiwiRkVUQ0hfRU5ERUQiLCJDTE9TRURfRVJST1IiLCJEYXRhU3luY2hyb25pemVyQWxnbyIsImNvbnN0cnVjdG9yIiwiZGF0YVNvdXJjZXMiLCJ0aW1lclJlc29sdXRpb24iLCJkYXRhU291cmNlTWFwIiwidHNSdW4iLCJpbnRlcnZhbCIsImRhdGFzb3VyY2VzIiwiZHMiLCJhZGREYXRhU291cmNlIiwicmVtb3ZlRGF0YVNvdXJjZSIsImRhdGFTb3VyY2VJZCIsImVsdCIsImRhdGFCbG9ja3MiLCJnZXRDdXJyZW50VGltZXN0YW1wIiwicHJvY2Vzc0RhdGEiLCJ0c1JlZiIsImNsb2NrVGltZVJlZiIsInBlcmZvcm1hbmNlIiwiY3VycmVudERzIiwiY3VycmVudERzSWQiLCJkYXRhQnVmZmVyIiwic2V0SW50ZXJ2YWwiLCJjb21wdXRlTmV4dERhdGEiLCJjb25zb2xlIiwid2FybiIsInRvSVNPU3RyaW5nIiwicmVmQ2xvY2tUaW1lIiwiRXJyb3IiLCJkYXRhU291cmNlIiwiY2hlY2tWZXJzaW9uIiwiZGF0YXNvdXJjZSIsImRhdGFCbG9jayIsIm9uRGF0YSIsImNoZWNrU3RhcnQiLCJzZXRTdGF0dXMiLCJzdGF0dXMiLCJjbG9zZSIsImNsZWFySW50ZXJ2YWwiLCJsb2ciLCJvbkNsb3NlIiwib25TdGFydCIsIkRhdGFTeW5jaHJvbml6ZXJBbGdvUmVhbHRpbWUiLCJsYXN0RGF0YSIsImxhdGVuY3kiLCJjdXJyZW50RHNUb1NoaWZ0IiwibWF4TGF0ZW5jeSIsIm1pbkxhdGVuY3kiLCJtaW4iLCJ0aW1lT3V0IiwiZENsb2NrIiwiZFRzIiwiZENsb2NrQWRqIiwicmVjIiwic2hpZnQiLCJ0aW1lZE91dCIsInZlcnNpb24iLCJyZXNldCIsInJlc2V0RGF0YVNvdXJjZSIsImRhdGFzb3VyY2VJZCIsInN0YXJ0QnVmZmVyaW5nVGltZSJdLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLHVCQUF1QixHQUFHLG9CQUFoQztBQUNBLE1BQU1DLHVCQUF1QixHQUFHLHlCQUFoQztBQUVBLE1BQU1DLHFCQUFxQixHQUFHLGtCQUE5QjtBQUNBLE1BQU1DLHFCQUFxQixHQUFHLGtCQUE5QjtBQUVBLE1BQU1DLHdCQUF3QixHQUFHLGdCQUFqQztBQUVBLE1BQU1DLGdCQUFnQixHQUFHLGNBQXpCLEM7O0FDUkEsTUFBTUMsU0FBUyxHQUFHO0VBQ3JCQyxJQUFJLEVBQUUsTUFEZTtFQUVyQkMsU0FBUyxFQUFFLFdBRlU7RUFHckJDLFdBQVcsRUFBRSxhQUhRO0VBSXJCQyxNQUFNLEVBQUUsUUFKYTtFQUtyQkMsWUFBWSxFQUFFLGNBTE87RUFNckJDLE1BQU0sRUFBRTtBQU5hLENBQWxCLEM7O0FDQVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ08sTUFBTUMsUUFBUSxHQUFHQyxJQUFJLENBQUNDLEdBQUwsQ0FBUyxDQUFULEVBQVksRUFBWixJQUFrQixDQUFuQztBQUVQO0FBQ0E7QUFDQTs7QUFDTyxTQUFTQyxTQUFULENBQW1CQyxDQUFuQixFQUFzQjtFQUN6QixPQUFPLE9BQVFBLENBQVIsS0FBZSxXQUFmLElBQThCQSxDQUFDLEtBQUssSUFBM0M7QUFDSDtBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUNPLFNBQVNDLFFBQVQsQ0FBa0JELENBQWxCLEVBQXFCO0VBQ3hCLE9BQU9ELFNBQVMsQ0FBQ0MsQ0FBRCxDQUFULElBQWdCQSxDQUFDLEtBQUssSUFBN0I7QUFDSDtBQUVEO0FBQ0E7QUFDQTs7QUFDTyxTQUFTRSxPQUFULENBQWlCQyxHQUFqQixFQUFxQjtFQUN4QixNQUFNLENBQUNDLENBQUQsRUFBSUMsQ0FBSixFQUFPQyxDQUFQLElBQVlILEdBQUcsQ0FBQ0ksS0FBSixDQUFVLE9BQVYsRUFBbUJDLEdBQW5CLENBQXVCQyxDQUFDLElBQUlDLFFBQVEsQ0FBQ0QsQ0FBRCxFQUFJLEVBQUosQ0FBcEMsQ0FBbEI7RUFDQSxPQUFPLENBQUNMLENBQUQsRUFBSUMsQ0FBSixFQUFPQyxDQUFQLENBQVA7QUFDSDtBQUVNLFNBQVNLLFFBQVQsQ0FBa0JSLEdBQWxCLEVBQXNCO0VBQ3pCLE9BQU8sQ0FDSE8sUUFBUSxDQUFDUCxHQUFHLENBQUNTLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBYixDQUFELEVBQWtCLEVBQWxCLENBREwsRUFFSEYsUUFBUSxDQUFDUCxHQUFHLENBQUNTLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBYixDQUFELEVBQWtCLEVBQWxCLENBRkwsRUFHSEYsUUFBUSxDQUFDUCxHQUFHLENBQUNTLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBYixDQUFELEVBQWtCLEVBQWxCLENBSEwsRUFJSEYsUUFBUSxDQUFDUCxHQUFHLENBQUNTLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBYixDQUFELEVBQWtCLEVBQWxCLENBQVIsR0FBZ0MsR0FKN0IsQ0FBUDtBQU1IO0FBRUQ7QUFDQTtBQUNBOztBQUNPLFNBQVNDLE9BQVQsQ0FBaUJiLENBQWpCLEVBQW9CYyxZQUFwQixFQUFrQztFQUNyQyxJQUFJQyxNQUFNLEdBQUdkLFFBQVEsQ0FBQ0QsQ0FBRCxDQUFyQjtFQUNBLE9BQU9lLE1BQU0sSUFBSSxPQUFRZixDQUFSLEtBQWVjLFlBQWhDO0FBQ0g7QUFFRDtBQUNBO0FBQ0E7O0FBQ08sU0FBU0UsUUFBVCxDQUFrQmhCLENBQWxCLEVBQXFCaUIsT0FBckIsRUFBOEI7RUFDakMsT0FBT0osT0FBTyxDQUFDYixDQUFELEVBQUksUUFBSixFQUFjaUIsT0FBZCxDQUFkO0FBQ0g7QUFFRDtBQUNBO0FBQ0E7O0FBQ08sU0FBU0MsT0FBVCxDQUFpQmxCLENBQWpCLEVBQW9CO0VBQ3ZCLE9BQU9ELFNBQVMsQ0FBQ0MsQ0FBRCxDQUFULElBQWdCbUIsS0FBSyxDQUFDRCxPQUFOLENBQWNsQixDQUFkLENBQXZCO0FBQ0g7QUFFRDtBQUNBO0FBQ0E7O0FBQ08sU0FBU29CLFVBQVQsQ0FBb0JwQixDQUFwQixFQUF1QmlCLE9BQXZCLEVBQWdDO0VBQ25DLE9BQU9KLE9BQU8sQ0FBQ2IsQ0FBRCxFQUFJLFVBQUosRUFBZ0JpQixPQUFoQixDQUFkO0FBQ0g7QUFFRDtBQUNBO0FBQ0E7O0FBQ08sU0FBU0ksYUFBVCxDQUF1QnJCLENBQXZCLEVBQTBCaUIsT0FBTyxHQUFHLFVBQXBDLEVBQWdEO0VBQ25ELElBQUksQ0FBQ2xCLFNBQVMsQ0FBQ0MsQ0FBRCxDQUFkLEVBQW1CO0lBQ2YsTUFBTWlCLE9BQU8sR0FBRyxrQkFBaEI7RUFDSDs7RUFDRCxPQUFPakIsQ0FBUDtBQUNIO0FBRU0sU0FBU3NCLFVBQVQsQ0FBb0J0QixDQUFwQixFQUF1QmlCLE9BQU8sR0FBRyxVQUFqQyxFQUE2QztFQUNoRCxJQUFJLENBQUNsQixTQUFTLENBQUNDLENBQUQsQ0FBVixJQUFpQixDQUFDQSxDQUF0QixFQUF5QjtJQUNyQixNQUFNaUIsT0FBTjtFQUNIOztFQUNELE9BQU9qQixDQUFQO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7O0FBQ08sU0FBU3VCLFVBQVQsQ0FBb0J2QixDQUFwQixFQUF1QmMsWUFBdkIsRUFBcUNHLE9BQU8sR0FBRyxVQUEvQyxFQUEyRDtFQUM5REksYUFBYSxDQUFDckIsQ0FBRCxFQUFJaUIsT0FBSixDQUFiOztFQUNBLElBQUksT0FBUWpCLENBQVIsS0FBZWMsWUFBbkIsRUFBaUM7SUFDN0IsTUFBTUcsT0FBTyxHQUFHLG1CQUFWLEdBQWdDSCxZQUF0QztFQUNIOztFQUNELE9BQU9kLENBQVA7QUFDSDtBQUVEO0FBQ0E7QUFDQTs7QUFDTyxTQUFTd0IsYUFBVCxDQUF1QnhCLENBQXZCLEVBQTBCaUIsT0FBMUIsRUFBbUM7RUFDdEMsT0FBT00sVUFBVSxDQUFDdkIsQ0FBRCxFQUFJLFNBQUosRUFBZWlCLE9BQWYsQ0FBakI7QUFDSDtBQUVEO0FBQ0E7QUFDQTs7QUFDTyxTQUFTUSxZQUFULENBQXNCekIsQ0FBdEIsRUFBeUJpQixPQUF6QixFQUFrQztFQUNyQyxPQUFPTSxVQUFVLENBQUN2QixDQUFELEVBQUksUUFBSixFQUFjaUIsT0FBZCxDQUFqQjtBQUNIO0FBRUQ7QUFDQTtBQUNBOztBQUNPLFNBQVNTLFlBQVQsQ0FBc0IxQixDQUF0QixFQUF5QmlCLE9BQXpCLEVBQWtDO0VBQ3JDLE9BQU9NLFVBQVUsQ0FBQ3ZCLENBQUQsRUFBSSxRQUFKLEVBQWNpQixPQUFkLENBQWpCO0FBQ0g7QUFFRDtBQUNBO0FBQ0E7O0FBQ08sU0FBU1UsY0FBVCxDQUF3QjNCLENBQXhCLEVBQTJCaUIsT0FBM0IsRUFBb0M7RUFDdkNTLFlBQVksQ0FBQzFCLENBQUQsRUFBSWlCLE9BQUosQ0FBWjs7RUFDQSxJQUFJakIsQ0FBQyxJQUFJLENBQVQsRUFBWTtJQUNSLE1BQU1pQixPQUFPLEdBQUcsNEJBQWhCO0VBQ0g7QUFDSjtBQUVEO0FBQ0E7QUFDQTs7QUFDTyxTQUFTVyxZQUFULENBQXNCNUIsQ0FBdEIsRUFBeUJpQixPQUF6QixFQUFrQztFQUNyQyxPQUFPTSxVQUFVLENBQUN2QixDQUFELEVBQUksUUFBSixFQUFjaUIsT0FBZCxDQUFqQjtBQUNIO0FBRUQ7QUFDQTtBQUNBOztBQUNPLFNBQVNZLFdBQVQsQ0FBcUI3QixDQUFyQixFQUF3QmlCLE9BQU8sR0FBRyxVQUFsQyxFQUE4QztFQUNqREksYUFBYSxDQUFDckIsQ0FBRCxFQUFJaUIsT0FBSixDQUFiOztFQUNBLElBQUksQ0FBQ0UsS0FBSyxDQUFDRCxPQUFOLENBQWNsQixDQUFkLENBQUwsRUFBdUI7SUFDbkIsTUFBTWlCLE9BQU8sR0FBRyxtQkFBaEI7RUFDSDs7RUFDRCxPQUFPakIsQ0FBUDtBQUNIO0FBRUQ7QUFDQTtBQUNBOztBQUNPLFNBQVM4QixjQUFULENBQXdCOUIsQ0FBeEIsRUFBMkJpQixPQUEzQixFQUFvQztFQUN2QyxPQUFPTSxVQUFVLENBQUN2QixDQUFELEVBQUksVUFBSixFQUFnQmlCLE9BQWhCLENBQWpCO0FBQ0g7QUFFRDtBQUNBO0FBQ0E7O0FBQ08sU0FBU2MsY0FBVCxDQUF3Qi9CLENBQXhCLEVBQTJCaUIsT0FBTyxHQUFHLFVBQXJDLEVBQWlEO0VBQ3BESSxhQUFhLENBQUNyQixDQUFELEVBQUlpQixPQUFKLENBQWI7O0VBQ0EsSUFBSSxDQUFDaEIsUUFBUSxDQUFDRCxDQUFELENBQWIsRUFBa0I7SUFDZCxNQUFNaUIsT0FBTyxHQUFHLG1CQUFoQjtFQUNIOztFQUNELE9BQU9qQixDQUFQO0FBQ0g7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFDTyxTQUFTZ0MsVUFBVCxHQUFzQjtFQUN6QixPQUFPLHVDQUF1Q0MsT0FBdkMsQ0FBK0MsT0FBL0MsRUFBd0QsVUFBVUMsQ0FBVixFQUFhO0lBQ3hFLElBQUk5QixDQUFDLEdBQUdQLElBQUksQ0FBQ3NDLE1BQUwsS0FBZ0IsRUFBaEIsR0FBcUIsQ0FBN0I7SUFBQSxJQUFnQ25DLENBQUMsR0FBR2tDLENBQUMsS0FBSyxHQUFOLEdBQVk5QixDQUFaLEdBQWlCQSxDQUFDLEdBQUcsR0FBSixHQUFVLEdBQS9EO0lBQ0EsT0FBT0osQ0FBQyxDQUFDb0MsUUFBRixDQUFXLEVBQVgsQ0FBUDtFQUNILENBSE0sQ0FBUDtBQUlIO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sU0FBU0MsU0FBVCxDQUFtQkMsR0FBbkIsRUFBd0I7RUFDM0JBLEdBQUcsQ0FBQ0MsT0FBSixHQUFjRCxHQUFHLENBQUNDLE9BQUosSUFBZVAsVUFBVSxFQUF2QztFQUNBLE9BQU9NLEdBQUcsQ0FBQ0MsT0FBWDtBQUNILEMsQ0FFRDtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sU0FBU0MsVUFBVCxDQUFvQkMsTUFBcEIsRUFBNEJDLE1BQTVCLEVBQW9DQyxJQUFwQyxFQUEwQztFQUM3QyxJQUFJQyxJQUFJLEdBQUcsSUFBSUMsUUFBSixDQUFhSixNQUFiLENBQVgsQ0FENkMsQ0FHN0M7RUFDQTtFQUNBOztFQUNBLElBQUlLLE9BQU8sR0FBRztJQUNWQyxNQUFNLEVBQUUsVUFBVUwsTUFBVixFQUFrQjtNQUN0QixPQUFPO1FBQUNNLEdBQUcsRUFBRUosSUFBSSxDQUFDSyxVQUFMLENBQWdCUCxNQUFoQixDQUFOO1FBQStCUSxLQUFLLEVBQUU7TUFBdEMsQ0FBUDtJQUNILENBSFM7SUFJVkMsT0FBTyxFQUFFLFVBQVVULE1BQVYsRUFBa0I7TUFDdkIsT0FBTztRQUFDTSxHQUFHLEVBQUVKLElBQUksQ0FBQ0ssVUFBTCxDQUFnQlAsTUFBaEIsQ0FBTjtRQUErQlEsS0FBSyxFQUFFO01BQXRDLENBQVA7SUFDSCxDQU5TO0lBT1ZFLE9BQU8sRUFBRSxVQUFVVixNQUFWLEVBQWtCO01BQ3ZCLE9BQU87UUFBQ00sR0FBRyxFQUFFSixJQUFJLENBQUNTLFVBQUwsQ0FBZ0JYLE1BQWhCLENBQU47UUFBK0JRLEtBQUssRUFBRTtNQUF0QyxDQUFQO0lBQ0gsQ0FUUztJQVVWSSxVQUFVLEVBQUUsVUFBVVosTUFBVixFQUFrQjtNQUMxQixPQUFPO1FBQUNNLEdBQUcsRUFBRUosSUFBSSxDQUFDVyxPQUFMLENBQWFiLE1BQWIsQ0FBTjtRQUE0QlEsS0FBSyxFQUFFO01BQW5DLENBQVA7SUFDSCxDQVpTO0lBYVZNLFNBQVMsRUFBRSxVQUFVZCxNQUFWLEVBQWtCO01BQ3pCLE9BQU87UUFBQ00sR0FBRyxFQUFFSixJQUFJLENBQUNhLFFBQUwsQ0FBY2YsTUFBZCxDQUFOO1FBQTZCUSxLQUFLLEVBQUU7TUFBcEMsQ0FBUDtJQUNILENBZlM7SUFnQlZRLFdBQVcsRUFBRSxVQUFVaEIsTUFBVixFQUFrQjtNQUMzQixPQUFPO1FBQUNNLEdBQUcsRUFBRUosSUFBSSxDQUFDZSxRQUFMLENBQWNqQixNQUFkLENBQU47UUFBNkJRLEtBQUssRUFBRTtNQUFwQyxDQUFQO0lBQ0gsQ0FsQlM7SUFtQlZVLFlBQVksRUFBRSxVQUFVbEIsTUFBVixFQUFrQjtNQUM1QixPQUFPO1FBQUNNLEdBQUcsRUFBRUosSUFBSSxDQUFDaUIsUUFBTCxDQUFjbkIsTUFBZCxDQUFOO1FBQTZCUSxLQUFLLEVBQUU7TUFBcEMsQ0FBUDtJQUNILENBckJTO0lBc0JWWSxXQUFXLEVBQUUsVUFBVXBCLE1BQVYsRUFBa0I7TUFDM0IsT0FBTztRQUFDTSxHQUFHLEVBQUVKLElBQUksQ0FBQ21CLFNBQUwsQ0FBZXJCLE1BQWYsQ0FBTjtRQUE4QlEsS0FBSyxFQUFFO01BQXJDLENBQVA7SUFDSCxDQXhCUztJQXlCVmMsYUFBYSxFQUFFLFVBQVV0QixNQUFWLEVBQWtCO01BQzdCLE9BQU87UUFBQ00sR0FBRyxFQUFFSixJQUFJLENBQUNxQixTQUFMLENBQWV2QixNQUFmLENBQU47UUFBOEJRLEtBQUssRUFBRTtNQUFyQyxDQUFQO0lBQ0gsQ0EzQlMsQ0E0QlY7O0VBNUJVLENBQWQ7RUE4QkEsT0FBT0osT0FBTyxDQUFDSCxJQUFELENBQVAsQ0FBY0QsTUFBZCxDQUFQO0FBQ0gsQyxDQUVEO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sU0FBU3dCLFFBQVQsQ0FBa0JDLE1BQWxCLEVBQTBCQyxJQUExQixFQUFnQ0MsV0FBaEMsRUFBNkM7RUFDaEQsSUFBSTNCLE1BQU0sR0FBRzJCLFdBQWI7O0VBQ0EsS0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHSCxNQUFNLENBQUNJLE1BQVAsQ0FBY0MsTUFBbEMsRUFBMENGLENBQUMsRUFBM0MsRUFBK0M7SUFDM0MsSUFBSUcsZUFBZSxHQUFHTixNQUFNLENBQUNJLE1BQVAsQ0FBY0QsQ0FBZCxDQUF0Qjs7SUFDQSxJQUFJdkUsU0FBUyxDQUFDMEUsZUFBZSxDQUFDOUIsSUFBakIsQ0FBVCxJQUFtQzhCLGVBQWUsQ0FBQzlCLElBQWhCLEtBQXlCLElBQWhFLEVBQXNFO01BQ2xFLElBQUkrQixHQUFHLEdBQUdsQyxVQUFVLENBQUM0QixJQUFELEVBQU8xQixNQUFQLEVBQWUrQixlQUFlLENBQUM5QixJQUEvQixDQUFwQjtNQUNBOEIsZUFBZSxDQUFDekIsR0FBaEIsR0FBc0IwQixHQUFHLENBQUMxQixHQUExQjtNQUNBTixNQUFNLElBQUlnQyxHQUFHLENBQUN4QixLQUFkO0lBQ0gsQ0FKRCxNQUlPLElBQUluRCxTQUFTLENBQUMwRSxlQUFlLENBQUNFLEtBQWpCLENBQVQsSUFBb0NGLGVBQWUsQ0FBQ0UsS0FBaEIsS0FBMEIsSUFBbEUsRUFBd0U7TUFDM0U7TUFDQSxJQUFJQyxLQUFLLENBQUNILGVBQWUsQ0FBQ0UsS0FBakIsQ0FBVCxFQUFrQztRQUM5QixJQUFJRSxFQUFFLEdBQUdKLGVBQWUsQ0FBQ0UsS0FBekI7UUFDQSxJQUFJRyxTQUFTLEdBQUdYLE1BQU0sQ0FBQ1ksV0FBUCxDQUFtQkYsRUFBbkIsQ0FBaEI7UUFDQUosZUFBZSxDQUFDRSxLQUFoQixHQUF3QlIsTUFBTSxDQUFDYSxlQUFQLENBQXVCRixTQUF2QixFQUFrQzlCLEdBQTFEO01BQ0g7O01BQ0QsS0FBSyxJQUFJZCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHdUMsZUFBZSxDQUFDRSxLQUFwQyxFQUEyQ3pDLENBQUMsRUFBNUMsRUFBZ0Q7UUFDNUMsS0FBSyxJQUFJK0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR1IsZUFBZSxDQUFDRixNQUFoQixDQUF1QkMsTUFBM0MsRUFBbURTLENBQUMsRUFBcEQsRUFBd0Q7VUFDcEQsSUFBSUMsS0FBSyxHQUFHQyxJQUFJLENBQUNDLEtBQUwsQ0FBV0QsSUFBSSxDQUFDRSxTQUFMLENBQWVaLGVBQWUsQ0FBQ0YsTUFBaEIsQ0FBdUJVLENBQXZCLENBQWYsQ0FBWCxDQUFaO1VBQ0F2QyxNQUFNLEdBQUd3QixRQUFRLENBQUNnQixLQUFELEVBQVFkLElBQVIsRUFBYzFCLE1BQWQsQ0FBakI7VUFDQStCLGVBQWUsQ0FBQ3pCLEdBQWhCLENBQW9Cc0MsSUFBcEIsQ0FBeUJKLEtBQXpCO1FBQ0g7TUFDSjtJQUNKO0VBQ0o7O0VBQ0QsT0FBT3hDLE1BQVA7QUFDSDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sU0FBUzZDLGVBQVQsQ0FBeUJDLGVBQXpCLEVBQTBDO0VBQzdDO0VBQ0EsSUFBSUMsTUFBTSxHQUFHLEVBQWI7O0VBQ0EsS0FBSyxJQUFJbkIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2tCLGVBQWUsQ0FBQ2pCLE1BQWhCLENBQXVCQyxNQUEzQyxFQUFtREYsQ0FBQyxFQUFwRCxFQUF3RDtJQUNwRCxJQUFJdkUsU0FBUyxDQUFDeUYsZUFBZSxDQUFDakIsTUFBaEIsQ0FBdUJELENBQXZCLEVBQTBCSyxLQUEzQixDQUFiLEVBQWdEO01BQzVDYyxNQUFNLENBQUNELGVBQWUsQ0FBQ2pCLE1BQWhCLENBQXVCRCxDQUF2QixFQUEwQm9CLElBQTNCLENBQU4sR0FBeUMsRUFBekM7O01BQ0EsS0FBSyxJQUFJeEQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3NELGVBQWUsQ0FBQ2pCLE1BQWhCLENBQXVCRCxDQUF2QixFQUEwQkssS0FBOUMsRUFBcUR6QyxDQUFDLEVBQXRELEVBQTBEO1FBQ3RELElBQUl5RCxJQUFJLEdBQUcsRUFBWDs7UUFDQSxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdKLGVBQWUsQ0FBQ2pCLE1BQWhCLENBQXVCRCxDQUF2QixFQUEwQnRCLEdBQTFCLENBQThCZCxDQUE5QixFQUFpQ3FDLE1BQWpDLENBQXdDQyxNQUE1RCxFQUFvRW9CLENBQUMsRUFBckUsRUFBeUU7VUFDckVELElBQUksQ0FBQ0gsZUFBZSxDQUFDakIsTUFBaEIsQ0FBdUJELENBQXZCLEVBQTBCdEIsR0FBMUIsQ0FBOEJkLENBQTlCLEVBQWlDcUMsTUFBakMsQ0FBd0NxQixDQUF4QyxFQUEyQ0YsSUFBNUMsQ0FBSixHQUF3REYsZUFBZSxDQUFDakIsTUFBaEIsQ0FBdUJELENBQXZCLEVBQTBCdEIsR0FBMUIsQ0FBOEJkLENBQTlCLEVBQWlDcUMsTUFBakMsQ0FBd0NxQixDQUF4QyxFQUEyQzVDLEdBQW5HO1FBQ0g7O1FBQ0R5QyxNQUFNLENBQUNELGVBQWUsQ0FBQ2pCLE1BQWhCLENBQXVCRCxDQUF2QixFQUEwQm9CLElBQTNCLENBQU4sQ0FBdUNKLElBQXZDLENBQTRDSyxJQUE1QztNQUNIO0lBQ0osQ0FURCxNQVNPO01BQ0hGLE1BQU0sQ0FBQ0QsZUFBZSxDQUFDakIsTUFBaEIsQ0FBdUJELENBQXZCLEVBQTBCb0IsSUFBM0IsQ0FBTixHQUF5Q0YsZUFBZSxDQUFDakIsTUFBaEIsQ0FBdUJELENBQXZCLEVBQTBCdEIsR0FBbkU7SUFDSDtFQUNKOztFQUNELE9BQU95QyxNQUFQO0FBQ0g7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFDTyxTQUFTSSxPQUFULEdBQW1CO0VBQ3RCLE9BQVEsQ0FBQyxDQUFDQyxNQUFNLENBQUNDLEdBQVQsSUFBZ0IsQ0FBQyxDQUFDQSxHQUFHLENBQUNDLE1BQXZCLElBQWtDLENBQUMsQ0FBQ0YsTUFBTSxDQUFDRyxLQUEzQyxJQUFvREMsU0FBUyxDQUFDQyxTQUFWLENBQW9CQyxPQUFwQixDQUE0QixPQUE1QixLQUF3QyxDQUFuRztBQUNIO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sU0FBU0MsU0FBVCxHQUFxQjtFQUN4QixPQUFPLE9BQU9DLGNBQVAsS0FBMEIsV0FBakM7QUFDSDtBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUNPLFNBQVNDLFFBQVQsR0FBb0I7RUFDdkIsT0FBT0MsTUFBTSxDQUFDQyxTQUFQLENBQWlCckUsUUFBakIsQ0FBMEJzRSxJQUExQixDQUErQlosTUFBTSxDQUFDYSxXQUF0QyxFQUFtRFAsT0FBbkQsQ0FBMkQsYUFBM0QsSUFBNEUsQ0FBbkY7QUFDSDtBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUNPLFNBQVNRLFFBQVQsR0FBb0I7RUFDdkIsT0FBTyxDQUFDLENBQUNkLE1BQU0sQ0FBQ2UsTUFBVCxJQUFtQixDQUFDLENBQUNmLE1BQU0sQ0FBQ2UsTUFBUCxDQUFjQyxRQUExQztBQUNIO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sU0FBU0MsT0FBVCxHQUFtQjtFQUN0QixPQUFPLENBQUNILFFBQVEsSUFBSWYsT0FBYixLQUF5QixDQUFDLENBQUNDLE1BQU0sQ0FBQ2tCLEdBQXpDO0FBQ0g7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sU0FBU0MsZ0JBQVQsQ0FBMEJDLENBQTFCLEVBQTZCNUcsQ0FBN0IsRUFBZ0M7RUFDbkMsT0FBTzRHLENBQUMsQ0FBQ0MsTUFBRixDQUFTLFVBQVVDLE9BQVYsRUFBbUI7SUFDL0IsT0FBTzlHLENBQUMsQ0FBQzhGLE9BQUYsQ0FBVWdCLE9BQVYsSUFBcUIsQ0FBQyxDQUE3QjtFQUNILENBRk0sRUFFSjVDLE1BRkksR0FFSyxDQUZaO0FBR0g7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNPLFNBQVM2QyxTQUFULENBQW1CQyxDQUFuQixFQUFzQjtFQUN6QixPQUNFLE9BQU9YLFdBQVAsS0FBdUIsUUFBdkIsR0FBa0NXLENBQUMsWUFBWVgsV0FBL0MsR0FBNkQ7RUFDM0RXLENBQUMsSUFBSSxPQUFPQSxDQUFQLEtBQWEsUUFBbEIsSUFBOEJBLENBQUMsS0FBSyxJQUFwQyxJQUE0Q0EsQ0FBQyxDQUFDQyxRQUFGLEtBQWUsQ0FBM0QsSUFBZ0UsT0FBT0QsQ0FBQyxDQUFDRSxRQUFULEtBQXNCLFFBRjFGO0FBSUg7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFDTyxTQUFTQyxXQUFULEdBQXVCO0VBQzFCLE9BQU8xSCxTQUFTLENBQUMySCxNQUFELENBQWhCO0FBQ0g7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFDTyxTQUFTQyxjQUFULENBQXdCQyxHQUF4QixFQUE2QixDQUNuQztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sU0FBU0MsU0FBVCxDQUFtQkQsR0FBbkIsRUFBd0JFLEdBQXhCLEVBQTZCO0VBQ2hDLElBQUlDLE1BQU0sR0FBR0gsR0FBRyxDQUFDSSxTQUFqQjtFQUNBRixHQUFHLEdBQUdDLE1BQU0sQ0FBQzlGLE9BQVAsQ0FBZTZGLEdBQWYsRUFBb0IsRUFBcEIsQ0FBTjtFQUNBRixHQUFHLENBQUNJLFNBQUosR0FBZ0JGLEdBQWhCO0FBQ0g7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNPLFNBQVNHLE1BQVQsQ0FBZ0JMLEdBQWhCLEVBQXFCRSxHQUFyQixFQUEwQjtFQUM3QkYsR0FBRyxDQUFDTSxZQUFKLENBQWlCLE9BQWpCLEVBQTBCTixHQUFHLENBQUNJLFNBQUosR0FBZ0IsR0FBaEIsR0FBc0JGLEdBQWhEO0FBQ0g7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNPLFNBQVNLLHFCQUFULENBQStCQyxLQUEvQixFQUFzQztFQUN6QyxJQUFJLENBQUNySSxTQUFTLENBQUNzSSxTQUFELENBQVYsSUFBeUJELEtBQUssS0FBSyxJQUFuQyxJQUEyQ0EsS0FBSyxDQUFDNUQsTUFBTixLQUFpQixDQUE1RCxJQUFpRSxDQUFDNEQsS0FBSyxDQUFDRSxRQUFOLENBQWUsR0FBZixDQUF0RSxFQUEyRjtJQUN2RixPQUFPRixLQUFQO0VBQ0g7O0VBRUQsT0FBT0EsS0FBSyxDQUFDRyxTQUFOLENBQWdCLENBQWhCLEVBQW1CSCxLQUFLLENBQUM1RCxNQUFOLEdBQWUsQ0FBbEMsQ0FBUDtBQUNIO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDTyxTQUFVZ0UscUJBQVYsQ0FBZ0NDLEdBQWhDLEVBQXFDO0VBQ3hDLE9BQU9BLEdBQUcsQ0FBQ0MsTUFBSixDQUFXLENBQVgsRUFBY0MsV0FBZCxLQUE4QkYsR0FBRyxDQUFDN0gsS0FBSixDQUFVLENBQVYsQ0FBckM7QUFDSDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sU0FBU2dJLFNBQVQsQ0FBbUJDLEdBQW5CLEVBQXdCO0VBQzNCLE9BQU9oSixJQUFJLENBQUNpSixLQUFMLENBQVdELEdBQUcsR0FBQyxDQUFmLElBQWtCLENBQXpCO0FBQ0g7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDTyxTQUFTRSxRQUFULENBQWtCQyxJQUFsQixFQUF3QkMsSUFBeEIsRUFBOEJDLFNBQTlCLEVBQXlDO0VBQzVDLElBQUlDLE9BQUosRUFBYUMsSUFBYixFQUFtQkMsT0FBbkIsRUFBNEJDLFNBQTVCLEVBQXVDN0QsTUFBdkM7O0VBRUEsSUFBSThELEtBQUssR0FBRyxZQUFXO0lBQ25CLElBQUlDLEdBQUcsR0FBRyxJQUFJQyxJQUFKLEdBQVdDLE9BQVgsRUFBVjtJQUFBLElBQ0lDLElBQUksR0FBR0gsR0FBRyxHQUFHRixTQURqQjs7SUFHQSxJQUFJSyxJQUFJLEdBQUdWLElBQVAsSUFBZVUsSUFBSSxJQUFJLENBQTNCLEVBQThCO01BQzFCUixPQUFPLEdBQUdTLFVBQVUsQ0FBQ0wsS0FBRCxFQUFRTixJQUFJLEdBQUdVLElBQWYsQ0FBcEI7SUFDSCxDQUZELE1BRU87TUFDSFIsT0FBTyxHQUFHLElBQVY7O01BQ0EsSUFBSSxDQUFDRCxTQUFMLEVBQWdCO1FBQ1p6RCxNQUFNLEdBQUd1RCxJQUFJLENBQUNhLEtBQUwsQ0FBV1IsT0FBWCxFQUFvQkQsSUFBcEIsQ0FBVDtRQUNBLElBQUksQ0FBQ0QsT0FBTCxFQUFjRSxPQUFPLEdBQUdELElBQUksR0FBRyxJQUFqQjtNQUNqQjtJQUNKO0VBQ0osQ0FiRDs7RUFlQSxPQUFPLFlBQVc7SUFDZEMsT0FBTyxHQUFHLElBQVY7SUFDQUQsSUFBSSxHQUFHVSxTQUFQO0lBQ0FSLFNBQVMsR0FBRyxJQUFJRyxJQUFKLEdBQVdDLE9BQVgsRUFBWjtJQUNBLElBQUlLLE9BQU8sR0FBR2IsU0FBUyxJQUFJLENBQUNDLE9BQTVCO0lBQ0EsSUFBSSxDQUFDQSxPQUFMLEVBQWNBLE9BQU8sR0FBR1MsVUFBVSxDQUFDTCxLQUFELEVBQVFOLElBQVIsQ0FBcEI7O0lBQ2QsSUFBSWMsT0FBSixFQUFhO01BQ1R0RSxNQUFNLEdBQUd1RCxJQUFJLENBQUNhLEtBQUwsQ0FBV1IsT0FBWCxFQUFvQkQsSUFBcEIsQ0FBVDtNQUNBQyxPQUFPLEdBQUdELElBQUksR0FBRyxJQUFqQjtJQUNIOztJQUVELE9BQU8zRCxNQUFQO0VBQ0gsQ0FaRDtBQWFIO0FBQUE7QUFFTSxTQUFTdUUsUUFBVCxDQUFrQmhCLElBQWxCLEVBQXdCQyxJQUF4QixFQUE4QmdCLE9BQTlCLEVBQXVDQyxRQUF2QyxFQUFpRGIsT0FBakQsRUFBMEQ7RUFDN0QsSUFBSWMsR0FBSixFQUFTZixJQUFULEVBQWUzRCxNQUFmO0VBQ0EsSUFBSTBELE9BQU8sR0FBRyxJQUFkO0VBQ0EsSUFBSWlCLFFBQVEsR0FBRyxDQUFmOztFQUNBLElBQUliLEtBQUssR0FBRyxZQUFXO0lBQ25CYSxRQUFRLEdBQUcsSUFBSVgsSUFBSixFQUFYO0lBQ0FOLE9BQU8sR0FBRyxJQUFWO0lBQ0ExRCxNQUFNLEdBQUd1RCxJQUFJLENBQUNhLEtBQUwsQ0FBV00sR0FBWCxFQUFnQmYsSUFBaEIsQ0FBVDtFQUNILENBSkQ7O0VBS0EsT0FBTyxZQUFXO0lBQ2QsSUFBSUksR0FBRyxHQUFHLElBQUlDLElBQUosRUFBVjtJQUNBLElBQUksQ0FBQ1csUUFBRCxJQUFhLENBQUNILE9BQWxCLEVBQTJCRyxRQUFRLEdBQUdaLEdBQVg7SUFDM0IsSUFBSWEsU0FBUyxHQUFHcEIsSUFBSSxJQUFJTyxHQUFHLEdBQUdZLFFBQVYsQ0FBcEI7SUFDQUQsR0FBRyxHQUFHZCxPQUFPLElBQUksSUFBakI7SUFDQUQsSUFBSSxHQUFHVSxTQUFQOztJQUNBLElBQUlPLFNBQVMsSUFBSSxDQUFqQixFQUFvQjtNQUNoQkMsWUFBWSxDQUFDbkIsT0FBRCxDQUFaO01BQ0FBLE9BQU8sR0FBRyxJQUFWO01BQ0FpQixRQUFRLEdBQUdaLEdBQVg7TUFDQS9ELE1BQU0sR0FBR3VELElBQUksQ0FBQ2EsS0FBTCxDQUFXTSxHQUFYLEVBQWdCZixJQUFoQixDQUFUO0lBQ0gsQ0FMRCxNQUtPLElBQUksQ0FBQ0QsT0FBRCxJQUFZZSxRQUFoQixFQUEwQjtNQUM3QmYsT0FBTyxHQUFHUyxVQUFVLENBQUNMLEtBQUQsRUFBUWMsU0FBUixDQUFwQjtJQUNIOztJQUNELE9BQU81RSxNQUFQO0VBQ0gsQ0FmRDtBQWdCSDtBQUFBO0FBRU0sU0FBUzhFLEtBQVQsQ0FBZ0JDLE1BQWhCLEVBQXdCQyxNQUF4QixFQUFnQztFQUNuQztFQUNBLEtBQUssTUFBTUMsR0FBWCxJQUFrQmxFLE1BQU0sQ0FBQ21FLElBQVAsQ0FBWUYsTUFBWixDQUFsQixFQUF1QztJQUNuQyxJQUFJQSxNQUFNLENBQUNDLEdBQUQsQ0FBTixZQUF1QmxFLE1BQXZCLElBQWlDa0UsR0FBRyxJQUFJRixNQUE1QyxFQUFvRGhFLE1BQU0sQ0FBQ29FLE1BQVAsQ0FBY0gsTUFBTSxDQUFDQyxHQUFELENBQXBCLEVBQTJCSCxLQUFLLENBQUNDLE1BQU0sQ0FBQ0UsR0FBRCxDQUFQLEVBQWNELE1BQU0sQ0FBQ0MsR0FBRCxDQUFwQixDQUFoQztFQUN2RCxDQUprQyxDQU1uQzs7O0VBQ0FsRSxNQUFNLENBQUNvRSxNQUFQLENBQWNKLE1BQU0sSUFBSSxFQUF4QixFQUE0QkMsTUFBNUI7RUFDQSxPQUFPRCxNQUFQO0FBQ0g7QUFBQTtBQUVNLFNBQVNLLFdBQVQsQ0FBcUJwQyxHQUFyQixFQUEwQjtFQUM3QixJQUFJcUMsYUFBYSxHQUFHckMsR0FBRyxDQUFDckMsT0FBSixDQUFZLEdBQVosSUFBbUIsQ0FBdkM7RUFDQSxJQUFJMkUsV0FBVyxHQUFHdEMsR0FBRyxDQUFDckMsT0FBSixDQUFZLEdBQVosQ0FBbEI7RUFDQSxJQUFJNEUsTUFBTSxHQUFHdkMsR0FBRyxDQUFDd0MsTUFBSixDQUFXSCxhQUFYLEVBQTBCQyxXQUFXLEdBQUNELGFBQXRDLENBQWI7RUFDQSxPQUFPRSxNQUFNLENBQUNFLEtBQVAsQ0FBYSxHQUFiLEVBQWtCMUssR0FBbEIsQ0FBc0IySyxNQUF0QixDQUFQO0FBQ0gsQzs7QUN0aEJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNQyxNQUFNLEdBQUc7RUFDbEJDLFVBQVUsRUFBRSxZQURNO0VBRWxCQyxTQUFTLEVBQUcsV0FGTTtFQUdsQkMsWUFBWSxFQUFFLGNBSEk7RUFJbEJDLGFBQWEsRUFBRSxhQUpHO0VBS2xCQyxXQUFXLEVBQUUsV0FMSztFQU1sQjlMLE1BQU0sRUFBRSxRQU5VO0VBT2xCK0wsWUFBWSxFQUFFO0FBUEksQ0FBZixDOztBQ0xQO0FBQ0E7O0FBRUEsTUFBTUMseUNBQU4sQ0FBMkI7RUFDdkJDLFdBQVcsQ0FBQ0MsV0FBRCxFQUFjQyxlQUFlLEdBQUcsQ0FBaEMsRUFBbUM7SUFDMUMsS0FBS0MsYUFBTCxHQUFxQixFQUFyQjtJQUNBLEtBQUtDLEtBQUwsR0FBYTNELFNBQWI7SUFDQSxLQUFLeUQsZUFBTCxHQUF1QkEsZUFBdkI7SUFDQSxLQUFLRyxRQUFMLEdBQWdCLElBQWhCO0lBQ0EsS0FBS0MsV0FBTCxHQUFtQixFQUFuQjs7SUFDQSxLQUFLLElBQUlDLEVBQVQsSUFBZU4sV0FBZixFQUE0QjtNQUN4QixLQUFLTyxhQUFMLENBQW1CRCxFQUFuQjtJQUNIO0VBQ0o7O0VBRURFLGdCQUFnQixDQUFDQyxZQUFELEVBQWU7SUFDM0IsS0FBS0osV0FBTCxHQUFtQixLQUFLQSxXQUFMLENBQWlCL0UsTUFBakIsQ0FBeUJvRixHQUFHLElBQUlBLEdBQUcsQ0FBQzFILEVBQUosS0FBV3lILFlBQTNDLENBQW5CO0lBQ0EsT0FBTyxLQUFLUCxhQUFMLENBQW1CTyxZQUFuQixDQUFQO0VBQ0g7O0VBRURoSCxJQUFJLENBQUNnSCxZQUFELEVBQWVFLFVBQWYsRUFBMkIsQ0FDOUI7O0VBRURDLG1CQUFtQixHQUFHO0lBQ2xCLE9BQU8sS0FBS1QsS0FBWjtFQUNIOztFQUVEVSxXQUFXLEdBQUc7SUFDVixJQUFJQyxLQUFLLEdBQUcsQ0FBQyxDQUFiO0lBQ0EsSUFBSUMsWUFBWSxHQUFHQyxXQUFXLENBQUNyRCxHQUFaLEVBQW5CLENBRlUsQ0FJVjtJQUNBOztJQUNBLElBQUlzRCxTQUFKOztJQUNBLEtBQUssSUFBSUMsV0FBVCxJQUF3QixLQUFLaEIsYUFBN0IsRUFBNEM7TUFDeENlLFNBQVMsR0FBRyxLQUFLZixhQUFMLENBQW1CZ0IsV0FBbkIsQ0FBWjs7TUFDQSxJQUFJRCxTQUFTLENBQUNFLFVBQVYsQ0FBcUJ4SSxNQUFyQixHQUE4QixDQUFsQyxFQUFxQztRQUNqQ21JLEtBQUssR0FBSUEsS0FBSyxLQUFLLENBQUMsQ0FBWCxJQUFnQkcsU0FBUyxDQUFDRSxVQUFWLENBQXFCLENBQXJCLEVBQXdCNUksSUFBeEIsQ0FBNkJrRixTQUE3QixHQUF5Q3FELEtBQTFELEdBQW1FRyxTQUFTLENBQUNFLFVBQVYsQ0FBcUIsQ0FBckIsRUFBd0I1SSxJQUF4QixDQUE2QmtGLFNBQWhHLEdBQ0pxRCxLQURKO01BRUg7SUFDSjs7SUFFRCxLQUFLVixRQUFMLEdBQWdCZ0IsV0FBVyxDQUFDLE1BQU07TUFDOUI7TUFDQSxPQUFPLEtBQUtDLGVBQUwsQ0FBcUJQLEtBQXJCLEVBQTRCQyxZQUE1QixDQUFQLENBQWtEO0lBRXJELENBSjBCLEVBSXhCLEtBQUtkLGVBSm1CLENBQTNCO0lBS0FxQixPQUFPLENBQUNDLElBQVIsQ0FBYyxxQkFBb0IsS0FBS3hCLFdBQUwsQ0FBaUJsRyxJQUFLLGdCQUFlLElBQUkrRCxJQUFKLENBQVNrRCxLQUFULEVBQWdCVSxXQUFoQixFQUE4QixFQUFyRztFQUNIO0VBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7RUFDSUgsZUFBZSxDQUFDUCxLQUFELEVBQVFXLFlBQVIsRUFBc0I7SUFDakMsTUFBTUMsS0FBSyxDQUFDLHNCQUFELENBQVg7RUFDSDtFQUVEO0FBQ0o7QUFDQTtBQUNBOzs7RUFDSW5CLGFBQWEsQ0FBQ29CLFVBQUQsRUFBYTtJQUN0QixNQUFNRCxLQUFLLENBQUMsc0JBQUQsQ0FBWDtFQUNIOztFQUVERSxZQUFZLENBQUNDLFVBQUQsRUFBYUMsU0FBYixFQUF3QjtJQUNoQyxNQUFNSixLQUFLLENBQUMsc0JBQUQsQ0FBWDtFQUNIOztFQUVESyxNQUFNLENBQUN0QixZQUFELEVBQWVxQixTQUFmLEVBQTBCLENBQy9COztFQUVERSxVQUFVLEdBQUcsQ0FBRTtFQUVmO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztFQUNJQyxTQUFTLENBQUN4QixZQUFELEVBQWV5QixNQUFmLEVBQXVCO0lBQzVCLE1BQU1SLEtBQUssQ0FBQyxzQkFBRCxDQUFYO0VBQ0g7O0VBRURTLEtBQUssR0FBRztJQUNKLElBQUlqTyxTQUFTLENBQUMsS0FBS2tNLFFBQU4sQ0FBYixFQUE4QjtNQUMxQmdDLGFBQWEsQ0FBQyxLQUFLaEMsUUFBTixDQUFiO01BQ0EsS0FBS0EsUUFBTCxHQUFnQjVELFNBQWhCO0lBQ0g7O0lBQ0Q4RSxPQUFPLENBQUNlLEdBQVIsQ0FBWSwyQ0FBWjtJQUNBLEtBQUtDLE9BQUw7RUFDSDs7RUFFREMsT0FBTyxHQUFJLENBQUU7O0VBQ2JELE9BQU8sR0FBRyxDQUFFOztBQTdGVzs7QUFnR1p4QywyR0FBZixFOztBQ25HQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTBDLDBEQUFOLFNBQTJDMUMsNkJBQTNDLENBQWdFO0VBQzVEckcsSUFBSSxDQUFDZ0gsWUFBRCxFQUFlRSxVQUFmLEVBQTJCO0lBQzNCLElBQUdBLFVBQVUsQ0FBQ2hJLE1BQVgsS0FBc0IsQ0FBekIsRUFBNEI7TUFDeEI7SUFDSDs7SUFFRCxNQUFNMkgsRUFBRSxHQUFHLEtBQUtKLGFBQUwsQ0FBbUJPLFlBQW5CLENBQVg7SUFDQSxNQUFNZ0MsUUFBUSxHQUFHOUIsVUFBVSxDQUFDQSxVQUFVLENBQUNoSSxNQUFYLEdBQWtCLENBQW5CLENBQTNCOztJQUNBLElBQUksQ0FBQyxLQUFLaUosWUFBTCxDQUFrQnRCLEVBQWxCLEVBQXNCbUMsUUFBdEIsQ0FBTCxFQUFzQztNQUNsQztJQUNIOztJQUVELElBQUlDLE9BQU8sR0FBRyxDQUFkOztJQUNBLElBQUksS0FBS3ZDLEtBQUwsR0FBYSxDQUFqQixFQUFvQjtNQUNoQnVDLE9BQU8sR0FBRyxLQUFLdkMsS0FBTCxHQUFhc0MsUUFBUSxDQUFDbEssSUFBVCxDQUFja0YsU0FBckM7SUFDSDs7SUFDRDZDLEVBQUUsQ0FBQ29DLE9BQUgsR0FBYUEsT0FBTyxHQUFHcEMsRUFBRSxDQUFDb0MsT0FBYixHQUF1QkEsT0FBdkIsR0FBaUMsQ0FBQ3BDLEVBQUUsQ0FBQ29DLE9BQUgsR0FBYUEsT0FBZCxJQUF5QixDQUF2RTtJQUVBcEMsRUFBRSxDQUFDYSxVQUFILENBQWMxSCxJQUFkLENBQW1CLEdBQUdrSCxVQUF0Qjs7SUFDQSxJQUFHLENBQUN6TSxTQUFTLENBQUMsS0FBS2tNLFFBQU4sQ0FBYixFQUE4QjtNQUMxQixLQUFLUyxXQUFMO0lBQ0g7RUFDSjtFQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0VBQ0lRLGVBQWUsQ0FBQ1AsS0FBRCxFQUFRVyxZQUFSLEVBQXNCO0lBQ2pDLElBQUlSLFNBQUo7SUFDQSxJQUFJMEIsZ0JBQWdCLEdBQUcsSUFBdkIsQ0FGaUMsQ0FJakM7O0lBQ0EsSUFBSUMsVUFBVSxHQUFHLENBQWpCO0lBQ0EsSUFBSUMsVUFBVSxHQUFHLENBQWpCOztJQUNBLEtBQUssSUFBSTNCLFdBQVQsSUFBd0IsS0FBS2hCLGFBQTdCLEVBQTRDO01BQ3hDZSxTQUFTLEdBQUcsS0FBS2YsYUFBTCxDQUFtQmdCLFdBQW5CLENBQVo7O01BQ0EsSUFBSUQsU0FBUyxDQUFDeUIsT0FBVixHQUFvQixDQUF4QixFQUEyQjtRQUN2QixJQUFJQSxPQUFPLEdBQUcxTyxJQUFJLENBQUM4TyxHQUFMLENBQVM3QixTQUFTLENBQUN5QixPQUFuQixFQUE0QnpCLFNBQVMsQ0FBQzhCLE9BQXRDLENBQWQ7UUFDQUgsVUFBVSxHQUFJRixPQUFPLEdBQUdFLFVBQVgsR0FBeUJGLE9BQXpCLEdBQW1DRSxVQUFoRDtRQUNBQyxVQUFVLEdBQUk1QixTQUFTLENBQUN5QixPQUFWLEdBQW9CRyxVQUFyQixHQUFtQzVCLFNBQVMsQ0FBQ3lCLE9BQTdDLEdBQXVERyxVQUFwRTtNQUNIO0lBQ0o7O0lBQ0QsTUFBTUcsTUFBTSxHQUFJaEMsV0FBVyxDQUFDckQsR0FBWixLQUFvQjhELFlBQXBDLENBZmlDLENBZ0JqQzs7SUFDQSxLQUFLLElBQUlQLFdBQVQsSUFBd0IsS0FBS2hCLGFBQTdCLEVBQTRDO01BQ3hDZSxTQUFTLEdBQUcsS0FBS2YsYUFBTCxDQUFtQmdCLFdBQW5CLENBQVo7TUFDQSxLQUFLZixLQUFMLEdBQWFXLEtBQUssR0FBR2tDLE1BQXJCOztNQUNBLElBQUkvQixTQUFTLENBQUNFLFVBQVYsQ0FBcUJ4SSxNQUFyQixHQUE4QixDQUFsQyxFQUFxQztRQUNqQyxNQUFNc0ssR0FBRyxHQUFJaEMsU0FBUyxDQUFDRSxVQUFWLENBQXFCLENBQXJCLEVBQXdCNUksSUFBeEIsQ0FBNkJrRixTQUE3QixHQUF5Q3FELEtBQXREO1FBQ0EsTUFBTW9DLFNBQVMsR0FBR0YsTUFBTSxHQUFHSixVQUEzQixDQUZpQyxDQUdqQztRQUNBOztRQUNBLElBQUlLLEdBQUcsSUFBSUMsU0FBWCxFQUFzQjtVQUNsQjtVQUNBLElBQUlQLGdCQUFnQixLQUFLLElBQXpCLEVBQStCO1lBQzNCQSxnQkFBZ0IsR0FBRzFCLFNBQW5CO1VBQ0gsQ0FGRCxNQUVPO1lBQ0g7WUFDQTBCLGdCQUFnQixHQUFJQSxnQkFBZ0IsQ0FBQ3hCLFVBQWpCLENBQTRCLENBQTVCLEVBQStCNUksSUFBL0IsQ0FBb0NrRixTQUFwQyxHQUFnRHdELFNBQVMsQ0FBQ0UsVUFBVixDQUFxQixDQUFyQixFQUF3QjVJLElBQXhCLENBQTZCa0YsU0FBOUUsR0FDZmtGLGdCQURlLEdBQ0kxQixTQUR2QjtVQUVIO1FBQ0o7TUFDSjtJQUNKLENBcENnQyxDQXNDakM7OztJQUNBLElBQUkwQixnQkFBZ0IsS0FBSyxJQUF6QixFQUErQjtNQUMzQixJQUFJUSxHQUFHLEdBQUdSLGdCQUFnQixDQUFDeEIsVUFBakIsQ0FBNEJpQyxLQUE1QixFQUFWLENBRDJCLENBRzNCO01BQ0E7TUFDQTs7TUFDQUQsR0FBRyxDQUFDLFVBQUQsQ0FBSCxHQUFrQmxDLFNBQVMsQ0FBQ3lCLE9BQVYsR0FBb0JHLFVBQXRDO01BQ0EsS0FBS2QsTUFBTCxDQUFZWSxnQkFBZ0IsQ0FBQzNKLEVBQTdCLEVBQWlDbUssR0FBakM7TUFDQSxPQUFPLElBQVA7SUFDSDs7SUFDRCxPQUFPLEtBQVA7RUFDSDtFQUVEO0FBQ0o7QUFDQTtBQUNBOzs7RUFDSTVDLGFBQWEsQ0FBQ29CLFVBQUQsRUFBYTtJQUN0QixLQUFLekIsYUFBTCxDQUFtQnlCLFVBQVUsQ0FBQzNJLEVBQTlCLElBQW9DO01BQ2hDK0osT0FBTyxFQUFFcEIsVUFBVSxDQUFDb0IsT0FBWCxJQUFzQixDQURDO01BRWhDNUIsVUFBVSxFQUFFLEVBRm9CO01BR2hDbkksRUFBRSxFQUFFMkksVUFBVSxDQUFDM0ksRUFIaUI7TUFJaENxSyxRQUFRLEVBQUUsS0FKc0I7TUFLaEN4SixJQUFJLEVBQUU4SCxVQUFVLENBQUM5SCxJQUFYLElBQW1COEgsVUFBVSxDQUFDM0ksRUFMSjtNQU1oQzBKLE9BQU8sRUFBRSxDQU51QjtNQU9oQ1IsTUFBTSxFQUFFM0MsTUFBTSxDQUFDRyxZQVBpQjtNQU9IO01BQzdCNEQsT0FBTyxFQUFFOUc7SUFSdUIsQ0FBcEM7SUFVQSxLQUFLNkQsV0FBTCxDQUFpQjVHLElBQWpCLENBQXNCa0ksVUFBdEI7RUFDSDs7RUFFREMsWUFBWSxDQUFDQyxVQUFELEVBQWFDLFNBQWIsRUFBd0I7SUFDaEMsSUFBR0QsVUFBVSxDQUFDSyxNQUFYLEtBQXNCM0MsTUFBTSxDQUFDRyxZQUFoQyxFQUE4QztNQUMxQyxPQUFPLElBQVA7SUFDSCxDQUZELE1BRU8sSUFBR21DLFVBQVUsQ0FBQ0ssTUFBWCxLQUFzQjNDLE1BQU0sQ0FBQ0csWUFBN0IsSUFBNkNtQyxVQUFVLENBQUN5QixPQUFYLEtBQXVCeEIsU0FBUyxDQUFDd0IsT0FBakYsRUFBMEY7TUFDN0YsT0FBTyxLQUFQO0lBQ0g7RUFDSjtFQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztFQUNJckIsU0FBUyxDQUFDeEIsWUFBRCxFQUFleUIsTUFBZixFQUF1QjtJQUM1QixJQUFJekIsWUFBWSxJQUFJLEtBQUtQLGFBQXpCLEVBQXdDO01BQ3BDLEtBQUtBLGFBQUwsQ0FBbUJPLFlBQW5CLEVBQWlDeUIsTUFBakMsR0FBMENBLE1BQTFDO01BQ0FaLE9BQU8sQ0FBQ0MsSUFBUixDQUFhVyxNQUFNLEdBQUMsY0FBUCxHQUF3QnpCLFlBQXhCLEdBQXVDLHlCQUFwRDtJQUNIO0VBQ0o7O0VBRUQ4QyxLQUFLLEdBQUc7SUFDSixLQUFLcEQsS0FBTCxHQUFhM0QsU0FBYjtJQUNBOEUsT0FBTyxDQUFDZSxHQUFSLENBQVkseUJBQVo7SUFDQSxLQUFLRixLQUFMOztJQUNBLEtBQUssSUFBSWpCLFdBQVQsSUFBd0IsS0FBS2hCLGFBQTdCLEVBQTRDO01BQ3hDLEtBQUtzRCxlQUFMLENBQXFCdEMsV0FBckI7SUFDSDtFQUNKOztFQUVEc0MsZUFBZSxDQUFDQyxZQUFELEVBQWU7SUFDMUIsTUFBTXhDLFNBQVMsR0FBRyxLQUFLZixhQUFMLENBQW1CdUQsWUFBbkIsQ0FBbEI7SUFDQXhDLFNBQVMsQ0FBQ0UsVUFBVixHQUF1QixFQUF2QjtJQUNBRixTQUFTLENBQUN5QyxrQkFBVixHQUErQixDQUFDLENBQWhDO0lBQ0F6QyxTQUFTLENBQUN5QixPQUFWLEdBQWtCLENBQWxCO0lBQ0F6QixTQUFTLENBQUNpQixNQUFWLEdBQWtCM0MsTUFBTSxDQUFDRyxZQUF6QjtJQUNBdUIsU0FBUyxDQUFDcUMsT0FBVixHQUFvQjlHLFNBQXBCO0VBQ0g7O0FBeEkyRDs7QUEySWpEZ0csNEhBQWYsRTs7QUMvSXlEO0FBQ047QUFDUDtBQUNrQzs7QUFFOUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSx5Q0FBUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzREFBcUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1Qyw2QkFBNEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFxQjtBQUNqQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0Msc0RBQXFCO0FBQ3pEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsWUFBWSxzQ0FBSztBQUNqQixTQUFTO0FBQ1Q7QUFDQSxnQkFBZ0Isc0NBQUs7QUFDckI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTLHNDQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLEtBQUs7QUFDTDtBQUNBLGNBQWMsU0FBUztBQUN2QixLQUFLO0FBQ0w7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBLFNBQVMsOEJBQThCLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQscUJBQXFCOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLFNBQVM7QUFDbEIsZ0NBQWdDLHNEQUFxQjtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkseUNBQVE7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSwyQ0FBVTs7QUFFZDtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBLFlBQVksMkNBQVU7QUFDdEIsZ0JBQWdCLFNBQVMsQ0FBQywyQ0FBVTtBQUNwQztBQUNBLCtCQUErQiwyQ0FBVTtBQUN6QywwQkFBMEIsU0FBUztBQUNuQyxpQkFBaUI7QUFDakI7O0FBRUEsZ0JBQWdCLFNBQVMsQ0FBQyx5Q0FBUTtBQUNsQyx3QkFBd0IseUNBQVE7QUFDaEMsc0JBQXNCLHlDQUFROztBQUU5QixtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBEQVRBX1NZTkNIUk9OSVpFUl9UT1BJQyA9ICdkYXRhLXN5bmNocm9uaXplci0nO1xuZXhwb3J0IGNvbnN0IFRJTUVfU1lOQ0hST05JWkVSX1RPUElDID0gJ2RhdGEtc3luY2hyb25pemVyLXRpbWUtJztcblxuZXhwb3J0IGNvbnN0IERBVEFTT1VSQ0VfREFUQV9UT1BJQyA9ICdkYXRhc291cmNlLWRhdGEtJztcbmV4cG9ydCBjb25zdCBEQVRBU09VUkNFX1RJTUVfVE9QSUMgPSAnZGF0YXNvdXJjZS10aW1lLSc7XG5cbmV4cG9ydCBjb25zdCBGRk1QRUdfVklFV19ERUNPREVfVE9QSUMgPSAnZmZtcGVnLWRlY29kZS0nO1xuXG5leHBvcnQgY29uc3QgTUFHSUNfRU5EX1BBQ0tFVCA9ICdtYWdpYy1wYWNrZXQnO1xuIiwiZXhwb3J0IGNvbnN0IEV2ZW50VHlwZSA9IHtcbiAgICBEQVRBOiAnZGF0YScsXG4gICAgTEFTVF9USU1FOiAnbGFzdC10aW1lJyxcbiAgICBNQVNURVJfVElNRTogJ21hc3Rlci10aW1lJyxcbiAgICBTVEFUVVM6ICdzdGF0dXMnLFxuICAgIFRJTUVfQ0hBTkdFRDogJ3RpbWUtY2hhbmdlZCcsXG4gICAgQ0xPU0VEOiAnY2xvc2VkJ1xufTtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gVGhlIGNvbnRlbnRzIG9mIHRoaXMgZmlsZSBhcmUgc3ViamVjdCB0byB0aGUgTW96aWxsYSBQdWJsaWMgTGljZW5zZSwgdi4gMi4wLlxuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZVxuIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblxuIFNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2VcbiBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyByaWdodHMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gQ29weXJpZ2h0IChDKSAyMDE1LTIwMjAgTWF0aGlldSBEaGFpbmF1dC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuIEF1dGhvcjogTWF0aGlldSBEaGFpbmF1dCA8bWF0aGlldS5kaGFpbmF1dEBnbWFpbC5jb20+XG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqICogQG1vZHVsZSBVdGlscyAqL1xuXG4vKiogTWF4aW11bSB2YWx1ZSBvZiBhIGxvbmcgKi9cbmV4cG9ydCBjb25zdCBNQVhfTE9ORyA9IE1hdGgucG93KDIsIDUzKSArIDE7XG5cbi8qKlxuICogR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbmVkKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mICh2KSAhPT0gJ3VuZGVmaW5lZCcgJiYgdiAhPT0gbnVsbDtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaGFzIGEgdmFsdWUsXG4gdGhhdCBpcyBpdCBpcyBkZWZpbmVkIGFuZCBub24gbnVsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzVmFsdWUodikge1xuICAgIHJldHVybiBpc0RlZmluZWQodikgJiYgdiAhPT0gbnVsbDtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdHJhbnNmb3JtIGhleCBjb2xvciBpbnRvIFJHQlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4MnJnYihoZXgpe1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IGhleC5tYXRjaCgvXFx3XFx3L2cpLm1hcCh4ID0+IHBhcnNlSW50KHgsIDE2KSk7XG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhleDJyZ2JhKGhleCl7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgcGFyc2VJbnQoaGV4LnNsaWNlKDEsIDMpLCAxNiksXG4gICAgICAgIHBhcnNlSW50KGhleC5zbGljZSgzLCA1KSwgMTYpLFxuICAgICAgICBwYXJzZUludChoZXguc2xpY2UoNSwgNyksIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoaGV4LnNsaWNlKDcsIDkpLCAxNikgLyAyNTVcbiAgICBdO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBvZiBhIHBhcnRpY3VsYXIgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzVHlwZSh2LCBleHBlY3RlZFR5cGUpIHtcbiAgICBsZXQgaGFzVmFsID0gaGFzVmFsdWUodik7XG4gICAgcmV0dXJuIGhhc1ZhbCAmJiB0eXBlb2YgKHYpID09PSBleHBlY3RlZFR5cGU7XG59XG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBoYXNUeXBlKHYsICdvYmplY3QnLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkodikge1xuICAgIHJldHVybiBpc0RlZmluZWQodikgJiYgQXJyYXkuaXNBcnJheSh2KTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGhhc1R5cGUodiwgJ2Z1bmN0aW9uJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGlmICghaXNEZWZpbmVkKHYpKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIGRlZmluZWRcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRUcnVlKHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgaWYgKCFpc0RlZmluZWQodikgfHwgIXYpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBhbmQgbm9uLW51bGxcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRUeXBlKHYsIGV4cGVjdGVkVHlwZSwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUpO1xuICAgIGlmICh0eXBlb2YgKHYpICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgb2YgdHlwZSBcIiArIGV4cGVjdGVkVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIHN0cmluZ1xuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEJvb2xlYW4odiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdib29sZWFuJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIHN0cmluZ1xuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFN0cmluZyh2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ3N0cmluZycsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBudW1iZXJcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROdW1iZXIodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdudW1iZXInLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgbnVtYmVyXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UG9zaXRpdmUodiwgbGV0TmFtZSkge1xuICAgIGFzc2VydE51bWJlcih2LCBsZXROYW1lKTtcbiAgICBpZiAodiA8PSAwKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCI7XG4gICAgfVxufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gb2JqZWN0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnb2JqZWN0JywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBvYmplY3RcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcnJheSh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIGFuIGFycmF5XCI7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBmdW5jdGlvblxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnZnVuY3Rpb24nLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGRlZmluZWQgYW5kIG5vbi1udWxsXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SGFzVmFsdWUodiwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUpO1xuICAgIGlmICghaGFzVmFsdWUodikpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3Qgbm90IGJlIG51bGxcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVVVSUQoKSB7XG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LXh4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgbGV0IHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gc3RhbXBzL2VtYmVkcyBhIFVVSUQgaW50byBhbiBvYmplY3QgYW5kIHJldHVybnMgdGhlIFVVSUQgZ2VuZXJhdGVkIGZvciBpdFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhbXBVVUlEKG9iaikge1xuICAgIG9iai5fb3NoX2lkID0gb2JqLl9vc2hfaWQgfHwgcmFuZG9tVVVJRCgpO1xuICAgIHJldHVybiBvYmouX29zaF9pZDtcbn1cblxuLy9idWZmZXIgaXMgYW4gQXJyYXlCdWZmZXIgb2JqZWN0LCB0aGUgb2Zmc2V0IGlmIHNwZWNpZmllZCBpbiBieXRlcywgYW5kIHRoZSB0eXBlIGlzIGEgc3RyaW5nXG4vL2NvcnJlc3BvbmRpbmcgdG8gYW4gT0dDIGRhdGEgdHlwZS5cbi8vU2VlIGh0dHA6Ly9kZWYuc2VlZ3JpZC5jc2lyby5hdS9zaXNzdm9jL29nYy1kZWYvcmVzb3VyY2U/dXJpPWh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZGVmL2RhdGFUeXBlL09HQy8wL1xuLyoqXG4gKlxuICogQHBhcmFtIGJ1ZmZlclxuICogQHBhcmFtIG9mZnNldFxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQYXJzZUJ5dGVzKGJ1ZmZlciwgb2Zmc2V0LCB0eXBlKSB7XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcblxuICAgIC8vTm90ZTogVGhlcmUgZXhpc3QgdHlwZXMgbm90IGxpc3RlZCBpbiB0aGUgbWFwIGJlbG93IHRoYXQgaGF2ZSBPR0MgZGVmaW5pdGlvbnMsIGJ1dCBubyBhcHByb3ByaWF0ZVxuICAgIC8vbWV0aG9kcyBvciBjb3JyZXNwb25kaW5nIHR5cGVzIGF2YWlsYWJsZSBmb3IgcGFyc2luZyBpbiBqYXZhc2NyaXB0LiBUaGV5IGFyZSBmbG9hdDEyOCwgZmxvYXQxNiwgc2lnbmVkTG9uZyxcbiAgICAvL2FuZCB1bnNpZ25lZExvbmdcbiAgICBsZXQgdHlwZU1hcCA9IHtcbiAgICAgICAgZG91YmxlOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRGbG9hdDY0KG9mZnNldCksIGJ5dGVzOiA4fTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXQ2NDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQpLCBieXRlczogOH07XG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0MzI6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEZsb2F0MzIob2Zmc2V0KSwgYnl0ZXM6IDR9O1xuICAgICAgICB9LFxuICAgICAgICBzaWduZWRCeXRlOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRJbnQ4KG9mZnNldCksIGJ5dGVzOiAxfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmVkSW50OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRJbnQzMihvZmZzZXQpLCBieXRlczogNH07XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25lZFNob3J0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRJbnQxNihvZmZzZXQpLCBieXRlczogMn07XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2lnbmVkQnl0ZTogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0VWludDgob2Zmc2V0KSwgYnl0ZXM6IDF9O1xuICAgICAgICB9LFxuICAgICAgICB1bnNpZ25lZEludDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0VWludDMyKG9mZnNldCksIGJ5dGVzOiA0fTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaWduZWRTaG9ydDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0VWludDE2KG9mZnNldCksIGJ5dGVzOiAyfTtcbiAgICAgICAgfSxcbiAgICAgICAgLy9UT0RPOiBzdHJpbmctdXRmLTg6XG4gICAgfTtcbiAgICByZXR1cm4gdHlwZU1hcFt0eXBlXShvZmZzZXQpO1xufVxuXG4vL1RoaXMgZnVuY3Rpb24gcmVjdXJzaXZsZXkgaXRlcmF0ZXMgb3ZlciB0aGUgcmVzdWx0U3RydWN0dXJlIHRvIGZpbGwgaW5cbi8vdmFsdWVzIHJlYWQgZnJvbSBkYXRhIHdoaWNoIHNob3VsZCBiZSBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIHRoZSBwYXlsb2FkIGZyb20gYSB3ZWJzb2NrZXRcbi8qKlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3RcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gb2Zmc2V0Qnl0ZXNcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSZWFkRGF0YShzdHJ1Y3QsIGRhdGEsIG9mZnNldEJ5dGVzKSB7XG4gICAgbGV0IG9mZnNldCA9IG9mZnNldEJ5dGVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RydWN0LmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY3VyckZpZWxkU3RydWN0ID0gc3RydWN0LmZpZWxkc1tpXTtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChjdXJyRmllbGRTdHJ1Y3QudHlwZSkgJiYgY3VyckZpZWxkU3RydWN0LnR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZXQgPSBQYXJzZUJ5dGVzKGRhdGEsIG9mZnNldCwgY3VyckZpZWxkU3RydWN0LnR5cGUpO1xuICAgICAgICAgICAgY3VyckZpZWxkU3RydWN0LnZhbCA9IHJldC52YWw7XG4gICAgICAgICAgICBvZmZzZXQgKz0gcmV0LmJ5dGVzO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmaW5lZChjdXJyRmllbGRTdHJ1Y3QuY291bnQpICYmIGN1cnJGaWVsZFN0cnVjdC5jb3VudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy9jaGVjayBpZiBjb3VudCBpcyBhIHJlZmVyZW5jZSB0byBhbm90aGVyIGxldGlhYmxlXG4gICAgICAgICAgICBpZiAoaXNOYU4oY3VyckZpZWxkU3RydWN0LmNvdW50KSkge1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IGN1cnJGaWVsZFN0cnVjdC5jb3VudDtcbiAgICAgICAgICAgICAgICBsZXQgZmllbGROYW1lID0gc3RydWN0LmlkMkZpZWxkTWFwW2lkXTtcbiAgICAgICAgICAgICAgICBjdXJyRmllbGRTdHJ1Y3QuY291bnQgPSBzdHJ1Y3QuZmluZEZpZWxkQnlOYW1lKGZpZWxkTmFtZSkudmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyRmllbGRTdHJ1Y3QuY291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3VyckZpZWxkU3RydWN0LmZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmllbGQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGN1cnJGaWVsZFN0cnVjdC5maWVsZHNbal0pKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gUmVhZERhdGEoZmllbGQsIGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJGaWVsZFN0cnVjdC52YWwucHVzaChmaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSByZXN1bHRTdHJ1Y3R1cmVcbiAqIEByZXR1cm4ge3t9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gR2V0UmVzdWx0T2JqZWN0KHJlc3VsdFN0cnVjdHVyZSkge1xuICAgIC8vVE9ETzogaGFuZGxlIGNhc2VzIGZvciBuZXN0ZWQgYXJyYXlzIC8gbWF0cml4IGRhdGEgdHlwZXNcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc0RlZmluZWQocmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5jb3VudCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLm5hbWVdID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0uY291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbFtjXS5maWVsZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbFtjXS5maWVsZHNba10ubmFtZV0gPSByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbFtjXS5maWVsZHNba10udmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5uYW1lXS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0ubmFtZV0gPSByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPcGVyYSgpIHtcbiAgICByZXR1cm4gKCEhd2luZG93Lm9wciAmJiAhIW9wci5hZGRvbnMpIHx8ICEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGaXJlZm94KCkge1xuICAgIHJldHVybiB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cuSFRNTEVsZW1lbnQpLmluZGV4T2YoJ0NvbnN0cnVjdG9yJykgPiAwO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDaHJvbWUoKSB7XG4gICAgcmV0dXJuICEhd2luZG93LmNocm9tZSAmJiAhIXdpbmRvdy5jaHJvbWUud2Vic3RvcmU7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4geyp8Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmxpbmsoKSB7XG4gICAgcmV0dXJuIChpc0Nocm9tZSB8fCBpc09wZXJhKSAmJiAhIXdpbmRvdy5DU1M7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBhXG4gKiBAcGFyYW0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlJbnRlcnNlY3QoYSwgYikge1xuICAgIHJldHVybiBhLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gYi5pbmRleE9mKGVsZW1lbnQpID4gLTE7XG4gICAgfSkubGVuZ3RoID4gMDtcbn1cblxuXG4vKipcbiAqXG4gKiBAcGFyYW0gb1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudChvKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJvYmplY3RcIiA/IG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA6IC8vRE9NMlxuICAgICAgICBvICYmIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmIG8gIT09IG51bGwgJiYgby5ub2RlVHlwZSA9PT0gMSAmJiB0eXBlb2Ygby5ub2RlTmFtZSA9PT0gXCJzdHJpbmdcIlxuICAgICk7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1dlYldvcmtlcigpIHtcbiAgICByZXR1cm4gaXNEZWZpbmVkKFdvcmtlcik7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBkaXZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRha2VTY3JlZW5TaG90KGRpdikge1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNzcyBjbGFzcyBmcm9tIGEgdGhlIGRpdiBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSBkaXYgdGhlIGRpdiB0byByZW1vdmUgdGhlIGNsYXNzIGZyb21cbiAqIEBwYXJhbSBjc3MgdGhlIGNzcyBjbGFzcyB0byByZW1vdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNzcyhkaXYsIGNzcykge1xuICAgIGxldCBkaXZDc3MgPSBkaXYuY2xhc3NOYW1lO1xuICAgIGNzcyA9IGRpdkNzcy5yZXBsYWNlKGNzcywgXCJcIik7XG4gICAgZGl2LmNsYXNzTmFtZSA9IGNzcztcbn1cblxuXG4vKipcbiAqIEFkZCBhIGNzcyBjbGFzcyB0byBhIHRoZSBkaXYgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0gZGl2IHRoZSBkaXYgdG8gYWRkIHRoZSBjbGFzcyB0b1xuICogQHBhcmFtIGNzcyB0aGUgY3NzIGNsYXNzIHRvIGFkZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ3NzKGRpdiwgY3NzKSB7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGRpdi5jbGFzc05hbWUgKyBcIiBcIiArIGNzcyk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgYSB7c3RyaW5nfSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgaW5wdXQge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlIHdpdGhvdXQgdGhlIGxhc3QgY2hhcmFjdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVMYXN0Q2hhcklmRXhpc3QodmFsdWUpIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh1bmRlZmluZWQpIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCB8fCAhdmFsdWUuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIDEpO1xufVxuXG4vKipcbiAqIENhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiBhIGdpdmVuIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHRoZSBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uICBjYXBpdGFsaXplRmlyc3RMZXR0ZXIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufVxuXG4vKipcbiAqIFJvdW5kIG9mZiBudW1iZXIgdG8gbmVhcmVzdCAwLjVcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gLSBUaGUgbnVtYmVyIHRvIHJvdW5kIG9mZlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcm91bmRlZCBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kSGFsZihudW0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChudW0qMikvMjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCxcbiAqIHdpbGwgbm90IGJlIGV4ZWN1dGVkLiBUaGUgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHdoZW5cbiAqIGl0IHdpbGwgc3RvcCBiZWluZyBjYWxsZWQgZm9yIG1vcmUgdGhhbiBOIG1pbGxpc2Vjb25kcy5cbiAqIElmIHRoZSBgaW1tZWRpYXRlYCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgdGhlbiB0aGUgZnVuY3Rpb25cbiAqIHdpbGwgYmUgZXhlY3V0ZWQgYXQgdGhlIGZpcnN0IGNhbGwgaW5zdGVhZCBvZiB0aGUgbGFzdC5cbiAqIFBhcmFtZXRlcnMgOlxuICogLSBmdW5jOiB0aGUgZnVuY3Rpb24gdG8gYGRlYm91bmNlcmAuXG4gKiAtIHdhaXQ6IHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIChOKSB0byB3YWl0IGJlZm9yZVxuICogY2FsbCBmdW5jKClcbiAqIC0gaW1tZWRpYXRlIChvcHRpb25hbCk6IENhbGwgZnVuYygpIGF0IHRoZSBmaXJzdCBpbnZvY2F0aW9uXG4gKiBpbnN0ZWFkIG9mIHRoZSBsYXN0IG9uZSAoRGVmYXVsdCBmYWxzZSlcbiAqIC0gY29udGV4dCAob3B0aW9uYWwpOiB0aGUgY29udGV4dCBpbiB3aGljaCB0byBjYWxsIGZ1bmMoKVxuICogKHRoaXMgYnkgZGVmYXVsdClcbiAqL1xuXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4vLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4vLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbi8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgIGxhc3QgPSBub3cgLSB0aW1lc3RhbXA7XG5cbiAgICAgICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIGxlYWRpbmcsIHRyYWlsaW5nLCBjb250ZXh0KSB7XG4gICAgdmFyIGN0eCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBwcmV2aW91cyA9IG5ldyBEYXRlO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjdHgsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGU7XG4gICAgICAgIGlmICghcHJldmlvdXMgJiYgIWxlYWRpbmcpIHByZXZpb3VzID0gbm93O1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICAgIGN0eCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIHRyYWlsaW5nKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2UgKHRhcmdldCwgc291cmNlKSB7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGBzb3VyY2VgIHByb3BlcnRpZXMgYW5kIGlmIGFuIGBPYmplY3RgIHNldCBwcm9wZXJ0eSB0byBtZXJnZSBvZiBgdGFyZ2V0YCBhbmQgYHNvdXJjZWAgcHJvcGVydGllc1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNvdXJjZSkpIHtcbiAgICAgICAgaWYgKHNvdXJjZVtrZXldIGluc3RhbmNlb2YgT2JqZWN0ICYmIGtleSBpbiB0YXJnZXQpIE9iamVjdC5hc3NpZ24oc291cmNlW2tleV0sIG1lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSkpXG4gICAgfVxuXG4gICAgLy8gSm9pbiBgdGFyZ2V0YCBhbmQgbW9kaWZpZWQgYHNvdXJjZWBcbiAgICBPYmplY3QuYXNzaWduKHRhcmdldCB8fCB7fSwgc291cmNlKVxuICAgIHJldHVybiB0YXJnZXRcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2JhVG9BcnJheShzdHIpIHtcbiAgICBsZXQgc3RhcnRJZHhWYWx1ZSA9IHN0ci5pbmRleE9mKCcoJykgKyAxO1xuICAgIGxldCBlbmRJZHhWYWx1ZSA9IHN0ci5pbmRleE9mKCcpJyk7XG4gICAgbGV0IHZhbHVlcyA9IHN0ci5zdWJzdHIoc3RhcnRJZHhWYWx1ZSwgZW5kSWR4VmFsdWUtc3RhcnRJZHhWYWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlcy5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xufVxuIiwiLyoqXG4gKiBFbnVtIGZvciBjb25uZWN0aW9uIHN0YXR1cy5cbiAqIEByZWFkb25seVxuICogQGVudW0ge3tuYW1lOiBzdHJpbmd9fVxuICovXG5leHBvcnQgY29uc3QgU3RhdHVzID0ge1xuICAgIENPTk5FQ1RJTkc6IFwiY29ubmVjdGluZ1wiLFxuICAgIENPTk5FQ1RFRDogIFwiY29ubmVjdGVkXCIsXG4gICAgRElTQ09OTkVDVEVEOiBcImRpc2Nvbm5lY3RlZFwiLFxuICAgIEZFVENIX1NUQVJURUQ6ICdmZXRjaC1zdGFydCcsXG4gICAgRkVUQ0hfRU5ERUQ6ICdmZXRjaC1lbmQnLFxuICAgIENMT1NFRDogXCJjbG9zZWRcIixcbiAgICBDTE9TRURfRVJST1I6IFwiY2xvc2VkLWVycm9yXCJcbn07XG4iLCJpbXBvcnQge2lzRGVmaW5lZH0gZnJvbSBcIi4uL3V0aWxzL1V0aWxzLmpzXCI7XG5pbXBvcnQge1N0YXR1c30gZnJvbSBcIi4uL2Nvbm5lY3Rvci9TdGF0dXMuanNcIjtcblxuY2xhc3MgRGF0YVN5bmNocm9uaXplckFsZ28ge1xuICAgIGNvbnN0cnVjdG9yKGRhdGFTb3VyY2VzLCB0aW1lclJlc29sdXRpb24gPSA1KSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLnRzUnVuID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRpbWVyUmVzb2x1dGlvbiA9IHRpbWVyUmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YXNvdXJjZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZHMgb2YgZGF0YVNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YVNvdXJjZShkcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVEYXRhU291cmNlKGRhdGFTb3VyY2VJZCkge1xuICAgICAgICB0aGlzLmRhdGFzb3VyY2VzID0gdGhpcy5kYXRhc291cmNlcy5maWx0ZXIoIGVsdCA9PiBlbHQuaWQgIT09IGRhdGFTb3VyY2VJZCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZUlkXTtcbiAgICB9XG5cbiAgICBwdXNoKGRhdGFTb3VyY2VJZCwgZGF0YUJsb2Nrcykge1xuICAgIH1cblxuICAgIGdldEN1cnJlbnRUaW1lc3RhbXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRzUnVuO1xuICAgIH1cblxuICAgIHByb2Nlc3NEYXRhKCkge1xuICAgICAgICBsZXQgdHNSZWYgPSAtMTtcbiAgICAgICAgbGV0IGNsb2NrVGltZVJlZiA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgIC8vIGdldCByZWZlcmVuY2Ugc3RhcnQgdGltZXN0YW1wXG4gICAgICAgIC8vIHRoZSByZWZlcmVuY2Ugc3RhcnQgdGltZXN0YW1wIHNob3VsZCB0aGUgb2xkZXN0IG9uZVxuICAgICAgICBsZXQgY3VycmVudERzO1xuICAgICAgICBmb3IgKGxldCBjdXJyZW50RHNJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGN1cnJlbnREcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtjdXJyZW50RHNJZF07XG4gICAgICAgICAgICBpZiAoY3VycmVudERzLmRhdGFCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRzUmVmID0gKHRzUmVmID09PSAtMSB8fCBjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS5kYXRhLnRpbWVzdGFtcCA8IHRzUmVmKSA/IGN1cnJlbnREcy5kYXRhQnVmZmVyWzBdLmRhdGEudGltZXN0YW1wIDpcbiAgICAgICAgICAgICAgICAgICAgdHNSZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgLy8gMSkgcmV0dXJuIHRoZSBvbGRlc3QgZGF0YSBpZiBhbnlcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbXB1dGVOZXh0RGF0YSh0c1JlZiwgY2xvY2tUaW1lUmVmKSkgO1xuXG4gICAgICAgIH0sIHRoaXMudGltZXJSZXNvbHV0aW9uKTtcbiAgICAgICAgY29uc29sZS53YXJuKGBTdGFydGVkIEFsZ29yaXRobSAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gd2l0aCAgdHNSZWY9JHtuZXcgRGF0ZSh0c1JlZikudG9JU09TdHJpbmcoKX1gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBuZXh0IGRhdGEgaWYgYW55LiBXZSByZXR1cm4gb25seSAxIHZhbHVlIGZvciB0aGlzIGl0ZXJhdGlvbi4gSWYgdGhlcmUgYXJlIG11bHRpcGxlIHZhbHVlcyB0byByZXR1cm4sXG4gICAgICogd2UgcmV0dXJuIG9ubHkgdGhlIG9sZGVzdCBvbmUuXG4gICAgICogQHBhcmFtIHRzUmVmIC0gdGhlIHRpbWVzdGFtcCBvZiB0aGUgZmlyc3QgZGF0YVxuICAgICAqIEBwYXJhbSByZWZDbG9ja1RpbWUgLSB0aGUgYWJzb2x1dGUgZGlmZiB0aW1lIHJlYWxseSBzcGVudFxuICAgICAqL1xuICAgIGNvbXB1dGVOZXh0RGF0YSh0c1JlZiwgcmVmQ2xvY2tUaW1lKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdTaG91bGQgYmUgb3ZlcnJpZGRlbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhU291cmNlIHRvIGJlIHN5bmNocm9uaXplZFxuICAgICAqIEBwYXJhbSB7RGF0YXNvdXJjZX0gZGF0YVNvdXJjZSAtIHRoZSBkYXRhU291cmNlIHRvIHN5bmNocm9uaXplXG4gICAgICovXG4gICAgYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdTaG91bGQgYmUgb3ZlcnJpZGRlbicpO1xuICAgIH1cblxuICAgIGNoZWNrVmVyc2lvbihkYXRhc291cmNlLCBkYXRhQmxvY2spIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Nob3VsZCBiZSBvdmVycmlkZGVuJyk7XG4gICAgfVxuXG4gICAgb25EYXRhKGRhdGFTb3VyY2VJZCwgZGF0YUJsb2NrKSB7XG4gICAgfVxuXG4gICAgY2hlY2tTdGFydCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGRhdGFTb3VyY2Ugc3RhdHVzXG4gICAgICogQHBhcmFtIHtTdGF0dXN9IHN0YXR1cyAtIHRoZSBuZXcgc3RhdHVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFTb3VyY2VJZCAtIHRoZSBjb3JyZXNwb25kaW5nIGRhdGFTb3VyY2UgaWRcbiAgICAgKi9cbiAgICBzZXRTdGF0dXMoZGF0YVNvdXJjZUlkLCBzdGF0dXMpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Nob3VsZCBiZSBvdmVycmlkZGVuJyk7XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5pbnRlcnZhbCkpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRGF0YSBzeW5jaHJvbml6ZXIgdGVybWluYXRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICAgIHRoaXMub25DbG9zZSgpO1xuICAgIH1cblxuICAgIG9uU3RhcnQoKSAge31cbiAgICBvbkNsb3NlKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YVN5bmNocm9uaXplckFsZ287XG4iLCJpbXBvcnQge2lzRGVmaW5lZH0gZnJvbSBcIi4uLy4uL3V0aWxzL1V0aWxzLmpzXCI7XG5pbXBvcnQge1N0YXR1c30gZnJvbSBcIi4uLy4uL2Nvbm5lY3Rvci9TdGF0dXMuanNcIjtcbmltcG9ydCBEYXRhU3luY2hyb25pemVyQWxnbyBmcm9tIFwiLi8uLi9EYXRhU3luY2hyb25pemVyQWxnb1wiO1xuXG5jbGFzcyBEYXRhU3luY2hyb25pemVyQWxnb1JlYWx0aW1lIGV4dGVuZHMgRGF0YVN5bmNocm9uaXplckFsZ28ge1xuICAgIHB1c2goZGF0YVNvdXJjZUlkLCBkYXRhQmxvY2tzKSB7XG4gICAgICAgIGlmKGRhdGFCbG9ja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlSWRdO1xuICAgICAgICBjb25zdCBsYXN0RGF0YSA9IGRhdGFCbG9ja3NbZGF0YUJsb2Nrcy5sZW5ndGgtMV07XG4gICAgICAgIGlmICghdGhpcy5jaGVja1ZlcnNpb24oZHMsIGxhc3REYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxhdGVuY3kgPSAwO1xuICAgICAgICBpZiAodGhpcy50c1J1biA+IDApIHtcbiAgICAgICAgICAgIGxhdGVuY3kgPSB0aGlzLnRzUnVuIC0gbGFzdERhdGEuZGF0YS50aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgZHMubGF0ZW5jeSA9IGxhdGVuY3kgPiBkcy5sYXRlbmN5ID8gbGF0ZW5jeSA6IChkcy5sYXRlbmN5ICsgbGF0ZW5jeSkgLyAyO1xuXG4gICAgICAgIGRzLmRhdGFCdWZmZXIucHVzaCguLi5kYXRhQmxvY2tzKTtcbiAgICAgICAgaWYoIWlzRGVmaW5lZCh0aGlzLmludGVydmFsKSkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRGF0YSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgbmV4dCBkYXRhIGlmIGFueS4gV2UgcmV0dXJuIG9ubHkgMSB2YWx1ZSBmb3IgdGhpcyBpdGVyYXRpb24uIElmIHRoZXJlIGFyZSBtdWx0aXBsZSB2YWx1ZXMgdG8gcmV0dXJuLFxuICAgICAqIHdlIHJldHVybiBvbmx5IHRoZSBvbGRlc3Qgb25lLlxuICAgICAqIEBwYXJhbSB0c1JlZiAtIHRoZSB0aW1lc3RhbXAgb2YgdGhlIGZpcnN0IGRhdGFcbiAgICAgKiBAcGFyYW0gcmVmQ2xvY2tUaW1lIC0gdGhlIGFic29sdXRlIGRpZmYgdGltZSByZWFsbHkgc3BlbnRcbiAgICAgKi9cbiAgICBjb21wdXRlTmV4dERhdGEodHNSZWYsIHJlZkNsb2NrVGltZSkge1xuICAgICAgICBsZXQgY3VycmVudERzO1xuICAgICAgICBsZXQgY3VycmVudERzVG9TaGlmdCA9IG51bGw7XG5cbiAgICAgICAgLy8gY29tcHV0ZSBtYXggbGF0ZW5jeVxuICAgICAgICBsZXQgbWF4TGF0ZW5jeSA9IDA7XG4gICAgICAgIGxldCBtaW5MYXRlbmN5ID0gMDtcbiAgICAgICAgZm9yIChsZXQgY3VycmVudERzSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICBjdXJyZW50RHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbY3VycmVudERzSWRdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5sYXRlbmN5ID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBsYXRlbmN5ID0gTWF0aC5taW4oY3VycmVudERzLmxhdGVuY3ksIGN1cnJlbnREcy50aW1lT3V0KTtcbiAgICAgICAgICAgICAgICBtYXhMYXRlbmN5ID0gKGxhdGVuY3kgPiBtYXhMYXRlbmN5KSA/IGxhdGVuY3kgOiBtYXhMYXRlbmN5O1xuICAgICAgICAgICAgICAgIG1pbkxhdGVuY3kgPSAoY3VycmVudERzLmxhdGVuY3kgPCBtaW5MYXRlbmN5KSA/IGN1cnJlbnREcy5sYXRlbmN5IDogbWluTGF0ZW5jeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkQ2xvY2sgPSAocGVyZm9ybWFuY2Uubm93KCkgLSByZWZDbG9ja1RpbWUpO1xuICAgICAgICAvLyBjb21wdXRlIG5leHQgZGF0YSB0byByZXR1cm5cbiAgICAgICAgZm9yIChsZXQgY3VycmVudERzSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICBjdXJyZW50RHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbY3VycmVudERzSWRdO1xuICAgICAgICAgICAgdGhpcy50c1J1biA9IHRzUmVmICsgZENsb2NrO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5kYXRhQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkVHMgPSAoY3VycmVudERzLmRhdGFCdWZmZXJbMF0uZGF0YS50aW1lc3RhbXAgLSB0c1JlZik7XG4gICAgICAgICAgICAgICAgY29uc3QgZENsb2NrQWRqID0gZENsb2NrIC0gbWF4TGF0ZW5jeTtcbiAgICAgICAgICAgICAgICAvLyB3ZSB1c2UgYW4gaW50ZXJtZWRpYXRlIG9iamVjdCB0byBzdG9yZSB0aGUgZGF0YSB0byBzaGlmdCBiZWNhdXNlIHdlIHdhbnQgdG8gcmV0dXJuIHRoZSBvbGRlc3Qgb25lXG4gICAgICAgICAgICAgICAgLy8gb25seVxuICAgICAgICAgICAgICAgIGlmIChkVHMgPD0gZENsb2NrQWRqKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG90aGVyIG9uZSB0byBjb21wYXJlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RHNUb1NoaWZ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHNUb1NoaWZ0ID0gY3VycmVudERzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFrZSB0aGUgb2xkZXN0IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREc1RvU2hpZnQgPSAoY3VycmVudERzVG9TaGlmdC5kYXRhQnVmZmVyWzBdLmRhdGEudGltZXN0YW1wIDwgY3VycmVudERzLmRhdGFCdWZmZXJbMF0uZGF0YS50aW1lc3RhbXApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHNUb1NoaWZ0IDogY3VycmVudERzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluYWxseSBwb3AgdGhlIGRhdGEgZnJvbSBEUyBxdWV1ZVxuICAgICAgICBpZiAoY3VycmVudERzVG9TaGlmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlYyA9IGN1cnJlbnREc1RvU2hpZnQuZGF0YUJ1ZmZlci5zaGlmdCgpO1xuXG4gICAgICAgICAgICAvLyBhZGQgbGF0ZW5jeSBmbGFnIHRvIGRhdGEgcmVjb3JkIGJlZm9yZSB3ZSBkaXNwYXRjaCBpdFxuICAgICAgICAgICAgLy8gdGhpcyBpcyByZWxhdGl2ZSBsYXRlbmN5IGluIG1pbGxpcyBjb21wYXJlZCB0byB0aGUgRFMgd2l0aCB0aGUgbG93ZXN0IGxhdGVuY3lcbiAgICAgICAgICAgIC8vIHNvIGl0IGlzIGFjY3VyYXRlIGV2ZW4gaWYgbG9jYWwgZGV2aWNlIHRpbWUgaXMgbm90IHNldCBwcm9wZXJseVxuICAgICAgICAgICAgcmVjWydAbGF0ZW5jeSddID0gY3VycmVudERzLmxhdGVuY3kgLSBtaW5MYXRlbmN5O1xuICAgICAgICAgICAgdGhpcy5vbkRhdGEoY3VycmVudERzVG9TaGlmdC5pZCwgcmVjKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgZGF0YVNvdXJjZSB0byBiZSBzeW5jaHJvbml6ZWRcbiAgICAgKiBAcGFyYW0ge0RhdGFzb3VyY2V9IGRhdGFTb3VyY2UgLSB0aGUgZGF0YVNvdXJjZSB0byBzeW5jaHJvbml6ZVxuICAgICAqL1xuICAgIGFkZERhdGFTb3VyY2UoZGF0YVNvdXJjZSkge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZS5pZF0gPSB7XG4gICAgICAgICAgICB0aW1lT3V0OiBkYXRhU291cmNlLnRpbWVPdXQgfHwgMCxcbiAgICAgICAgICAgIGRhdGFCdWZmZXI6IFtdLFxuICAgICAgICAgICAgaWQ6IGRhdGFTb3VyY2UuaWQsXG4gICAgICAgICAgICB0aW1lZE91dDogZmFsc2UsXG4gICAgICAgICAgICBuYW1lOiBkYXRhU291cmNlLm5hbWUgfHwgZGF0YVNvdXJjZS5pZCxcbiAgICAgICAgICAgIGxhdGVuY3k6IDAsXG4gICAgICAgICAgICBzdGF0dXM6IFN0YXR1cy5ESVNDT05ORUNURUQsIC8vTUVBTklORyBFbmFibGVkLCAwID0gRGlzYWJsZWRcbiAgICAgICAgICAgIHZlcnNpb246IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRhdGFzb3VyY2VzLnB1c2goZGF0YVNvdXJjZSk7XG4gICAgfVxuXG4gICAgY2hlY2tWZXJzaW9uKGRhdGFzb3VyY2UsIGRhdGFCbG9jaykge1xuICAgICAgICBpZihkYXRhc291cmNlLnN0YXR1cyAhPT0gU3RhdHVzLkRJU0NPTk5FQ1RFRCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZihkYXRhc291cmNlLnN0YXR1cyA9PT0gU3RhdHVzLkRJU0NPTk5FQ1RFRCAmJiBkYXRhc291cmNlLnZlcnNpb24gIT09IGRhdGFCbG9jay52ZXJzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGRhdGFTb3VyY2Ugc3RhdHVzXG4gICAgICogQHBhcmFtIHtTdGF0dXN9IHN0YXR1cyAtIHRoZSBuZXcgc3RhdHVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFTb3VyY2VJZCAtIHRoZSBjb3JyZXNwb25kaW5nIGRhdGFTb3VyY2UgaWRcbiAgICAgKi9cbiAgICBzZXRTdGF0dXMoZGF0YVNvdXJjZUlkLCBzdGF0dXMpIHtcbiAgICAgICAgaWYgKGRhdGFTb3VyY2VJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlSWRdLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihzdGF0dXMrJyBEYXRhU291cmNlICcgKyBkYXRhU291cmNlSWQgKyAnIGZyb20gdGhlIHN5bmNocm9uaXplciAnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnRzUnVuID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zb2xlLmxvZygncmVzZXQgc3luY2hyb25pemVyIGFsZ28nKVxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIGZvciAobGV0IGN1cnJlbnREc0lkIGluIHRoaXMuZGF0YVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldERhdGFTb3VyY2UoY3VycmVudERzSWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXREYXRhU291cmNlKGRhdGFzb3VyY2VJZCkge1xuICAgICAgICBjb25zdCBjdXJyZW50RHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YXNvdXJjZUlkXTtcbiAgICAgICAgY3VycmVudERzLmRhdGFCdWZmZXIgPSBbXTtcbiAgICAgICAgY3VycmVudERzLnN0YXJ0QnVmZmVyaW5nVGltZSA9IC0xO1xuICAgICAgICBjdXJyZW50RHMubGF0ZW5jeT0wO1xuICAgICAgICBjdXJyZW50RHMuc3RhdHVzPSBTdGF0dXMuRElTQ09OTkVDVEVEO1xuICAgICAgICBjdXJyZW50RHMudmVyc2lvbiA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERhdGFTeW5jaHJvbml6ZXJBbGdvUmVhbHRpbWU7XG4iLCJpbXBvcnQge0RBVEFTT1VSQ0VfREFUQV9UT1BJQ30gZnJvbSBcIi4uLy4uL0NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHtFdmVudFR5cGV9IGZyb20gXCIuLi8uLi9ldmVudC9FdmVudFR5cGUuanNcIjtcbmltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vLi4vdXRpbHMvVXRpbHNcIjtcbmltcG9ydCBEYXRhU3luY2hyb25pemVyQWxnb1JlYWx0aW1lIGZyb20gXCIuL0RhdGFTeW5jaHJvbml6ZXJBbGdvLnJlYWx0aW1lLmpzXCI7XG5cbmNvbnN0IGJjQ2hhbm5lbHMgPSB7fTtcbmxldCBkYXRhU3luY2hyb25pemVyQWxnbztcblxubGV0IGluaXQgPSBmYWxzZTtcbmxldCBkYXRhU3luY2hyb25pemVyQnJvYWRDYXN0Q2hhbm5lbCA9IG51bGw7XG5sZXQgbGFzdERhdGEgPSB1bmRlZmluZWQ7XG5jb25zdCBkYXRhU291cmNlcyA9IHt9O1xubGV0IHRpbWVCcm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbmxldCB0b3BpY1RpbWU7XG5sZXQgdG9waWNEYXRhO1xubGV0IG1hc3RlclRpbWVJbnRlcnZhbCA9IHVuZGVmaW5lZDtcbmxldCBjVGltZTtcbmxldCBjSWQ7XG5sZXQgbGFzdFRpbWUgPSAtMTtcbmxldCB2ZXJzaW9uID0gLTE7XG5sZXQgcHJvbWlzZTtcbmxldCBtYXN0ZXJUaW1lUmVmcmVzaFJhdGU7XG5cbnNlbGYub25tZXNzYWdlID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgaGFuZGxlTWVzc2FnZShldmVudCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICBsZXQgcmVzcCA9IHt9O1xuICAgIGlmIChldmVudC5kYXRhLmFja0lkKSB7XG4gICAgICAgIHJlc3AuYWNrSWQgPSBldmVudC5kYXRhLmFja0lkO1xuICAgIH1cblxuICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgdmVyc2lvbiA9IGV2ZW50LmRhdGEudmVyc2lvbjtcblxuICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28gPSBuZXcgRGF0YVN5bmNocm9uaXplckFsZ29SZWFsdGltZShcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmRhdGFTb3VyY2VzLFxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEucmVwbGF5U3BlZWQsXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS50aW1lclJlc29sdXRpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5vbkRhdGEgPSBvbkRhdGE7XG4gICAgICAgICAgICBpbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGFkZERhdGFTb3VyY2VzKGV2ZW50LmRhdGEuZGF0YVNvdXJjZXMpO1xuICAgICAgICAgICAgdG9waWNEYXRhID0gZXZlbnQuZGF0YS50b3BpY3MuZGF0YTtcbiAgICAgICAgICAgIHRvcGljVGltZSA9IGV2ZW50LmRhdGEudG9waWNzLnRpbWU7XG4gICAgICAgICAgICBpbml0QnJvYWRjYXN0Q2hhbm5lbCh0b3BpY0RhdGEsIHRvcGljVGltZSk7XG4gICAgICAgICAgICBtYXN0ZXJUaW1lUmVmcmVzaFJhdGUgPSBldmVudC5kYXRhLm1hc3RlclRpbWVSZWZyZXNoUmF0ZTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdhZGQnICYmIGV2ZW50LmRhdGEuZGF0YVNvdXJjZXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBZGQgZGF0YXNvdXJjZSB0byBzeW5jaHJvbml6ZXIuLicpXG4gICAgICAgICAgICBhZGREYXRhU291cmNlcyhldmVudC5kYXRhLmRhdGFTb3VyY2VzKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdjb25uZWN0Jykge1xuICAgICAgICAgICAgc3RhcnRNYXN0ZXJUaW1lSW50ZXJ2YWwobWFzdGVyVGltZVJlZnJlc2hSYXRlKTtcbiAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLmNoZWNrU3RhcnQoKTtcbiAgICAgICAgICAgIHZlcnNpb24gPSBldmVudC5kYXRhLnZlcnNpb247XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnaXMtY29ubmVjdGVkJykge1xuICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaXMtY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBpc0RlZmluZWQobWFzdGVyVGltZUludGVydmFsKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdyZW1vdmUnICYmIGV2ZW50LmRhdGEuZGF0YVNvdXJjZUlkcykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlbW92ZSBkYXRhc291cmNlIGZyb20gc3luY2hyb25pemVyLi4nKVxuICAgICAgICAgICAgYXdhaXQgcmVtb3ZlRGF0YVNvdXJjZXMoZXZlbnQuZGF0YS5kYXRhU291cmNlSWRzKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdjdXJyZW50LXRpbWUnKSB7XG4gICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdjdXJyZW50LXRpbWUnLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFTeW5jaHJvbml6ZXJBbGdvLmdldEN1cnJlbnRUaW1lc3RhbXAoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdyZXNldCcpIHtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAncmVwbGF5LXNwZWVkJykge1xuICAgICAgICAgICAgaWYgKGRhdGFTeW5jaHJvbml6ZXJBbGdvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgY2hlY2tNYXN0ZXJUaW1lKCk7XG4gICAgICAgICAgICBpZiAoZGF0YVN5bmNocm9uaXplckFsZ28gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5wdXNoKGV2ZW50LmRhdGEuZGF0YVNvdXJjZUlkLCBldmVudC5kYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihleCk7XG4gICAgICAgIHJlc3AuZXJyb3IgPSBleDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXNwLmRhdGEgPSBkYXRhO1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3ApO1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiByZXNldCgpIHtcbiAgICBjbGVhckludGVydmFsKG1hc3RlclRpbWVJbnRlcnZhbCk7XG4gICAgbWFzdGVyVGltZUludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIGlmIChkYXRhU3luY2hyb25pemVyQWxnbyAhPT0gbnVsbCkge1xuICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5yZXNldCgpO1xuICAgIH1cbiAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5USU1FX0NIQU5HRURcbiAgICB9KTtcbiAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5DTE9TRURcbiAgICB9KTtcbiAgICBkYXRhU3luY2hyb25pemVyQnJvYWRDYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5TVEFUVVMsXG4gICAgICAgIHN0YXR1czogJ25vdF9ydW5uaW5nJyxcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaW5pdEJyb2FkY2FzdENoYW5uZWwoZGF0YVRvcGljLCB0aW1lVG9waWMpIHtcbiAgICBjb25zb2xlLmxvZygnbGlzdGVuIG9uIHRvcGljICcsIGRhdGFUb3BpYylcblxuICAgIGRhdGFTeW5jaHJvbml6ZXJCcm9hZENhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoZGF0YVRvcGljKTtcbiAgICBkYXRhU3luY2hyb25pemVyQnJvYWRDYXN0Q2hhbm5lbC5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY2hlY2tNYXN0ZXJUaW1lKCk7XG4gICAgICAgIGlmIChldmVudC5kYXRhLnR5cGUgPT09IEV2ZW50VHlwZS5EQVRBKSB7XG4gICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5wdXNoKGV2ZW50LmRhdGEuZGF0YVNvdXJjZUlkLCBldmVudC5kYXRhLnZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS50eXBlID09PSBFdmVudFR5cGUuU1RBVFVTKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhU291cmNlSWQgPSBldmVudC5kYXRhLmRhdGFTb3VyY2VJZDtcbiAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnNldFN0YXR1cyhkYXRhU291cmNlSWQsIGV2ZW50LmRhdGEuc3RhdHVzKTtcbiAgICAgICAgICAgIC8vIGJ1YmJsZSB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgaWYgKGRhdGFTb3VyY2VJZCBpbiBiY0NoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YVNvdXJjZXNbZGF0YVNvdXJjZUlkXS5uYW1lICsgXCI6IHN0YXR1cz1cIiArIGV2ZW50LmRhdGEuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICBiY0NoYW5uZWxzW2RhdGFTb3VyY2VJZF0ucG9zdE1lc3NhZ2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKHRpbWVUb3BpYyk7XG5cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGRhdGFTb3VyY2VzXG4gKi9cbmZ1bmN0aW9uIGFkZERhdGFTb3VyY2VzKGRhdGFTb3VyY2VzKSB7XG4gICAgZm9yIChsZXQgZGF0YVNvdXJjZSBvZiBkYXRhU291cmNlcykge1xuICAgICAgICBhZGREYXRhU291cmNlKGRhdGFTb3VyY2UpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKSB7XG4gICAgZGF0YVN5bmNocm9uaXplckFsZ28uYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKTtcbiAgICAvLyBjcmVhdGUgYSBCQyB0byBwdXNoIGJhY2sgdGhlIHN5bmNocm9uaXplZCBkYXRhIGludG8gdGhlIERBVEEgU3RyZWFtLlxuICAgIGJjQ2hhbm5lbHNbZGF0YVNvdXJjZS5pZF0gPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChEQVRBU09VUkNFX0RBVEFfVE9QSUMgKyBkYXRhU291cmNlLmlkKTtcblxuICAgIGlmICghKGRhdGFTb3VyY2UuaWQgaW4gZGF0YVNvdXJjZXMpKSB7XG4gICAgICAgIGRhdGFTb3VyY2VzW2RhdGFTb3VyY2UuaWRdID0gZGF0YVNvdXJjZTtcbiAgICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBkYXRhU291cmNlSWRzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZURhdGFTb3VyY2VzKGRhdGFTb3VyY2VJZHMpIHtcbiAgICBmb3IgKGxldCBkYXRhU291cmNlSWQgb2YgZGF0YVNvdXJjZUlkcykge1xuICAgICAgICBhd2FpdCByZW1vdmVEYXRhU291cmNlKGRhdGFTb3VyY2VJZCk7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZW1vdmVEYXRhU291cmNlKGRhdGFTb3VyY2VJZCkge1xuICAgIGF3YWl0IGRhdGFTeW5jaHJvbml6ZXJBbGdvLnJlbW92ZURhdGFTb3VyY2UoZGF0YVNvdXJjZUlkKTtcbiAgICAvLyBjcmVhdGUgYSBCQyB0byBwdXNoIGJhY2sgdGhlIHN5bmNocm9uaXplZCBkYXRhIGludG8gdGhlIERBVEEgU3RyZWFtLlxuICAgIGNvbnNvbGUubG9nKCdkZWxldGluZyBCQyBmb3IgZGF0YXNvdXJjZSAnICsgZGF0YVNvdXJjZUlkKTtcbiAgICBkZWxldGUgYmNDaGFubmVsc1tkYXRhU291cmNlSWRdO1xuICAgIGRlbGV0ZSBkYXRhU291cmNlc1tkYXRhU291cmNlSWRdO1xufVxuXG5mdW5jdGlvbiBjaGVja01hc3RlclRpbWUoKSB7XG4gICAgaWYgKCFpc0RlZmluZWQobWFzdGVyVGltZUludGVydmFsKSkge1xuICAgICAgICBzdGFydE1hc3RlclRpbWVJbnRlcnZhbChtYXN0ZXJUaW1lUmVmcmVzaFJhdGUpO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgY29uc3QgbWFzdGVyVGltZSA9IGRhdGFTeW5jaHJvbml6ZXJBbGdvLmdldEN1cnJlbnRUaW1lc3RhbXAoKTtcbiAgICBjbGVhckludGVydmFsKG1hc3RlclRpbWVJbnRlcnZhbCk7XG4gICAgbWFzdGVyVGltZUludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIC8vIGVuZCBhdCB0aGlzIHRpbWVcbiAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHRpbWVzdGFtcDogbWFzdGVyVGltZSxcbiAgICAgICAgdHlwZTogRXZlbnRUeXBlLk1BU1RFUl9USU1FXG4gICAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgY2hlY2tNYXN0ZXJUaW1lKCk7XG59XG5cbmZ1bmN0aW9uIG9uQ2xvc2UoKSB7XG4gICAgdGltZUJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBFdmVudFR5cGUuQ0xPU0VEXG4gICAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uRGF0YShkYXRhU291cmNlSWQsIGRhdGFCbG9jaykge1xuICAgIGlmIChkYXRhQmxvY2sudmVyc2lvbiAhPT0gdmVyc2lvbikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCd2ZXJzaW9uIGFyZSBkaWZmZXJlbnQ6JywgZGF0YUJsb2NrLnZlcnNpb24sIHZlcnNpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3REYXRhID0ge1xuICAgICAgICBkYXRhU291cmNlSWQ6IGRhdGFTb3VyY2VJZCxcbiAgICAgICAgZGF0YUJsb2NrOiBkYXRhQmxvY2ssXG4gICAgfTtcbiAgICBiY0NoYW5uZWxzW2RhdGFTb3VyY2VJZF0ucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdmFsdWVzOiBbZGF0YUJsb2NrXSxcbiAgICAgICAgICAgIGRhdGFTb3VyY2VJZDogZGF0YVNvdXJjZUlkLFxuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkRBVEFcbiAgICAgICAgfVxuICAgICk7XG59XG5cbnNlbGYub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkYXRhU3luY2hyb25pemVyQWxnby5jbG9zZSgpO1xuICAgIGNvbnNvbGUubG9nKFwiRGF0YSBTeW5jaHJvbml6ZXIgaGFzIGJlZW4gdGVybWluYXRlZCBzdWNjZXNzZnVsbHlcIik7XG59XG5cbmxldCBtYXN0ZXJUaW1lO1xuXG5mdW5jdGlvbiBzdGFydE1hc3RlclRpbWVJbnRlcnZhbChtYXN0ZXJUaW1lUmVmcmVzaFJhdGUpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChtYXN0ZXJUaW1lSW50ZXJ2YWwpKSB7XG4gICAgICAgIG1hc3RlclRpbWVJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIG1hc3RlclRpbWUgPSBkYXRhU3luY2hyb25pemVyQWxnby5nZXRDdXJyZW50VGltZXN0YW1wKCk7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKG1hc3RlclRpbWUpKSB7XG4gICAgICAgICAgICAgICAgdGltZUJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG1hc3RlclRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5NQVNURVJfVElNRVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxhc3REYXRhKSkge1xuICAgICAgICAgICAgICAgIGNUaW1lID0gbGFzdERhdGEuZGF0YUJsb2NrLmRhdGEudGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIGNJZCA9IGxhc3REYXRhLmRhdGFTb3VyY2VJZDtcblxuICAgICAgICAgICAgICAgIGlmICgoY1RpbWUgIT09IC0xICYmIGxhc3RUaW1lID09PSAtMSkgfHwgKGxhc3RUaW1lICE9PSAtMSAmJiBjVGltZSAhPT0gbGFzdFRpbWUpKSB7IC8vIGRvZXMgbm90IHNlbmQgdGhlIHNhbWUgZGF0YSB0d2ljZVxuICAgICAgICAgICAgICAgICAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGNUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVNvdXJjZUlkOiBjSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuTEFTVF9USU1FXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0VGltZSA9IGNUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBtYXN0ZXJUaW1lUmVmcmVzaFJhdGUpO1xuICAgICAgICBkYXRhU3luY2hyb25pemVyQnJvYWRDYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuU1RBVFVTLFxuICAgICAgICAgICAgc3RhdHVzOiAncnVubmluZycsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")}]);