(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{165:function(module,exports,__webpack_require__){eval("/*!\n * Chart.js v2.9.3\n * https://www.chartjs.org\n * (c) 2019 Chart.js Contributors\n * Released under the MIT License\n */\n(function (global, factory) {\n   true ? module.exports = factory(function () {\n    try {\n      return __webpack_require__(1);\n    } catch (e) {}\n  }()) : undefined;\n})(this, function (moment) {\n  'use strict';\n\n  moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  function getCjsExportFromNamespace(n) {\n    return n && n['default'] || n;\n  }\n\n  var colorName = {\n    \"aliceblue\": [240, 248, 255],\n    \"antiquewhite\": [250, 235, 215],\n    \"aqua\": [0, 255, 255],\n    \"aquamarine\": [127, 255, 212],\n    \"azure\": [240, 255, 255],\n    \"beige\": [245, 245, 220],\n    \"bisque\": [255, 228, 196],\n    \"black\": [0, 0, 0],\n    \"blanchedalmond\": [255, 235, 205],\n    \"blue\": [0, 0, 255],\n    \"blueviolet\": [138, 43, 226],\n    \"brown\": [165, 42, 42],\n    \"burlywood\": [222, 184, 135],\n    \"cadetblue\": [95, 158, 160],\n    \"chartreuse\": [127, 255, 0],\n    \"chocolate\": [210, 105, 30],\n    \"coral\": [255, 127, 80],\n    \"cornflowerblue\": [100, 149, 237],\n    \"cornsilk\": [255, 248, 220],\n    \"crimson\": [220, 20, 60],\n    \"cyan\": [0, 255, 255],\n    \"darkblue\": [0, 0, 139],\n    \"darkcyan\": [0, 139, 139],\n    \"darkgoldenrod\": [184, 134, 11],\n    \"darkgray\": [169, 169, 169],\n    \"darkgreen\": [0, 100, 0],\n    \"darkgrey\": [169, 169, 169],\n    \"darkkhaki\": [189, 183, 107],\n    \"darkmagenta\": [139, 0, 139],\n    \"darkolivegreen\": [85, 107, 47],\n    \"darkorange\": [255, 140, 0],\n    \"darkorchid\": [153, 50, 204],\n    \"darkred\": [139, 0, 0],\n    \"darksalmon\": [233, 150, 122],\n    \"darkseagreen\": [143, 188, 143],\n    \"darkslateblue\": [72, 61, 139],\n    \"darkslategray\": [47, 79, 79],\n    \"darkslategrey\": [47, 79, 79],\n    \"darkturquoise\": [0, 206, 209],\n    \"darkviolet\": [148, 0, 211],\n    \"deeppink\": [255, 20, 147],\n    \"deepskyblue\": [0, 191, 255],\n    \"dimgray\": [105, 105, 105],\n    \"dimgrey\": [105, 105, 105],\n    \"dodgerblue\": [30, 144, 255],\n    \"firebrick\": [178, 34, 34],\n    \"floralwhite\": [255, 250, 240],\n    \"forestgreen\": [34, 139, 34],\n    \"fuchsia\": [255, 0, 255],\n    \"gainsboro\": [220, 220, 220],\n    \"ghostwhite\": [248, 248, 255],\n    \"gold\": [255, 215, 0],\n    \"goldenrod\": [218, 165, 32],\n    \"gray\": [128, 128, 128],\n    \"green\": [0, 128, 0],\n    \"greenyellow\": [173, 255, 47],\n    \"grey\": [128, 128, 128],\n    \"honeydew\": [240, 255, 240],\n    \"hotpink\": [255, 105, 180],\n    \"indianred\": [205, 92, 92],\n    \"indigo\": [75, 0, 130],\n    \"ivory\": [255, 255, 240],\n    \"khaki\": [240, 230, 140],\n    \"lavender\": [230, 230, 250],\n    \"lavenderblush\": [255, 240, 245],\n    \"lawngreen\": [124, 252, 0],\n    \"lemonchiffon\": [255, 250, 205],\n    \"lightblue\": [173, 216, 230],\n    \"lightcoral\": [240, 128, 128],\n    \"lightcyan\": [224, 255, 255],\n    \"lightgoldenrodyellow\": [250, 250, 210],\n    \"lightgray\": [211, 211, 211],\n    \"lightgreen\": [144, 238, 144],\n    \"lightgrey\": [211, 211, 211],\n    \"lightpink\": [255, 182, 193],\n    \"lightsalmon\": [255, 160, 122],\n    \"lightseagreen\": [32, 178, 170],\n    \"lightskyblue\": [135, 206, 250],\n    \"lightslategray\": [119, 136, 153],\n    \"lightslategrey\": [119, 136, 153],\n    \"lightsteelblue\": [176, 196, 222],\n    \"lightyellow\": [255, 255, 224],\n    \"lime\": [0, 255, 0],\n    \"limegreen\": [50, 205, 50],\n    \"linen\": [250, 240, 230],\n    \"magenta\": [255, 0, 255],\n    \"maroon\": [128, 0, 0],\n    \"mediumaquamarine\": [102, 205, 170],\n    \"mediumblue\": [0, 0, 205],\n    \"mediumorchid\": [186, 85, 211],\n    \"mediumpurple\": [147, 112, 219],\n    \"mediumseagreen\": [60, 179, 113],\n    \"mediumslateblue\": [123, 104, 238],\n    \"mediumspringgreen\": [0, 250, 154],\n    \"mediumturquoise\": [72, 209, 204],\n    \"mediumvioletred\": [199, 21, 133],\n    \"midnightblue\": [25, 25, 112],\n    \"mintcream\": [245, 255, 250],\n    \"mistyrose\": [255, 228, 225],\n    \"moccasin\": [255, 228, 181],\n    \"navajowhite\": [255, 222, 173],\n    \"navy\": [0, 0, 128],\n    \"oldlace\": [253, 245, 230],\n    \"olive\": [128, 128, 0],\n    \"olivedrab\": [107, 142, 35],\n    \"orange\": [255, 165, 0],\n    \"orangered\": [255, 69, 0],\n    \"orchid\": [218, 112, 214],\n    \"palegoldenrod\": [238, 232, 170],\n    \"palegreen\": [152, 251, 152],\n    \"paleturquoise\": [175, 238, 238],\n    \"palevioletred\": [219, 112, 147],\n    \"papayawhip\": [255, 239, 213],\n    \"peachpuff\": [255, 218, 185],\n    \"peru\": [205, 133, 63],\n    \"pink\": [255, 192, 203],\n    \"plum\": [221, 160, 221],\n    \"powderblue\": [176, 224, 230],\n    \"purple\": [128, 0, 128],\n    \"rebeccapurple\": [102, 51, 153],\n    \"red\": [255, 0, 0],\n    \"rosybrown\": [188, 143, 143],\n    \"royalblue\": [65, 105, 225],\n    \"saddlebrown\": [139, 69, 19],\n    \"salmon\": [250, 128, 114],\n    \"sandybrown\": [244, 164, 96],\n    \"seagreen\": [46, 139, 87],\n    \"seashell\": [255, 245, 238],\n    \"sienna\": [160, 82, 45],\n    \"silver\": [192, 192, 192],\n    \"skyblue\": [135, 206, 235],\n    \"slateblue\": [106, 90, 205],\n    \"slategray\": [112, 128, 144],\n    \"slategrey\": [112, 128, 144],\n    \"snow\": [255, 250, 250],\n    \"springgreen\": [0, 255, 127],\n    \"steelblue\": [70, 130, 180],\n    \"tan\": [210, 180, 140],\n    \"teal\": [0, 128, 128],\n    \"thistle\": [216, 191, 216],\n    \"tomato\": [255, 99, 71],\n    \"turquoise\": [64, 224, 208],\n    \"violet\": [238, 130, 238],\n    \"wheat\": [245, 222, 179],\n    \"white\": [255, 255, 255],\n    \"whitesmoke\": [245, 245, 245],\n    \"yellow\": [255, 255, 0],\n    \"yellowgreen\": [154, 205, 50]\n  };\n  var conversions = createCommonjsModule(function (module) {\n    /* MIT license */\n    // NOTE: conversions should only return primitive values (i.e. arrays, or\n    //       values that give correct `typeof` results).\n    //       do not use box values types (i.e. Number(), String(), etc.)\n    var reverseKeywords = {};\n\n    for (var key in colorName) {\n      if (colorName.hasOwnProperty(key)) {\n        reverseKeywords[colorName[key]] = key;\n      }\n    }\n\n    var convert = module.exports = {\n      rgb: {\n        channels: 3,\n        labels: 'rgb'\n      },\n      hsl: {\n        channels: 3,\n        labels: 'hsl'\n      },\n      hsv: {\n        channels: 3,\n        labels: 'hsv'\n      },\n      hwb: {\n        channels: 3,\n        labels: 'hwb'\n      },\n      cmyk: {\n        channels: 4,\n        labels: 'cmyk'\n      },\n      xyz: {\n        channels: 3,\n        labels: 'xyz'\n      },\n      lab: {\n        channels: 3,\n        labels: 'lab'\n      },\n      lch: {\n        channels: 3,\n        labels: 'lch'\n      },\n      hex: {\n        channels: 1,\n        labels: ['hex']\n      },\n      keyword: {\n        channels: 1,\n        labels: ['keyword']\n      },\n      ansi16: {\n        channels: 1,\n        labels: ['ansi16']\n      },\n      ansi256: {\n        channels: 1,\n        labels: ['ansi256']\n      },\n      hcg: {\n        channels: 3,\n        labels: ['h', 'c', 'g']\n      },\n      apple: {\n        channels: 3,\n        labels: ['r16', 'g16', 'b16']\n      },\n      gray: {\n        channels: 1,\n        labels: ['gray']\n      }\n    }; // hide .channels and .labels properties\n\n    for (var model in convert) {\n      if (convert.hasOwnProperty(model)) {\n        if (!('channels' in convert[model])) {\n          throw new Error('missing channels property: ' + model);\n        }\n\n        if (!('labels' in convert[model])) {\n          throw new Error('missing channel labels property: ' + model);\n        }\n\n        if (convert[model].labels.length !== convert[model].channels) {\n          throw new Error('channel and label counts mismatch: ' + model);\n        }\n\n        var channels = convert[model].channels;\n        var labels = convert[model].labels;\n        delete convert[model].channels;\n        delete convert[model].labels;\n        Object.defineProperty(convert[model], 'channels', {\n          value: channels\n        });\n        Object.defineProperty(convert[model], 'labels', {\n          value: labels\n        });\n      }\n    }\n\n    convert.rgb.hsl = function (rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var min = Math.min(r, g, b);\n      var max = Math.max(r, g, b);\n      var delta = max - min;\n      var h;\n      var s;\n      var l;\n\n      if (max === min) {\n        h = 0;\n      } else if (r === max) {\n        h = (g - b) / delta;\n      } else if (g === max) {\n        h = 2 + (b - r) / delta;\n      } else if (b === max) {\n        h = 4 + (r - g) / delta;\n      }\n\n      h = Math.min(h * 60, 360);\n\n      if (h < 0) {\n        h += 360;\n      }\n\n      l = (min + max) / 2;\n\n      if (max === min) {\n        s = 0;\n      } else if (l <= 0.5) {\n        s = delta / (max + min);\n      } else {\n        s = delta / (2 - max - min);\n      }\n\n      return [h, s * 100, l * 100];\n    };\n\n    convert.rgb.hsv = function (rgb) {\n      var rdif;\n      var gdif;\n      var bdif;\n      var h;\n      var s;\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var v = Math.max(r, g, b);\n      var diff = v - Math.min(r, g, b);\n\n      var diffc = function (c) {\n        return (v - c) / 6 / diff + 1 / 2;\n      };\n\n      if (diff === 0) {\n        h = s = 0;\n      } else {\n        s = diff / v;\n        rdif = diffc(r);\n        gdif = diffc(g);\n        bdif = diffc(b);\n\n        if (r === v) {\n          h = bdif - gdif;\n        } else if (g === v) {\n          h = 1 / 3 + rdif - bdif;\n        } else if (b === v) {\n          h = 2 / 3 + gdif - rdif;\n        }\n\n        if (h < 0) {\n          h += 1;\n        } else if (h > 1) {\n          h -= 1;\n        }\n      }\n\n      return [h * 360, s * 100, v * 100];\n    };\n\n    convert.rgb.hwb = function (rgb) {\n      var r = rgb[0];\n      var g = rgb[1];\n      var b = rgb[2];\n      var h = convert.rgb.hsl(rgb)[0];\n      var w = 1 / 255 * Math.min(r, Math.min(g, b));\n      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n      return [h, w * 100, b * 100];\n    };\n\n    convert.rgb.cmyk = function (rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var c;\n      var m;\n      var y;\n      var k;\n      k = Math.min(1 - r, 1 - g, 1 - b);\n      c = (1 - r - k) / (1 - k) || 0;\n      m = (1 - g - k) / (1 - k) || 0;\n      y = (1 - b - k) / (1 - k) || 0;\n      return [c * 100, m * 100, y * 100, k * 100];\n    };\n    /**\n     * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n     * */\n\n\n    function comparativeDistance(x, y) {\n      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);\n    }\n\n    convert.rgb.keyword = function (rgb) {\n      var reversed = reverseKeywords[rgb];\n\n      if (reversed) {\n        return reversed;\n      }\n\n      var currentClosestDistance = Infinity;\n      var currentClosestKeyword;\n\n      for (var keyword in colorName) {\n        if (colorName.hasOwnProperty(keyword)) {\n          var value = colorName[keyword]; // Compute comparative distance\n\n          var distance = comparativeDistance(rgb, value); // Check if its less, if so set as closest\n\n          if (distance < currentClosestDistance) {\n            currentClosestDistance = distance;\n            currentClosestKeyword = keyword;\n          }\n        }\n      }\n\n      return currentClosestKeyword;\n    };\n\n    convert.keyword.rgb = function (keyword) {\n      return colorName[keyword];\n    };\n\n    convert.rgb.xyz = function (rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255; // assume sRGB\n\n      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\n      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n      return [x * 100, y * 100, z * 100];\n    };\n\n    convert.rgb.lab = function (rgb) {\n      var xyz = convert.rgb.xyz(rgb);\n      var x = xyz[0];\n      var y = xyz[1];\n      var z = xyz[2];\n      var l;\n      var a;\n      var b;\n      x /= 95.047;\n      y /= 100;\n      z /= 108.883;\n      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n      l = 116 * y - 16;\n      a = 500 * (x - y);\n      b = 200 * (y - z);\n      return [l, a, b];\n    };\n\n    convert.hsl.rgb = function (hsl) {\n      var h = hsl[0] / 360;\n      var s = hsl[1] / 100;\n      var l = hsl[2] / 100;\n      var t1;\n      var t2;\n      var t3;\n      var rgb;\n      var val;\n\n      if (s === 0) {\n        val = l * 255;\n        return [val, val, val];\n      }\n\n      if (l < 0.5) {\n        t2 = l * (1 + s);\n      } else {\n        t2 = l + s - l * s;\n      }\n\n      t1 = 2 * l - t2;\n      rgb = [0, 0, 0];\n\n      for (var i = 0; i < 3; i++) {\n        t3 = h + 1 / 3 * -(i - 1);\n\n        if (t3 < 0) {\n          t3++;\n        }\n\n        if (t3 > 1) {\n          t3--;\n        }\n\n        if (6 * t3 < 1) {\n          val = t1 + (t2 - t1) * 6 * t3;\n        } else if (2 * t3 < 1) {\n          val = t2;\n        } else if (3 * t3 < 2) {\n          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n        } else {\n          val = t1;\n        }\n\n        rgb[i] = val * 255;\n      }\n\n      return rgb;\n    };\n\n    convert.hsl.hsv = function (hsl) {\n      var h = hsl[0];\n      var s = hsl[1] / 100;\n      var l = hsl[2] / 100;\n      var smin = s;\n      var lmin = Math.max(l, 0.01);\n      var sv;\n      var v;\n      l *= 2;\n      s *= l <= 1 ? l : 2 - l;\n      smin *= lmin <= 1 ? lmin : 2 - lmin;\n      v = (l + s) / 2;\n      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);\n      return [h, sv * 100, v * 100];\n    };\n\n    convert.hsv.rgb = function (hsv) {\n      var h = hsv[0] / 60;\n      var s = hsv[1] / 100;\n      var v = hsv[2] / 100;\n      var hi = Math.floor(h) % 6;\n      var f = h - Math.floor(h);\n      var p = 255 * v * (1 - s);\n      var q = 255 * v * (1 - s * f);\n      var t = 255 * v * (1 - s * (1 - f));\n      v *= 255;\n\n      switch (hi) {\n        case 0:\n          return [v, t, p];\n\n        case 1:\n          return [q, v, p];\n\n        case 2:\n          return [p, v, t];\n\n        case 3:\n          return [p, q, v];\n\n        case 4:\n          return [t, p, v];\n\n        case 5:\n          return [v, p, q];\n      }\n    };\n\n    convert.hsv.hsl = function (hsv) {\n      var h = hsv[0];\n      var s = hsv[1] / 100;\n      var v = hsv[2] / 100;\n      var vmin = Math.max(v, 0.01);\n      var lmin;\n      var sl;\n      var l;\n      l = (2 - s) * v;\n      lmin = (2 - s) * vmin;\n      sl = s * vmin;\n      sl /= lmin <= 1 ? lmin : 2 - lmin;\n      sl = sl || 0;\n      l /= 2;\n      return [h, sl * 100, l * 100];\n    }; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb\n\n\n    convert.hwb.rgb = function (hwb) {\n      var h = hwb[0] / 360;\n      var wh = hwb[1] / 100;\n      var bl = hwb[2] / 100;\n      var ratio = wh + bl;\n      var i;\n      var v;\n      var f;\n      var n; // wh + bl cant be > 1\n\n      if (ratio > 1) {\n        wh /= ratio;\n        bl /= ratio;\n      }\n\n      i = Math.floor(6 * h);\n      v = 1 - bl;\n      f = 6 * h - i;\n\n      if ((i & 0x01) !== 0) {\n        f = 1 - f;\n      }\n\n      n = wh + f * (v - wh); // linear interpolation\n\n      var r;\n      var g;\n      var b;\n\n      switch (i) {\n        default:\n        case 6:\n        case 0:\n          r = v;\n          g = n;\n          b = wh;\n          break;\n\n        case 1:\n          r = n;\n          g = v;\n          b = wh;\n          break;\n\n        case 2:\n          r = wh;\n          g = v;\n          b = n;\n          break;\n\n        case 3:\n          r = wh;\n          g = n;\n          b = v;\n          break;\n\n        case 4:\n          r = n;\n          g = wh;\n          b = v;\n          break;\n\n        case 5:\n          r = v;\n          g = wh;\n          b = n;\n          break;\n      }\n\n      return [r * 255, g * 255, b * 255];\n    };\n\n    convert.cmyk.rgb = function (cmyk) {\n      var c = cmyk[0] / 100;\n      var m = cmyk[1] / 100;\n      var y = cmyk[2] / 100;\n      var k = cmyk[3] / 100;\n      var r;\n      var g;\n      var b;\n      r = 1 - Math.min(1, c * (1 - k) + k);\n      g = 1 - Math.min(1, m * (1 - k) + k);\n      b = 1 - Math.min(1, y * (1 - k) + k);\n      return [r * 255, g * 255, b * 255];\n    };\n\n    convert.xyz.rgb = function (xyz) {\n      var x = xyz[0] / 100;\n      var y = xyz[1] / 100;\n      var z = xyz[2] / 100;\n      var r;\n      var g;\n      var b;\n      r = x * 3.2406 + y * -1.5372 + z * -0.4986;\n      g = x * -0.9689 + y * 1.8758 + z * 0.0415;\n      b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB\n\n      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;\n      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;\n      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;\n      r = Math.min(Math.max(0, r), 1);\n      g = Math.min(Math.max(0, g), 1);\n      b = Math.min(Math.max(0, b), 1);\n      return [r * 255, g * 255, b * 255];\n    };\n\n    convert.xyz.lab = function (xyz) {\n      var x = xyz[0];\n      var y = xyz[1];\n      var z = xyz[2];\n      var l;\n      var a;\n      var b;\n      x /= 95.047;\n      y /= 100;\n      z /= 108.883;\n      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n      l = 116 * y - 16;\n      a = 500 * (x - y);\n      b = 200 * (y - z);\n      return [l, a, b];\n    };\n\n    convert.lab.xyz = function (lab) {\n      var l = lab[0];\n      var a = lab[1];\n      var b = lab[2];\n      var x;\n      var y;\n      var z;\n      y = (l + 16) / 116;\n      x = a / 500 + y;\n      z = y - b / 200;\n      var y2 = Math.pow(y, 3);\n      var x2 = Math.pow(x, 3);\n      var z2 = Math.pow(z, 3);\n      y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n      x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n      z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n      x *= 95.047;\n      y *= 100;\n      z *= 108.883;\n      return [x, y, z];\n    };\n\n    convert.lab.lch = function (lab) {\n      var l = lab[0];\n      var a = lab[1];\n      var b = lab[2];\n      var hr;\n      var h;\n      var c;\n      hr = Math.atan2(b, a);\n      h = hr * 360 / 2 / Math.PI;\n\n      if (h < 0) {\n        h += 360;\n      }\n\n      c = Math.sqrt(a * a + b * b);\n      return [l, c, h];\n    };\n\n    convert.lch.lab = function (lch) {\n      var l = lch[0];\n      var c = lch[1];\n      var h = lch[2];\n      var a;\n      var b;\n      var hr;\n      hr = h / 360 * 2 * Math.PI;\n      a = c * Math.cos(hr);\n      b = c * Math.sin(hr);\n      return [l, a, b];\n    };\n\n    convert.rgb.ansi16 = function (args) {\n      var r = args[0];\n      var g = args[1];\n      var b = args[2];\n      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization\n\n      value = Math.round(value / 50);\n\n      if (value === 0) {\n        return 30;\n      }\n\n      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));\n\n      if (value === 2) {\n        ansi += 60;\n      }\n\n      return ansi;\n    };\n\n    convert.hsv.ansi16 = function (args) {\n      // optimization here; we already know the value and don't need to get\n      // it converted for us.\n      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n    };\n\n    convert.rgb.ansi256 = function (args) {\n      var r = args[0];\n      var g = args[1];\n      var b = args[2]; // we use the extended greyscale palette here, with the exception of\n      // black and white. normal palette only has 4 greyscale shades.\n\n      if (r === g && g === b) {\n        if (r < 8) {\n          return 16;\n        }\n\n        if (r > 248) {\n          return 231;\n        }\n\n        return Math.round((r - 8) / 247 * 24) + 232;\n      }\n\n      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);\n      return ansi;\n    };\n\n    convert.ansi16.rgb = function (args) {\n      var color = args % 10; // handle greyscale\n\n      if (color === 0 || color === 7) {\n        if (args > 50) {\n          color += 3.5;\n        }\n\n        color = color / 10.5 * 255;\n        return [color, color, color];\n      }\n\n      var mult = (~~(args > 50) + 1) * 0.5;\n      var r = (color & 1) * mult * 255;\n      var g = (color >> 1 & 1) * mult * 255;\n      var b = (color >> 2 & 1) * mult * 255;\n      return [r, g, b];\n    };\n\n    convert.ansi256.rgb = function (args) {\n      // handle greyscale\n      if (args >= 232) {\n        var c = (args - 232) * 10 + 8;\n        return [c, c, c];\n      }\n\n      args -= 16;\n      var rem;\n      var r = Math.floor(args / 36) / 5 * 255;\n      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n      var b = rem % 6 / 5 * 255;\n      return [r, g, b];\n    };\n\n    convert.rgb.hex = function (args) {\n      var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);\n      var string = integer.toString(16).toUpperCase();\n      return '000000'.substring(string.length) + string;\n    };\n\n    convert.hex.rgb = function (args) {\n      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\n      if (!match) {\n        return [0, 0, 0];\n      }\n\n      var colorString = match[0];\n\n      if (match[0].length === 3) {\n        colorString = colorString.split('').map(function (char) {\n          return char + char;\n        }).join('');\n      }\n\n      var integer = parseInt(colorString, 16);\n      var r = integer >> 16 & 0xFF;\n      var g = integer >> 8 & 0xFF;\n      var b = integer & 0xFF;\n      return [r, g, b];\n    };\n\n    convert.rgb.hcg = function (rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var max = Math.max(Math.max(r, g), b);\n      var min = Math.min(Math.min(r, g), b);\n      var chroma = max - min;\n      var grayscale;\n      var hue;\n\n      if (chroma < 1) {\n        grayscale = min / (1 - chroma);\n      } else {\n        grayscale = 0;\n      }\n\n      if (chroma <= 0) {\n        hue = 0;\n      } else if (max === r) {\n        hue = (g - b) / chroma % 6;\n      } else if (max === g) {\n        hue = 2 + (b - r) / chroma;\n      } else {\n        hue = 4 + (r - g) / chroma + 4;\n      }\n\n      hue /= 6;\n      hue %= 1;\n      return [hue * 360, chroma * 100, grayscale * 100];\n    };\n\n    convert.hsl.hcg = function (hsl) {\n      var s = hsl[1] / 100;\n      var l = hsl[2] / 100;\n      var c = 1;\n      var f = 0;\n\n      if (l < 0.5) {\n        c = 2.0 * s * l;\n      } else {\n        c = 2.0 * s * (1.0 - l);\n      }\n\n      if (c < 1.0) {\n        f = (l - 0.5 * c) / (1.0 - c);\n      }\n\n      return [hsl[0], c * 100, f * 100];\n    };\n\n    convert.hsv.hcg = function (hsv) {\n      var s = hsv[1] / 100;\n      var v = hsv[2] / 100;\n      var c = s * v;\n      var f = 0;\n\n      if (c < 1.0) {\n        f = (v - c) / (1 - c);\n      }\n\n      return [hsv[0], c * 100, f * 100];\n    };\n\n    convert.hcg.rgb = function (hcg) {\n      var h = hcg[0] / 360;\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n\n      if (c === 0.0) {\n        return [g * 255, g * 255, g * 255];\n      }\n\n      var pure = [0, 0, 0];\n      var hi = h % 1 * 6;\n      var v = hi % 1;\n      var w = 1 - v;\n      var mg = 0;\n\n      switch (Math.floor(hi)) {\n        case 0:\n          pure[0] = 1;\n          pure[1] = v;\n          pure[2] = 0;\n          break;\n\n        case 1:\n          pure[0] = w;\n          pure[1] = 1;\n          pure[2] = 0;\n          break;\n\n        case 2:\n          pure[0] = 0;\n          pure[1] = 1;\n          pure[2] = v;\n          break;\n\n        case 3:\n          pure[0] = 0;\n          pure[1] = w;\n          pure[2] = 1;\n          break;\n\n        case 4:\n          pure[0] = v;\n          pure[1] = 0;\n          pure[2] = 1;\n          break;\n\n        default:\n          pure[0] = 1;\n          pure[1] = 0;\n          pure[2] = w;\n      }\n\n      mg = (1.0 - c) * g;\n      return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];\n    };\n\n    convert.hcg.hsv = function (hcg) {\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      var v = c + g * (1.0 - c);\n      var f = 0;\n\n      if (v > 0.0) {\n        f = c / v;\n      }\n\n      return [hcg[0], f * 100, v * 100];\n    };\n\n    convert.hcg.hsl = function (hcg) {\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      var l = g * (1.0 - c) + 0.5 * c;\n      var s = 0;\n\n      if (l > 0.0 && l < 0.5) {\n        s = c / (2 * l);\n      } else if (l >= 0.5 && l < 1.0) {\n        s = c / (2 * (1 - l));\n      }\n\n      return [hcg[0], s * 100, l * 100];\n    };\n\n    convert.hcg.hwb = function (hcg) {\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      var v = c + g * (1.0 - c);\n      return [hcg[0], (v - c) * 100, (1 - v) * 100];\n    };\n\n    convert.hwb.hcg = function (hwb) {\n      var w = hwb[1] / 100;\n      var b = hwb[2] / 100;\n      var v = 1 - b;\n      var c = v - w;\n      var g = 0;\n\n      if (c < 1) {\n        g = (v - c) / (1 - c);\n      }\n\n      return [hwb[0], c * 100, g * 100];\n    };\n\n    convert.apple.rgb = function (apple) {\n      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];\n    };\n\n    convert.rgb.apple = function (rgb) {\n      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];\n    };\n\n    convert.gray.rgb = function (args) {\n      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n    };\n\n    convert.gray.hsl = convert.gray.hsv = function (args) {\n      return [0, 0, args[0]];\n    };\n\n    convert.gray.hwb = function (gray) {\n      return [0, 100, gray[0]];\n    };\n\n    convert.gray.cmyk = function (gray) {\n      return [0, 0, 0, gray[0]];\n    };\n\n    convert.gray.lab = function (gray) {\n      return [gray[0], 0, 0];\n    };\n\n    convert.gray.hex = function (gray) {\n      var val = Math.round(gray[0] / 100 * 255) & 0xFF;\n      var integer = (val << 16) + (val << 8) + val;\n      var string = integer.toString(16).toUpperCase();\n      return '000000'.substring(string.length) + string;\n    };\n\n    convert.rgb.gray = function (rgb) {\n      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n      return [val / 255 * 100];\n    };\n  });\n  var conversions_1 = conversions.rgb;\n  var conversions_2 = conversions.hsl;\n  var conversions_3 = conversions.hsv;\n  var conversions_4 = conversions.hwb;\n  var conversions_5 = conversions.cmyk;\n  var conversions_6 = conversions.xyz;\n  var conversions_7 = conversions.lab;\n  var conversions_8 = conversions.lch;\n  var conversions_9 = conversions.hex;\n  var conversions_10 = conversions.keyword;\n  var conversions_11 = conversions.ansi16;\n  var conversions_12 = conversions.ansi256;\n  var conversions_13 = conversions.hcg;\n  var conversions_14 = conversions.apple;\n  var conversions_15 = conversions.gray;\n  /*\n  \tthis function routes a model to all other models.\n  \n  \tall functions that are routed have a property `.conversion` attached\n  \tto the returned synthetic function. This property is an array\n  \tof strings, each with the steps in between the 'from' and 'to'\n  \tcolor models (inclusive).\n  \n  \tconversions that are not possible simply are not included.\n  */\n\n  function buildGraph() {\n    var graph = {}; // https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\n    var models = Object.keys(conversions);\n\n    for (var len = models.length, i = 0; i < len; i++) {\n      graph[models[i]] = {\n        // http://jsperf.com/1-vs-infinity\n        // micro-opt, but this is simple.\n        distance: -1,\n        parent: null\n      };\n    }\n\n    return graph;\n  } // https://en.wikipedia.org/wiki/Breadth-first_search\n\n\n  function deriveBFS(fromModel) {\n    var graph = buildGraph();\n    var queue = [fromModel]; // unshift -> queue -> pop\n\n    graph[fromModel].distance = 0;\n\n    while (queue.length) {\n      var current = queue.pop();\n      var adjacents = Object.keys(conversions[current]);\n\n      for (var len = adjacents.length, i = 0; i < len; i++) {\n        var adjacent = adjacents[i];\n        var node = graph[adjacent];\n\n        if (node.distance === -1) {\n          node.distance = graph[current].distance + 1;\n          node.parent = current;\n          queue.unshift(adjacent);\n        }\n      }\n    }\n\n    return graph;\n  }\n\n  function link(from, to) {\n    return function (args) {\n      return to(from(args));\n    };\n  }\n\n  function wrapConversion(toModel, graph) {\n    var path = [graph[toModel].parent, toModel];\n    var fn = conversions[graph[toModel].parent][toModel];\n    var cur = graph[toModel].parent;\n\n    while (graph[cur].parent) {\n      path.unshift(graph[cur].parent);\n      fn = link(conversions[graph[cur].parent][cur], fn);\n      cur = graph[cur].parent;\n    }\n\n    fn.conversion = path;\n    return fn;\n  }\n\n  var route = function (fromModel) {\n    var graph = deriveBFS(fromModel);\n    var conversion = {};\n    var models = Object.keys(graph);\n\n    for (var len = models.length, i = 0; i < len; i++) {\n      var toModel = models[i];\n      var node = graph[toModel];\n\n      if (node.parent === null) {\n        // no possible conversion, or this node is the source model.\n        continue;\n      }\n\n      conversion[toModel] = wrapConversion(toModel, graph);\n    }\n\n    return conversion;\n  };\n\n  var convert = {};\n  var models = Object.keys(conversions);\n\n  function wrapRaw(fn) {\n    var wrappedFn = function (args) {\n      if (args === undefined || args === null) {\n        return args;\n      }\n\n      if (arguments.length > 1) {\n        args = Array.prototype.slice.call(arguments);\n      }\n\n      return fn(args);\n    }; // preserve .conversion property if there is one\n\n\n    if ('conversion' in fn) {\n      wrappedFn.conversion = fn.conversion;\n    }\n\n    return wrappedFn;\n  }\n\n  function wrapRounded(fn) {\n    var wrappedFn = function (args) {\n      if (args === undefined || args === null) {\n        return args;\n      }\n\n      if (arguments.length > 1) {\n        args = Array.prototype.slice.call(arguments);\n      }\n\n      var result = fn(args); // we're assuming the result is an array here.\n      // see notice in conversions.js; don't use box types\n      // in conversion functions.\n\n      if (typeof result === 'object') {\n        for (var len = result.length, i = 0; i < len; i++) {\n          result[i] = Math.round(result[i]);\n        }\n      }\n\n      return result;\n    }; // preserve .conversion property if there is one\n\n\n    if ('conversion' in fn) {\n      wrappedFn.conversion = fn.conversion;\n    }\n\n    return wrappedFn;\n  }\n\n  models.forEach(function (fromModel) {\n    convert[fromModel] = {};\n    Object.defineProperty(convert[fromModel], 'channels', {\n      value: conversions[fromModel].channels\n    });\n    Object.defineProperty(convert[fromModel], 'labels', {\n      value: conversions[fromModel].labels\n    });\n    var routes = route(fromModel);\n    var routeModels = Object.keys(routes);\n    routeModels.forEach(function (toModel) {\n      var fn = routes[toModel];\n      convert[fromModel][toModel] = wrapRounded(fn);\n      convert[fromModel][toModel].raw = wrapRaw(fn);\n    });\n  });\n  var colorConvert = convert;\n  var colorName$1 = {\n    \"aliceblue\": [240, 248, 255],\n    \"antiquewhite\": [250, 235, 215],\n    \"aqua\": [0, 255, 255],\n    \"aquamarine\": [127, 255, 212],\n    \"azure\": [240, 255, 255],\n    \"beige\": [245, 245, 220],\n    \"bisque\": [255, 228, 196],\n    \"black\": [0, 0, 0],\n    \"blanchedalmond\": [255, 235, 205],\n    \"blue\": [0, 0, 255],\n    \"blueviolet\": [138, 43, 226],\n    \"brown\": [165, 42, 42],\n    \"burlywood\": [222, 184, 135],\n    \"cadetblue\": [95, 158, 160],\n    \"chartreuse\": [127, 255, 0],\n    \"chocolate\": [210, 105, 30],\n    \"coral\": [255, 127, 80],\n    \"cornflowerblue\": [100, 149, 237],\n    \"cornsilk\": [255, 248, 220],\n    \"crimson\": [220, 20, 60],\n    \"cyan\": [0, 255, 255],\n    \"darkblue\": [0, 0, 139],\n    \"darkcyan\": [0, 139, 139],\n    \"darkgoldenrod\": [184, 134, 11],\n    \"darkgray\": [169, 169, 169],\n    \"darkgreen\": [0, 100, 0],\n    \"darkgrey\": [169, 169, 169],\n    \"darkkhaki\": [189, 183, 107],\n    \"darkmagenta\": [139, 0, 139],\n    \"darkolivegreen\": [85, 107, 47],\n    \"darkorange\": [255, 140, 0],\n    \"darkorchid\": [153, 50, 204],\n    \"darkred\": [139, 0, 0],\n    \"darksalmon\": [233, 150, 122],\n    \"darkseagreen\": [143, 188, 143],\n    \"darkslateblue\": [72, 61, 139],\n    \"darkslategray\": [47, 79, 79],\n    \"darkslategrey\": [47, 79, 79],\n    \"darkturquoise\": [0, 206, 209],\n    \"darkviolet\": [148, 0, 211],\n    \"deeppink\": [255, 20, 147],\n    \"deepskyblue\": [0, 191, 255],\n    \"dimgray\": [105, 105, 105],\n    \"dimgrey\": [105, 105, 105],\n    \"dodgerblue\": [30, 144, 255],\n    \"firebrick\": [178, 34, 34],\n    \"floralwhite\": [255, 250, 240],\n    \"forestgreen\": [34, 139, 34],\n    \"fuchsia\": [255, 0, 255],\n    \"gainsboro\": [220, 220, 220],\n    \"ghostwhite\": [248, 248, 255],\n    \"gold\": [255, 215, 0],\n    \"goldenrod\": [218, 165, 32],\n    \"gray\": [128, 128, 128],\n    \"green\": [0, 128, 0],\n    \"greenyellow\": [173, 255, 47],\n    \"grey\": [128, 128, 128],\n    \"honeydew\": [240, 255, 240],\n    \"hotpink\": [255, 105, 180],\n    \"indianred\": [205, 92, 92],\n    \"indigo\": [75, 0, 130],\n    \"ivory\": [255, 255, 240],\n    \"khaki\": [240, 230, 140],\n    \"lavender\": [230, 230, 250],\n    \"lavenderblush\": [255, 240, 245],\n    \"lawngreen\": [124, 252, 0],\n    \"lemonchiffon\": [255, 250, 205],\n    \"lightblue\": [173, 216, 230],\n    \"lightcoral\": [240, 128, 128],\n    \"lightcyan\": [224, 255, 255],\n    \"lightgoldenrodyellow\": [250, 250, 210],\n    \"lightgray\": [211, 211, 211],\n    \"lightgreen\": [144, 238, 144],\n    \"lightgrey\": [211, 211, 211],\n    \"lightpink\": [255, 182, 193],\n    \"lightsalmon\": [255, 160, 122],\n    \"lightseagreen\": [32, 178, 170],\n    \"lightskyblue\": [135, 206, 250],\n    \"lightslategray\": [119, 136, 153],\n    \"lightslategrey\": [119, 136, 153],\n    \"lightsteelblue\": [176, 196, 222],\n    \"lightyellow\": [255, 255, 224],\n    \"lime\": [0, 255, 0],\n    \"limegreen\": [50, 205, 50],\n    \"linen\": [250, 240, 230],\n    \"magenta\": [255, 0, 255],\n    \"maroon\": [128, 0, 0],\n    \"mediumaquamarine\": [102, 205, 170],\n    \"mediumblue\": [0, 0, 205],\n    \"mediumorchid\": [186, 85, 211],\n    \"mediumpurple\": [147, 112, 219],\n    \"mediumseagreen\": [60, 179, 113],\n    \"mediumslateblue\": [123, 104, 238],\n    \"mediumspringgreen\": [0, 250, 154],\n    \"mediumturquoise\": [72, 209, 204],\n    \"mediumvioletred\": [199, 21, 133],\n    \"midnightblue\": [25, 25, 112],\n    \"mintcream\": [245, 255, 250],\n    \"mistyrose\": [255, 228, 225],\n    \"moccasin\": [255, 228, 181],\n    \"navajowhite\": [255, 222, 173],\n    \"navy\": [0, 0, 128],\n    \"oldlace\": [253, 245, 230],\n    \"olive\": [128, 128, 0],\n    \"olivedrab\": [107, 142, 35],\n    \"orange\": [255, 165, 0],\n    \"orangered\": [255, 69, 0],\n    \"orchid\": [218, 112, 214],\n    \"palegoldenrod\": [238, 232, 170],\n    \"palegreen\": [152, 251, 152],\n    \"paleturquoise\": [175, 238, 238],\n    \"palevioletred\": [219, 112, 147],\n    \"papayawhip\": [255, 239, 213],\n    \"peachpuff\": [255, 218, 185],\n    \"peru\": [205, 133, 63],\n    \"pink\": [255, 192, 203],\n    \"plum\": [221, 160, 221],\n    \"powderblue\": [176, 224, 230],\n    \"purple\": [128, 0, 128],\n    \"rebeccapurple\": [102, 51, 153],\n    \"red\": [255, 0, 0],\n    \"rosybrown\": [188, 143, 143],\n    \"royalblue\": [65, 105, 225],\n    \"saddlebrown\": [139, 69, 19],\n    \"salmon\": [250, 128, 114],\n    \"sandybrown\": [244, 164, 96],\n    \"seagreen\": [46, 139, 87],\n    \"seashell\": [255, 245, 238],\n    \"sienna\": [160, 82, 45],\n    \"silver\": [192, 192, 192],\n    \"skyblue\": [135, 206, 235],\n    \"slateblue\": [106, 90, 205],\n    \"slategray\": [112, 128, 144],\n    \"slategrey\": [112, 128, 144],\n    \"snow\": [255, 250, 250],\n    \"springgreen\": [0, 255, 127],\n    \"steelblue\": [70, 130, 180],\n    \"tan\": [210, 180, 140],\n    \"teal\": [0, 128, 128],\n    \"thistle\": [216, 191, 216],\n    \"tomato\": [255, 99, 71],\n    \"turquoise\": [64, 224, 208],\n    \"violet\": [238, 130, 238],\n    \"wheat\": [245, 222, 179],\n    \"white\": [255, 255, 255],\n    \"whitesmoke\": [245, 245, 245],\n    \"yellow\": [255, 255, 0],\n    \"yellowgreen\": [154, 205, 50]\n  };\n  /* MIT license */\n\n  var colorString = {\n    getRgba: getRgba,\n    getHsla: getHsla,\n    getRgb: getRgb,\n    getHsl: getHsl,\n    getHwb: getHwb,\n    getAlpha: getAlpha,\n    hexString: hexString,\n    rgbString: rgbString,\n    rgbaString: rgbaString,\n    percentString: percentString,\n    percentaString: percentaString,\n    hslString: hslString,\n    hslaString: hslaString,\n    hwbString: hwbString,\n    keyword: keyword\n  };\n\n  function getRgba(string) {\n    if (!string) {\n      return;\n    }\n\n    var abbr = /^#([a-fA-F0-9]{3,4})$/i,\n        hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,\n        rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n        per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n        keyword = /(\\w+)/;\n    var rgb = [0, 0, 0],\n        a = 1,\n        match = string.match(abbr),\n        hexAlpha = \"\";\n\n    if (match) {\n      match = match[1];\n      hexAlpha = match[3];\n\n      for (var i = 0; i < rgb.length; i++) {\n        rgb[i] = parseInt(match[i] + match[i], 16);\n      }\n\n      if (hexAlpha) {\n        a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;\n      }\n    } else if (match = string.match(hex)) {\n      hexAlpha = match[2];\n      match = match[1];\n\n      for (var i = 0; i < rgb.length; i++) {\n        rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\n      }\n\n      if (hexAlpha) {\n        a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;\n      }\n    } else if (match = string.match(rgba)) {\n      for (var i = 0; i < rgb.length; i++) {\n        rgb[i] = parseInt(match[i + 1]);\n      }\n\n      a = parseFloat(match[4]);\n    } else if (match = string.match(per)) {\n      for (var i = 0; i < rgb.length; i++) {\n        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n      }\n\n      a = parseFloat(match[4]);\n    } else if (match = string.match(keyword)) {\n      if (match[1] == \"transparent\") {\n        return [0, 0, 0, 0];\n      }\n\n      rgb = colorName$1[match[1]];\n\n      if (!rgb) {\n        return;\n      }\n    }\n\n    for (var i = 0; i < rgb.length; i++) {\n      rgb[i] = scale(rgb[i], 0, 255);\n    }\n\n    if (!a && a != 0) {\n      a = 1;\n    } else {\n      a = scale(a, 0, 1);\n    }\n\n    rgb[3] = a;\n    return rgb;\n  }\n\n  function getHsla(string) {\n    if (!string) {\n      return;\n    }\n\n    var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n    var match = string.match(hsl);\n\n    if (match) {\n      var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          s = scale(parseFloat(match[2]), 0, 100),\n          l = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, s, l, a];\n    }\n  }\n\n  function getHwb(string) {\n    if (!string) {\n      return;\n    }\n\n    var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n    var match = string.match(hwb);\n\n    if (match) {\n      var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          w = scale(parseFloat(match[2]), 0, 100),\n          b = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, w, b, a];\n    }\n  }\n\n  function getRgb(string) {\n    var rgba = getRgba(string);\n    return rgba && rgba.slice(0, 3);\n  }\n\n  function getHsl(string) {\n    var hsla = getHsla(string);\n    return hsla && hsla.slice(0, 3);\n  }\n\n  function getAlpha(string) {\n    var vals = getRgba(string);\n\n    if (vals) {\n      return vals[3];\n    } else if (vals = getHsla(string)) {\n      return vals[3];\n    } else if (vals = getHwb(string)) {\n      return vals[3];\n    }\n  } // generators\n\n\n  function hexString(rgba, a) {\n    var a = a !== undefined && rgba.length === 3 ? a : rgba[3];\n    return \"#\" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : \"\");\n  }\n\n  function rgbString(rgba, alpha) {\n    if (alpha < 1 || rgba[3] && rgba[3] < 1) {\n      return rgbaString(rgba, alpha);\n    }\n\n    return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\n  }\n\n  function rgbaString(rgba, alpha) {\n    if (alpha === undefined) {\n      alpha = rgba[3] !== undefined ? rgba[3] : 1;\n    }\n\n    return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \", \" + alpha + \")\";\n  }\n\n  function percentString(rgba, alpha) {\n    if (alpha < 1 || rgba[3] && rgba[3] < 1) {\n      return percentaString(rgba, alpha);\n    }\n\n    var r = Math.round(rgba[0] / 255 * 100),\n        g = Math.round(rgba[1] / 255 * 100),\n        b = Math.round(rgba[2] / 255 * 100);\n    return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\n  }\n\n  function percentaString(rgba, alpha) {\n    var r = Math.round(rgba[0] / 255 * 100),\n        g = Math.round(rgba[1] / 255 * 100),\n        b = Math.round(rgba[2] / 255 * 100);\n    return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\n  }\n\n  function hslString(hsla, alpha) {\n    if (alpha < 1 || hsla[3] && hsla[3] < 1) {\n      return hslaString(hsla, alpha);\n    }\n\n    return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\n  }\n\n  function hslaString(hsla, alpha) {\n    if (alpha === undefined) {\n      alpha = hsla[3] !== undefined ? hsla[3] : 1;\n    }\n\n    return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \" + alpha + \")\";\n  } // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n  // (hwb have alpha optional & 1 is default value)\n\n\n  function hwbString(hwb, alpha) {\n    if (alpha === undefined) {\n      alpha = hwb[3] !== undefined ? hwb[3] : 1;\n    }\n\n    return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\" + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\n  }\n\n  function keyword(rgb) {\n    return reverseNames[rgb.slice(0, 3)];\n  } // helpers\n\n\n  function scale(num, min, max) {\n    return Math.min(Math.max(min, num), max);\n  }\n\n  function hexDouble(num) {\n    var str = num.toString(16).toUpperCase();\n    return str.length < 2 ? \"0\" + str : str;\n  } //create a list of reverse color names\n\n\n  var reverseNames = {};\n\n  for (var name in colorName$1) {\n    reverseNames[colorName$1[name]] = name;\n  }\n  /* MIT license */\n\n\n  var Color = function (obj) {\n    if (obj instanceof Color) {\n      return obj;\n    }\n\n    if (!(this instanceof Color)) {\n      return new Color(obj);\n    }\n\n    this.valid = false;\n    this.values = {\n      rgb: [0, 0, 0],\n      hsl: [0, 0, 0],\n      hsv: [0, 0, 0],\n      hwb: [0, 0, 0],\n      cmyk: [0, 0, 0, 0],\n      alpha: 1\n    }; // parse Color() argument\n\n    var vals;\n\n    if (typeof obj === 'string') {\n      vals = colorString.getRgba(obj);\n\n      if (vals) {\n        this.setValues('rgb', vals);\n      } else if (vals = colorString.getHsla(obj)) {\n        this.setValues('hsl', vals);\n      } else if (vals = colorString.getHwb(obj)) {\n        this.setValues('hwb', vals);\n      }\n    } else if (typeof obj === 'object') {\n      vals = obj;\n\n      if (vals.r !== undefined || vals.red !== undefined) {\n        this.setValues('rgb', vals);\n      } else if (vals.l !== undefined || vals.lightness !== undefined) {\n        this.setValues('hsl', vals);\n      } else if (vals.v !== undefined || vals.value !== undefined) {\n        this.setValues('hsv', vals);\n      } else if (vals.w !== undefined || vals.whiteness !== undefined) {\n        this.setValues('hwb', vals);\n      } else if (vals.c !== undefined || vals.cyan !== undefined) {\n        this.setValues('cmyk', vals);\n      }\n    }\n  };\n\n  Color.prototype = {\n    isValid: function () {\n      return this.valid;\n    },\n    rgb: function () {\n      return this.setSpace('rgb', arguments);\n    },\n    hsl: function () {\n      return this.setSpace('hsl', arguments);\n    },\n    hsv: function () {\n      return this.setSpace('hsv', arguments);\n    },\n    hwb: function () {\n      return this.setSpace('hwb', arguments);\n    },\n    cmyk: function () {\n      return this.setSpace('cmyk', arguments);\n    },\n    rgbArray: function () {\n      return this.values.rgb;\n    },\n    hslArray: function () {\n      return this.values.hsl;\n    },\n    hsvArray: function () {\n      return this.values.hsv;\n    },\n    hwbArray: function () {\n      var values = this.values;\n\n      if (values.alpha !== 1) {\n        return values.hwb.concat([values.alpha]);\n      }\n\n      return values.hwb;\n    },\n    cmykArray: function () {\n      return this.values.cmyk;\n    },\n    rgbaArray: function () {\n      var values = this.values;\n      return values.rgb.concat([values.alpha]);\n    },\n    hslaArray: function () {\n      var values = this.values;\n      return values.hsl.concat([values.alpha]);\n    },\n    alpha: function (val) {\n      if (val === undefined) {\n        return this.values.alpha;\n      }\n\n      this.setValues('alpha', val);\n      return this;\n    },\n    red: function (val) {\n      return this.setChannel('rgb', 0, val);\n    },\n    green: function (val) {\n      return this.setChannel('rgb', 1, val);\n    },\n    blue: function (val) {\n      return this.setChannel('rgb', 2, val);\n    },\n    hue: function (val) {\n      if (val) {\n        val %= 360;\n        val = val < 0 ? 360 + val : val;\n      }\n\n      return this.setChannel('hsl', 0, val);\n    },\n    saturation: function (val) {\n      return this.setChannel('hsl', 1, val);\n    },\n    lightness: function (val) {\n      return this.setChannel('hsl', 2, val);\n    },\n    saturationv: function (val) {\n      return this.setChannel('hsv', 1, val);\n    },\n    whiteness: function (val) {\n      return this.setChannel('hwb', 1, val);\n    },\n    blackness: function (val) {\n      return this.setChannel('hwb', 2, val);\n    },\n    value: function (val) {\n      return this.setChannel('hsv', 2, val);\n    },\n    cyan: function (val) {\n      return this.setChannel('cmyk', 0, val);\n    },\n    magenta: function (val) {\n      return this.setChannel('cmyk', 1, val);\n    },\n    yellow: function (val) {\n      return this.setChannel('cmyk', 2, val);\n    },\n    black: function (val) {\n      return this.setChannel('cmyk', 3, val);\n    },\n    hexString: function () {\n      return colorString.hexString(this.values.rgb);\n    },\n    rgbString: function () {\n      return colorString.rgbString(this.values.rgb, this.values.alpha);\n    },\n    rgbaString: function () {\n      return colorString.rgbaString(this.values.rgb, this.values.alpha);\n    },\n    percentString: function () {\n      return colorString.percentString(this.values.rgb, this.values.alpha);\n    },\n    hslString: function () {\n      return colorString.hslString(this.values.hsl, this.values.alpha);\n    },\n    hslaString: function () {\n      return colorString.hslaString(this.values.hsl, this.values.alpha);\n    },\n    hwbString: function () {\n      return colorString.hwbString(this.values.hwb, this.values.alpha);\n    },\n    keyword: function () {\n      return colorString.keyword(this.values.rgb, this.values.alpha);\n    },\n    rgbNumber: function () {\n      var rgb = this.values.rgb;\n      return rgb[0] << 16 | rgb[1] << 8 | rgb[2];\n    },\n    luminosity: function () {\n      // http://www.w3.org/TR/WCAG20/#relativeluminancedef\n      var rgb = this.values.rgb;\n      var lum = [];\n\n      for (var i = 0; i < rgb.length; i++) {\n        var chan = rgb[i] / 255;\n        lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);\n      }\n\n      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n    },\n    contrast: function (color2) {\n      // http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n      var lum1 = this.luminosity();\n      var lum2 = color2.luminosity();\n\n      if (lum1 > lum2) {\n        return (lum1 + 0.05) / (lum2 + 0.05);\n      }\n\n      return (lum2 + 0.05) / (lum1 + 0.05);\n    },\n    level: function (color2) {\n      var contrastRatio = this.contrast(color2);\n\n      if (contrastRatio >= 7.1) {\n        return 'AAA';\n      }\n\n      return contrastRatio >= 4.5 ? 'AA' : '';\n    },\n    dark: function () {\n      // YIQ equation from http://24ways.org/2010/calculating-color-contrast\n      var rgb = this.values.rgb;\n      var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n      return yiq < 128;\n    },\n    light: function () {\n      return !this.dark();\n    },\n    negate: function () {\n      var rgb = [];\n\n      for (var i = 0; i < 3; i++) {\n        rgb[i] = 255 - this.values.rgb[i];\n      }\n\n      this.setValues('rgb', rgb);\n      return this;\n    },\n    lighten: function (ratio) {\n      var hsl = this.values.hsl;\n      hsl[2] += hsl[2] * ratio;\n      this.setValues('hsl', hsl);\n      return this;\n    },\n    darken: function (ratio) {\n      var hsl = this.values.hsl;\n      hsl[2] -= hsl[2] * ratio;\n      this.setValues('hsl', hsl);\n      return this;\n    },\n    saturate: function (ratio) {\n      var hsl = this.values.hsl;\n      hsl[1] += hsl[1] * ratio;\n      this.setValues('hsl', hsl);\n      return this;\n    },\n    desaturate: function (ratio) {\n      var hsl = this.values.hsl;\n      hsl[1] -= hsl[1] * ratio;\n      this.setValues('hsl', hsl);\n      return this;\n    },\n    whiten: function (ratio) {\n      var hwb = this.values.hwb;\n      hwb[1] += hwb[1] * ratio;\n      this.setValues('hwb', hwb);\n      return this;\n    },\n    blacken: function (ratio) {\n      var hwb = this.values.hwb;\n      hwb[2] += hwb[2] * ratio;\n      this.setValues('hwb', hwb);\n      return this;\n    },\n    greyscale: function () {\n      var rgb = this.values.rgb; // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\n      var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n      this.setValues('rgb', [val, val, val]);\n      return this;\n    },\n    clearer: function (ratio) {\n      var alpha = this.values.alpha;\n      this.setValues('alpha', alpha - alpha * ratio);\n      return this;\n    },\n    opaquer: function (ratio) {\n      var alpha = this.values.alpha;\n      this.setValues('alpha', alpha + alpha * ratio);\n      return this;\n    },\n    rotate: function (degrees) {\n      var hsl = this.values.hsl;\n      var hue = (hsl[0] + degrees) % 360;\n      hsl[0] = hue < 0 ? 360 + hue : hue;\n      this.setValues('hsl', hsl);\n      return this;\n    },\n\n    /**\n     * Ported from sass implementation in C\n     * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n     */\n    mix: function (mixinColor, weight) {\n      var color1 = this;\n      var color2 = mixinColor;\n      var p = weight === undefined ? 0.5 : weight;\n      var w = 2 * p - 1;\n      var a = color1.alpha() - color2.alpha();\n      var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      var w2 = 1 - w1;\n      return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));\n    },\n    toJSON: function () {\n      return this.rgb();\n    },\n    clone: function () {\n      // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\n      // making the final build way to big to embed in Chart.js. So let's do it manually,\n      // assuming that values to clone are 1 dimension arrays containing only numbers,\n      // except 'alpha' which is a number.\n      var result = new Color();\n      var source = this.values;\n      var target = result.values;\n      var value, type;\n\n      for (var prop in source) {\n        if (source.hasOwnProperty(prop)) {\n          value = source[prop];\n          type = {}.toString.call(value);\n\n          if (type === '[object Array]') {\n            target[prop] = value.slice(0);\n          } else if (type === '[object Number]') {\n            target[prop] = value;\n          } else {\n            console.error('unexpected color value:', value);\n          }\n        }\n      }\n\n      return result;\n    }\n  };\n  Color.prototype.spaces = {\n    rgb: ['red', 'green', 'blue'],\n    hsl: ['hue', 'saturation', 'lightness'],\n    hsv: ['hue', 'saturation', 'value'],\n    hwb: ['hue', 'whiteness', 'blackness'],\n    cmyk: ['cyan', 'magenta', 'yellow', 'black']\n  };\n  Color.prototype.maxes = {\n    rgb: [255, 255, 255],\n    hsl: [360, 100, 100],\n    hsv: [360, 100, 100],\n    hwb: [360, 100, 100],\n    cmyk: [100, 100, 100, 100]\n  };\n\n  Color.prototype.getValues = function (space) {\n    var values = this.values;\n    var vals = {};\n\n    for (var i = 0; i < space.length; i++) {\n      vals[space.charAt(i)] = values[space][i];\n    }\n\n    if (values.alpha !== 1) {\n      vals.a = values.alpha;\n    } // {r: 255, g: 255, b: 255, a: 0.4}\n\n\n    return vals;\n  };\n\n  Color.prototype.setValues = function (space, vals) {\n    var values = this.values;\n    var spaces = this.spaces;\n    var maxes = this.maxes;\n    var alpha = 1;\n    var i;\n    this.valid = true;\n\n    if (space === 'alpha') {\n      alpha = vals;\n    } else if (vals.length) {\n      // [10, 10, 10]\n      values[space] = vals.slice(0, space.length);\n      alpha = vals[space.length];\n    } else if (vals[space.charAt(0)] !== undefined) {\n      // {r: 10, g: 10, b: 10}\n      for (i = 0; i < space.length; i++) {\n        values[space][i] = vals[space.charAt(i)];\n      }\n\n      alpha = vals.a;\n    } else if (vals[spaces[space][0]] !== undefined) {\n      // {red: 10, green: 10, blue: 10}\n      var chans = spaces[space];\n\n      for (i = 0; i < space.length; i++) {\n        values[space][i] = vals[chans[i]];\n      }\n\n      alpha = vals.alpha;\n    }\n\n    values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));\n\n    if (space === 'alpha') {\n      return false;\n    }\n\n    var capped; // cap values of the space prior converting all values\n\n    for (i = 0; i < space.length; i++) {\n      capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\n      values[space][i] = Math.round(capped);\n    } // convert to all the other color spaces\n\n\n    for (var sname in spaces) {\n      if (sname !== space) {\n        values[sname] = colorConvert[space][sname](values[space]);\n      }\n    }\n\n    return true;\n  };\n\n  Color.prototype.setSpace = function (space, args) {\n    var vals = args[0];\n\n    if (vals === undefined) {\n      // color.rgb()\n      return this.getValues(space);\n    } // color.rgb(10, 10, 10)\n\n\n    if (typeof vals === 'number') {\n      vals = Array.prototype.slice.call(args);\n    }\n\n    this.setValues(space, vals);\n    return this;\n  };\n\n  Color.prototype.setChannel = function (space, index, val) {\n    var svalues = this.values[space];\n\n    if (val === undefined) {\n      // color.red()\n      return svalues[index];\n    } else if (val === svalues[index]) {\n      // color.red(color.red())\n      return this;\n    } // color.red(100)\n\n\n    svalues[index] = val;\n    this.setValues(space, svalues);\n    return this;\n  };\n\n  if (typeof window !== 'undefined') {\n    window.Color = Color;\n  }\n\n  var chartjsColor = Color;\n  /**\n   * @namespace Chart.helpers\n   */\n\n  var helpers = {\n    /**\n     * An empty function that can be used, for example, for optional callback.\n     */\n    noop: function () {},\n\n    /**\n     * Returns a unique id, sequentially generated from a global variable.\n     * @returns {number}\n     * @function\n     */\n    uid: function () {\n      var id = 0;\n      return function () {\n        return id++;\n      };\n    }(),\n\n    /**\n     * Returns true if `value` is neither null nor undefined, else returns false.\n     * @param {*} value - The value to test.\n     * @returns {boolean}\n     * @since 2.7.0\n     */\n    isNullOrUndef: function (value) {\n      return value === null || typeof value === 'undefined';\n    },\n\n    /**\n     * Returns true if `value` is an array (including typed arrays), else returns false.\n     * @param {*} value - The value to test.\n     * @returns {boolean}\n     * @function\n     */\n    isArray: function (value) {\n      if (Array.isArray && Array.isArray(value)) {\n        return true;\n      }\n\n      var type = Object.prototype.toString.call(value);\n\n      if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Returns true if `value` is an object (excluding null), else returns false.\n     * @param {*} value - The value to test.\n     * @returns {boolean}\n     * @since 2.7.0\n     */\n    isObject: function (value) {\n      return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n    },\n\n    /**\n     * Returns true if `value` is a finite number, else returns false\n     * @param {*} value  - The value to test.\n     * @returns {boolean}\n     */\n    isFinite: function (value) {\n      return (typeof value === 'number' || value instanceof Number) && isFinite(value);\n    },\n\n    /**\n     * Returns `value` if defined, else returns `defaultValue`.\n     * @param {*} value - The value to return if defined.\n     * @param {*} defaultValue - The value to return if `value` is undefined.\n     * @returns {*}\n     */\n    valueOrDefault: function (value, defaultValue) {\n      return typeof value === 'undefined' ? defaultValue : value;\n    },\n\n    /**\n     * Returns value at the given `index` in array if defined, else returns `defaultValue`.\n     * @param {Array} value - The array to lookup for value at `index`.\n     * @param {number} index - The index in `value` to lookup for value.\n     * @param {*} defaultValue - The value to return if `value[index]` is undefined.\n     * @returns {*}\n     */\n    valueAtIndexOrDefault: function (value, index, defaultValue) {\n      return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);\n    },\n\n    /**\n     * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n     * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n     * @param {function} fn - The function to call.\n     * @param {Array|undefined|null} args - The arguments with which `fn` should be called.\n     * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.\n     * @returns {*}\n     */\n    callback: function (fn, args, thisArg) {\n      if (fn && typeof fn.call === 'function') {\n        return fn.apply(thisArg, args);\n      }\n    },\n\n    /**\n     * Note(SB) for performance sake, this method should only be used when loopable type\n     * is unknown or in none intensive code (not called often and small loopable). Else\n     * it's preferable to use a regular for() loop and save extra function calls.\n     * @param {object|Array} loopable - The object or array to be iterated.\n     * @param {function} fn - The function to call for each item.\n     * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.\n     * @param {boolean} [reverse] - If true, iterates backward on the loopable.\n     */\n    each: function (loopable, fn, thisArg, reverse) {\n      var i, len, keys;\n\n      if (helpers.isArray(loopable)) {\n        len = loopable.length;\n\n        if (reverse) {\n          for (i = len - 1; i >= 0; i--) {\n            fn.call(thisArg, loopable[i], i);\n          }\n        } else {\n          for (i = 0; i < len; i++) {\n            fn.call(thisArg, loopable[i], i);\n          }\n        }\n      } else if (helpers.isObject(loopable)) {\n        keys = Object.keys(loopable);\n        len = keys.length;\n\n        for (i = 0; i < len; i++) {\n          fn.call(thisArg, loopable[keys[i]], keys[i]);\n        }\n      }\n    },\n\n    /**\n     * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n     * @see https://stackoverflow.com/a/14853974\n     * @param {Array} a0 - The array to compare\n     * @param {Array} a1 - The array to compare\n     * @returns {boolean}\n     */\n    arrayEquals: function (a0, a1) {\n      var i, ilen, v0, v1;\n\n      if (!a0 || !a1 || a0.length !== a1.length) {\n        return false;\n      }\n\n      for (i = 0, ilen = a0.length; i < ilen; ++i) {\n        v0 = a0[i];\n        v1 = a1[i];\n\n        if (v0 instanceof Array && v1 instanceof Array) {\n          if (!helpers.arrayEquals(v0, v1)) {\n            return false;\n          }\n        } else if (v0 !== v1) {\n          // NOTE: two different object instances will never be equal: {x:20} != {x:20}\n          return false;\n        }\n      }\n\n      return true;\n    },\n\n    /**\n     * Returns a deep copy of `source` without keeping references on objects and arrays.\n     * @param {*} source - The value to clone.\n     * @returns {*}\n     */\n    clone: function (source) {\n      if (helpers.isArray(source)) {\n        return source.map(helpers.clone);\n      }\n\n      if (helpers.isObject(source)) {\n        var target = {};\n        var keys = Object.keys(source);\n        var klen = keys.length;\n        var k = 0;\n\n        for (; k < klen; ++k) {\n          target[keys[k]] = helpers.clone(source[keys[k]]);\n        }\n\n        return target;\n      }\n\n      return source;\n    },\n\n    /**\n     * The default merger when Chart.helpers.merge is called without merger option.\n     * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n     * @private\n     */\n    _merger: function (key, target, source, options) {\n      var tval = target[key];\n      var sval = source[key];\n\n      if (helpers.isObject(tval) && helpers.isObject(sval)) {\n        helpers.merge(tval, sval, options);\n      } else {\n        target[key] = helpers.clone(sval);\n      }\n    },\n\n    /**\n     * Merges source[key] in target[key] only if target[key] is undefined.\n     * @private\n     */\n    _mergerIf: function (key, target, source) {\n      var tval = target[key];\n      var sval = source[key];\n\n      if (helpers.isObject(tval) && helpers.isObject(sval)) {\n        helpers.mergeIf(tval, sval);\n      } else if (!target.hasOwnProperty(key)) {\n        target[key] = helpers.clone(sval);\n      }\n    },\n\n    /**\n     * Recursively deep copies `source` properties into `target` with the given `options`.\n     * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n     * @param {object} target - The target object in which all sources are merged into.\n     * @param {object|object[]} source - Object(s) to merge into `target`.\n     * @param {object} [options] - Merging options:\n     * @param {function} [options.merger] - The merge method (key, target, source, options)\n     * @returns {object} The `target` object.\n     */\n    merge: function (target, source, options) {\n      var sources = helpers.isArray(source) ? source : [source];\n      var ilen = sources.length;\n      var merge, i, keys, klen, k;\n\n      if (!helpers.isObject(target)) {\n        return target;\n      }\n\n      options = options || {};\n      merge = options.merger || helpers._merger;\n\n      for (i = 0; i < ilen; ++i) {\n        source = sources[i];\n\n        if (!helpers.isObject(source)) {\n          continue;\n        }\n\n        keys = Object.keys(source);\n\n        for (k = 0, klen = keys.length; k < klen; ++k) {\n          merge(keys[k], target, source, options);\n        }\n      }\n\n      return target;\n    },\n\n    /**\n     * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n     * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n     * @param {object} target - The target object in which all sources are merged into.\n     * @param {object|object[]} source - Object(s) to merge into `target`.\n     * @returns {object} The `target` object.\n     */\n    mergeIf: function (target, source) {\n      return helpers.merge(target, source, {\n        merger: helpers._mergerIf\n      });\n    },\n\n    /**\n     * Applies the contents of two or more objects together into the first object.\n     * @param {object} target - The target object in which all objects are merged into.\n     * @param {object} arg1 - Object containing additional properties to merge in target.\n     * @param {object} argN - Additional objects containing properties to merge in target.\n     * @returns {object} The `target` object.\n     */\n    extend: Object.assign || function (target) {\n      return helpers.merge(target, [].slice.call(arguments, 1), {\n        merger: function (key, dst, src) {\n          dst[key] = src[key];\n        }\n      });\n    },\n\n    /**\n     * Basic javascript inheritance based on the model created in Backbone.js\n     */\n    inherits: function (extensions) {\n      var me = this;\n      var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {\n        return me.apply(this, arguments);\n      };\n\n      var Surrogate = function () {\n        this.constructor = ChartElement;\n      };\n\n      Surrogate.prototype = me.prototype;\n      ChartElement.prototype = new Surrogate();\n      ChartElement.extend = helpers.inherits;\n\n      if (extensions) {\n        helpers.extend(ChartElement.prototype, extensions);\n      }\n\n      ChartElement.__super__ = me.prototype;\n      return ChartElement;\n    },\n    _deprecated: function (scope, value, previous, current) {\n      if (value !== undefined) {\n        console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n      }\n    }\n  };\n  var helpers_core = helpers; // DEPRECATIONS\n\n  /**\n   * Provided for backward compatibility, use Chart.helpers.callback instead.\n   * @function Chart.helpers.callCallback\n   * @deprecated since version 2.6.0\n   * @todo remove at version 3\n   * @private\n   */\n\n  helpers.callCallback = helpers.callback;\n  /**\n   * Provided for backward compatibility, use Array.prototype.indexOf instead.\n   * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+\n   * @function Chart.helpers.indexOf\n   * @deprecated since version 2.7.0\n   * @todo remove at version 3\n   * @private\n   */\n\n  helpers.indexOf = function (array, item, fromIndex) {\n    return Array.prototype.indexOf.call(array, item, fromIndex);\n  };\n  /**\n   * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.\n   * @function Chart.helpers.getValueOrDefault\n   * @deprecated since version 2.7.0\n   * @todo remove at version 3\n   * @private\n   */\n\n\n  helpers.getValueOrDefault = helpers.valueOrDefault;\n  /**\n   * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.\n   * @function Chart.helpers.getValueAtIndexOrDefault\n   * @deprecated since version 2.7.0\n   * @todo remove at version 3\n   * @private\n   */\n\n  helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n  /**\n   * Easing functions adapted from Robert Penner's easing equations.\n   * @namespace Chart.helpers.easingEffects\n   * @see http://www.robertpenner.com/easing/\n   */\n\n  var effects = {\n    linear: function (t) {\n      return t;\n    },\n    easeInQuad: function (t) {\n      return t * t;\n    },\n    easeOutQuad: function (t) {\n      return -t * (t - 2);\n    },\n    easeInOutQuad: function (t) {\n      if ((t /= 0.5) < 1) {\n        return 0.5 * t * t;\n      }\n\n      return -0.5 * (--t * (t - 2) - 1);\n    },\n    easeInCubic: function (t) {\n      return t * t * t;\n    },\n    easeOutCubic: function (t) {\n      return (t = t - 1) * t * t + 1;\n    },\n    easeInOutCubic: function (t) {\n      if ((t /= 0.5) < 1) {\n        return 0.5 * t * t * t;\n      }\n\n      return 0.5 * ((t -= 2) * t * t + 2);\n    },\n    easeInQuart: function (t) {\n      return t * t * t * t;\n    },\n    easeOutQuart: function (t) {\n      return -((t = t - 1) * t * t * t - 1);\n    },\n    easeInOutQuart: function (t) {\n      if ((t /= 0.5) < 1) {\n        return 0.5 * t * t * t * t;\n      }\n\n      return -0.5 * ((t -= 2) * t * t * t - 2);\n    },\n    easeInQuint: function (t) {\n      return t * t * t * t * t;\n    },\n    easeOutQuint: function (t) {\n      return (t = t - 1) * t * t * t * t + 1;\n    },\n    easeInOutQuint: function (t) {\n      if ((t /= 0.5) < 1) {\n        return 0.5 * t * t * t * t * t;\n      }\n\n      return 0.5 * ((t -= 2) * t * t * t * t + 2);\n    },\n    easeInSine: function (t) {\n      return -Math.cos(t * (Math.PI / 2)) + 1;\n    },\n    easeOutSine: function (t) {\n      return Math.sin(t * (Math.PI / 2));\n    },\n    easeInOutSine: function (t) {\n      return -0.5 * (Math.cos(Math.PI * t) - 1);\n    },\n    easeInExpo: function (t) {\n      return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));\n    },\n    easeOutExpo: function (t) {\n      return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;\n    },\n    easeInOutExpo: function (t) {\n      if (t === 0) {\n        return 0;\n      }\n\n      if (t === 1) {\n        return 1;\n      }\n\n      if ((t /= 0.5) < 1) {\n        return 0.5 * Math.pow(2, 10 * (t - 1));\n      }\n\n      return 0.5 * (-Math.pow(2, -10 * --t) + 2);\n    },\n    easeInCirc: function (t) {\n      if (t >= 1) {\n        return t;\n      }\n\n      return -(Math.sqrt(1 - t * t) - 1);\n    },\n    easeOutCirc: function (t) {\n      return Math.sqrt(1 - (t = t - 1) * t);\n    },\n    easeInOutCirc: function (t) {\n      if ((t /= 0.5) < 1) {\n        return -0.5 * (Math.sqrt(1 - t * t) - 1);\n      }\n\n      return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n    },\n    easeInElastic: function (t) {\n      var s = 1.70158;\n      var p = 0;\n      var a = 1;\n\n      if (t === 0) {\n        return 0;\n      }\n\n      if (t === 1) {\n        return 1;\n      }\n\n      if (!p) {\n        p = 0.3;\n      }\n\n      if (a < 1) {\n        a = 1;\n        s = p / 4;\n      } else {\n        s = p / (2 * Math.PI) * Math.asin(1 / a);\n      }\n\n      return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n    },\n    easeOutElastic: function (t) {\n      var s = 1.70158;\n      var p = 0;\n      var a = 1;\n\n      if (t === 0) {\n        return 0;\n      }\n\n      if (t === 1) {\n        return 1;\n      }\n\n      if (!p) {\n        p = 0.3;\n      }\n\n      if (a < 1) {\n        a = 1;\n        s = p / 4;\n      } else {\n        s = p / (2 * Math.PI) * Math.asin(1 / a);\n      }\n\n      return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;\n    },\n    easeInOutElastic: function (t) {\n      var s = 1.70158;\n      var p = 0;\n      var a = 1;\n\n      if (t === 0) {\n        return 0;\n      }\n\n      if ((t /= 0.5) === 2) {\n        return 1;\n      }\n\n      if (!p) {\n        p = 0.45;\n      }\n\n      if (a < 1) {\n        a = 1;\n        s = p / 4;\n      } else {\n        s = p / (2 * Math.PI) * Math.asin(1 / a);\n      }\n\n      if (t < 1) {\n        return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n      }\n\n      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;\n    },\n    easeInBack: function (t) {\n      var s = 1.70158;\n      return t * t * ((s + 1) * t - s);\n    },\n    easeOutBack: function (t) {\n      var s = 1.70158;\n      return (t = t - 1) * t * ((s + 1) * t + s) + 1;\n    },\n    easeInOutBack: function (t) {\n      var s = 1.70158;\n\n      if ((t /= 0.5) < 1) {\n        return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n      }\n\n      return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n    },\n    easeInBounce: function (t) {\n      return 1 - effects.easeOutBounce(1 - t);\n    },\n    easeOutBounce: function (t) {\n      if (t < 1 / 2.75) {\n        return 7.5625 * t * t;\n      }\n\n      if (t < 2 / 2.75) {\n        return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;\n      }\n\n      if (t < 2.5 / 2.75) {\n        return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;\n      }\n\n      return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n    },\n    easeInOutBounce: function (t) {\n      if (t < 0.5) {\n        return effects.easeInBounce(t * 2) * 0.5;\n      }\n\n      return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\n    }\n  };\n  var helpers_easing = {\n    effects: effects\n  }; // DEPRECATIONS\n\n  /**\n   * Provided for backward compatibility, use Chart.helpers.easing.effects instead.\n   * @function Chart.helpers.easingEffects\n   * @deprecated since version 2.7.0\n   * @todo remove at version 3\n   * @private\n   */\n\n  helpers_core.easingEffects = effects;\n  var PI = Math.PI;\n  var RAD_PER_DEG = PI / 180;\n  var DOUBLE_PI = PI * 2;\n  var HALF_PI = PI / 2;\n  var QUARTER_PI = PI / 4;\n  var TWO_THIRDS_PI = PI * 2 / 3;\n  /**\n   * @namespace Chart.helpers.canvas\n   */\n\n  var exports$1 = {\n    /**\n     * Clears the entire canvas associated to the given `chart`.\n     * @param {Chart} chart - The chart for which to clear the canvas.\n     */\n    clear: function (chart) {\n      chart.ctx.clearRect(0, 0, chart.width, chart.height);\n    },\n\n    /**\n     * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with a\n     * given size (width, height) and the same `radius` for all corners.\n     * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\n     * @param {number} x - The x axis of the coordinate for the rectangle starting point.\n     * @param {number} y - The y axis of the coordinate for the rectangle starting point.\n     * @param {number} width - The rectangle's width.\n     * @param {number} height - The rectangle's height.\n     * @param {number} radius - The rounded amount (in pixels) for the four corners.\n     * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?\n     */\n    roundedRect: function (ctx, x, y, width, height, radius) {\n      if (radius) {\n        var r = Math.min(radius, height / 2, width / 2);\n        var left = x + r;\n        var top = y + r;\n        var right = x + width - r;\n        var bottom = y + height - r;\n        ctx.moveTo(x, top);\n\n        if (left < right && top < bottom) {\n          ctx.arc(left, top, r, -PI, -HALF_PI);\n          ctx.arc(right, top, r, -HALF_PI, 0);\n          ctx.arc(right, bottom, r, 0, HALF_PI);\n          ctx.arc(left, bottom, r, HALF_PI, PI);\n        } else if (left < right) {\n          ctx.moveTo(left, y);\n          ctx.arc(right, top, r, -HALF_PI, HALF_PI);\n          ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);\n        } else if (top < bottom) {\n          ctx.arc(left, top, r, -PI, 0);\n          ctx.arc(left, bottom, r, 0, PI);\n        } else {\n          ctx.arc(left, top, r, -PI, PI);\n        }\n\n        ctx.closePath();\n        ctx.moveTo(x, y);\n      } else {\n        ctx.rect(x, y, width, height);\n      }\n    },\n    drawPoint: function (ctx, style, radius, x, y, rotation) {\n      var type, xOffset, yOffset, size, cornerRadius;\n      var rad = (rotation || 0) * RAD_PER_DEG;\n\n      if (style && typeof style === 'object') {\n        type = style.toString();\n\n        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n          ctx.save();\n          ctx.translate(x, y);\n          ctx.rotate(rad);\n          ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n          ctx.restore();\n          return;\n        }\n      }\n\n      if (isNaN(radius) || radius <= 0) {\n        return;\n      }\n\n      ctx.beginPath();\n\n      switch (style) {\n        // Default includes circle\n        default:\n          ctx.arc(x, y, radius, 0, DOUBLE_PI);\n          ctx.closePath();\n          break;\n\n        case 'triangle':\n          ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n          rad += TWO_THIRDS_PI;\n          ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n          rad += TWO_THIRDS_PI;\n          ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n          ctx.closePath();\n          break;\n\n        case 'rectRounded':\n          // NOTE: the rounded rect implementation changed to use `arc` instead of\n          // `quadraticCurveTo` since it generates better results when rect is\n          // almost a circle. 0.516 (instead of 0.5) produces results with visually\n          // closer proportion to the previous impl and it is inscribed in the\n          // circle with `radius`. For more details, see the following PRs:\n          // https://github.com/chartjs/Chart.js/issues/5597\n          // https://github.com/chartjs/Chart.js/issues/5858\n          cornerRadius = radius * 0.516;\n          size = radius - cornerRadius;\n          xOffset = Math.cos(rad + QUARTER_PI) * size;\n          yOffset = Math.sin(rad + QUARTER_PI) * size;\n          ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n          ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n          ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n          ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n          ctx.closePath();\n          break;\n\n        case 'rect':\n          if (!rotation) {\n            size = Math.SQRT1_2 * radius;\n            ctx.rect(x - size, y - size, 2 * size, 2 * size);\n            break;\n          }\n\n          rad += QUARTER_PI;\n\n        /* falls through */\n\n        case 'rectRot':\n          xOffset = Math.cos(rad) * radius;\n          yOffset = Math.sin(rad) * radius;\n          ctx.moveTo(x - xOffset, y - yOffset);\n          ctx.lineTo(x + yOffset, y - xOffset);\n          ctx.lineTo(x + xOffset, y + yOffset);\n          ctx.lineTo(x - yOffset, y + xOffset);\n          ctx.closePath();\n          break;\n\n        case 'crossRot':\n          rad += QUARTER_PI;\n\n        /* falls through */\n\n        case 'cross':\n          xOffset = Math.cos(rad) * radius;\n          yOffset = Math.sin(rad) * radius;\n          ctx.moveTo(x - xOffset, y - yOffset);\n          ctx.lineTo(x + xOffset, y + yOffset);\n          ctx.moveTo(x + yOffset, y - xOffset);\n          ctx.lineTo(x - yOffset, y + xOffset);\n          break;\n\n        case 'star':\n          xOffset = Math.cos(rad) * radius;\n          yOffset = Math.sin(rad) * radius;\n          ctx.moveTo(x - xOffset, y - yOffset);\n          ctx.lineTo(x + xOffset, y + yOffset);\n          ctx.moveTo(x + yOffset, y - xOffset);\n          ctx.lineTo(x - yOffset, y + xOffset);\n          rad += QUARTER_PI;\n          xOffset = Math.cos(rad) * radius;\n          yOffset = Math.sin(rad) * radius;\n          ctx.moveTo(x - xOffset, y - yOffset);\n          ctx.lineTo(x + xOffset, y + yOffset);\n          ctx.moveTo(x + yOffset, y - xOffset);\n          ctx.lineTo(x - yOffset, y + xOffset);\n          break;\n\n        case 'line':\n          xOffset = Math.cos(rad) * radius;\n          yOffset = Math.sin(rad) * radius;\n          ctx.moveTo(x - xOffset, y - yOffset);\n          ctx.lineTo(x + xOffset, y + yOffset);\n          break;\n\n        case 'dash':\n          ctx.moveTo(x, y);\n          ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n          break;\n      }\n\n      ctx.fill();\n      ctx.stroke();\n    },\n\n    /**\n     * Returns true if the point is inside the rectangle\n     * @param {object} point - The point to test\n     * @param {object} area - The rectangle\n     * @returns {boolean}\n     * @private\n     */\n    _isPointInArea: function (point, area) {\n      var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\n\n      return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;\n    },\n    clipArea: function (ctx, area) {\n      ctx.save();\n      ctx.beginPath();\n      ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n      ctx.clip();\n    },\n    unclipArea: function (ctx) {\n      ctx.restore();\n    },\n    lineTo: function (ctx, previous, target, flip) {\n      var stepped = target.steppedLine;\n\n      if (stepped) {\n        if (stepped === 'middle') {\n          var midpoint = (previous.x + target.x) / 2.0;\n          ctx.lineTo(midpoint, flip ? target.y : previous.y);\n          ctx.lineTo(midpoint, flip ? previous.y : target.y);\n        } else if (stepped === 'after' && !flip || stepped !== 'after' && flip) {\n          ctx.lineTo(previous.x, target.y);\n        } else {\n          ctx.lineTo(target.x, previous.y);\n        }\n\n        ctx.lineTo(target.x, target.y);\n        return;\n      }\n\n      if (!target.tension) {\n        ctx.lineTo(target.x, target.y);\n        return;\n      }\n\n      ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);\n    }\n  };\n  var helpers_canvas = exports$1; // DEPRECATIONS\n\n  /**\n   * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.\n   * @namespace Chart.helpers.clear\n   * @deprecated since version 2.7.0\n   * @todo remove at version 3\n   * @private\n   */\n\n  helpers_core.clear = exports$1.clear;\n  /**\n   * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.\n   * @namespace Chart.helpers.drawRoundedRectangle\n   * @deprecated since version 2.7.0\n   * @todo remove at version 3\n   * @private\n   */\n\n  helpers_core.drawRoundedRectangle = function (ctx) {\n    ctx.beginPath();\n    exports$1.roundedRect.apply(exports$1, arguments);\n  };\n\n  var defaults = {\n    /**\n     * @private\n     */\n    _set: function (scope, values) {\n      return helpers_core.merge(this[scope] || (this[scope] = {}), values);\n    }\n  }; // TODO(v3): remove 'global' from namespace.  all default are global and\n  // there's inconsistency around which options are under 'global'\n\n  defaults._set('global', {\n    defaultColor: 'rgba(0,0,0,0.1)',\n    defaultFontColor: '#666',\n    defaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n    defaultFontSize: 12,\n    defaultFontStyle: 'normal',\n    defaultLineHeight: 1.2,\n    showLines: true\n  });\n\n  var core_defaults = defaults;\n  var valueOrDefault = helpers_core.valueOrDefault;\n  /**\n   * Converts the given font object into a CSS font string.\n   * @param {object} font - A font object.\n   * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n   * @private\n   */\n\n  function toFontString(font) {\n    if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {\n      return null;\n    }\n\n    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;\n  }\n  /**\n   * @alias Chart.helpers.options\n   * @namespace\n   */\n\n\n  var helpers_options = {\n    /**\n     * Converts the given line height `value` in pixels for a specific font `size`.\n     * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n     * @param {number} size - The font size (in pixels) used to resolve relative `value`.\n     * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n     * @since 2.7.0\n     */\n    toLineHeight: function (value, size) {\n      var matches = ('' + value).match(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\n\n      if (!matches || matches[1] === 'normal') {\n        return size * 1.2;\n      }\n\n      value = +matches[2];\n\n      switch (matches[3]) {\n        case 'px':\n          return value;\n\n        case '%':\n          value /= 100;\n          break;\n      }\n\n      return size * value;\n    },\n\n    /**\n     * Converts the given value into a padding object with pre-computed width/height.\n     * @param {number|object} value - If a number, set the value to all TRBL component,\n     *  else, if and object, use defined properties and sets undefined ones to 0.\n     * @returns {object} The padding values (top, right, bottom, left, width, height)\n     * @since 2.7.0\n     */\n    toPadding: function (value) {\n      var t, r, b, l;\n\n      if (helpers_core.isObject(value)) {\n        t = +value.top || 0;\n        r = +value.right || 0;\n        b = +value.bottom || 0;\n        l = +value.left || 0;\n      } else {\n        t = r = b = l = +value || 0;\n      }\n\n      return {\n        top: t,\n        right: r,\n        bottom: b,\n        left: l,\n        height: t + b,\n        width: l + r\n      };\n    },\n\n    /**\n     * Parses font options and returns the font object.\n     * @param {object} options - A object that contains font options to be parsed.\n     * @return {object} The font object.\n     * @todo Support font.* options and renamed to toFont().\n     * @private\n     */\n    _parseFont: function (options) {\n      var globalDefaults = core_defaults.global;\n      var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n      var font = {\n        family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),\n        lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),\n        size: size,\n        style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),\n        weight: null,\n        string: ''\n      };\n      font.string = toFontString(font);\n      return font;\n    },\n\n    /**\n     * Evaluates the given `inputs` sequentially and returns the first defined value.\n     * @param {Array} inputs - An array of values, falling back to the last value.\n     * @param {object} [context] - If defined and the current value is a function, the value\n     * is called with `context` as first argument and the result becomes the new input.\n     * @param {number} [index] - If defined and the current value is an array, the value\n     * at `index` become the new input.\n     * @param {object} [info] - object to return information about resolution in\n     * @param {boolean} [info.cacheable] - Will be set to `false` if option is not cacheable.\n     * @since 2.7.0\n     */\n    resolve: function (inputs, context, index, info) {\n      var cacheable = true;\n      var i, ilen, value;\n\n      for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n        value = inputs[i];\n\n        if (value === undefined) {\n          continue;\n        }\n\n        if (context !== undefined && typeof value === 'function') {\n          value = value(context);\n          cacheable = false;\n        }\n\n        if (index !== undefined && helpers_core.isArray(value)) {\n          value = value[index];\n          cacheable = false;\n        }\n\n        if (value !== undefined) {\n          if (info && !cacheable) {\n            info.cacheable = false;\n          }\n\n          return value;\n        }\n      }\n    }\n  };\n  /**\n   * @alias Chart.helpers.math\n   * @namespace\n   */\n\n  var exports$2 = {\n    /**\n     * Returns an array of factors sorted from 1 to sqrt(value)\n     * @private\n     */\n    _factorize: function (value) {\n      var result = [];\n      var sqrt = Math.sqrt(value);\n      var i;\n\n      for (i = 1; i < sqrt; i++) {\n        if (value % i === 0) {\n          result.push(i);\n          result.push(value / i);\n        }\n      }\n\n      if (sqrt === (sqrt | 0)) {\n        // if value is a square number\n        result.push(sqrt);\n      }\n\n      result.sort(function (a, b) {\n        return a - b;\n      }).pop();\n      return result;\n    },\n    log10: Math.log10 || function (x) {\n      var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.\n      // Check for whole powers of 10,\n      // which due to floating point rounding error should be corrected.\n\n      var powerOf10 = Math.round(exponent);\n      var isPowerOf10 = x === Math.pow(10, powerOf10);\n      return isPowerOf10 ? powerOf10 : exponent;\n    }\n  };\n  var helpers_math = exports$2; // DEPRECATIONS\n\n  /**\n   * Provided for backward compatibility, use Chart.helpers.math.log10 instead.\n   * @namespace Chart.helpers.log10\n   * @deprecated since version 2.9.0\n   * @todo remove at version 3\n   * @private\n   */\n\n  helpers_core.log10 = exports$2.log10;\n\n  var getRtlAdapter = function (rectX, width) {\n    return {\n      x: function (x) {\n        return rectX + rectX + width - x;\n      },\n      setWidth: function (w) {\n        width = w;\n      },\n      textAlign: function (align) {\n        if (align === 'center') {\n          return align;\n        }\n\n        return align === 'right' ? 'left' : 'right';\n      },\n      xPlus: function (x, value) {\n        return x - value;\n      },\n      leftForLtr: function (x, itemWidth) {\n        return x - itemWidth;\n      }\n    };\n  };\n\n  var getLtrAdapter = function () {\n    return {\n      x: function (x) {\n        return x;\n      },\n      setWidth: function (w) {// eslint-disable-line no-unused-vars\n      },\n      textAlign: function (align) {\n        return align;\n      },\n      xPlus: function (x, value) {\n        return x + value;\n      },\n      leftForLtr: function (x, _itemWidth) {\n        // eslint-disable-line no-unused-vars\n        return x;\n      }\n    };\n  };\n\n  var getAdapter = function (rtl, rectX, width) {\n    return rtl ? getRtlAdapter(rectX, width) : getLtrAdapter();\n  };\n\n  var overrideTextDirection = function (ctx, direction) {\n    var style, original;\n\n    if (direction === 'ltr' || direction === 'rtl') {\n      style = ctx.canvas.style;\n      original = [style.getPropertyValue('direction'), style.getPropertyPriority('direction')];\n      style.setProperty('direction', direction, 'important');\n      ctx.prevTextDirection = original;\n    }\n  };\n\n  var restoreTextDirection = function (ctx) {\n    var original = ctx.prevTextDirection;\n\n    if (original !== undefined) {\n      delete ctx.prevTextDirection;\n      ctx.canvas.style.setProperty('direction', original[0], original[1]);\n    }\n  };\n\n  var helpers_rtl = {\n    getRtlAdapter: getAdapter,\n    overrideTextDirection: overrideTextDirection,\n    restoreTextDirection: restoreTextDirection\n  };\n  var helpers$1 = helpers_core;\n  var easing = helpers_easing;\n  var canvas = helpers_canvas;\n  var options = helpers_options;\n  var math = helpers_math;\n  var rtl = helpers_rtl;\n  helpers$1.easing = easing;\n  helpers$1.canvas = canvas;\n  helpers$1.options = options;\n  helpers$1.math = math;\n  helpers$1.rtl = rtl;\n\n  function interpolate(start, view, model, ease) {\n    var keys = Object.keys(model);\n    var i, ilen, key, actual, origin, target, type, c0, c1;\n\n    for (i = 0, ilen = keys.length; i < ilen; ++i) {\n      key = keys[i];\n      target = model[key]; // if a value is added to the model after pivot() has been called, the view\n      // doesn't contain it, so let's initialize the view to the target value.\n\n      if (!view.hasOwnProperty(key)) {\n        view[key] = target;\n      }\n\n      actual = view[key];\n\n      if (actual === target || key[0] === '_') {\n        continue;\n      }\n\n      if (!start.hasOwnProperty(key)) {\n        start[key] = actual;\n      }\n\n      origin = start[key];\n      type = typeof target;\n\n      if (type === typeof origin) {\n        if (type === 'string') {\n          c0 = chartjsColor(origin);\n\n          if (c0.valid) {\n            c1 = chartjsColor(target);\n\n            if (c1.valid) {\n              view[key] = c1.mix(c0, ease).rgbString();\n              continue;\n            }\n          }\n        } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {\n          view[key] = origin + (target - origin) * ease;\n          continue;\n        }\n      }\n\n      view[key] = target;\n    }\n  }\n\n  var Element = function (configuration) {\n    helpers$1.extend(this, configuration);\n    this.initialize.apply(this, arguments);\n  };\n\n  helpers$1.extend(Element.prototype, {\n    _type: undefined,\n    initialize: function () {\n      this.hidden = false;\n    },\n    pivot: function () {\n      var me = this;\n\n      if (!me._view) {\n        me._view = helpers$1.extend({}, me._model);\n      }\n\n      me._start = {};\n      return me;\n    },\n    transition: function (ease) {\n      var me = this;\n      var model = me._model;\n      var start = me._start;\n      var view = me._view; // No animation -> No Transition\n\n      if (!model || ease === 1) {\n        me._view = helpers$1.extend({}, model);\n        me._start = null;\n        return me;\n      }\n\n      if (!view) {\n        view = me._view = {};\n      }\n\n      if (!start) {\n        start = me._start = {};\n      }\n\n      interpolate(start, view, model, ease);\n      return me;\n    },\n    tooltipPosition: function () {\n      return {\n        x: this._model.x,\n        y: this._model.y\n      };\n    },\n    hasValue: function () {\n      return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);\n    }\n  });\n  Element.extend = helpers$1.inherits;\n  var core_element = Element;\n  var exports$3 = core_element.extend({\n    chart: null,\n    // the animation associated chart instance\n    currentStep: 0,\n    // the current animation step\n    numSteps: 60,\n    // default number of steps\n    easing: '',\n    // the easing to use for this animation\n    render: null,\n    // render function used by the animation service\n    onAnimationProgress: null,\n    // user specified callback to fire on each step of the animation\n    onAnimationComplete: null // user specified callback to fire when the animation finishes\n\n  });\n  var core_animation = exports$3; // DEPRECATIONS\n\n  /**\n   * Provided for backward compatibility, use Chart.Animation instead\n   * @prop Chart.Animation#animationObject\n   * @deprecated since version 2.6.0\n   * @todo remove at version 3\n   */\n\n  Object.defineProperty(exports$3.prototype, 'animationObject', {\n    get: function () {\n      return this;\n    }\n  });\n  /**\n   * Provided for backward compatibility, use Chart.Animation#chart instead\n   * @prop Chart.Animation#chartInstance\n   * @deprecated since version 2.6.0\n   * @todo remove at version 3\n   */\n\n  Object.defineProperty(exports$3.prototype, 'chartInstance', {\n    get: function () {\n      return this.chart;\n    },\n    set: function (value) {\n      this.chart = value;\n    }\n  });\n\n  core_defaults._set('global', {\n    animation: {\n      duration: 1000,\n      easing: 'easeOutQuart',\n      onProgress: helpers$1.noop,\n      onComplete: helpers$1.noop\n    }\n  });\n\n  var core_animations = {\n    animations: [],\n    request: null,\n\n    /**\n     * @param {Chart} chart - The chart to animate.\n     * @param {Chart.Animation} animation - The animation that we will animate.\n     * @param {number} duration - The animation duration in ms.\n     * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\n     */\n    addAnimation: function (chart, animation, duration, lazy) {\n      var animations = this.animations;\n      var i, ilen;\n      animation.chart = chart;\n      animation.startTime = Date.now();\n      animation.duration = duration;\n\n      if (!lazy) {\n        chart.animating = true;\n      }\n\n      for (i = 0, ilen = animations.length; i < ilen; ++i) {\n        if (animations[i].chart === chart) {\n          animations[i] = animation;\n          return;\n        }\n      }\n\n      animations.push(animation); // If there are no animations queued, manually kickstart a digest, for lack of a better word\n\n      if (animations.length === 1) {\n        this.requestAnimationFrame();\n      }\n    },\n    cancelAnimation: function (chart) {\n      var index = helpers$1.findIndex(this.animations, function (animation) {\n        return animation.chart === chart;\n      });\n\n      if (index !== -1) {\n        this.animations.splice(index, 1);\n        chart.animating = false;\n      }\n    },\n    requestAnimationFrame: function () {\n      var me = this;\n\n      if (me.request === null) {\n        // Skip animation frame requests until the active one is executed.\n        // This can happen when processing mouse events, e.g. 'mousemove'\n        // and 'mouseout' events will trigger multiple renders.\n        me.request = helpers$1.requestAnimFrame.call(window, function () {\n          me.request = null;\n          me.startDigest();\n        });\n      }\n    },\n\n    /**\n     * @private\n     */\n    startDigest: function () {\n      var me = this;\n      me.advance(); // Do we have more stuff to animate?\n\n      if (me.animations.length > 0) {\n        me.requestAnimationFrame();\n      }\n    },\n\n    /**\n     * @private\n     */\n    advance: function () {\n      var animations = this.animations;\n      var animation, chart, numSteps, nextStep;\n      var i = 0; // 1 animation per chart, so we are looping charts here\n\n      while (i < animations.length) {\n        animation = animations[i];\n        chart = animation.chart;\n        numSteps = animation.numSteps; // Make sure that currentStep starts at 1\n        // https://github.com/chartjs/Chart.js/issues/6104\n\n        nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;\n        animation.currentStep = Math.min(nextStep, numSteps);\n        helpers$1.callback(animation.render, [chart, animation], chart);\n        helpers$1.callback(animation.onAnimationProgress, [animation], chart);\n\n        if (animation.currentStep >= numSteps) {\n          helpers$1.callback(animation.onAnimationComplete, [animation], chart);\n          chart.animating = false;\n          animations.splice(i, 1);\n        } else {\n          ++i;\n        }\n      }\n    }\n  };\n  var resolve = helpers$1.options.resolve;\n  var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n  /**\n   * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n   * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n   * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\n   */\n\n  function listenArrayEvents(array, listener) {\n    if (array._chartjs) {\n      array._chartjs.listeners.push(listener);\n\n      return;\n    }\n\n    Object.defineProperty(array, '_chartjs', {\n      configurable: true,\n      enumerable: false,\n      value: {\n        listeners: [listener]\n      }\n    });\n    arrayEvents.forEach(function (key) {\n      var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\n      var base = array[key];\n      Object.defineProperty(array, key, {\n        configurable: true,\n        enumerable: false,\n        value: function () {\n          var args = Array.prototype.slice.call(arguments);\n          var res = base.apply(this, args);\n          helpers$1.each(array._chartjs.listeners, function (object) {\n            if (typeof object[method] === 'function') {\n              object[method].apply(object, args);\n            }\n          });\n          return res;\n        }\n      });\n    });\n  }\n  /**\n   * Removes the given array event listener and cleanup extra attached properties (such as\n   * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n   */\n\n\n  function unlistenArrayEvents(array, listener) {\n    var stub = array._chartjs;\n\n    if (!stub) {\n      return;\n    }\n\n    var listeners = stub.listeners;\n    var index = listeners.indexOf(listener);\n\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n\n    if (listeners.length > 0) {\n      return;\n    }\n\n    arrayEvents.forEach(function (key) {\n      delete array[key];\n    });\n    delete array._chartjs;\n  } // Base class for all dataset controllers (line, bar, etc)\n\n\n  var DatasetController = function (chart, datasetIndex) {\n    this.initialize(chart, datasetIndex);\n  };\n\n  helpers$1.extend(DatasetController.prototype, {\n    /**\n     * Element type used to generate a meta dataset (e.g. Chart.element.Line).\n     * @type {Chart.core.element}\n     */\n    datasetElementType: null,\n\n    /**\n     * Element type used to generate a meta data (e.g. Chart.element.Point).\n     * @type {Chart.core.element}\n     */\n    dataElementType: null,\n\n    /**\n     * Dataset element option keys to be resolved in _resolveDatasetElementOptions.\n     * A derived controller may override this to resolve controller-specific options.\n     * The keys defined here are for backward compatibility for legend styles.\n     * @private\n     */\n    _datasetElementOptions: ['backgroundColor', 'borderCapStyle', 'borderColor', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'borderWidth'],\n\n    /**\n     * Data element option keys to be resolved in _resolveDataElementOptions.\n     * A derived controller may override this to resolve controller-specific options.\n     * The keys defined here are for backward compatibility for legend styles.\n     * @private\n     */\n    _dataElementOptions: ['backgroundColor', 'borderColor', 'borderWidth', 'pointStyle'],\n    initialize: function (chart, datasetIndex) {\n      var me = this;\n      me.chart = chart;\n      me.index = datasetIndex;\n      me.linkScales();\n      me.addElements();\n      me._type = me.getMeta().type;\n    },\n    updateIndex: function (datasetIndex) {\n      this.index = datasetIndex;\n    },\n    linkScales: function () {\n      var me = this;\n      var meta = me.getMeta();\n      var chart = me.chart;\n      var scales = chart.scales;\n      var dataset = me.getDataset();\n      var scalesOpts = chart.options.scales;\n\n      if (meta.xAxisID === null || !(meta.xAxisID in scales) || dataset.xAxisID) {\n        meta.xAxisID = dataset.xAxisID || scalesOpts.xAxes[0].id;\n      }\n\n      if (meta.yAxisID === null || !(meta.yAxisID in scales) || dataset.yAxisID) {\n        meta.yAxisID = dataset.yAxisID || scalesOpts.yAxes[0].id;\n      }\n    },\n    getDataset: function () {\n      return this.chart.data.datasets[this.index];\n    },\n    getMeta: function () {\n      return this.chart.getDatasetMeta(this.index);\n    },\n    getScaleForId: function (scaleID) {\n      return this.chart.scales[scaleID];\n    },\n\n    /**\n     * @private\n     */\n    _getValueScaleId: function () {\n      return this.getMeta().yAxisID;\n    },\n\n    /**\n     * @private\n     */\n    _getIndexScaleId: function () {\n      return this.getMeta().xAxisID;\n    },\n\n    /**\n     * @private\n     */\n    _getValueScale: function () {\n      return this.getScaleForId(this._getValueScaleId());\n    },\n\n    /**\n     * @private\n     */\n    _getIndexScale: function () {\n      return this.getScaleForId(this._getIndexScaleId());\n    },\n    reset: function () {\n      this._update(true);\n    },\n\n    /**\n     * @private\n     */\n    destroy: function () {\n      if (this._data) {\n        unlistenArrayEvents(this._data, this);\n      }\n    },\n    createMetaDataset: function () {\n      var me = this;\n      var type = me.datasetElementType;\n      return type && new type({\n        _chart: me.chart,\n        _datasetIndex: me.index\n      });\n    },\n    createMetaData: function (index) {\n      var me = this;\n      var type = me.dataElementType;\n      return type && new type({\n        _chart: me.chart,\n        _datasetIndex: me.index,\n        _index: index\n      });\n    },\n    addElements: function () {\n      var me = this;\n      var meta = me.getMeta();\n      var data = me.getDataset().data || [];\n      var metaData = meta.data;\n      var i, ilen;\n\n      for (i = 0, ilen = data.length; i < ilen; ++i) {\n        metaData[i] = metaData[i] || me.createMetaData(i);\n      }\n\n      meta.dataset = meta.dataset || me.createMetaDataset();\n    },\n    addElementAndReset: function (index) {\n      var element = this.createMetaData(index);\n      this.getMeta().data.splice(index, 0, element);\n      this.updateElement(element, index, true);\n    },\n    buildOrUpdateElements: function () {\n      var me = this;\n      var dataset = me.getDataset();\n      var data = dataset.data || (dataset.data = []); // In order to correctly handle data addition/deletion animation (an thus simulate\n      // real-time charts), we need to monitor these data modifications and synchronize\n      // the internal meta data accordingly.\n\n      if (me._data !== data) {\n        if (me._data) {\n          // This case happens when the user replaced the data array instance.\n          unlistenArrayEvents(me._data, me);\n        }\n\n        if (data && Object.isExtensible(data)) {\n          listenArrayEvents(data, me);\n        }\n\n        me._data = data;\n      } // Re-sync meta data in case the user replaced the data array or if we missed\n      // any updates and so make sure that we handle number of datapoints changing.\n\n\n      me.resyncElements();\n    },\n\n    /**\n     * Returns the merged user-supplied and default dataset-level options\n     * @private\n     */\n    _configure: function () {\n      var me = this;\n      me._config = helpers$1.merge({}, [me.chart.options.datasets[me._type], me.getDataset()], {\n        merger: function (key, target, source) {\n          if (key !== '_meta' && key !== 'data') {\n            helpers$1._merger(key, target, source);\n          }\n        }\n      });\n    },\n    _update: function (reset) {\n      var me = this;\n\n      me._configure();\n\n      me._cachedDataOpts = null;\n      me.update(reset);\n    },\n    update: helpers$1.noop,\n    transition: function (easingValue) {\n      var meta = this.getMeta();\n      var elements = meta.data || [];\n      var ilen = elements.length;\n      var i = 0;\n\n      for (; i < ilen; ++i) {\n        elements[i].transition(easingValue);\n      }\n\n      if (meta.dataset) {\n        meta.dataset.transition(easingValue);\n      }\n    },\n    draw: function () {\n      var meta = this.getMeta();\n      var elements = meta.data || [];\n      var ilen = elements.length;\n      var i = 0;\n\n      if (meta.dataset) {\n        meta.dataset.draw();\n      }\n\n      for (; i < ilen; ++i) {\n        elements[i].draw();\n      }\n    },\n\n    /**\n     * Returns a set of predefined style properties that should be used to represent the dataset\n     * or the data if the index is specified\n     * @param {number} index - data index\n     * @return {IStyleInterface} style object\n     */\n    getStyle: function (index) {\n      var me = this;\n      var meta = me.getMeta();\n      var dataset = meta.dataset;\n      var style;\n\n      me._configure();\n\n      if (dataset && index === undefined) {\n        style = me._resolveDatasetElementOptions(dataset || {});\n      } else {\n        index = index || 0;\n        style = me._resolveDataElementOptions(meta.data[index] || {}, index);\n      }\n\n      if (style.fill === false || style.fill === null) {\n        style.backgroundColor = style.borderColor;\n      }\n\n      return style;\n    },\n\n    /**\n     * @private\n     */\n    _resolveDatasetElementOptions: function (element, hover) {\n      var me = this;\n      var chart = me.chart;\n      var datasetOpts = me._config;\n      var custom = element.custom || {};\n      var options = chart.options.elements[me.datasetElementType.prototype._type] || {};\n      var elementOptions = me._datasetElementOptions;\n      var values = {};\n      var i, ilen, key, readKey; // Scriptable options\n\n      var context = {\n        chart: chart,\n        dataset: me.getDataset(),\n        datasetIndex: me.index,\n        hover: hover\n      };\n\n      for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {\n        key = elementOptions[i];\n        readKey = hover ? 'hover' + key.charAt(0).toUpperCase() + key.slice(1) : key;\n        values[key] = resolve([custom[readKey], datasetOpts[readKey], options[readKey]], context);\n      }\n\n      return values;\n    },\n\n    /**\n     * @private\n     */\n    _resolveDataElementOptions: function (element, index) {\n      var me = this;\n      var custom = element && element.custom;\n      var cached = me._cachedDataOpts;\n\n      if (cached && !custom) {\n        return cached;\n      }\n\n      var chart = me.chart;\n      var datasetOpts = me._config;\n      var options = chart.options.elements[me.dataElementType.prototype._type] || {};\n      var elementOptions = me._dataElementOptions;\n      var values = {}; // Scriptable options\n\n      var context = {\n        chart: chart,\n        dataIndex: index,\n        dataset: me.getDataset(),\n        datasetIndex: me.index\n      }; // `resolve` sets cacheable to `false` if any option is indexed or scripted\n\n      var info = {\n        cacheable: !custom\n      };\n      var keys, i, ilen, key;\n      custom = custom || {};\n\n      if (helpers$1.isArray(elementOptions)) {\n        for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {\n          key = elementOptions[i];\n          values[key] = resolve([custom[key], datasetOpts[key], options[key]], context, index, info);\n        }\n      } else {\n        keys = Object.keys(elementOptions);\n\n        for (i = 0, ilen = keys.length; i < ilen; ++i) {\n          key = keys[i];\n          values[key] = resolve([custom[key], datasetOpts[elementOptions[key]], datasetOpts[key], options[key]], context, index, info);\n        }\n      }\n\n      if (info.cacheable) {\n        me._cachedDataOpts = Object.freeze(values);\n      }\n\n      return values;\n    },\n    removeHoverStyle: function (element) {\n      helpers$1.merge(element._model, element.$previousStyle || {});\n      delete element.$previousStyle;\n    },\n    setHoverStyle: function (element) {\n      var dataset = this.chart.data.datasets[element._datasetIndex];\n      var index = element._index;\n      var custom = element.custom || {};\n      var model = element._model;\n      var getHoverColor = helpers$1.getHoverColor;\n      element.$previousStyle = {\n        backgroundColor: model.backgroundColor,\n        borderColor: model.borderColor,\n        borderWidth: model.borderWidth\n      };\n      model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);\n      model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);\n      model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);\n    },\n\n    /**\n     * @private\n     */\n    _removeDatasetHoverStyle: function () {\n      var element = this.getMeta().dataset;\n\n      if (element) {\n        this.removeHoverStyle(element);\n      }\n    },\n\n    /**\n     * @private\n     */\n    _setDatasetHoverStyle: function () {\n      var element = this.getMeta().dataset;\n      var prev = {};\n      var i, ilen, key, keys, hoverOptions, model;\n\n      if (!element) {\n        return;\n      }\n\n      model = element._model;\n      hoverOptions = this._resolveDatasetElementOptions(element, true);\n      keys = Object.keys(hoverOptions);\n\n      for (i = 0, ilen = keys.length; i < ilen; ++i) {\n        key = keys[i];\n        prev[key] = model[key];\n        model[key] = hoverOptions[key];\n      }\n\n      element.$previousStyle = prev;\n    },\n\n    /**\n     * @private\n     */\n    resyncElements: function () {\n      var me = this;\n      var meta = me.getMeta();\n      var data = me.getDataset().data;\n      var numMeta = meta.data.length;\n      var numData = data.length;\n\n      if (numData < numMeta) {\n        meta.data.splice(numData, numMeta - numData);\n      } else if (numData > numMeta) {\n        me.insertElements(numMeta, numData - numMeta);\n      }\n    },\n\n    /**\n     * @private\n     */\n    insertElements: function (start, count) {\n      for (var i = 0; i < count; ++i) {\n        this.addElementAndReset(start + i);\n      }\n    },\n\n    /**\n     * @private\n     */\n    onDataPush: function () {\n      var count = arguments.length;\n      this.insertElements(this.getDataset().data.length - count, count);\n    },\n\n    /**\n     * @private\n     */\n    onDataPop: function () {\n      this.getMeta().data.pop();\n    },\n\n    /**\n     * @private\n     */\n    onDataShift: function () {\n      this.getMeta().data.shift();\n    },\n\n    /**\n     * @private\n     */\n    onDataSplice: function (start, count) {\n      this.getMeta().data.splice(start, count);\n      this.insertElements(start, arguments.length - 2);\n    },\n\n    /**\n     * @private\n     */\n    onDataUnshift: function () {\n      this.insertElements(0, arguments.length);\n    }\n  });\n  DatasetController.extend = helpers$1.inherits;\n  var core_datasetController = DatasetController;\n  var TAU = Math.PI * 2;\n\n  core_defaults._set('global', {\n    elements: {\n      arc: {\n        backgroundColor: core_defaults.global.defaultColor,\n        borderColor: '#fff',\n        borderWidth: 2,\n        borderAlign: 'center'\n      }\n    }\n  });\n\n  function clipArc(ctx, arc) {\n    var startAngle = arc.startAngle;\n    var endAngle = arc.endAngle;\n    var pixelMargin = arc.pixelMargin;\n    var angleMargin = pixelMargin / arc.outerRadius;\n    var x = arc.x;\n    var y = arc.y; // Draw an inner border by cliping the arc and drawing a double-width border\n    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n\n    ctx.beginPath();\n    ctx.arc(x, y, arc.outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n\n    if (arc.innerRadius > pixelMargin) {\n      angleMargin = pixelMargin / arc.innerRadius;\n      ctx.arc(x, y, arc.innerRadius - pixelMargin, endAngle + angleMargin, startAngle - angleMargin, true);\n    } else {\n      ctx.arc(x, y, pixelMargin, endAngle + Math.PI / 2, startAngle - Math.PI / 2);\n    }\n\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  function drawFullCircleBorders(ctx, vm, arc, inner) {\n    var endAngle = arc.endAngle;\n    var i;\n\n    if (inner) {\n      arc.endAngle = arc.startAngle + TAU;\n      clipArc(ctx, arc);\n      arc.endAngle = endAngle;\n\n      if (arc.endAngle === arc.startAngle && arc.fullCircles) {\n        arc.endAngle += TAU;\n        arc.fullCircles--;\n      }\n    }\n\n    ctx.beginPath();\n    ctx.arc(arc.x, arc.y, arc.innerRadius, arc.startAngle + TAU, arc.startAngle, true);\n\n    for (i = 0; i < arc.fullCircles; ++i) {\n      ctx.stroke();\n    }\n\n    ctx.beginPath();\n    ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.startAngle + TAU);\n\n    for (i = 0; i < arc.fullCircles; ++i) {\n      ctx.stroke();\n    }\n  }\n\n  function drawBorder(ctx, vm, arc) {\n    var inner = vm.borderAlign === 'inner';\n\n    if (inner) {\n      ctx.lineWidth = vm.borderWidth * 2;\n      ctx.lineJoin = 'round';\n    } else {\n      ctx.lineWidth = vm.borderWidth;\n      ctx.lineJoin = 'bevel';\n    }\n\n    if (arc.fullCircles) {\n      drawFullCircleBorders(ctx, vm, arc, inner);\n    }\n\n    if (inner) {\n      clipArc(ctx, arc);\n    }\n\n    ctx.beginPath();\n    ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.endAngle);\n    ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n  var element_arc = core_element.extend({\n    _type: 'arc',\n    inLabelRange: function (mouseX) {\n      var vm = this._view;\n\n      if (vm) {\n        return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);\n      }\n\n      return false;\n    },\n    inRange: function (chartX, chartY) {\n      var vm = this._view;\n\n      if (vm) {\n        var pointRelativePosition = helpers$1.getAngleFromPoint(vm, {\n          x: chartX,\n          y: chartY\n        });\n        var angle = pointRelativePosition.angle;\n        var distance = pointRelativePosition.distance; // Sanitise angle range\n\n        var startAngle = vm.startAngle;\n        var endAngle = vm.endAngle;\n\n        while (endAngle < startAngle) {\n          endAngle += TAU;\n        }\n\n        while (angle > endAngle) {\n          angle -= TAU;\n        }\n\n        while (angle < startAngle) {\n          angle += TAU;\n        } // Check if within the range of the open/close angle\n\n\n        var betweenAngles = angle >= startAngle && angle <= endAngle;\n        var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;\n        return betweenAngles && withinRadius;\n      }\n\n      return false;\n    },\n    getCenterPoint: function () {\n      var vm = this._view;\n      var halfAngle = (vm.startAngle + vm.endAngle) / 2;\n      var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\n      return {\n        x: vm.x + Math.cos(halfAngle) * halfRadius,\n        y: vm.y + Math.sin(halfAngle) * halfRadius\n      };\n    },\n    getArea: function () {\n      var vm = this._view;\n      return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\n    },\n    tooltipPosition: function () {\n      var vm = this._view;\n      var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;\n      var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\n      return {\n        x: vm.x + Math.cos(centreAngle) * rangeFromCentre,\n        y: vm.y + Math.sin(centreAngle) * rangeFromCentre\n      };\n    },\n    draw: function () {\n      var ctx = this._chart.ctx;\n      var vm = this._view;\n      var pixelMargin = vm.borderAlign === 'inner' ? 0.33 : 0;\n      var arc = {\n        x: vm.x,\n        y: vm.y,\n        innerRadius: vm.innerRadius,\n        outerRadius: Math.max(vm.outerRadius - pixelMargin, 0),\n        pixelMargin: pixelMargin,\n        startAngle: vm.startAngle,\n        endAngle: vm.endAngle,\n        fullCircles: Math.floor(vm.circumference / TAU)\n      };\n      var i;\n      ctx.save();\n      ctx.fillStyle = vm.backgroundColor;\n      ctx.strokeStyle = vm.borderColor;\n\n      if (arc.fullCircles) {\n        arc.endAngle = arc.startAngle + TAU;\n        ctx.beginPath();\n        ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);\n        ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);\n        ctx.closePath();\n\n        for (i = 0; i < arc.fullCircles; ++i) {\n          ctx.fill();\n        }\n\n        arc.endAngle = arc.startAngle + vm.circumference % TAU;\n      }\n\n      ctx.beginPath();\n      ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);\n      ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);\n      ctx.closePath();\n      ctx.fill();\n\n      if (vm.borderWidth) {\n        drawBorder(ctx, vm, arc);\n      }\n\n      ctx.restore();\n    }\n  });\n  var valueOrDefault$1 = helpers$1.valueOrDefault;\n  var defaultColor = core_defaults.global.defaultColor;\n\n  core_defaults._set('global', {\n    elements: {\n      line: {\n        tension: 0.4,\n        backgroundColor: defaultColor,\n        borderWidth: 3,\n        borderColor: defaultColor,\n        borderCapStyle: 'butt',\n        borderDash: [],\n        borderDashOffset: 0.0,\n        borderJoinStyle: 'miter',\n        capBezierPoints: true,\n        fill: true // do we fill in the area between the line and its base axis\n\n      }\n    }\n  });\n\n  var element_line = core_element.extend({\n    _type: 'line',\n    draw: function () {\n      var me = this;\n      var vm = me._view;\n      var ctx = me._chart.ctx;\n      var spanGaps = vm.spanGaps;\n\n      var points = me._children.slice(); // clone array\n\n\n      var globalDefaults = core_defaults.global;\n      var globalOptionLineElements = globalDefaults.elements.line;\n      var lastDrawnIndex = -1;\n      var closePath = me._loop;\n      var index, previous, currentVM;\n\n      if (!points.length) {\n        return;\n      }\n\n      if (me._loop) {\n        for (index = 0; index < points.length; ++index) {\n          previous = helpers$1.previousItem(points, index); // If the line has an open path, shift the point array\n\n          if (!points[index]._view.skip && previous._view.skip) {\n            points = points.slice(index).concat(points.slice(0, index));\n            closePath = spanGaps;\n            break;\n          }\n        } // If the line has a close path, add the first point again\n\n\n        if (closePath) {\n          points.push(points[0]);\n        }\n      }\n\n      ctx.save(); // Stroke Line Options\n\n      ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle; // IE 9 and 10 do not support line dash\n\n      if (ctx.setLineDash) {\n        ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n      }\n\n      ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);\n      ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n      ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);\n      ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor; // Stroke Line\n\n      ctx.beginPath(); // First point moves to it's starting position no matter what\n\n      currentVM = points[0]._view;\n\n      if (!currentVM.skip) {\n        ctx.moveTo(currentVM.x, currentVM.y);\n        lastDrawnIndex = 0;\n      }\n\n      for (index = 1; index < points.length; ++index) {\n        currentVM = points[index]._view;\n        previous = lastDrawnIndex === -1 ? helpers$1.previousItem(points, index) : points[lastDrawnIndex];\n\n        if (!currentVM.skip) {\n          if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {\n            // There was a gap and this is the first point after the gap\n            ctx.moveTo(currentVM.x, currentVM.y);\n          } else {\n            // Line to next point\n            helpers$1.canvas.lineTo(ctx, previous._view, currentVM);\n          }\n\n          lastDrawnIndex = index;\n        }\n      }\n\n      if (closePath) {\n        ctx.closePath();\n      }\n\n      ctx.stroke();\n      ctx.restore();\n    }\n  });\n  var valueOrDefault$2 = helpers$1.valueOrDefault;\n  var defaultColor$1 = core_defaults.global.defaultColor;\n\n  core_defaults._set('global', {\n    elements: {\n      point: {\n        radius: 3,\n        pointStyle: 'circle',\n        backgroundColor: defaultColor$1,\n        borderColor: defaultColor$1,\n        borderWidth: 1,\n        // Hover\n        hitRadius: 1,\n        hoverRadius: 4,\n        hoverBorderWidth: 1\n      }\n    }\n  });\n\n  function xRange(mouseX) {\n    var vm = this._view;\n    return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;\n  }\n\n  function yRange(mouseY) {\n    var vm = this._view;\n    return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;\n  }\n\n  var element_point = core_element.extend({\n    _type: 'point',\n    inRange: function (mouseX, mouseY) {\n      var vm = this._view;\n      return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;\n    },\n    inLabelRange: xRange,\n    inXRange: xRange,\n    inYRange: yRange,\n    getCenterPoint: function () {\n      var vm = this._view;\n      return {\n        x: vm.x,\n        y: vm.y\n      };\n    },\n    getArea: function () {\n      return Math.PI * Math.pow(this._view.radius, 2);\n    },\n    tooltipPosition: function () {\n      var vm = this._view;\n      return {\n        x: vm.x,\n        y: vm.y,\n        padding: vm.radius + vm.borderWidth\n      };\n    },\n    draw: function (chartArea) {\n      var vm = this._view;\n      var ctx = this._chart.ctx;\n      var pointStyle = vm.pointStyle;\n      var rotation = vm.rotation;\n      var radius = vm.radius;\n      var x = vm.x;\n      var y = vm.y;\n      var globalDefaults = core_defaults.global;\n      var defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow\n\n      if (vm.skip) {\n        return;\n      } // Clipping for Points.\n\n\n      if (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {\n        ctx.strokeStyle = vm.borderColor || defaultColor;\n        ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);\n        ctx.fillStyle = vm.backgroundColor || defaultColor;\n        helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);\n      }\n    }\n  });\n  var defaultColor$2 = core_defaults.global.defaultColor;\n\n  core_defaults._set('global', {\n    elements: {\n      rectangle: {\n        backgroundColor: defaultColor$2,\n        borderColor: defaultColor$2,\n        borderSkipped: 'bottom',\n        borderWidth: 0\n      }\n    }\n  });\n\n  function isVertical(vm) {\n    return vm && vm.width !== undefined;\n  }\n  /**\n   * Helper function to get the bounds of the bar regardless of the orientation\n   * @param bar {Chart.Element.Rectangle} the bar\n   * @return {Bounds} bounds of the bar\n   * @private\n   */\n\n\n  function getBarBounds(vm) {\n    var x1, x2, y1, y2, half;\n\n    if (isVertical(vm)) {\n      half = vm.width / 2;\n      x1 = vm.x - half;\n      x2 = vm.x + half;\n      y1 = Math.min(vm.y, vm.base);\n      y2 = Math.max(vm.y, vm.base);\n    } else {\n      half = vm.height / 2;\n      x1 = Math.min(vm.x, vm.base);\n      x2 = Math.max(vm.x, vm.base);\n      y1 = vm.y - half;\n      y2 = vm.y + half;\n    }\n\n    return {\n      left: x1,\n      top: y1,\n      right: x2,\n      bottom: y2\n    };\n  }\n\n  function swap(orig, v1, v2) {\n    return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n  }\n\n  function parseBorderSkipped(vm) {\n    var edge = vm.borderSkipped;\n    var res = {};\n\n    if (!edge) {\n      return res;\n    }\n\n    if (vm.horizontal) {\n      if (vm.base > vm.x) {\n        edge = swap(edge, 'left', 'right');\n      }\n    } else if (vm.base < vm.y) {\n      edge = swap(edge, 'bottom', 'top');\n    }\n\n    res[edge] = true;\n    return res;\n  }\n\n  function parseBorderWidth(vm, maxW, maxH) {\n    var value = vm.borderWidth;\n    var skip = parseBorderSkipped(vm);\n    var t, r, b, l;\n\n    if (helpers$1.isObject(value)) {\n      t = +value.top || 0;\n      r = +value.right || 0;\n      b = +value.bottom || 0;\n      l = +value.left || 0;\n    } else {\n      t = r = b = l = +value || 0;\n    }\n\n    return {\n      t: skip.top || t < 0 ? 0 : t > maxH ? maxH : t,\n      r: skip.right || r < 0 ? 0 : r > maxW ? maxW : r,\n      b: skip.bottom || b < 0 ? 0 : b > maxH ? maxH : b,\n      l: skip.left || l < 0 ? 0 : l > maxW ? maxW : l\n    };\n  }\n\n  function boundingRects(vm) {\n    var bounds = getBarBounds(vm);\n    var width = bounds.right - bounds.left;\n    var height = bounds.bottom - bounds.top;\n    var border = parseBorderWidth(vm, width / 2, height / 2);\n    return {\n      outer: {\n        x: bounds.left,\n        y: bounds.top,\n        w: width,\n        h: height\n      },\n      inner: {\n        x: bounds.left + border.l,\n        y: bounds.top + border.t,\n        w: width - border.l - border.r,\n        h: height - border.t - border.b\n      }\n    };\n  }\n\n  function inRange(vm, x, y) {\n    var skipX = x === null;\n    var skipY = y === null;\n    var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);\n    return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);\n  }\n\n  var element_rectangle = core_element.extend({\n    _type: 'rectangle',\n    draw: function () {\n      var ctx = this._chart.ctx;\n      var vm = this._view;\n      var rects = boundingRects(vm);\n      var outer = rects.outer;\n      var inner = rects.inner;\n      ctx.fillStyle = vm.backgroundColor;\n      ctx.fillRect(outer.x, outer.y, outer.w, outer.h);\n\n      if (outer.w === inner.w && outer.h === inner.h) {\n        return;\n      }\n\n      ctx.save();\n      ctx.beginPath();\n      ctx.rect(outer.x, outer.y, outer.w, outer.h);\n      ctx.clip();\n      ctx.fillStyle = vm.borderColor;\n      ctx.rect(inner.x, inner.y, inner.w, inner.h);\n      ctx.fill('evenodd');\n      ctx.restore();\n    },\n    height: function () {\n      var vm = this._view;\n      return vm.base - vm.y;\n    },\n    inRange: function (mouseX, mouseY) {\n      return inRange(this._view, mouseX, mouseY);\n    },\n    inLabelRange: function (mouseX, mouseY) {\n      var vm = this._view;\n      return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);\n    },\n    inXRange: function (mouseX) {\n      return inRange(this._view, mouseX, null);\n    },\n    inYRange: function (mouseY) {\n      return inRange(this._view, null, mouseY);\n    },\n    getCenterPoint: function () {\n      var vm = this._view;\n      var x, y;\n\n      if (isVertical(vm)) {\n        x = vm.x;\n        y = (vm.y + vm.base) / 2;\n      } else {\n        x = (vm.x + vm.base) / 2;\n        y = vm.y;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    getArea: function () {\n      var vm = this._view;\n      return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);\n    },\n    tooltipPosition: function () {\n      var vm = this._view;\n      return {\n        x: vm.x,\n        y: vm.y\n      };\n    }\n  });\n  var elements = {};\n  var Arc = element_arc;\n  var Line = element_line;\n  var Point = element_point;\n  var Rectangle = element_rectangle;\n  elements.Arc = Arc;\n  elements.Line = Line;\n  elements.Point = Point;\n  elements.Rectangle = Rectangle;\n  var deprecated = helpers$1._deprecated;\n  var valueOrDefault$3 = helpers$1.valueOrDefault;\n\n  core_defaults._set('bar', {\n    hover: {\n      mode: 'label'\n    },\n    scales: {\n      xAxes: [{\n        type: 'category',\n        offset: true,\n        gridLines: {\n          offsetGridLines: true\n        }\n      }],\n      yAxes: [{\n        type: 'linear'\n      }]\n    }\n  });\n\n  core_defaults._set('global', {\n    datasets: {\n      bar: {\n        categoryPercentage: 0.8,\n        barPercentage: 0.9\n      }\n    }\n  });\n  /**\n   * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n   * @private\n   */\n\n\n  function computeMinSampleSize(scale, pixels) {\n    var min = scale._length;\n    var prev, curr, i, ilen;\n\n    for (i = 1, ilen = pixels.length; i < ilen; ++i) {\n      min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));\n    }\n\n    for (i = 0, ilen = scale.getTicks().length; i < ilen; ++i) {\n      curr = scale.getPixelForTick(i);\n      min = i > 0 ? Math.min(min, Math.abs(curr - prev)) : min;\n      prev = curr;\n    }\n\n    return min;\n  }\n  /**\n   * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n   * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n   * mode currently always generates bars equally sized (until we introduce scriptable options?).\n   * @private\n   */\n\n\n  function computeFitCategoryTraits(index, ruler, options) {\n    var thickness = options.barThickness;\n    var count = ruler.stackCount;\n    var curr = ruler.pixels[index];\n    var min = helpers$1.isNullOrUndef(thickness) ? computeMinSampleSize(ruler.scale, ruler.pixels) : -1;\n    var size, ratio;\n\n    if (helpers$1.isNullOrUndef(thickness)) {\n      size = min * options.categoryPercentage;\n      ratio = options.barPercentage;\n    } else {\n      // When bar thickness is enforced, category and bar percentages are ignored.\n      // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n      // and deprecate barPercentage since this value is ignored when thickness is absolute.\n      size = thickness * count;\n      ratio = 1;\n    }\n\n    return {\n      chunk: size / count,\n      ratio: ratio,\n      start: curr - size / 2\n    };\n  }\n  /**\n   * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n   * percentage options are 1), based on the previous and following categories. This mode\n   * generates bars with different widths when data are not evenly spaced.\n   * @private\n   */\n\n\n  function computeFlexCategoryTraits(index, ruler, options) {\n    var pixels = ruler.pixels;\n    var curr = pixels[index];\n    var prev = index > 0 ? pixels[index - 1] : null;\n    var next = index < pixels.length - 1 ? pixels[index + 1] : null;\n    var percent = options.categoryPercentage;\n    var start, size;\n\n    if (prev === null) {\n      // first data: its size is double based on the next point or,\n      // if it's also the last data, we use the scale size.\n      prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n    }\n\n    if (next === null) {\n      // last data: its size is also double based on the previous point.\n      next = curr + curr - prev;\n    }\n\n    start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n    size = Math.abs(next - prev) / 2 * percent;\n    return {\n      chunk: size / ruler.stackCount,\n      ratio: options.barPercentage,\n      start: start\n    };\n  }\n\n  var controller_bar = core_datasetController.extend({\n    dataElementType: elements.Rectangle,\n\n    /**\n     * @private\n     */\n    _dataElementOptions: ['backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth', 'barPercentage', 'barThickness', 'categoryPercentage', 'maxBarThickness', 'minBarLength'],\n    initialize: function () {\n      var me = this;\n      var meta, scaleOpts;\n      core_datasetController.prototype.initialize.apply(me, arguments);\n      meta = me.getMeta();\n      meta.stack = me.getDataset().stack;\n      meta.bar = true;\n      scaleOpts = me._getIndexScale().options;\n      deprecated('bar chart', scaleOpts.barPercentage, 'scales.[x/y]Axes.barPercentage', 'dataset.barPercentage');\n      deprecated('bar chart', scaleOpts.barThickness, 'scales.[x/y]Axes.barThickness', 'dataset.barThickness');\n      deprecated('bar chart', scaleOpts.categoryPercentage, 'scales.[x/y]Axes.categoryPercentage', 'dataset.categoryPercentage');\n      deprecated('bar chart', me._getValueScale().options.minBarLength, 'scales.[x/y]Axes.minBarLength', 'dataset.minBarLength');\n      deprecated('bar chart', scaleOpts.maxBarThickness, 'scales.[x/y]Axes.maxBarThickness', 'dataset.maxBarThickness');\n    },\n    update: function (reset) {\n      var me = this;\n      var rects = me.getMeta().data;\n      var i, ilen;\n      me._ruler = me.getRuler();\n\n      for (i = 0, ilen = rects.length; i < ilen; ++i) {\n        me.updateElement(rects[i], i, reset);\n      }\n    },\n    updateElement: function (rectangle, index, reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var dataset = me.getDataset();\n\n      var options = me._resolveDataElementOptions(rectangle, index);\n\n      rectangle._xScale = me.getScaleForId(meta.xAxisID);\n      rectangle._yScale = me.getScaleForId(meta.yAxisID);\n      rectangle._datasetIndex = me.index;\n      rectangle._index = index;\n      rectangle._model = {\n        backgroundColor: options.backgroundColor,\n        borderColor: options.borderColor,\n        borderSkipped: options.borderSkipped,\n        borderWidth: options.borderWidth,\n        datasetLabel: dataset.label,\n        label: me.chart.data.labels[index]\n      };\n\n      if (helpers$1.isArray(dataset.data[index])) {\n        rectangle._model.borderSkipped = null;\n      }\n\n      me._updateElementGeometry(rectangle, index, reset, options);\n\n      rectangle.pivot();\n    },\n\n    /**\n     * @private\n     */\n    _updateElementGeometry: function (rectangle, index, reset, options) {\n      var me = this;\n      var model = rectangle._model;\n\n      var vscale = me._getValueScale();\n\n      var base = vscale.getBasePixel();\n      var horizontal = vscale.isHorizontal();\n      var ruler = me._ruler || me.getRuler();\n      var vpixels = me.calculateBarValuePixels(me.index, index, options);\n      var ipixels = me.calculateBarIndexPixels(me.index, index, ruler, options);\n      model.horizontal = horizontal;\n      model.base = reset ? base : vpixels.base;\n      model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\n      model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\n      model.height = horizontal ? ipixels.size : undefined;\n      model.width = horizontal ? undefined : ipixels.size;\n    },\n\n    /**\n     * Returns the stacks based on groups and bar visibility.\n     * @param {number} [last] - The dataset index\n     * @returns {string[]} The list of stack IDs\n     * @private\n     */\n    _getStacks: function (last) {\n      var me = this;\n\n      var scale = me._getIndexScale();\n\n      var metasets = scale._getMatchingVisibleMetas(me._type);\n\n      var stacked = scale.options.stacked;\n      var ilen = metasets.length;\n      var stacks = [];\n      var i, meta;\n\n      for (i = 0; i < ilen; ++i) {\n        meta = metasets[i]; // stacked   | meta.stack\n        //           | found | not found | undefined\n        // false     |   x   |     x     |     x\n        // true      |       |     x     |\n        // undefined |       |     x     |     x\n\n        if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {\n          stacks.push(meta.stack);\n        }\n\n        if (meta.index === last) {\n          break;\n        }\n      }\n\n      return stacks;\n    },\n\n    /**\n     * Returns the effective number of stacks based on groups and bar visibility.\n     * @private\n     */\n    getStackCount: function () {\n      return this._getStacks().length;\n    },\n\n    /**\n     * Returns the stack index for the given dataset based on groups and bar visibility.\n     * @param {number} [datasetIndex] - The dataset index\n     * @param {string} [name] - The stack name to find\n     * @returns {number} The stack index\n     * @private\n     */\n    getStackIndex: function (datasetIndex, name) {\n      var stacks = this._getStacks(datasetIndex);\n\n      var index = name !== undefined ? stacks.indexOf(name) : -1; // indexOf returns -1 if element is not present\n\n      return index === -1 ? stacks.length - 1 : index;\n    },\n\n    /**\n     * @private\n     */\n    getRuler: function () {\n      var me = this;\n\n      var scale = me._getIndexScale();\n\n      var pixels = [];\n      var i, ilen;\n\n      for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\n        pixels.push(scale.getPixelForValue(null, i, me.index));\n      }\n\n      return {\n        pixels: pixels,\n        start: scale._startPixel,\n        end: scale._endPixel,\n        stackCount: me.getStackCount(),\n        scale: scale\n      };\n    },\n\n    /**\n     * Note: pixel values are not clamped to the scale area.\n     * @private\n     */\n    calculateBarValuePixels: function (datasetIndex, index, options) {\n      var me = this;\n      var chart = me.chart;\n\n      var scale = me._getValueScale();\n\n      var isHorizontal = scale.isHorizontal();\n      var datasets = chart.data.datasets;\n\n      var metasets = scale._getMatchingVisibleMetas(me._type);\n\n      var value = scale._parseValue(datasets[datasetIndex].data[index]);\n\n      var minBarLength = options.minBarLength;\n      var stacked = scale.options.stacked;\n      var stack = me.getMeta().stack;\n      var start = value.start === undefined ? 0 : value.max >= 0 && value.min >= 0 ? value.min : value.max;\n      var length = value.start === undefined ? value.end : value.max >= 0 && value.min >= 0 ? value.max - value.min : value.min - value.max;\n      var ilen = metasets.length;\n      var i, imeta, ivalue, base, head, size, stackLength;\n\n      if (stacked || stacked === undefined && stack !== undefined) {\n        for (i = 0; i < ilen; ++i) {\n          imeta = metasets[i];\n\n          if (imeta.index === datasetIndex) {\n            break;\n          }\n\n          if (imeta.stack === stack) {\n            stackLength = scale._parseValue(datasets[imeta.index].data[index]);\n            ivalue = stackLength.start === undefined ? stackLength.end : stackLength.min >= 0 && stackLength.max >= 0 ? stackLength.max : stackLength.min;\n\n            if (value.min < 0 && ivalue < 0 || value.max >= 0 && ivalue > 0) {\n              start += ivalue;\n            }\n          }\n        }\n      }\n\n      base = scale.getPixelForValue(start);\n      head = scale.getPixelForValue(start + length);\n      size = head - base;\n\n      if (minBarLength !== undefined && Math.abs(size) < minBarLength) {\n        size = minBarLength;\n\n        if (length >= 0 && !isHorizontal || length < 0 && isHorizontal) {\n          head = base - minBarLength;\n        } else {\n          head = base + minBarLength;\n        }\n      }\n\n      return {\n        size: size,\n        base: base,\n        head: head,\n        center: head + size / 2\n      };\n    },\n\n    /**\n     * @private\n     */\n    calculateBarIndexPixels: function (datasetIndex, index, ruler, options) {\n      var me = this;\n      var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);\n      var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\n      var center = range.start + range.chunk * stackIndex + range.chunk / 2;\n      var size = Math.min(valueOrDefault$3(options.maxBarThickness, Infinity), range.chunk * range.ratio);\n      return {\n        base: center - size / 2,\n        head: center + size / 2,\n        center: center,\n        size: size\n      };\n    },\n    draw: function () {\n      var me = this;\n      var chart = me.chart;\n\n      var scale = me._getValueScale();\n\n      var rects = me.getMeta().data;\n      var dataset = me.getDataset();\n      var ilen = rects.length;\n      var i = 0;\n      helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);\n\n      for (; i < ilen; ++i) {\n        var val = scale._parseValue(dataset.data[i]);\n\n        if (!isNaN(val.min) && !isNaN(val.max)) {\n          rects[i].draw();\n        }\n      }\n\n      helpers$1.canvas.unclipArea(chart.ctx);\n    },\n\n    /**\n     * @private\n     */\n    _resolveDataElementOptions: function () {\n      var me = this;\n      var values = helpers$1.extend({}, core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments));\n\n      var indexOpts = me._getIndexScale().options;\n\n      var valueOpts = me._getValueScale().options;\n\n      values.barPercentage = valueOrDefault$3(indexOpts.barPercentage, values.barPercentage);\n      values.barThickness = valueOrDefault$3(indexOpts.barThickness, values.barThickness);\n      values.categoryPercentage = valueOrDefault$3(indexOpts.categoryPercentage, values.categoryPercentage);\n      values.maxBarThickness = valueOrDefault$3(indexOpts.maxBarThickness, values.maxBarThickness);\n      values.minBarLength = valueOrDefault$3(valueOpts.minBarLength, values.minBarLength);\n      return values;\n    }\n  });\n  var valueOrDefault$4 = helpers$1.valueOrDefault;\n  var resolve$1 = helpers$1.options.resolve;\n\n  core_defaults._set('bubble', {\n    hover: {\n      mode: 'single'\n    },\n    scales: {\n      xAxes: [{\n        type: 'linear',\n        // bubble should probably use a linear scale by default\n        position: 'bottom',\n        id: 'x-axis-0' // need an ID so datasets can reference the scale\n\n      }],\n      yAxes: [{\n        type: 'linear',\n        position: 'left',\n        id: 'y-axis-0'\n      }]\n    },\n    tooltips: {\n      callbacks: {\n        title: function () {\n          // Title doesn't make sense for scatter since we format the data as a point\n          return '';\n        },\n        label: function (item, data) {\n          var datasetLabel = data.datasets[item.datasetIndex].label || '';\n          var dataPoint = data.datasets[item.datasetIndex].data[item.index];\n          return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';\n        }\n      }\n    }\n  });\n\n  var controller_bubble = core_datasetController.extend({\n    /**\n     * @protected\n     */\n    dataElementType: elements.Point,\n\n    /**\n     * @private\n     */\n    _dataElementOptions: ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle', 'rotation'],\n\n    /**\n     * @protected\n     */\n    update: function (reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var points = meta.data; // Update Points\n\n      helpers$1.each(points, function (point, index) {\n        me.updateElement(point, index, reset);\n      });\n    },\n\n    /**\n     * @protected\n     */\n    updateElement: function (point, index, reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var custom = point.custom || {};\n      var xScale = me.getScaleForId(meta.xAxisID);\n      var yScale = me.getScaleForId(meta.yAxisID);\n\n      var options = me._resolveDataElementOptions(point, index);\n\n      var data = me.getDataset().data[index];\n      var dsIndex = me.index;\n      var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);\n      var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);\n      point._xScale = xScale;\n      point._yScale = yScale;\n      point._options = options;\n      point._datasetIndex = dsIndex;\n      point._index = index;\n      point._model = {\n        backgroundColor: options.backgroundColor,\n        borderColor: options.borderColor,\n        borderWidth: options.borderWidth,\n        hitRadius: options.hitRadius,\n        pointStyle: options.pointStyle,\n        rotation: options.rotation,\n        radius: reset ? 0 : options.radius,\n        skip: custom.skip || isNaN(x) || isNaN(y),\n        x: x,\n        y: y\n      };\n      point.pivot();\n    },\n\n    /**\n     * @protected\n     */\n    setHoverStyle: function (point) {\n      var model = point._model;\n      var options = point._options;\n      var getHoverColor = helpers$1.getHoverColor;\n      point.$previousStyle = {\n        backgroundColor: model.backgroundColor,\n        borderColor: model.borderColor,\n        borderWidth: model.borderWidth,\n        radius: model.radius\n      };\n      model.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n      model.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));\n      model.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);\n      model.radius = options.radius + options.hoverRadius;\n    },\n\n    /**\n     * @private\n     */\n    _resolveDataElementOptions: function (point, index) {\n      var me = this;\n      var chart = me.chart;\n      var dataset = me.getDataset();\n      var custom = point.custom || {};\n      var data = dataset.data[index] || {};\n\n      var values = core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments); // Scriptable options\n\n\n      var context = {\n        chart: chart,\n        dataIndex: index,\n        dataset: dataset,\n        datasetIndex: me.index\n      }; // In case values were cached (and thus frozen), we need to clone the values\n\n      if (me._cachedDataOpts === values) {\n        values = helpers$1.extend({}, values);\n      } // Custom radius resolution\n\n\n      values.radius = resolve$1([custom.radius, data.r, me._config.radius, chart.options.elements.point.radius], context, index);\n      return values;\n    }\n  });\n  var valueOrDefault$5 = helpers$1.valueOrDefault;\n  var PI$1 = Math.PI;\n  var DOUBLE_PI$1 = PI$1 * 2;\n  var HALF_PI$1 = PI$1 / 2;\n\n  core_defaults._set('doughnut', {\n    animation: {\n      // Boolean - Whether we animate the rotation of the Doughnut\n      animateRotate: true,\n      // Boolean - Whether we animate scaling the Doughnut from the centre\n      animateScale: false\n    },\n    hover: {\n      mode: 'single'\n    },\n    legendCallback: function (chart) {\n      var list = document.createElement('ul');\n      var data = chart.data;\n      var datasets = data.datasets;\n      var labels = data.labels;\n      var i, ilen, listItem, listItemSpan;\n      list.setAttribute('class', chart.id + '-legend');\n\n      if (datasets.length) {\n        for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {\n          listItem = list.appendChild(document.createElement('li'));\n          listItemSpan = listItem.appendChild(document.createElement('span'));\n          listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];\n\n          if (labels[i]) {\n            listItem.appendChild(document.createTextNode(labels[i]));\n          }\n        }\n      }\n\n      return list.outerHTML;\n    },\n    legend: {\n      labels: {\n        generateLabels: function (chart) {\n          var data = chart.data;\n\n          if (data.labels.length && data.datasets.length) {\n            return data.labels.map(function (label, i) {\n              var meta = chart.getDatasetMeta(0);\n              var style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,\n                // Extra data used for toggling the correct item\n                index: i\n              };\n            });\n          }\n\n          return [];\n        }\n      },\n      onClick: function (e, legendItem) {\n        var index = legendItem.index;\n        var chart = this.chart;\n        var i, ilen, meta;\n\n        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n          meta = chart.getDatasetMeta(i); // toggle visibility of index if exists\n\n          if (meta.data[index]) {\n            meta.data[index].hidden = !meta.data[index].hidden;\n          }\n        }\n\n        chart.update();\n      }\n    },\n    // The percentage of the chart that we cut out of the middle.\n    cutoutPercentage: 50,\n    // The rotation of the chart, where the first data arc begins.\n    rotation: -HALF_PI$1,\n    // The total circumference of the chart.\n    circumference: DOUBLE_PI$1,\n    // Need to override these to give a nice default\n    tooltips: {\n      callbacks: {\n        title: function () {\n          return '';\n        },\n        label: function (tooltipItem, data) {\n          var dataLabel = data.labels[tooltipItem.index];\n          var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\n          if (helpers$1.isArray(dataLabel)) {\n            // show value on first line of multiline label\n            // need to clone because we are changing the value\n            dataLabel = dataLabel.slice();\n            dataLabel[0] += value;\n          } else {\n            dataLabel += value;\n          }\n\n          return dataLabel;\n        }\n      }\n    }\n  });\n\n  var controller_doughnut = core_datasetController.extend({\n    dataElementType: elements.Arc,\n    linkScales: helpers$1.noop,\n\n    /**\n     * @private\n     */\n    _dataElementOptions: ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'],\n    // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\n    getRingIndex: function (datasetIndex) {\n      var ringIndex = 0;\n\n      for (var j = 0; j < datasetIndex; ++j) {\n        if (this.chart.isDatasetVisible(j)) {\n          ++ringIndex;\n        }\n      }\n\n      return ringIndex;\n    },\n    update: function (reset) {\n      var me = this;\n      var chart = me.chart;\n      var chartArea = chart.chartArea;\n      var opts = chart.options;\n      var ratioX = 1;\n      var ratioY = 1;\n      var offsetX = 0;\n      var offsetY = 0;\n      var meta = me.getMeta();\n      var arcs = meta.data;\n      var cutout = opts.cutoutPercentage / 100 || 0;\n      var circumference = opts.circumference;\n\n      var chartWeight = me._getRingWeight(me.index);\n\n      var maxWidth, maxHeight, i, ilen; // If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc\n\n      if (circumference < DOUBLE_PI$1) {\n        var startAngle = opts.rotation % DOUBLE_PI$1;\n        startAngle += startAngle >= PI$1 ? -DOUBLE_PI$1 : startAngle < -PI$1 ? DOUBLE_PI$1 : 0;\n        var endAngle = startAngle + circumference;\n        var startX = Math.cos(startAngle);\n        var startY = Math.sin(startAngle);\n        var endX = Math.cos(endAngle);\n        var endY = Math.sin(endAngle);\n        var contains0 = startAngle <= 0 && endAngle >= 0 || endAngle >= DOUBLE_PI$1;\n        var contains90 = startAngle <= HALF_PI$1 && endAngle >= HALF_PI$1 || endAngle >= DOUBLE_PI$1 + HALF_PI$1;\n        var contains180 = startAngle === -PI$1 || endAngle >= PI$1;\n        var contains270 = startAngle <= -HALF_PI$1 && endAngle >= -HALF_PI$1 || endAngle >= PI$1 + HALF_PI$1;\n        var minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);\n        var minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);\n        var maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);\n        var maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);\n        ratioX = (maxX - minX) / 2;\n        ratioY = (maxY - minY) / 2;\n        offsetX = -(maxX + minX) / 2;\n        offsetY = -(maxY + minY) / 2;\n      }\n\n      for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n        arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);\n      }\n\n      chart.borderWidth = me.getMaxBorderWidth();\n      maxWidth = (chartArea.right - chartArea.left - chart.borderWidth) / ratioX;\n      maxHeight = (chartArea.bottom - chartArea.top - chart.borderWidth) / ratioY;\n      chart.outerRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n      chart.innerRadius = Math.max(chart.outerRadius * cutout, 0);\n      chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);\n      chart.offsetX = offsetX * chart.outerRadius;\n      chart.offsetY = offsetY * chart.outerRadius;\n      meta.total = me.calculateTotal();\n      me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);\n      me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);\n\n      for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n        me.updateElement(arcs[i], i, reset);\n      }\n    },\n    updateElement: function (arc, index, reset) {\n      var me = this;\n      var chart = me.chart;\n      var chartArea = chart.chartArea;\n      var opts = chart.options;\n      var animationOpts = opts.animation;\n      var centerX = (chartArea.left + chartArea.right) / 2;\n      var centerY = (chartArea.top + chartArea.bottom) / 2;\n      var startAngle = opts.rotation; // non reset case handled later\n\n      var endAngle = opts.rotation; // non reset case handled later\n\n      var dataset = me.getDataset();\n      var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / DOUBLE_PI$1);\n      var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;\n      var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;\n      var options = arc._options || {};\n      helpers$1.extend(arc, {\n        // Utility\n        _datasetIndex: me.index,\n        _index: index,\n        // Desired view properties\n        _model: {\n          backgroundColor: options.backgroundColor,\n          borderColor: options.borderColor,\n          borderWidth: options.borderWidth,\n          borderAlign: options.borderAlign,\n          x: centerX + chart.offsetX,\n          y: centerY + chart.offsetY,\n          startAngle: startAngle,\n          endAngle: endAngle,\n          circumference: circumference,\n          outerRadius: outerRadius,\n          innerRadius: innerRadius,\n          label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\n        }\n      });\n      var model = arc._model; // Set correct angles if not resetting\n\n      if (!reset || !animationOpts.animateRotate) {\n        if (index === 0) {\n          model.startAngle = opts.rotation;\n        } else {\n          model.startAngle = me.getMeta().data[index - 1]._model.endAngle;\n        }\n\n        model.endAngle = model.startAngle + model.circumference;\n      }\n\n      arc.pivot();\n    },\n    calculateTotal: function () {\n      var dataset = this.getDataset();\n      var meta = this.getMeta();\n      var total = 0;\n      var value;\n      helpers$1.each(meta.data, function (element, index) {\n        value = dataset.data[index];\n\n        if (!isNaN(value) && !element.hidden) {\n          total += Math.abs(value);\n        }\n      });\n      /* if (total === 0) {\n      \ttotal = NaN;\n      }*/\n\n      return total;\n    },\n    calculateCircumference: function (value) {\n      var total = this.getMeta().total;\n\n      if (total > 0 && !isNaN(value)) {\n        return DOUBLE_PI$1 * (Math.abs(value) / total);\n      }\n\n      return 0;\n    },\n    // gets the max border or hover width to properly scale pie charts\n    getMaxBorderWidth: function (arcs) {\n      var me = this;\n      var max = 0;\n      var chart = me.chart;\n      var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;\n\n      if (!arcs) {\n        // Find the outmost visible dataset\n        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n          if (chart.isDatasetVisible(i)) {\n            meta = chart.getDatasetMeta(i);\n            arcs = meta.data;\n\n            if (i !== me.index) {\n              controller = meta.controller;\n            }\n\n            break;\n          }\n        }\n      }\n\n      if (!arcs) {\n        return 0;\n      }\n\n      for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n        arc = arcs[i];\n\n        if (controller) {\n          controller._configure();\n\n          options = controller._resolveDataElementOptions(arc, i);\n        } else {\n          options = arc._options;\n        }\n\n        if (options.borderAlign !== 'inner') {\n          borderWidth = options.borderWidth;\n          hoverWidth = options.hoverBorderWidth;\n          max = borderWidth > max ? borderWidth : max;\n          max = hoverWidth > max ? hoverWidth : max;\n        }\n      }\n\n      return max;\n    },\n\n    /**\n     * @protected\n     */\n    setHoverStyle: function (arc) {\n      var model = arc._model;\n      var options = arc._options;\n      var getHoverColor = helpers$1.getHoverColor;\n      arc.$previousStyle = {\n        backgroundColor: model.backgroundColor,\n        borderColor: model.borderColor,\n        borderWidth: model.borderWidth\n      };\n      model.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n      model.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));\n      model.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);\n    },\n\n    /**\n     * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\n     * @private\n     */\n    _getRingWeightOffset: function (datasetIndex) {\n      var ringWeightOffset = 0;\n\n      for (var i = 0; i < datasetIndex; ++i) {\n        if (this.chart.isDatasetVisible(i)) {\n          ringWeightOffset += this._getRingWeight(i);\n        }\n      }\n\n      return ringWeightOffset;\n    },\n\n    /**\n     * @private\n     */\n    _getRingWeight: function (dataSetIndex) {\n      return Math.max(valueOrDefault$5(this.chart.data.datasets[dataSetIndex].weight, 1), 0);\n    },\n\n    /**\n     * Returns the sum of all visibile data set weights.  This value can be 0.\n     * @private\n     */\n    _getVisibleDatasetWeightTotal: function () {\n      return this._getRingWeightOffset(this.chart.data.datasets.length);\n    }\n  });\n\n  core_defaults._set('horizontalBar', {\n    hover: {\n      mode: 'index',\n      axis: 'y'\n    },\n    scales: {\n      xAxes: [{\n        type: 'linear',\n        position: 'bottom'\n      }],\n      yAxes: [{\n        type: 'category',\n        position: 'left',\n        offset: true,\n        gridLines: {\n          offsetGridLines: true\n        }\n      }]\n    },\n    elements: {\n      rectangle: {\n        borderSkipped: 'left'\n      }\n    },\n    tooltips: {\n      mode: 'index',\n      axis: 'y'\n    }\n  });\n\n  core_defaults._set('global', {\n    datasets: {\n      horizontalBar: {\n        categoryPercentage: 0.8,\n        barPercentage: 0.9\n      }\n    }\n  });\n\n  var controller_horizontalBar = controller_bar.extend({\n    /**\n     * @private\n     */\n    _getValueScaleId: function () {\n      return this.getMeta().xAxisID;\n    },\n\n    /**\n     * @private\n     */\n    _getIndexScaleId: function () {\n      return this.getMeta().yAxisID;\n    }\n  });\n  var valueOrDefault$6 = helpers$1.valueOrDefault;\n  var resolve$2 = helpers$1.options.resolve;\n  var isPointInArea = helpers$1.canvas._isPointInArea;\n\n  core_defaults._set('line', {\n    showLines: true,\n    spanGaps: false,\n    hover: {\n      mode: 'label'\n    },\n    scales: {\n      xAxes: [{\n        type: 'category',\n        id: 'x-axis-0'\n      }],\n      yAxes: [{\n        type: 'linear',\n        id: 'y-axis-0'\n      }]\n    }\n  });\n\n  function scaleClip(scale, halfBorderWidth) {\n    var tickOpts = scale && scale.options.ticks || {};\n    var reverse = tickOpts.reverse;\n    var min = tickOpts.min === undefined ? halfBorderWidth : 0;\n    var max = tickOpts.max === undefined ? halfBorderWidth : 0;\n    return {\n      start: reverse ? max : min,\n      end: reverse ? min : max\n    };\n  }\n\n  function defaultClip(xScale, yScale, borderWidth) {\n    var halfBorderWidth = borderWidth / 2;\n    var x = scaleClip(xScale, halfBorderWidth);\n    var y = scaleClip(yScale, halfBorderWidth);\n    return {\n      top: y.end,\n      right: x.end,\n      bottom: y.start,\n      left: x.start\n    };\n  }\n\n  function toClip(value) {\n    var t, r, b, l;\n\n    if (helpers$1.isObject(value)) {\n      t = value.top;\n      r = value.right;\n      b = value.bottom;\n      l = value.left;\n    } else {\n      t = r = b = l = value;\n    }\n\n    return {\n      top: t,\n      right: r,\n      bottom: b,\n      left: l\n    };\n  }\n\n  var controller_line = core_datasetController.extend({\n    datasetElementType: elements.Line,\n    dataElementType: elements.Point,\n\n    /**\n     * @private\n     */\n    _datasetElementOptions: ['backgroundColor', 'borderCapStyle', 'borderColor', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'borderWidth', 'cubicInterpolationMode', 'fill'],\n\n    /**\n     * @private\n     */\n    _dataElementOptions: {\n      backgroundColor: 'pointBackgroundColor',\n      borderColor: 'pointBorderColor',\n      borderWidth: 'pointBorderWidth',\n      hitRadius: 'pointHitRadius',\n      hoverBackgroundColor: 'pointHoverBackgroundColor',\n      hoverBorderColor: 'pointHoverBorderColor',\n      hoverBorderWidth: 'pointHoverBorderWidth',\n      hoverRadius: 'pointHoverRadius',\n      pointStyle: 'pointStyle',\n      radius: 'pointRadius',\n      rotation: 'pointRotation'\n    },\n    update: function (reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var line = meta.dataset;\n      var points = meta.data || [];\n      var options = me.chart.options;\n      var config = me._config;\n      var showLine = me._showLine = valueOrDefault$6(config.showLine, options.showLines);\n      var i, ilen;\n      me._xScale = me.getScaleForId(meta.xAxisID);\n      me._yScale = me.getScaleForId(meta.yAxisID); // Update Line\n\n      if (showLine) {\n        // Compatibility: If the properties are defined with only the old name, use those values\n        if (config.tension !== undefined && config.lineTension === undefined) {\n          config.lineTension = config.tension;\n        } // Utility\n\n\n        line._scale = me._yScale;\n        line._datasetIndex = me.index; // Data\n\n        line._children = points; // Model\n\n        line._model = me._resolveDatasetElementOptions(line);\n        line.pivot();\n      } // Update Points\n\n\n      for (i = 0, ilen = points.length; i < ilen; ++i) {\n        me.updateElement(points[i], i, reset);\n      }\n\n      if (showLine && line._model.tension !== 0) {\n        me.updateBezierControlPoints();\n      } // Now pivot the point for animation\n\n\n      for (i = 0, ilen = points.length; i < ilen; ++i) {\n        points[i].pivot();\n      }\n    },\n    updateElement: function (point, index, reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var custom = point.custom || {};\n      var dataset = me.getDataset();\n      var datasetIndex = me.index;\n      var value = dataset.data[index];\n      var xScale = me._xScale;\n      var yScale = me._yScale;\n      var lineModel = meta.dataset._model;\n      var x, y;\n\n      var options = me._resolveDataElementOptions(point, index);\n\n      x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);\n      y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex); // Utility\n\n      point._xScale = xScale;\n      point._yScale = yScale;\n      point._options = options;\n      point._datasetIndex = datasetIndex;\n      point._index = index; // Desired view properties\n\n      point._model = {\n        x: x,\n        y: y,\n        skip: custom.skip || isNaN(x) || isNaN(y),\n        // Appearance\n        radius: options.radius,\n        pointStyle: options.pointStyle,\n        rotation: options.rotation,\n        backgroundColor: options.backgroundColor,\n        borderColor: options.borderColor,\n        borderWidth: options.borderWidth,\n        tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),\n        steppedLine: lineModel ? lineModel.steppedLine : false,\n        // Tooltip\n        hitRadius: options.hitRadius\n      };\n    },\n\n    /**\n     * @private\n     */\n    _resolveDatasetElementOptions: function (element) {\n      var me = this;\n      var config = me._config;\n      var custom = element.custom || {};\n      var options = me.chart.options;\n      var lineOptions = options.elements.line;\n\n      var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments); // The default behavior of lines is to break at null values, according\n      // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n      // This option gives lines the ability to span gaps\n\n\n      values.spanGaps = valueOrDefault$6(config.spanGaps, options.spanGaps);\n      values.tension = valueOrDefault$6(config.lineTension, lineOptions.tension);\n      values.steppedLine = resolve$2([custom.steppedLine, config.steppedLine, lineOptions.stepped]);\n      values.clip = toClip(valueOrDefault$6(config.clip, defaultClip(me._xScale, me._yScale, values.borderWidth)));\n      return values;\n    },\n    calculatePointY: function (value, index, datasetIndex) {\n      var me = this;\n      var chart = me.chart;\n      var yScale = me._yScale;\n      var sumPos = 0;\n      var sumNeg = 0;\n      var i, ds, dsMeta, stackedRightValue, rightValue, metasets, ilen;\n\n      if (yScale.options.stacked) {\n        rightValue = +yScale.getRightValue(value);\n        metasets = chart._getSortedVisibleDatasetMetas();\n        ilen = metasets.length;\n\n        for (i = 0; i < ilen; ++i) {\n          dsMeta = metasets[i];\n\n          if (dsMeta.index === datasetIndex) {\n            break;\n          }\n\n          ds = chart.data.datasets[dsMeta.index];\n\n          if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id) {\n            stackedRightValue = +yScale.getRightValue(ds.data[index]);\n\n            if (stackedRightValue < 0) {\n              sumNeg += stackedRightValue || 0;\n            } else {\n              sumPos += stackedRightValue || 0;\n            }\n          }\n        }\n\n        if (rightValue < 0) {\n          return yScale.getPixelForValue(sumNeg + rightValue);\n        }\n\n        return yScale.getPixelForValue(sumPos + rightValue);\n      }\n\n      return yScale.getPixelForValue(value);\n    },\n    updateBezierControlPoints: function () {\n      var me = this;\n      var chart = me.chart;\n      var meta = me.getMeta();\n      var lineModel = meta.dataset._model;\n      var area = chart.chartArea;\n      var points = meta.data || [];\n      var i, ilen, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used\n\n      if (lineModel.spanGaps) {\n        points = points.filter(function (pt) {\n          return !pt._model.skip;\n        });\n      }\n\n      function capControlPoint(pt, min, max) {\n        return Math.max(Math.min(pt, max), min);\n      }\n\n      if (lineModel.cubicInterpolationMode === 'monotone') {\n        helpers$1.splineCurveMonotone(points);\n      } else {\n        for (i = 0, ilen = points.length; i < ilen; ++i) {\n          model = points[i]._model;\n          controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);\n          model.controlPointPreviousX = controlPoints.previous.x;\n          model.controlPointPreviousY = controlPoints.previous.y;\n          model.controlPointNextX = controlPoints.next.x;\n          model.controlPointNextY = controlPoints.next.y;\n        }\n      }\n\n      if (chart.options.elements.line.capBezierPoints) {\n        for (i = 0, ilen = points.length; i < ilen; ++i) {\n          model = points[i]._model;\n\n          if (isPointInArea(model, area)) {\n            if (i > 0 && isPointInArea(points[i - 1]._model, area)) {\n              model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n              model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n            }\n\n            if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {\n              model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n              model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n            }\n          }\n        }\n      }\n    },\n    draw: function () {\n      var me = this;\n      var chart = me.chart;\n      var meta = me.getMeta();\n      var points = meta.data || [];\n      var area = chart.chartArea;\n      var canvas = chart.canvas;\n      var i = 0;\n      var ilen = points.length;\n      var clip;\n\n      if (me._showLine) {\n        clip = meta.dataset._model.clip;\n        helpers$1.canvas.clipArea(chart.ctx, {\n          left: clip.left === false ? 0 : area.left - clip.left,\n          right: clip.right === false ? canvas.width : area.right + clip.right,\n          top: clip.top === false ? 0 : area.top - clip.top,\n          bottom: clip.bottom === false ? canvas.height : area.bottom + clip.bottom\n        });\n        meta.dataset.draw();\n        helpers$1.canvas.unclipArea(chart.ctx);\n      } // Draw the points\n\n\n      for (; i < ilen; ++i) {\n        points[i].draw(area);\n      }\n    },\n\n    /**\n     * @protected\n     */\n    setHoverStyle: function (point) {\n      var model = point._model;\n      var options = point._options;\n      var getHoverColor = helpers$1.getHoverColor;\n      point.$previousStyle = {\n        backgroundColor: model.backgroundColor,\n        borderColor: model.borderColor,\n        borderWidth: model.borderWidth,\n        radius: model.radius\n      };\n      model.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n      model.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));\n      model.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);\n      model.radius = valueOrDefault$6(options.hoverRadius, options.radius);\n    }\n  });\n  var resolve$3 = helpers$1.options.resolve;\n\n  core_defaults._set('polarArea', {\n    scale: {\n      type: 'radialLinear',\n      angleLines: {\n        display: false\n      },\n      gridLines: {\n        circular: true\n      },\n      pointLabels: {\n        display: false\n      },\n      ticks: {\n        beginAtZero: true\n      }\n    },\n    // Boolean - Whether to animate the rotation of the chart\n    animation: {\n      animateRotate: true,\n      animateScale: true\n    },\n    startAngle: -0.5 * Math.PI,\n    legendCallback: function (chart) {\n      var list = document.createElement('ul');\n      var data = chart.data;\n      var datasets = data.datasets;\n      var labels = data.labels;\n      var i, ilen, listItem, listItemSpan;\n      list.setAttribute('class', chart.id + '-legend');\n\n      if (datasets.length) {\n        for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {\n          listItem = list.appendChild(document.createElement('li'));\n          listItemSpan = listItem.appendChild(document.createElement('span'));\n          listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];\n\n          if (labels[i]) {\n            listItem.appendChild(document.createTextNode(labels[i]));\n          }\n        }\n      }\n\n      return list.outerHTML;\n    },\n    legend: {\n      labels: {\n        generateLabels: function (chart) {\n          var data = chart.data;\n\n          if (data.labels.length && data.datasets.length) {\n            return data.labels.map(function (label, i) {\n              var meta = chart.getDatasetMeta(0);\n              var style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,\n                // Extra data used for toggling the correct item\n                index: i\n              };\n            });\n          }\n\n          return [];\n        }\n      },\n      onClick: function (e, legendItem) {\n        var index = legendItem.index;\n        var chart = this.chart;\n        var i, ilen, meta;\n\n        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n          meta = chart.getDatasetMeta(i);\n          meta.data[index].hidden = !meta.data[index].hidden;\n        }\n\n        chart.update();\n      }\n    },\n    // Need to override these to give a nice default\n    tooltips: {\n      callbacks: {\n        title: function () {\n          return '';\n        },\n        label: function (item, data) {\n          return data.labels[item.index] + ': ' + item.yLabel;\n        }\n      }\n    }\n  });\n\n  var controller_polarArea = core_datasetController.extend({\n    dataElementType: elements.Arc,\n    linkScales: helpers$1.noop,\n\n    /**\n     * @private\n     */\n    _dataElementOptions: ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'],\n\n    /**\n     * @private\n     */\n    _getIndexScaleId: function () {\n      return this.chart.scale.id;\n    },\n\n    /**\n     * @private\n     */\n    _getValueScaleId: function () {\n      return this.chart.scale.id;\n    },\n    update: function (reset) {\n      var me = this;\n      var dataset = me.getDataset();\n      var meta = me.getMeta();\n      var start = me.chart.options.startAngle || 0;\n      var starts = me._starts = [];\n      var angles = me._angles = [];\n      var arcs = meta.data;\n      var i, ilen, angle;\n\n      me._updateRadius();\n\n      meta.count = me.countVisibleElements();\n\n      for (i = 0, ilen = dataset.data.length; i < ilen; i++) {\n        starts[i] = start;\n        angle = me._computeAngle(i);\n        angles[i] = angle;\n        start += angle;\n      }\n\n      for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n        arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);\n        me.updateElement(arcs[i], i, reset);\n      }\n    },\n\n    /**\n     * @private\n     */\n    _updateRadius: function () {\n      var me = this;\n      var chart = me.chart;\n      var chartArea = chart.chartArea;\n      var opts = chart.options;\n      var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n      chart.outerRadius = Math.max(minSize / 2, 0);\n      chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n      chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n      me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;\n      me.innerRadius = me.outerRadius - chart.radiusLength;\n    },\n    updateElement: function (arc, index, reset) {\n      var me = this;\n      var chart = me.chart;\n      var dataset = me.getDataset();\n      var opts = chart.options;\n      var animationOpts = opts.animation;\n      var scale = chart.scale;\n      var labels = chart.data.labels;\n      var centerX = scale.xCenter;\n      var centerY = scale.yCenter; // var negHalfPI = -0.5 * Math.PI;\n\n      var datasetStartAngle = opts.startAngle;\n      var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n      var startAngle = me._starts[index];\n      var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);\n      var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n      var options = arc._options || {};\n      helpers$1.extend(arc, {\n        // Utility\n        _datasetIndex: me.index,\n        _index: index,\n        _scale: scale,\n        // Desired view properties\n        _model: {\n          backgroundColor: options.backgroundColor,\n          borderColor: options.borderColor,\n          borderWidth: options.borderWidth,\n          borderAlign: options.borderAlign,\n          x: centerX,\n          y: centerY,\n          innerRadius: 0,\n          outerRadius: reset ? resetRadius : distance,\n          startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\n          endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\n          label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])\n        }\n      });\n      arc.pivot();\n    },\n    countVisibleElements: function () {\n      var dataset = this.getDataset();\n      var meta = this.getMeta();\n      var count = 0;\n      helpers$1.each(meta.data, function (element, index) {\n        if (!isNaN(dataset.data[index]) && !element.hidden) {\n          count++;\n        }\n      });\n      return count;\n    },\n\n    /**\n     * @protected\n     */\n    setHoverStyle: function (arc) {\n      var model = arc._model;\n      var options = arc._options;\n      var getHoverColor = helpers$1.getHoverColor;\n      var valueOrDefault = helpers$1.valueOrDefault;\n      arc.$previousStyle = {\n        backgroundColor: model.backgroundColor,\n        borderColor: model.borderColor,\n        borderWidth: model.borderWidth\n      };\n      model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n      model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));\n      model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);\n    },\n\n    /**\n     * @private\n     */\n    _computeAngle: function (index) {\n      var me = this;\n      var count = this.getMeta().count;\n      var dataset = me.getDataset();\n      var meta = me.getMeta();\n\n      if (isNaN(dataset.data[index]) || meta.data[index].hidden) {\n        return 0;\n      } // Scriptable options\n\n\n      var context = {\n        chart: me.chart,\n        dataIndex: index,\n        dataset: dataset,\n        datasetIndex: me.index\n      };\n      return resolve$3([me.chart.options.elements.arc.angle, 2 * Math.PI / count], context, index);\n    }\n  });\n\n  core_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));\n\n  core_defaults._set('pie', {\n    cutoutPercentage: 0\n  }); // Pie charts are Doughnut chart with different defaults\n\n\n  var controller_pie = controller_doughnut;\n  var valueOrDefault$7 = helpers$1.valueOrDefault;\n\n  core_defaults._set('radar', {\n    spanGaps: false,\n    scale: {\n      type: 'radialLinear'\n    },\n    elements: {\n      line: {\n        fill: 'start',\n        tension: 0 // no bezier in radar\n\n      }\n    }\n  });\n\n  var controller_radar = core_datasetController.extend({\n    datasetElementType: elements.Line,\n    dataElementType: elements.Point,\n    linkScales: helpers$1.noop,\n\n    /**\n     * @private\n     */\n    _datasetElementOptions: ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill'],\n\n    /**\n     * @private\n     */\n    _dataElementOptions: {\n      backgroundColor: 'pointBackgroundColor',\n      borderColor: 'pointBorderColor',\n      borderWidth: 'pointBorderWidth',\n      hitRadius: 'pointHitRadius',\n      hoverBackgroundColor: 'pointHoverBackgroundColor',\n      hoverBorderColor: 'pointHoverBorderColor',\n      hoverBorderWidth: 'pointHoverBorderWidth',\n      hoverRadius: 'pointHoverRadius',\n      pointStyle: 'pointStyle',\n      radius: 'pointRadius',\n      rotation: 'pointRotation'\n    },\n\n    /**\n     * @private\n     */\n    _getIndexScaleId: function () {\n      return this.chart.scale.id;\n    },\n\n    /**\n     * @private\n     */\n    _getValueScaleId: function () {\n      return this.chart.scale.id;\n    },\n    update: function (reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var line = meta.dataset;\n      var points = meta.data || [];\n      var scale = me.chart.scale;\n      var config = me._config;\n      var i, ilen; // Compatibility: If the properties are defined with only the old name, use those values\n\n      if (config.tension !== undefined && config.lineTension === undefined) {\n        config.lineTension = config.tension;\n      } // Utility\n\n\n      line._scale = scale;\n      line._datasetIndex = me.index; // Data\n\n      line._children = points;\n      line._loop = true; // Model\n\n      line._model = me._resolveDatasetElementOptions(line);\n      line.pivot(); // Update Points\n\n      for (i = 0, ilen = points.length; i < ilen; ++i) {\n        me.updateElement(points[i], i, reset);\n      } // Update bezier control points\n\n\n      me.updateBezierControlPoints(); // Now pivot the point for animation\n\n      for (i = 0, ilen = points.length; i < ilen; ++i) {\n        points[i].pivot();\n      }\n    },\n    updateElement: function (point, index, reset) {\n      var me = this;\n      var custom = point.custom || {};\n      var dataset = me.getDataset();\n      var scale = me.chart.scale;\n      var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\n\n      var options = me._resolveDataElementOptions(point, index);\n\n      var lineModel = me.getMeta().dataset._model;\n\n      var x = reset ? scale.xCenter : pointPosition.x;\n      var y = reset ? scale.yCenter : pointPosition.y; // Utility\n\n      point._scale = scale;\n      point._options = options;\n      point._datasetIndex = me.index;\n      point._index = index; // Desired view properties\n\n      point._model = {\n        x: x,\n        // value not used in dataset scale, but we want a consistent API between scales\n        y: y,\n        skip: custom.skip || isNaN(x) || isNaN(y),\n        // Appearance\n        radius: options.radius,\n        pointStyle: options.pointStyle,\n        rotation: options.rotation,\n        backgroundColor: options.backgroundColor,\n        borderColor: options.borderColor,\n        borderWidth: options.borderWidth,\n        tension: valueOrDefault$7(custom.tension, lineModel ? lineModel.tension : 0),\n        // Tooltip\n        hitRadius: options.hitRadius\n      };\n    },\n\n    /**\n     * @private\n     */\n    _resolveDatasetElementOptions: function () {\n      var me = this;\n      var config = me._config;\n      var options = me.chart.options;\n\n      var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);\n\n      values.spanGaps = valueOrDefault$7(config.spanGaps, options.spanGaps);\n      values.tension = valueOrDefault$7(config.lineTension, options.elements.line.tension);\n      return values;\n    },\n    updateBezierControlPoints: function () {\n      var me = this;\n      var meta = me.getMeta();\n      var area = me.chart.chartArea;\n      var points = meta.data || [];\n      var i, ilen, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used\n\n      if (meta.dataset._model.spanGaps) {\n        points = points.filter(function (pt) {\n          return !pt._model.skip;\n        });\n      }\n\n      function capControlPoint(pt, min, max) {\n        return Math.max(Math.min(pt, max), min);\n      }\n\n      for (i = 0, ilen = points.length; i < ilen; ++i) {\n        model = points[i]._model;\n        controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension); // Prevent the bezier going outside of the bounds of the graph\n\n        model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);\n        model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);\n        model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);\n        model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);\n      }\n    },\n    setHoverStyle: function (point) {\n      var model = point._model;\n      var options = point._options;\n      var getHoverColor = helpers$1.getHoverColor;\n      point.$previousStyle = {\n        backgroundColor: model.backgroundColor,\n        borderColor: model.borderColor,\n        borderWidth: model.borderWidth,\n        radius: model.radius\n      };\n      model.backgroundColor = valueOrDefault$7(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n      model.borderColor = valueOrDefault$7(options.hoverBorderColor, getHoverColor(options.borderColor));\n      model.borderWidth = valueOrDefault$7(options.hoverBorderWidth, options.borderWidth);\n      model.radius = valueOrDefault$7(options.hoverRadius, options.radius);\n    }\n  });\n\n  core_defaults._set('scatter', {\n    hover: {\n      mode: 'single'\n    },\n    scales: {\n      xAxes: [{\n        id: 'x-axis-1',\n        // need an ID so datasets can reference the scale\n        type: 'linear',\n        // scatter should not use a category axis\n        position: 'bottom'\n      }],\n      yAxes: [{\n        id: 'y-axis-1',\n        type: 'linear',\n        position: 'left'\n      }]\n    },\n    tooltips: {\n      callbacks: {\n        title: function () {\n          return ''; // doesn't make sense for scatter since data are formatted as a point\n        },\n        label: function (item) {\n          return '(' + item.xLabel + ', ' + item.yLabel + ')';\n        }\n      }\n    }\n  });\n\n  core_defaults._set('global', {\n    datasets: {\n      scatter: {\n        showLine: false\n      }\n    }\n  }); // Scatter charts use line controllers\n\n\n  var controller_scatter = controller_line; // NOTE export a map in which the key represents the controller type, not\n  // the class, and so must be CamelCase in order to be correctly retrieved\n  // by the controller in core.controller.js (`controllers[meta.type]`).\n\n  var controllers = {\n    bar: controller_bar,\n    bubble: controller_bubble,\n    doughnut: controller_doughnut,\n    horizontalBar: controller_horizontalBar,\n    line: controller_line,\n    polarArea: controller_polarArea,\n    pie: controller_pie,\n    radar: controller_radar,\n    scatter: controller_scatter\n  };\n  /**\n   * Helper function to get relative position for an event\n   * @param {Event|IEvent} event - The event to get the position for\n   * @param {Chart} chart - The chart\n   * @returns {object} the event position\n   */\n\n  function getRelativePosition(e, chart) {\n    if (e.native) {\n      return {\n        x: e.x,\n        y: e.y\n      };\n    }\n\n    return helpers$1.getRelativePosition(e, chart);\n  }\n  /**\n   * Helper function to traverse all of the visible elements in the chart\n   * @param {Chart} chart - the chart\n   * @param {function} handler - the callback to execute for each visible item\n   */\n\n\n  function parseVisibleItems(chart, handler) {\n    var metasets = chart._getSortedVisibleDatasetMetas();\n\n    var metadata, i, j, ilen, jlen, element;\n\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      metadata = metasets[i].data;\n\n      for (j = 0, jlen = metadata.length; j < jlen; ++j) {\n        element = metadata[j];\n\n        if (!element._view.skip) {\n          handler(element);\n        }\n      }\n    }\n  }\n  /**\n   * Helper function to get the items that intersect the event position\n   * @param {ChartElement[]} items - elements to filter\n   * @param {object} position - the point to be nearest to\n   * @return {ChartElement[]} the nearest items\n   */\n\n\n  function getIntersectItems(chart, position) {\n    var elements = [];\n    parseVisibleItems(chart, function (element) {\n      if (element.inRange(position.x, position.y)) {\n        elements.push(element);\n      }\n    });\n    return elements;\n  }\n  /**\n   * Helper function to get the items nearest to the event position considering all visible items in teh chart\n   * @param {Chart} chart - the chart to look at elements from\n   * @param {object} position - the point to be nearest to\n   * @param {boolean} intersect - if true, only consider items that intersect the position\n   * @param {function} distanceMetric - function to provide the distance between points\n   * @return {ChartElement[]} the nearest items\n   */\n\n\n  function getNearestItems(chart, position, intersect, distanceMetric) {\n    var minDistance = Number.POSITIVE_INFINITY;\n    var nearestItems = [];\n    parseVisibleItems(chart, function (element) {\n      if (intersect && !element.inRange(position.x, position.y)) {\n        return;\n      }\n\n      var center = element.getCenterPoint();\n      var distance = distanceMetric(position, center);\n\n      if (distance < minDistance) {\n        nearestItems = [element];\n        minDistance = distance;\n      } else if (distance === minDistance) {\n        // Can have multiple items at the same distance in which case we sort by size\n        nearestItems.push(element);\n      }\n    });\n    return nearestItems;\n  }\n  /**\n   * Get a distance metric function for two points based on the\n   * axis mode setting\n   * @param {string} axis - the axis mode. x|y|xy\n   */\n\n\n  function getDistanceMetricForAxis(axis) {\n    var useX = axis.indexOf('x') !== -1;\n    var useY = axis.indexOf('y') !== -1;\n    return function (pt1, pt2) {\n      var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n      var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n    };\n  }\n\n  function indexMode(chart, e, options) {\n    var position = getRelativePosition(e, chart); // Default axis for index mode is 'x' to match old behaviour\n\n    options.axis = options.axis || 'x';\n    var distanceMetric = getDistanceMetricForAxis(options.axis);\n    var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n    var elements = [];\n\n    if (!items.length) {\n      return [];\n    }\n\n    chart._getSortedVisibleDatasetMetas().forEach(function (meta) {\n      var element = meta.data[items[0]._index]; // don't count items that are skipped (null data)\n\n      if (element && !element._view.skip) {\n        elements.push(element);\n      }\n    });\n\n    return elements;\n  }\n  /**\n   * @interface IInteractionOptions\n   */\n\n  /**\n   * If true, only consider items that intersect the point\n   * @name IInterfaceOptions#boolean\n   * @type Boolean\n   */\n\n  /**\n   * Contains interaction related functions\n   * @namespace Chart.Interaction\n   */\n\n\n  var core_interaction = {\n    // Helper function for different modes\n    modes: {\n      single: function (chart, e) {\n        var position = getRelativePosition(e, chart);\n        var elements = [];\n        parseVisibleItems(chart, function (element) {\n          if (element.inRange(position.x, position.y)) {\n            elements.push(element);\n            return elements;\n          }\n        });\n        return elements.slice(0, 1);\n      },\n\n      /**\n       * @function Chart.Interaction.modes.label\n       * @deprecated since version 2.4.0\n       * @todo remove at version 3\n       * @private\n       */\n      label: indexMode,\n\n      /**\n       * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n       * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n       * @function Chart.Interaction.modes.index\n       * @since v2.4.0\n       * @param {Chart} chart - the chart we are returning items from\n       * @param {Event} e - the event we are find things at\n       * @param {IInteractionOptions} options - options to use during interaction\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n      index: indexMode,\n\n      /**\n       * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n       * If the options.intersect is false, we find the nearest item and return the items in that dataset\n       * @function Chart.Interaction.modes.dataset\n       * @param {Chart} chart - the chart we are returning items from\n       * @param {Event} e - the event we are find things at\n       * @param {IInteractionOptions} options - options to use during interaction\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n      dataset: function (chart, e, options) {\n        var position = getRelativePosition(e, chart);\n        options.axis = options.axis || 'xy';\n        var distanceMetric = getDistanceMetricForAxis(options.axis);\n        var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\n        if (items.length > 0) {\n          items = chart.getDatasetMeta(items[0]._datasetIndex).data;\n        }\n\n        return items;\n      },\n\n      /**\n       * @function Chart.Interaction.modes.x-axis\n       * @deprecated since version 2.4.0. Use index mode and intersect == true\n       * @todo remove at version 3\n       * @private\n       */\n      'x-axis': function (chart, e) {\n        return indexMode(chart, e, {\n          intersect: false\n        });\n      },\n\n      /**\n       * Point mode returns all elements that hit test based on the event position\n       * of the event\n       * @function Chart.Interaction.modes.intersect\n       * @param {Chart} chart - the chart we are returning items from\n       * @param {Event} e - the event we are find things at\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n      point: function (chart, e) {\n        var position = getRelativePosition(e, chart);\n        return getIntersectItems(chart, position);\n      },\n\n      /**\n       * nearest mode returns the element closest to the point\n       * @function Chart.Interaction.modes.intersect\n       * @param {Chart} chart - the chart we are returning items from\n       * @param {Event} e - the event we are find things at\n       * @param {IInteractionOptions} options - options to use\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n      nearest: function (chart, e, options) {\n        var position = getRelativePosition(e, chart);\n        options.axis = options.axis || 'xy';\n        var distanceMetric = getDistanceMetricForAxis(options.axis);\n        return getNearestItems(chart, position, options.intersect, distanceMetric);\n      },\n\n      /**\n       * x mode returns the elements that hit-test at the current x coordinate\n       * @function Chart.Interaction.modes.x\n       * @param {Chart} chart - the chart we are returning items from\n       * @param {Event} e - the event we are find things at\n       * @param {IInteractionOptions} options - options to use\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n      x: function (chart, e, options) {\n        var position = getRelativePosition(e, chart);\n        var items = [];\n        var intersectsItem = false;\n        parseVisibleItems(chart, function (element) {\n          if (element.inXRange(position.x)) {\n            items.push(element);\n          }\n\n          if (element.inRange(position.x, position.y)) {\n            intersectsItem = true;\n          }\n        }); // If we want to trigger on an intersect and we don't have any items\n        // that intersect the position, return nothing\n\n        if (options.intersect && !intersectsItem) {\n          items = [];\n        }\n\n        return items;\n      },\n\n      /**\n       * y mode returns the elements that hit-test at the current y coordinate\n       * @function Chart.Interaction.modes.y\n       * @param {Chart} chart - the chart we are returning items from\n       * @param {Event} e - the event we are find things at\n       * @param {IInteractionOptions} options - options to use\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n      y: function (chart, e, options) {\n        var position = getRelativePosition(e, chart);\n        var items = [];\n        var intersectsItem = false;\n        parseVisibleItems(chart, function (element) {\n          if (element.inYRange(position.y)) {\n            items.push(element);\n          }\n\n          if (element.inRange(position.x, position.y)) {\n            intersectsItem = true;\n          }\n        }); // If we want to trigger on an intersect and we don't have any items\n        // that intersect the position, return nothing\n\n        if (options.intersect && !intersectsItem) {\n          items = [];\n        }\n\n        return items;\n      }\n    }\n  };\n  var extend = helpers$1.extend;\n\n  function filterByPosition(array, position) {\n    return helpers$1.where(array, function (v) {\n      return v.pos === position;\n    });\n  }\n\n  function sortByWeight(array, reverse) {\n    return array.sort(function (a, b) {\n      var v0 = reverse ? b : a;\n      var v1 = reverse ? a : b;\n      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n    });\n  }\n\n  function wrapBoxes(boxes) {\n    var layoutBoxes = [];\n    var i, ilen, box;\n\n    for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n      box = boxes[i];\n      layoutBoxes.push({\n        index: i,\n        box: box,\n        pos: box.position,\n        horizontal: box.isHorizontal(),\n        weight: box.weight\n      });\n    }\n\n    return layoutBoxes;\n  }\n\n  function setLayoutDims(layouts, params) {\n    var i, ilen, layout;\n\n    for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n      layout = layouts[i]; // store width used instead of chartArea.w in fitBoxes\n\n      layout.width = layout.horizontal ? layout.box.fullWidth && params.availableWidth : params.vBoxMaxWidth; // store height used instead of chartArea.h in fitBoxes\n\n      layout.height = layout.horizontal && params.hBoxMaxHeight;\n    }\n  }\n\n  function buildLayoutBoxes(boxes) {\n    var layoutBoxes = wrapBoxes(boxes);\n    var left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n    var right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n    var top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n    var bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n    return {\n      leftAndTop: left.concat(top),\n      rightAndBottom: right.concat(bottom),\n      chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n      vertical: left.concat(right),\n      horizontal: top.concat(bottom)\n    };\n  }\n\n  function getCombinedMax(maxPadding, chartArea, a, b) {\n    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n  }\n\n  function updateDims(chartArea, params, layout) {\n    var box = layout.box;\n    var maxPadding = chartArea.maxPadding;\n    var newWidth, newHeight;\n\n    if (layout.size) {\n      // this layout was already counted for, lets first reduce old size\n      chartArea[layout.pos] -= layout.size;\n    }\n\n    layout.size = layout.horizontal ? box.height : box.width;\n    chartArea[layout.pos] += layout.size;\n\n    if (box.getPadding) {\n      var boxPadding = box.getPadding();\n      maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n      maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n      maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n      maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n    }\n\n    newWidth = params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right');\n    newHeight = params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom');\n\n    if (newWidth !== chartArea.w || newHeight !== chartArea.h) {\n      chartArea.w = newWidth;\n      chartArea.h = newHeight; // return true if chart area changed in layout's direction\n\n      return layout.horizontal ? newWidth !== chartArea.w : newHeight !== chartArea.h;\n    }\n  }\n\n  function handleMaxPadding(chartArea) {\n    var maxPadding = chartArea.maxPadding;\n\n    function updatePos(pos) {\n      var change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n      chartArea[pos] += change;\n      return change;\n    }\n\n    chartArea.y += updatePos('top');\n    chartArea.x += updatePos('left');\n    updatePos('right');\n    updatePos('bottom');\n  }\n\n  function getMargins(horizontal, chartArea) {\n    var maxPadding = chartArea.maxPadding;\n\n    function marginForPositions(positions) {\n      var margin = {\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0\n      };\n      positions.forEach(function (pos) {\n        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n      });\n      return margin;\n    }\n\n    return horizontal ? marginForPositions(['left', 'right']) : marginForPositions(['top', 'bottom']);\n  }\n\n  function fitBoxes(boxes, chartArea, params) {\n    var refitBoxes = [];\n    var i, ilen, layout, box, refit, changed;\n\n    for (i = 0, ilen = boxes.length; i < ilen; ++i) {\n      layout = boxes[i];\n      box = layout.box;\n      box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n\n      if (updateDims(chartArea, params, layout)) {\n        changed = true;\n\n        if (refitBoxes.length) {\n          // Dimensions changed and there were non full width boxes before this\n          // -> we have to refit those\n          refit = true;\n        }\n      }\n\n      if (!box.fullWidth) {\n        // fullWidth boxes don't need to be re-fitted in any case\n        refitBoxes.push(layout);\n      }\n    }\n\n    return refit ? fitBoxes(refitBoxes, chartArea, params) || changed : changed;\n  }\n\n  function placeBoxes(boxes, chartArea, params) {\n    var userPadding = params.padding;\n    var x = chartArea.x;\n    var y = chartArea.y;\n    var i, ilen, layout, box;\n\n    for (i = 0, ilen = boxes.length; i < ilen; ++i) {\n      layout = boxes[i];\n      box = layout.box;\n\n      if (layout.horizontal) {\n        box.left = box.fullWidth ? userPadding.left : chartArea.left;\n        box.right = box.fullWidth ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;\n        box.top = y;\n        box.bottom = y + box.height;\n        box.width = box.right - box.left;\n        y = box.bottom;\n      } else {\n        box.left = x;\n        box.right = x + box.width;\n        box.top = chartArea.top;\n        box.bottom = chartArea.top + chartArea.h;\n        box.height = box.bottom - box.top;\n        x = box.right;\n      }\n    }\n\n    chartArea.x = x;\n    chartArea.y = y;\n  }\n\n  core_defaults._set('global', {\n    layout: {\n      padding: {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      }\n    }\n  });\n  /**\n   * @interface ILayoutItem\n   * @prop {string} position - The position of the item in the chart layout. Possible values are\n   * 'left', 'top', 'right', 'bottom', and 'chartArea'\n   * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n   * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\n   * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n   * @prop {function} update - Takes two parameters: width and height. Returns size of item\n   * @prop {function} getPadding -  Returns an object with padding on the edges\n   * @prop {number} width - Width of item. Must be valid after update()\n   * @prop {number} height - Height of item. Must be valid after update()\n   * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\n   * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\n   * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\n   * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n   */\n  // The layout service is very self explanatory.  It's responsible for the layout within a chart.\n  // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n  // It is this service's responsibility of carrying out that layout.\n\n\n  var core_layouts = {\n    defaults: {},\n\n    /**\n     * Register a box to a chart.\n     * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n     * @param {Chart} chart - the chart to use\n     * @param {ILayoutItem} item - the item to add to be layed out\n     */\n    addBox: function (chart, item) {\n      if (!chart.boxes) {\n        chart.boxes = [];\n      } // initialize item with default values\n\n\n      item.fullWidth = item.fullWidth || false;\n      item.position = item.position || 'top';\n      item.weight = item.weight || 0;\n\n      item._layers = item._layers || function () {\n        return [{\n          z: 0,\n          draw: function () {\n            item.draw.apply(item, arguments);\n          }\n        }];\n      };\n\n      chart.boxes.push(item);\n    },\n\n    /**\n     * Remove a layoutItem from a chart\n     * @param {Chart} chart - the chart to remove the box from\n     * @param {ILayoutItem} layoutItem - the item to remove from the layout\n     */\n    removeBox: function (chart, layoutItem) {\n      var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\n      if (index !== -1) {\n        chart.boxes.splice(index, 1);\n      }\n    },\n\n    /**\n     * Sets (or updates) options on the given `item`.\n     * @param {Chart} chart - the chart in which the item lives (or will be added to)\n     * @param {ILayoutItem} item - the item to configure with the given options\n     * @param {object} options - the new item options.\n     */\n    configure: function (chart, item, options) {\n      var props = ['fullWidth', 'position', 'weight'];\n      var ilen = props.length;\n      var i = 0;\n      var prop;\n\n      for (; i < ilen; ++i) {\n        prop = props[i];\n\n        if (options.hasOwnProperty(prop)) {\n          item[prop] = options[prop];\n        }\n      }\n    },\n\n    /**\n     * Fits boxes of the given chart into the given size by having each box measure itself\n     * then running a fitting algorithm\n     * @param {Chart} chart - the chart\n     * @param {number} width - the width to fit into\n     * @param {number} height - the height to fit into\n     */\n    update: function (chart, width, height) {\n      if (!chart) {\n        return;\n      }\n\n      var layoutOptions = chart.options.layout || {};\n      var padding = helpers$1.options.toPadding(layoutOptions.padding);\n      var availableWidth = width - padding.width;\n      var availableHeight = height - padding.height;\n      var boxes = buildLayoutBoxes(chart.boxes);\n      var verticalBoxes = boxes.vertical;\n      var horizontalBoxes = boxes.horizontal; // Essentially we now have any number of boxes on each of the 4 sides.\n      // Our canvas looks like the following.\n      // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n      // B1 is the bottom axis\n      // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n      // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n      // an error will be thrown.\n      //\n      // |----------------------------------------------------|\n      // |                  T1 (Full Width)                   |\n      // |----------------------------------------------------|\n      // |    |    |                 T2                  |    |\n      // |    |----|-------------------------------------|----|\n      // |    |    | C1 |                           | C2 |    |\n      // |    |    |----|                           |----|    |\n      // |    |    |                                     |    |\n      // | L1 | L2 |           ChartArea (C0)            | R1 |\n      // |    |    |                                     |    |\n      // |    |    |----|                           |----|    |\n      // |    |    | C3 |                           | C4 |    |\n      // |    |----|-------------------------------------|----|\n      // |    |    |                 B1                  |    |\n      // |----------------------------------------------------|\n      // |                  B2 (Full Width)                   |\n      // |----------------------------------------------------|\n      //\n\n      var params = Object.freeze({\n        outerWidth: width,\n        outerHeight: height,\n        padding: padding,\n        availableWidth: availableWidth,\n        vBoxMaxWidth: availableWidth / 2 / verticalBoxes.length,\n        hBoxMaxHeight: availableHeight / 2\n      });\n      var chartArea = extend({\n        maxPadding: extend({}, padding),\n        w: availableWidth,\n        h: availableHeight,\n        x: padding.left,\n        y: padding.top\n      }, padding);\n      setLayoutDims(verticalBoxes.concat(horizontalBoxes), params); // First fit vertical boxes\n\n      fitBoxes(verticalBoxes, chartArea, params); // Then fit horizontal boxes\n\n      if (fitBoxes(horizontalBoxes, chartArea, params)) {\n        // if the area changed, re-fit vertical boxes\n        fitBoxes(verticalBoxes, chartArea, params);\n      }\n\n      handleMaxPadding(chartArea); // Finally place the boxes to correct coordinates\n\n      placeBoxes(boxes.leftAndTop, chartArea, params); // Move to opposite side of chart\n\n      chartArea.x += chartArea.w;\n      chartArea.y += chartArea.h;\n      placeBoxes(boxes.rightAndBottom, chartArea, params);\n      chart.chartArea = {\n        left: chartArea.left,\n        top: chartArea.top,\n        right: chartArea.left + chartArea.w,\n        bottom: chartArea.top + chartArea.h\n      }; // Finally update boxes in chartArea (radial scale for example)\n\n      helpers$1.each(boxes.chartArea, function (layout) {\n        var box = layout.box;\n        extend(box, chart.chartArea);\n        box.update(chartArea.w, chartArea.h);\n      });\n    }\n  };\n  /**\n   * Platform fallback implementation (minimal).\n   * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n   */\n\n  var platform_basic = {\n    acquireContext: function (item) {\n      if (item && item.canvas) {\n        // Support for any object associated to a canvas (including a context2d)\n        item = item.canvas;\n      }\n\n      return item && item.getContext('2d') || null;\n    }\n  };\n  var platform_dom = \"/*\\n * DOM element rendering detection\\n * https://davidwalsh.name/detect-node-insertion\\n */\\n@keyframes chartjs-render-animation {\\n\\tfrom { opacity: 0.99; }\\n\\tto { opacity: 1; }\\n}\\n\\n.chartjs-render-monitor {\\n\\tanimation: chartjs-render-animation 0.001s;\\n}\\n\\n/*\\n * DOM element resizing detection\\n * https://github.com/marcj/css-element-queries\\n */\\n.chartjs-size-monitor,\\n.chartjs-size-monitor-expand,\\n.chartjs-size-monitor-shrink {\\n\\tposition: absolute;\\n\\tdirection: ltr;\\n\\tleft: 0;\\n\\ttop: 0;\\n\\tright: 0;\\n\\tbottom: 0;\\n\\toverflow: hidden;\\n\\tpointer-events: none;\\n\\tvisibility: hidden;\\n\\tz-index: -1;\\n}\\n\\n.chartjs-size-monitor-expand > div {\\n\\tposition: absolute;\\n\\twidth: 1000000px;\\n\\theight: 1000000px;\\n\\tleft: 0;\\n\\ttop: 0;\\n}\\n\\n.chartjs-size-monitor-shrink > div {\\n\\tposition: absolute;\\n\\twidth: 200%;\\n\\theight: 200%;\\n\\tleft: 0;\\n\\ttop: 0;\\n}\\n\";\n  var platform_dom$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    'default': platform_dom\n  });\n  var stylesheet = getCjsExportFromNamespace(platform_dom$1);\n  var EXPANDO_KEY = '$chartjs';\n  var CSS_PREFIX = 'chartjs-';\n  var CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';\n  var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';\n  var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';\n  var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];\n  /**\n   * DOM event types -> Chart.js event types.\n   * Note: only events with different types are mapped.\n   * @see https://developer.mozilla.org/en-US/docs/Web/Events\n   */\n\n  var EVENT_TYPES = {\n    touchstart: 'mousedown',\n    touchmove: 'mousemove',\n    touchend: 'mouseup',\n    pointerenter: 'mouseenter',\n    pointerdown: 'mousedown',\n    pointermove: 'mousemove',\n    pointerup: 'mouseup',\n    pointerleave: 'mouseout',\n    pointerout: 'mouseout'\n  };\n  /**\n   * The \"used\" size is the final value of a dimension property after all calculations have\n   * been performed. This method uses the computed style of `element` but returns undefined\n   * if the computed style is not expressed in pixels. That can happen in some cases where\n   * `element` has a size relative to its parent and this last one is not yet displayed,\n   * for example because of `display: none` on a parent node.\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n   * @returns {number} Size in pixels or undefined if unknown.\n   */\n\n  function readUsedSize(element, property) {\n    var value = helpers$1.getStyle(element, property);\n    var matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n    return matches ? Number(matches[1]) : undefined;\n  }\n  /**\n   * Initializes the canvas style and render size without modifying the canvas display size,\n   * since responsiveness is handled by the controller.resize() method. The config is used\n   * to determine the aspect ratio to apply in case no explicit height has been specified.\n   */\n\n\n  function initCanvas(canvas, config) {\n    var style = canvas.style; // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n    // returns null or '' if no explicit value has been set to the canvas attribute.\n\n    var renderHeight = canvas.getAttribute('height');\n    var renderWidth = canvas.getAttribute('width'); // Chart.js modifies some canvas values that we want to restore on destroy\n\n    canvas[EXPANDO_KEY] = {\n      initial: {\n        height: renderHeight,\n        width: renderWidth,\n        style: {\n          display: style.display,\n          height: style.height,\n          width: style.width\n        }\n      }\n    }; // Force canvas to display as block to avoid extra space caused by inline\n    // elements, which would interfere with the responsive resize process.\n    // https://github.com/chartjs/Chart.js/issues/2538\n\n    style.display = style.display || 'block';\n\n    if (renderWidth === null || renderWidth === '') {\n      var displayWidth = readUsedSize(canvas, 'width');\n\n      if (displayWidth !== undefined) {\n        canvas.width = displayWidth;\n      }\n    }\n\n    if (renderHeight === null || renderHeight === '') {\n      if (canvas.style.height === '') {\n        // If no explicit render height and style height, let's apply the aspect ratio,\n        // which one can be specified by the user but also by charts as default option\n        // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n        canvas.height = canvas.width / (config.options.aspectRatio || 2);\n      } else {\n        var displayHeight = readUsedSize(canvas, 'height');\n\n        if (displayWidth !== undefined) {\n          canvas.height = displayHeight;\n        }\n      }\n    }\n\n    return canvas;\n  }\n  /**\n   * Detects support for options object argument in addEventListener.\n   * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n   * @private\n   */\n\n\n  var supportsEventListenerOptions = function () {\n    var supports = false;\n\n    try {\n      var options = Object.defineProperty({}, 'passive', {\n        // eslint-disable-next-line getter-return\n        get: function () {\n          supports = true;\n        }\n      });\n      window.addEventListener('e', null, options);\n    } catch (e) {// continue regardless of error\n    }\n\n    return supports;\n  }(); // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n  // https://github.com/chartjs/Chart.js/issues/4287\n\n\n  var eventListenerOptions = supportsEventListenerOptions ? {\n    passive: true\n  } : false;\n\n  function addListener(node, type, listener) {\n    node.addEventListener(type, listener, eventListenerOptions);\n  }\n\n  function removeListener(node, type, listener) {\n    node.removeEventListener(type, listener, eventListenerOptions);\n  }\n\n  function createEvent(type, chart, x, y, nativeEvent) {\n    return {\n      type: type,\n      chart: chart,\n      native: nativeEvent || null,\n      x: x !== undefined ? x : null,\n      y: y !== undefined ? y : null\n    };\n  }\n\n  function fromNativeEvent(event, chart) {\n    var type = EVENT_TYPES[event.type] || event.type;\n    var pos = helpers$1.getRelativePosition(event, chart);\n    return createEvent(type, chart, pos.x, pos.y, event);\n  }\n\n  function throttled(fn, thisArg) {\n    var ticking = false;\n    var args = [];\n    return function () {\n      args = Array.prototype.slice.call(arguments);\n      thisArg = thisArg || this;\n\n      if (!ticking) {\n        ticking = true;\n        helpers$1.requestAnimFrame.call(window, function () {\n          ticking = false;\n          fn.apply(thisArg, args);\n        });\n      }\n    };\n  }\n\n  function createDiv(cls) {\n    var el = document.createElement('div');\n    el.className = cls || '';\n    return el;\n  } // Implementation based on https://github.com/marcj/css-element-queries\n\n\n  function createResizer(handler) {\n    var maxSize = 1000000; // NOTE(SB) Don't use innerHTML because it could be considered unsafe.\n    // https://github.com/chartjs/Chart.js/issues/5902\n\n    var resizer = createDiv(CSS_SIZE_MONITOR);\n    var expand = createDiv(CSS_SIZE_MONITOR + '-expand');\n    var shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');\n    expand.appendChild(createDiv());\n    shrink.appendChild(createDiv());\n    resizer.appendChild(expand);\n    resizer.appendChild(shrink);\n\n    resizer._reset = function () {\n      expand.scrollLeft = maxSize;\n      expand.scrollTop = maxSize;\n      shrink.scrollLeft = maxSize;\n      shrink.scrollTop = maxSize;\n    };\n\n    var onScroll = function () {\n      resizer._reset();\n\n      handler();\n    };\n\n    addListener(expand, 'scroll', onScroll.bind(expand, 'expand'));\n    addListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));\n    return resizer;\n  } // https://davidwalsh.name/detect-node-insertion\n\n\n  function watchForRender(node, handler) {\n    var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n\n    var proxy = expando.renderProxy = function (e) {\n      if (e.animationName === CSS_RENDER_ANIMATION) {\n        handler();\n      }\n    };\n\n    helpers$1.each(ANIMATION_START_EVENTS, function (type) {\n      addListener(node, type, proxy);\n    }); // #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class\n    // is removed then added back immediately (same animation frame?). Accessing the\n    // `offsetParent` property will force a reflow and re-evaluate the CSS animation.\n    // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics\n    // https://github.com/chartjs/Chart.js/issues/4737\n\n    expando.reflow = !!node.offsetParent;\n    node.classList.add(CSS_RENDER_MONITOR);\n  }\n\n  function unwatchForRender(node) {\n    var expando = node[EXPANDO_KEY] || {};\n    var proxy = expando.renderProxy;\n\n    if (proxy) {\n      helpers$1.each(ANIMATION_START_EVENTS, function (type) {\n        removeListener(node, type, proxy);\n      });\n      delete expando.renderProxy;\n    }\n\n    node.classList.remove(CSS_RENDER_MONITOR);\n  }\n\n  function addResizeListener(node, listener, chart) {\n    var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {}); // Let's keep track of this added resizer and thus avoid DOM query when removing it.\n\n    var resizer = expando.resizer = createResizer(throttled(function () {\n      if (expando.resizer) {\n        var container = chart.options.maintainAspectRatio && node.parentNode;\n        var w = container ? container.clientWidth : 0;\n        listener(createEvent('resize', chart));\n\n        if (container && container.clientWidth < w && chart.canvas) {\n          // If the container size shrank during chart resize, let's assume\n          // scrollbar appeared. So we resize again with the scrollbar visible -\n          // effectively making chart smaller and the scrollbar hidden again.\n          // Because we are inside `throttled`, and currently `ticking`, scroll\n          // events are ignored during this whole 2 resize process.\n          // If we assumed wrong and something else happened, we are resizing\n          // twice in a frame (potential performance issue)\n          listener(createEvent('resize', chart));\n        }\n      }\n    })); // The resizer needs to be attached to the node parent, so we first need to be\n    // sure that `node` is attached to the DOM before injecting the resizer element.\n\n    watchForRender(node, function () {\n      if (expando.resizer) {\n        var container = node.parentNode;\n\n        if (container && container !== resizer.parentNode) {\n          container.insertBefore(resizer, container.firstChild);\n        } // The container size might have changed, let's reset the resizer state.\n\n\n        resizer._reset();\n      }\n    });\n  }\n\n  function removeResizeListener(node) {\n    var expando = node[EXPANDO_KEY] || {};\n    var resizer = expando.resizer;\n    delete expando.resizer;\n    unwatchForRender(node);\n\n    if (resizer && resizer.parentNode) {\n      resizer.parentNode.removeChild(resizer);\n    }\n  }\n  /**\n   * Injects CSS styles inline if the styles are not already present.\n   * @param {HTMLDocument|ShadowRoot} rootNode - the node to contain the <style>.\n   * @param {string} css - the CSS to be injected.\n   */\n\n\n  function injectCSS(rootNode, css) {\n    // https://stackoverflow.com/q/3922139\n    var expando = rootNode[EXPANDO_KEY] || (rootNode[EXPANDO_KEY] = {});\n\n    if (!expando.containsStyles) {\n      expando.containsStyles = true;\n      css = '/* Chart.js */\\n' + css;\n      var style = document.createElement('style');\n      style.setAttribute('type', 'text/css');\n      style.appendChild(document.createTextNode(css));\n      rootNode.appendChild(style);\n    }\n  }\n\n  var platform_dom$2 = {\n    /**\n     * When `true`, prevents the automatic injection of the stylesheet required to\n     * correctly detect when the chart is added to the DOM and then resized. This\n     * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)\n     * to be manually imported to make this library compatible with any CSP.\n     * See https://github.com/chartjs/Chart.js/issues/5208\n     */\n    disableCSSInjection: false,\n\n    /**\n     * This property holds whether this platform is enabled for the current environment.\n     * Currently used by platform.js to select the proper implementation.\n     * @private\n     */\n    _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',\n\n    /**\n     * Initializes resources that depend on platform options.\n     * @param {HTMLCanvasElement} canvas - The Canvas element.\n     * @private\n     */\n    _ensureLoaded: function (canvas) {\n      if (!this.disableCSSInjection) {\n        // If the canvas is in a shadow DOM, then the styles must also be inserted\n        // into the same shadow DOM.\n        // https://github.com/chartjs/Chart.js/issues/5763\n        var root = canvas.getRootNode ? canvas.getRootNode() : document;\n        var targetNode = root.host ? root : document.head;\n        injectCSS(targetNode, stylesheet);\n      }\n    },\n    acquireContext: function (item, config) {\n      if (typeof item === 'string') {\n        item = document.getElementById(item);\n      } else if (item.length) {\n        // Support for array based queries (such as jQuery)\n        item = item[0];\n      }\n\n      if (item && item.canvas) {\n        // Support for any object associated to a canvas (including a context2d)\n        item = item.canvas;\n      } // To prevent canvas fingerprinting, some add-ons undefine the getContext\n      // method, for example: https://github.com/kkapsner/CanvasBlocker\n      // https://github.com/chartjs/Chart.js/issues/2807\n\n\n      var context = item && item.getContext && item.getContext('2d'); // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is\n      // inside an iframe or when running in a protected environment. We could guess the\n      // types from their toString() value but let's keep things flexible and assume it's\n      // a sufficient condition if the item has a context2D which has item as `canvas`.\n      // https://github.com/chartjs/Chart.js/issues/3887\n      // https://github.com/chartjs/Chart.js/issues/4102\n      // https://github.com/chartjs/Chart.js/issues/4152\n\n      if (context && context.canvas === item) {\n        // Load platform resources on first chart creation, to make it possible to\n        // import the library before setting platform options.\n        this._ensureLoaded(item);\n\n        initCanvas(item, config);\n        return context;\n      }\n\n      return null;\n    },\n    releaseContext: function (context) {\n      var canvas = context.canvas;\n\n      if (!canvas[EXPANDO_KEY]) {\n        return;\n      }\n\n      var initial = canvas[EXPANDO_KEY].initial;\n      ['height', 'width'].forEach(function (prop) {\n        var value = initial[prop];\n\n        if (helpers$1.isNullOrUndef(value)) {\n          canvas.removeAttribute(prop);\n        } else {\n          canvas.setAttribute(prop, value);\n        }\n      });\n      helpers$1.each(initial.style || {}, function (value, key) {\n        canvas.style[key] = value;\n      }); // The canvas render size might have been changed (and thus the state stack discarded),\n      // we can't use save() and restore() to restore the initial state. So make sure that at\n      // least the canvas context is reset to the default state by setting the canvas width.\n      // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n      // eslint-disable-next-line no-self-assign\n\n      canvas.width = canvas.width;\n      delete canvas[EXPANDO_KEY];\n    },\n    addEventListener: function (chart, type, listener) {\n      var canvas = chart.canvas;\n\n      if (type === 'resize') {\n        // Note: the resize event is not supported on all browsers.\n        addResizeListener(canvas, listener, chart);\n        return;\n      }\n\n      var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});\n      var proxies = expando.proxies || (expando.proxies = {});\n\n      var proxy = proxies[chart.id + '_' + type] = function (event) {\n        listener(fromNativeEvent(event, chart));\n      };\n\n      addListener(canvas, type, proxy);\n    },\n    removeEventListener: function (chart, type, listener) {\n      var canvas = chart.canvas;\n\n      if (type === 'resize') {\n        // Note: the resize event is not supported on all browsers.\n        removeResizeListener(canvas);\n        return;\n      }\n\n      var expando = listener[EXPANDO_KEY] || {};\n      var proxies = expando.proxies || {};\n      var proxy = proxies[chart.id + '_' + type];\n\n      if (!proxy) {\n        return;\n      }\n\n      removeListener(canvas, type, proxy);\n    }\n  }; // DEPRECATIONS\n\n  /**\n   * Provided for backward compatibility, use EventTarget.addEventListener instead.\n   * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n   * @function Chart.helpers.addEvent\n   * @deprecated since version 2.7.0\n   * @todo remove at version 3\n   * @private\n   */\n\n  helpers$1.addEvent = addListener;\n  /**\n   * Provided for backward compatibility, use EventTarget.removeEventListener instead.\n   * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\n   * @function Chart.helpers.removeEvent\n   * @deprecated since version 2.7.0\n   * @todo remove at version 3\n   * @private\n   */\n\n  helpers$1.removeEvent = removeListener; // @TODO Make possible to select another platform at build time.\n\n  var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;\n  /**\n   * @namespace Chart.platform\n   * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\n   * @since 2.4.0\n   */\n\n  var platform = helpers$1.extend({\n    /**\n     * @since 2.7.0\n     */\n    initialize: function () {},\n\n    /**\n     * Called at chart construction time, returns a context2d instance implementing\n     * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n     * @param {*} item - The native item from which to acquire context (platform specific)\n     * @param {object} options - The chart options\n     * @returns {CanvasRenderingContext2D} context2d instance\n     */\n    acquireContext: function () {},\n\n    /**\n     * Called at chart destruction time, releases any resources associated to the context\n     * previously returned by the acquireContext() method.\n     * @param {CanvasRenderingContext2D} context - The context2d instance\n     * @returns {boolean} true if the method succeeded, else false\n     */\n    releaseContext: function () {},\n\n    /**\n     * Registers the specified listener on the given chart.\n     * @param {Chart} chart - Chart from which to listen for event\n     * @param {string} type - The ({@link IEvent}) type to listen for\n     * @param {function} listener - Receives a notification (an object that implements\n     * the {@link IEvent} interface) when an event of the specified type occurs.\n     */\n    addEventListener: function () {},\n\n    /**\n     * Removes the specified listener previously registered with addEventListener.\n     * @param {Chart} chart - Chart from which to remove the listener\n     * @param {string} type - The ({@link IEvent}) type to remove\n     * @param {function} listener - The listener function to remove from the event target.\n     */\n    removeEventListener: function () {}\n  }, implementation);\n\n  core_defaults._set('global', {\n    plugins: {}\n  });\n  /**\n   * The plugin service singleton\n   * @namespace Chart.plugins\n   * @since 2.1.0\n   */\n\n\n  var core_plugins = {\n    /**\n     * Globally registered plugins.\n     * @private\n     */\n    _plugins: [],\n\n    /**\n     * This identifier is used to invalidate the descriptors cache attached to each chart\n     * when a global plugin is registered or unregistered. In this case, the cache ID is\n     * incremented and descriptors are regenerated during following API calls.\n     * @private\n     */\n    _cacheId: 0,\n\n    /**\n     * Registers the given plugin(s) if not already registered.\n     * @param {IPlugin[]|IPlugin} plugins plugin instance(s).\n     */\n    register: function (plugins) {\n      var p = this._plugins;\n      [].concat(plugins).forEach(function (plugin) {\n        if (p.indexOf(plugin) === -1) {\n          p.push(plugin);\n        }\n      });\n      this._cacheId++;\n    },\n\n    /**\n     * Unregisters the given plugin(s) only if registered.\n     * @param {IPlugin[]|IPlugin} plugins plugin instance(s).\n     */\n    unregister: function (plugins) {\n      var p = this._plugins;\n      [].concat(plugins).forEach(function (plugin) {\n        var idx = p.indexOf(plugin);\n\n        if (idx !== -1) {\n          p.splice(idx, 1);\n        }\n      });\n      this._cacheId++;\n    },\n\n    /**\n     * Remove all registered plugins.\n     * @since 2.1.5\n     */\n    clear: function () {\n      this._plugins = [];\n      this._cacheId++;\n    },\n\n    /**\n     * Returns the number of registered plugins?\n     * @returns {number}\n     * @since 2.1.5\n     */\n    count: function () {\n      return this._plugins.length;\n    },\n\n    /**\n     * Returns all registered plugin instances.\n     * @returns {IPlugin[]} array of plugin objects.\n     * @since 2.1.5\n     */\n    getAll: function () {\n      return this._plugins;\n    },\n\n    /**\n     * Calls enabled plugins for `chart` on the specified hook and with the given args.\n     * This method immediately returns as soon as a plugin explicitly returns false. The\n     * returned value can be used, for instance, to interrupt the current action.\n     * @param {Chart} chart - The chart instance for which plugins should be called.\n     * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n     * @param {Array} [args] - Extra arguments to apply to the hook call.\n     * @returns {boolean} false if any of the plugins return false, else returns true.\n     */\n    notify: function (chart, hook, args) {\n      var descriptors = this.descriptors(chart);\n      var ilen = descriptors.length;\n      var i, descriptor, plugin, params, method;\n\n      for (i = 0; i < ilen; ++i) {\n        descriptor = descriptors[i];\n        plugin = descriptor.plugin;\n        method = plugin[hook];\n\n        if (typeof method === 'function') {\n          params = [chart].concat(args || []);\n          params.push(descriptor.options);\n\n          if (method.apply(plugin, params) === false) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    },\n\n    /**\n     * Returns descriptors of enabled plugins for the given chart.\n     * @returns {object[]} [{ plugin, options }]\n     * @private\n     */\n    descriptors: function (chart) {\n      var cache = chart.$plugins || (chart.$plugins = {});\n\n      if (cache.id === this._cacheId) {\n        return cache.descriptors;\n      }\n\n      var plugins = [];\n      var descriptors = [];\n      var config = chart && chart.config || {};\n      var options = config.options && config.options.plugins || {};\n\n      this._plugins.concat(config.plugins || []).forEach(function (plugin) {\n        var idx = plugins.indexOf(plugin);\n\n        if (idx !== -1) {\n          return;\n        }\n\n        var id = plugin.id;\n        var opts = options[id];\n\n        if (opts === false) {\n          return;\n        }\n\n        if (opts === true) {\n          opts = helpers$1.clone(core_defaults.global.plugins[id]);\n        }\n\n        plugins.push(plugin);\n        descriptors.push({\n          plugin: plugin,\n          options: opts || {}\n        });\n      });\n\n      cache.descriptors = descriptors;\n      cache.id = this._cacheId;\n      return descriptors;\n    },\n\n    /**\n     * Invalidates cache for the given chart: descriptors hold a reference on plugin option,\n     * but in some cases, this reference can be changed by the user when updating options.\n     * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n     * @private\n     */\n    _invalidate: function (chart) {\n      delete chart.$plugins;\n    }\n  };\n  var core_scaleService = {\n    // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\n    // use the new chart options to grab the correct scale\n    constructors: {},\n    // Use a registration function so that we can move to an ES6 map when we no longer need to support\n    // old browsers\n    // Scale config defaults\n    defaults: {},\n    registerScaleType: function (type, scaleConstructor, scaleDefaults) {\n      this.constructors[type] = scaleConstructor;\n      this.defaults[type] = helpers$1.clone(scaleDefaults);\n    },\n    getScaleConstructor: function (type) {\n      return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n    },\n    getScaleDefaults: function (type) {\n      // Return the scale defaults merged with the global settings so that we always use the latest ones\n      return this.defaults.hasOwnProperty(type) ? helpers$1.merge({}, [core_defaults.scale, this.defaults[type]]) : {};\n    },\n    updateScaleDefaults: function (type, additions) {\n      var me = this;\n\n      if (me.defaults.hasOwnProperty(type)) {\n        me.defaults[type] = helpers$1.extend(me.defaults[type], additions);\n      }\n    },\n    addScalesToLayout: function (chart) {\n      // Adds each scale to the chart.boxes array to be sized accordingly\n      helpers$1.each(chart.scales, function (scale) {\n        // Set ILayoutItem parameters for backwards compatibility\n        scale.fullWidth = scale.options.fullWidth;\n        scale.position = scale.options.position;\n        scale.weight = scale.options.weight;\n        core_layouts.addBox(chart, scale);\n      });\n    }\n  };\n  var valueOrDefault$8 = helpers$1.valueOrDefault;\n  var getRtlHelper = helpers$1.rtl.getRtlAdapter;\n\n  core_defaults._set('global', {\n    tooltips: {\n      enabled: true,\n      custom: null,\n      mode: 'nearest',\n      position: 'average',\n      intersect: true,\n      backgroundColor: 'rgba(0,0,0,0.8)',\n      titleFontStyle: 'bold',\n      titleSpacing: 2,\n      titleMarginBottom: 6,\n      titleFontColor: '#fff',\n      titleAlign: 'left',\n      bodySpacing: 2,\n      bodyFontColor: '#fff',\n      bodyAlign: 'left',\n      footerFontStyle: 'bold',\n      footerSpacing: 2,\n      footerMarginTop: 6,\n      footerFontColor: '#fff',\n      footerAlign: 'left',\n      yPadding: 6,\n      xPadding: 6,\n      caretPadding: 2,\n      caretSize: 5,\n      cornerRadius: 6,\n      multiKeyBackground: '#fff',\n      displayColors: true,\n      borderColor: 'rgba(0,0,0,0)',\n      borderWidth: 0,\n      callbacks: {\n        // Args are: (tooltipItems, data)\n        beforeTitle: helpers$1.noop,\n        title: function (tooltipItems, data) {\n          var title = '';\n          var labels = data.labels;\n          var labelCount = labels ? labels.length : 0;\n\n          if (tooltipItems.length > 0) {\n            var item = tooltipItems[0];\n\n            if (item.label) {\n              title = item.label;\n            } else if (item.xLabel) {\n              title = item.xLabel;\n            } else if (labelCount > 0 && item.index < labelCount) {\n              title = labels[item.index];\n            }\n          }\n\n          return title;\n        },\n        afterTitle: helpers$1.noop,\n        // Args are: (tooltipItems, data)\n        beforeBody: helpers$1.noop,\n        // Args are: (tooltipItem, data)\n        beforeLabel: helpers$1.noop,\n        label: function (tooltipItem, data) {\n          var label = data.datasets[tooltipItem.datasetIndex].label || '';\n\n          if (label) {\n            label += ': ';\n          }\n\n          if (!helpers$1.isNullOrUndef(tooltipItem.value)) {\n            label += tooltipItem.value;\n          } else {\n            label += tooltipItem.yLabel;\n          }\n\n          return label;\n        },\n        labelColor: function (tooltipItem, chart) {\n          var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);\n          var activeElement = meta.data[tooltipItem.index];\n          var view = activeElement._view;\n          return {\n            borderColor: view.borderColor,\n            backgroundColor: view.backgroundColor\n          };\n        },\n        labelTextColor: function () {\n          return this._options.bodyFontColor;\n        },\n        afterLabel: helpers$1.noop,\n        // Args are: (tooltipItems, data)\n        afterBody: helpers$1.noop,\n        // Args are: (tooltipItems, data)\n        beforeFooter: helpers$1.noop,\n        footer: helpers$1.noop,\n        afterFooter: helpers$1.noop\n      }\n    }\n  });\n\n  var positioners = {\n    /**\n     * Average mode places the tooltip at the average position of the elements shown\n     * @function Chart.Tooltip.positioners.average\n     * @param elements {ChartElement[]} the elements being displayed in the tooltip\n     * @returns {object} tooltip position\n     */\n    average: function (elements) {\n      if (!elements.length) {\n        return false;\n      }\n\n      var i, len;\n      var x = 0;\n      var y = 0;\n      var count = 0;\n\n      for (i = 0, len = elements.length; i < len; ++i) {\n        var el = elements[i];\n\n        if (el && el.hasValue()) {\n          var pos = el.tooltipPosition();\n          x += pos.x;\n          y += pos.y;\n          ++count;\n        }\n      }\n\n      return {\n        x: x / count,\n        y: y / count\n      };\n    },\n\n    /**\n     * Gets the tooltip position nearest of the item nearest to the event position\n     * @function Chart.Tooltip.positioners.nearest\n     * @param elements {Chart.Element[]} the tooltip elements\n     * @param eventPosition {object} the position of the event in canvas coordinates\n     * @returns {object} the tooltip position\n     */\n    nearest: function (elements, eventPosition) {\n      var x = eventPosition.x;\n      var y = eventPosition.y;\n      var minDistance = Number.POSITIVE_INFINITY;\n      var i, len, nearestElement;\n\n      for (i = 0, len = elements.length; i < len; ++i) {\n        var el = elements[i];\n\n        if (el && el.hasValue()) {\n          var center = el.getCenterPoint();\n          var d = helpers$1.distanceBetweenPoints(eventPosition, center);\n\n          if (d < minDistance) {\n            minDistance = d;\n            nearestElement = el;\n          }\n        }\n      }\n\n      if (nearestElement) {\n        var tp = nearestElement.tooltipPosition();\n        x = tp.x;\n        y = tp.y;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }; // Helper to push or concat based on if the 2nd parameter is an array or not\n\n  function pushOrConcat(base, toPush) {\n    if (toPush) {\n      if (helpers$1.isArray(toPush)) {\n        // base = base.concat(toPush);\n        Array.prototype.push.apply(base, toPush);\n      } else {\n        base.push(toPush);\n      }\n    }\n\n    return base;\n  }\n  /**\n   * Returns array of strings split by newline\n   * @param {string} value - The value to split by newline.\n   * @returns {string[]} value if newline present - Returned from String split() method\n   * @function\n   */\n\n\n  function splitNewlines(str) {\n    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n      return str.split('\\n');\n    }\n\n    return str;\n  }\n  /**\n   * Private helper to create a tooltip item model\n   * @param element - the chart element (point, arc, bar) to create the tooltip item for\n   * @return new tooltip item\n   */\n\n\n  function createTooltipItem(element) {\n    var xScale = element._xScale;\n    var yScale = element._yScale || element._scale; // handle radar || polarArea charts\n\n    var index = element._index;\n    var datasetIndex = element._datasetIndex;\n\n    var controller = element._chart.getDatasetMeta(datasetIndex).controller;\n\n    var indexScale = controller._getIndexScale();\n\n    var valueScale = controller._getValueScale();\n\n    return {\n      xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\n      yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\n      label: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',\n      value: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',\n      index: index,\n      datasetIndex: datasetIndex,\n      x: element._model.x,\n      y: element._model.y\n    };\n  }\n  /**\n   * Helper to get the reset model for the tooltip\n   * @param tooltipOpts {object} the tooltip options\n   */\n\n\n  function getBaseModel(tooltipOpts) {\n    var globalDefaults = core_defaults.global;\n    return {\n      // Positioning\n      xPadding: tooltipOpts.xPadding,\n      yPadding: tooltipOpts.yPadding,\n      xAlign: tooltipOpts.xAlign,\n      yAlign: tooltipOpts.yAlign,\n      // Drawing direction and text direction\n      rtl: tooltipOpts.rtl,\n      textDirection: tooltipOpts.textDirection,\n      // Body\n      bodyFontColor: tooltipOpts.bodyFontColor,\n      _bodyFontFamily: valueOrDefault$8(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\n      _bodyFontStyle: valueOrDefault$8(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\n      _bodyAlign: tooltipOpts.bodyAlign,\n      bodyFontSize: valueOrDefault$8(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\n      bodySpacing: tooltipOpts.bodySpacing,\n      // Title\n      titleFontColor: tooltipOpts.titleFontColor,\n      _titleFontFamily: valueOrDefault$8(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\n      _titleFontStyle: valueOrDefault$8(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\n      titleFontSize: valueOrDefault$8(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\n      _titleAlign: tooltipOpts.titleAlign,\n      titleSpacing: tooltipOpts.titleSpacing,\n      titleMarginBottom: tooltipOpts.titleMarginBottom,\n      // Footer\n      footerFontColor: tooltipOpts.footerFontColor,\n      _footerFontFamily: valueOrDefault$8(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\n      _footerFontStyle: valueOrDefault$8(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\n      footerFontSize: valueOrDefault$8(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\n      _footerAlign: tooltipOpts.footerAlign,\n      footerSpacing: tooltipOpts.footerSpacing,\n      footerMarginTop: tooltipOpts.footerMarginTop,\n      // Appearance\n      caretSize: tooltipOpts.caretSize,\n      cornerRadius: tooltipOpts.cornerRadius,\n      backgroundColor: tooltipOpts.backgroundColor,\n      opacity: 0,\n      legendColorBackground: tooltipOpts.multiKeyBackground,\n      displayColors: tooltipOpts.displayColors,\n      borderColor: tooltipOpts.borderColor,\n      borderWidth: tooltipOpts.borderWidth\n    };\n  }\n  /**\n   * Get the size of the tooltip\n   */\n\n\n  function getTooltipSize(tooltip, model) {\n    var ctx = tooltip._chart.ctx;\n    var height = model.yPadding * 2; // Tooltip Padding\n\n    var width = 0; // Count of all lines in the body\n\n    var body = model.body;\n    var combinedBodyLength = body.reduce(function (count, bodyItem) {\n      return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\n    }, 0);\n    combinedBodyLength += model.beforeBody.length + model.afterBody.length;\n    var titleLineCount = model.title.length;\n    var footerLineCount = model.footer.length;\n    var titleFontSize = model.titleFontSize;\n    var bodyFontSize = model.bodyFontSize;\n    var footerFontSize = model.footerFontSize;\n    height += titleLineCount * titleFontSize; // Title Lines\n\n    height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\n\n    height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\n\n    height += combinedBodyLength * bodyFontSize; // Body Lines\n\n    height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\n\n    height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\n\n    height += footerLineCount * footerFontSize; // Footer Lines\n\n    height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\n    // Title width\n\n    var widthPadding = 0;\n\n    var maxLineWidth = function (line) {\n      width = Math.max(width, ctx.measureText(line).width + widthPadding);\n    };\n\n    ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\n    helpers$1.each(model.title, maxLineWidth); // Body width\n\n    ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\n    helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth); // Body lines may include some extra width due to the color box\n\n    widthPadding = model.displayColors ? bodyFontSize + 2 : 0;\n    helpers$1.each(body, function (bodyItem) {\n      helpers$1.each(bodyItem.before, maxLineWidth);\n      helpers$1.each(bodyItem.lines, maxLineWidth);\n      helpers$1.each(bodyItem.after, maxLineWidth);\n    }); // Reset back to 0\n\n    widthPadding = 0; // Footer width\n\n    ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\n    helpers$1.each(model.footer, maxLineWidth); // Add padding\n\n    width += 2 * model.xPadding;\n    return {\n      width: width,\n      height: height\n    };\n  }\n  /**\n   * Helper to get the alignment of a tooltip given the size\n   */\n\n\n  function determineAlignment(tooltip, size) {\n    var model = tooltip._model;\n    var chart = tooltip._chart;\n    var chartArea = tooltip._chart.chartArea;\n    var xAlign = 'center';\n    var yAlign = 'center';\n\n    if (model.y < size.height) {\n      yAlign = 'top';\n    } else if (model.y > chart.height - size.height) {\n      yAlign = 'bottom';\n    }\n\n    var lf, rf; // functions to determine left, right alignment\n\n    var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\n\n    var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\n\n    var midX = (chartArea.left + chartArea.right) / 2;\n    var midY = (chartArea.top + chartArea.bottom) / 2;\n\n    if (yAlign === 'center') {\n      lf = function (x) {\n        return x <= midX;\n      };\n\n      rf = function (x) {\n        return x > midX;\n      };\n    } else {\n      lf = function (x) {\n        return x <= size.width / 2;\n      };\n\n      rf = function (x) {\n        return x >= chart.width - size.width / 2;\n      };\n    }\n\n    olf = function (x) {\n      return x + size.width + model.caretSize + model.caretPadding > chart.width;\n    };\n\n    orf = function (x) {\n      return x - size.width - model.caretSize - model.caretPadding < 0;\n    };\n\n    yf = function (y) {\n      return y <= midY ? 'top' : 'bottom';\n    };\n\n    if (lf(model.x)) {\n      xAlign = 'left'; // Is tooltip too wide and goes over the right side of the chart.?\n\n      if (olf(model.x)) {\n        xAlign = 'center';\n        yAlign = yf(model.y);\n      }\n    } else if (rf(model.x)) {\n      xAlign = 'right'; // Is tooltip too wide and goes outside left edge of canvas?\n\n      if (orf(model.x)) {\n        xAlign = 'center';\n        yAlign = yf(model.y);\n      }\n    }\n\n    var opts = tooltip._options;\n    return {\n      xAlign: opts.xAlign ? opts.xAlign : xAlign,\n      yAlign: opts.yAlign ? opts.yAlign : yAlign\n    };\n  }\n  /**\n   * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n   */\n\n\n  function getBackgroundPoint(vm, size, alignment, chart) {\n    // Background Position\n    var x = vm.x;\n    var y = vm.y;\n    var caretSize = vm.caretSize;\n    var caretPadding = vm.caretPadding;\n    var cornerRadius = vm.cornerRadius;\n    var xAlign = alignment.xAlign;\n    var yAlign = alignment.yAlign;\n    var paddingAndSize = caretSize + caretPadding;\n    var radiusAndPadding = cornerRadius + caretPadding;\n\n    if (xAlign === 'right') {\n      x -= size.width;\n    } else if (xAlign === 'center') {\n      x -= size.width / 2;\n\n      if (x + size.width > chart.width) {\n        x = chart.width - size.width;\n      }\n\n      if (x < 0) {\n        x = 0;\n      }\n    }\n\n    if (yAlign === 'top') {\n      y += paddingAndSize;\n    } else if (yAlign === 'bottom') {\n      y -= size.height + paddingAndSize;\n    } else {\n      y -= size.height / 2;\n    }\n\n    if (yAlign === 'center') {\n      if (xAlign === 'left') {\n        x += paddingAndSize;\n      } else if (xAlign === 'right') {\n        x -= paddingAndSize;\n      }\n    } else if (xAlign === 'left') {\n      x -= radiusAndPadding;\n    } else if (xAlign === 'right') {\n      x += radiusAndPadding;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  }\n\n  function getAlignedX(vm, align) {\n    return align === 'center' ? vm.x + vm.width / 2 : align === 'right' ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;\n  }\n  /**\n   * Helper to build before and after body lines\n   */\n\n\n  function getBeforeAfterBodyLines(callback) {\n    return pushOrConcat([], splitNewlines(callback));\n  }\n\n  var exports$4 = core_element.extend({\n    initialize: function () {\n      this._model = getBaseModel(this._options);\n      this._lastActive = [];\n    },\n    // Get the title\n    // Args are: (tooltipItem, data)\n    getTitle: function () {\n      var me = this;\n      var opts = me._options;\n      var callbacks = opts.callbacks;\n      var beforeTitle = callbacks.beforeTitle.apply(me, arguments);\n      var title = callbacks.title.apply(me, arguments);\n      var afterTitle = callbacks.afterTitle.apply(me, arguments);\n      var lines = [];\n      lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n      lines = pushOrConcat(lines, splitNewlines(title));\n      lines = pushOrConcat(lines, splitNewlines(afterTitle));\n      return lines;\n    },\n    // Args are: (tooltipItem, data)\n    getBeforeBody: function () {\n      return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));\n    },\n    // Args are: (tooltipItem, data)\n    getBody: function (tooltipItems, data) {\n      var me = this;\n      var callbacks = me._options.callbacks;\n      var bodyItems = [];\n      helpers$1.each(tooltipItems, function (tooltipItem) {\n        var bodyItem = {\n          before: [],\n          lines: [],\n          after: []\n        };\n        pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));\n        pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\n        pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));\n        bodyItems.push(bodyItem);\n      });\n      return bodyItems;\n    },\n    // Args are: (tooltipItem, data)\n    getAfterBody: function () {\n      return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));\n    },\n    // Get the footer and beforeFooter and afterFooter lines\n    // Args are: (tooltipItem, data)\n    getFooter: function () {\n      var me = this;\n      var callbacks = me._options.callbacks;\n      var beforeFooter = callbacks.beforeFooter.apply(me, arguments);\n      var footer = callbacks.footer.apply(me, arguments);\n      var afterFooter = callbacks.afterFooter.apply(me, arguments);\n      var lines = [];\n      lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n      lines = pushOrConcat(lines, splitNewlines(footer));\n      lines = pushOrConcat(lines, splitNewlines(afterFooter));\n      return lines;\n    },\n    update: function (changed) {\n      var me = this;\n      var opts = me._options; // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\n      // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\n      // which breaks any animations.\n\n      var existingModel = me._model;\n      var model = me._model = getBaseModel(opts);\n      var active = me._active;\n      var data = me._data; // In the case where active.length === 0 we need to keep these at existing values for good animations\n\n      var alignment = {\n        xAlign: existingModel.xAlign,\n        yAlign: existingModel.yAlign\n      };\n      var backgroundPoint = {\n        x: existingModel.x,\n        y: existingModel.y\n      };\n      var tooltipSize = {\n        width: existingModel.width,\n        height: existingModel.height\n      };\n      var tooltipPosition = {\n        x: existingModel.caretX,\n        y: existingModel.caretY\n      };\n      var i, len;\n\n      if (active.length) {\n        model.opacity = 1;\n        var labelColors = [];\n        var labelTextColors = [];\n        tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);\n        var tooltipItems = [];\n\n        for (i = 0, len = active.length; i < len; ++i) {\n          tooltipItems.push(createTooltipItem(active[i]));\n        } // If the user provided a filter function, use it to modify the tooltip items\n\n\n        if (opts.filter) {\n          tooltipItems = tooltipItems.filter(function (a) {\n            return opts.filter(a, data);\n          });\n        } // If the user provided a sorting function, use it to modify the tooltip items\n\n\n        if (opts.itemSort) {\n          tooltipItems = tooltipItems.sort(function (a, b) {\n            return opts.itemSort(a, b, data);\n          });\n        } // Determine colors for boxes\n\n\n        helpers$1.each(tooltipItems, function (tooltipItem) {\n          labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\n          labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));\n        }); // Build the Text Lines\n\n        model.title = me.getTitle(tooltipItems, data);\n        model.beforeBody = me.getBeforeBody(tooltipItems, data);\n        model.body = me.getBody(tooltipItems, data);\n        model.afterBody = me.getAfterBody(tooltipItems, data);\n        model.footer = me.getFooter(tooltipItems, data); // Initial positioning and colors\n\n        model.x = tooltipPosition.x;\n        model.y = tooltipPosition.y;\n        model.caretPadding = opts.caretPadding;\n        model.labelColors = labelColors;\n        model.labelTextColors = labelTextColors; // data points\n\n        model.dataPoints = tooltipItems; // We need to determine alignment of the tooltip\n\n        tooltipSize = getTooltipSize(this, model);\n        alignment = determineAlignment(this, tooltipSize); // Final Size and Position\n\n        backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);\n      } else {\n        model.opacity = 0;\n      }\n\n      model.xAlign = alignment.xAlign;\n      model.yAlign = alignment.yAlign;\n      model.x = backgroundPoint.x;\n      model.y = backgroundPoint.y;\n      model.width = tooltipSize.width;\n      model.height = tooltipSize.height; // Point where the caret on the tooltip points to\n\n      model.caretX = tooltipPosition.x;\n      model.caretY = tooltipPosition.y;\n      me._model = model;\n\n      if (changed && opts.custom) {\n        opts.custom.call(me, model);\n      }\n\n      return me;\n    },\n    drawCaret: function (tooltipPoint, size) {\n      var ctx = this._chart.ctx;\n      var vm = this._view;\n      var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);\n      ctx.lineTo(caretPosition.x1, caretPosition.y1);\n      ctx.lineTo(caretPosition.x2, caretPosition.y2);\n      ctx.lineTo(caretPosition.x3, caretPosition.y3);\n    },\n    getCaretPosition: function (tooltipPoint, size, vm) {\n      var x1, x2, x3, y1, y2, y3;\n      var caretSize = vm.caretSize;\n      var cornerRadius = vm.cornerRadius;\n      var xAlign = vm.xAlign;\n      var yAlign = vm.yAlign;\n      var ptX = tooltipPoint.x;\n      var ptY = tooltipPoint.y;\n      var width = size.width;\n      var height = size.height;\n\n      if (yAlign === 'center') {\n        y2 = ptY + height / 2;\n\n        if (xAlign === 'left') {\n          x1 = ptX;\n          x2 = x1 - caretSize;\n          x3 = x1;\n          y1 = y2 + caretSize;\n          y3 = y2 - caretSize;\n        } else {\n          x1 = ptX + width;\n          x2 = x1 + caretSize;\n          x3 = x1;\n          y1 = y2 - caretSize;\n          y3 = y2 + caretSize;\n        }\n      } else {\n        if (xAlign === 'left') {\n          x2 = ptX + cornerRadius + caretSize;\n          x1 = x2 - caretSize;\n          x3 = x2 + caretSize;\n        } else if (xAlign === 'right') {\n          x2 = ptX + width - cornerRadius - caretSize;\n          x1 = x2 - caretSize;\n          x3 = x2 + caretSize;\n        } else {\n          x2 = vm.caretX;\n          x1 = x2 - caretSize;\n          x3 = x2 + caretSize;\n        }\n\n        if (yAlign === 'top') {\n          y1 = ptY;\n          y2 = y1 - caretSize;\n          y3 = y1;\n        } else {\n          y1 = ptY + height;\n          y2 = y1 + caretSize;\n          y3 = y1; // invert drawing order\n\n          var tmp = x3;\n          x3 = x1;\n          x1 = tmp;\n        }\n      }\n\n      return {\n        x1: x1,\n        x2: x2,\n        x3: x3,\n        y1: y1,\n        y2: y2,\n        y3: y3\n      };\n    },\n    drawTitle: function (pt, vm, ctx) {\n      var title = vm.title;\n      var length = title.length;\n      var titleFontSize, titleSpacing, i;\n\n      if (length) {\n        var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);\n        pt.x = getAlignedX(vm, vm._titleAlign);\n        ctx.textAlign = rtlHelper.textAlign(vm._titleAlign);\n        ctx.textBaseline = 'middle';\n        titleFontSize = vm.titleFontSize;\n        titleSpacing = vm.titleSpacing;\n        ctx.fillStyle = vm.titleFontColor;\n        ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n\n        for (i = 0; i < length; ++i) {\n          ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFontSize / 2);\n          pt.y += titleFontSize + titleSpacing; // Line Height and spacing\n\n          if (i + 1 === length) {\n            pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n          }\n        }\n      }\n    },\n    drawBody: function (pt, vm, ctx) {\n      var bodyFontSize = vm.bodyFontSize;\n      var bodySpacing = vm.bodySpacing;\n      var bodyAlign = vm._bodyAlign;\n      var body = vm.body;\n      var drawColorBoxes = vm.displayColors;\n      var xLinePadding = 0;\n      var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;\n      var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);\n\n      var fillLineOfText = function (line) {\n        ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyFontSize / 2);\n        pt.y += bodyFontSize + bodySpacing;\n      };\n\n      var bodyItem, textColor, labelColors, lines, i, j, ilen, jlen;\n      var bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n      ctx.textAlign = bodyAlign;\n      ctx.textBaseline = 'middle';\n      ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n      pt.x = getAlignedX(vm, bodyAlignForCalculation); // Before body lines\n\n      ctx.fillStyle = vm.bodyFontColor;\n      helpers$1.each(vm.beforeBody, fillLineOfText);\n      xLinePadding = drawColorBoxes && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0; // Draw body lines now\n\n      for (i = 0, ilen = body.length; i < ilen; ++i) {\n        bodyItem = body[i];\n        textColor = vm.labelTextColors[i];\n        labelColors = vm.labelColors[i];\n        ctx.fillStyle = textColor;\n        helpers$1.each(bodyItem.before, fillLineOfText);\n        lines = bodyItem.lines;\n\n        for (j = 0, jlen = lines.length; j < jlen; ++j) {\n          // Draw Legend-like boxes if needed\n          if (drawColorBoxes) {\n            var rtlColorX = rtlHelper.x(colorX); // Fill a white rect so that colours merge nicely if the opacity is < 1\n\n            ctx.fillStyle = vm.legendColorBackground;\n            ctx.fillRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize); // Border\n\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = labelColors.borderColor;\n            ctx.strokeRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize); // Inner square\n\n            ctx.fillStyle = labelColors.backgroundColor;\n            ctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), bodyFontSize - 2), pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n            ctx.fillStyle = textColor;\n          }\n\n          fillLineOfText(lines[j]);\n        }\n\n        helpers$1.each(bodyItem.after, fillLineOfText);\n      } // Reset back to 0 for after body\n\n\n      xLinePadding = 0; // After body lines\n\n      helpers$1.each(vm.afterBody, fillLineOfText);\n      pt.y -= bodySpacing; // Remove last body spacing\n    },\n    drawFooter: function (pt, vm, ctx) {\n      var footer = vm.footer;\n      var length = footer.length;\n      var footerFontSize, i;\n\n      if (length) {\n        var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);\n        pt.x = getAlignedX(vm, vm._footerAlign);\n        pt.y += vm.footerMarginTop;\n        ctx.textAlign = rtlHelper.textAlign(vm._footerAlign);\n        ctx.textBaseline = 'middle';\n        footerFontSize = vm.footerFontSize;\n        ctx.fillStyle = vm.footerFontColor;\n        ctx.font = helpers$1.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n\n        for (i = 0; i < length; ++i) {\n          ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFontSize / 2);\n          pt.y += footerFontSize + vm.footerSpacing;\n        }\n      }\n    },\n    drawBackground: function (pt, vm, ctx, tooltipSize) {\n      ctx.fillStyle = vm.backgroundColor;\n      ctx.strokeStyle = vm.borderColor;\n      ctx.lineWidth = vm.borderWidth;\n      var xAlign = vm.xAlign;\n      var yAlign = vm.yAlign;\n      var x = pt.x;\n      var y = pt.y;\n      var width = tooltipSize.width;\n      var height = tooltipSize.height;\n      var radius = vm.cornerRadius;\n      ctx.beginPath();\n      ctx.moveTo(x + radius, y);\n\n      if (yAlign === 'top') {\n        this.drawCaret(pt, tooltipSize);\n      }\n\n      ctx.lineTo(x + width - radius, y);\n      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\n      if (yAlign === 'center' && xAlign === 'right') {\n        this.drawCaret(pt, tooltipSize);\n      }\n\n      ctx.lineTo(x + width, y + height - radius);\n      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\n      if (yAlign === 'bottom') {\n        this.drawCaret(pt, tooltipSize);\n      }\n\n      ctx.lineTo(x + radius, y + height);\n      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\n      if (yAlign === 'center' && xAlign === 'left') {\n        this.drawCaret(pt, tooltipSize);\n      }\n\n      ctx.lineTo(x, y + radius);\n      ctx.quadraticCurveTo(x, y, x + radius, y);\n      ctx.closePath();\n      ctx.fill();\n\n      if (vm.borderWidth > 0) {\n        ctx.stroke();\n      }\n    },\n    draw: function () {\n      var ctx = this._chart.ctx;\n      var vm = this._view;\n\n      if (vm.opacity === 0) {\n        return;\n      }\n\n      var tooltipSize = {\n        width: vm.width,\n        height: vm.height\n      };\n      var pt = {\n        x: vm.x,\n        y: vm.y\n      }; // IE11/Edge does not like very small opacities, so snap to 0\n\n      var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity; // Truthy/falsey value for empty tooltip\n\n      var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;\n\n      if (this._options.enabled && hasTooltipContent) {\n        ctx.save();\n        ctx.globalAlpha = opacity; // Draw Background\n\n        this.drawBackground(pt, vm, ctx, tooltipSize); // Draw Title, Body, and Footer\n\n        pt.y += vm.yPadding;\n        helpers$1.rtl.overrideTextDirection(ctx, vm.textDirection); // Titles\n\n        this.drawTitle(pt, vm, ctx); // Body\n\n        this.drawBody(pt, vm, ctx); // Footer\n\n        this.drawFooter(pt, vm, ctx);\n        helpers$1.rtl.restoreTextDirection(ctx, vm.textDirection);\n        ctx.restore();\n      }\n    },\n\n    /**\n     * Handle an event\n     * @private\n     * @param {IEvent} event - The event to handle\n     * @returns {boolean} true if the tooltip changed\n     */\n    handleEvent: function (e) {\n      var me = this;\n      var options = me._options;\n      var changed = false;\n      me._lastActive = me._lastActive || []; // Find Active Elements for tooltips\n\n      if (e.type === 'mouseout') {\n        me._active = [];\n      } else {\n        me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);\n\n        if (options.reverse) {\n          me._active.reverse();\n        }\n      } // Remember Last Actives\n\n\n      changed = !helpers$1.arrayEquals(me._active, me._lastActive); // Only handle target event on tooltip change\n\n      if (changed) {\n        me._lastActive = me._active;\n\n        if (options.enabled || options.custom) {\n          me._eventPosition = {\n            x: e.x,\n            y: e.y\n          };\n          me.update(true);\n          me.pivot();\n        }\n      }\n\n      return changed;\n    }\n  });\n  /**\n   * @namespace Chart.Tooltip.positioners\n   */\n\n  var positioners_1 = positioners;\n  var core_tooltip = exports$4;\n  core_tooltip.positioners = positioners_1;\n  var valueOrDefault$9 = helpers$1.valueOrDefault;\n\n  core_defaults._set('global', {\n    elements: {},\n    events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],\n    hover: {\n      onHover: null,\n      mode: 'nearest',\n      intersect: true,\n      animationDuration: 400\n    },\n    onClick: null,\n    maintainAspectRatio: true,\n    responsive: true,\n    responsiveAnimationDuration: 0\n  });\n  /**\n   * Recursively merge the given config objects representing the `scales` option\n   * by incorporating scale defaults in `xAxes` and `yAxes` array items, then\n   * returns a deep copy of the result, thus doesn't alter inputs.\n   */\n\n\n  function mergeScaleConfig() {\n    return helpers$1.merge({}, [].slice.call(arguments), {\n      merger: function (key, target, source, options) {\n        if (key === 'xAxes' || key === 'yAxes') {\n          var slen = source[key].length;\n          var i, type, scale;\n\n          if (!target[key]) {\n            target[key] = [];\n          }\n\n          for (i = 0; i < slen; ++i) {\n            scale = source[key][i];\n            type = valueOrDefault$9(scale.type, key === 'xAxes' ? 'category' : 'linear');\n\n            if (i >= target[key].length) {\n              target[key].push({});\n            }\n\n            if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {\n              // new/untyped scale or type changed: let's apply the new defaults\n              // then merge source scale to correctly overwrite the defaults.\n              helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);\n            } else {\n              // scales type are the same\n              helpers$1.merge(target[key][i], scale);\n            }\n          }\n        } else {\n          helpers$1._merger(key, target, source, options);\n        }\n      }\n    });\n  }\n  /**\n   * Recursively merge the given config objects as the root options by handling\n   * default scale options for the `scales` and `scale` properties, then returns\n   * a deep copy of the result, thus doesn't alter inputs.\n   */\n\n\n  function mergeConfig() {\n    return helpers$1.merge({}, [].slice.call(arguments), {\n      merger: function (key, target, source, options) {\n        var tval = target[key] || {};\n        var sval = source[key];\n\n        if (key === 'scales') {\n          // scale config merging is complex. Add our own function here for that\n          target[key] = mergeScaleConfig(tval, sval);\n        } else if (key === 'scale') {\n          // used in polar area & radar charts since there is only one scale\n          target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);\n        } else {\n          helpers$1._merger(key, target, source, options);\n        }\n      }\n    });\n  }\n\n  function initConfig(config) {\n    config = config || {}; // Do NOT use mergeConfig for the data object because this method merges arrays\n    // and so would change references to labels and datasets, preventing data updates.\n\n    var data = config.data = config.data || {};\n    data.datasets = data.datasets || [];\n    data.labels = data.labels || [];\n    config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});\n    return config;\n  }\n\n  function updateConfig(chart) {\n    var newOptions = chart.options;\n    helpers$1.each(chart.scales, function (scale) {\n      core_layouts.removeBox(chart, scale);\n    });\n    newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);\n    chart.options = chart.config.options = newOptions;\n    chart.ensureScalesHaveIDs();\n    chart.buildOrUpdateScales(); // Tooltip\n\n    chart.tooltip._options = newOptions.tooltips;\n    chart.tooltip.initialize();\n  }\n\n  function nextAvailableScaleId(axesOpts, prefix, index) {\n    var id;\n\n    var hasId = function (obj) {\n      return obj.id === id;\n    };\n\n    do {\n      id = prefix + index++;\n    } while (helpers$1.findIndex(axesOpts, hasId) >= 0);\n\n    return id;\n  }\n\n  function positionIsHorizontal(position) {\n    return position === 'top' || position === 'bottom';\n  }\n\n  function compare2Level(l1, l2) {\n    return function (a, b) {\n      return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n    };\n  }\n\n  var Chart = function (item, config) {\n    this.construct(item, config);\n    return this;\n  };\n\n  helpers$1.extend(Chart.prototype,\n  /** @lends Chart */\n  {\n    /**\n     * @private\n     */\n    construct: function (item, config) {\n      var me = this;\n      config = initConfig(config);\n      var context = platform.acquireContext(item, config);\n      var canvas = context && context.canvas;\n      var height = canvas && canvas.height;\n      var width = canvas && canvas.width;\n      me.id = helpers$1.uid();\n      me.ctx = context;\n      me.canvas = canvas;\n      me.config = config;\n      me.width = width;\n      me.height = height;\n      me.aspectRatio = height ? width / height : null;\n      me.options = config.options;\n      me._bufferedRender = false;\n      me._layers = [];\n      /**\n       * Provided for backward compatibility, Chart and Chart.Controller have been merged,\n       * the \"instance\" still need to be defined since it might be called from plugins.\n       * @prop Chart#chart\n       * @deprecated since version 2.6.0\n       * @todo remove at version 3\n       * @private\n       */\n\n      me.chart = me;\n      me.controller = me; // chart.chart.controller #inception\n      // Add the chart instance to the global namespace\n\n      Chart.instances[me.id] = me; // Define alias to the config data: `chart.data === chart.config.data`\n\n      Object.defineProperty(me, 'data', {\n        get: function () {\n          return me.config.data;\n        },\n        set: function (value) {\n          me.config.data = value;\n        }\n      });\n\n      if (!context || !canvas) {\n        // The given item is not a compatible context2d element, let's return before finalizing\n        // the chart initialization but after setting basic chart / controller properties that\n        // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n        // https://github.com/chartjs/Chart.js/issues/2807\n        console.error(\"Failed to create chart: can't acquire context from the given item\");\n        return;\n      }\n\n      me.initialize();\n      me.update();\n    },\n\n    /**\n     * @private\n     */\n    initialize: function () {\n      var me = this; // Before init plugin notification\n\n      core_plugins.notify(me, 'beforeInit');\n      helpers$1.retinaScale(me, me.options.devicePixelRatio);\n      me.bindEvents();\n\n      if (me.options.responsive) {\n        // Initial resize before chart draws (must be silent to preserve initial animations).\n        me.resize(true);\n      }\n\n      me.initToolTip(); // After init plugin notification\n\n      core_plugins.notify(me, 'afterInit');\n      return me;\n    },\n    clear: function () {\n      helpers$1.canvas.clear(this);\n      return this;\n    },\n    stop: function () {\n      // Stops any current animation loop occurring\n      core_animations.cancelAnimation(this);\n      return this;\n    },\n    resize: function (silent) {\n      var me = this;\n      var options = me.options;\n      var canvas = me.canvas;\n      var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null; // the canvas render width and height will be casted to integers so make sure that\n      // the canvas display style uses the same integer values to avoid blurring effect.\n      // Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed\n\n      var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));\n      var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));\n\n      if (me.width === newWidth && me.height === newHeight) {\n        return;\n      }\n\n      canvas.width = me.width = newWidth;\n      canvas.height = me.height = newHeight;\n      canvas.style.width = newWidth + 'px';\n      canvas.style.height = newHeight + 'px';\n      helpers$1.retinaScale(me, options.devicePixelRatio);\n\n      if (!silent) {\n        // Notify any plugins about the resize\n        var newSize = {\n          width: newWidth,\n          height: newHeight\n        };\n        core_plugins.notify(me, 'resize', [newSize]); // Notify of resize\n\n        if (options.onResize) {\n          options.onResize(me, newSize);\n        }\n\n        me.stop();\n        me.update({\n          duration: options.responsiveAnimationDuration\n        });\n      }\n    },\n    ensureScalesHaveIDs: function () {\n      var options = this.options;\n      var scalesOptions = options.scales || {};\n      var scaleOptions = options.scale;\n      helpers$1.each(scalesOptions.xAxes, function (xAxisOptions, index) {\n        if (!xAxisOptions.id) {\n          xAxisOptions.id = nextAvailableScaleId(scalesOptions.xAxes, 'x-axis-', index);\n        }\n      });\n      helpers$1.each(scalesOptions.yAxes, function (yAxisOptions, index) {\n        if (!yAxisOptions.id) {\n          yAxisOptions.id = nextAvailableScaleId(scalesOptions.yAxes, 'y-axis-', index);\n        }\n      });\n\n      if (scaleOptions) {\n        scaleOptions.id = scaleOptions.id || 'scale';\n      }\n    },\n\n    /**\n     * Builds a map of scale ID to scale object for future lookup.\n     */\n    buildOrUpdateScales: function () {\n      var me = this;\n      var options = me.options;\n      var scales = me.scales || {};\n      var items = [];\n      var updated = Object.keys(scales).reduce(function (obj, id) {\n        obj[id] = false;\n        return obj;\n      }, {});\n\n      if (options.scales) {\n        items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {\n          return {\n            options: xAxisOptions,\n            dtype: 'category',\n            dposition: 'bottom'\n          };\n        }), (options.scales.yAxes || []).map(function (yAxisOptions) {\n          return {\n            options: yAxisOptions,\n            dtype: 'linear',\n            dposition: 'left'\n          };\n        }));\n      }\n\n      if (options.scale) {\n        items.push({\n          options: options.scale,\n          dtype: 'radialLinear',\n          isDefault: true,\n          dposition: 'chartArea'\n        });\n      }\n\n      helpers$1.each(items, function (item) {\n        var scaleOptions = item.options;\n        var id = scaleOptions.id;\n        var scaleType = valueOrDefault$9(scaleOptions.type, item.dtype);\n\n        if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {\n          scaleOptions.position = item.dposition;\n        }\n\n        updated[id] = true;\n        var scale = null;\n\n        if (id in scales && scales[id].type === scaleType) {\n          scale = scales[id];\n          scale.options = scaleOptions;\n          scale.ctx = me.ctx;\n          scale.chart = me;\n        } else {\n          var scaleClass = core_scaleService.getScaleConstructor(scaleType);\n\n          if (!scaleClass) {\n            return;\n          }\n\n          scale = new scaleClass({\n            id: id,\n            type: scaleType,\n            options: scaleOptions,\n            ctx: me.ctx,\n            chart: me\n          });\n          scales[scale.id] = scale;\n        }\n\n        scale.mergeTicksOptions(); // TODO(SB): I think we should be able to remove this custom case (options.scale)\n        // and consider it as a regular scale part of the \"scales\"\" map only! This would\n        // make the logic easier and remove some useless? custom code.\n\n        if (item.isDefault) {\n          me.scale = scale;\n        }\n      }); // clear up discarded scales\n\n      helpers$1.each(updated, function (hasUpdated, id) {\n        if (!hasUpdated) {\n          delete scales[id];\n        }\n      });\n      me.scales = scales;\n      core_scaleService.addScalesToLayout(this);\n    },\n    buildOrUpdateControllers: function () {\n      var me = this;\n      var newControllers = [];\n      var datasets = me.data.datasets;\n      var i, ilen;\n\n      for (i = 0, ilen = datasets.length; i < ilen; i++) {\n        var dataset = datasets[i];\n        var meta = me.getDatasetMeta(i);\n        var type = dataset.type || me.config.type;\n\n        if (meta.type && meta.type !== type) {\n          me.destroyDatasetMeta(i);\n          meta = me.getDatasetMeta(i);\n        }\n\n        meta.type = type;\n        meta.order = dataset.order || 0;\n        meta.index = i;\n\n        if (meta.controller) {\n          meta.controller.updateIndex(i);\n          meta.controller.linkScales();\n        } else {\n          var ControllerClass = controllers[meta.type];\n\n          if (ControllerClass === undefined) {\n            throw new Error('\"' + meta.type + '\" is not a chart type.');\n          }\n\n          meta.controller = new ControllerClass(me, i);\n          newControllers.push(meta.controller);\n        }\n      }\n\n      return newControllers;\n    },\n\n    /**\n     * Reset the elements of all datasets\n     * @private\n     */\n    resetElements: function () {\n      var me = this;\n      helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {\n        me.getDatasetMeta(datasetIndex).controller.reset();\n      }, me);\n    },\n\n    /**\n    * Resets the chart back to it's state before the initial animation\n    */\n    reset: function () {\n      this.resetElements();\n      this.tooltip.initialize();\n    },\n    update: function (config) {\n      var me = this;\n      var i, ilen;\n\n      if (!config || typeof config !== 'object') {\n        // backwards compatibility\n        config = {\n          duration: config,\n          lazy: arguments[1]\n        };\n      }\n\n      updateConfig(me); // plugins options references might have change, let's invalidate the cache\n      // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n\n      core_plugins._invalidate(me);\n\n      if (core_plugins.notify(me, 'beforeUpdate') === false) {\n        return;\n      } // In case the entire data object changed\n\n\n      me.tooltip._data = me.data; // Make sure dataset controllers are updated and new controllers are reset\n\n      var newControllers = me.buildOrUpdateControllers(); // Make sure all dataset controllers have correct meta data counts\n\n      for (i = 0, ilen = me.data.datasets.length; i < ilen; i++) {\n        me.getDatasetMeta(i).controller.buildOrUpdateElements();\n      }\n\n      me.updateLayout(); // Can only reset the new controllers after the scales have been updated\n\n      if (me.options.animation && me.options.animation.duration) {\n        helpers$1.each(newControllers, function (controller) {\n          controller.reset();\n        });\n      }\n\n      me.updateDatasets(); // Need to reset tooltip in case it is displayed with elements that are removed\n      // after update.\n\n      me.tooltip.initialize(); // Last active contains items that were previously in the tooltip.\n      // When we reset the tooltip, we need to clear it\n\n      me.lastActive = []; // Do this before render so that any plugins that need final scale updates can use it\n\n      core_plugins.notify(me, 'afterUpdate');\n\n      me._layers.sort(compare2Level('z', '_idx'));\n\n      if (me._bufferedRender) {\n        me._bufferedRequest = {\n          duration: config.duration,\n          easing: config.easing,\n          lazy: config.lazy\n        };\n      } else {\n        me.render(config);\n      }\n    },\n\n    /**\n     * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n     * hook, in which case, plugins will not be called on `afterLayout`.\n     * @private\n     */\n    updateLayout: function () {\n      var me = this;\n\n      if (core_plugins.notify(me, 'beforeLayout') === false) {\n        return;\n      }\n\n      core_layouts.update(this, this.width, this.height);\n      me._layers = [];\n      helpers$1.each(me.boxes, function (box) {\n        // _configure is called twice, once in core.scale.update and once here.\n        // Here the boxes are fully updated and at their final positions.\n        if (box._configure) {\n          box._configure();\n        }\n\n        me._layers.push.apply(me._layers, box._layers());\n      }, me);\n\n      me._layers.forEach(function (item, index) {\n        item._idx = index;\n      });\n      /**\n       * Provided for backward compatibility, use `afterLayout` instead.\n       * @method IPlugin#afterScaleUpdate\n       * @deprecated since version 2.5.0\n       * @todo remove at version 3\n       * @private\n       */\n\n\n      core_plugins.notify(me, 'afterScaleUpdate');\n      core_plugins.notify(me, 'afterLayout');\n    },\n\n    /**\n     * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n     * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n     * @private\n     */\n    updateDatasets: function () {\n      var me = this;\n\n      if (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n        return;\n      }\n\n      for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n        me.updateDataset(i);\n      }\n\n      core_plugins.notify(me, 'afterDatasetsUpdate');\n    },\n\n    /**\n     * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n     * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n     * @private\n     */\n    updateDataset: function (index) {\n      var me = this;\n      var meta = me.getDatasetMeta(index);\n      var args = {\n        meta: meta,\n        index: index\n      };\n\n      if (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {\n        return;\n      }\n\n      meta.controller._update();\n\n      core_plugins.notify(me, 'afterDatasetUpdate', [args]);\n    },\n    render: function (config) {\n      var me = this;\n\n      if (!config || typeof config !== 'object') {\n        // backwards compatibility\n        config = {\n          duration: config,\n          lazy: arguments[1]\n        };\n      }\n\n      var animationOptions = me.options.animation;\n      var duration = valueOrDefault$9(config.duration, animationOptions && animationOptions.duration);\n      var lazy = config.lazy;\n\n      if (core_plugins.notify(me, 'beforeRender') === false) {\n        return;\n      }\n\n      var onComplete = function (animation) {\n        core_plugins.notify(me, 'afterRender');\n        helpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);\n      };\n\n      if (animationOptions && duration) {\n        var animation = new core_animation({\n          numSteps: duration / 16.66,\n          // 60 fps\n          easing: config.easing || animationOptions.easing,\n          render: function (chart, animationObject) {\n            var easingFunction = helpers$1.easing.effects[animationObject.easing];\n            var currentStep = animationObject.currentStep;\n            var stepDecimal = currentStep / animationObject.numSteps;\n            chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);\n          },\n          onAnimationProgress: animationOptions.onProgress,\n          onAnimationComplete: onComplete\n        });\n        core_animations.addAnimation(me, animation, duration, lazy);\n      } else {\n        me.draw(); // See https://github.com/chartjs/Chart.js/issues/3781\n\n        onComplete(new core_animation({\n          numSteps: 0,\n          chart: me\n        }));\n      }\n\n      return me;\n    },\n    draw: function (easingValue) {\n      var me = this;\n      var i, layers;\n      me.clear();\n\n      if (helpers$1.isNullOrUndef(easingValue)) {\n        easingValue = 1;\n      }\n\n      me.transition(easingValue);\n\n      if (me.width <= 0 || me.height <= 0) {\n        return;\n      }\n\n      if (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\n        return;\n      } // Because of plugin hooks (before/afterDatasetsDraw), datasets can't\n      // currently be part of layers. Instead, we draw\n      // layers <= 0 before(default, backward compat), and the rest after\n\n\n      layers = me._layers;\n\n      for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n        layers[i].draw(me.chartArea);\n      }\n\n      me.drawDatasets(easingValue); // Rest of layers\n\n      for (; i < layers.length; ++i) {\n        layers[i].draw(me.chartArea);\n      }\n\n      me._drawTooltip(easingValue);\n\n      core_plugins.notify(me, 'afterDraw', [easingValue]);\n    },\n\n    /**\n     * @private\n     */\n    transition: function (easingValue) {\n      var me = this;\n\n      for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {\n        if (me.isDatasetVisible(i)) {\n          me.getDatasetMeta(i).controller.transition(easingValue);\n        }\n      }\n\n      me.tooltip.transition(easingValue);\n    },\n\n    /**\n     * @private\n     */\n    _getSortedDatasetMetas: function (filterVisible) {\n      var me = this;\n      var datasets = me.data.datasets || [];\n      var result = [];\n      var i, ilen;\n\n      for (i = 0, ilen = datasets.length; i < ilen; ++i) {\n        if (!filterVisible || me.isDatasetVisible(i)) {\n          result.push(me.getDatasetMeta(i));\n        }\n      }\n\n      result.sort(compare2Level('order', 'index'));\n      return result;\n    },\n\n    /**\n     * @private\n     */\n    _getSortedVisibleDatasetMetas: function () {\n      return this._getSortedDatasetMetas(true);\n    },\n\n    /**\n     * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n     * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n     * @private\n     */\n    drawDatasets: function (easingValue) {\n      var me = this;\n      var metasets, i;\n\n      if (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\n        return;\n      }\n\n      metasets = me._getSortedVisibleDatasetMetas();\n\n      for (i = metasets.length - 1; i >= 0; --i) {\n        me.drawDataset(metasets[i], easingValue);\n      }\n\n      core_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);\n    },\n\n    /**\n     * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n     * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n     * @private\n     */\n    drawDataset: function (meta, easingValue) {\n      var me = this;\n      var args = {\n        meta: meta,\n        index: meta.index,\n        easingValue: easingValue\n      };\n\n      if (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\n        return;\n      }\n\n      meta.controller.draw(easingValue);\n      core_plugins.notify(me, 'afterDatasetDraw', [args]);\n    },\n\n    /**\n     * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`\n     * hook, in which case, plugins will not be called on `afterTooltipDraw`.\n     * @private\n     */\n    _drawTooltip: function (easingValue) {\n      var me = this;\n      var tooltip = me.tooltip;\n      var args = {\n        tooltip: tooltip,\n        easingValue: easingValue\n      };\n\n      if (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {\n        return;\n      }\n\n      tooltip.draw();\n      core_plugins.notify(me, 'afterTooltipDraw', [args]);\n    },\n\n    /**\n     * Get the single element that was clicked on\n     * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\n     */\n    getElementAtEvent: function (e) {\n      return core_interaction.modes.single(this, e);\n    },\n    getElementsAtEvent: function (e) {\n      return core_interaction.modes.label(this, e, {\n        intersect: true\n      });\n    },\n    getElementsAtXAxis: function (e) {\n      return core_interaction.modes['x-axis'](this, e, {\n        intersect: true\n      });\n    },\n    getElementsAtEventForMode: function (e, mode, options) {\n      var method = core_interaction.modes[mode];\n\n      if (typeof method === 'function') {\n        return method(this, e, options);\n      }\n\n      return [];\n    },\n    getDatasetAtEvent: function (e) {\n      return core_interaction.modes.dataset(this, e, {\n        intersect: true\n      });\n    },\n    getDatasetMeta: function (datasetIndex) {\n      var me = this;\n      var dataset = me.data.datasets[datasetIndex];\n\n      if (!dataset._meta) {\n        dataset._meta = {};\n      }\n\n      var meta = dataset._meta[me.id];\n\n      if (!meta) {\n        meta = dataset._meta[me.id] = {\n          type: null,\n          data: [],\n          dataset: null,\n          controller: null,\n          hidden: null,\n          // See isDatasetVisible() comment\n          xAxisID: null,\n          yAxisID: null,\n          order: dataset.order || 0,\n          index: datasetIndex\n        };\n      }\n\n      return meta;\n    },\n    getVisibleDatasetCount: function () {\n      var count = 0;\n\n      for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n        if (this.isDatasetVisible(i)) {\n          count++;\n        }\n      }\n\n      return count;\n    },\n    isDatasetVisible: function (datasetIndex) {\n      var meta = this.getDatasetMeta(datasetIndex); // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n      // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n\n      return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n    },\n    generateLegend: function () {\n      return this.options.legendCallback(this);\n    },\n\n    /**\n     * @private\n     */\n    destroyDatasetMeta: function (datasetIndex) {\n      var id = this.id;\n      var dataset = this.data.datasets[datasetIndex];\n      var meta = dataset._meta && dataset._meta[id];\n\n      if (meta) {\n        meta.controller.destroy();\n        delete dataset._meta[id];\n      }\n    },\n    destroy: function () {\n      var me = this;\n      var canvas = me.canvas;\n      var i, ilen;\n      me.stop(); // dataset controllers need to cleanup associated data\n\n      for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n        me.destroyDatasetMeta(i);\n      }\n\n      if (canvas) {\n        me.unbindEvents();\n        helpers$1.canvas.clear(me);\n        platform.releaseContext(me.ctx);\n        me.canvas = null;\n        me.ctx = null;\n      }\n\n      core_plugins.notify(me, 'destroy');\n      delete Chart.instances[me.id];\n    },\n    toBase64Image: function () {\n      return this.canvas.toDataURL.apply(this.canvas, arguments);\n    },\n    initToolTip: function () {\n      var me = this;\n      me.tooltip = new core_tooltip({\n        _chart: me,\n        _chartInstance: me,\n        // deprecated, backward compatibility\n        _data: me.data,\n        _options: me.options.tooltips\n      }, me);\n    },\n\n    /**\n     * @private\n     */\n    bindEvents: function () {\n      var me = this;\n      var listeners = me._listeners = {};\n\n      var listener = function () {\n        me.eventHandler.apply(me, arguments);\n      };\n\n      helpers$1.each(me.options.events, function (type) {\n        platform.addEventListener(me, type, listener);\n        listeners[type] = listener;\n      }); // Elements used to detect size change should not be injected for non responsive charts.\n      // See https://github.com/chartjs/Chart.js/issues/2210\n\n      if (me.options.responsive) {\n        listener = function () {\n          me.resize();\n        };\n\n        platform.addEventListener(me, 'resize', listener);\n        listeners.resize = listener;\n      }\n    },\n\n    /**\n     * @private\n     */\n    unbindEvents: function () {\n      var me = this;\n      var listeners = me._listeners;\n\n      if (!listeners) {\n        return;\n      }\n\n      delete me._listeners;\n      helpers$1.each(listeners, function (listener, type) {\n        platform.removeEventListener(me, type, listener);\n      });\n    },\n    updateHoverStyle: function (elements, mode, enabled) {\n      var prefix = enabled ? 'set' : 'remove';\n      var element, i, ilen;\n\n      for (i = 0, ilen = elements.length; i < ilen; ++i) {\n        element = elements[i];\n\n        if (element) {\n          this.getDatasetMeta(element._datasetIndex).controller[prefix + 'HoverStyle'](element);\n        }\n      }\n\n      if (mode === 'dataset') {\n        this.getDatasetMeta(elements[0]._datasetIndex).controller['_' + prefix + 'DatasetHoverStyle']();\n      }\n    },\n\n    /**\n     * @private\n     */\n    eventHandler: function (e) {\n      var me = this;\n      var tooltip = me.tooltip;\n\n      if (core_plugins.notify(me, 'beforeEvent', [e]) === false) {\n        return;\n      } // Buffer any update calls so that renders do not occur\n\n\n      me._bufferedRender = true;\n      me._bufferedRequest = null;\n      var changed = me.handleEvent(e); // for smooth tooltip animations issue #4989\n      // the tooltip should be the source of change\n      // Animation check workaround:\n      // tooltip._start will be null when tooltip isn't animating\n\n      if (tooltip) {\n        changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);\n      }\n\n      core_plugins.notify(me, 'afterEvent', [e]);\n      var bufferedRequest = me._bufferedRequest;\n\n      if (bufferedRequest) {\n        // If we have an update that was triggered, we need to do a normal render\n        me.render(bufferedRequest);\n      } else if (changed && !me.animating) {\n        // If entering, leaving, or changing elements, animate the change via pivot\n        me.stop(); // We only need to render at this point. Updating will cause scales to be\n        // recomputed generating flicker & using more memory than necessary.\n\n        me.render({\n          duration: me.options.hover.animationDuration,\n          lazy: true\n        });\n      }\n\n      me._bufferedRender = false;\n      me._bufferedRequest = null;\n      return me;\n    },\n\n    /**\n     * Handle an event\n     * @private\n     * @param {IEvent} event the event to handle\n     * @return {boolean} true if the chart needs to re-render\n     */\n    handleEvent: function (e) {\n      var me = this;\n      var options = me.options || {};\n      var hoverOptions = options.hover;\n      var changed = false;\n      me.lastActive = me.lastActive || []; // Find Active Elements for hover and tooltips\n\n      if (e.type === 'mouseout') {\n        me.active = [];\n      } else {\n        me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\n      } // Invoke onHover hook\n      // Need to call with native event here to not break backwards compatibility\n\n\n      helpers$1.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);\n\n      if (e.type === 'mouseup' || e.type === 'click') {\n        if (options.onClick) {\n          // Use e.native here for backwards compatibility\n          options.onClick.call(me, e.native, me.active);\n        }\n      } // Remove styling for last active (even if it may still be active)\n\n\n      if (me.lastActive.length) {\n        me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n      } // Built in hover styling\n\n\n      if (me.active.length && hoverOptions.mode) {\n        me.updateHoverStyle(me.active, hoverOptions.mode, true);\n      }\n\n      changed = !helpers$1.arrayEquals(me.active, me.lastActive); // Remember Last Actives\n\n      me.lastActive = me.active;\n      return changed;\n    }\n  });\n  /**\n   * NOTE(SB) We actually don't use this container anymore but we need to keep it\n   * for backward compatibility. Though, it can still be useful for plugins that\n   * would need to work on multiple charts?!\n   */\n\n  Chart.instances = {};\n  var core_controller = Chart; // DEPRECATIONS\n\n  /**\n   * Provided for backward compatibility, use Chart instead.\n   * @class Chart.Controller\n   * @deprecated since version 2.6\n   * @todo remove at version 3\n   * @private\n   */\n\n  Chart.Controller = Chart;\n  /**\n   * Provided for backward compatibility, not available anymore.\n   * @namespace Chart\n   * @deprecated since version 2.8\n   * @todo remove at version 3\n   * @private\n   */\n\n  Chart.types = {};\n  /**\n   * Provided for backward compatibility, not available anymore.\n   * @namespace Chart.helpers.configMerge\n   * @deprecated since version 2.8.0\n   * @todo remove at version 3\n   * @private\n   */\n\n  helpers$1.configMerge = mergeConfig;\n  /**\n   * Provided for backward compatibility, not available anymore.\n   * @namespace Chart.helpers.scaleMerge\n   * @deprecated since version 2.8.0\n   * @todo remove at version 3\n   * @private\n   */\n\n  helpers$1.scaleMerge = mergeScaleConfig;\n\n  var core_helpers = function () {\n    // -- Basic js utility methods\n    helpers$1.where = function (collection, filterCallback) {\n      if (helpers$1.isArray(collection) && Array.prototype.filter) {\n        return collection.filter(filterCallback);\n      }\n\n      var filtered = [];\n      helpers$1.each(collection, function (item) {\n        if (filterCallback(item)) {\n          filtered.push(item);\n        }\n      });\n      return filtered;\n    };\n\n    helpers$1.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {\n      return array.findIndex(callback, scope);\n    } : function (array, callback, scope) {\n      scope = scope === undefined ? array : scope;\n\n      for (var i = 0, ilen = array.length; i < ilen; ++i) {\n        if (callback.call(scope, array[i], i, array)) {\n          return i;\n        }\n      }\n\n      return -1;\n    };\n\n    helpers$1.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {\n      // Default to start of the array\n      if (helpers$1.isNullOrUndef(startIndex)) {\n        startIndex = -1;\n      }\n\n      for (var i = startIndex + 1; i < arrayToSearch.length; i++) {\n        var currentItem = arrayToSearch[i];\n\n        if (filterCallback(currentItem)) {\n          return currentItem;\n        }\n      }\n    };\n\n    helpers$1.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {\n      // Default to end of the array\n      if (helpers$1.isNullOrUndef(startIndex)) {\n        startIndex = arrayToSearch.length;\n      }\n\n      for (var i = startIndex - 1; i >= 0; i--) {\n        var currentItem = arrayToSearch[i];\n\n        if (filterCallback(currentItem)) {\n          return currentItem;\n        }\n      }\n    }; // -- Math methods\n\n\n    helpers$1.isNumber = function (n) {\n      return !isNaN(parseFloat(n)) && isFinite(n);\n    };\n\n    helpers$1.almostEquals = function (x, y, epsilon) {\n      return Math.abs(x - y) < epsilon;\n    };\n\n    helpers$1.almostWhole = function (x, epsilon) {\n      var rounded = Math.round(x);\n      return rounded - epsilon <= x && rounded + epsilon >= x;\n    };\n\n    helpers$1.max = function (array) {\n      return array.reduce(function (max, value) {\n        if (!isNaN(value)) {\n          return Math.max(max, value);\n        }\n\n        return max;\n      }, Number.NEGATIVE_INFINITY);\n    };\n\n    helpers$1.min = function (array) {\n      return array.reduce(function (min, value) {\n        if (!isNaN(value)) {\n          return Math.min(min, value);\n        }\n\n        return min;\n      }, Number.POSITIVE_INFINITY);\n    };\n\n    helpers$1.sign = Math.sign ? function (x) {\n      return Math.sign(x);\n    } : function (x) {\n      x = +x; // convert to a number\n\n      if (x === 0 || isNaN(x)) {\n        return x;\n      }\n\n      return x > 0 ? 1 : -1;\n    };\n\n    helpers$1.toRadians = function (degrees) {\n      return degrees * (Math.PI / 180);\n    };\n\n    helpers$1.toDegrees = function (radians) {\n      return radians * (180 / Math.PI);\n    };\n    /**\n     * Returns the number of decimal places\n     * i.e. the number of digits after the decimal point, of the value of this Number.\n     * @param {number} x - A number.\n     * @returns {number} The number of decimal places.\n     * @private\n     */\n\n\n    helpers$1._decimalPlaces = function (x) {\n      if (!helpers$1.isFinite(x)) {\n        return;\n      }\n\n      var e = 1;\n      var p = 0;\n\n      while (Math.round(x * e) / e !== x) {\n        e *= 10;\n        p++;\n      }\n\n      return p;\n    }; // Gets the angle from vertical upright to the point about a centre.\n\n\n    helpers$1.getAngleFromPoint = function (centrePoint, anglePoint) {\n      var distanceFromXCenter = anglePoint.x - centrePoint.x;\n      var distanceFromYCenter = anglePoint.y - centrePoint.y;\n      var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n      var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n      if (angle < -0.5 * Math.PI) {\n        angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n      }\n\n      return {\n        angle: angle,\n        distance: radialDistanceFromCenter\n      };\n    };\n\n    helpers$1.distanceBetweenPoints = function (pt1, pt2) {\n      return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n    };\n    /**\n     * Provided for backward compatibility, not available anymore\n     * @function Chart.helpers.aliasPixel\n     * @deprecated since version 2.8.0\n     * @todo remove at version 3\n     */\n\n\n    helpers$1.aliasPixel = function (pixelWidth) {\n      return pixelWidth % 2 === 0 ? 0 : 0.5;\n    };\n    /**\n     * Returns the aligned pixel value to avoid anti-aliasing blur\n     * @param {Chart} chart - The chart instance.\n     * @param {number} pixel - A pixel value.\n     * @param {number} width - The width of the element.\n     * @returns {number} The aligned pixel value.\n     * @private\n     */\n\n\n    helpers$1._alignPixel = function (chart, pixel, width) {\n      var devicePixelRatio = chart.currentDevicePixelRatio;\n      var halfWidth = width / 2;\n      return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n    };\n\n    helpers$1.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {\n      // Props to Rob Spencer at scaled innovation for his post on splining between points\n      // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n      // This function must also respect \"skipped\" points\n      var previous = firstPoint.skip ? middlePoint : firstPoint;\n      var current = middlePoint;\n      var next = afterPoint.skip ? middlePoint : afterPoint;\n      var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n      var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n      var s01 = d01 / (d01 + d12);\n      var s12 = d12 / (d01 + d12); // If all points are the same, s01 & s02 will be inf\n\n      s01 = isNaN(s01) ? 0 : s01;\n      s12 = isNaN(s12) ? 0 : s12;\n      var fa = t * s01; // scaling factor for triangle Ta\n\n      var fb = t * s12;\n      return {\n        previous: {\n          x: current.x - fa * (next.x - previous.x),\n          y: current.y - fa * (next.y - previous.y)\n        },\n        next: {\n          x: current.x + fb * (next.x - previous.x),\n          y: current.y + fb * (next.y - previous.y)\n        }\n      };\n    };\n\n    helpers$1.EPSILON = Number.EPSILON || 1e-14;\n\n    helpers$1.splineCurveMonotone = function (points) {\n      // This function calculates Bézier control points in a similar way than |splineCurve|,\n      // but preserves monotonicity of the provided data and ensures no local extremums are added\n      // between the dataset discrete points due to the interpolation.\n      // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n      var pointsWithTangents = (points || []).map(function (point) {\n        return {\n          model: point._model,\n          deltaK: 0,\n          mK: 0\n        };\n      }); // Calculate slopes (deltaK) and initialize tangents (mK)\n\n      var pointsLen = pointsWithTangents.length;\n      var i, pointBefore, pointCurrent, pointAfter;\n\n      for (i = 0; i < pointsLen; ++i) {\n        pointCurrent = pointsWithTangents[i];\n\n        if (pointCurrent.model.skip) {\n          continue;\n        }\n\n        pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n        pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\n        if (pointAfter && !pointAfter.model.skip) {\n          var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x; // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n\n          pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\n        }\n\n        if (!pointBefore || pointBefore.model.skip) {\n          pointCurrent.mK = pointCurrent.deltaK;\n        } else if (!pointAfter || pointAfter.model.skip) {\n          pointCurrent.mK = pointBefore.deltaK;\n        } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\n          pointCurrent.mK = 0;\n        } else {\n          pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n        }\n      } // Adjust tangents to ensure monotonic properties\n\n\n      var alphaK, betaK, tauK, squaredMagnitude;\n\n      for (i = 0; i < pointsLen - 1; ++i) {\n        pointCurrent = pointsWithTangents[i];\n        pointAfter = pointsWithTangents[i + 1];\n\n        if (pointCurrent.model.skip || pointAfter.model.skip) {\n          continue;\n        }\n\n        if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\n          pointCurrent.mK = pointAfter.mK = 0;\n          continue;\n        }\n\n        alphaK = pointCurrent.mK / pointCurrent.deltaK;\n        betaK = pointAfter.mK / pointCurrent.deltaK;\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\n        if (squaredMagnitude <= 9) {\n          continue;\n        }\n\n        tauK = 3 / Math.sqrt(squaredMagnitude);\n        pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n        pointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n      } // Compute control points\n\n\n      var deltaX;\n\n      for (i = 0; i < pointsLen; ++i) {\n        pointCurrent = pointsWithTangents[i];\n\n        if (pointCurrent.model.skip) {\n          continue;\n        }\n\n        pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n        pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\n        if (pointBefore && !pointBefore.model.skip) {\n          deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n          pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n          pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n        }\n\n        if (pointAfter && !pointAfter.model.skip) {\n          deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n          pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n          pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n        }\n      }\n    };\n\n    helpers$1.nextItem = function (collection, index, loop) {\n      if (loop) {\n        return index >= collection.length - 1 ? collection[0] : collection[index + 1];\n      }\n\n      return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\n    };\n\n    helpers$1.previousItem = function (collection, index, loop) {\n      if (loop) {\n        return index <= 0 ? collection[collection.length - 1] : collection[index - 1];\n      }\n\n      return index <= 0 ? collection[0] : collection[index - 1];\n    }; // Implementation of the nice number algorithm used in determining where axis labels will go\n\n\n    helpers$1.niceNum = function (range, round) {\n      var exponent = Math.floor(helpers$1.log10(range));\n      var fraction = range / Math.pow(10, exponent);\n      var niceFraction;\n\n      if (round) {\n        if (fraction < 1.5) {\n          niceFraction = 1;\n        } else if (fraction < 3) {\n          niceFraction = 2;\n        } else if (fraction < 7) {\n          niceFraction = 5;\n        } else {\n          niceFraction = 10;\n        }\n      } else if (fraction <= 1.0) {\n        niceFraction = 1;\n      } else if (fraction <= 2) {\n        niceFraction = 2;\n      } else if (fraction <= 5) {\n        niceFraction = 5;\n      } else {\n        niceFraction = 10;\n      }\n\n      return niceFraction * Math.pow(10, exponent);\n    }; // Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n\n\n    helpers$1.requestAnimFrame = function () {\n      if (typeof window === 'undefined') {\n        return function (callback) {\n          callback();\n        };\n      }\n\n      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n        return window.setTimeout(callback, 1000 / 60);\n      };\n    }(); // -- DOM methods\n\n\n    helpers$1.getRelativePosition = function (evt, chart) {\n      var mouseX, mouseY;\n      var e = evt.originalEvent || evt;\n      var canvas = evt.target || evt.srcElement;\n      var boundingRect = canvas.getBoundingClientRect();\n      var touches = e.touches;\n\n      if (touches && touches.length > 0) {\n        mouseX = touches[0].clientX;\n        mouseY = touches[0].clientY;\n      } else {\n        mouseX = e.clientX;\n        mouseY = e.clientY;\n      } // Scale mouse coordinates into canvas coordinates\n      // by following the pattern laid out by 'jerryj' in the comments of\n      // https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\n\n\n      var paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));\n      var paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));\n      var paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));\n      var paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));\n      var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\n      var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom; // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\n      // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\n\n      mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);\n      mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);\n      return {\n        x: mouseX,\n        y: mouseY\n      };\n    }; // Private helper function to convert max-width/max-height values that may be percentages into a number\n\n\n    function parseMaxStyle(styleValue, node, parentProperty) {\n      var valueInPixels;\n\n      if (typeof styleValue === 'string') {\n        valueInPixels = parseInt(styleValue, 10);\n\n        if (styleValue.indexOf('%') !== -1) {\n          // percentage * size in dimension\n          valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n        }\n      } else {\n        valueInPixels = styleValue;\n      }\n\n      return valueInPixels;\n    }\n    /**\n     * Returns if the given value contains an effective constraint.\n     * @private\n     */\n\n\n    function isConstrainedValue(value) {\n      return value !== undefined && value !== null && value !== 'none';\n    }\n    /**\n     * Returns the max width or height of the given DOM node in a cross-browser compatible fashion\n     * @param {HTMLElement} domNode - the node to check the constraint on\n     * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')\n     * @param {string} percentageProperty - property of parent to use when calculating width as a percentage\n     * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}\n     */\n\n\n    function getConstraintDimension(domNode, maxStyle, percentageProperty) {\n      var view = document.defaultView;\n\n      var parentNode = helpers$1._getParentNode(domNode);\n\n      var constrainedNode = view.getComputedStyle(domNode)[maxStyle];\n      var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\n      var hasCNode = isConstrainedValue(constrainedNode);\n      var hasCContainer = isConstrainedValue(constrainedContainer);\n      var infinity = Number.POSITIVE_INFINITY;\n\n      if (hasCNode || hasCContainer) {\n        return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\n      }\n\n      return 'none';\n    } // returns Number or undefined if no constraint\n\n\n    helpers$1.getConstraintWidth = function (domNode) {\n      return getConstraintDimension(domNode, 'max-width', 'clientWidth');\n    }; // returns Number or undefined if no constraint\n\n\n    helpers$1.getConstraintHeight = function (domNode) {\n      return getConstraintDimension(domNode, 'max-height', 'clientHeight');\n    };\n    /**\n     * @private\n    \t */\n\n\n    helpers$1._calculatePadding = function (container, padding, parentDimension) {\n      padding = helpers$1.getStyle(container, padding);\n      return padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);\n    };\n    /**\n     * @private\n     */\n\n\n    helpers$1._getParentNode = function (domNode) {\n      var parent = domNode.parentNode;\n\n      if (parent && parent.toString() === '[object ShadowRoot]') {\n        parent = parent.host;\n      }\n\n      return parent;\n    };\n\n    helpers$1.getMaximumWidth = function (domNode) {\n      var container = helpers$1._getParentNode(domNode);\n\n      if (!container) {\n        return domNode.clientWidth;\n      }\n\n      var clientWidth = container.clientWidth;\n\n      var paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);\n\n      var paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);\n\n      var w = clientWidth - paddingLeft - paddingRight;\n      var cw = helpers$1.getConstraintWidth(domNode);\n      return isNaN(cw) ? w : Math.min(w, cw);\n    };\n\n    helpers$1.getMaximumHeight = function (domNode) {\n      var container = helpers$1._getParentNode(domNode);\n\n      if (!container) {\n        return domNode.clientHeight;\n      }\n\n      var clientHeight = container.clientHeight;\n\n      var paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);\n\n      var paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);\n\n      var h = clientHeight - paddingTop - paddingBottom;\n      var ch = helpers$1.getConstraintHeight(domNode);\n      return isNaN(ch) ? h : Math.min(h, ch);\n    };\n\n    helpers$1.getStyle = function (el, property) {\n      return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n    };\n\n    helpers$1.retinaScale = function (chart, forceRatio) {\n      var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== 'undefined' && window.devicePixelRatio || 1;\n\n      if (pixelRatio === 1) {\n        return;\n      }\n\n      var canvas = chart.canvas;\n      var height = chart.height;\n      var width = chart.width;\n      canvas.height = height * pixelRatio;\n      canvas.width = width * pixelRatio;\n      chart.ctx.scale(pixelRatio, pixelRatio); // If no style has been set on the canvas, the render size is used as display size,\n      // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n      // See https://github.com/chartjs/Chart.js/issues/3575\n\n      if (!canvas.style.height && !canvas.style.width) {\n        canvas.style.height = height + 'px';\n        canvas.style.width = width + 'px';\n      }\n    }; // -- Canvas methods\n\n\n    helpers$1.fontString = function (pixelSize, fontStyle, fontFamily) {\n      return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n    };\n\n    helpers$1.longestText = function (ctx, font, arrayOfThings, cache) {\n      cache = cache || {};\n      var data = cache.data = cache.data || {};\n      var gc = cache.garbageCollect = cache.garbageCollect || [];\n\n      if (cache.font !== font) {\n        data = cache.data = {};\n        gc = cache.garbageCollect = [];\n        cache.font = font;\n      }\n\n      ctx.font = font;\n      var longest = 0;\n      var ilen = arrayOfThings.length;\n      var i, j, jlen, thing, nestedThing;\n\n      for (i = 0; i < ilen; i++) {\n        thing = arrayOfThings[i]; // Undefined strings and arrays should not be measured\n\n        if (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {\n          longest = helpers$1.measureText(ctx, data, gc, longest, thing);\n        } else if (helpers$1.isArray(thing)) {\n          // if it is an array lets measure each element\n          // to do maybe simplify this function a bit so we can do this more recursively?\n          for (j = 0, jlen = thing.length; j < jlen; j++) {\n            nestedThing = thing[j]; // Undefined strings and arrays should not be measured\n\n            if (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {\n              longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);\n            }\n          }\n        }\n      }\n\n      var gcLen = gc.length / 2;\n\n      if (gcLen > arrayOfThings.length) {\n        for (i = 0; i < gcLen; i++) {\n          delete data[gc[i]];\n        }\n\n        gc.splice(0, gcLen);\n      }\n\n      return longest;\n    };\n\n    helpers$1.measureText = function (ctx, data, gc, longest, string) {\n      var textWidth = data[string];\n\n      if (!textWidth) {\n        textWidth = data[string] = ctx.measureText(string).width;\n        gc.push(string);\n      }\n\n      if (textWidth > longest) {\n        longest = textWidth;\n      }\n\n      return longest;\n    };\n    /**\n     * @deprecated\n     */\n\n\n    helpers$1.numberOfLabelLines = function (arrayOfThings) {\n      var numberOfLines = 1;\n      helpers$1.each(arrayOfThings, function (thing) {\n        if (helpers$1.isArray(thing)) {\n          if (thing.length > numberOfLines) {\n            numberOfLines = thing.length;\n          }\n        }\n      });\n      return numberOfLines;\n    };\n\n    helpers$1.color = !chartjsColor ? function (value) {\n      console.error('Color.js not found!');\n      return value;\n    } : function (value) {\n      /* global CanvasGradient */\n      if (value instanceof CanvasGradient) {\n        value = core_defaults.global.defaultColor;\n      }\n\n      return chartjsColor(value);\n    };\n\n    helpers$1.getHoverColor = function (colorValue) {\n      /* global CanvasPattern */\n      return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();\n    };\n  };\n\n  function abstract() {\n    throw new Error('This method is not implemented: either no adapter can ' + 'be found or an incomplete integration was provided.');\n  }\n  /**\n   * Date adapter (current used by the time scale)\n   * @namespace Chart._adapters._date\n   * @memberof Chart._adapters\n   * @private\n   */\n\n  /**\n   * Currently supported unit string values.\n   * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}\n   * @memberof Chart._adapters._date\n   * @name Unit\n   */\n\n  /**\n   * @class\n   */\n\n\n  function DateAdapter(options) {\n    this.options = options || {};\n  }\n\n  helpers$1.extend(DateAdapter.prototype,\n  /** @lends DateAdapter */\n  {\n    /**\n     * Returns a map of time formats for the supported formatting units defined\n     * in Unit as well as 'datetime' representing a detailed date/time string.\n     * @returns {{string: string}}\n     */\n    formats: abstract,\n\n    /**\n     * Parses the given `value` and return the associated timestamp.\n     * @param {any} value - the value to parse (usually comes from the data)\n     * @param {string} [format] - the expected data format\n     * @returns {(number|null)}\n     * @function\n     */\n    parse: abstract,\n\n    /**\n     * Returns the formatted date in the specified `format` for a given `timestamp`.\n     * @param {number} timestamp - the timestamp to format\n     * @param {string} format - the date/time token\n     * @return {string}\n     * @function\n     */\n    format: abstract,\n\n    /**\n     * Adds the specified `amount` of `unit` to the given `timestamp`.\n     * @param {number} timestamp - the input timestamp\n     * @param {number} amount - the amount to add\n     * @param {Unit} unit - the unit as string\n     * @return {number}\n     * @function\n     */\n    add: abstract,\n\n    /**\n     * Returns the number of `unit` between the given timestamps.\n     * @param {number} max - the input timestamp (reference)\n     * @param {number} min - the timestamp to substract\n     * @param {Unit} unit - the unit as string\n     * @return {number}\n     * @function\n     */\n    diff: abstract,\n\n    /**\n     * Returns start of `unit` for the given `timestamp`.\n     * @param {number} timestamp - the input timestamp\n     * @param {Unit} unit - the unit as string\n     * @param {number} [weekday] - the ISO day of the week with 1 being Monday\n     * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\n     * @function\n     */\n    startOf: abstract,\n\n    /**\n     * Returns end of `unit` for the given `timestamp`.\n     * @param {number} timestamp - the input timestamp\n     * @param {Unit} unit - the unit as string\n     * @function\n     */\n    endOf: abstract,\n    // DEPRECATIONS\n\n    /**\n     * Provided for backward compatibility for scale.getValueForPixel(),\n     * this method should be overridden only by the moment adapter.\n     * @deprecated since version 2.8.0\n     * @todo remove at version 3\n     * @private\n     */\n    _create: function (value) {\n      return value;\n    }\n  });\n\n  DateAdapter.override = function (members) {\n    helpers$1.extend(DateAdapter.prototype, members);\n  };\n\n  var _date = DateAdapter;\n  var core_adapters = {\n    _date: _date\n  };\n  /**\n   * Namespace to hold static tick generation functions\n   * @namespace Chart.Ticks\n   */\n\n  var core_ticks = {\n    /**\n     * Namespace to hold formatters for different types of ticks\n     * @namespace Chart.Ticks.formatters\n     */\n    formatters: {\n      /**\n       * Formatter for value labels\n       * @method Chart.Ticks.formatters.values\n       * @param value the value to display\n       * @return {string|string[]} the label to display\n       */\n      values: function (value) {\n        return helpers$1.isArray(value) ? value : '' + value;\n      },\n\n      /**\n       * Formatter for linear numeric ticks\n       * @method Chart.Ticks.formatters.linear\n       * @param tickValue {number} the value to be formatted\n       * @param index {number} the position of the tickValue parameter in the ticks array\n       * @param ticks {number[]} the list of ticks being converted\n       * @return {string} string representation of the tickValue parameter\n       */\n      linear: function (tickValue, index, ticks) {\n        // If we have lots of ticks, don't use the ones\n        var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\n        if (Math.abs(delta) > 1) {\n          if (tickValue !== Math.floor(tickValue)) {\n            // not an integer\n            delta = tickValue - Math.floor(tickValue);\n          }\n        }\n\n        var logDelta = helpers$1.log10(Math.abs(delta));\n        var tickString = '';\n\n        if (tickValue !== 0) {\n          var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));\n\n          if (maxTick < 1e-4) {\n            // all ticks are small numbers; use scientific notation\n            var logTick = helpers$1.log10(Math.abs(tickValue));\n            var numExponential = Math.floor(logTick) - Math.floor(logDelta);\n            numExponential = Math.max(Math.min(numExponential, 20), 0);\n            tickString = tickValue.toExponential(numExponential);\n          } else {\n            var numDecimal = -1 * Math.floor(logDelta);\n            numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\n            tickString = tickValue.toFixed(numDecimal);\n          }\n        } else {\n          tickString = '0'; // never show decimal places for 0\n        }\n\n        return tickString;\n      },\n      logarithmic: function (tickValue, index, ticks) {\n        var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));\n\n        if (tickValue === 0) {\n          return '0';\n        } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n          return tickValue.toExponential();\n        }\n\n        return '';\n      }\n    }\n  };\n  var isArray = helpers$1.isArray;\n  var isNullOrUndef = helpers$1.isNullOrUndef;\n  var valueOrDefault$a = helpers$1.valueOrDefault;\n  var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;\n\n  core_defaults._set('scale', {\n    display: true,\n    position: 'left',\n    offset: false,\n    // grid line settings\n    gridLines: {\n      display: true,\n      color: 'rgba(0,0,0,0.1)',\n      lineWidth: 1,\n      drawBorder: true,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickMarkLength: 10,\n      zeroLineWidth: 1,\n      zeroLineColor: 'rgba(0,0,0,0.25)',\n      zeroLineBorderDash: [],\n      zeroLineBorderDashOffset: 0.0,\n      offsetGridLines: false,\n      borderDash: [],\n      borderDashOffset: 0.0\n    },\n    // scale label\n    scaleLabel: {\n      // display property\n      display: false,\n      // actual label\n      labelString: '',\n      // top/bottom padding\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n    // label settings\n    ticks: {\n      beginAtZero: false,\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      padding: 0,\n      reverse: false,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 0,\n      labelOffset: 0,\n      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n      callback: core_ticks.formatters.values,\n      minor: {},\n      major: {}\n    }\n  });\n  /** Returns a new array containing numItems from arr */\n\n\n  function sample(arr, numItems) {\n    var result = [];\n    var increment = arr.length / numItems;\n    var i = 0;\n    var len = arr.length;\n\n    for (; i < len; i += increment) {\n      result.push(arr[Math.floor(i)]);\n    }\n\n    return result;\n  }\n\n  function getPixelForGridLine(scale, index, offsetGridLines) {\n    var length = scale.getTicks().length;\n    var validIndex = Math.min(index, length - 1);\n    var lineValue = scale.getPixelForTick(validIndex);\n    var start = scale._startPixel;\n    var end = scale._endPixel;\n    var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\n\n    var offset;\n\n    if (offsetGridLines) {\n      if (length === 1) {\n        offset = Math.max(lineValue - start, end - lineValue);\n      } else if (index === 0) {\n        offset = (scale.getPixelForTick(1) - lineValue) / 2;\n      } else {\n        offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n      }\n\n      lineValue += validIndex < index ? offset : -offset; // Return undefined if the pixel is out of the range\n\n      if (lineValue < start - epsilon || lineValue > end + epsilon) {\n        return;\n      }\n    }\n\n    return lineValue;\n  }\n\n  function garbageCollect(caches, length) {\n    helpers$1.each(caches, function (cache) {\n      var gc = cache.gc;\n      var gcLen = gc.length / 2;\n      var i;\n\n      if (gcLen > length) {\n        for (i = 0; i < gcLen; ++i) {\n          delete cache.data[gc[i]];\n        }\n\n        gc.splice(0, gcLen);\n      }\n    });\n  }\n  /**\n   * Returns {width, height, offset} objects for the first, last, widest, highest tick\n   * labels where offset indicates the anchor point offset from the top in pixels.\n   */\n\n\n  function computeLabelSizes(ctx, tickFonts, ticks, caches) {\n    var length = ticks.length;\n    var widths = [];\n    var heights = [];\n    var offsets = [];\n    var i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel, widest, highest;\n\n    for (i = 0; i < length; ++i) {\n      label = ticks[i].label;\n      tickFont = ticks[i].major ? tickFonts.major : tickFonts.minor;\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {\n        data: {},\n        gc: []\n      };\n      lineHeight = tickFont.lineHeight;\n      width = height = 0; // Undefined labels and arrays should not be measured\n\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = helpers$1.measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        // if it is an array let's measure each element\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = label[j]; // Undefined labels and arrays should not be measured\n\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = helpers$1.measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n\n      widths.push(width);\n      heights.push(height);\n      offsets.push(lineHeight / 2);\n    }\n\n    garbageCollect(caches, length);\n    widest = widths.indexOf(Math.max.apply(null, widths));\n    highest = heights.indexOf(Math.max.apply(null, heights));\n\n    function valueAt(idx) {\n      return {\n        width: widths[idx] || 0,\n        height: heights[idx] || 0,\n        offset: offsets[idx] || 0\n      };\n    }\n\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest)\n    };\n  }\n\n  function getTickMarkLength(options) {\n    return options.drawTicks ? options.tickMarkLength : 0;\n  }\n\n  function getScaleLabelHeight(options) {\n    var font, padding;\n\n    if (!options.display) {\n      return 0;\n    }\n\n    font = helpers$1.options._parseFont(options);\n    padding = helpers$1.options.toPadding(options.padding);\n    return font.lineHeight + padding.height;\n  }\n\n  function parseFontOptions(options, nestedOpts) {\n    return helpers$1.extend(helpers$1.options._parseFont({\n      fontFamily: valueOrDefault$a(nestedOpts.fontFamily, options.fontFamily),\n      fontSize: valueOrDefault$a(nestedOpts.fontSize, options.fontSize),\n      fontStyle: valueOrDefault$a(nestedOpts.fontStyle, options.fontStyle),\n      lineHeight: valueOrDefault$a(nestedOpts.lineHeight, options.lineHeight)\n    }), {\n      color: helpers$1.options.resolve([nestedOpts.fontColor, options.fontColor, core_defaults.global.defaultFontColor])\n    });\n  }\n\n  function parseTickFontOptions(options) {\n    var minor = parseFontOptions(options, options.minor);\n    var major = options.major.enabled ? parseFontOptions(options, options.major) : minor;\n    return {\n      minor: minor,\n      major: major\n    };\n  }\n\n  function nonSkipped(ticksToFilter) {\n    var filtered = [];\n    var item, index, len;\n\n    for (index = 0, len = ticksToFilter.length; index < len; ++index) {\n      item = ticksToFilter[index];\n\n      if (typeof item._index !== 'undefined') {\n        filtered.push(item);\n      }\n    }\n\n    return filtered;\n  }\n\n  function getEvenSpacing(arr) {\n    var len = arr.length;\n    var i, diff;\n\n    if (len < 2) {\n      return false;\n    }\n\n    for (diff = arr[0], i = 1; i < len; ++i) {\n      if (arr[i] - arr[i - 1] !== diff) {\n        return false;\n      }\n    }\n\n    return diff;\n  }\n\n  function calculateSpacing(majorIndices, ticks, axisLength, ticksLimit) {\n    var evenMajorSpacing = getEvenSpacing(majorIndices);\n    var spacing = (ticks.length - 1) / ticksLimit;\n    var factors, factor, i, ilen; // If the major ticks are evenly spaced apart, place the minor ticks\n    // so that they divide the major ticks into even chunks\n\n    if (!evenMajorSpacing) {\n      return Math.max(spacing, 1);\n    }\n\n    factors = helpers$1.math._factorize(evenMajorSpacing);\n\n    for (i = 0, ilen = factors.length - 1; i < ilen; i++) {\n      factor = factors[i];\n\n      if (factor > spacing) {\n        return factor;\n      }\n    }\n\n    return Math.max(spacing, 1);\n  }\n\n  function getMajorIndices(ticks) {\n    var result = [];\n    var i, ilen;\n\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (ticks[i].major) {\n        result.push(i);\n      }\n    }\n\n    return result;\n  }\n\n  function skipMajors(ticks, majorIndices, spacing) {\n    var count = 0;\n    var next = majorIndices[0];\n    var i, tick;\n    spacing = Math.ceil(spacing);\n\n    for (i = 0; i < ticks.length; i++) {\n      tick = ticks[i];\n\n      if (i === next) {\n        tick._index = i;\n        count++;\n        next = majorIndices[count * spacing];\n      } else {\n        delete tick.label;\n      }\n    }\n  }\n\n  function skip(ticks, spacing, majorStart, majorEnd) {\n    var start = valueOrDefault$a(majorStart, 0);\n    var end = Math.min(valueOrDefault$a(majorEnd, ticks.length), ticks.length);\n    var count = 0;\n    var length, i, tick, next;\n    spacing = Math.ceil(spacing);\n\n    if (majorEnd) {\n      length = majorEnd - majorStart;\n      spacing = length / Math.floor(length / spacing);\n    }\n\n    next = start;\n\n    while (next < 0) {\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n\n    for (i = Math.max(start, 0); i < end; i++) {\n      tick = ticks[i];\n\n      if (i === next) {\n        tick._index = i;\n        count++;\n        next = Math.round(start + count * spacing);\n      } else {\n        delete tick.label;\n      }\n    }\n  }\n\n  var Scale = core_element.extend({\n    zeroLineIndex: 0,\n\n    /**\n     * Get the padding needed for the scale\n     * @method getPadding\n     * @private\n     * @returns {Padding} the necessary padding\n     */\n    getPadding: function () {\n      var me = this;\n      return {\n        left: me.paddingLeft || 0,\n        top: me.paddingTop || 0,\n        right: me.paddingRight || 0,\n        bottom: me.paddingBottom || 0\n      };\n    },\n\n    /**\n     * Returns the scale tick objects ({label, major})\n     * @since 2.7\n     */\n    getTicks: function () {\n      return this._ticks;\n    },\n\n    /**\n    * @private\n    */\n    _getLabels: function () {\n      var data = this.chart.data;\n      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n    },\n    // These methods are ordered by lifecyle. Utilities then follow.\n    // Any function defined here is inherited by all scale types.\n    // Any function can be extended by the scale type\n\n    /**\n     * Provided for backward compatibility, not available anymore\n     * @function Chart.Scale.mergeTicksOptions\n     * @deprecated since version 2.8.0\n     * @todo remove at version 3\n     */\n    mergeTicksOptions: function () {// noop\n    },\n    beforeUpdate: function () {\n      helpers$1.callback(this.options.beforeUpdate, [this]);\n    },\n\n    /**\n     * @param {number} maxWidth - the max width in pixels\n     * @param {number} maxHeight - the max height in pixels\n     * @param {object} margins - the space between the edge of the other scales and edge of the chart\n     *   This space comes from two sources:\n     *     - padding - space that's required to show the labels at the edges of the scale\n     *     - thickness of scales or legends in another orientation\n     */\n    update: function (maxWidth, maxHeight, margins) {\n      var me = this;\n      var tickOpts = me.options.ticks;\n      var sampleSize = tickOpts.sampleSize;\n      var i, ilen, labels, ticks, samplingEnabled; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\n      me.beforeUpdate(); // Absorb the master measurements\n\n      me.maxWidth = maxWidth;\n      me.maxHeight = maxHeight;\n      me.margins = helpers$1.extend({\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }, margins);\n      me._ticks = null;\n      me.ticks = null;\n      me._labelSizes = null;\n      me._maxLabelLines = 0;\n      me.longestLabelWidth = 0;\n      me.longestTextCache = me.longestTextCache || {};\n      me._gridLineItems = null;\n      me._labelItems = null; // Dimensions\n\n      me.beforeSetDimensions();\n      me.setDimensions();\n      me.afterSetDimensions(); // Data min/max\n\n      me.beforeDataLimits();\n      me.determineDataLimits();\n      me.afterDataLimits(); // Ticks - `this.ticks` is now DEPRECATED!\n      // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member\n      // and must not be accessed directly from outside this class. `this.ticks` being\n      // around for long time and not marked as private, we can't change its structure\n      // without unexpected breaking changes. If you need to access the scale ticks,\n      // use scale.getTicks() instead.\n\n      me.beforeBuildTicks(); // New implementations should return an array of objects but for BACKWARD COMPAT,\n      // we still support no return (`this.ticks` internally set by calling this method).\n\n      ticks = me.buildTicks() || []; // Allow modification of ticks in callback.\n\n      ticks = me.afterBuildTicks(ticks) || ticks; // Ensure ticks contains ticks in new tick format\n\n      if ((!ticks || !ticks.length) && me.ticks) {\n        ticks = [];\n\n        for (i = 0, ilen = me.ticks.length; i < ilen; ++i) {\n          ticks.push({\n            value: me.ticks[i],\n            major: false\n          });\n        }\n      }\n\n      me._ticks = ticks; // Compute tick rotation and fit using a sampled subset of labels\n      // We generally don't need to compute the size of every single label for determining scale size\n\n      samplingEnabled = sampleSize < ticks.length;\n      labels = me._convertTicksToLabels(samplingEnabled ? sample(ticks, sampleSize) : ticks); // _configure is called twice, once here, once from core.controller.updateLayout.\n      // Here we haven't been positioned yet, but dimensions are correct.\n      // Variables set in _configure are needed for calculateTickRotation, and\n      // it's ok that coordinates are not correct there, only dimensions matter.\n\n      me._configure(); // Tick Rotation\n\n\n      me.beforeCalculateTickRotation();\n      me.calculateTickRotation();\n      me.afterCalculateTickRotation();\n      me.beforeFit();\n      me.fit();\n      me.afterFit(); // Auto-skip\n\n      me._ticksToDraw = tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto') ? me._autoSkip(ticks) : ticks;\n\n      if (samplingEnabled) {\n        // Generate labels using all non-skipped ticks\n        labels = me._convertTicksToLabels(me._ticksToDraw);\n      }\n\n      me.ticks = labels; // BACKWARD COMPATIBILITY\n      // IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!\n\n      me.afterUpdate(); // TODO(v3): remove minSize as a public property and return value from all layout boxes. It is unused\n      // make maxWidth and maxHeight private\n\n      return me.minSize;\n    },\n\n    /**\n     * @private\n     */\n    _configure: function () {\n      var me = this;\n      var reversePixels = me.options.ticks.reverse;\n      var startPixel, endPixel;\n\n      if (me.isHorizontal()) {\n        startPixel = me.left;\n        endPixel = me.right;\n      } else {\n        startPixel = me.top;\n        endPixel = me.bottom; // by default vertical scales are from bottom to top, so pixels are reversed\n\n        reversePixels = !reversePixels;\n      }\n\n      me._startPixel = startPixel;\n      me._endPixel = endPixel;\n      me._reversePixels = reversePixels;\n      me._length = endPixel - startPixel;\n    },\n    afterUpdate: function () {\n      helpers$1.callback(this.options.afterUpdate, [this]);\n    },\n    //\n    beforeSetDimensions: function () {\n      helpers$1.callback(this.options.beforeSetDimensions, [this]);\n    },\n    setDimensions: function () {\n      var me = this; // Set the unconstrained dimension before label rotation\n\n      if (me.isHorizontal()) {\n        // Reset position before calculating rotation\n        me.width = me.maxWidth;\n        me.left = 0;\n        me.right = me.width;\n      } else {\n        me.height = me.maxHeight; // Reset position before calculating rotation\n\n        me.top = 0;\n        me.bottom = me.height;\n      } // Reset padding\n\n\n      me.paddingLeft = 0;\n      me.paddingTop = 0;\n      me.paddingRight = 0;\n      me.paddingBottom = 0;\n    },\n    afterSetDimensions: function () {\n      helpers$1.callback(this.options.afterSetDimensions, [this]);\n    },\n    // Data limits\n    beforeDataLimits: function () {\n      helpers$1.callback(this.options.beforeDataLimits, [this]);\n    },\n    determineDataLimits: helpers$1.noop,\n    afterDataLimits: function () {\n      helpers$1.callback(this.options.afterDataLimits, [this]);\n    },\n    //\n    beforeBuildTicks: function () {\n      helpers$1.callback(this.options.beforeBuildTicks, [this]);\n    },\n    buildTicks: helpers$1.noop,\n    afterBuildTicks: function (ticks) {\n      var me = this; // ticks is empty for old axis implementations here\n\n      if (isArray(ticks) && ticks.length) {\n        return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);\n      } // Support old implementations (that modified `this.ticks` directly in buildTicks)\n\n\n      me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;\n      return ticks;\n    },\n    beforeTickToLabelConversion: function () {\n      helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);\n    },\n    convertTicksToLabels: function () {\n      var me = this; // Convert ticks to strings\n\n      var tickOpts = me.options.ticks;\n      me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\n    },\n    afterTickToLabelConversion: function () {\n      helpers$1.callback(this.options.afterTickToLabelConversion, [this]);\n    },\n    //\n    beforeCalculateTickRotation: function () {\n      helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);\n    },\n    calculateTickRotation: function () {\n      var me = this;\n      var options = me.options;\n      var tickOpts = options.ticks;\n      var numTicks = me.getTicks().length;\n      var minRotation = tickOpts.minRotation || 0;\n      var maxRotation = tickOpts.maxRotation;\n      var labelRotation = minRotation;\n      var labelSizes, maxLabelWidth, maxLabelHeight, maxWidth, tickWidth, maxHeight, maxLabelDiagonal;\n\n      if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {\n        me.labelRotation = minRotation;\n        return;\n      }\n\n      labelSizes = me._getLabelSizes();\n      maxLabelWidth = labelSizes.widest.width;\n      maxLabelHeight = labelSizes.highest.height - labelSizes.highest.offset; // Estimate the width of each grid based on the canvas width, the maximum\n      // label width and the number of tick intervals\n\n      maxWidth = Math.min(me.maxWidth, me.chart.width - maxLabelWidth);\n      tickWidth = options.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1); // Allow 3 pixels x2 padding either side for label readability\n\n      if (maxLabelWidth + 6 > tickWidth) {\n        tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n        maxHeight = me.maxHeight - getTickMarkLength(options.gridLines) - tickOpts.padding - getScaleLabelHeight(options.scaleLabel);\n        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n        labelRotation = helpers$1.toDegrees(Math.min(Math.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)), Math.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)));\n        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n      }\n\n      me.labelRotation = labelRotation;\n    },\n    afterCalculateTickRotation: function () {\n      helpers$1.callback(this.options.afterCalculateTickRotation, [this]);\n    },\n    //\n    beforeFit: function () {\n      helpers$1.callback(this.options.beforeFit, [this]);\n    },\n    fit: function () {\n      var me = this; // Reset\n\n      var minSize = me.minSize = {\n        width: 0,\n        height: 0\n      };\n      var chart = me.chart;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n      var scaleLabelOpts = opts.scaleLabel;\n      var gridLineOpts = opts.gridLines;\n\n      var display = me._isVisible();\n\n      var isBottom = opts.position === 'bottom';\n      var isHorizontal = me.isHorizontal(); // Width\n\n      if (isHorizontal) {\n        minSize.width = me.maxWidth;\n      } else if (display) {\n        minSize.width = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);\n      } // height\n\n\n      if (!isHorizontal) {\n        minSize.height = me.maxHeight; // fill all the height\n      } else if (display) {\n        minSize.height = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);\n      } // Don't bother fitting the ticks if we are not showing the labels\n\n\n      if (tickOpts.display && display) {\n        var tickFonts = parseTickFontOptions(tickOpts);\n\n        var labelSizes = me._getLabelSizes();\n\n        var firstLabelSize = labelSizes.first;\n        var lastLabelSize = labelSizes.last;\n        var widestLabelSize = labelSizes.widest;\n        var highestLabelSize = labelSizes.highest;\n        var lineSpace = tickFonts.minor.lineHeight * 0.4;\n        var tickPadding = tickOpts.padding;\n\n        if (isHorizontal) {\n          // A horizontal axis is more constrained by the height.\n          var isRotated = me.labelRotation !== 0;\n          var angleRadians = helpers$1.toRadians(me.labelRotation);\n          var cosRotation = Math.cos(angleRadians);\n          var sinRotation = Math.sin(angleRadians);\n          var labelHeight = sinRotation * widestLabelSize.width + cosRotation * (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0)) + (isRotated ? 0 : lineSpace); // padding\n\n          minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n          var offsetLeft = me.getPixelForTick(0) - me.left;\n          var offsetRight = me.right - me.getPixelForTick(me.getTicks().length - 1);\n          var paddingLeft, paddingRight; // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n          // which means that the right padding is dominated by the font height\n\n          if (isRotated) {\n            paddingLeft = isBottom ? cosRotation * firstLabelSize.width + sinRotation * firstLabelSize.offset : sinRotation * (firstLabelSize.height - firstLabelSize.offset);\n            paddingRight = isBottom ? sinRotation * (lastLabelSize.height - lastLabelSize.offset) : cosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;\n          } else {\n            paddingLeft = firstLabelSize.width / 2;\n            paddingRight = lastLabelSize.width / 2;\n          } // Adjust padding taking into account changes in offsets\n          // and add 3 px to move away from canvas edges\n\n\n          me.paddingLeft = Math.max((paddingLeft - offsetLeft) * me.width / (me.width - offsetLeft), 0) + 3;\n          me.paddingRight = Math.max((paddingRight - offsetRight) * me.width / (me.width - offsetRight), 0) + 3;\n        } else {\n          // A vertical axis is more constrained by the width. Labels are the\n          // dominant factor here, so get that length first and account for padding\n          var labelWidth = tickOpts.mirror ? 0 : // use lineSpace for consistency with horizontal axis\n          // tickPadding is not implemented for horizontal\n          widestLabelSize.width + tickPadding + lineSpace;\n          minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth);\n          me.paddingTop = firstLabelSize.height / 2;\n          me.paddingBottom = lastLabelSize.height / 2;\n        }\n      }\n\n      me.handleMargins();\n\n      if (isHorizontal) {\n        me.width = me._length = chart.width - me.margins.left - me.margins.right;\n        me.height = minSize.height;\n      } else {\n        me.width = minSize.width;\n        me.height = me._length = chart.height - me.margins.top - me.margins.bottom;\n      }\n    },\n\n    /**\n     * Handle margins and padding interactions\n     * @private\n     */\n    handleMargins: function () {\n      var me = this;\n\n      if (me.margins) {\n        me.margins.left = Math.max(me.paddingLeft, me.margins.left);\n        me.margins.top = Math.max(me.paddingTop, me.margins.top);\n        me.margins.right = Math.max(me.paddingRight, me.margins.right);\n        me.margins.bottom = Math.max(me.paddingBottom, me.margins.bottom);\n      }\n    },\n    afterFit: function () {\n      helpers$1.callback(this.options.afterFit, [this]);\n    },\n    // Shared Methods\n    isHorizontal: function () {\n      var pos = this.options.position;\n      return pos === 'top' || pos === 'bottom';\n    },\n    isFullWidth: function () {\n      return this.options.fullWidth;\n    },\n    // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n    getRightValue: function (rawValue) {\n      // Null and undefined values first\n      if (isNullOrUndef(rawValue)) {\n        return NaN;\n      } // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\n\n      if ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {\n        return NaN;\n      } // If it is in fact an object, dive in one more level\n\n\n      if (rawValue) {\n        if (this.isHorizontal()) {\n          if (rawValue.x !== undefined) {\n            return this.getRightValue(rawValue.x);\n          }\n        } else if (rawValue.y !== undefined) {\n          return this.getRightValue(rawValue.y);\n        }\n      } // Value is good, return it\n\n\n      return rawValue;\n    },\n    _convertTicksToLabels: function (ticks) {\n      var me = this;\n      var labels, i, ilen;\n      me.ticks = ticks.map(function (tick) {\n        return tick.value;\n      });\n      me.beforeTickToLabelConversion(); // New implementations should return the formatted tick labels but for BACKWARD\n      // COMPAT, we still support no return (`this.ticks` internally changed by calling\n      // this method and supposed to contain only string values).\n\n      labels = me.convertTicksToLabels(ticks) || me.ticks;\n      me.afterTickToLabelConversion(); // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)\n\n      for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n        ticks[i].label = labels[i];\n      }\n\n      return labels;\n    },\n\n    /**\n     * @private\n     */\n    _getLabelSizes: function () {\n      var me = this;\n      var labelSizes = me._labelSizes;\n\n      if (!labelSizes) {\n        me._labelSizes = labelSizes = computeLabelSizes(me.ctx, parseTickFontOptions(me.options.ticks), me.getTicks(), me.longestTextCache);\n        me.longestLabelWidth = labelSizes.widest.width;\n      }\n\n      return labelSizes;\n    },\n\n    /**\n     * @private\n     */\n    _parseValue: function (value) {\n      var start, end, min, max;\n\n      if (isArray(value)) {\n        start = +this.getRightValue(value[0]);\n        end = +this.getRightValue(value[1]);\n        min = Math.min(start, end);\n        max = Math.max(start, end);\n      } else {\n        value = +this.getRightValue(value);\n        start = undefined;\n        end = value;\n        min = value;\n        max = value;\n      }\n\n      return {\n        min: min,\n        max: max,\n        start: start,\n        end: end\n      };\n    },\n\n    /**\n    * @private\n    */\n    _getScaleLabel: function (rawValue) {\n      var v = this._parseValue(rawValue);\n\n      if (v.start !== undefined) {\n        return '[' + v.start + ', ' + v.end + ']';\n      }\n\n      return +this.getRightValue(rawValue);\n    },\n\n    /**\n     * Used to get the value to display in the tooltip for the data at the given index\n     * @param index\n     * @param datasetIndex\n     */\n    getLabelForIndex: helpers$1.noop,\n\n    /**\n     * Returns the location of the given data point. Value can either be an index or a numerical value\n     * The coordinate (0, 0) is at the upper-left corner of the canvas\n     * @param value\n     * @param index\n     * @param datasetIndex\n     */\n    getPixelForValue: helpers$1.noop,\n\n    /**\n     * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n     * The coordinate (0, 0) is at the upper-left corner of the canvas\n     * @param pixel\n     */\n    getValueForPixel: helpers$1.noop,\n\n    /**\n     * Returns the location of the tick at the given index\n     * The coordinate (0, 0) is at the upper-left corner of the canvas\n     */\n    getPixelForTick: function (index) {\n      var me = this;\n      var offset = me.options.offset;\n      var numTicks = me._ticks.length;\n      var tickWidth = 1 / Math.max(numTicks - (offset ? 0 : 1), 1);\n      return index < 0 || index > numTicks - 1 ? null : me.getPixelForDecimal(index * tickWidth + (offset ? tickWidth / 2 : 0));\n    },\n\n    /**\n     * Utility for getting the pixel location of a percentage of scale\n     * The coordinate (0, 0) is at the upper-left corner of the canvas\n     */\n    getPixelForDecimal: function (decimal) {\n      var me = this;\n\n      if (me._reversePixels) {\n        decimal = 1 - decimal;\n      }\n\n      return me._startPixel + decimal * me._length;\n    },\n    getDecimalForPixel: function (pixel) {\n      var decimal = (pixel - this._startPixel) / this._length;\n      return this._reversePixels ? 1 - decimal : decimal;\n    },\n\n    /**\n     * Returns the pixel for the minimum chart value\n     * The coordinate (0, 0) is at the upper-left corner of the canvas\n     */\n    getBasePixel: function () {\n      return this.getPixelForValue(this.getBaseValue());\n    },\n    getBaseValue: function () {\n      var me = this;\n      var min = me.min;\n      var max = me.max;\n      return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    },\n\n    /**\n     * Returns a subset of ticks to be plotted to avoid overlapping labels.\n     * @private\n     */\n    _autoSkip: function (ticks) {\n      var me = this;\n      var tickOpts = me.options.ticks;\n      var axisLength = me._length;\n      var ticksLimit = tickOpts.maxTicksLimit || axisLength / me._tickSize() + 1;\n      var majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n      var numMajorIndices = majorIndices.length;\n      var first = majorIndices[0];\n      var last = majorIndices[numMajorIndices - 1];\n      var i, ilen, spacing, avgMajorSpacing; // If there are too many major ticks to display them all\n\n      if (numMajorIndices > ticksLimit) {\n        skipMajors(ticks, majorIndices, numMajorIndices / ticksLimit);\n        return nonSkipped(ticks);\n      }\n\n      spacing = calculateSpacing(majorIndices, ticks, axisLength, ticksLimit);\n\n      if (numMajorIndices > 0) {\n        for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n          skip(ticks, spacing, majorIndices[i], majorIndices[i + 1]);\n        }\n\n        avgMajorSpacing = numMajorIndices > 1 ? (last - first) / (numMajorIndices - 1) : null;\n        skip(ticks, spacing, helpers$1.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n        skip(ticks, spacing, last, helpers$1.isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n        return nonSkipped(ticks);\n      }\n\n      skip(ticks, spacing);\n      return nonSkipped(ticks);\n    },\n\n    /**\n     * @private\n     */\n    _tickSize: function () {\n      var me = this;\n      var optionTicks = me.options.ticks; // Calculate space needed by label in axis direction.\n\n      var rot = helpers$1.toRadians(me.labelRotation);\n      var cos = Math.abs(Math.cos(rot));\n      var sin = Math.abs(Math.sin(rot));\n\n      var labelSizes = me._getLabelSizes();\n\n      var padding = optionTicks.autoSkipPadding || 0;\n      var w = labelSizes ? labelSizes.widest.width + padding : 0;\n      var h = labelSizes ? labelSizes.highest.height + padding : 0; // Calculate space needed for 1 tick in axis direction.\n\n      return me.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n    },\n\n    /**\n     * @private\n     */\n    _isVisible: function () {\n      var me = this;\n      var chart = me.chart;\n      var display = me.options.display;\n      var i, ilen, meta;\n\n      if (display !== 'auto') {\n        return !!display;\n      } // When 'auto', the scale is visible if at least one associated dataset is visible.\n\n\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n\n          if (meta.xAxisID === me.id || meta.yAxisID === me.id) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * @private\n     */\n    _computeGridLineItems: function (chartArea) {\n      var me = this;\n      var chart = me.chart;\n      var options = me.options;\n      var gridLines = options.gridLines;\n      var position = options.position;\n      var offsetGridLines = gridLines.offsetGridLines;\n      var isHorizontal = me.isHorizontal();\n      var ticks = me._ticksToDraw;\n      var ticksLength = ticks.length + (offsetGridLines ? 1 : 0);\n      var tl = getTickMarkLength(gridLines);\n      var items = [];\n      var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;\n      var axisHalfWidth = axisWidth / 2;\n      var alignPixel = helpers$1._alignPixel;\n\n      var alignBorderValue = function (pixel) {\n        return alignPixel(chart, pixel, axisWidth);\n      };\n\n      var borderValue, i, tick, lineValue, alignedLineValue;\n      var tx1, ty1, tx2, ty2, x1, y1, x2, y2, lineWidth, lineColor, borderDash, borderDashOffset;\n\n      if (position === 'top') {\n        borderValue = alignBorderValue(me.bottom);\n        ty1 = me.bottom - tl;\n        ty2 = borderValue - axisHalfWidth;\n        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n        y2 = chartArea.bottom;\n      } else if (position === 'bottom') {\n        borderValue = alignBorderValue(me.top);\n        y1 = chartArea.top;\n        y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n        ty1 = borderValue + axisHalfWidth;\n        ty2 = me.top + tl;\n      } else if (position === 'left') {\n        borderValue = alignBorderValue(me.right);\n        tx1 = me.right - tl;\n        tx2 = borderValue - axisHalfWidth;\n        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n        x2 = chartArea.right;\n      } else {\n        borderValue = alignBorderValue(me.left);\n        x1 = chartArea.left;\n        x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n        tx1 = borderValue + axisHalfWidth;\n        tx2 = me.left + tl;\n      }\n\n      for (i = 0; i < ticksLength; ++i) {\n        tick = ticks[i] || {}; // autoskipper skipped this tick (#4635)\n\n        if (isNullOrUndef(tick.label) && i < ticks.length) {\n          continue;\n        }\n\n        if (i === me.zeroLineIndex && options.offset === offsetGridLines) {\n          // Draw the first index specially\n          lineWidth = gridLines.zeroLineWidth;\n          lineColor = gridLines.zeroLineColor;\n          borderDash = gridLines.zeroLineBorderDash || [];\n          borderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;\n        } else {\n          lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, i, 1);\n          lineColor = valueAtIndexOrDefault(gridLines.color, i, 'rgba(0,0,0,0.1)');\n          borderDash = gridLines.borderDash || [];\n          borderDashOffset = gridLines.borderDashOffset || 0.0;\n        }\n\n        lineValue = getPixelForGridLine(me, tick._index || i, offsetGridLines); // Skip if the pixel is out of the range\n\n        if (lineValue === undefined) {\n          continue;\n        }\n\n        alignedLineValue = alignPixel(chart, lineValue, lineWidth);\n\n        if (isHorizontal) {\n          tx1 = tx2 = x1 = x2 = alignedLineValue;\n        } else {\n          ty1 = ty2 = y1 = y2 = alignedLineValue;\n        }\n\n        items.push({\n          tx1: tx1,\n          ty1: ty1,\n          tx2: tx2,\n          ty2: ty2,\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2,\n          width: lineWidth,\n          color: lineColor,\n          borderDash: borderDash,\n          borderDashOffset: borderDashOffset\n        });\n      }\n\n      items.ticksLength = ticksLength;\n      items.borderValue = borderValue;\n      return items;\n    },\n\n    /**\n     * @private\n     */\n    _computeLabelItems: function () {\n      var me = this;\n      var options = me.options;\n      var optionTicks = options.ticks;\n      var position = options.position;\n      var isMirrored = optionTicks.mirror;\n      var isHorizontal = me.isHorizontal();\n      var ticks = me._ticksToDraw;\n      var fonts = parseTickFontOptions(optionTicks);\n      var tickPadding = optionTicks.padding;\n      var tl = getTickMarkLength(options.gridLines);\n      var rotation = -helpers$1.toRadians(me.labelRotation);\n      var items = [];\n      var i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n\n      if (position === 'top') {\n        y = me.bottom - tl - tickPadding;\n        textAlign = !rotation ? 'center' : 'left';\n      } else if (position === 'bottom') {\n        y = me.top + tl + tickPadding;\n        textAlign = !rotation ? 'center' : 'right';\n      } else if (position === 'left') {\n        x = me.right - (isMirrored ? 0 : tl) - tickPadding;\n        textAlign = isMirrored ? 'left' : 'right';\n      } else {\n        x = me.left + (isMirrored ? 0 : tl) + tickPadding;\n        textAlign = isMirrored ? 'right' : 'left';\n      }\n\n      for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n        tick = ticks[i];\n        label = tick.label; // autoskipper skipped this tick (#4635)\n\n        if (isNullOrUndef(label)) {\n          continue;\n        }\n\n        pixel = me.getPixelForTick(tick._index || i) + optionTicks.labelOffset;\n        font = tick.major ? fonts.major : fonts.minor;\n        lineHeight = font.lineHeight;\n        lineCount = isArray(label) ? label.length : 1;\n\n        if (isHorizontal) {\n          x = pixel;\n          textOffset = position === 'top' ? ((!rotation ? 0.5 : 1) - lineCount) * lineHeight : (!rotation ? 0.5 : 0) * lineHeight;\n        } else {\n          y = pixel;\n          textOffset = (1 - lineCount) * lineHeight / 2;\n        }\n\n        items.push({\n          x: x,\n          y: y,\n          rotation: rotation,\n          label: label,\n          font: font,\n          textOffset: textOffset,\n          textAlign: textAlign\n        });\n      }\n\n      return items;\n    },\n\n    /**\n     * @private\n     */\n    _drawGrid: function (chartArea) {\n      var me = this;\n      var gridLines = me.options.gridLines;\n\n      if (!gridLines.display) {\n        return;\n      }\n\n      var ctx = me.ctx;\n      var chart = me.chart;\n      var alignPixel = helpers$1._alignPixel;\n      var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;\n\n      var items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));\n\n      var width, color, i, ilen, item;\n\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        item = items[i];\n        width = item.width;\n        color = item.color;\n\n        if (width && color) {\n          ctx.save();\n          ctx.lineWidth = width;\n          ctx.strokeStyle = color;\n\n          if (ctx.setLineDash) {\n            ctx.setLineDash(item.borderDash);\n            ctx.lineDashOffset = item.borderDashOffset;\n          }\n\n          ctx.beginPath();\n\n          if (gridLines.drawTicks) {\n            ctx.moveTo(item.tx1, item.ty1);\n            ctx.lineTo(item.tx2, item.ty2);\n          }\n\n          if (gridLines.drawOnChartArea) {\n            ctx.moveTo(item.x1, item.y1);\n            ctx.lineTo(item.x2, item.y2);\n          }\n\n          ctx.stroke();\n          ctx.restore();\n        }\n      }\n\n      if (axisWidth) {\n        // Draw the line at the edge of the axis\n        var firstLineWidth = axisWidth;\n        var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, items.ticksLength - 1, 1);\n        var borderValue = items.borderValue;\n        var x1, x2, y1, y2;\n\n        if (me.isHorizontal()) {\n          x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;\n          x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;\n          y1 = y2 = borderValue;\n        } else {\n          y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;\n          y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;\n          x1 = x2 = borderValue;\n        }\n\n        ctx.lineWidth = axisWidth;\n        ctx.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n      }\n    },\n\n    /**\n     * @private\n     */\n    _drawLabels: function () {\n      var me = this;\n      var optionTicks = me.options.ticks;\n\n      if (!optionTicks.display) {\n        return;\n      }\n\n      var ctx = me.ctx;\n\n      var items = me._labelItems || (me._labelItems = me._computeLabelItems());\n\n      var i, j, ilen, jlen, item, tickFont, label, y;\n\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        item = items[i];\n        tickFont = item.font; // Make sure we draw text in the correct color and font\n\n        ctx.save();\n        ctx.translate(item.x, item.y);\n        ctx.rotate(item.rotation);\n        ctx.font = tickFont.string;\n        ctx.fillStyle = tickFont.color;\n        ctx.textBaseline = 'middle';\n        ctx.textAlign = item.textAlign;\n        label = item.label;\n        y = item.textOffset;\n\n        if (isArray(label)) {\n          for (j = 0, jlen = label.length; j < jlen; ++j) {\n            // We just make sure the multiline element is a string here..\n            ctx.fillText('' + label[j], 0, y);\n            y += tickFont.lineHeight;\n          }\n        } else {\n          ctx.fillText(label, 0, y);\n        }\n\n        ctx.restore();\n      }\n    },\n\n    /**\n     * @private\n     */\n    _drawTitle: function () {\n      var me = this;\n      var ctx = me.ctx;\n      var options = me.options;\n      var scaleLabel = options.scaleLabel;\n\n      if (!scaleLabel.display) {\n        return;\n      }\n\n      var scaleLabelFontColor = valueOrDefault$a(scaleLabel.fontColor, core_defaults.global.defaultFontColor);\n\n      var scaleLabelFont = helpers$1.options._parseFont(scaleLabel);\n\n      var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);\n      var halfLineHeight = scaleLabelFont.lineHeight / 2;\n      var position = options.position;\n      var rotation = 0;\n      var scaleLabelX, scaleLabelY;\n\n      if (me.isHorizontal()) {\n        scaleLabelX = me.left + me.width / 2; // midpoint of the width\n\n        scaleLabelY = position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;\n      } else {\n        var isLeft = position === 'left';\n        scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;\n        scaleLabelY = me.top + me.height / 2;\n        rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n      }\n\n      ctx.save();\n      ctx.translate(scaleLabelX, scaleLabelY);\n      ctx.rotate(rotation);\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillStyle = scaleLabelFontColor; // render in correct colour\n\n      ctx.font = scaleLabelFont.string;\n      ctx.fillText(scaleLabel.labelString, 0, 0);\n      ctx.restore();\n    },\n    draw: function (chartArea) {\n      var me = this;\n\n      if (!me._isVisible()) {\n        return;\n      }\n\n      me._drawGrid(chartArea);\n\n      me._drawTitle();\n\n      me._drawLabels();\n    },\n\n    /**\n     * @private\n     */\n    _layers: function () {\n      var me = this;\n      var opts = me.options;\n      var tz = opts.ticks && opts.ticks.z || 0;\n      var gz = opts.gridLines && opts.gridLines.z || 0;\n\n      if (!me._isVisible() || tz === gz || me.draw !== me._draw) {\n        // backward compatibility: draw has been overridden by custom scale\n        return [{\n          z: tz,\n          draw: function () {\n            me.draw.apply(me, arguments);\n          }\n        }];\n      }\n\n      return [{\n        z: gz,\n        draw: function () {\n          me._drawGrid.apply(me, arguments);\n\n          me._drawTitle.apply(me, arguments);\n        }\n      }, {\n        z: tz,\n        draw: function () {\n          me._drawLabels.apply(me, arguments);\n        }\n      }];\n    },\n\n    /**\n     * @private\n     */\n    _getMatchingVisibleMetas: function (type) {\n      var me = this;\n      var isHorizontal = me.isHorizontal();\n      return me.chart._getSortedVisibleDatasetMetas().filter(function (meta) {\n        return (!type || meta.type === type) && (isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id);\n      });\n    }\n  });\n  Scale.prototype._draw = Scale.prototype.draw;\n  var core_scale = Scale;\n  var isNullOrUndef$1 = helpers$1.isNullOrUndef;\n  var defaultConfig = {\n    position: 'bottom'\n  };\n  var scale_category = core_scale.extend({\n    determineDataLimits: function () {\n      var me = this;\n\n      var labels = me._getLabels();\n\n      var ticksOpts = me.options.ticks;\n      var min = ticksOpts.min;\n      var max = ticksOpts.max;\n      var minIndex = 0;\n      var maxIndex = labels.length - 1;\n      var findIndex;\n\n      if (min !== undefined) {\n        // user specified min value\n        findIndex = labels.indexOf(min);\n\n        if (findIndex >= 0) {\n          minIndex = findIndex;\n        }\n      }\n\n      if (max !== undefined) {\n        // user specified max value\n        findIndex = labels.indexOf(max);\n\n        if (findIndex >= 0) {\n          maxIndex = findIndex;\n        }\n      }\n\n      me.minIndex = minIndex;\n      me.maxIndex = maxIndex;\n      me.min = labels[minIndex];\n      me.max = labels[maxIndex];\n    },\n    buildTicks: function () {\n      var me = this;\n\n      var labels = me._getLabels();\n\n      var minIndex = me.minIndex;\n      var maxIndex = me.maxIndex; // If we are viewing some subset of labels, slice the original array\n\n      me.ticks = minIndex === 0 && maxIndex === labels.length - 1 ? labels : labels.slice(minIndex, maxIndex + 1);\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      var me = this;\n      var chart = me.chart;\n\n      if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {\n        return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);\n      }\n\n      return me._getLabels()[index];\n    },\n    _configure: function () {\n      var me = this;\n      var offset = me.options.offset;\n      var ticks = me.ticks;\n\n      core_scale.prototype._configure.call(me);\n\n      if (!me.isHorizontal()) {\n        // For backward compatibility, vertical category scale reverse is inverted.\n        me._reversePixels = !me._reversePixels;\n      }\n\n      if (!ticks) {\n        return;\n      }\n\n      me._startValue = me.minIndex - (offset ? 0.5 : 0);\n      me._valueRange = Math.max(ticks.length - (offset ? 0 : 1), 1);\n    },\n    // Used to get data value locations.  Value can either be an index or a numerical value\n    getPixelForValue: function (value, index, datasetIndex) {\n      var me = this;\n      var valueCategory, labels, idx;\n\n      if (!isNullOrUndef$1(index) && !isNullOrUndef$1(datasetIndex)) {\n        value = me.chart.data.datasets[datasetIndex].data[index];\n      } // If value is a data object, then index is the index in the data array,\n      // not the index of the scale. We need to change that.\n\n\n      if (!isNullOrUndef$1(value)) {\n        valueCategory = me.isHorizontal() ? value.x : value.y;\n      }\n\n      if (valueCategory !== undefined || value !== undefined && isNaN(index)) {\n        labels = me._getLabels();\n        value = helpers$1.valueOrDefault(valueCategory, value);\n        idx = labels.indexOf(value);\n        index = idx !== -1 ? idx : index;\n\n        if (isNaN(index)) {\n          index = value;\n        }\n      }\n\n      return me.getPixelForDecimal((index - me._startValue) / me._valueRange);\n    },\n    getPixelForTick: function (index) {\n      var ticks = this.ticks;\n      return index < 0 || index > ticks.length - 1 ? null : this.getPixelForValue(ticks[index], index + this.minIndex);\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var value = Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);\n      return Math.min(Math.max(value, 0), me.ticks.length - 1);\n    },\n    getBasePixel: function () {\n      return this.bottom;\n    }\n  }); // INTERNAL: static default options, registered in src/index.js\n\n  var _defaults = defaultConfig;\n  scale_category._defaults = _defaults;\n  var noop = helpers$1.noop;\n  var isNullOrUndef$2 = helpers$1.isNullOrUndef;\n  /**\n   * Generate a set of linear ticks\n   * @param generationOptions the options used to generate the ticks\n   * @param dataRange the range of the data\n   * @returns {number[]} array of tick values\n   */\n\n  function generateTicks(generationOptions, dataRange) {\n    var ticks = []; // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n    // \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n    // for details.\n\n    var MIN_SPACING = 1e-14;\n    var stepSize = generationOptions.stepSize;\n    var unit = stepSize || 1;\n    var maxNumSpaces = generationOptions.maxTicks - 1;\n    var min = generationOptions.min;\n    var max = generationOptions.max;\n    var precision = generationOptions.precision;\n    var rmin = dataRange.min;\n    var rmax = dataRange.max;\n    var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;\n    var factor, niceMin, niceMax, numSpaces; // Beyond MIN_SPACING floating point numbers being to lose precision\n    // such that we can't do the math necessary to generate ticks\n\n    if (spacing < MIN_SPACING && isNullOrUndef$2(min) && isNullOrUndef$2(max)) {\n      return [rmin, rmax];\n    }\n\n    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n\n    if (numSpaces > maxNumSpaces) {\n      // If the calculated num of spaces exceeds maxNumSpaces, recalculate it\n      spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;\n    }\n\n    if (stepSize || isNullOrUndef$2(precision)) {\n      // If a precision is not specified, calculate factor based on spacing\n      factor = Math.pow(10, helpers$1._decimalPlaces(spacing));\n    } else {\n      // If the user specified a precision, round to that number of decimal places\n      factor = Math.pow(10, precision);\n      spacing = Math.ceil(spacing * factor) / factor;\n    }\n\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.\n\n    if (stepSize) {\n      // If very close to our whole number, use it.\n      if (!isNullOrUndef$2(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {\n        niceMin = min;\n      }\n\n      if (!isNullOrUndef$2(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {\n        niceMax = max;\n      }\n    }\n\n    numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.\n\n    if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n\n    niceMin = Math.round(niceMin * factor) / factor;\n    niceMax = Math.round(niceMax * factor) / factor;\n    ticks.push(isNullOrUndef$2(min) ? niceMin : min);\n\n    for (var j = 1; j < numSpaces; ++j) {\n      ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);\n    }\n\n    ticks.push(isNullOrUndef$2(max) ? niceMax : max);\n    return ticks;\n  }\n\n  var scale_linearbase = core_scale.extend({\n    getRightValue: function (value) {\n      if (typeof value === 'string') {\n        return +value;\n      }\n\n      return core_scale.prototype.getRightValue.call(this, value);\n    },\n    handleTickRangeOptions: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n      // do nothing since that would make the chart weird. If the user really wants a weird chart\n      // axis, they can manually override it\n\n      if (tickOpts.beginAtZero) {\n        var minSign = helpers$1.sign(me.min);\n        var maxSign = helpers$1.sign(me.max);\n\n        if (minSign < 0 && maxSign < 0) {\n          // move the top up to 0\n          me.max = 0;\n        } else if (minSign > 0 && maxSign > 0) {\n          // move the bottom down to 0\n          me.min = 0;\n        }\n      }\n\n      var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n      var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n\n      if (tickOpts.min !== undefined) {\n        me.min = tickOpts.min;\n      } else if (tickOpts.suggestedMin !== undefined) {\n        if (me.min === null) {\n          me.min = tickOpts.suggestedMin;\n        } else {\n          me.min = Math.min(me.min, tickOpts.suggestedMin);\n        }\n      }\n\n      if (tickOpts.max !== undefined) {\n        me.max = tickOpts.max;\n      } else if (tickOpts.suggestedMax !== undefined) {\n        if (me.max === null) {\n          me.max = tickOpts.suggestedMax;\n        } else {\n          me.max = Math.max(me.max, tickOpts.suggestedMax);\n        }\n      }\n\n      if (setMin !== setMax) {\n        // We set the min or the max but not both.\n        // So ensure that our range is good\n        // Inverted or 0 length range can happen when\n        // ticks.min is set, and no datasets are visible\n        if (me.min >= me.max) {\n          if (setMin) {\n            me.max = me.min + 1;\n          } else {\n            me.min = me.max - 1;\n          }\n        }\n      }\n\n      if (me.min === me.max) {\n        me.max++;\n\n        if (!tickOpts.beginAtZero) {\n          me.min--;\n        }\n      }\n    },\n    getTickLimit: function () {\n      var me = this;\n      var tickOpts = me.options.ticks;\n      var stepSize = tickOpts.stepSize;\n      var maxTicksLimit = tickOpts.maxTicksLimit;\n      var maxTicks;\n\n      if (stepSize) {\n        maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;\n      } else {\n        maxTicks = me._computeTickLimit();\n        maxTicksLimit = maxTicksLimit || 11;\n      }\n\n      if (maxTicksLimit) {\n        maxTicks = Math.min(maxTicksLimit, maxTicks);\n      }\n\n      return maxTicks;\n    },\n    _computeTickLimit: function () {\n      return Number.POSITIVE_INFINITY;\n    },\n    handleDirectionalChanges: noop,\n    buildTicks: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of\n      // the axis area. For now, we say that the minimum tick spacing in pixels must be 40\n      // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n      // the graph. Make sure we always have at least 2 ticks\n\n      var maxTicks = me.getTickLimit();\n      maxTicks = Math.max(2, maxTicks);\n      var numericGeneratorOptions = {\n        maxTicks: maxTicks,\n        min: tickOpts.min,\n        max: tickOpts.max,\n        precision: tickOpts.precision,\n        stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n      };\n      var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\n      me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the\n      // range of the scale\n\n      me.max = helpers$1.max(ticks);\n      me.min = helpers$1.min(ticks);\n\n      if (tickOpts.reverse) {\n        ticks.reverse();\n        me.start = me.max;\n        me.end = me.min;\n      } else {\n        me.start = me.min;\n        me.end = me.max;\n      }\n    },\n    convertTicksToLabels: function () {\n      var me = this;\n      me.ticksAsNumbers = me.ticks.slice();\n      me.zeroLineIndex = me.ticks.indexOf(0);\n      core_scale.prototype.convertTicksToLabels.call(me);\n    },\n    _configure: function () {\n      var me = this;\n      var ticks = me.getTicks();\n      var start = me.min;\n      var end = me.max;\n      var offset;\n\n      core_scale.prototype._configure.call(me);\n\n      if (me.options.offset && ticks.length) {\n        offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n        start -= offset;\n        end += offset;\n      }\n\n      me._startValue = start;\n      me._endValue = end;\n      me._valueRange = end - start;\n    }\n  });\n  var defaultConfig$1 = {\n    position: 'left',\n    ticks: {\n      callback: core_ticks.formatters.linear\n    }\n  };\n  var DEFAULT_MIN = 0;\n  var DEFAULT_MAX = 1;\n\n  function getOrCreateStack(stacks, stacked, meta) {\n    var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n    stacked === undefined && meta.stack === undefined ? meta.index : '', meta.stack].join('.');\n\n    if (stacks[key] === undefined) {\n      stacks[key] = {\n        pos: [],\n        neg: []\n      };\n    }\n\n    return stacks[key];\n  }\n\n  function stackData(scale, stacks, meta, data) {\n    var opts = scale.options;\n    var stacked = opts.stacked;\n    var stack = getOrCreateStack(stacks, stacked, meta);\n    var pos = stack.pos;\n    var neg = stack.neg;\n    var ilen = data.length;\n    var i, value;\n\n    for (i = 0; i < ilen; ++i) {\n      value = scale._parseValue(data[i]);\n\n      if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {\n        continue;\n      }\n\n      pos[i] = pos[i] || 0;\n      neg[i] = neg[i] || 0;\n\n      if (opts.relativePoints) {\n        pos[i] = 100;\n      } else if (value.min < 0 || value.max < 0) {\n        neg[i] += value.min;\n      } else {\n        pos[i] += value.max;\n      }\n    }\n  }\n\n  function updateMinMax(scale, meta, data) {\n    var ilen = data.length;\n    var i, value;\n\n    for (i = 0; i < ilen; ++i) {\n      value = scale._parseValue(data[i]);\n\n      if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {\n        continue;\n      }\n\n      scale.min = Math.min(scale.min, value.min);\n      scale.max = Math.max(scale.max, value.max);\n    }\n  }\n\n  var scale_linear = scale_linearbase.extend({\n    determineDataLimits: function () {\n      var me = this;\n      var opts = me.options;\n      var chart = me.chart;\n      var datasets = chart.data.datasets;\n\n      var metasets = me._getMatchingVisibleMetas();\n\n      var hasStacks = opts.stacked;\n      var stacks = {};\n      var ilen = metasets.length;\n      var i, meta, data, values;\n      me.min = Number.POSITIVE_INFINITY;\n      me.max = Number.NEGATIVE_INFINITY;\n\n      if (hasStacks === undefined) {\n        for (i = 0; !hasStacks && i < ilen; ++i) {\n          meta = metasets[i];\n          hasStacks = meta.stack !== undefined;\n        }\n      }\n\n      for (i = 0; i < ilen; ++i) {\n        meta = metasets[i];\n        data = datasets[meta.index].data;\n\n        if (hasStacks) {\n          stackData(me, stacks, meta, data);\n        } else {\n          updateMinMax(me, meta, data);\n        }\n      }\n\n      helpers$1.each(stacks, function (stackValues) {\n        values = stackValues.pos.concat(stackValues.neg);\n        me.min = Math.min(me.min, helpers$1.min(values));\n        me.max = Math.max(me.max, helpers$1.max(values));\n      });\n      me.min = helpers$1.isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;\n      me.max = helpers$1.isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\n      me.handleTickRangeOptions();\n    },\n    // Returns the maximum number of ticks based on the scale dimension\n    _computeTickLimit: function () {\n      var me = this;\n      var tickFont;\n\n      if (me.isHorizontal()) {\n        return Math.ceil(me.width / 40);\n      }\n\n      tickFont = helpers$1.options._parseFont(me.options.ticks);\n      return Math.ceil(me.height / tickFont.lineHeight);\n    },\n    // Called after the ticks are built. We need\n    handleDirectionalChanges: function () {\n      if (!this.isHorizontal()) {\n        // We are in a vertical orientation. The top value is the highest. So reverse the array\n        this.ticks.reverse();\n      }\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);\n    },\n    // Utils\n    getPixelForValue: function (value) {\n      var me = this;\n      return me.getPixelForDecimal((+me.getRightValue(value) - me._startValue) / me._valueRange);\n    },\n    getValueForPixel: function (pixel) {\n      return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n    },\n    getPixelForTick: function (index) {\n      var ticks = this.ticksAsNumbers;\n\n      if (index < 0 || index > ticks.length - 1) {\n        return null;\n      }\n\n      return this.getPixelForValue(ticks[index]);\n    }\n  }); // INTERNAL: static default options, registered in src/index.js\n\n  var _defaults$1 = defaultConfig$1;\n  scale_linear._defaults = _defaults$1;\n  var valueOrDefault$b = helpers$1.valueOrDefault;\n  var log10 = helpers$1.math.log10;\n  /**\n   * Generate a set of logarithmic ticks\n   * @param generationOptions the options used to generate the ticks\n   * @param dataRange the range of the data\n   * @returns {number[]} array of tick values\n   */\n\n  function generateTicks$1(generationOptions, dataRange) {\n    var ticks = [];\n    var tickVal = valueOrDefault$b(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));\n    var endExp = Math.floor(log10(dataRange.max));\n    var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n    var exp, significand;\n\n    if (tickVal === 0) {\n      exp = Math.floor(log10(dataRange.minNotZero));\n      significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n      ticks.push(tickVal);\n      tickVal = significand * Math.pow(10, exp);\n    } else {\n      exp = Math.floor(log10(tickVal));\n      significand = Math.floor(tickVal / Math.pow(10, exp));\n    }\n\n    var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\n    do {\n      ticks.push(tickVal);\n      ++significand;\n\n      if (significand === 10) {\n        significand = 1;\n        ++exp;\n        precision = exp >= 0 ? 1 : precision;\n      }\n\n      tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n    } while (exp < endExp || exp === endExp && significand < endSignificand);\n\n    var lastTick = valueOrDefault$b(generationOptions.max, tickVal);\n    ticks.push(lastTick);\n    return ticks;\n  }\n\n  var defaultConfig$2 = {\n    position: 'left',\n    // label settings\n    ticks: {\n      callback: core_ticks.formatters.logarithmic\n    }\n  }; // TODO(v3): change this to positiveOrDefault\n\n  function nonNegativeOrDefault(value, defaultValue) {\n    return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;\n  }\n\n  var scale_logarithmic = core_scale.extend({\n    determineDataLimits: function () {\n      var me = this;\n      var opts = me.options;\n      var chart = me.chart;\n      var datasets = chart.data.datasets;\n      var isHorizontal = me.isHorizontal();\n\n      function IDMatches(meta) {\n        return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n      }\n\n      var datasetIndex, meta, value, data, i, ilen; // Calculate Range\n\n      me.min = Number.POSITIVE_INFINITY;\n      me.max = Number.NEGATIVE_INFINITY;\n      me.minNotZero = Number.POSITIVE_INFINITY;\n      var hasStacks = opts.stacked;\n\n      if (hasStacks === undefined) {\n        for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {\n          meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {\n            hasStacks = true;\n            break;\n          }\n        }\n      }\n\n      if (opts.stacked || hasStacks) {\n        var valuesPerStack = {};\n\n        for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {\n          meta = chart.getDatasetMeta(datasetIndex);\n          var key = [// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n          meta.type, opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            if (valuesPerStack[key] === undefined) {\n              valuesPerStack[key] = [];\n            }\n\n            data = datasets[datasetIndex].data;\n\n            for (i = 0, ilen = data.length; i < ilen; i++) {\n              var values = valuesPerStack[key];\n              value = me._parseValue(data[i]); // invalid, hidden and negative values are ignored\n\n              if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {\n                continue;\n              }\n\n              values[i] = values[i] || 0;\n              values[i] += value.max;\n            }\n          }\n        }\n\n        helpers$1.each(valuesPerStack, function (valuesForType) {\n          if (valuesForType.length > 0) {\n            var minVal = helpers$1.min(valuesForType);\n            var maxVal = helpers$1.max(valuesForType);\n            me.min = Math.min(me.min, minVal);\n            me.max = Math.max(me.max, maxVal);\n          }\n        });\n      } else {\n        for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {\n          meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            data = datasets[datasetIndex].data;\n\n            for (i = 0, ilen = data.length; i < ilen; i++) {\n              value = me._parseValue(data[i]); // invalid, hidden and negative values are ignored\n\n              if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {\n                continue;\n              }\n\n              me.min = Math.min(value.min, me.min);\n              me.max = Math.max(value.max, me.max);\n\n              if (value.min !== 0) {\n                me.minNotZero = Math.min(value.min, me.minNotZero);\n              }\n            }\n          }\n        }\n      }\n\n      me.min = helpers$1.isFinite(me.min) ? me.min : null;\n      me.max = helpers$1.isFinite(me.max) ? me.max : null;\n      me.minNotZero = helpers$1.isFinite(me.minNotZero) ? me.minNotZero : null; // Common base implementation to handle ticks.min, ticks.max\n\n      this.handleTickRangeOptions();\n    },\n    handleTickRangeOptions: function () {\n      var me = this;\n      var tickOpts = me.options.ticks;\n      var DEFAULT_MIN = 1;\n      var DEFAULT_MAX = 10;\n      me.min = nonNegativeOrDefault(tickOpts.min, me.min);\n      me.max = nonNegativeOrDefault(tickOpts.max, me.max);\n\n      if (me.min === me.max) {\n        if (me.min !== 0 && me.min !== null) {\n          me.min = Math.pow(10, Math.floor(log10(me.min)) - 1);\n          me.max = Math.pow(10, Math.floor(log10(me.max)) + 1);\n        } else {\n          me.min = DEFAULT_MIN;\n          me.max = DEFAULT_MAX;\n        }\n      }\n\n      if (me.min === null) {\n        me.min = Math.pow(10, Math.floor(log10(me.max)) - 1);\n      }\n\n      if (me.max === null) {\n        me.max = me.min !== 0 ? Math.pow(10, Math.floor(log10(me.min)) + 1) : DEFAULT_MAX;\n      }\n\n      if (me.minNotZero === null) {\n        if (me.min > 0) {\n          me.minNotZero = me.min;\n        } else if (me.max < 1) {\n          me.minNotZero = Math.pow(10, Math.floor(log10(me.max)));\n        } else {\n          me.minNotZero = DEFAULT_MIN;\n        }\n      }\n    },\n    buildTicks: function () {\n      var me = this;\n      var tickOpts = me.options.ticks;\n      var reverse = !me.isHorizontal();\n      var generationOptions = {\n        min: nonNegativeOrDefault(tickOpts.min),\n        max: nonNegativeOrDefault(tickOpts.max)\n      };\n      var ticks = me.ticks = generateTicks$1(generationOptions, me); // At this point, we need to update our max and min given the tick values since we have expanded the\n      // range of the scale\n\n      me.max = helpers$1.max(ticks);\n      me.min = helpers$1.min(ticks);\n\n      if (tickOpts.reverse) {\n        reverse = !reverse;\n        me.start = me.max;\n        me.end = me.min;\n      } else {\n        me.start = me.min;\n        me.end = me.max;\n      }\n\n      if (reverse) {\n        ticks.reverse();\n      }\n    },\n    convertTicksToLabels: function () {\n      this.tickValues = this.ticks.slice();\n      core_scale.prototype.convertTicksToLabels.call(this);\n    },\n    // Get the correct tooltip label\n    getLabelForIndex: function (index, datasetIndex) {\n      return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);\n    },\n    getPixelForTick: function (index) {\n      var ticks = this.tickValues;\n\n      if (index < 0 || index > ticks.length - 1) {\n        return null;\n      }\n\n      return this.getPixelForValue(ticks[index]);\n    },\n\n    /**\n     * Returns the value of the first tick.\n     * @param {number} value - The minimum not zero value.\n     * @return {number} The first tick value.\n     * @private\n     */\n    _getFirstTickValue: function (value) {\n      var exp = Math.floor(log10(value));\n      var significand = Math.floor(value / Math.pow(10, exp));\n      return significand * Math.pow(10, exp);\n    },\n    _configure: function () {\n      var me = this;\n      var start = me.min;\n      var offset = 0;\n\n      core_scale.prototype._configure.call(me);\n\n      if (start === 0) {\n        start = me._getFirstTickValue(me.minNotZero);\n        offset = valueOrDefault$b(me.options.ticks.fontSize, core_defaults.global.defaultFontSize) / me._length;\n      }\n\n      me._startValue = log10(start);\n      me._valueOffset = offset;\n      me._valueRange = (log10(me.max) - log10(start)) / (1 - offset);\n    },\n    getPixelForValue: function (value) {\n      var me = this;\n      var decimal = 0;\n      value = +me.getRightValue(value);\n\n      if (value > me.min && value > 0) {\n        decimal = (log10(value) - me._startValue) / me._valueRange + me._valueOffset;\n      }\n\n      return me.getPixelForDecimal(decimal);\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var decimal = me.getDecimalForPixel(pixel);\n      return decimal === 0 && me.min === 0 ? 0 : Math.pow(10, me._startValue + (decimal - me._valueOffset) * me._valueRange);\n    }\n  }); // INTERNAL: static default options, registered in src/index.js\n\n  var _defaults$2 = defaultConfig$2;\n  scale_logarithmic._defaults = _defaults$2;\n  var valueOrDefault$c = helpers$1.valueOrDefault;\n  var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;\n  var resolve$4 = helpers$1.options.resolve;\n  var defaultConfig$3 = {\n    display: true,\n    // Boolean - Whether to animate scaling the chart from the centre\n    animate: true,\n    position: 'chartArea',\n    angleLines: {\n      display: true,\n      color: 'rgba(0,0,0,0.1)',\n      lineWidth: 1,\n      borderDash: [],\n      borderDashOffset: 0.0\n    },\n    gridLines: {\n      circular: false\n    },\n    // label settings\n    ticks: {\n      // Boolean - Show a backdrop to the scale label\n      showLabelBackdrop: true,\n      // String - The colour of the label backdrop\n      backdropColor: 'rgba(255,255,255,0.75)',\n      // Number - The backdrop padding above & below the label in pixels\n      backdropPaddingY: 2,\n      // Number - The backdrop padding to the side of the label in pixels\n      backdropPaddingX: 2,\n      callback: core_ticks.formatters.linear\n    },\n    pointLabels: {\n      // Boolean - if true, show point labels\n      display: true,\n      // Number - Point label font size in pixels\n      fontSize: 10,\n      // Function - Used to convert point labels\n      callback: function (label) {\n        return label;\n      }\n    }\n  };\n\n  function getTickBackdropHeight(opts) {\n    var tickOpts = opts.ticks;\n\n    if (tickOpts.display && opts.display) {\n      return valueOrDefault$c(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;\n    }\n\n    return 0;\n  }\n\n  function measureLabelSize(ctx, lineHeight, label) {\n    if (helpers$1.isArray(label)) {\n      return {\n        w: helpers$1.longestText(ctx, ctx.font, label),\n        h: label.length * lineHeight\n      };\n    }\n\n    return {\n      w: ctx.measureText(label).width,\n      h: lineHeight\n    };\n  }\n\n  function determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n      return {\n        start: pos - size / 2,\n        end: pos + size / 2\n      };\n    } else if (angle < min || angle > max) {\n      return {\n        start: pos - size,\n        end: pos\n      };\n    }\n\n    return {\n      start: pos,\n      end: pos + size\n    };\n  }\n  /**\n   * Helper function to fit a radial linear scale with point labels\n   */\n\n\n  function fitWithPointLabels(scale) {\n    // Right, this is really confusing and there is a lot of maths going on here\n    // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n    //\n    // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n    //\n    // Solution:\n    //\n    // We assume the radius of the polygon is half the size of the canvas at first\n    // at each index we check if the text overlaps.\n    //\n    // Where it does, we store that angle and that index.\n    //\n    // After finding the largest index and angle we calculate how much we need to remove\n    // from the shape radius to move the point inwards by that x.\n    //\n    // We average the left and right distances to get the maximum shape radius that can fit in the box\n    // along with labels.\n    //\n    // Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n    // on each side, removing that from the size, halving it and adding the left x protrusion width.\n    //\n    // This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n    // and position it in the most space efficient manner\n    //\n    // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n    var plFont = helpers$1.options._parseFont(scale.options.pointLabels); // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n    // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\n\n    var furthestLimits = {\n      l: 0,\n      r: scale.width,\n      t: 0,\n      b: scale.height - scale.paddingTop\n    };\n    var furthestAngles = {};\n    var i, textSize, pointPosition;\n    scale.ctx.font = plFont.string;\n    scale._pointLabelSizes = [];\n    var valueCount = scale.chart.data.labels.length;\n\n    for (i = 0; i < valueCount; i++) {\n      pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);\n      textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i]);\n      scale._pointLabelSizes[i] = textSize; // Add quarter circle to make degree 0 mean top of circle\n\n      var angleRadians = scale.getIndexAngle(i);\n      var angle = helpers$1.toDegrees(angleRadians) % 360;\n      var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n      var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n      if (hLimits.start < furthestLimits.l) {\n        furthestLimits.l = hLimits.start;\n        furthestAngles.l = angleRadians;\n      }\n\n      if (hLimits.end > furthestLimits.r) {\n        furthestLimits.r = hLimits.end;\n        furthestAngles.r = angleRadians;\n      }\n\n      if (vLimits.start < furthestLimits.t) {\n        furthestLimits.t = vLimits.start;\n        furthestAngles.t = angleRadians;\n      }\n\n      if (vLimits.end > furthestLimits.b) {\n        furthestLimits.b = vLimits.end;\n        furthestAngles.b = angleRadians;\n      }\n    }\n\n    scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);\n  }\n\n  function getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n      return 'center';\n    } else if (angle < 180) {\n      return 'left';\n    }\n\n    return 'right';\n  }\n\n  function fillText(ctx, text, position, lineHeight) {\n    var y = position.y + lineHeight / 2;\n    var i, ilen;\n\n    if (helpers$1.isArray(text)) {\n      for (i = 0, ilen = text.length; i < ilen; ++i) {\n        ctx.fillText(text[i], position.x, y);\n        y += lineHeight;\n      }\n    } else {\n      ctx.fillText(text, position.x, y);\n    }\n  }\n\n  function adjustPointPositionForLabelHeight(angle, textSize, position) {\n    if (angle === 90 || angle === 270) {\n      position.y -= textSize.h / 2;\n    } else if (angle > 270 || angle < 90) {\n      position.y -= textSize.h;\n    }\n  }\n\n  function drawPointLabels(scale) {\n    var ctx = scale.ctx;\n    var opts = scale.options;\n    var pointLabelOpts = opts.pointLabels;\n    var tickBackdropHeight = getTickBackdropHeight(opts);\n    var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\n\n    var plFont = helpers$1.options._parseFont(pointLabelOpts);\n\n    ctx.save();\n    ctx.font = plFont.string;\n    ctx.textBaseline = 'middle';\n\n    for (var i = scale.chart.data.labels.length - 1; i >= 0; i--) {\n      // Extra pixels out for some label spacing\n      var extra = i === 0 ? tickBackdropHeight / 2 : 0;\n      var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5); // Keep this in loop since we may support array properties here\n\n      var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);\n      ctx.fillStyle = pointLabelFontColor;\n      var angleRadians = scale.getIndexAngle(i);\n      var angle = helpers$1.toDegrees(angleRadians);\n      ctx.textAlign = getTextAlignForAngle(angle);\n      adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n      fillText(ctx, scale.pointLabels[i], pointLabelPosition, plFont.lineHeight);\n    }\n\n    ctx.restore();\n  }\n\n  function drawRadiusLine(scale, gridLineOpts, radius, index) {\n    var ctx = scale.ctx;\n    var circular = gridLineOpts.circular;\n    var valueCount = scale.chart.data.labels.length;\n    var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);\n    var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);\n    var pointPosition;\n\n    if (!circular && !valueCount || !lineColor || !lineWidth) {\n      return;\n    }\n\n    ctx.save();\n    ctx.strokeStyle = lineColor;\n    ctx.lineWidth = lineWidth;\n\n    if (ctx.setLineDash) {\n      ctx.setLineDash(gridLineOpts.borderDash || []);\n      ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;\n    }\n\n    ctx.beginPath();\n\n    if (circular) {\n      // Draw circular arcs between the points\n      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n    } else {\n      // Draw straight lines connecting each index\n      pointPosition = scale.getPointPosition(0, radius);\n      ctx.moveTo(pointPosition.x, pointPosition.y);\n\n      for (var i = 1; i < valueCount; i++) {\n        pointPosition = scale.getPointPosition(i, radius);\n        ctx.lineTo(pointPosition.x, pointPosition.y);\n      }\n    }\n\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  function numberOrZero(param) {\n    return helpers$1.isNumber(param) ? param : 0;\n  }\n\n  var scale_radialLinear = scale_linearbase.extend({\n    setDimensions: function () {\n      var me = this; // Set the unconstrained dimension before label rotation\n\n      me.width = me.maxWidth;\n      me.height = me.maxHeight;\n      me.paddingTop = getTickBackdropHeight(me.options) / 2;\n      me.xCenter = Math.floor(me.width / 2);\n      me.yCenter = Math.floor((me.height - me.paddingTop) / 2);\n      me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;\n    },\n    determineDataLimits: function () {\n      var me = this;\n      var chart = me.chart;\n      var min = Number.POSITIVE_INFINITY;\n      var max = Number.NEGATIVE_INFINITY;\n      helpers$1.each(chart.data.datasets, function (dataset, datasetIndex) {\n        if (chart.isDatasetVisible(datasetIndex)) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n          helpers$1.each(dataset.data, function (rawValue, index) {\n            var value = +me.getRightValue(rawValue);\n\n            if (isNaN(value) || meta.data[index].hidden) {\n              return;\n            }\n\n            min = Math.min(value, min);\n            max = Math.max(value, max);\n          });\n        }\n      });\n      me.min = min === Number.POSITIVE_INFINITY ? 0 : min;\n      me.max = max === Number.NEGATIVE_INFINITY ? 0 : max; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\n      me.handleTickRangeOptions();\n    },\n    // Returns the maximum number of ticks based on the scale dimension\n    _computeTickLimit: function () {\n      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n    },\n    convertTicksToLabels: function () {\n      var me = this;\n      scale_linearbase.prototype.convertTicksToLabels.call(me); // Point labels\n\n      me.pointLabels = me.chart.data.labels.map(function () {\n        var label = helpers$1.callback(me.options.pointLabels.callback, arguments, me);\n        return label || label === 0 ? label : '';\n      });\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n    },\n    fit: function () {\n      var me = this;\n      var opts = me.options;\n\n      if (opts.display && opts.pointLabels.display) {\n        fitWithPointLabels(me);\n      } else {\n        me.setCenterPoint(0, 0, 0, 0);\n      }\n    },\n\n    /**\n     * Set radius reductions and determine new radius and center point\n     * @private\n     */\n    setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {\n      var me = this;\n      var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n      var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n      var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n      var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\n      radiusReductionLeft = numberOrZero(radiusReductionLeft);\n      radiusReductionRight = numberOrZero(radiusReductionRight);\n      radiusReductionTop = numberOrZero(radiusReductionTop);\n      radiusReductionBottom = numberOrZero(radiusReductionBottom);\n      me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n      me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n    },\n    setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {\n      var me = this;\n      var maxRight = me.width - rightMovement - me.drawingArea;\n      var maxLeft = leftMovement + me.drawingArea;\n      var maxTop = topMovement + me.drawingArea;\n      var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;\n      me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);\n      me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);\n    },\n    getIndexAngle: function (index) {\n      var chart = this.chart;\n      var angleMultiplier = 360 / chart.data.labels.length;\n      var options = chart.options || {};\n      var startAngle = options.startAngle || 0; // Start from the top instead of right, so remove a quarter of the circle\n\n      var angle = (index * angleMultiplier + startAngle) % 360;\n      return (angle < 0 ? angle + 360 : angle) * Math.PI * 2 / 360;\n    },\n    getDistanceFromCenterForValue: function (value) {\n      var me = this;\n\n      if (helpers$1.isNullOrUndef(value)) {\n        return NaN;\n      } // Take into account half font size + the yPadding of the top value\n\n\n      var scalingFactor = me.drawingArea / (me.max - me.min);\n\n      if (me.options.ticks.reverse) {\n        return (me.max - value) * scalingFactor;\n      }\n\n      return (value - me.min) * scalingFactor;\n    },\n    getPointPosition: function (index, distanceFromCenter) {\n      var me = this;\n      var thisAngle = me.getIndexAngle(index) - Math.PI / 2;\n      return {\n        x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,\n        y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter\n      };\n    },\n    getPointPositionForValue: function (index, value) {\n      return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    },\n    getBasePosition: function (index) {\n      var me = this;\n      var min = me.min;\n      var max = me.max;\n      return me.getPointPositionForValue(index || 0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);\n    },\n\n    /**\n     * @private\n     */\n    _drawGrid: function () {\n      var me = this;\n      var ctx = me.ctx;\n      var opts = me.options;\n      var gridLineOpts = opts.gridLines;\n      var angleLineOpts = opts.angleLines;\n      var lineWidth = valueOrDefault$c(angleLineOpts.lineWidth, gridLineOpts.lineWidth);\n      var lineColor = valueOrDefault$c(angleLineOpts.color, gridLineOpts.color);\n      var i, offset, position;\n\n      if (opts.pointLabels.display) {\n        drawPointLabels(me);\n      }\n\n      if (gridLineOpts.display) {\n        helpers$1.each(me.ticks, function (label, index) {\n          if (index !== 0) {\n            offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n            drawRadiusLine(me, gridLineOpts, offset, index);\n          }\n        });\n      }\n\n      if (angleLineOpts.display && lineWidth && lineColor) {\n        ctx.save();\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = lineColor;\n\n        if (ctx.setLineDash) {\n          ctx.setLineDash(resolve$4([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));\n          ctx.lineDashOffset = resolve$4([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);\n        }\n\n        for (i = me.chart.data.labels.length - 1; i >= 0; i--) {\n          offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);\n          position = me.getPointPosition(i, offset);\n          ctx.beginPath();\n          ctx.moveTo(me.xCenter, me.yCenter);\n          ctx.lineTo(position.x, position.y);\n          ctx.stroke();\n        }\n\n        ctx.restore();\n      }\n    },\n\n    /**\n     * @private\n     */\n    _drawLabels: function () {\n      var me = this;\n      var ctx = me.ctx;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n\n      if (!tickOpts.display) {\n        return;\n      }\n\n      var startAngle = me.getIndexAngle(0);\n\n      var tickFont = helpers$1.options._parseFont(tickOpts);\n\n      var tickFontColor = valueOrDefault$c(tickOpts.fontColor, core_defaults.global.defaultFontColor);\n      var offset, width;\n      ctx.save();\n      ctx.font = tickFont.string;\n      ctx.translate(me.xCenter, me.yCenter);\n      ctx.rotate(startAngle);\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      helpers$1.each(me.ticks, function (label, index) {\n        if (index === 0 && !tickOpts.reverse) {\n          return;\n        }\n\n        offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n\n        if (tickOpts.showLabelBackdrop) {\n          width = ctx.measureText(label).width;\n          ctx.fillStyle = tickOpts.backdropColor;\n          ctx.fillRect(-width / 2 - tickOpts.backdropPaddingX, -offset - tickFont.size / 2 - tickOpts.backdropPaddingY, width + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);\n        }\n\n        ctx.fillStyle = tickFontColor;\n        ctx.fillText(label, 0, -offset);\n      });\n      ctx.restore();\n    },\n\n    /**\n     * @private\n     */\n    _drawTitle: helpers$1.noop\n  }); // INTERNAL: static default options, registered in src/index.js\n\n  var _defaults$3 = defaultConfig$3;\n  scale_radialLinear._defaults = _defaults$3;\n  var deprecated$1 = helpers$1._deprecated;\n  var resolve$5 = helpers$1.options.resolve;\n  var valueOrDefault$d = helpers$1.valueOrDefault; // Integer constants are from the ES6 spec.\n\n  var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\n  var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n  var INTERVALS = {\n    millisecond: {\n      common: true,\n      size: 1,\n      steps: 1000\n    },\n    second: {\n      common: true,\n      size: 1000,\n      steps: 60\n    },\n    minute: {\n      common: true,\n      size: 60000,\n      steps: 60\n    },\n    hour: {\n      common: true,\n      size: 3600000,\n      steps: 24\n    },\n    day: {\n      common: true,\n      size: 86400000,\n      steps: 30\n    },\n    week: {\n      common: false,\n      size: 604800000,\n      steps: 4\n    },\n    month: {\n      common: true,\n      size: 2.628e9,\n      steps: 12\n    },\n    quarter: {\n      common: false,\n      size: 7.884e9,\n      steps: 4\n    },\n    year: {\n      common: true,\n      size: 3.154e10\n    }\n  };\n  var UNITS = Object.keys(INTERVALS);\n\n  function sorter(a, b) {\n    return a - b;\n  }\n\n  function arrayUnique(items) {\n    var hash = {};\n    var out = [];\n    var i, ilen, item;\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n\n      if (!hash[item]) {\n        hash[item] = true;\n        out.push(item);\n      }\n    }\n\n    return out;\n  }\n\n  function getMin(options) {\n    return helpers$1.valueOrDefault(options.time.min, options.ticks.min);\n  }\n\n  function getMax(options) {\n    return helpers$1.valueOrDefault(options.time.max, options.ticks.max);\n  }\n  /**\n   * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n   * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n   * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n   * extremity (left + width or top + height). Note that it would be more optimized to directly\n   * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n   * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n   *\n   * @param {number[]} timestamps - timestamps sorted from lowest to highest.\n   * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min\n   * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.\n   * If 'series', timestamps will be positioned at the same distance from each other. In this\n   * case, only timestamps that break the time linearity are registered, meaning that in the\n   * best case, all timestamps are linear, the table contains only min and max.\n   */\n\n\n  function buildLookupTable(timestamps, min, max, distribution) {\n    if (distribution === 'linear' || !timestamps.length) {\n      return [{\n        time: min,\n        pos: 0\n      }, {\n        time: max,\n        pos: 1\n      }];\n    }\n\n    var table = [];\n    var items = [min];\n    var i, ilen, prev, curr, next;\n\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n\n      if (curr > min && curr < max) {\n        items.push(curr);\n      }\n    }\n\n    items.push(max);\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i]; // only add points that breaks the scale linearity\n\n      if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {\n        table.push({\n          time: curr,\n          pos: i / (ilen - 1)\n        });\n      }\n    }\n\n    return table;\n  } // @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/\n\n\n  function lookup(table, key, value) {\n    var lo = 0;\n    var hi = table.length - 1;\n    var mid, i0, i1;\n\n    while (lo >= 0 && lo <= hi) {\n      mid = lo + hi >> 1;\n      i0 = table[mid - 1] || null;\n      i1 = table[mid];\n\n      if (!i0) {\n        // given value is outside table (before first item)\n        return {\n          lo: null,\n          hi: i1\n        };\n      } else if (i1[key] < value) {\n        lo = mid + 1;\n      } else if (i0[key] > value) {\n        hi = mid - 1;\n      } else {\n        return {\n          lo: i0,\n          hi: i1\n        };\n      }\n    } // given value is outside table (after last item)\n\n\n    return {\n      lo: i1,\n      hi: null\n    };\n  }\n  /**\n   * Linearly interpolates the given source `value` using the table items `skey` values and\n   * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\n   * returns the position for a timestamp equal to 42. If value is out of bounds, values at\n   * index [0, 1] or [n - 1, n] are used for the interpolation.\n   */\n\n\n  function interpolate$1(table, skey, sval, tkey) {\n    var range = lookup(table, skey, sval); // Note: the lookup table ALWAYS contains at least 2 items (min and max)\n\n    var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;\n    var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;\n    var span = next[skey] - prev[skey];\n    var ratio = span ? (sval - prev[skey]) / span : 0;\n    var offset = (next[tkey] - prev[tkey]) * ratio;\n    return prev[tkey] + offset;\n  }\n\n  function toTimestamp(scale, input) {\n    var adapter = scale._adapter;\n    var options = scale.options.time;\n    var parser = options.parser;\n    var format = parser || options.format;\n    var value = input;\n\n    if (typeof parser === 'function') {\n      value = parser(value);\n    } // Only parse if its not a timestamp already\n\n\n    if (!helpers$1.isFinite(value)) {\n      value = typeof format === 'string' ? adapter.parse(value, format) : adapter.parse(value);\n    }\n\n    if (value !== null) {\n      return +value;\n    } // Labels are in an incompatible format and no `parser` has been provided.\n    // The user might still use the deprecated `format` option for parsing.\n\n\n    if (!parser && typeof format === 'function') {\n      value = format(input); // `format` could return something else than a timestamp, if so, parse it\n\n      if (!helpers$1.isFinite(value)) {\n        value = adapter.parse(value);\n      }\n    }\n\n    return value;\n  }\n\n  function parse(scale, input) {\n    if (helpers$1.isNullOrUndef(input)) {\n      return null;\n    }\n\n    var options = scale.options.time;\n    var value = toTimestamp(scale, scale.getRightValue(input));\n\n    if (value === null) {\n      return value;\n    }\n\n    if (options.round) {\n      value = +scale._adapter.startOf(value, options.round);\n    }\n\n    return value;\n  }\n  /**\n   * Figures out what unit results in an appropriate number of auto-generated ticks\n   */\n\n\n  function determineUnitForAutoTicks(minUnit, min, max, capacity) {\n    var ilen = UNITS.length;\n    var i, interval, factor;\n\n    for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n      interval = INTERVALS[UNITS[i]];\n      factor = interval.steps ? interval.steps : MAX_INTEGER;\n\n      if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n        return UNITS[i];\n      }\n    }\n\n    return UNITS[ilen - 1];\n  }\n  /**\n   * Figures out what unit to format a set of ticks with\n   */\n\n\n  function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n    var i, unit;\n\n    for (i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n      unit = UNITS[i];\n\n      if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n        return unit;\n      }\n    }\n\n    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n  }\n\n  function determineMajorUnit(unit) {\n    for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n      if (INTERVALS[UNITS[i]].common) {\n        return UNITS[i];\n      }\n    }\n  }\n  /**\n   * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n   * `minor` unit using the given scale time `options`.\n   * Important: this method can return ticks outside the min and max range, it's the\n   * responsibility of the calling code to clamp values if needed.\n   */\n\n\n  function generate(scale, min, max, capacity) {\n    var adapter = scale._adapter;\n    var options = scale.options;\n    var timeOpts = options.time;\n    var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n    var stepSize = resolve$5([timeOpts.stepSize, timeOpts.unitStepSize, 1]);\n    var weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    var first = min;\n    var ticks = [];\n    var time; // For 'week' unit, handle the first day of week option\n\n    if (weekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    } // Align first ticks on unit\n\n\n    first = +adapter.startOf(first, weekday ? 'day' : minor); // Prevent browser from freezing in case user options request millions of milliseconds\n\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor;\n    }\n\n    for (time = first; time < max; time = +adapter.add(time, stepSize, minor)) {\n      ticks.push(time);\n    }\n\n    if (time === max || options.bounds === 'ticks') {\n      ticks.push(time);\n    }\n\n    return ticks;\n  }\n  /**\n   * Returns the start and end offsets from edges in the form of {start, end}\n   * where each value is a relative width to the scale and ranges between 0 and 1.\n   * They add extra margins on the both sides by scaling down the original scale.\n   * Offsets are added when the `offset` option is true.\n   */\n\n\n  function computeOffsets(table, ticks, min, max, options) {\n    var start = 0;\n    var end = 0;\n    var first, last;\n\n    if (options.offset && ticks.length) {\n      first = interpolate$1(table, 'time', ticks[0], 'pos');\n\n      if (ticks.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;\n      }\n\n      last = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');\n\n      if (ticks.length === 1) {\n        end = last;\n      } else {\n        end = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;\n      }\n    }\n\n    return {\n      start: start,\n      end: end,\n      factor: 1 / (start + 1 + end)\n    };\n  }\n\n  function setMajorTicks(scale, ticks, map, majorUnit) {\n    var adapter = scale._adapter;\n    var first = +adapter.startOf(ticks[0].value, majorUnit);\n    var last = ticks[ticks.length - 1].value;\n    var major, index;\n\n    for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n      index = map[major];\n\n      if (index >= 0) {\n        ticks[index].major = true;\n      }\n    }\n\n    return ticks;\n  }\n\n  function ticksFromTimestamps(scale, values, majorUnit) {\n    var ticks = [];\n    var map = {};\n    var ilen = values.length;\n    var i, value;\n\n    for (i = 0; i < ilen; ++i) {\n      value = values[i];\n      map[value] = i;\n      ticks.push({\n        value: value,\n        major: false\n      });\n    } // We set the major ticks separately from the above loop because calling startOf for every tick\n    // is expensive when there is a large number of ticks\n\n\n    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n  }\n\n  var defaultConfig$4 = {\n    position: 'bottom',\n\n    /**\n     * Data distribution along the scale:\n     * - 'linear': data are spread according to their time (distances can vary),\n     * - 'series': data are spread at the same distance from each other.\n     * @see https://github.com/chartjs/Chart.js/pull/4507\n     * @since 2.7.0\n     */\n    distribution: 'linear',\n\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 2.7.0\n     */\n    bounds: 'data',\n    adapters: {},\n    time: {\n      parser: false,\n      // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n      unit: false,\n      // false == automatic or override with week, month, year, etc.\n      round: false,\n      // none, or override with week, month, year, etc.\n      displayFormat: false,\n      // DEPRECATED\n      isoWeekday: false,\n      // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/\n      minUnit: 'millisecond',\n      displayFormats: {}\n    },\n    ticks: {\n      autoSkip: false,\n\n      /**\n       * Ticks generation input values:\n       * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n       * - 'labels': generates ticks from user given `data.labels` values ONLY.\n       * @see https://github.com/chartjs/Chart.js/pull/4507\n       * @since 2.7.0\n       */\n      source: 'auto',\n      major: {\n        enabled: false\n      }\n    }\n  };\n  var scale_time = core_scale.extend({\n    initialize: function () {\n      this.mergeTicksOptions();\n      core_scale.prototype.initialize.call(this);\n    },\n    update: function () {\n      var me = this;\n      var options = me.options;\n      var time = options.time || (options.time = {});\n      var adapter = me._adapter = new core_adapters._date(options.adapters.date); // DEPRECATIONS: output a message only one time per update\n\n      deprecated$1('time scale', time.format, 'time.format', 'time.parser');\n      deprecated$1('time scale', time.min, 'time.min', 'ticks.min');\n      deprecated$1('time scale', time.max, 'time.max', 'ticks.max'); // Backward compatibility: before introducing adapter, `displayFormats` was\n      // supposed to contain *all* unit/string pairs but this can't be resolved\n      // when loading the scale (adapters are loaded afterward), so let's populate\n      // missing formats on update\n\n      helpers$1.mergeIf(time.displayFormats, adapter.formats());\n      return core_scale.prototype.update.apply(me, arguments);\n    },\n\n    /**\n     * Allows data to be referenced via 't' attribute\n     */\n    getRightValue: function (rawValue) {\n      if (rawValue && rawValue.t !== undefined) {\n        rawValue = rawValue.t;\n      }\n\n      return core_scale.prototype.getRightValue.call(this, rawValue);\n    },\n    determineDataLimits: function () {\n      var me = this;\n      var chart = me.chart;\n      var adapter = me._adapter;\n      var options = me.options;\n      var unit = options.time.unit || 'day';\n      var min = MAX_INTEGER;\n      var max = MIN_INTEGER;\n      var timestamps = [];\n      var datasets = [];\n      var labels = [];\n      var i, j, ilen, jlen, data, timestamp, labelsAdded;\n\n      var dataLabels = me._getLabels();\n\n      for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {\n        labels.push(parse(me, dataLabels[i]));\n      }\n\n      for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          data = chart.data.datasets[i].data; // Let's consider that all data have the same format.\n\n          if (helpers$1.isObject(data[0])) {\n            datasets[i] = [];\n\n            for (j = 0, jlen = data.length; j < jlen; ++j) {\n              timestamp = parse(me, data[j]);\n              timestamps.push(timestamp);\n              datasets[i][j] = timestamp;\n            }\n          } else {\n            datasets[i] = labels.slice(0);\n\n            if (!labelsAdded) {\n              timestamps = timestamps.concat(labels);\n              labelsAdded = true;\n            }\n          }\n        } else {\n          datasets[i] = [];\n        }\n      }\n\n      if (labels.length) {\n        min = Math.min(min, labels[0]);\n        max = Math.max(max, labels[labels.length - 1]);\n      }\n\n      if (timestamps.length) {\n        timestamps = ilen > 1 ? arrayUnique(timestamps).sort(sorter) : timestamps.sort(sorter);\n        min = Math.min(min, timestamps[0]);\n        max = Math.max(max, timestamps[timestamps.length - 1]);\n      }\n\n      min = parse(me, getMin(options)) || min;\n      max = parse(me, getMax(options)) || max; // In case there is no valid min/max, set limits based on unit time option\n\n      min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;\n      max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max; // Make sure that max is strictly higher than min (required by the lookup table)\n\n      me.min = Math.min(min, max);\n      me.max = Math.max(min + 1, max); // PRIVATE\n\n      me._table = [];\n      me._timestamps = {\n        data: timestamps,\n        datasets: datasets,\n        labels: labels\n      };\n    },\n    buildTicks: function () {\n      var me = this;\n      var min = me.min;\n      var max = me.max;\n      var options = me.options;\n      var tickOpts = options.ticks;\n      var timeOpts = options.time;\n      var timestamps = me._timestamps;\n      var ticks = [];\n      var capacity = me.getLabelCapacity(min);\n      var source = tickOpts.source;\n      var distribution = options.distribution;\n      var i, ilen, timestamp;\n\n      if (source === 'data' || source === 'auto' && distribution === 'series') {\n        timestamps = timestamps.data;\n      } else if (source === 'labels') {\n        timestamps = timestamps.labels;\n      } else {\n        timestamps = generate(me, min, max, capacity);\n      }\n\n      if (options.bounds === 'ticks' && timestamps.length) {\n        min = timestamps[0];\n        max = timestamps[timestamps.length - 1];\n      } // Enforce limits with user min/max options\n\n\n      min = parse(me, getMin(options)) || min;\n      max = parse(me, getMax(options)) || max; // Remove ticks outside the min/max range\n\n      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n        timestamp = timestamps[i];\n\n        if (timestamp >= min && timestamp <= max) {\n          ticks.push(timestamp);\n        }\n      }\n\n      me.min = min;\n      me.max = max; // PRIVATE\n      // determineUnitForFormatting relies on the number of ticks so we don't use it when\n      // autoSkip is enabled because we don't yet know what the final number of ticks will be\n\n      me._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, capacity) : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));\n      me._majorUnit = !tickOpts.major.enabled || me._unit === 'year' ? undefined : determineMajorUnit(me._unit);\n      me._table = buildLookupTable(me._timestamps.data, min, max, distribution);\n      me._offsets = computeOffsets(me._table, ticks, min, max, options);\n\n      if (tickOpts.reverse) {\n        ticks.reverse();\n      }\n\n      return ticksFromTimestamps(me, ticks, me._majorUnit);\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      var me = this;\n      var adapter = me._adapter;\n      var data = me.chart.data;\n      var timeOpts = me.options.time;\n      var label = data.labels && index < data.labels.length ? data.labels[index] : '';\n      var value = data.datasets[datasetIndex].data[index];\n\n      if (helpers$1.isObject(value)) {\n        label = me.getRightValue(value);\n      }\n\n      if (timeOpts.tooltipFormat) {\n        return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);\n      }\n\n      if (typeof label === 'string') {\n        return label;\n      }\n\n      return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);\n    },\n\n    /**\n     * Function to format an individual tick mark\n     * @private\n     */\n    tickFormatFunction: function (time, index, ticks, format) {\n      var me = this;\n      var adapter = me._adapter;\n      var options = me.options;\n      var formats = options.time.displayFormats;\n      var minorFormat = formats[me._unit];\n      var majorUnit = me._majorUnit;\n      var majorFormat = formats[majorUnit];\n      var tick = ticks[index];\n      var tickOpts = options.ticks;\n      var major = majorUnit && majorFormat && tick && tick.major;\n      var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);\n      var nestedTickOpts = major ? tickOpts.major : tickOpts.minor;\n      var formatter = resolve$5([nestedTickOpts.callback, nestedTickOpts.userCallback, tickOpts.callback, tickOpts.userCallback]);\n      return formatter ? formatter(label, index, ticks) : label;\n    },\n    convertTicksToLabels: function (ticks) {\n      var labels = [];\n      var i, ilen;\n\n      for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n        labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));\n      }\n\n      return labels;\n    },\n\n    /**\n     * @private\n     */\n    getPixelForOffset: function (time) {\n      var me = this;\n      var offsets = me._offsets;\n      var pos = interpolate$1(me._table, 'time', time, 'pos');\n      return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n    },\n    getPixelForValue: function (value, index, datasetIndex) {\n      var me = this;\n      var time = null;\n\n      if (index !== undefined && datasetIndex !== undefined) {\n        time = me._timestamps.datasets[datasetIndex][index];\n      }\n\n      if (time === null) {\n        time = parse(me, value);\n      }\n\n      if (time !== null) {\n        return me.getPixelForOffset(time);\n      }\n    },\n    getPixelForTick: function (index) {\n      var ticks = this.getTicks();\n      return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var offsets = me._offsets;\n      var pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n      var time = interpolate$1(me._table, 'pos', pos, 'time'); // DEPRECATION, we should return time directly\n\n      return me._adapter._create(time);\n    },\n\n    /**\n     * @private\n     */\n    _getLabelSize: function (label) {\n      var me = this;\n      var ticksOpts = me.options.ticks;\n      var tickLabelWidth = me.ctx.measureText(label).width;\n      var angle = helpers$1.toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n      var cosRotation = Math.cos(angle);\n      var sinRotation = Math.sin(angle);\n      var tickFontSize = valueOrDefault$d(ticksOpts.fontSize, core_defaults.global.defaultFontSize);\n      return {\n        w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n        h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n      };\n    },\n\n    /**\n     * Crude approximation of what the label width might be\n     * @private\n     */\n    getLabelWidth: function (label) {\n      return this._getLabelSize(label).w;\n    },\n\n    /**\n     * @private\n     */\n    getLabelCapacity: function (exampleTime) {\n      var me = this;\n      var timeOpts = me.options.time;\n      var displayFormats = timeOpts.displayFormats; // pick the longest format (milliseconds) for guestimation\n\n      var format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n      var exampleLabel = me.tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format);\n\n      var size = me._getLabelSize(exampleLabel);\n\n      var capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h);\n\n      if (me.options.offset) {\n        capacity--;\n      }\n\n      return capacity > 0 ? capacity : 1;\n    }\n  }); // INTERNAL: static default options, registered in src/index.js\n\n  var _defaults$4 = defaultConfig$4;\n  scale_time._defaults = _defaults$4;\n  var scales = {\n    category: scale_category,\n    linear: scale_linear,\n    logarithmic: scale_logarithmic,\n    radialLinear: scale_radialLinear,\n    time: scale_time\n  };\n  var FORMATS = {\n    datetime: 'MMM D, YYYY, h:mm:ss a',\n    millisecond: 'h:mm:ss.SSS a',\n    second: 'h:mm:ss a',\n    minute: 'h:mm a',\n    hour: 'hA',\n    day: 'MMM D',\n    week: 'll',\n    month: 'MMM YYYY',\n    quarter: '[Q]Q - YYYY',\n    year: 'YYYY'\n  };\n\n  core_adapters._date.override(typeof moment === 'function' ? {\n    _id: 'moment',\n    // DEBUG ONLY\n    formats: function () {\n      return FORMATS;\n    },\n    parse: function (value, format) {\n      if (typeof value === 'string' && typeof format === 'string') {\n        value = moment(value, format);\n      } else if (!(value instanceof moment)) {\n        value = moment(value);\n      }\n\n      return value.isValid() ? value.valueOf() : null;\n    },\n    format: function (time, format) {\n      return moment(time).format(format);\n    },\n    add: function (time, amount, unit) {\n      return moment(time).add(amount, unit).valueOf();\n    },\n    diff: function (max, min, unit) {\n      return moment(max).diff(moment(min), unit);\n    },\n    startOf: function (time, unit, weekday) {\n      time = moment(time);\n\n      if (unit === 'isoWeek') {\n        return time.isoWeekday(weekday).valueOf();\n      }\n\n      return time.startOf(unit).valueOf();\n    },\n    endOf: function (time, unit) {\n      return moment(time).endOf(unit).valueOf();\n    },\n    // DEPRECATIONS\n\n    /**\n     * Provided for backward compatibility with scale.getValueForPixel().\n     * @deprecated since version 2.8.0\n     * @todo remove at version 3\n     * @private\n     */\n    _create: function (time) {\n      return moment(time);\n    }\n  } : {});\n\n  core_defaults._set('global', {\n    plugins: {\n      filler: {\n        propagate: true\n      }\n    }\n  });\n\n  var mappers = {\n    dataset: function (source) {\n      var index = source.fill;\n      var chart = source.chart;\n      var meta = chart.getDatasetMeta(index);\n      var visible = meta && chart.isDatasetVisible(index);\n      var points = visible && meta.dataset._children || [];\n      var length = points.length || 0;\n      return !length ? null : function (point, i) {\n        return i < length && points[i]._view || null;\n      };\n    },\n    boundary: function (source) {\n      var boundary = source.boundary;\n      var x = boundary ? boundary.x : null;\n      var y = boundary ? boundary.y : null;\n\n      if (helpers$1.isArray(boundary)) {\n        return function (point, i) {\n          return boundary[i];\n        };\n      }\n\n      return function (point) {\n        return {\n          x: x === null ? point.x : x,\n          y: y === null ? point.y : y\n        };\n      };\n    }\n  }; // @todo if (fill[0] === '#')\n\n  function decodeFill(el, index, count) {\n    var model = el._model || {};\n    var fill = model.fill;\n    var target;\n\n    if (fill === undefined) {\n      fill = !!model.backgroundColor;\n    }\n\n    if (fill === false || fill === null) {\n      return false;\n    }\n\n    if (fill === true) {\n      return 'origin';\n    }\n\n    target = parseFloat(fill, 10);\n\n    if (isFinite(target) && Math.floor(target) === target) {\n      if (fill[0] === '-' || fill[0] === '+') {\n        target = index + target;\n      }\n\n      if (target === index || target < 0 || target >= count) {\n        return false;\n      }\n\n      return target;\n    }\n\n    switch (fill) {\n      // compatibility\n      case 'bottom':\n        return 'start';\n\n      case 'top':\n        return 'end';\n\n      case 'zero':\n        return 'origin';\n      // supported boundaries\n\n      case 'origin':\n      case 'start':\n      case 'end':\n        return fill;\n      // invalid fill values\n\n      default:\n        return false;\n    }\n  }\n\n  function computeLinearBoundary(source) {\n    var model = source.el._model || {};\n    var scale = source.el._scale || {};\n    var fill = source.fill;\n    var target = null;\n    var horizontal;\n\n    if (isFinite(fill)) {\n      return null;\n    } // Backward compatibility: until v3, we still need to support boundary values set on\n    // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\n    // controllers might still use it (e.g. the Smith chart).\n\n\n    if (fill === 'start') {\n      target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\n    } else if (fill === 'end') {\n      target = model.scaleTop === undefined ? scale.top : model.scaleTop;\n    } else if (model.scaleZero !== undefined) {\n      target = model.scaleZero;\n    } else if (scale.getBasePixel) {\n      target = scale.getBasePixel();\n    }\n\n    if (target !== undefined && target !== null) {\n      if (target.x !== undefined && target.y !== undefined) {\n        return target;\n      }\n\n      if (helpers$1.isFinite(target)) {\n        horizontal = scale.isHorizontal();\n        return {\n          x: horizontal ? target : null,\n          y: horizontal ? null : target\n        };\n      }\n    }\n\n    return null;\n  }\n\n  function computeCircularBoundary(source) {\n    var scale = source.el._scale;\n    var options = scale.options;\n    var length = scale.chart.data.labels.length;\n    var fill = source.fill;\n    var target = [];\n    var start, end, center, i, point;\n\n    if (!length) {\n      return null;\n    }\n\n    start = options.ticks.reverse ? scale.max : scale.min;\n    end = options.ticks.reverse ? scale.min : scale.max;\n    center = scale.getPointPositionForValue(0, start);\n\n    for (i = 0; i < length; ++i) {\n      point = fill === 'start' || fill === 'end' ? scale.getPointPositionForValue(i, fill === 'start' ? start : end) : scale.getBasePosition(i);\n\n      if (options.gridLines.circular) {\n        point.cx = center.x;\n        point.cy = center.y;\n        point.angle = scale.getIndexAngle(i) - Math.PI / 2;\n      }\n\n      target.push(point);\n    }\n\n    return target;\n  }\n\n  function computeBoundary(source) {\n    var scale = source.el._scale || {};\n\n    if (scale.getPointPositionForValue) {\n      return computeCircularBoundary(source);\n    }\n\n    return computeLinearBoundary(source);\n  }\n\n  function resolveTarget(sources, index, propagate) {\n    var source = sources[index];\n    var fill = source.fill;\n    var visited = [index];\n    var target;\n\n    if (!propagate) {\n      return fill;\n    }\n\n    while (fill !== false && visited.indexOf(fill) === -1) {\n      if (!isFinite(fill)) {\n        return fill;\n      }\n\n      target = sources[fill];\n\n      if (!target) {\n        return false;\n      }\n\n      if (target.visible) {\n        return fill;\n      }\n\n      visited.push(fill);\n      fill = target.fill;\n    }\n\n    return false;\n  }\n\n  function createMapper(source) {\n    var fill = source.fill;\n    var type = 'dataset';\n\n    if (fill === false) {\n      return null;\n    }\n\n    if (!isFinite(fill)) {\n      type = 'boundary';\n    }\n\n    return mappers[type](source);\n  }\n\n  function isDrawable(point) {\n    return point && !point.skip;\n  }\n\n  function drawArea(ctx, curve0, curve1, len0, len1) {\n    var i, cx, cy, r;\n\n    if (!len0 || !len1) {\n      return;\n    } // building first area curve (normal)\n\n\n    ctx.moveTo(curve0[0].x, curve0[0].y);\n\n    for (i = 1; i < len0; ++i) {\n      helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);\n    }\n\n    if (curve1[0].angle !== undefined) {\n      cx = curve1[0].cx;\n      cy = curve1[0].cy;\n      r = Math.sqrt(Math.pow(curve1[0].x - cx, 2) + Math.pow(curve1[0].y - cy, 2));\n\n      for (i = len1 - 1; i > 0; --i) {\n        ctx.arc(cx, cy, r, curve1[i].angle, curve1[i - 1].angle, true);\n      }\n\n      return;\n    } // joining the two area curves\n\n\n    ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y); // building opposite area curve (reverse)\n\n    for (i = len1 - 1; i > 0; --i) {\n      helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);\n    }\n  }\n\n  function doFill(ctx, points, mapper, view, color, loop) {\n    var count = points.length;\n    var span = view.spanGaps;\n    var curve0 = [];\n    var curve1 = [];\n    var len0 = 0;\n    var len1 = 0;\n    var i, ilen, index, p0, p1, d0, d1, loopOffset;\n    ctx.beginPath();\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i % count;\n      p0 = points[index]._view;\n      p1 = mapper(p0, index, view);\n      d0 = isDrawable(p0);\n      d1 = isDrawable(p1);\n\n      if (loop && loopOffset === undefined && d0) {\n        loopOffset = i + 1;\n        ilen = count + loopOffset;\n      }\n\n      if (d0 && d1) {\n        len0 = curve0.push(p0);\n        len1 = curve1.push(p1);\n      } else if (len0 && len1) {\n        if (!span) {\n          drawArea(ctx, curve0, curve1, len0, len1);\n          len0 = len1 = 0;\n          curve0 = [];\n          curve1 = [];\n        } else {\n          if (d0) {\n            curve0.push(p0);\n          }\n\n          if (d1) {\n            curve1.push(p1);\n          }\n        }\n      }\n    }\n\n    drawArea(ctx, curve0, curve1, len0, len1);\n    ctx.closePath();\n    ctx.fillStyle = color;\n    ctx.fill();\n  }\n\n  var plugin_filler = {\n    id: 'filler',\n    afterDatasetsUpdate: function (chart, options) {\n      var count = (chart.data.datasets || []).length;\n      var propagate = options.propagate;\n      var sources = [];\n      var meta, i, el, source;\n\n      for (i = 0; i < count; ++i) {\n        meta = chart.getDatasetMeta(i);\n        el = meta.dataset;\n        source = null;\n\n        if (el && el._model && el instanceof elements.Line) {\n          source = {\n            visible: chart.isDatasetVisible(i),\n            fill: decodeFill(el, i, count),\n            chart: chart,\n            el: el\n          };\n        }\n\n        meta.$filler = source;\n        sources.push(source);\n      }\n\n      for (i = 0; i < count; ++i) {\n        source = sources[i];\n\n        if (!source) {\n          continue;\n        }\n\n        source.fill = resolveTarget(sources, i, propagate);\n        source.boundary = computeBoundary(source);\n        source.mapper = createMapper(source);\n      }\n    },\n    beforeDatasetsDraw: function (chart) {\n      var metasets = chart._getSortedVisibleDatasetMetas();\n\n      var ctx = chart.ctx;\n      var meta, i, el, view, points, mapper, color;\n\n      for (i = metasets.length - 1; i >= 0; --i) {\n        meta = metasets[i].$filler;\n\n        if (!meta || !meta.visible) {\n          continue;\n        }\n\n        el = meta.el;\n        view = el._view;\n        points = el._children || [];\n        mapper = meta.mapper;\n        color = view.backgroundColor || core_defaults.global.defaultColor;\n\n        if (mapper && color && points.length) {\n          helpers$1.canvas.clipArea(ctx, chart.chartArea);\n          doFill(ctx, points, mapper, view, color, el._loop);\n          helpers$1.canvas.unclipArea(ctx);\n        }\n      }\n    }\n  };\n  var getRtlHelper$1 = helpers$1.rtl.getRtlAdapter;\n  var noop$1 = helpers$1.noop;\n  var valueOrDefault$e = helpers$1.valueOrDefault;\n\n  core_defaults._set('global', {\n    legend: {\n      display: true,\n      position: 'top',\n      align: 'center',\n      fullWidth: true,\n      reverse: false,\n      weight: 1000,\n      // a callback that will handle\n      onClick: function (e, legendItem) {\n        var index = legendItem.datasetIndex;\n        var ci = this.chart;\n        var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment\n\n        meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart\n\n        ci.update();\n      },\n      onHover: null,\n      onLeave: null,\n      labels: {\n        boxWidth: 40,\n        padding: 10,\n        // Generates labels shown in the legend\n        // Valid properties to return:\n        // text : text to display\n        // fillStyle : fill of coloured box\n        // strokeStyle: stroke of coloured box\n        // hidden : if this legend item refers to a hidden item\n        // lineCap : cap style for line\n        // lineDash\n        // lineDashOffset :\n        // lineJoin :\n        // lineWidth :\n        generateLabels: function (chart) {\n          var datasets = chart.data.datasets;\n          var options = chart.options.legend || {};\n          var usePointStyle = options.labels && options.labels.usePointStyle;\n          return chart._getSortedDatasetMetas().map(function (meta) {\n            var style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n            return {\n              text: datasets[meta.index].label,\n              fillStyle: style.backgroundColor,\n              hidden: !chart.isDatasetVisible(meta.index),\n              lineCap: style.borderCapStyle,\n              lineDash: style.borderDash,\n              lineDashOffset: style.borderDashOffset,\n              lineJoin: style.borderJoinStyle,\n              lineWidth: style.borderWidth,\n              strokeStyle: style.borderColor,\n              pointStyle: style.pointStyle,\n              rotation: style.rotation,\n              // Below is extra data used for toggling the datasets\n              datasetIndex: meta.index\n            };\n          }, this);\n        }\n      }\n    },\n    legendCallback: function (chart) {\n      var list = document.createElement('ul');\n      var datasets = chart.data.datasets;\n      var i, ilen, listItem, listItemSpan;\n      list.setAttribute('class', chart.id + '-legend');\n\n      for (i = 0, ilen = datasets.length; i < ilen; i++) {\n        listItem = list.appendChild(document.createElement('li'));\n        listItemSpan = listItem.appendChild(document.createElement('span'));\n        listItemSpan.style.backgroundColor = datasets[i].backgroundColor;\n\n        if (datasets[i].label) {\n          listItem.appendChild(document.createTextNode(datasets[i].label));\n        }\n      }\n\n      return list.outerHTML;\n    }\n  });\n  /**\n   * Helper function to get the box width based on the usePointStyle option\n   * @param {object} labelopts - the label options on the legend\n   * @param {number} fontSize - the label font size\n   * @return {number} width of the color box area\n   */\n\n\n  function getBoxWidth(labelOpts, fontSize) {\n    return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;\n  }\n  /**\n   * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n   */\n\n\n  var Legend = core_element.extend({\n    initialize: function (config) {\n      var me = this;\n      helpers$1.extend(me, config); // Contains hit boxes for each dataset (in dataset order)\n\n      me.legendHitBoxes = [];\n      /**\n      \t * @private\n      \t */\n\n      me._hoveredItem = null; // Are we in doughnut mode which has a different data type\n\n      me.doughnutMode = false;\n    },\n    // These methods are ordered by lifecycle. Utilities then follow.\n    // Any function defined here is inherited by all legend types.\n    // Any function can be extended by the legend type\n    beforeUpdate: noop$1,\n    update: function (maxWidth, maxHeight, margins) {\n      var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\n      me.beforeUpdate(); // Absorb the master measurements\n\n      me.maxWidth = maxWidth;\n      me.maxHeight = maxHeight;\n      me.margins = margins; // Dimensions\n\n      me.beforeSetDimensions();\n      me.setDimensions();\n      me.afterSetDimensions(); // Labels\n\n      me.beforeBuildLabels();\n      me.buildLabels();\n      me.afterBuildLabels(); // Fit\n\n      me.beforeFit();\n      me.fit();\n      me.afterFit(); //\n\n      me.afterUpdate();\n      return me.minSize;\n    },\n    afterUpdate: noop$1,\n    //\n    beforeSetDimensions: noop$1,\n    setDimensions: function () {\n      var me = this; // Set the unconstrained dimension before label rotation\n\n      if (me.isHorizontal()) {\n        // Reset position before calculating rotation\n        me.width = me.maxWidth;\n        me.left = 0;\n        me.right = me.width;\n      } else {\n        me.height = me.maxHeight; // Reset position before calculating rotation\n\n        me.top = 0;\n        me.bottom = me.height;\n      } // Reset padding\n\n\n      me.paddingLeft = 0;\n      me.paddingTop = 0;\n      me.paddingRight = 0;\n      me.paddingBottom = 0; // Reset minSize\n\n      me.minSize = {\n        width: 0,\n        height: 0\n      };\n    },\n    afterSetDimensions: noop$1,\n    //\n    beforeBuildLabels: noop$1,\n    buildLabels: function () {\n      var me = this;\n      var labelOpts = me.options.labels || {};\n      var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];\n\n      if (labelOpts.filter) {\n        legendItems = legendItems.filter(function (item) {\n          return labelOpts.filter(item, me.chart.data);\n        });\n      }\n\n      if (me.options.reverse) {\n        legendItems.reverse();\n      }\n\n      me.legendItems = legendItems;\n    },\n    afterBuildLabels: noop$1,\n    //\n    beforeFit: noop$1,\n    fit: function () {\n      var me = this;\n      var opts = me.options;\n      var labelOpts = opts.labels;\n      var display = opts.display;\n      var ctx = me.ctx;\n\n      var labelFont = helpers$1.options._parseFont(labelOpts);\n\n      var fontSize = labelFont.size; // Reset hit boxes\n\n      var hitboxes = me.legendHitBoxes = [];\n      var minSize = me.minSize;\n      var isHorizontal = me.isHorizontal();\n\n      if (isHorizontal) {\n        minSize.width = me.maxWidth; // fill all the width\n\n        minSize.height = display ? 10 : 0;\n      } else {\n        minSize.width = display ? 10 : 0;\n        minSize.height = me.maxHeight; // fill all the height\n      } // Increase sizes here\n\n\n      if (!display) {\n        me.width = minSize.width = me.height = minSize.height = 0;\n        return;\n      }\n\n      ctx.font = labelFont.string;\n\n      if (isHorizontal) {\n        // Labels\n        // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n        var lineWidths = me.lineWidths = [0];\n        var totalHeight = 0;\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'middle';\n        helpers$1.each(me.legendItems, function (legendItem, i) {\n          var boxWidth = getBoxWidth(labelOpts, fontSize);\n          var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n\n          if (i === 0 || lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {\n            totalHeight += fontSize + labelOpts.padding;\n            lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n          } // Store the hitbox width and height here. Final position will be updated in `draw`\n\n\n          hitboxes[i] = {\n            left: 0,\n            top: 0,\n            width: width,\n            height: fontSize\n          };\n          lineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n        });\n        minSize.height += totalHeight;\n      } else {\n        var vPadding = labelOpts.padding;\n        var columnWidths = me.columnWidths = [];\n        var columnHeights = me.columnHeights = [];\n        var totalWidth = labelOpts.padding;\n        var currentColWidth = 0;\n        var currentColHeight = 0;\n        helpers$1.each(me.legendItems, function (legendItem, i) {\n          var boxWidth = getBoxWidth(labelOpts, fontSize);\n          var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column\n\n          if (i > 0 && currentColHeight + fontSize + 2 * vPadding > minSize.height) {\n            totalWidth += currentColWidth + labelOpts.padding;\n            columnWidths.push(currentColWidth); // previous column width\n\n            columnHeights.push(currentColHeight);\n            currentColWidth = 0;\n            currentColHeight = 0;\n          } // Get max width\n\n\n          currentColWidth = Math.max(currentColWidth, itemWidth);\n          currentColHeight += fontSize + vPadding; // Store the hitbox width and height here. Final position will be updated in `draw`\n\n          hitboxes[i] = {\n            left: 0,\n            top: 0,\n            width: itemWidth,\n            height: fontSize\n          };\n        });\n        totalWidth += currentColWidth;\n        columnWidths.push(currentColWidth);\n        columnHeights.push(currentColHeight);\n        minSize.width += totalWidth;\n      }\n\n      me.width = minSize.width;\n      me.height = minSize.height;\n    },\n    afterFit: noop$1,\n    // Shared Methods\n    isHorizontal: function () {\n      return this.options.position === 'top' || this.options.position === 'bottom';\n    },\n    // Actually draw the legend on the canvas\n    draw: function () {\n      var me = this;\n      var opts = me.options;\n      var labelOpts = opts.labels;\n      var globalDefaults = core_defaults.global;\n      var defaultColor = globalDefaults.defaultColor;\n      var lineDefault = globalDefaults.elements.line;\n      var legendHeight = me.height;\n      var columnHeights = me.columnHeights;\n      var legendWidth = me.width;\n      var lineWidths = me.lineWidths;\n\n      if (!opts.display) {\n        return;\n      }\n\n      var rtlHelper = getRtlHelper$1(opts.rtl, me.left, me.minSize.width);\n      var ctx = me.ctx;\n      var fontColor = valueOrDefault$e(labelOpts.fontColor, globalDefaults.defaultFontColor);\n\n      var labelFont = helpers$1.options._parseFont(labelOpts);\n\n      var fontSize = labelFont.size;\n      var cursor; // Canvas setup\n\n      ctx.textAlign = rtlHelper.textAlign('left');\n      ctx.textBaseline = 'middle';\n      ctx.lineWidth = 0.5;\n      ctx.strokeStyle = fontColor; // for strikethrough effect\n\n      ctx.fillStyle = fontColor; // render in correct colour\n\n      ctx.font = labelFont.string;\n      var boxWidth = getBoxWidth(labelOpts, fontSize);\n      var hitboxes = me.legendHitBoxes; // current position\n\n      var drawLegendBox = function (x, y, legendItem) {\n        if (isNaN(boxWidth) || boxWidth <= 0) {\n          return;\n        } // Set the ctx for the box\n\n\n        ctx.save();\n        var lineWidth = valueOrDefault$e(legendItem.lineWidth, lineDefault.borderWidth);\n        ctx.fillStyle = valueOrDefault$e(legendItem.fillStyle, defaultColor);\n        ctx.lineCap = valueOrDefault$e(legendItem.lineCap, lineDefault.borderCapStyle);\n        ctx.lineDashOffset = valueOrDefault$e(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n        ctx.lineJoin = valueOrDefault$e(legendItem.lineJoin, lineDefault.borderJoinStyle);\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = valueOrDefault$e(legendItem.strokeStyle, defaultColor);\n\n        if (ctx.setLineDash) {\n          // IE 9 and 10 do not support line dash\n          ctx.setLineDash(valueOrDefault$e(legendItem.lineDash, lineDefault.borderDash));\n        }\n\n        if (labelOpts && labelOpts.usePointStyle) {\n          // Recalculate x and y for drawPoint() because its expecting\n          // x and y to be center of figure (instead of top left)\n          var radius = boxWidth * Math.SQRT2 / 2;\n          var centerX = rtlHelper.xPlus(x, boxWidth / 2);\n          var centerY = y + fontSize / 2; // Draw pointStyle as legend symbol\n\n          helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY, legendItem.rotation);\n        } else {\n          // Draw box as legend symbol\n          ctx.fillRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);\n\n          if (lineWidth !== 0) {\n            ctx.strokeRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);\n          }\n        }\n\n        ctx.restore();\n      };\n\n      var fillText = function (x, y, legendItem, textWidth) {\n        var halfFontSize = fontSize / 2;\n        var xLeft = rtlHelper.xPlus(x, boxWidth + halfFontSize);\n        var yMiddle = y + halfFontSize;\n        ctx.fillText(legendItem.text, xLeft, yMiddle);\n\n        if (legendItem.hidden) {\n          // Strikethrough the text if hidden\n          ctx.beginPath();\n          ctx.lineWidth = 2;\n          ctx.moveTo(xLeft, yMiddle);\n          ctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);\n          ctx.stroke();\n        }\n      };\n\n      var alignmentOffset = function (dimension, blockSize) {\n        switch (opts.align) {\n          case 'start':\n            return labelOpts.padding;\n\n          case 'end':\n            return dimension - blockSize;\n\n          default:\n            // center\n            return (dimension - blockSize + labelOpts.padding) / 2;\n        }\n      }; // Horizontal\n\n\n      var isHorizontal = me.isHorizontal();\n\n      if (isHorizontal) {\n        cursor = {\n          x: me.left + alignmentOffset(legendWidth, lineWidths[0]),\n          y: me.top + labelOpts.padding,\n          line: 0\n        };\n      } else {\n        cursor = {\n          x: me.left + labelOpts.padding,\n          y: me.top + alignmentOffset(legendHeight, columnHeights[0]),\n          line: 0\n        };\n      }\n\n      helpers$1.rtl.overrideTextDirection(me.ctx, opts.textDirection);\n      var itemHeight = fontSize + labelOpts.padding;\n      helpers$1.each(me.legendItems, function (legendItem, i) {\n        var textWidth = ctx.measureText(legendItem.text).width;\n        var width = boxWidth + fontSize / 2 + textWidth;\n        var x = cursor.x;\n        var y = cursor.y;\n        rtlHelper.setWidth(me.minSize.width); // Use (me.left + me.minSize.width) and (me.top + me.minSize.height)\n        // instead of me.right and me.bottom because me.width and me.height\n        // may have been changed since me.minSize was calculated\n\n        if (isHorizontal) {\n          if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {\n            y = cursor.y += itemHeight;\n            cursor.line++;\n            x = cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);\n          }\n        } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {\n          x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n          cursor.line++;\n          y = cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);\n        }\n\n        var realX = rtlHelper.x(x);\n        drawLegendBox(realX, y, legendItem);\n        hitboxes[i].left = rtlHelper.leftForLtr(realX, hitboxes[i].width);\n        hitboxes[i].top = y; // Fill the actual label\n\n        fillText(realX, y, legendItem, textWidth);\n\n        if (isHorizontal) {\n          cursor.x += width + labelOpts.padding;\n        } else {\n          cursor.y += itemHeight;\n        }\n      });\n      helpers$1.rtl.restoreTextDirection(me.ctx, opts.textDirection);\n    },\n\n    /**\n     * @private\n     */\n    _getLegendItemAt: function (x, y) {\n      var me = this;\n      var i, hitBox, lh;\n\n      if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n        // See if we are touching one of the dataset boxes\n        lh = me.legendHitBoxes;\n\n        for (i = 0; i < lh.length; ++i) {\n          hitBox = lh[i];\n\n          if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n            // Touching an element\n            return me.legendItems[i];\n          }\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Handle an event\n     * @private\n     * @param {IEvent} event - The event to handle\n     */\n    handleEvent: function (e) {\n      var me = this;\n      var opts = me.options;\n      var type = e.type === 'mouseup' ? 'click' : e.type;\n      var hoveredItem;\n\n      if (type === 'mousemove') {\n        if (!opts.onHover && !opts.onLeave) {\n          return;\n        }\n      } else if (type === 'click') {\n        if (!opts.onClick) {\n          return;\n        }\n      } else {\n        return;\n      } // Chart event already has relative position in it\n\n\n      hoveredItem = me._getLegendItemAt(e.x, e.y);\n\n      if (type === 'click') {\n        if (hoveredItem && opts.onClick) {\n          // use e.native for backwards compatibility\n          opts.onClick.call(me, e.native, hoveredItem);\n        }\n      } else {\n        if (opts.onLeave && hoveredItem !== me._hoveredItem) {\n          if (me._hoveredItem) {\n            opts.onLeave.call(me, e.native, me._hoveredItem);\n          }\n\n          me._hoveredItem = hoveredItem;\n        }\n\n        if (opts.onHover && hoveredItem) {\n          // use e.native for backwards compatibility\n          opts.onHover.call(me, e.native, hoveredItem);\n        }\n      }\n    }\n  });\n\n  function createNewLegendAndAttach(chart, legendOpts) {\n    var legend = new Legend({\n      ctx: chart.ctx,\n      options: legendOpts,\n      chart: chart\n    });\n    core_layouts.configure(chart, legend, legendOpts);\n    core_layouts.addBox(chart, legend);\n    chart.legend = legend;\n  }\n\n  var plugin_legend = {\n    id: 'legend',\n\n    /**\n     * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making\n     * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of\n     * the plugin, which one will be re-exposed in the chart.js file.\n     * https://github.com/chartjs/Chart.js/pull/2640\n     * @private\n     */\n    _element: Legend,\n    beforeInit: function (chart) {\n      var legendOpts = chart.options.legend;\n\n      if (legendOpts) {\n        createNewLegendAndAttach(chart, legendOpts);\n      }\n    },\n    beforeUpdate: function (chart) {\n      var legendOpts = chart.options.legend;\n      var legend = chart.legend;\n\n      if (legendOpts) {\n        helpers$1.mergeIf(legendOpts, core_defaults.global.legend);\n\n        if (legend) {\n          core_layouts.configure(chart, legend, legendOpts);\n          legend.options = legendOpts;\n        } else {\n          createNewLegendAndAttach(chart, legendOpts);\n        }\n      } else if (legend) {\n        core_layouts.removeBox(chart, legend);\n        delete chart.legend;\n      }\n    },\n    afterEvent: function (chart, e) {\n      var legend = chart.legend;\n\n      if (legend) {\n        legend.handleEvent(e);\n      }\n    }\n  };\n  var noop$2 = helpers$1.noop;\n\n  core_defaults._set('global', {\n    title: {\n      display: false,\n      fontStyle: 'bold',\n      fullWidth: true,\n      padding: 10,\n      position: 'top',\n      text: '',\n      weight: 2000 // by default greater than legend (1000) to be above\n\n    }\n  });\n  /**\n   * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n   */\n\n\n  var Title = core_element.extend({\n    initialize: function (config) {\n      var me = this;\n      helpers$1.extend(me, config); // Contains hit boxes for each dataset (in dataset order)\n\n      me.legendHitBoxes = [];\n    },\n    // These methods are ordered by lifecycle. Utilities then follow.\n    beforeUpdate: noop$2,\n    update: function (maxWidth, maxHeight, margins) {\n      var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\n      me.beforeUpdate(); // Absorb the master measurements\n\n      me.maxWidth = maxWidth;\n      me.maxHeight = maxHeight;\n      me.margins = margins; // Dimensions\n\n      me.beforeSetDimensions();\n      me.setDimensions();\n      me.afterSetDimensions(); // Labels\n\n      me.beforeBuildLabels();\n      me.buildLabels();\n      me.afterBuildLabels(); // Fit\n\n      me.beforeFit();\n      me.fit();\n      me.afterFit(); //\n\n      me.afterUpdate();\n      return me.minSize;\n    },\n    afterUpdate: noop$2,\n    //\n    beforeSetDimensions: noop$2,\n    setDimensions: function () {\n      var me = this; // Set the unconstrained dimension before label rotation\n\n      if (me.isHorizontal()) {\n        // Reset position before calculating rotation\n        me.width = me.maxWidth;\n        me.left = 0;\n        me.right = me.width;\n      } else {\n        me.height = me.maxHeight; // Reset position before calculating rotation\n\n        me.top = 0;\n        me.bottom = me.height;\n      } // Reset padding\n\n\n      me.paddingLeft = 0;\n      me.paddingTop = 0;\n      me.paddingRight = 0;\n      me.paddingBottom = 0; // Reset minSize\n\n      me.minSize = {\n        width: 0,\n        height: 0\n      };\n    },\n    afterSetDimensions: noop$2,\n    //\n    beforeBuildLabels: noop$2,\n    buildLabels: noop$2,\n    afterBuildLabels: noop$2,\n    //\n    beforeFit: noop$2,\n    fit: function () {\n      var me = this;\n      var opts = me.options;\n      var minSize = me.minSize = {};\n      var isHorizontal = me.isHorizontal();\n      var lineCount, textSize;\n\n      if (!opts.display) {\n        me.width = minSize.width = me.height = minSize.height = 0;\n        return;\n      }\n\n      lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;\n      textSize = lineCount * helpers$1.options._parseFont(opts).lineHeight + opts.padding * 2;\n      me.width = minSize.width = isHorizontal ? me.maxWidth : textSize;\n      me.height = minSize.height = isHorizontal ? textSize : me.maxHeight;\n    },\n    afterFit: noop$2,\n    // Shared Methods\n    isHorizontal: function () {\n      var pos = this.options.position;\n      return pos === 'top' || pos === 'bottom';\n    },\n    // Actually draw the title block on the canvas\n    draw: function () {\n      var me = this;\n      var ctx = me.ctx;\n      var opts = me.options;\n\n      if (!opts.display) {\n        return;\n      }\n\n      var fontOpts = helpers$1.options._parseFont(opts);\n\n      var lineHeight = fontOpts.lineHeight;\n      var offset = lineHeight / 2 + opts.padding;\n      var rotation = 0;\n      var top = me.top;\n      var left = me.left;\n      var bottom = me.bottom;\n      var right = me.right;\n      var maxWidth, titleX, titleY;\n      ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour\n\n      ctx.font = fontOpts.string; // Horizontal\n\n      if (me.isHorizontal()) {\n        titleX = left + (right - left) / 2; // midpoint of the width\n\n        titleY = top + offset;\n        maxWidth = right - left;\n      } else {\n        titleX = opts.position === 'left' ? left + offset : right - offset;\n        titleY = top + (bottom - top) / 2;\n        maxWidth = bottom - top;\n        rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n      }\n\n      ctx.save();\n      ctx.translate(titleX, titleY);\n      ctx.rotate(rotation);\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      var text = opts.text;\n\n      if (helpers$1.isArray(text)) {\n        var y = 0;\n\n        for (var i = 0; i < text.length; ++i) {\n          ctx.fillText(text[i], 0, y, maxWidth);\n          y += lineHeight;\n        }\n      } else {\n        ctx.fillText(text, 0, 0, maxWidth);\n      }\n\n      ctx.restore();\n    }\n  });\n\n  function createNewTitleBlockAndAttach(chart, titleOpts) {\n    var title = new Title({\n      ctx: chart.ctx,\n      options: titleOpts,\n      chart: chart\n    });\n    core_layouts.configure(chart, title, titleOpts);\n    core_layouts.addBox(chart, title);\n    chart.titleBlock = title;\n  }\n\n  var plugin_title = {\n    id: 'title',\n\n    /**\n     * Backward compatibility: since 2.1.5, the title is registered as a plugin, making\n     * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of\n     * the plugin, which one will be re-exposed in the chart.js file.\n     * https://github.com/chartjs/Chart.js/pull/2640\n     * @private\n     */\n    _element: Title,\n    beforeInit: function (chart) {\n      var titleOpts = chart.options.title;\n\n      if (titleOpts) {\n        createNewTitleBlockAndAttach(chart, titleOpts);\n      }\n    },\n    beforeUpdate: function (chart) {\n      var titleOpts = chart.options.title;\n      var titleBlock = chart.titleBlock;\n\n      if (titleOpts) {\n        helpers$1.mergeIf(titleOpts, core_defaults.global.title);\n\n        if (titleBlock) {\n          core_layouts.configure(chart, titleBlock, titleOpts);\n          titleBlock.options = titleOpts;\n        } else {\n          createNewTitleBlockAndAttach(chart, titleOpts);\n        }\n      } else if (titleBlock) {\n        core_layouts.removeBox(chart, titleBlock);\n        delete chart.titleBlock;\n      }\n    }\n  };\n  var plugins = {};\n  var filler = plugin_filler;\n  var legend = plugin_legend;\n  var title = plugin_title;\n  plugins.filler = filler;\n  plugins.legend = legend;\n  plugins.title = title;\n  /**\n   * @namespace Chart\n   */\n\n  core_controller.helpers = helpers$1; // @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!\n\n  core_helpers();\n  core_controller._adapters = core_adapters;\n  core_controller.Animation = core_animation;\n  core_controller.animationService = core_animations;\n  core_controller.controllers = controllers;\n  core_controller.DatasetController = core_datasetController;\n  core_controller.defaults = core_defaults;\n  core_controller.Element = core_element;\n  core_controller.elements = elements;\n  core_controller.Interaction = core_interaction;\n  core_controller.layouts = core_layouts;\n  core_controller.platform = platform;\n  core_controller.plugins = core_plugins;\n  core_controller.Scale = core_scale;\n  core_controller.scaleService = core_scaleService;\n  core_controller.Ticks = core_ticks;\n  core_controller.Tooltip = core_tooltip; // Register built-in scales\n\n  core_controller.helpers.each(scales, function (scale, type) {\n    core_controller.scaleService.registerScaleType(type, scale, scale._defaults);\n  }); // Load to register built-in adapters (as side effects)\n  // Loading built-in plugins\n\n  for (var k in plugins) {\n    if (plugins.hasOwnProperty(k)) {\n      core_controller.plugins.register(plugins[k]);\n    }\n  }\n\n  core_controller.platform.initialize();\n  var src = core_controller;\n\n  if (typeof window !== 'undefined') {\n    window.Chart = core_controller;\n  } // DEPRECATIONS\n\n  /**\n   * Provided for backward compatibility, not available anymore\n   * @namespace Chart.Chart\n   * @deprecated since version 2.8.0\n   * @todo remove at version 3\n   * @private\n   */\n\n\n  core_controller.Chart = core_controller;\n  /**\n   * Provided for backward compatibility, not available anymore\n   * @namespace Chart.Legend\n   * @deprecated since version 2.1.5\n   * @todo remove at version 3\n   * @private\n   */\n\n  core_controller.Legend = plugins.legend._element;\n  /**\n   * Provided for backward compatibility, not available anymore\n   * @namespace Chart.Title\n   * @deprecated since version 2.1.5\n   * @todo remove at version 3\n   * @private\n   */\n\n  core_controller.Title = plugins.title._element;\n  /**\n   * Provided for backward compatibility, use Chart.plugins instead\n   * @namespace Chart.pluginService\n   * @deprecated since version 2.1.5\n   * @todo remove at version 3\n   * @private\n   */\n\n  core_controller.pluginService = core_controller.plugins;\n  /**\n   * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\n   * effect, instead simply create/register plugins via plain JavaScript objects.\n   * @interface Chart.PluginBase\n   * @deprecated since version 2.5.0\n   * @todo remove at version 3\n   * @private\n   */\n\n  core_controller.PluginBase = core_controller.Element.extend({});\n  /**\n   * Provided for backward compatibility, use Chart.helpers.canvas instead.\n   * @namespace Chart.canvasHelpers\n   * @deprecated since version 2.6.0\n   * @todo remove at version 3\n   * @private\n   */\n\n  core_controller.canvasHelpers = core_controller.helpers.canvas;\n  /**\n   * Provided for backward compatibility, use Chart.layouts instead.\n   * @namespace Chart.layoutService\n   * @deprecated since version 2.7.3\n   * @todo remove at version 3\n   * @private\n   */\n\n  core_controller.layoutService = core_controller.layouts;\n  /**\n   * Provided for backward compatibility, not available anymore.\n   * @namespace Chart.LinearScaleBase\n   * @deprecated since version 2.8\n   * @todo remove at version 3\n   * @private\n   */\n\n  core_controller.LinearScaleBase = scale_linearbase;\n  /**\n   * Provided for backward compatibility, instead we should create a new Chart\n   * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).\n   * @deprecated since version 2.8.0\n   * @todo remove at version 3\n   */\n\n  core_controller.helpers.each(['Bar', 'Bubble', 'Doughnut', 'Line', 'PolarArea', 'Radar', 'Scatter'], function (klass) {\n    core_controller[klass] = function (ctx, cfg) {\n      return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {\n        type: klass.charAt(0).toLowerCase() + klass.slice(1)\n      }));\n    };\n  });\n  return src;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9DaGFydC5qcz8zMGVmIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsImUiLCJtb21lbnQiLCJoYXNPd25Qcm9wZXJ0eSIsImNyZWF0ZUNvbW1vbmpzTW9kdWxlIiwiZm4iLCJnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlIiwibiIsImNvbG9yTmFtZSIsImNvbnZlcnNpb25zIiwicmV2ZXJzZUtleXdvcmRzIiwia2V5IiwiY29udmVydCIsInJnYiIsImNoYW5uZWxzIiwibGFiZWxzIiwiaHNsIiwiaHN2IiwiaHdiIiwiY215ayIsInh5eiIsImxhYiIsImxjaCIsImhleCIsImtleXdvcmQiLCJhbnNpMTYiLCJhbnNpMjU2IiwiaGNnIiwiYXBwbGUiLCJncmF5IiwibW9kZWwiLCJFcnJvciIsImxlbmd0aCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJyIiwiZyIsImIiLCJtaW4iLCJNYXRoIiwibWF4IiwiZGVsdGEiLCJoIiwicyIsImwiLCJyZGlmIiwiZ2RpZiIsImJkaWYiLCJ2IiwiZGlmZiIsImRpZmZjIiwiYyIsInciLCJtIiwieSIsImsiLCJjb21wYXJhdGl2ZURpc3RhbmNlIiwieCIsInBvdyIsInJldmVyc2VkIiwiY3VycmVudENsb3Nlc3REaXN0YW5jZSIsIkluZmluaXR5IiwiY3VycmVudENsb3Nlc3RLZXl3b3JkIiwiZGlzdGFuY2UiLCJ6IiwiYSIsInQxIiwidDIiLCJ0MyIsInZhbCIsImkiLCJzbWluIiwibG1pbiIsInN2IiwiaGkiLCJmbG9vciIsImYiLCJwIiwicSIsInQiLCJ2bWluIiwic2wiLCJ3aCIsImJsIiwicmF0aW8iLCJ5MiIsIngyIiwiejIiLCJociIsImF0YW4yIiwiUEkiLCJzcXJ0IiwiY29zIiwic2luIiwiYXJncyIsImFyZ3VtZW50cyIsInJvdW5kIiwiYW5zaSIsImNvbG9yIiwibXVsdCIsInJlbSIsImludGVnZXIiLCJzdHJpbmciLCJ0b1N0cmluZyIsInRvVXBwZXJDYXNlIiwic3Vic3RyaW5nIiwibWF0Y2giLCJjb2xvclN0cmluZyIsInNwbGl0IiwibWFwIiwiY2hhciIsImpvaW4iLCJwYXJzZUludCIsImNocm9tYSIsImdyYXlzY2FsZSIsImh1ZSIsInB1cmUiLCJtZyIsImNvbnZlcnNpb25zXzEiLCJjb252ZXJzaW9uc18yIiwiY29udmVyc2lvbnNfMyIsImNvbnZlcnNpb25zXzQiLCJjb252ZXJzaW9uc181IiwiY29udmVyc2lvbnNfNiIsImNvbnZlcnNpb25zXzciLCJjb252ZXJzaW9uc184IiwiY29udmVyc2lvbnNfOSIsImNvbnZlcnNpb25zXzEwIiwiY29udmVyc2lvbnNfMTEiLCJjb252ZXJzaW9uc18xMiIsImNvbnZlcnNpb25zXzEzIiwiY29udmVyc2lvbnNfMTQiLCJjb252ZXJzaW9uc18xNSIsImJ1aWxkR3JhcGgiLCJncmFwaCIsIm1vZGVscyIsImtleXMiLCJsZW4iLCJwYXJlbnQiLCJkZXJpdmVCRlMiLCJmcm9tTW9kZWwiLCJxdWV1ZSIsImN1cnJlbnQiLCJwb3AiLCJhZGphY2VudHMiLCJhZGphY2VudCIsIm5vZGUiLCJ1bnNoaWZ0IiwibGluayIsImZyb20iLCJ0byIsIndyYXBDb252ZXJzaW9uIiwidG9Nb2RlbCIsInBhdGgiLCJjdXIiLCJjb252ZXJzaW9uIiwicm91dGUiLCJ3cmFwUmF3Iiwid3JhcHBlZEZuIiwidW5kZWZpbmVkIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJ3cmFwUm91bmRlZCIsInJlc3VsdCIsImZvckVhY2giLCJyb3V0ZXMiLCJyb3V0ZU1vZGVscyIsInJhdyIsImNvbG9yQ29udmVydCIsImNvbG9yTmFtZSQxIiwiZ2V0UmdiYSIsImdldEhzbGEiLCJnZXRSZ2IiLCJnZXRIc2wiLCJnZXRId2IiLCJnZXRBbHBoYSIsImhleFN0cmluZyIsInJnYlN0cmluZyIsInJnYmFTdHJpbmciLCJwZXJjZW50U3RyaW5nIiwicGVyY2VudGFTdHJpbmciLCJoc2xTdHJpbmciLCJoc2xhU3RyaW5nIiwiaHdiU3RyaW5nIiwiYWJiciIsInJnYmEiLCJwZXIiLCJoZXhBbHBoYSIsInBhcnNlRmxvYXQiLCJzY2FsZSIsImFscGhhIiwiaXNOYU4iLCJoc2xhIiwidmFscyIsImhleERvdWJsZSIsInJldmVyc2VOYW1lcyIsIm51bSIsInN0ciIsIm5hbWUiLCJDb2xvciIsIm9iaiIsInZhbGlkIiwidmFsdWVzIiwic2V0VmFsdWVzIiwicmVkIiwibGlnaHRuZXNzIiwid2hpdGVuZXNzIiwiY3lhbiIsImlzVmFsaWQiLCJzZXRTcGFjZSIsInJnYkFycmF5IiwiaHNsQXJyYXkiLCJoc3ZBcnJheSIsImh3YkFycmF5IiwiY29uY2F0IiwiY215a0FycmF5IiwicmdiYUFycmF5IiwiaHNsYUFycmF5Iiwic2V0Q2hhbm5lbCIsImdyZWVuIiwiYmx1ZSIsInNhdHVyYXRpb24iLCJzYXR1cmF0aW9udiIsImJsYWNrbmVzcyIsIm1hZ2VudGEiLCJ5ZWxsb3ciLCJibGFjayIsInJnYk51bWJlciIsImx1bWlub3NpdHkiLCJsdW0iLCJjaGFuIiwiY29udHJhc3QiLCJjb2xvcjIiLCJsdW0xIiwibHVtMiIsImxldmVsIiwiY29udHJhc3RSYXRpbyIsImRhcmsiLCJ5aXEiLCJsaWdodCIsIm5lZ2F0ZSIsImxpZ2h0ZW4iLCJkYXJrZW4iLCJzYXR1cmF0ZSIsImRlc2F0dXJhdGUiLCJ3aGl0ZW4iLCJibGFja2VuIiwiZ3JleXNjYWxlIiwiY2xlYXJlciIsIm9wYXF1ZXIiLCJyb3RhdGUiLCJkZWdyZWVzIiwibWl4IiwibWl4aW5Db2xvciIsIndlaWdodCIsImNvbG9yMSIsIncxIiwidzIiLCJ0b0pTT04iLCJjbG9uZSIsInNvdXJjZSIsInRhcmdldCIsInR5cGUiLCJwcm9wIiwiY29uc29sZSIsImVycm9yIiwic3BhY2VzIiwibWF4ZXMiLCJnZXRWYWx1ZXMiLCJzcGFjZSIsImNoYXJBdCIsImNoYW5zIiwiY2FwcGVkIiwic25hbWUiLCJpbmRleCIsInN2YWx1ZXMiLCJ3aW5kb3ciLCJjaGFydGpzQ29sb3IiLCJoZWxwZXJzIiwibm9vcCIsInVpZCIsImlkIiwiaXNOdWxsT3JVbmRlZiIsImlzQXJyYXkiLCJzdWJzdHIiLCJpc09iamVjdCIsImlzRmluaXRlIiwiTnVtYmVyIiwidmFsdWVPckRlZmF1bHQiLCJkZWZhdWx0VmFsdWUiLCJ2YWx1ZUF0SW5kZXhPckRlZmF1bHQiLCJjYWxsYmFjayIsInRoaXNBcmciLCJhcHBseSIsImVhY2giLCJsb29wYWJsZSIsInJldmVyc2UiLCJhcnJheUVxdWFscyIsImEwIiwiYTEiLCJpbGVuIiwidjAiLCJ2MSIsImtsZW4iLCJfbWVyZ2VyIiwib3B0aW9ucyIsInR2YWwiLCJzdmFsIiwibWVyZ2UiLCJfbWVyZ2VySWYiLCJtZXJnZUlmIiwic291cmNlcyIsIm1lcmdlciIsImV4dGVuZCIsImFzc2lnbiIsImRzdCIsInNyYyIsImluaGVyaXRzIiwiZXh0ZW5zaW9ucyIsIm1lIiwiQ2hhcnRFbGVtZW50IiwiY29uc3RydWN0b3IiLCJTdXJyb2dhdGUiLCJfX3N1cGVyX18iLCJfZGVwcmVjYXRlZCIsInNjb3BlIiwicHJldmlvdXMiLCJ3YXJuIiwiaGVscGVyc19jb3JlIiwiY2FsbENhbGxiYWNrIiwiaW5kZXhPZiIsImFycmF5IiwiaXRlbSIsImZyb21JbmRleCIsImdldFZhbHVlT3JEZWZhdWx0IiwiZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0IiwiZWZmZWN0cyIsImxpbmVhciIsImVhc2VJblF1YWQiLCJlYXNlT3V0UXVhZCIsImVhc2VJbk91dFF1YWQiLCJlYXNlSW5DdWJpYyIsImVhc2VPdXRDdWJpYyIsImVhc2VJbk91dEN1YmljIiwiZWFzZUluUXVhcnQiLCJlYXNlT3V0UXVhcnQiLCJlYXNlSW5PdXRRdWFydCIsImVhc2VJblF1aW50IiwiZWFzZU91dFF1aW50IiwiZWFzZUluT3V0UXVpbnQiLCJlYXNlSW5TaW5lIiwiZWFzZU91dFNpbmUiLCJlYXNlSW5PdXRTaW5lIiwiZWFzZUluRXhwbyIsImVhc2VPdXRFeHBvIiwiZWFzZUluT3V0RXhwbyIsImVhc2VJbkNpcmMiLCJlYXNlT3V0Q2lyYyIsImVhc2VJbk91dENpcmMiLCJlYXNlSW5FbGFzdGljIiwiYXNpbiIsImVhc2VPdXRFbGFzdGljIiwiZWFzZUluT3V0RWxhc3RpYyIsImVhc2VJbkJhY2siLCJlYXNlT3V0QmFjayIsImVhc2VJbk91dEJhY2siLCJlYXNlSW5Cb3VuY2UiLCJlYXNlT3V0Qm91bmNlIiwiZWFzZUluT3V0Qm91bmNlIiwiaGVscGVyc19lYXNpbmciLCJlYXNpbmdFZmZlY3RzIiwiUkFEX1BFUl9ERUciLCJET1VCTEVfUEkiLCJIQUxGX1BJIiwiUVVBUlRFUl9QSSIsIlRXT19USElSRFNfUEkiLCJleHBvcnRzJDEiLCJjbGVhciIsImNoYXJ0IiwiY3R4IiwiY2xlYXJSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJyb3VuZGVkUmVjdCIsInJhZGl1cyIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsIm1vdmVUbyIsImFyYyIsImNsb3NlUGF0aCIsInJlY3QiLCJkcmF3UG9pbnQiLCJzdHlsZSIsInJvdGF0aW9uIiwieE9mZnNldCIsInlPZmZzZXQiLCJzaXplIiwiY29ybmVyUmFkaXVzIiwicmFkIiwic2F2ZSIsInRyYW5zbGF0ZSIsImRyYXdJbWFnZSIsInJlc3RvcmUiLCJiZWdpblBhdGgiLCJsaW5lVG8iLCJTUVJUMV8yIiwiZmlsbCIsInN0cm9rZSIsIl9pc1BvaW50SW5BcmVhIiwicG9pbnQiLCJhcmVhIiwiZXBzaWxvbiIsImNsaXBBcmVhIiwiY2xpcCIsInVuY2xpcEFyZWEiLCJmbGlwIiwic3RlcHBlZCIsInN0ZXBwZWRMaW5lIiwibWlkcG9pbnQiLCJ0ZW5zaW9uIiwiYmV6aWVyQ3VydmVUbyIsImNvbnRyb2xQb2ludFByZXZpb3VzWCIsImNvbnRyb2xQb2ludE5leHRYIiwiY29udHJvbFBvaW50UHJldmlvdXNZIiwiY29udHJvbFBvaW50TmV4dFkiLCJoZWxwZXJzX2NhbnZhcyIsImRyYXdSb3VuZGVkUmVjdGFuZ2xlIiwiZGVmYXVsdHMiLCJfc2V0IiwiZGVmYXVsdENvbG9yIiwiZGVmYXVsdEZvbnRDb2xvciIsImRlZmF1bHRGb250RmFtaWx5IiwiZGVmYXVsdEZvbnRTaXplIiwiZGVmYXVsdEZvbnRTdHlsZSIsImRlZmF1bHRMaW5lSGVpZ2h0Iiwic2hvd0xpbmVzIiwiY29yZV9kZWZhdWx0cyIsInRvRm9udFN0cmluZyIsImZvbnQiLCJmYW1pbHkiLCJoZWxwZXJzX29wdGlvbnMiLCJ0b0xpbmVIZWlnaHQiLCJtYXRjaGVzIiwidG9QYWRkaW5nIiwiX3BhcnNlRm9udCIsImdsb2JhbERlZmF1bHRzIiwiZm9udFNpemUiLCJmb250RmFtaWx5IiwibGluZUhlaWdodCIsImZvbnRTdHlsZSIsInJlc29sdmUiLCJpbnB1dHMiLCJjb250ZXh0IiwiaW5mbyIsImNhY2hlYWJsZSIsImV4cG9ydHMkMiIsIl9mYWN0b3JpemUiLCJwdXNoIiwic29ydCIsImxvZzEwIiwiZXhwb25lbnQiLCJsb2ciLCJMT0cxMEUiLCJwb3dlck9mMTAiLCJpc1Bvd2VyT2YxMCIsImhlbHBlcnNfbWF0aCIsImdldFJ0bEFkYXB0ZXIiLCJyZWN0WCIsInNldFdpZHRoIiwidGV4dEFsaWduIiwiYWxpZ24iLCJ4UGx1cyIsImxlZnRGb3JMdHIiLCJpdGVtV2lkdGgiLCJnZXRMdHJBZGFwdGVyIiwiX2l0ZW1XaWR0aCIsImdldEFkYXB0ZXIiLCJydGwiLCJvdmVycmlkZVRleHREaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJvcmlnaW5hbCIsImNhbnZhcyIsImdldFByb3BlcnR5VmFsdWUiLCJnZXRQcm9wZXJ0eVByaW9yaXR5Iiwic2V0UHJvcGVydHkiLCJwcmV2VGV4dERpcmVjdGlvbiIsInJlc3RvcmVUZXh0RGlyZWN0aW9uIiwiaGVscGVyc19ydGwiLCJoZWxwZXJzJDEiLCJlYXNpbmciLCJtYXRoIiwiaW50ZXJwb2xhdGUiLCJzdGFydCIsInZpZXciLCJlYXNlIiwiYWN0dWFsIiwib3JpZ2luIiwiYzAiLCJjMSIsIkVsZW1lbnQiLCJjb25maWd1cmF0aW9uIiwiaW5pdGlhbGl6ZSIsIl90eXBlIiwiaGlkZGVuIiwicGl2b3QiLCJfdmlldyIsIl9tb2RlbCIsIl9zdGFydCIsInRyYW5zaXRpb24iLCJ0b29sdGlwUG9zaXRpb24iLCJoYXNWYWx1ZSIsImlzTnVtYmVyIiwiY29yZV9lbGVtZW50IiwiZXhwb3J0cyQzIiwiY3VycmVudFN0ZXAiLCJudW1TdGVwcyIsInJlbmRlciIsIm9uQW5pbWF0aW9uUHJvZ3Jlc3MiLCJvbkFuaW1hdGlvbkNvbXBsZXRlIiwiY29yZV9hbmltYXRpb24iLCJnZXQiLCJzZXQiLCJhbmltYXRpb24iLCJkdXJhdGlvbiIsIm9uUHJvZ3Jlc3MiLCJvbkNvbXBsZXRlIiwiY29yZV9hbmltYXRpb25zIiwiYW5pbWF0aW9ucyIsInJlcXVlc3QiLCJhZGRBbmltYXRpb24iLCJsYXp5Iiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsImFuaW1hdGluZyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbiIsImZpbmRJbmRleCIsInNwbGljZSIsInJlcXVlc3RBbmltRnJhbWUiLCJzdGFydERpZ2VzdCIsImFkdmFuY2UiLCJuZXh0U3RlcCIsImFycmF5RXZlbnRzIiwibGlzdGVuQXJyYXlFdmVudHMiLCJsaXN0ZW5lciIsIl9jaGFydGpzIiwibGlzdGVuZXJzIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIm1ldGhvZCIsImJhc2UiLCJyZXMiLCJvYmplY3QiLCJ1bmxpc3RlbkFycmF5RXZlbnRzIiwic3R1YiIsIkRhdGFzZXRDb250cm9sbGVyIiwiZGF0YXNldEluZGV4IiwiZGF0YXNldEVsZW1lbnRUeXBlIiwiZGF0YUVsZW1lbnRUeXBlIiwiX2RhdGFzZXRFbGVtZW50T3B0aW9ucyIsIl9kYXRhRWxlbWVudE9wdGlvbnMiLCJsaW5rU2NhbGVzIiwiYWRkRWxlbWVudHMiLCJnZXRNZXRhIiwidXBkYXRlSW5kZXgiLCJtZXRhIiwic2NhbGVzIiwiZGF0YXNldCIsImdldERhdGFzZXQiLCJzY2FsZXNPcHRzIiwieEF4aXNJRCIsInhBeGVzIiwieUF4aXNJRCIsInlBeGVzIiwiZGF0YSIsImRhdGFzZXRzIiwiZ2V0RGF0YXNldE1ldGEiLCJnZXRTY2FsZUZvcklkIiwic2NhbGVJRCIsIl9nZXRWYWx1ZVNjYWxlSWQiLCJfZ2V0SW5kZXhTY2FsZUlkIiwiX2dldFZhbHVlU2NhbGUiLCJfZ2V0SW5kZXhTY2FsZSIsInJlc2V0IiwiX3VwZGF0ZSIsImRlc3Ryb3kiLCJfZGF0YSIsImNyZWF0ZU1ldGFEYXRhc2V0IiwiX2NoYXJ0IiwiX2RhdGFzZXRJbmRleCIsImNyZWF0ZU1ldGFEYXRhIiwiX2luZGV4IiwibWV0YURhdGEiLCJhZGRFbGVtZW50QW5kUmVzZXQiLCJlbGVtZW50IiwidXBkYXRlRWxlbWVudCIsImJ1aWxkT3JVcGRhdGVFbGVtZW50cyIsImlzRXh0ZW5zaWJsZSIsInJlc3luY0VsZW1lbnRzIiwiX2NvbmZpZ3VyZSIsIl9jb25maWciLCJfY2FjaGVkRGF0YU9wdHMiLCJ1cGRhdGUiLCJlYXNpbmdWYWx1ZSIsImVsZW1lbnRzIiwiZHJhdyIsImdldFN0eWxlIiwiX3Jlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMiLCJfcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyIsImJhY2tncm91bmRDb2xvciIsImJvcmRlckNvbG9yIiwiaG92ZXIiLCJkYXRhc2V0T3B0cyIsImN1c3RvbSIsImVsZW1lbnRPcHRpb25zIiwicmVhZEtleSIsImNhY2hlZCIsImRhdGFJbmRleCIsImZyZWV6ZSIsInJlbW92ZUhvdmVyU3R5bGUiLCIkcHJldmlvdXNTdHlsZSIsInNldEhvdmVyU3R5bGUiLCJnZXRIb3ZlckNvbG9yIiwiYm9yZGVyV2lkdGgiLCJob3ZlckJhY2tncm91bmRDb2xvciIsImhvdmVyQm9yZGVyQ29sb3IiLCJob3ZlckJvcmRlcldpZHRoIiwiX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlIiwiX3NldERhdGFzZXRIb3ZlclN0eWxlIiwicHJldiIsImhvdmVyT3B0aW9ucyIsIm51bU1ldGEiLCJudW1EYXRhIiwiaW5zZXJ0RWxlbWVudHMiLCJjb3VudCIsIm9uRGF0YVB1c2giLCJvbkRhdGFQb3AiLCJvbkRhdGFTaGlmdCIsInNoaWZ0Iiwib25EYXRhU3BsaWNlIiwib25EYXRhVW5zaGlmdCIsImNvcmVfZGF0YXNldENvbnRyb2xsZXIiLCJUQVUiLCJib3JkZXJBbGlnbiIsImNsaXBBcmMiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJwaXhlbE1hcmdpbiIsImFuZ2xlTWFyZ2luIiwib3V0ZXJSYWRpdXMiLCJpbm5lclJhZGl1cyIsImRyYXdGdWxsQ2lyY2xlQm9yZGVycyIsInZtIiwiaW5uZXIiLCJmdWxsQ2lyY2xlcyIsImRyYXdCb3JkZXIiLCJsaW5lV2lkdGgiLCJsaW5lSm9pbiIsImVsZW1lbnRfYXJjIiwiaW5MYWJlbFJhbmdlIiwibW91c2VYIiwiaG92ZXJSYWRpdXMiLCJpblJhbmdlIiwiY2hhcnRYIiwiY2hhcnRZIiwicG9pbnRSZWxhdGl2ZVBvc2l0aW9uIiwiZ2V0QW5nbGVGcm9tUG9pbnQiLCJhbmdsZSIsImJldHdlZW5BbmdsZXMiLCJ3aXRoaW5SYWRpdXMiLCJnZXRDZW50ZXJQb2ludCIsImhhbGZBbmdsZSIsImhhbGZSYWRpdXMiLCJnZXRBcmVhIiwiY2VudHJlQW5nbGUiLCJyYW5nZUZyb21DZW50cmUiLCJjaXJjdW1mZXJlbmNlIiwiZmlsbFN0eWxlIiwic3Ryb2tlU3R5bGUiLCJ2YWx1ZU9yRGVmYXVsdCQxIiwibGluZSIsImJvcmRlckNhcFN0eWxlIiwiYm9yZGVyRGFzaCIsImJvcmRlckRhc2hPZmZzZXQiLCJib3JkZXJKb2luU3R5bGUiLCJjYXBCZXppZXJQb2ludHMiLCJlbGVtZW50X2xpbmUiLCJzcGFuR2FwcyIsInBvaW50cyIsIl9jaGlsZHJlbiIsImdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cyIsImxhc3REcmF3bkluZGV4IiwiX2xvb3AiLCJjdXJyZW50Vk0iLCJwcmV2aW91c0l0ZW0iLCJza2lwIiwibGluZUNhcCIsInNldExpbmVEYXNoIiwibGluZURhc2hPZmZzZXQiLCJ2YWx1ZU9yRGVmYXVsdCQyIiwiZGVmYXVsdENvbG9yJDEiLCJwb2ludFN0eWxlIiwiaGl0UmFkaXVzIiwieFJhbmdlIiwiYWJzIiwieVJhbmdlIiwibW91c2VZIiwiZWxlbWVudF9wb2ludCIsImluWFJhbmdlIiwiaW5ZUmFuZ2UiLCJwYWRkaW5nIiwiY2hhcnRBcmVhIiwiZGVmYXVsdENvbG9yJDIiLCJyZWN0YW5nbGUiLCJib3JkZXJTa2lwcGVkIiwiaXNWZXJ0aWNhbCIsImdldEJhckJvdW5kcyIsIngxIiwieTEiLCJoYWxmIiwic3dhcCIsIm9yaWciLCJ2MiIsInBhcnNlQm9yZGVyU2tpcHBlZCIsImVkZ2UiLCJob3Jpem9udGFsIiwicGFyc2VCb3JkZXJXaWR0aCIsIm1heFciLCJtYXhIIiwiYm91bmRpbmdSZWN0cyIsImJvdW5kcyIsImJvcmRlciIsIm91dGVyIiwic2tpcFgiLCJza2lwWSIsImVsZW1lbnRfcmVjdGFuZ2xlIiwicmVjdHMiLCJmaWxsUmVjdCIsIkFyYyIsIkxpbmUiLCJQb2ludCIsIlJlY3RhbmdsZSIsImRlcHJlY2F0ZWQiLCJ2YWx1ZU9yRGVmYXVsdCQzIiwibW9kZSIsIm9mZnNldCIsImdyaWRMaW5lcyIsIm9mZnNldEdyaWRMaW5lcyIsImJhciIsImNhdGVnb3J5UGVyY2VudGFnZSIsImJhclBlcmNlbnRhZ2UiLCJjb21wdXRlTWluU2FtcGxlU2l6ZSIsInBpeGVscyIsIl9sZW5ndGgiLCJjdXJyIiwiZ2V0VGlja3MiLCJnZXRQaXhlbEZvclRpY2siLCJjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMiLCJydWxlciIsInRoaWNrbmVzcyIsImJhclRoaWNrbmVzcyIsInN0YWNrQ291bnQiLCJjaHVuayIsImNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMiLCJuZXh0IiwicGVyY2VudCIsImVuZCIsImNvbnRyb2xsZXJfYmFyIiwic2NhbGVPcHRzIiwic3RhY2siLCJtaW5CYXJMZW5ndGgiLCJtYXhCYXJUaGlja25lc3MiLCJfcnVsZXIiLCJnZXRSdWxlciIsIl94U2NhbGUiLCJfeVNjYWxlIiwiZGF0YXNldExhYmVsIiwibGFiZWwiLCJfdXBkYXRlRWxlbWVudEdlb21ldHJ5IiwidnNjYWxlIiwiZ2V0QmFzZVBpeGVsIiwiaXNIb3Jpem9udGFsIiwidnBpeGVscyIsImNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwiaXBpeGVscyIsImNhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwiaGVhZCIsImNlbnRlciIsIl9nZXRTdGFja3MiLCJsYXN0IiwibWV0YXNldHMiLCJfZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMiLCJzdGFja2VkIiwic3RhY2tzIiwiZ2V0U3RhY2tDb3VudCIsImdldFN0YWNrSW5kZXgiLCJnZXRQaXhlbEZvclZhbHVlIiwiX3N0YXJ0UGl4ZWwiLCJfZW5kUGl4ZWwiLCJfcGFyc2VWYWx1ZSIsImltZXRhIiwiaXZhbHVlIiwic3RhY2tMZW5ndGgiLCJyYW5nZSIsInN0YWNrSW5kZXgiLCJpbmRleE9wdHMiLCJ2YWx1ZU9wdHMiLCJ2YWx1ZU9yRGVmYXVsdCQ0IiwicmVzb2x2ZSQxIiwicG9zaXRpb24iLCJ0b29sdGlwcyIsImNhbGxiYWNrcyIsInRpdGxlIiwiZGF0YVBvaW50IiwieExhYmVsIiwieUxhYmVsIiwiY29udHJvbGxlcl9idWJibGUiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJkc0luZGV4IiwiZ2V0UGl4ZWxGb3JEZWNpbWFsIiwiTmFOIiwiX29wdGlvbnMiLCJ2YWx1ZU9yRGVmYXVsdCQ1IiwiUEkkMSIsIkRPVUJMRV9QSSQxIiwiSEFMRl9QSSQxIiwiYW5pbWF0ZVJvdGF0ZSIsImFuaW1hdGVTY2FsZSIsImxlZ2VuZENhbGxiYWNrIiwibGlzdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImxpc3RJdGVtIiwibGlzdEl0ZW1TcGFuIiwic2V0QXR0cmlidXRlIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsIm91dGVySFRNTCIsImxlZ2VuZCIsImdlbmVyYXRlTGFiZWxzIiwiY29udHJvbGxlciIsInRleHQiLCJvbkNsaWNrIiwibGVnZW5kSXRlbSIsImN1dG91dFBlcmNlbnRhZ2UiLCJ0b29sdGlwSXRlbSIsImRhdGFMYWJlbCIsImNvbnRyb2xsZXJfZG91Z2hudXQiLCJnZXRSaW5nSW5kZXgiLCJyaW5nSW5kZXgiLCJqIiwiaXNEYXRhc2V0VmlzaWJsZSIsIm9wdHMiLCJyYXRpb1giLCJyYXRpb1kiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImFyY3MiLCJjdXRvdXQiLCJjaGFydFdlaWdodCIsIl9nZXRSaW5nV2VpZ2h0IiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJzdGFydFgiLCJzdGFydFkiLCJlbmRYIiwiZW5kWSIsImNvbnRhaW5zMCIsImNvbnRhaW5zOTAiLCJjb250YWluczE4MCIsImNvbnRhaW5zMjcwIiwibWluWCIsIm1pblkiLCJtYXhYIiwibWF4WSIsImdldE1heEJvcmRlcldpZHRoIiwicmFkaXVzTGVuZ3RoIiwiX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwiLCJ0b3RhbCIsImNhbGN1bGF0ZVRvdGFsIiwiX2dldFJpbmdXZWlnaHRPZmZzZXQiLCJhbmltYXRpb25PcHRzIiwiY2VudGVyWCIsImNlbnRlclkiLCJjYWxjdWxhdGVDaXJjdW1mZXJlbmNlIiwiaG92ZXJXaWR0aCIsInJpbmdXZWlnaHRPZmZzZXQiLCJkYXRhU2V0SW5kZXgiLCJheGlzIiwiaG9yaXpvbnRhbEJhciIsImNvbnRyb2xsZXJfaG9yaXpvbnRhbEJhciIsInZhbHVlT3JEZWZhdWx0JDYiLCJyZXNvbHZlJDIiLCJpc1BvaW50SW5BcmVhIiwic2NhbGVDbGlwIiwiaGFsZkJvcmRlcldpZHRoIiwidGlja09wdHMiLCJ0aWNrcyIsImRlZmF1bHRDbGlwIiwidG9DbGlwIiwiY29udHJvbGxlcl9saW5lIiwiY29uZmlnIiwic2hvd0xpbmUiLCJfc2hvd0xpbmUiLCJsaW5lVGVuc2lvbiIsIl9zY2FsZSIsInVwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCJsaW5lTW9kZWwiLCJjYWxjdWxhdGVQb2ludFkiLCJsaW5lT3B0aW9ucyIsInN1bVBvcyIsInN1bU5lZyIsImRzIiwiZHNNZXRhIiwic3RhY2tlZFJpZ2h0VmFsdWUiLCJyaWdodFZhbHVlIiwiZ2V0UmlnaHRWYWx1ZSIsIl9nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzIiwiY29udHJvbFBvaW50cyIsImZpbHRlciIsInB0IiwiY2FwQ29udHJvbFBvaW50IiwiY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSIsInNwbGluZUN1cnZlTW9ub3RvbmUiLCJzcGxpbmVDdXJ2ZSIsIm5leHRJdGVtIiwicmVzb2x2ZSQzIiwiYW5nbGVMaW5lcyIsImRpc3BsYXkiLCJjaXJjdWxhciIsInBvaW50TGFiZWxzIiwiYmVnaW5BdFplcm8iLCJjb250cm9sbGVyX3BvbGFyQXJlYSIsInN0YXJ0cyIsIl9zdGFydHMiLCJhbmdsZXMiLCJfYW5nbGVzIiwiX3VwZGF0ZVJhZGl1cyIsImNvdW50VmlzaWJsZUVsZW1lbnRzIiwiX2NvbXB1dGVBbmdsZSIsIm1pblNpemUiLCJnZXRWaXNpYmxlRGF0YXNldENvdW50IiwieENlbnRlciIsInlDZW50ZXIiLCJkYXRhc2V0U3RhcnRBbmdsZSIsImdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlIiwicmVzZXRSYWRpdXMiLCJkb3VnaG51dCIsImNvbnRyb2xsZXJfcGllIiwidmFsdWVPckRlZmF1bHQkNyIsImNvbnRyb2xsZXJfcmFkYXIiLCJwb2ludFBvc2l0aW9uIiwiZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlIiwic2NhdHRlciIsImNvbnRyb2xsZXJfc2NhdHRlciIsImNvbnRyb2xsZXJzIiwiYnViYmxlIiwicG9sYXJBcmVhIiwicGllIiwicmFkYXIiLCJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwibmF0aXZlIiwicGFyc2VWaXNpYmxlSXRlbXMiLCJoYW5kbGVyIiwibWV0YWRhdGEiLCJqbGVuIiwiZ2V0SW50ZXJzZWN0SXRlbXMiLCJnZXROZWFyZXN0SXRlbXMiLCJpbnRlcnNlY3QiLCJkaXN0YW5jZU1ldHJpYyIsIm1pbkRpc3RhbmNlIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJuZWFyZXN0SXRlbXMiLCJnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMiLCJ1c2VYIiwidXNlWSIsInB0MSIsInB0MiIsImRlbHRhWCIsImRlbHRhWSIsImluZGV4TW9kZSIsIml0ZW1zIiwiY29yZV9pbnRlcmFjdGlvbiIsIm1vZGVzIiwic2luZ2xlIiwibmVhcmVzdCIsImludGVyc2VjdHNJdGVtIiwiZmlsdGVyQnlQb3NpdGlvbiIsIndoZXJlIiwicG9zIiwic29ydEJ5V2VpZ2h0Iiwid3JhcEJveGVzIiwiYm94ZXMiLCJsYXlvdXRCb3hlcyIsImJveCIsInNldExheW91dERpbXMiLCJsYXlvdXRzIiwicGFyYW1zIiwibGF5b3V0IiwiZnVsbFdpZHRoIiwiYXZhaWxhYmxlV2lkdGgiLCJ2Qm94TWF4V2lkdGgiLCJoQm94TWF4SGVpZ2h0IiwiYnVpbGRMYXlvdXRCb3hlcyIsImxlZnRBbmRUb3AiLCJyaWdodEFuZEJvdHRvbSIsInZlcnRpY2FsIiwiZ2V0Q29tYmluZWRNYXgiLCJtYXhQYWRkaW5nIiwidXBkYXRlRGltcyIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwiZ2V0UGFkZGluZyIsImJveFBhZGRpbmciLCJvdXRlcldpZHRoIiwib3V0ZXJIZWlnaHQiLCJoYW5kbGVNYXhQYWRkaW5nIiwidXBkYXRlUG9zIiwiY2hhbmdlIiwiZ2V0TWFyZ2lucyIsIm1hcmdpbkZvclBvc2l0aW9ucyIsInBvc2l0aW9ucyIsIm1hcmdpbiIsImZpdEJveGVzIiwicmVmaXRCb3hlcyIsInJlZml0IiwiY2hhbmdlZCIsInBsYWNlQm94ZXMiLCJ1c2VyUGFkZGluZyIsImNvcmVfbGF5b3V0cyIsImFkZEJveCIsIl9sYXllcnMiLCJyZW1vdmVCb3giLCJsYXlvdXRJdGVtIiwiY29uZmlndXJlIiwicHJvcHMiLCJsYXlvdXRPcHRpb25zIiwiYXZhaWxhYmxlSGVpZ2h0IiwidmVydGljYWxCb3hlcyIsImhvcml6b250YWxCb3hlcyIsInBsYXRmb3JtX2Jhc2ljIiwiYWNxdWlyZUNvbnRleHQiLCJnZXRDb250ZXh0IiwicGxhdGZvcm1fZG9tIiwicGxhdGZvcm1fZG9tJDEiLCJfX3Byb3RvX18iLCJzdHlsZXNoZWV0IiwiRVhQQU5ET19LRVkiLCJDU1NfUFJFRklYIiwiQ1NTX1NJWkVfTU9OSVRPUiIsIkNTU19SRU5ERVJfTU9OSVRPUiIsIkNTU19SRU5ERVJfQU5JTUFUSU9OIiwiQU5JTUFUSU9OX1NUQVJUX0VWRU5UUyIsIkVWRU5UX1RZUEVTIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmRvd24iLCJwb2ludGVybW92ZSIsInBvaW50ZXJ1cCIsInBvaW50ZXJsZWF2ZSIsInBvaW50ZXJvdXQiLCJyZWFkVXNlZFNpemUiLCJwcm9wZXJ0eSIsImluaXRDYW52YXMiLCJyZW5kZXJIZWlnaHQiLCJnZXRBdHRyaWJ1dGUiLCJyZW5kZXJXaWR0aCIsImluaXRpYWwiLCJkaXNwbGF5V2lkdGgiLCJhc3BlY3RSYXRpbyIsImRpc3BsYXlIZWlnaHQiLCJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwic3VwcG9ydHMiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnRMaXN0ZW5lck9wdGlvbnMiLCJwYXNzaXZlIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjcmVhdGVFdmVudCIsIm5hdGl2ZUV2ZW50IiwiZnJvbU5hdGl2ZUV2ZW50IiwiZXZlbnQiLCJ0aHJvdHRsZWQiLCJ0aWNraW5nIiwiY3JlYXRlRGl2IiwiY2xzIiwiZWwiLCJjbGFzc05hbWUiLCJjcmVhdGVSZXNpemVyIiwibWF4U2l6ZSIsInJlc2l6ZXIiLCJleHBhbmQiLCJzaHJpbmsiLCJfcmVzZXQiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwib25TY3JvbGwiLCJiaW5kIiwid2F0Y2hGb3JSZW5kZXIiLCJleHBhbmRvIiwicHJveHkiLCJyZW5kZXJQcm94eSIsImFuaW1hdGlvbk5hbWUiLCJyZWZsb3ciLCJvZmZzZXRQYXJlbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJ1bndhdGNoRm9yUmVuZGVyIiwicmVtb3ZlIiwiYWRkUmVzaXplTGlzdGVuZXIiLCJjb250YWluZXIiLCJtYWludGFpbkFzcGVjdFJhdGlvIiwicGFyZW50Tm9kZSIsImNsaWVudFdpZHRoIiwiaW5zZXJ0QmVmb3JlIiwiZmlyc3RDaGlsZCIsInJlbW92ZVJlc2l6ZUxpc3RlbmVyIiwicmVtb3ZlQ2hpbGQiLCJpbmplY3RDU1MiLCJyb290Tm9kZSIsImNzcyIsImNvbnRhaW5zU3R5bGVzIiwicGxhdGZvcm1fZG9tJDIiLCJkaXNhYmxlQ1NTSW5qZWN0aW9uIiwiX2VuYWJsZWQiLCJfZW5zdXJlTG9hZGVkIiwicm9vdCIsImdldFJvb3ROb2RlIiwidGFyZ2V0Tm9kZSIsImhvc3QiLCJnZXRFbGVtZW50QnlJZCIsInJlbGVhc2VDb250ZXh0IiwicmVtb3ZlQXR0cmlidXRlIiwicHJveGllcyIsImFkZEV2ZW50IiwicmVtb3ZlRXZlbnQiLCJpbXBsZW1lbnRhdGlvbiIsInBsYXRmb3JtIiwicGx1Z2lucyIsImNvcmVfcGx1Z2lucyIsIl9wbHVnaW5zIiwiX2NhY2hlSWQiLCJyZWdpc3RlciIsInBsdWdpbiIsInVucmVnaXN0ZXIiLCJpZHgiLCJnZXRBbGwiLCJub3RpZnkiLCJob29rIiwiZGVzY3JpcHRvcnMiLCJkZXNjcmlwdG9yIiwiY2FjaGUiLCIkcGx1Z2lucyIsIl9pbnZhbGlkYXRlIiwiY29yZV9zY2FsZVNlcnZpY2UiLCJjb25zdHJ1Y3RvcnMiLCJyZWdpc3RlclNjYWxlVHlwZSIsInNjYWxlQ29uc3RydWN0b3IiLCJzY2FsZURlZmF1bHRzIiwiZ2V0U2NhbGVDb25zdHJ1Y3RvciIsImdldFNjYWxlRGVmYXVsdHMiLCJ1cGRhdGVTY2FsZURlZmF1bHRzIiwiYWRkaXRpb25zIiwiYWRkU2NhbGVzVG9MYXlvdXQiLCJ2YWx1ZU9yRGVmYXVsdCQ4IiwiZ2V0UnRsSGVscGVyIiwiZW5hYmxlZCIsInRpdGxlRm9udFN0eWxlIiwidGl0bGVTcGFjaW5nIiwidGl0bGVNYXJnaW5Cb3R0b20iLCJ0aXRsZUZvbnRDb2xvciIsInRpdGxlQWxpZ24iLCJib2R5U3BhY2luZyIsImJvZHlGb250Q29sb3IiLCJib2R5QWxpZ24iLCJmb290ZXJGb250U3R5bGUiLCJmb290ZXJTcGFjaW5nIiwiZm9vdGVyTWFyZ2luVG9wIiwiZm9vdGVyRm9udENvbG9yIiwiZm9vdGVyQWxpZ24iLCJ5UGFkZGluZyIsInhQYWRkaW5nIiwiY2FyZXRQYWRkaW5nIiwiY2FyZXRTaXplIiwibXVsdGlLZXlCYWNrZ3JvdW5kIiwiZGlzcGxheUNvbG9ycyIsImJlZm9yZVRpdGxlIiwidG9vbHRpcEl0ZW1zIiwibGFiZWxDb3VudCIsImFmdGVyVGl0bGUiLCJiZWZvcmVCb2R5IiwiYmVmb3JlTGFiZWwiLCJsYWJlbENvbG9yIiwiYWN0aXZlRWxlbWVudCIsImxhYmVsVGV4dENvbG9yIiwiYWZ0ZXJMYWJlbCIsImFmdGVyQm9keSIsImJlZm9yZUZvb3RlciIsImZvb3RlciIsImFmdGVyRm9vdGVyIiwicG9zaXRpb25lcnMiLCJhdmVyYWdlIiwiZXZlbnRQb3NpdGlvbiIsIm5lYXJlc3RFbGVtZW50IiwiZCIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsInRwIiwicHVzaE9yQ29uY2F0IiwidG9QdXNoIiwic3BsaXROZXdsaW5lcyIsIlN0cmluZyIsImNyZWF0ZVRvb2x0aXBJdGVtIiwiaW5kZXhTY2FsZSIsInZhbHVlU2NhbGUiLCJnZXRMYWJlbEZvckluZGV4IiwiZ2V0QmFzZU1vZGVsIiwidG9vbHRpcE9wdHMiLCJ4QWxpZ24iLCJ5QWxpZ24iLCJ0ZXh0RGlyZWN0aW9uIiwiX2JvZHlGb250RmFtaWx5IiwiYm9keUZvbnRGYW1pbHkiLCJfYm9keUZvbnRTdHlsZSIsImJvZHlGb250U3R5bGUiLCJfYm9keUFsaWduIiwiYm9keUZvbnRTaXplIiwiX3RpdGxlRm9udEZhbWlseSIsInRpdGxlRm9udEZhbWlseSIsIl90aXRsZUZvbnRTdHlsZSIsInRpdGxlRm9udFNpemUiLCJfdGl0bGVBbGlnbiIsIl9mb290ZXJGb250RmFtaWx5IiwiZm9vdGVyRm9udEZhbWlseSIsIl9mb290ZXJGb250U3R5bGUiLCJmb290ZXJGb250U2l6ZSIsIl9mb290ZXJBbGlnbiIsIm9wYWNpdHkiLCJsZWdlbmRDb2xvckJhY2tncm91bmQiLCJnZXRUb29sdGlwU2l6ZSIsInRvb2x0aXAiLCJib2R5IiwiY29tYmluZWRCb2R5TGVuZ3RoIiwicmVkdWNlIiwiYm9keUl0ZW0iLCJiZWZvcmUiLCJsaW5lcyIsImFmdGVyIiwidGl0bGVMaW5lQ291bnQiLCJmb290ZXJMaW5lQ291bnQiLCJ3aWR0aFBhZGRpbmciLCJtYXhMaW5lV2lkdGgiLCJtZWFzdXJlVGV4dCIsImZvbnRTdHJpbmciLCJkZXRlcm1pbmVBbGlnbm1lbnQiLCJsZiIsInJmIiwib2xmIiwib3JmIiwieWYiLCJtaWRYIiwibWlkWSIsImdldEJhY2tncm91bmRQb2ludCIsImFsaWdubWVudCIsInBhZGRpbmdBbmRTaXplIiwicmFkaXVzQW5kUGFkZGluZyIsImdldEFsaWduZWRYIiwiZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMiLCJleHBvcnRzJDQiLCJfbGFzdEFjdGl2ZSIsImdldFRpdGxlIiwiZ2V0QmVmb3JlQm9keSIsImdldEJvZHkiLCJib2R5SXRlbXMiLCJnZXRBZnRlckJvZHkiLCJnZXRGb290ZXIiLCJleGlzdGluZ01vZGVsIiwiYWN0aXZlIiwiX2FjdGl2ZSIsImJhY2tncm91bmRQb2ludCIsInRvb2x0aXBTaXplIiwiY2FyZXRYIiwiY2FyZXRZIiwibGFiZWxDb2xvcnMiLCJsYWJlbFRleHRDb2xvcnMiLCJfZXZlbnRQb3NpdGlvbiIsIml0ZW1Tb3J0IiwiZGF0YVBvaW50cyIsImRyYXdDYXJldCIsInRvb2x0aXBQb2ludCIsImNhcmV0UG9zaXRpb24iLCJnZXRDYXJldFBvc2l0aW9uIiwieDMiLCJ5MyIsInB0WCIsInB0WSIsInRtcCIsImRyYXdUaXRsZSIsInJ0bEhlbHBlciIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0IiwiZHJhd0JvZHkiLCJkcmF3Q29sb3JCb3hlcyIsInhMaW5lUGFkZGluZyIsImNvbG9yWCIsImZpbGxMaW5lT2ZUZXh0IiwidGV4dENvbG9yIiwiYm9keUFsaWduRm9yQ2FsY3VsYXRpb24iLCJydGxDb2xvclgiLCJzdHJva2VSZWN0IiwiZHJhd0Zvb3RlciIsImRyYXdCYWNrZ3JvdW5kIiwicXVhZHJhdGljQ3VydmVUbyIsImhhc1Rvb2x0aXBDb250ZW50IiwiZ2xvYmFsQWxwaGEiLCJoYW5kbGVFdmVudCIsImdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUiLCJwb3NpdGlvbmVyc18xIiwiY29yZV90b29sdGlwIiwidmFsdWVPckRlZmF1bHQkOSIsImV2ZW50cyIsIm9uSG92ZXIiLCJhbmltYXRpb25EdXJhdGlvbiIsInJlc3BvbnNpdmUiLCJyZXNwb25zaXZlQW5pbWF0aW9uRHVyYXRpb24iLCJtZXJnZVNjYWxlQ29uZmlnIiwic2xlbiIsIm1lcmdlQ29uZmlnIiwiaW5pdENvbmZpZyIsInVwZGF0ZUNvbmZpZyIsIm5ld09wdGlvbnMiLCJlbnN1cmVTY2FsZXNIYXZlSURzIiwiYnVpbGRPclVwZGF0ZVNjYWxlcyIsIm5leHRBdmFpbGFibGVTY2FsZUlkIiwiYXhlc09wdHMiLCJwcmVmaXgiLCJoYXNJZCIsInBvc2l0aW9uSXNIb3Jpem9udGFsIiwiY29tcGFyZTJMZXZlbCIsImwxIiwibDIiLCJDaGFydCIsImNvbnN0cnVjdCIsIl9idWZmZXJlZFJlbmRlciIsImluc3RhbmNlcyIsInJldGluYVNjYWxlIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImJpbmRFdmVudHMiLCJyZXNpemUiLCJpbml0VG9vbFRpcCIsInN0b3AiLCJzaWxlbnQiLCJnZXRNYXhpbXVtV2lkdGgiLCJnZXRNYXhpbXVtSGVpZ2h0IiwibmV3U2l6ZSIsIm9uUmVzaXplIiwic2NhbGVzT3B0aW9ucyIsInNjYWxlT3B0aW9ucyIsInhBeGlzT3B0aW9ucyIsInlBeGlzT3B0aW9ucyIsInVwZGF0ZWQiLCJkdHlwZSIsImRwb3NpdGlvbiIsImlzRGVmYXVsdCIsInNjYWxlVHlwZSIsInNjYWxlQ2xhc3MiLCJtZXJnZVRpY2tzT3B0aW9ucyIsImhhc1VwZGF0ZWQiLCJidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMiLCJuZXdDb250cm9sbGVycyIsImRlc3Ryb3lEYXRhc2V0TWV0YSIsIm9yZGVyIiwiQ29udHJvbGxlckNsYXNzIiwicmVzZXRFbGVtZW50cyIsInVwZGF0ZUxheW91dCIsInVwZGF0ZURhdGFzZXRzIiwibGFzdEFjdGl2ZSIsIl9idWZmZXJlZFJlcXVlc3QiLCJfaWR4IiwidXBkYXRlRGF0YXNldCIsImFuaW1hdGlvbk9wdGlvbnMiLCJhbmltYXRpb25PYmplY3QiLCJlYXNpbmdGdW5jdGlvbiIsInN0ZXBEZWNpbWFsIiwibGF5ZXJzIiwiZHJhd0RhdGFzZXRzIiwiX2RyYXdUb29sdGlwIiwiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsImZpbHRlclZpc2libGUiLCJkcmF3RGF0YXNldCIsImdldEVsZW1lbnRBdEV2ZW50IiwiZ2V0RWxlbWVudHNBdEV2ZW50IiwiZ2V0RWxlbWVudHNBdFhBeGlzIiwiZ2V0RGF0YXNldEF0RXZlbnQiLCJfbWV0YSIsImdlbmVyYXRlTGVnZW5kIiwidW5iaW5kRXZlbnRzIiwidG9CYXNlNjRJbWFnZSIsInRvRGF0YVVSTCIsIl9jaGFydEluc3RhbmNlIiwiX2xpc3RlbmVycyIsImV2ZW50SGFuZGxlciIsInVwZGF0ZUhvdmVyU3R5bGUiLCJidWZmZXJlZFJlcXVlc3QiLCJjb3JlX2NvbnRyb2xsZXIiLCJDb250cm9sbGVyIiwidHlwZXMiLCJjb25maWdNZXJnZSIsInNjYWxlTWVyZ2UiLCJjb3JlX2hlbHBlcnMiLCJjb2xsZWN0aW9uIiwiZmlsdGVyQ2FsbGJhY2siLCJmaWx0ZXJlZCIsImZpbmROZXh0V2hlcmUiLCJhcnJheVRvU2VhcmNoIiwic3RhcnRJbmRleCIsImN1cnJlbnRJdGVtIiwiZmluZFByZXZpb3VzV2hlcmUiLCJhbG1vc3RFcXVhbHMiLCJhbG1vc3RXaG9sZSIsInJvdW5kZWQiLCJORUdBVElWRV9JTkZJTklUWSIsInNpZ24iLCJ0b1JhZGlhbnMiLCJ0b0RlZ3JlZXMiLCJyYWRpYW5zIiwiX2RlY2ltYWxQbGFjZXMiLCJjZW50cmVQb2ludCIsImFuZ2xlUG9pbnQiLCJkaXN0YW5jZUZyb21YQ2VudGVyIiwiZGlzdGFuY2VGcm9tWUNlbnRlciIsInJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciIsImFsaWFzUGl4ZWwiLCJwaXhlbFdpZHRoIiwiX2FsaWduUGl4ZWwiLCJwaXhlbCIsImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwiaGFsZldpZHRoIiwiZmlyc3RQb2ludCIsIm1pZGRsZVBvaW50IiwiYWZ0ZXJQb2ludCIsImQwMSIsImQxMiIsInMwMSIsInMxMiIsImZhIiwiZmIiLCJFUFNJTE9OIiwicG9pbnRzV2l0aFRhbmdlbnRzIiwiZGVsdGFLIiwibUsiLCJwb2ludHNMZW4iLCJwb2ludEJlZm9yZSIsInBvaW50Q3VycmVudCIsInBvaW50QWZ0ZXIiLCJzbG9wZURlbHRhWCIsImFscGhhSyIsImJldGFLIiwidGF1SyIsInNxdWFyZWRNYWduaXR1ZGUiLCJsb29wIiwibmljZU51bSIsImZyYWN0aW9uIiwibmljZUZyYWN0aW9uIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsImV2dCIsIm9yaWdpbmFsRXZlbnQiLCJzcmNFbGVtZW50IiwiYm91bmRpbmdSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG91Y2hlcyIsImNsaWVudFgiLCJjbGllbnRZIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ0JvdHRvbSIsInBhcnNlTWF4U3R5bGUiLCJzdHlsZVZhbHVlIiwicGFyZW50UHJvcGVydHkiLCJ2YWx1ZUluUGl4ZWxzIiwiaXNDb25zdHJhaW5lZFZhbHVlIiwiZ2V0Q29uc3RyYWludERpbWVuc2lvbiIsImRvbU5vZGUiLCJtYXhTdHlsZSIsInBlcmNlbnRhZ2VQcm9wZXJ0eSIsImRlZmF1bHRWaWV3IiwiX2dldFBhcmVudE5vZGUiLCJjb25zdHJhaW5lZE5vZGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiY29uc3RyYWluZWRDb250YWluZXIiLCJoYXNDTm9kZSIsImhhc0NDb250YWluZXIiLCJpbmZpbml0eSIsImdldENvbnN0cmFpbnRXaWR0aCIsImdldENvbnN0cmFpbnRIZWlnaHQiLCJfY2FsY3VsYXRlUGFkZGluZyIsInBhcmVudERpbWVuc2lvbiIsImN3IiwiY2xpZW50SGVpZ2h0IiwiY2giLCJjdXJyZW50U3R5bGUiLCJmb3JjZVJhdGlvIiwicGl4ZWxSYXRpbyIsInBpeGVsU2l6ZSIsImxvbmdlc3RUZXh0IiwiYXJyYXlPZlRoaW5ncyIsImdjIiwiZ2FyYmFnZUNvbGxlY3QiLCJsb25nZXN0IiwidGhpbmciLCJuZXN0ZWRUaGluZyIsImdjTGVuIiwidGV4dFdpZHRoIiwibnVtYmVyT2ZMYWJlbExpbmVzIiwibnVtYmVyT2ZMaW5lcyIsIkNhbnZhc0dyYWRpZW50IiwiY29sb3JWYWx1ZSIsIkNhbnZhc1BhdHRlcm4iLCJhYnN0cmFjdCIsIkRhdGVBZGFwdGVyIiwiZm9ybWF0cyIsInBhcnNlIiwiZm9ybWF0Iiwic3RhcnRPZiIsImVuZE9mIiwiX2NyZWF0ZSIsIm92ZXJyaWRlIiwibWVtYmVycyIsIl9kYXRlIiwiY29yZV9hZGFwdGVycyIsImNvcmVfdGlja3MiLCJmb3JtYXR0ZXJzIiwidGlja1ZhbHVlIiwibG9nRGVsdGEiLCJ0aWNrU3RyaW5nIiwibWF4VGljayIsImxvZ1RpY2siLCJudW1FeHBvbmVudGlhbCIsInRvRXhwb25lbnRpYWwiLCJudW1EZWNpbWFsIiwidG9GaXhlZCIsImxvZ2FyaXRobWljIiwicmVtYWluIiwidmFsdWVPckRlZmF1bHQkYSIsImRyYXdPbkNoYXJ0QXJlYSIsImRyYXdUaWNrcyIsInRpY2tNYXJrTGVuZ3RoIiwiemVyb0xpbmVXaWR0aCIsInplcm9MaW5lQ29sb3IiLCJ6ZXJvTGluZUJvcmRlckRhc2giLCJ6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQiLCJzY2FsZUxhYmVsIiwibGFiZWxTdHJpbmciLCJtaW5Sb3RhdGlvbiIsIm1heFJvdGF0aW9uIiwibWlycm9yIiwiYXV0b1NraXAiLCJhdXRvU2tpcFBhZGRpbmciLCJsYWJlbE9mZnNldCIsIm1pbm9yIiwibWFqb3IiLCJzYW1wbGUiLCJhcnIiLCJudW1JdGVtcyIsImluY3JlbWVudCIsImdldFBpeGVsRm9yR3JpZExpbmUiLCJ2YWxpZEluZGV4IiwibGluZVZhbHVlIiwiY2FjaGVzIiwiY29tcHV0ZUxhYmVsU2l6ZXMiLCJ0aWNrRm9udHMiLCJ3aWR0aHMiLCJoZWlnaHRzIiwib2Zmc2V0cyIsInRpY2tGb250IiwibmVzdGVkTGFiZWwiLCJ3aWRlc3QiLCJoaWdoZXN0IiwidmFsdWVBdCIsImZpcnN0IiwiZ2V0VGlja01hcmtMZW5ndGgiLCJnZXRTY2FsZUxhYmVsSGVpZ2h0IiwicGFyc2VGb250T3B0aW9ucyIsIm5lc3RlZE9wdHMiLCJmb250Q29sb3IiLCJwYXJzZVRpY2tGb250T3B0aW9ucyIsIm5vblNraXBwZWQiLCJ0aWNrc1RvRmlsdGVyIiwiZ2V0RXZlblNwYWNpbmciLCJjYWxjdWxhdGVTcGFjaW5nIiwibWFqb3JJbmRpY2VzIiwiYXhpc0xlbmd0aCIsInRpY2tzTGltaXQiLCJldmVuTWFqb3JTcGFjaW5nIiwic3BhY2luZyIsImZhY3RvcnMiLCJmYWN0b3IiLCJnZXRNYWpvckluZGljZXMiLCJza2lwTWFqb3JzIiwidGljayIsImNlaWwiLCJtYWpvclN0YXJ0IiwibWFqb3JFbmQiLCJTY2FsZSIsInplcm9MaW5lSW5kZXgiLCJfdGlja3MiLCJfZ2V0TGFiZWxzIiwieExhYmVscyIsInlMYWJlbHMiLCJiZWZvcmVVcGRhdGUiLCJtYXJnaW5zIiwic2FtcGxlU2l6ZSIsInNhbXBsaW5nRW5hYmxlZCIsIl9sYWJlbFNpemVzIiwiX21heExhYmVsTGluZXMiLCJsb25nZXN0TGFiZWxXaWR0aCIsImxvbmdlc3RUZXh0Q2FjaGUiLCJfZ3JpZExpbmVJdGVtcyIsIl9sYWJlbEl0ZW1zIiwiYmVmb3JlU2V0RGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJhZnRlclNldERpbWVuc2lvbnMiLCJiZWZvcmVEYXRhTGltaXRzIiwiZGV0ZXJtaW5lRGF0YUxpbWl0cyIsImFmdGVyRGF0YUxpbWl0cyIsImJlZm9yZUJ1aWxkVGlja3MiLCJidWlsZFRpY2tzIiwiYWZ0ZXJCdWlsZFRpY2tzIiwiX2NvbnZlcnRUaWNrc1RvTGFiZWxzIiwiYmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uIiwiY2FsY3VsYXRlVGlja1JvdGF0aW9uIiwiYWZ0ZXJDYWxjdWxhdGVUaWNrUm90YXRpb24iLCJiZWZvcmVGaXQiLCJmaXQiLCJhZnRlckZpdCIsIl90aWNrc1RvRHJhdyIsIl9hdXRvU2tpcCIsImFmdGVyVXBkYXRlIiwicmV2ZXJzZVBpeGVscyIsInN0YXJ0UGl4ZWwiLCJlbmRQaXhlbCIsIl9yZXZlcnNlUGl4ZWxzIiwiYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uIiwiY29udmVydFRpY2tzVG9MYWJlbHMiLCJ1c2VyQ2FsbGJhY2siLCJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsIm51bVRpY2tzIiwibGFiZWxSb3RhdGlvbiIsImxhYmVsU2l6ZXMiLCJtYXhMYWJlbFdpZHRoIiwibWF4TGFiZWxIZWlnaHQiLCJ0aWNrV2lkdGgiLCJtYXhMYWJlbERpYWdvbmFsIiwiX2lzVmlzaWJsZSIsIl9nZXRMYWJlbFNpemVzIiwic2NhbGVMYWJlbE9wdHMiLCJncmlkTGluZU9wdHMiLCJpc0JvdHRvbSIsImZpcnN0TGFiZWxTaXplIiwibGFzdExhYmVsU2l6ZSIsIndpZGVzdExhYmVsU2l6ZSIsImhpZ2hlc3RMYWJlbFNpemUiLCJsaW5lU3BhY2UiLCJ0aWNrUGFkZGluZyIsImlzUm90YXRlZCIsImFuZ2xlUmFkaWFucyIsImNvc1JvdGF0aW9uIiwic2luUm90YXRpb24iLCJsYWJlbEhlaWdodCIsIm9mZnNldExlZnQiLCJvZmZzZXRSaWdodCIsImxhYmVsV2lkdGgiLCJoYW5kbGVNYXJnaW5zIiwiaXNGdWxsV2lkdGgiLCJyYXdWYWx1ZSIsIl9nZXRTY2FsZUxhYmVsIiwiZ2V0VmFsdWVGb3JQaXhlbCIsImRlY2ltYWwiLCJnZXREZWNpbWFsRm9yUGl4ZWwiLCJnZXRCYXNlVmFsdWUiLCJtYXhUaWNrc0xpbWl0IiwiX3RpY2tTaXplIiwibnVtTWFqb3JJbmRpY2VzIiwiYXZnTWFqb3JTcGFjaW5nIiwib3B0aW9uVGlja3MiLCJyb3QiLCJfY29tcHV0ZUdyaWRMaW5lSXRlbXMiLCJ0aWNrc0xlbmd0aCIsInRsIiwiYXhpc1dpZHRoIiwiYXhpc0hhbGZXaWR0aCIsImFsaWduUGl4ZWwiLCJhbGlnbkJvcmRlclZhbHVlIiwiYm9yZGVyVmFsdWUiLCJhbGlnbmVkTGluZVZhbHVlIiwidHgxIiwidHkxIiwidHgyIiwidHkyIiwibGluZUNvbG9yIiwiX2NvbXB1dGVMYWJlbEl0ZW1zIiwiaXNNaXJyb3JlZCIsImZvbnRzIiwibGluZUNvdW50IiwidGV4dE9mZnNldCIsIl9kcmF3R3JpZCIsImZpcnN0TGluZVdpZHRoIiwibGFzdExpbmVXaWR0aCIsIl9kcmF3TGFiZWxzIiwiX2RyYXdUaXRsZSIsInNjYWxlTGFiZWxGb250Q29sb3IiLCJzY2FsZUxhYmVsRm9udCIsInNjYWxlTGFiZWxQYWRkaW5nIiwiaGFsZkxpbmVIZWlnaHQiLCJzY2FsZUxhYmVsWCIsInNjYWxlTGFiZWxZIiwiaXNMZWZ0IiwidHoiLCJneiIsIl9kcmF3IiwiY29yZV9zY2FsZSIsImlzTnVsbE9yVW5kZWYkMSIsImRlZmF1bHRDb25maWciLCJzY2FsZV9jYXRlZ29yeSIsInRpY2tzT3B0cyIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJfc3RhcnRWYWx1ZSIsIl92YWx1ZVJhbmdlIiwidmFsdWVDYXRlZ29yeSIsIl9kZWZhdWx0cyIsImlzTnVsbE9yVW5kZWYkMiIsImdlbmVyYXRlVGlja3MiLCJnZW5lcmF0aW9uT3B0aW9ucyIsImRhdGFSYW5nZSIsIk1JTl9TUEFDSU5HIiwic3RlcFNpemUiLCJ1bml0IiwibWF4TnVtU3BhY2VzIiwibWF4VGlja3MiLCJwcmVjaXNpb24iLCJybWluIiwicm1heCIsIm5pY2VNaW4iLCJuaWNlTWF4IiwibnVtU3BhY2VzIiwic2NhbGVfbGluZWFyYmFzZSIsImhhbmRsZVRpY2tSYW5nZU9wdGlvbnMiLCJtaW5TaWduIiwibWF4U2lnbiIsInNldE1pbiIsInN1Z2dlc3RlZE1pbiIsInNldE1heCIsInN1Z2dlc3RlZE1heCIsImdldFRpY2tMaW1pdCIsIl9jb21wdXRlVGlja0xpbWl0IiwiaGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzIiwibnVtZXJpY0dlbmVyYXRvck9wdGlvbnMiLCJmaXhlZFN0ZXBTaXplIiwidGlja3NBc051bWJlcnMiLCJfZW5kVmFsdWUiLCJkZWZhdWx0Q29uZmlnJDEiLCJERUZBVUxUX01JTiIsIkRFRkFVTFRfTUFYIiwiZ2V0T3JDcmVhdGVTdGFjayIsIm5lZyIsInN0YWNrRGF0YSIsInJlbGF0aXZlUG9pbnRzIiwidXBkYXRlTWluTWF4Iiwic2NhbGVfbGluZWFyIiwiaGFzU3RhY2tzIiwic3RhY2tWYWx1ZXMiLCJfZGVmYXVsdHMkMSIsInZhbHVlT3JEZWZhdWx0JGIiLCJnZW5lcmF0ZVRpY2tzJDEiLCJ0aWNrVmFsIiwiZW5kRXhwIiwiZW5kU2lnbmlmaWNhbmQiLCJleHAiLCJzaWduaWZpY2FuZCIsIm1pbk5vdFplcm8iLCJsYXN0VGljayIsImRlZmF1bHRDb25maWckMiIsIm5vbk5lZ2F0aXZlT3JEZWZhdWx0Iiwic2NhbGVfbG9nYXJpdGhtaWMiLCJJRE1hdGNoZXMiLCJ2YWx1ZXNQZXJTdGFjayIsInZhbHVlc0ZvclR5cGUiLCJtaW5WYWwiLCJtYXhWYWwiLCJ0aWNrVmFsdWVzIiwiX2dldEZpcnN0VGlja1ZhbHVlIiwiX3ZhbHVlT2Zmc2V0IiwiX2RlZmF1bHRzJDIiLCJ2YWx1ZU9yRGVmYXVsdCRjIiwidmFsdWVBdEluZGV4T3JEZWZhdWx0JDEiLCJyZXNvbHZlJDQiLCJkZWZhdWx0Q29uZmlnJDMiLCJhbmltYXRlIiwic2hvd0xhYmVsQmFja2Ryb3AiLCJiYWNrZHJvcENvbG9yIiwiYmFja2Ryb3BQYWRkaW5nWSIsImJhY2tkcm9wUGFkZGluZ1giLCJnZXRUaWNrQmFja2Ryb3BIZWlnaHQiLCJtZWFzdXJlTGFiZWxTaXplIiwiZGV0ZXJtaW5lTGltaXRzIiwiZml0V2l0aFBvaW50TGFiZWxzIiwicGxGb250IiwiZnVydGhlc3RMaW1pdHMiLCJmdXJ0aGVzdEFuZ2xlcyIsInRleHRTaXplIiwiX3BvaW50TGFiZWxTaXplcyIsInZhbHVlQ291bnQiLCJnZXRQb2ludFBvc2l0aW9uIiwiZHJhd2luZ0FyZWEiLCJnZXRJbmRleEFuZ2xlIiwiaExpbWl0cyIsInZMaW1pdHMiLCJzZXRSZWR1Y3Rpb25zIiwiZ2V0VGV4dEFsaWduRm9yQW5nbGUiLCJhZGp1c3RQb2ludFBvc2l0aW9uRm9yTGFiZWxIZWlnaHQiLCJkcmF3UG9pbnRMYWJlbHMiLCJwb2ludExhYmVsT3B0cyIsInRpY2tCYWNrZHJvcEhlaWdodCIsIm91dGVyRGlzdGFuY2UiLCJleHRyYSIsInBvaW50TGFiZWxQb3NpdGlvbiIsInBvaW50TGFiZWxGb250Q29sb3IiLCJkcmF3UmFkaXVzTGluZSIsIm51bWJlck9yWmVybyIsInBhcmFtIiwic2NhbGVfcmFkaWFsTGluZWFyIiwic2V0Q2VudGVyUG9pbnQiLCJsYXJnZXN0UG9zc2libGVSYWRpdXMiLCJyYWRpdXNSZWR1Y3Rpb25MZWZ0IiwicmFkaXVzUmVkdWN0aW9uUmlnaHQiLCJyYWRpdXNSZWR1Y3Rpb25Ub3AiLCJyYWRpdXNSZWR1Y3Rpb25Cb3R0b20iLCJsZWZ0TW92ZW1lbnQiLCJyaWdodE1vdmVtZW50IiwidG9wTW92ZW1lbnQiLCJib3R0b21Nb3ZlbWVudCIsIm1heFJpZ2h0IiwibWF4TGVmdCIsIm1heFRvcCIsIm1heEJvdHRvbSIsImFuZ2xlTXVsdGlwbGllciIsInNjYWxpbmdGYWN0b3IiLCJkaXN0YW5jZUZyb21DZW50ZXIiLCJ0aGlzQW5nbGUiLCJnZXRCYXNlUG9zaXRpb24iLCJhbmdsZUxpbmVPcHRzIiwidGlja0ZvbnRDb2xvciIsIl9kZWZhdWx0cyQzIiwiZGVwcmVjYXRlZCQxIiwicmVzb2x2ZSQ1IiwidmFsdWVPckRlZmF1bHQkZCIsIk1JTl9JTlRFR0VSIiwiTUlOX1NBRkVfSU5URUdFUiIsIk1BWF9JTlRFR0VSIiwiTUFYX1NBRkVfSU5URUdFUiIsIklOVEVSVkFMUyIsIm1pbGxpc2Vjb25kIiwiY29tbW9uIiwic3RlcHMiLCJzZWNvbmQiLCJtaW51dGUiLCJob3VyIiwiZGF5Iiwid2VlayIsIm1vbnRoIiwicXVhcnRlciIsInllYXIiLCJVTklUUyIsInNvcnRlciIsImFycmF5VW5pcXVlIiwiaGFzaCIsIm91dCIsImdldE1pbiIsInRpbWUiLCJnZXRNYXgiLCJidWlsZExvb2t1cFRhYmxlIiwidGltZXN0YW1wcyIsImRpc3RyaWJ1dGlvbiIsInRhYmxlIiwibG9va3VwIiwibG8iLCJtaWQiLCJpMCIsImkxIiwiaW50ZXJwb2xhdGUkMSIsInNrZXkiLCJ0a2V5Iiwic3BhbiIsInRvVGltZXN0YW1wIiwiaW5wdXQiLCJhZGFwdGVyIiwiX2FkYXB0ZXIiLCJwYXJzZXIiLCJkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzIiwibWluVW5pdCIsImNhcGFjaXR5IiwiaW50ZXJ2YWwiLCJkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyIsImRldGVybWluZU1ham9yVW5pdCIsImdlbmVyYXRlIiwidGltZU9wdHMiLCJ1bml0U3RlcFNpemUiLCJ3ZWVrZGF5IiwiaXNvV2Vla2RheSIsImNvbXB1dGVPZmZzZXRzIiwic2V0TWFqb3JUaWNrcyIsIm1ham9yVW5pdCIsInRpY2tzRnJvbVRpbWVzdGFtcHMiLCJkZWZhdWx0Q29uZmlnJDQiLCJhZGFwdGVycyIsImRpc3BsYXlGb3JtYXQiLCJkaXNwbGF5Rm9ybWF0cyIsInNjYWxlX3RpbWUiLCJkYXRlIiwidGltZXN0YW1wIiwibGFiZWxzQWRkZWQiLCJkYXRhTGFiZWxzIiwiX3RhYmxlIiwiX3RpbWVzdGFtcHMiLCJnZXRMYWJlbENhcGFjaXR5IiwiX3VuaXQiLCJfbWFqb3JVbml0IiwiX29mZnNldHMiLCJ0b29sdGlwRm9ybWF0IiwiZGF0ZXRpbWUiLCJ0aWNrRm9ybWF0RnVuY3Rpb24iLCJtaW5vckZvcm1hdCIsIm1ham9yRm9ybWF0IiwibmVzdGVkVGlja09wdHMiLCJmb3JtYXR0ZXIiLCJnZXRQaXhlbEZvck9mZnNldCIsIl9nZXRMYWJlbFNpemUiLCJ0aWNrTGFiZWxXaWR0aCIsInRpY2tGb250U2l6ZSIsImdldExhYmVsV2lkdGgiLCJleGFtcGxlVGltZSIsImV4YW1wbGVMYWJlbCIsIl9kZWZhdWx0cyQ0IiwiY2F0ZWdvcnkiLCJyYWRpYWxMaW5lYXIiLCJGT1JNQVRTIiwiX2lkIiwidmFsdWVPZiIsImFtb3VudCIsImZpbGxlciIsInByb3BhZ2F0ZSIsIm1hcHBlcnMiLCJ2aXNpYmxlIiwiYm91bmRhcnkiLCJkZWNvZGVGaWxsIiwiY29tcHV0ZUxpbmVhckJvdW5kYXJ5Iiwic2NhbGVCb3R0b20iLCJzY2FsZVRvcCIsInNjYWxlWmVybyIsImNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5IiwiY3giLCJjeSIsImNvbXB1dGVCb3VuZGFyeSIsInJlc29sdmVUYXJnZXQiLCJ2aXNpdGVkIiwiY3JlYXRlTWFwcGVyIiwiaXNEcmF3YWJsZSIsImRyYXdBcmVhIiwiY3VydmUwIiwiY3VydmUxIiwibGVuMCIsImxlbjEiLCJkb0ZpbGwiLCJtYXBwZXIiLCJwMCIsInAxIiwiZDAiLCJkMSIsImxvb3BPZmZzZXQiLCJwbHVnaW5fZmlsbGVyIiwiYWZ0ZXJEYXRhc2V0c1VwZGF0ZSIsIiRmaWxsZXIiLCJiZWZvcmVEYXRhc2V0c0RyYXciLCJnZXRSdGxIZWxwZXIkMSIsIm5vb3AkMSIsInZhbHVlT3JEZWZhdWx0JGUiLCJjaSIsIm9uTGVhdmUiLCJib3hXaWR0aCIsInVzZVBvaW50U3R5bGUiLCJsaW5lRGFzaCIsImdldEJveFdpZHRoIiwibGFiZWxPcHRzIiwiTGVnZW5kIiwibGVnZW5kSGl0Qm94ZXMiLCJfaG92ZXJlZEl0ZW0iLCJkb3VnaG51dE1vZGUiLCJiZWZvcmVCdWlsZExhYmVscyIsImJ1aWxkTGFiZWxzIiwiYWZ0ZXJCdWlsZExhYmVscyIsImxlZ2VuZEl0ZW1zIiwibGFiZWxGb250IiwiaGl0Ym94ZXMiLCJsaW5lV2lkdGhzIiwidG90YWxIZWlnaHQiLCJ2UGFkZGluZyIsImNvbHVtbldpZHRocyIsImNvbHVtbkhlaWdodHMiLCJ0b3RhbFdpZHRoIiwiY3VycmVudENvbFdpZHRoIiwiY3VycmVudENvbEhlaWdodCIsImxpbmVEZWZhdWx0IiwibGVnZW5kSGVpZ2h0IiwibGVnZW5kV2lkdGgiLCJjdXJzb3IiLCJkcmF3TGVnZW5kQm94IiwiU1FSVDIiLCJoYWxmRm9udFNpemUiLCJ4TGVmdCIsInlNaWRkbGUiLCJhbGlnbm1lbnRPZmZzZXQiLCJkaW1lbnNpb24iLCJibG9ja1NpemUiLCJpdGVtSGVpZ2h0IiwicmVhbFgiLCJfZ2V0TGVnZW5kSXRlbUF0IiwiaGl0Qm94IiwibGgiLCJob3ZlcmVkSXRlbSIsImNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaCIsImxlZ2VuZE9wdHMiLCJwbHVnaW5fbGVnZW5kIiwiX2VsZW1lbnQiLCJiZWZvcmVJbml0IiwiYWZ0ZXJFdmVudCIsIm5vb3AkMiIsIlRpdGxlIiwiZm9udE9wdHMiLCJ0aXRsZVgiLCJ0aXRsZVkiLCJjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoIiwidGl0bGVPcHRzIiwidGl0bGVCbG9jayIsInBsdWdpbl90aXRsZSIsIl9hZGFwdGVycyIsIkFuaW1hdGlvbiIsImFuaW1hdGlvblNlcnZpY2UiLCJJbnRlcmFjdGlvbiIsInNjYWxlU2VydmljZSIsIlRpY2tzIiwiVG9vbHRpcCIsInBsdWdpblNlcnZpY2UiLCJQbHVnaW5CYXNlIiwiY2FudmFzSGVscGVycyIsImxheW91dFNlcnZpY2UiLCJMaW5lYXJTY2FsZUJhc2UiLCJrbGFzcyIsImNmZyIsInRvTG93ZXJDYXNlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDZmxwQixtQkFBZSxDQUFDa3BCLEtBQUQsQ0FBZixHQUF5QixVQUFTenBELEdBQVQsRUFBYzBwRCxHQUFkLEVBQW1CO0FBQzNDLGFBQU8sSUFBSW5wQixlQUFKLENBQW9CdmdDLEdBQXBCLEVBQXlCdWdDLGVBQWUsQ0FBQzVtQyxPQUFoQixDQUF3QjhCLEtBQXhCLENBQThCaXVELEdBQUcsSUFBSSxFQUFyQyxFQUF5QztBQUN4RS93RCxZQUFJLEVBQUU4d0QsS0FBSyxDQUFDdHdELE1BQU4sQ0FBYSxDQUFiLEVBQWdCd3dELFdBQWhCLEtBQWdDRixLQUFLLENBQUNwM0QsS0FBTixDQUFZLENBQVo7QUFEa0MsT0FBekMsQ0FBekIsQ0FBUDtBQUdBLEtBSkQ7QUFLQSxHQWhCRjtBQW1CQSxTQUFPNEosR0FBUDtBQUVDLENBaHhmQSxDQUFEIiwiZmlsZSI6IjE2NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ2hhcnQuanMgdjIuOS4zXG4gKiBodHRwczovL3d3dy5jaGFydGpzLm9yZ1xuICogKGMpIDIwMTkgQ2hhcnQuanMgQ29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShmdW5jdGlvbigpIHsgdHJ5IHsgcmV0dXJuIHJlcXVpcmUoJ21vbWVudCcpOyB9IGNhdGNoKGUpIHsgfSB9KCkpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ3JlcXVpcmUnXSwgZnVuY3Rpb24ocmVxdWlyZSkgeyByZXR1cm4gZmFjdG9yeShmdW5jdGlvbigpIHsgdHJ5IHsgcmV0dXJuIHJlcXVpcmUoJ21vbWVudCcpOyB9IGNhdGNoKGUpIHsgfSB9KCkpOyB9KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5DaGFydCA9IGZhY3RvcnkoZ2xvYmFsLm1vbWVudCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cbm1vbWVudCA9IG1vbWVudCAmJiBtb21lbnQuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSA/IG1vbWVudFsnZGVmYXVsdCddIDogbW9tZW50O1xuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxuZnVuY3Rpb24gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZSAobikge1xuXHRyZXR1cm4gbiAmJiBuWydkZWZhdWx0J10gfHwgbjtcbn1cblxudmFyIGNvbG9yTmFtZSA9IHtcclxuXHRcImFsaWNlYmx1ZVwiOiBbMjQwLCAyNDgsIDI1NV0sXHJcblx0XCJhbnRpcXVld2hpdGVcIjogWzI1MCwgMjM1LCAyMTVdLFxyXG5cdFwiYXF1YVwiOiBbMCwgMjU1LCAyNTVdLFxyXG5cdFwiYXF1YW1hcmluZVwiOiBbMTI3LCAyNTUsIDIxMl0sXHJcblx0XCJhenVyZVwiOiBbMjQwLCAyNTUsIDI1NV0sXHJcblx0XCJiZWlnZVwiOiBbMjQ1LCAyNDUsIDIyMF0sXHJcblx0XCJiaXNxdWVcIjogWzI1NSwgMjI4LCAxOTZdLFxyXG5cdFwiYmxhY2tcIjogWzAsIDAsIDBdLFxyXG5cdFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwgMjM1LCAyMDVdLFxyXG5cdFwiYmx1ZVwiOiBbMCwgMCwgMjU1XSxcclxuXHRcImJsdWV2aW9sZXRcIjogWzEzOCwgNDMsIDIyNl0sXHJcblx0XCJicm93blwiOiBbMTY1LCA0MiwgNDJdLFxyXG5cdFwiYnVybHl3b29kXCI6IFsyMjIsIDE4NCwgMTM1XSxcclxuXHRcImNhZGV0Ymx1ZVwiOiBbOTUsIDE1OCwgMTYwXSxcclxuXHRcImNoYXJ0cmV1c2VcIjogWzEyNywgMjU1LCAwXSxcclxuXHRcImNob2NvbGF0ZVwiOiBbMjEwLCAxMDUsIDMwXSxcclxuXHRcImNvcmFsXCI6IFsyNTUsIDEyNywgODBdLFxyXG5cdFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwgMTQ5LCAyMzddLFxyXG5cdFwiY29ybnNpbGtcIjogWzI1NSwgMjQ4LCAyMjBdLFxyXG5cdFwiY3JpbXNvblwiOiBbMjIwLCAyMCwgNjBdLFxyXG5cdFwiY3lhblwiOiBbMCwgMjU1LCAyNTVdLFxyXG5cdFwiZGFya2JsdWVcIjogWzAsIDAsIDEzOV0sXHJcblx0XCJkYXJrY3lhblwiOiBbMCwgMTM5LCAxMzldLFxyXG5cdFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LCAxMzQsIDExXSxcclxuXHRcImRhcmtncmF5XCI6IFsxNjksIDE2OSwgMTY5XSxcclxuXHRcImRhcmtncmVlblwiOiBbMCwgMTAwLCAwXSxcclxuXHRcImRhcmtncmV5XCI6IFsxNjksIDE2OSwgMTY5XSxcclxuXHRcImRhcmtraGFraVwiOiBbMTg5LCAxODMsIDEwN10sXHJcblx0XCJkYXJrbWFnZW50YVwiOiBbMTM5LCAwLCAxMzldLFxyXG5cdFwiZGFya29saXZlZ3JlZW5cIjogWzg1LCAxMDcsIDQ3XSxcclxuXHRcImRhcmtvcmFuZ2VcIjogWzI1NSwgMTQwLCAwXSxcclxuXHRcImRhcmtvcmNoaWRcIjogWzE1MywgNTAsIDIwNF0sXHJcblx0XCJkYXJrcmVkXCI6IFsxMzksIDAsIDBdLFxyXG5cdFwiZGFya3NhbG1vblwiOiBbMjMzLCAxNTAsIDEyMl0sXHJcblx0XCJkYXJrc2VhZ3JlZW5cIjogWzE0MywgMTg4LCAxNDNdLFxyXG5cdFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsIDYxLCAxMzldLFxyXG5cdFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrc2xhdGVncmV5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmt0dXJxdW9pc2VcIjogWzAsIDIwNiwgMjA5XSxcclxuXHRcImRhcmt2aW9sZXRcIjogWzE0OCwgMCwgMjExXSxcclxuXHRcImRlZXBwaW5rXCI6IFsyNTUsIDIwLCAxNDddLFxyXG5cdFwiZGVlcHNreWJsdWVcIjogWzAsIDE5MSwgMjU1XSxcclxuXHRcImRpbWdyYXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZGltZ3JleVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkb2RnZXJibHVlXCI6IFszMCwgMTQ0LCAyNTVdLFxyXG5cdFwiZmlyZWJyaWNrXCI6IFsxNzgsIDM0LCAzNF0sXHJcblx0XCJmbG9yYWx3aGl0ZVwiOiBbMjU1LCAyNTAsIDI0MF0sXHJcblx0XCJmb3Jlc3RncmVlblwiOiBbMzQsIDEzOSwgMzRdLFxyXG5cdFwiZnVjaHNpYVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwiZ2FpbnNib3JvXCI6IFsyMjAsIDIyMCwgMjIwXSxcclxuXHRcImdob3N0d2hpdGVcIjogWzI0OCwgMjQ4LCAyNTVdLFxyXG5cdFwiZ29sZFwiOiBbMjU1LCAyMTUsIDBdLFxyXG5cdFwiZ29sZGVucm9kXCI6IFsyMTgsIDE2NSwgMzJdLFxyXG5cdFwiZ3JheVwiOiBbMTI4LCAxMjgsIDEyOF0sXHJcblx0XCJncmVlblwiOiBbMCwgMTI4LCAwXSxcclxuXHRcImdyZWVueWVsbG93XCI6IFsxNzMsIDI1NSwgNDddLFxyXG5cdFwiZ3JleVwiOiBbMTI4LCAxMjgsIDEyOF0sXHJcblx0XCJob25leWRld1wiOiBbMjQwLCAyNTUsIDI0MF0sXHJcblx0XCJob3RwaW5rXCI6IFsyNTUsIDEwNSwgMTgwXSxcclxuXHRcImluZGlhbnJlZFwiOiBbMjA1LCA5MiwgOTJdLFxyXG5cdFwiaW5kaWdvXCI6IFs3NSwgMCwgMTMwXSxcclxuXHRcIml2b3J5XCI6IFsyNTUsIDI1NSwgMjQwXSxcclxuXHRcImtoYWtpXCI6IFsyNDAsIDIzMCwgMTQwXSxcclxuXHRcImxhdmVuZGVyXCI6IFsyMzAsIDIzMCwgMjUwXSxcclxuXHRcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwgMjQwLCAyNDVdLFxyXG5cdFwibGF3bmdyZWVuXCI6IFsxMjQsIDI1MiwgMF0sXHJcblx0XCJsZW1vbmNoaWZmb25cIjogWzI1NSwgMjUwLCAyMDVdLFxyXG5cdFwibGlnaHRibHVlXCI6IFsxNzMsIDIxNiwgMjMwXSxcclxuXHRcImxpZ2h0Y29yYWxcIjogWzI0MCwgMTI4LCAxMjhdLFxyXG5cdFwibGlnaHRjeWFuXCI6IFsyMjQsIDI1NSwgMjU1XSxcclxuXHRcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsIDI1MCwgMjEwXSxcclxuXHRcImxpZ2h0Z3JheVwiOiBbMjExLCAyMTEsIDIxMV0sXHJcblx0XCJsaWdodGdyZWVuXCI6IFsxNDQsIDIzOCwgMTQ0XSxcclxuXHRcImxpZ2h0Z3JleVwiOiBbMjExLCAyMTEsIDIxMV0sXHJcblx0XCJsaWdodHBpbmtcIjogWzI1NSwgMTgyLCAxOTNdLFxyXG5cdFwibGlnaHRzYWxtb25cIjogWzI1NSwgMTYwLCAxMjJdLFxyXG5cdFwibGlnaHRzZWFncmVlblwiOiBbMzIsIDE3OCwgMTcwXSxcclxuXHRcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDI1MF0sXHJcblx0XCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LCAxMzYsIDE1M10sXHJcblx0XCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LCAxMzYsIDE1M10sXHJcblx0XCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LCAxOTYsIDIyMl0sXHJcblx0XCJsaWdodHllbGxvd1wiOiBbMjU1LCAyNTUsIDIyNF0sXHJcblx0XCJsaW1lXCI6IFswLCAyNTUsIDBdLFxyXG5cdFwibGltZWdyZWVuXCI6IFs1MCwgMjA1LCA1MF0sXHJcblx0XCJsaW5lblwiOiBbMjUwLCAyNDAsIDIzMF0sXHJcblx0XCJtYWdlbnRhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJtYXJvb25cIjogWzEyOCwgMCwgMF0sXHJcblx0XCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsIDIwNSwgMTcwXSxcclxuXHRcIm1lZGl1bWJsdWVcIjogWzAsIDAsIDIwNV0sXHJcblx0XCJtZWRpdW1vcmNoaWRcIjogWzE4NiwgODUsIDIxMV0sXHJcblx0XCJtZWRpdW1wdXJwbGVcIjogWzE0NywgMTEyLCAyMTldLFxyXG5cdFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLCAxNzksIDExM10sXHJcblx0XCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMywgMTA0LCAyMzhdLFxyXG5cdFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsIDI1MCwgMTU0XSxcclxuXHRcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsIDIwOSwgMjA0XSxcclxuXHRcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5LCAyMSwgMTMzXSxcclxuXHRcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsIDI1LCAxMTJdLFxyXG5cdFwibWludGNyZWFtXCI6IFsyNDUsIDI1NSwgMjUwXSxcclxuXHRcIm1pc3R5cm9zZVwiOiBbMjU1LCAyMjgsIDIyNV0sXHJcblx0XCJtb2NjYXNpblwiOiBbMjU1LCAyMjgsIDE4MV0sXHJcblx0XCJuYXZham93aGl0ZVwiOiBbMjU1LCAyMjIsIDE3M10sXHJcblx0XCJuYXZ5XCI6IFswLCAwLCAxMjhdLFxyXG5cdFwib2xkbGFjZVwiOiBbMjUzLCAyNDUsIDIzMF0sXHJcblx0XCJvbGl2ZVwiOiBbMTI4LCAxMjgsIDBdLFxyXG5cdFwib2xpdmVkcmFiXCI6IFsxMDcsIDE0MiwgMzVdLFxyXG5cdFwib3JhbmdlXCI6IFsyNTUsIDE2NSwgMF0sXHJcblx0XCJvcmFuZ2VyZWRcIjogWzI1NSwgNjksIDBdLFxyXG5cdFwib3JjaGlkXCI6IFsyMTgsIDExMiwgMjE0XSxcclxuXHRcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwgMjMyLCAxNzBdLFxyXG5cdFwicGFsZWdyZWVuXCI6IFsxNTIsIDI1MSwgMTUyXSxcclxuXHRcInBhbGV0dXJxdW9pc2VcIjogWzE3NSwgMjM4LCAyMzhdLFxyXG5cdFwicGFsZXZpb2xldHJlZFwiOiBbMjE5LCAxMTIsIDE0N10sXHJcblx0XCJwYXBheWF3aGlwXCI6IFsyNTUsIDIzOSwgMjEzXSxcclxuXHRcInBlYWNocHVmZlwiOiBbMjU1LCAyMTgsIDE4NV0sXHJcblx0XCJwZXJ1XCI6IFsyMDUsIDEzMywgNjNdLFxyXG5cdFwicGlua1wiOiBbMjU1LCAxOTIsIDIwM10sXHJcblx0XCJwbHVtXCI6IFsyMjEsIDE2MCwgMjIxXSxcclxuXHRcInBvd2RlcmJsdWVcIjogWzE3NiwgMjI0LCAyMzBdLFxyXG5cdFwicHVycGxlXCI6IFsxMjgsIDAsIDEyOF0sXHJcblx0XCJyZWJlY2NhcHVycGxlXCI6IFsxMDIsIDUxLCAxNTNdLFxyXG5cdFwicmVkXCI6IFsyNTUsIDAsIDBdLFxyXG5cdFwicm9zeWJyb3duXCI6IFsxODgsIDE0MywgMTQzXSxcclxuXHRcInJveWFsYmx1ZVwiOiBbNjUsIDEwNSwgMjI1XSxcclxuXHRcInNhZGRsZWJyb3duXCI6IFsxMzksIDY5LCAxOV0sXHJcblx0XCJzYWxtb25cIjogWzI1MCwgMTI4LCAxMTRdLFxyXG5cdFwic2FuZHlicm93blwiOiBbMjQ0LCAxNjQsIDk2XSxcclxuXHRcInNlYWdyZWVuXCI6IFs0NiwgMTM5LCA4N10sXHJcblx0XCJzZWFzaGVsbFwiOiBbMjU1LCAyNDUsIDIzOF0sXHJcblx0XCJzaWVubmFcIjogWzE2MCwgODIsIDQ1XSxcclxuXHRcInNpbHZlclwiOiBbMTkyLCAxOTIsIDE5Ml0sXHJcblx0XCJza3libHVlXCI6IFsxMzUsIDIwNiwgMjM1XSxcclxuXHRcInNsYXRlYmx1ZVwiOiBbMTA2LCA5MCwgMjA1XSxcclxuXHRcInNsYXRlZ3JheVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbGF0ZWdyZXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic25vd1wiOiBbMjU1LCAyNTAsIDI1MF0sXHJcblx0XCJzcHJpbmdncmVlblwiOiBbMCwgMjU1LCAxMjddLFxyXG5cdFwic3RlZWxibHVlXCI6IFs3MCwgMTMwLCAxODBdLFxyXG5cdFwidGFuXCI6IFsyMTAsIDE4MCwgMTQwXSxcclxuXHRcInRlYWxcIjogWzAsIDEyOCwgMTI4XSxcclxuXHRcInRoaXN0bGVcIjogWzIxNiwgMTkxLCAyMTZdLFxyXG5cdFwidG9tYXRvXCI6IFsyNTUsIDk5LCA3MV0sXHJcblx0XCJ0dXJxdW9pc2VcIjogWzY0LCAyMjQsIDIwOF0sXHJcblx0XCJ2aW9sZXRcIjogWzIzOCwgMTMwLCAyMzhdLFxyXG5cdFwid2hlYXRcIjogWzI0NSwgMjIyLCAxNzldLFxyXG5cdFwid2hpdGVcIjogWzI1NSwgMjU1LCAyNTVdLFxyXG5cdFwid2hpdGVzbW9rZVwiOiBbMjQ1LCAyNDUsIDI0NV0sXHJcblx0XCJ5ZWxsb3dcIjogWzI1NSwgMjU1LCAwXSxcclxuXHRcInllbGxvd2dyZWVuXCI6IFsxNTQsIDIwNSwgNTBdXHJcbn07XG5cbnZhciBjb252ZXJzaW9ucyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbi8qIE1JVCBsaWNlbnNlICovXG5cblxuLy8gTk9URTogY29udmVyc2lvbnMgc2hvdWxkIG9ubHkgcmV0dXJuIHByaW1pdGl2ZSB2YWx1ZXMgKGkuZS4gYXJyYXlzLCBvclxuLy8gICAgICAgdmFsdWVzIHRoYXQgZ2l2ZSBjb3JyZWN0IGB0eXBlb2ZgIHJlc3VsdHMpLlxuLy8gICAgICAgZG8gbm90IHVzZSBib3ggdmFsdWVzIHR5cGVzIChpLmUuIE51bWJlcigpLCBTdHJpbmcoKSwgZXRjLilcblxudmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuZm9yICh2YXIga2V5IGluIGNvbG9yTmFtZSkge1xuXHRpZiAoY29sb3JOYW1lLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRyZXZlcnNlS2V5d29yZHNbY29sb3JOYW1lW2tleV1dID0ga2V5O1xuXHR9XG59XG5cbnZhciBjb252ZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSB7XG5cdHJnYjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdyZ2InfSxcblx0aHNsOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2hzbCd9LFxuXHRoc3Y6IHtjaGFubmVsczogMywgbGFiZWxzOiAnaHN2J30sXG5cdGh3Yjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdod2InfSxcblx0Y215azoge2NoYW5uZWxzOiA0LCBsYWJlbHM6ICdjbXlrJ30sXG5cdHh5ejoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICd4eXonfSxcblx0bGFiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2xhYid9LFxuXHRsY2g6IHtjaGFubmVsczogMywgbGFiZWxzOiAnbGNoJ30sXG5cdGhleDoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnaGV4J119LFxuXHRrZXl3b3JkOiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydrZXl3b3JkJ119LFxuXHRhbnNpMTY6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2Fuc2kxNiddfSxcblx0YW5zaTI1Njoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnYW5zaTI1NiddfSxcblx0aGNnOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogWydoJywgJ2MnLCAnZyddfSxcblx0YXBwbGU6IHtjaGFubmVsczogMywgbGFiZWxzOiBbJ3IxNicsICdnMTYnLCAnYjE2J119LFxuXHRncmF5OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydncmF5J119XG59O1xuXG4vLyBoaWRlIC5jaGFubmVscyBhbmQgLmxhYmVscyBwcm9wZXJ0aWVzXG5mb3IgKHZhciBtb2RlbCBpbiBjb252ZXJ0KSB7XG5cdGlmIChjb252ZXJ0Lmhhc093blByb3BlcnR5KG1vZGVsKSkge1xuXHRcdGlmICghKCdjaGFubmVscycgaW4gY29udmVydFttb2RlbF0pKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhbm5lbHMgcHJvcGVydHk6ICcgKyBtb2RlbCk7XG5cdFx0fVxuXG5cdFx0aWYgKCEoJ2xhYmVscycgaW4gY29udmVydFttb2RlbF0pKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhbm5lbCBsYWJlbHMgcHJvcGVydHk6ICcgKyBtb2RlbCk7XG5cdFx0fVxuXG5cdFx0aWYgKGNvbnZlcnRbbW9kZWxdLmxhYmVscy5sZW5ndGggIT09IGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NoYW5uZWwgYW5kIGxhYmVsIGNvdW50cyBtaXNtYXRjaDogJyArIG1vZGVsKTtcblx0XHR9XG5cblx0XHR2YXIgY2hhbm5lbHMgPSBjb252ZXJ0W21vZGVsXS5jaGFubmVscztcblx0XHR2YXIgbGFiZWxzID0gY29udmVydFttb2RlbF0ubGFiZWxzO1xuXHRcdGRlbGV0ZSBjb252ZXJ0W21vZGVsXS5jaGFubmVscztcblx0XHRkZWxldGUgY29udmVydFttb2RlbF0ubGFiZWxzO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W21vZGVsXSwgJ2NoYW5uZWxzJywge3ZhbHVlOiBjaGFubmVsc30pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W21vZGVsXSwgJ2xhYmVscycsIHt2YWx1ZTogbGFiZWxzfSk7XG5cdH1cbn1cblxuY29udmVydC5yZ2IuaHNsID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXSAvIDI1NTtcblx0dmFyIGcgPSByZ2JbMV0gLyAyNTU7XG5cdHZhciBiID0gcmdiWzJdIC8gMjU1O1xuXHR2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG5cdHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcblx0dmFyIGRlbHRhID0gbWF4IC0gbWluO1xuXHR2YXIgaDtcblx0dmFyIHM7XG5cdHZhciBsO1xuXG5cdGlmIChtYXggPT09IG1pbikge1xuXHRcdGggPSAwO1xuXHR9IGVsc2UgaWYgKHIgPT09IG1heCkge1xuXHRcdGggPSAoZyAtIGIpIC8gZGVsdGE7XG5cdH0gZWxzZSBpZiAoZyA9PT0gbWF4KSB7XG5cdFx0aCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG5cdH0gZWxzZSBpZiAoYiA9PT0gbWF4KSB7XG5cdFx0aCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG5cdH1cblxuXHRoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG5cdGlmIChoIDwgMCkge1xuXHRcdGggKz0gMzYwO1xuXHR9XG5cblx0bCA9IChtaW4gKyBtYXgpIC8gMjtcblxuXHRpZiAobWF4ID09PSBtaW4pIHtcblx0XHRzID0gMDtcblx0fSBlbHNlIGlmIChsIDw9IDAuNSkge1xuXHRcdHMgPSBkZWx0YSAvIChtYXggKyBtaW4pO1xuXHR9IGVsc2Uge1xuXHRcdHMgPSBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblx0fVxuXG5cdHJldHVybiBbaCwgcyAqIDEwMCwgbCAqIDEwMF07XG59O1xuXG5jb252ZXJ0LnJnYi5oc3YgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByZGlmO1xuXHR2YXIgZ2RpZjtcblx0dmFyIGJkaWY7XG5cdHZhciBoO1xuXHR2YXIgcztcblxuXHR2YXIgciA9IHJnYlswXSAvIDI1NTtcblx0dmFyIGcgPSByZ2JbMV0gLyAyNTU7XG5cdHZhciBiID0gcmdiWzJdIC8gMjU1O1xuXHR2YXIgdiA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHR2YXIgZGlmZiA9IHYgLSBNYXRoLm1pbihyLCBnLCBiKTtcblx0dmFyIGRpZmZjID0gZnVuY3Rpb24gKGMpIHtcblx0XHRyZXR1cm4gKHYgLSBjKSAvIDYgLyBkaWZmICsgMSAvIDI7XG5cdH07XG5cblx0aWYgKGRpZmYgPT09IDApIHtcblx0XHRoID0gcyA9IDA7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IGRpZmYgLyB2O1xuXHRcdHJkaWYgPSBkaWZmYyhyKTtcblx0XHRnZGlmID0gZGlmZmMoZyk7XG5cdFx0YmRpZiA9IGRpZmZjKGIpO1xuXG5cdFx0aWYgKHIgPT09IHYpIHtcblx0XHRcdGggPSBiZGlmIC0gZ2RpZjtcblx0XHR9IGVsc2UgaWYgKGcgPT09IHYpIHtcblx0XHRcdGggPSAoMSAvIDMpICsgcmRpZiAtIGJkaWY7XG5cdFx0fSBlbHNlIGlmIChiID09PSB2KSB7XG5cdFx0XHRoID0gKDIgLyAzKSArIGdkaWYgLSByZGlmO1xuXHRcdH1cblx0XHRpZiAoaCA8IDApIHtcblx0XHRcdGggKz0gMTtcblx0XHR9IGVsc2UgaWYgKGggPiAxKSB7XG5cdFx0XHRoIC09IDE7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFtcblx0XHRoICogMzYwLFxuXHRcdHMgKiAxMDAsXG5cdFx0diAqIDEwMFxuXHRdO1xufTtcblxuY29udmVydC5yZ2IuaHdiID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXTtcblx0dmFyIGcgPSByZ2JbMV07XG5cdHZhciBiID0gcmdiWzJdO1xuXHR2YXIgaCA9IGNvbnZlcnQucmdiLmhzbChyZ2IpWzBdO1xuXHR2YXIgdyA9IDEgLyAyNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSk7XG5cblx0YiA9IDEgLSAxIC8gMjU1ICogTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuXG5cdHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LnJnYi5jbXlrID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXSAvIDI1NTtcblx0dmFyIGcgPSByZ2JbMV0gLyAyNTU7XG5cdHZhciBiID0gcmdiWzJdIC8gMjU1O1xuXHR2YXIgYztcblx0dmFyIG07XG5cdHZhciB5O1xuXHR2YXIgaztcblxuXHRrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG5cdGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaykgfHwgMDtcblx0bSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuXHR5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG5cblx0cmV0dXJuIFtjICogMTAwLCBtICogMTAwLCB5ICogMTAwLCBrICogMTAwXTtcbn07XG5cbi8qKlxuICogU2VlIGh0dHBzOi8vZW4ubS53aWtpcGVkaWEub3JnL3dpa2kvRXVjbGlkZWFuX2Rpc3RhbmNlI1NxdWFyZWRfRXVjbGlkZWFuX2Rpc3RhbmNlXG4gKiAqL1xuZnVuY3Rpb24gY29tcGFyYXRpdmVEaXN0YW5jZSh4LCB5KSB7XG5cdHJldHVybiAoXG5cdFx0TWF0aC5wb3coeFswXSAtIHlbMF0sIDIpICtcblx0XHRNYXRoLnBvdyh4WzFdIC0geVsxXSwgMikgK1xuXHRcdE1hdGgucG93KHhbMl0gLSB5WzJdLCAyKVxuXHQpO1xufVxuXG5jb252ZXJ0LnJnYi5rZXl3b3JkID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgcmV2ZXJzZWQgPSByZXZlcnNlS2V5d29yZHNbcmdiXTtcblx0aWYgKHJldmVyc2VkKSB7XG5cdFx0cmV0dXJuIHJldmVyc2VkO1xuXHR9XG5cblx0dmFyIGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcblx0dmFyIGN1cnJlbnRDbG9zZXN0S2V5d29yZDtcblxuXHRmb3IgKHZhciBrZXl3b3JkIGluIGNvbG9yTmFtZSkge1xuXHRcdGlmIChjb2xvck5hbWUuaGFzT3duUHJvcGVydHkoa2V5d29yZCkpIHtcblx0XHRcdHZhciB2YWx1ZSA9IGNvbG9yTmFtZVtrZXl3b3JkXTtcblxuXHRcdFx0Ly8gQ29tcHV0ZSBjb21wYXJhdGl2ZSBkaXN0YW5jZVxuXHRcdFx0dmFyIGRpc3RhbmNlID0gY29tcGFyYXRpdmVEaXN0YW5jZShyZ2IsIHZhbHVlKTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgaXRzIGxlc3MsIGlmIHNvIHNldCBhcyBjbG9zZXN0XG5cdFx0XHRpZiAoZGlzdGFuY2UgPCBjdXJyZW50Q2xvc2VzdERpc3RhbmNlKSB7XG5cdFx0XHRcdGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHRcdFx0Y3VycmVudENsb3Nlc3RLZXl3b3JkID0ga2V5d29yZDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY3VycmVudENsb3Nlc3RLZXl3b3JkO1xufTtcblxuY29udmVydC5rZXl3b3JkLnJnYiA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XG5cdHJldHVybiBjb2xvck5hbWVba2V5d29yZF07XG59O1xuXG5jb252ZXJ0LnJnYi54eXogPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cblx0Ly8gYXNzdW1lIHNSR0Jcblx0ciA9IHIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChyICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKHIgLyAxMi45Mik7XG5cdGcgPSBnID4gMC4wNDA0NSA/IE1hdGgucG93KCgoZyArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChnIC8gMTIuOTIpO1xuXHRiID0gYiA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoYiAvIDEyLjkyKTtcblxuXHR2YXIgeCA9IChyICogMC40MTI0KSArIChnICogMC4zNTc2KSArIChiICogMC4xODA1KTtcblx0dmFyIHkgPSAociAqIDAuMjEyNikgKyAoZyAqIDAuNzE1MikgKyAoYiAqIDAuMDcyMik7XG5cdHZhciB6ID0gKHIgKiAwLjAxOTMpICsgKGcgKiAwLjExOTIpICsgKGIgKiAwLjk1MDUpO1xuXG5cdHJldHVybiBbeCAqIDEwMCwgeSAqIDEwMCwgeiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LnJnYi5sYWIgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciB4eXogPSBjb252ZXJ0LnJnYi54eXoocmdiKTtcblx0dmFyIHggPSB4eXpbMF07XG5cdHZhciB5ID0geHl6WzFdO1xuXHR2YXIgeiA9IHh5elsyXTtcblx0dmFyIGw7XG5cdHZhciBhO1xuXHR2YXIgYjtcblxuXHR4IC89IDk1LjA0Nztcblx0eSAvPSAxMDA7XG5cdHogLz0gMTA4Ljg4MztcblxuXHR4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMSAvIDMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuXHR5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMSAvIDMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuXHR6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMSAvIDMpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG5cdGwgPSAoMTE2ICogeSkgLSAxNjtcblx0YSA9IDUwMCAqICh4IC0geSk7XG5cdGIgPSAyMDAgKiAoeSAtIHopO1xuXG5cdHJldHVybiBbbCwgYSwgYl07XG59O1xuXG5jb252ZXJ0LmhzbC5yZ2IgPSBmdW5jdGlvbiAoaHNsKSB7XG5cdHZhciBoID0gaHNsWzBdIC8gMzYwO1xuXHR2YXIgcyA9IGhzbFsxXSAvIDEwMDtcblx0dmFyIGwgPSBoc2xbMl0gLyAxMDA7XG5cdHZhciB0MTtcblx0dmFyIHQyO1xuXHR2YXIgdDM7XG5cdHZhciByZ2I7XG5cdHZhciB2YWw7XG5cblx0aWYgKHMgPT09IDApIHtcblx0XHR2YWwgPSBsICogMjU1O1xuXHRcdHJldHVybiBbdmFsLCB2YWwsIHZhbF07XG5cdH1cblxuXHRpZiAobCA8IDAuNSkge1xuXHRcdHQyID0gbCAqICgxICsgcyk7XG5cdH0gZWxzZSB7XG5cdFx0dDIgPSBsICsgcyAtIGwgKiBzO1xuXHR9XG5cblx0dDEgPSAyICogbCAtIHQyO1xuXG5cdHJnYiA9IFswLCAwLCAwXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHR0MyA9IGggKyAxIC8gMyAqIC0oaSAtIDEpO1xuXHRcdGlmICh0MyA8IDApIHtcblx0XHRcdHQzKys7XG5cdFx0fVxuXHRcdGlmICh0MyA+IDEpIHtcblx0XHRcdHQzLS07XG5cdFx0fVxuXG5cdFx0aWYgKDYgKiB0MyA8IDEpIHtcblx0XHRcdHZhbCA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzO1xuXHRcdH0gZWxzZSBpZiAoMiAqIHQzIDwgMSkge1xuXHRcdFx0dmFsID0gdDI7XG5cdFx0fSBlbHNlIGlmICgzICogdDMgPCAyKSB7XG5cdFx0XHR2YWwgPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbCA9IHQxO1xuXHRcdH1cblxuXHRcdHJnYltpXSA9IHZhbCAqIDI1NTtcblx0fVxuXG5cdHJldHVybiByZ2I7XG59O1xuXG5jb252ZXJ0LmhzbC5oc3YgPSBmdW5jdGlvbiAoaHNsKSB7XG5cdHZhciBoID0gaHNsWzBdO1xuXHR2YXIgcyA9IGhzbFsxXSAvIDEwMDtcblx0dmFyIGwgPSBoc2xbMl0gLyAxMDA7XG5cdHZhciBzbWluID0gcztcblx0dmFyIGxtaW4gPSBNYXRoLm1heChsLCAwLjAxKTtcblx0dmFyIHN2O1xuXHR2YXIgdjtcblxuXHRsICo9IDI7XG5cdHMgKj0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG5cdHNtaW4gKj0gbG1pbiA8PSAxID8gbG1pbiA6IDIgLSBsbWluO1xuXHR2ID0gKGwgKyBzKSAvIDI7XG5cdHN2ID0gbCA9PT0gMCA/ICgyICogc21pbikgLyAobG1pbiArIHNtaW4pIDogKDIgKiBzKSAvIChsICsgcyk7XG5cblx0cmV0dXJuIFtoLCBzdiAqIDEwMCwgdiAqIDEwMF07XG59O1xuXG5jb252ZXJ0Lmhzdi5yZ2IgPSBmdW5jdGlvbiAoaHN2KSB7XG5cdHZhciBoID0gaHN2WzBdIC8gNjA7XG5cdHZhciBzID0gaHN2WzFdIC8gMTAwO1xuXHR2YXIgdiA9IGhzdlsyXSAvIDEwMDtcblx0dmFyIGhpID0gTWF0aC5mbG9vcihoKSAlIDY7XG5cblx0dmFyIGYgPSBoIC0gTWF0aC5mbG9vcihoKTtcblx0dmFyIHAgPSAyNTUgKiB2ICogKDEgLSBzKTtcblx0dmFyIHEgPSAyNTUgKiB2ICogKDEgLSAocyAqIGYpKTtcblx0dmFyIHQgPSAyNTUgKiB2ICogKDEgLSAocyAqICgxIC0gZikpKTtcblx0diAqPSAyNTU7XG5cblx0c3dpdGNoIChoaSkge1xuXHRcdGNhc2UgMDpcblx0XHRcdHJldHVybiBbdiwgdCwgcF07XG5cdFx0Y2FzZSAxOlxuXHRcdFx0cmV0dXJuIFtxLCB2LCBwXTtcblx0XHRjYXNlIDI6XG5cdFx0XHRyZXR1cm4gW3AsIHYsIHRdO1xuXHRcdGNhc2UgMzpcblx0XHRcdHJldHVybiBbcCwgcSwgdl07XG5cdFx0Y2FzZSA0OlxuXHRcdFx0cmV0dXJuIFt0LCBwLCB2XTtcblx0XHRjYXNlIDU6XG5cdFx0XHRyZXR1cm4gW3YsIHAsIHFdO1xuXHR9XG59O1xuXG5jb252ZXJ0Lmhzdi5oc2wgPSBmdW5jdGlvbiAoaHN2KSB7XG5cdHZhciBoID0gaHN2WzBdO1xuXHR2YXIgcyA9IGhzdlsxXSAvIDEwMDtcblx0dmFyIHYgPSBoc3ZbMl0gLyAxMDA7XG5cdHZhciB2bWluID0gTWF0aC5tYXgodiwgMC4wMSk7XG5cdHZhciBsbWluO1xuXHR2YXIgc2w7XG5cdHZhciBsO1xuXG5cdGwgPSAoMiAtIHMpICogdjtcblx0bG1pbiA9ICgyIC0gcykgKiB2bWluO1xuXHRzbCA9IHMgKiB2bWluO1xuXHRzbCAvPSAobG1pbiA8PSAxKSA/IGxtaW4gOiAyIC0gbG1pbjtcblx0c2wgPSBzbCB8fCAwO1xuXHRsIC89IDI7XG5cblx0cmV0dXJuIFtoLCBzbCAqIDEwMCwgbCAqIDEwMF07XG59O1xuXG4vLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3MtY29sb3IvI2h3Yi10by1yZ2JcbmNvbnZlcnQuaHdiLnJnYiA9IGZ1bmN0aW9uIChod2IpIHtcblx0dmFyIGggPSBod2JbMF0gLyAzNjA7XG5cdHZhciB3aCA9IGh3YlsxXSAvIDEwMDtcblx0dmFyIGJsID0gaHdiWzJdIC8gMTAwO1xuXHR2YXIgcmF0aW8gPSB3aCArIGJsO1xuXHR2YXIgaTtcblx0dmFyIHY7XG5cdHZhciBmO1xuXHR2YXIgbjtcblxuXHQvLyB3aCArIGJsIGNhbnQgYmUgPiAxXG5cdGlmIChyYXRpbyA+IDEpIHtcblx0XHR3aCAvPSByYXRpbztcblx0XHRibCAvPSByYXRpbztcblx0fVxuXG5cdGkgPSBNYXRoLmZsb29yKDYgKiBoKTtcblx0diA9IDEgLSBibDtcblx0ZiA9IDYgKiBoIC0gaTtcblxuXHRpZiAoKGkgJiAweDAxKSAhPT0gMCkge1xuXHRcdGYgPSAxIC0gZjtcblx0fVxuXG5cdG4gPSB3aCArIGYgKiAodiAtIHdoKTsgLy8gbGluZWFyIGludGVycG9sYXRpb25cblxuXHR2YXIgcjtcblx0dmFyIGc7XG5cdHZhciBiO1xuXHRzd2l0Y2ggKGkpIHtcblx0XHRkZWZhdWx0OlxuXHRcdGNhc2UgNjpcblx0XHRjYXNlIDA6IHIgPSB2OyBnID0gbjsgYiA9IHdoOyBicmVhaztcblx0XHRjYXNlIDE6IHIgPSBuOyBnID0gdjsgYiA9IHdoOyBicmVhaztcblx0XHRjYXNlIDI6IHIgPSB3aDsgZyA9IHY7IGIgPSBuOyBicmVhaztcblx0XHRjYXNlIDM6IHIgPSB3aDsgZyA9IG47IGIgPSB2OyBicmVhaztcblx0XHRjYXNlIDQ6IHIgPSBuOyBnID0gd2g7IGIgPSB2OyBicmVhaztcblx0XHRjYXNlIDU6IHIgPSB2OyBnID0gd2g7IGIgPSBuOyBicmVhaztcblx0fVxuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuXG5jb252ZXJ0LmNteWsucmdiID0gZnVuY3Rpb24gKGNteWspIHtcblx0dmFyIGMgPSBjbXlrWzBdIC8gMTAwO1xuXHR2YXIgbSA9IGNteWtbMV0gLyAxMDA7XG5cdHZhciB5ID0gY215a1syXSAvIDEwMDtcblx0dmFyIGsgPSBjbXlrWzNdIC8gMTAwO1xuXHR2YXIgcjtcblx0dmFyIGc7XG5cdHZhciBiO1xuXG5cdHIgPSAxIC0gTWF0aC5taW4oMSwgYyAqICgxIC0gaykgKyBrKTtcblx0ZyA9IDEgLSBNYXRoLm1pbigxLCBtICogKDEgLSBrKSArIGspO1xuXHRiID0gMSAtIE1hdGgubWluKDEsIHkgKiAoMSAtIGspICsgayk7XG5cblx0cmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn07XG5cbmNvbnZlcnQueHl6LnJnYiA9IGZ1bmN0aW9uICh4eXopIHtcblx0dmFyIHggPSB4eXpbMF0gLyAxMDA7XG5cdHZhciB5ID0geHl6WzFdIC8gMTAwO1xuXHR2YXIgeiA9IHh5elsyXSAvIDEwMDtcblx0dmFyIHI7XG5cdHZhciBnO1xuXHR2YXIgYjtcblxuXHRyID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG5cdGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuXHRiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuXHQvLyBhc3N1bWUgc1JHQlxuXHRyID0gciA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIE1hdGgucG93KHIsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG5cdFx0OiByICogMTIuOTI7XG5cblx0ZyA9IGcgPiAwLjAwMzEzMDhcblx0XHQ/ICgoMS4wNTUgKiBNYXRoLnBvdyhnLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuXHRcdDogZyAqIDEyLjkyO1xuXG5cdGIgPSBiID4gMC4wMDMxMzA4XG5cdFx0PyAoKDEuMDU1ICogTWF0aC5wb3coYiwgMS4wIC8gMi40KSkgLSAwLjA1NSlcblx0XHQ6IGIgKiAxMi45MjtcblxuXHRyID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuXHRnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuXHRiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuXG5jb252ZXJ0Lnh5ei5sYWIgPSBmdW5jdGlvbiAoeHl6KSB7XG5cdHZhciB4ID0geHl6WzBdO1xuXHR2YXIgeSA9IHh5elsxXTtcblx0dmFyIHogPSB4eXpbMl07XG5cdHZhciBsO1xuXHR2YXIgYTtcblx0dmFyIGI7XG5cblx0eCAvPSA5NS4wNDc7XG5cdHkgLz0gMTAwO1xuXHR6IC89IDEwOC44ODM7XG5cblx0eCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEgLyAzKSA6ICg3Ljc4NyAqIHgpICsgKDE2IC8gMTE2KTtcblx0eSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEgLyAzKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcblx0eiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEgLyAzKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuXHRsID0gKDExNiAqIHkpIC0gMTY7XG5cdGEgPSA1MDAgKiAoeCAtIHkpO1xuXHRiID0gMjAwICogKHkgLSB6KTtcblxuXHRyZXR1cm4gW2wsIGEsIGJdO1xufTtcblxuY29udmVydC5sYWIueHl6ID0gZnVuY3Rpb24gKGxhYikge1xuXHR2YXIgbCA9IGxhYlswXTtcblx0dmFyIGEgPSBsYWJbMV07XG5cdHZhciBiID0gbGFiWzJdO1xuXHR2YXIgeDtcblx0dmFyIHk7XG5cdHZhciB6O1xuXG5cdHkgPSAobCArIDE2KSAvIDExNjtcblx0eCA9IGEgLyA1MDAgKyB5O1xuXHR6ID0geSAtIGIgLyAyMDA7XG5cblx0dmFyIHkyID0gTWF0aC5wb3coeSwgMyk7XG5cdHZhciB4MiA9IE1hdGgucG93KHgsIDMpO1xuXHR2YXIgejIgPSBNYXRoLnBvdyh6LCAzKTtcblx0eSA9IHkyID4gMC4wMDg4NTYgPyB5MiA6ICh5IC0gMTYgLyAxMTYpIC8gNy43ODc7XG5cdHggPSB4MiA+IDAuMDA4ODU2ID8geDIgOiAoeCAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuXHR6ID0gejIgPiAwLjAwODg1NiA/IHoyIDogKHogLSAxNiAvIDExNikgLyA3Ljc4NztcblxuXHR4ICo9IDk1LjA0Nztcblx0eSAqPSAxMDA7XG5cdHogKj0gMTA4Ljg4MztcblxuXHRyZXR1cm4gW3gsIHksIHpdO1xufTtcblxuY29udmVydC5sYWIubGNoID0gZnVuY3Rpb24gKGxhYikge1xuXHR2YXIgbCA9IGxhYlswXTtcblx0dmFyIGEgPSBsYWJbMV07XG5cdHZhciBiID0gbGFiWzJdO1xuXHR2YXIgaHI7XG5cdHZhciBoO1xuXHR2YXIgYztcblxuXHRociA9IE1hdGguYXRhbjIoYiwgYSk7XG5cdGggPSBociAqIDM2MCAvIDIgLyBNYXRoLlBJO1xuXG5cdGlmIChoIDwgMCkge1xuXHRcdGggKz0gMzYwO1xuXHR9XG5cblx0YyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcblxuXHRyZXR1cm4gW2wsIGMsIGhdO1xufTtcblxuY29udmVydC5sY2gubGFiID0gZnVuY3Rpb24gKGxjaCkge1xuXHR2YXIgbCA9IGxjaFswXTtcblx0dmFyIGMgPSBsY2hbMV07XG5cdHZhciBoID0gbGNoWzJdO1xuXHR2YXIgYTtcblx0dmFyIGI7XG5cdHZhciBocjtcblxuXHRociA9IGggLyAzNjAgKiAyICogTWF0aC5QSTtcblx0YSA9IGMgKiBNYXRoLmNvcyhocik7XG5cdGIgPSBjICogTWF0aC5zaW4oaHIpO1xuXG5cdHJldHVybiBbbCwgYSwgYl07XG59O1xuXG5jb252ZXJ0LnJnYi5hbnNpMTYgPSBmdW5jdGlvbiAoYXJncykge1xuXHR2YXIgciA9IGFyZ3NbMF07XG5cdHZhciBnID0gYXJnc1sxXTtcblx0dmFyIGIgPSBhcmdzWzJdO1xuXHR2YXIgdmFsdWUgPSAxIGluIGFyZ3VtZW50cyA/IGFyZ3VtZW50c1sxXSA6IGNvbnZlcnQucmdiLmhzdihhcmdzKVsyXTsgLy8gaHN2IC0+IGFuc2kxNiBvcHRpbWl6YXRpb25cblxuXHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgLyA1MCk7XG5cblx0aWYgKHZhbHVlID09PSAwKSB7XG5cdFx0cmV0dXJuIDMwO1xuXHR9XG5cblx0dmFyIGFuc2kgPSAzMFxuXHRcdCsgKChNYXRoLnJvdW5kKGIgLyAyNTUpIDw8IDIpXG5cdFx0fCAoTWF0aC5yb3VuZChnIC8gMjU1KSA8PCAxKVxuXHRcdHwgTWF0aC5yb3VuZChyIC8gMjU1KSk7XG5cblx0aWYgKHZhbHVlID09PSAyKSB7XG5cdFx0YW5zaSArPSA2MDtcblx0fVxuXG5cdHJldHVybiBhbnNpO1xufTtcblxuY29udmVydC5oc3YuYW5zaTE2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0Ly8gb3B0aW1pemF0aW9uIGhlcmU7IHdlIGFscmVhZHkga25vdyB0aGUgdmFsdWUgYW5kIGRvbid0IG5lZWQgdG8gZ2V0XG5cdC8vIGl0IGNvbnZlcnRlZCBmb3IgdXMuXG5cdHJldHVybiBjb252ZXJ0LnJnYi5hbnNpMTYoY29udmVydC5oc3YucmdiKGFyZ3MpLCBhcmdzWzJdKTtcbn07XG5cbmNvbnZlcnQucmdiLmFuc2kyNTYgPSBmdW5jdGlvbiAoYXJncykge1xuXHR2YXIgciA9IGFyZ3NbMF07XG5cdHZhciBnID0gYXJnc1sxXTtcblx0dmFyIGIgPSBhcmdzWzJdO1xuXG5cdC8vIHdlIHVzZSB0aGUgZXh0ZW5kZWQgZ3JleXNjYWxlIHBhbGV0dGUgaGVyZSwgd2l0aCB0aGUgZXhjZXB0aW9uIG9mXG5cdC8vIGJsYWNrIGFuZCB3aGl0ZS4gbm9ybWFsIHBhbGV0dGUgb25seSBoYXMgNCBncmV5c2NhbGUgc2hhZGVzLlxuXHRpZiAociA9PT0gZyAmJiBnID09PSBiKSB7XG5cdFx0aWYgKHIgPCA4KSB7XG5cdFx0XHRyZXR1cm4gMTY7XG5cdFx0fVxuXG5cdFx0aWYgKHIgPiAyNDgpIHtcblx0XHRcdHJldHVybiAyMzE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1hdGgucm91bmQoKChyIC0gOCkgLyAyNDcpICogMjQpICsgMjMyO1xuXHR9XG5cblx0dmFyIGFuc2kgPSAxNlxuXHRcdCsgKDM2ICogTWF0aC5yb3VuZChyIC8gMjU1ICogNSkpXG5cdFx0KyAoNiAqIE1hdGgucm91bmQoZyAvIDI1NSAqIDUpKVxuXHRcdCsgTWF0aC5yb3VuZChiIC8gMjU1ICogNSk7XG5cblx0cmV0dXJuIGFuc2k7XG59O1xuXG5jb252ZXJ0LmFuc2kxNi5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHR2YXIgY29sb3IgPSBhcmdzICUgMTA7XG5cblx0Ly8gaGFuZGxlIGdyZXlzY2FsZVxuXHRpZiAoY29sb3IgPT09IDAgfHwgY29sb3IgPT09IDcpIHtcblx0XHRpZiAoYXJncyA+IDUwKSB7XG5cdFx0XHRjb2xvciArPSAzLjU7XG5cdFx0fVxuXG5cdFx0Y29sb3IgPSBjb2xvciAvIDEwLjUgKiAyNTU7XG5cblx0XHRyZXR1cm4gW2NvbG9yLCBjb2xvciwgY29sb3JdO1xuXHR9XG5cblx0dmFyIG11bHQgPSAofn4oYXJncyA+IDUwKSArIDEpICogMC41O1xuXHR2YXIgciA9ICgoY29sb3IgJiAxKSAqIG11bHQpICogMjU1O1xuXHR2YXIgZyA9ICgoKGNvbG9yID4+IDEpICYgMSkgKiBtdWx0KSAqIDI1NTtcblx0dmFyIGIgPSAoKChjb2xvciA+PiAyKSAmIDEpICogbXVsdCkgKiAyNTU7XG5cblx0cmV0dXJuIFtyLCBnLCBiXTtcbn07XG5cbmNvbnZlcnQuYW5zaTI1Ni5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHQvLyBoYW5kbGUgZ3JleXNjYWxlXG5cdGlmIChhcmdzID49IDIzMikge1xuXHRcdHZhciBjID0gKGFyZ3MgLSAyMzIpICogMTAgKyA4O1xuXHRcdHJldHVybiBbYywgYywgY107XG5cdH1cblxuXHRhcmdzIC09IDE2O1xuXG5cdHZhciByZW07XG5cdHZhciByID0gTWF0aC5mbG9vcihhcmdzIC8gMzYpIC8gNSAqIDI1NTtcblx0dmFyIGcgPSBNYXRoLmZsb29yKChyZW0gPSBhcmdzICUgMzYpIC8gNikgLyA1ICogMjU1O1xuXHR2YXIgYiA9IChyZW0gJSA2KSAvIDUgKiAyNTU7XG5cblx0cmV0dXJuIFtyLCBnLCBiXTtcbn07XG5cbmNvbnZlcnQucmdiLmhleCA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciBpbnRlZ2VyID0gKChNYXRoLnJvdW5kKGFyZ3NbMF0pICYgMHhGRikgPDwgMTYpXG5cdFx0KyAoKE1hdGgucm91bmQoYXJnc1sxXSkgJiAweEZGKSA8PCA4KVxuXHRcdCsgKE1hdGgucm91bmQoYXJnc1syXSkgJiAweEZGKTtcblxuXHR2YXIgc3RyaW5nID0gaW50ZWdlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0cmV0dXJuICcwMDAwMDAnLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbn07XG5cbmNvbnZlcnQuaGV4LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciBtYXRjaCA9IGFyZ3MudG9TdHJpbmcoMTYpLm1hdGNoKC9bYS1mMC05XXs2fXxbYS1mMC05XXszfS9pKTtcblx0aWYgKCFtYXRjaCkge1xuXHRcdHJldHVybiBbMCwgMCwgMF07XG5cdH1cblxuXHR2YXIgY29sb3JTdHJpbmcgPSBtYXRjaFswXTtcblxuXHRpZiAobWF0Y2hbMF0ubGVuZ3RoID09PSAzKSB7XG5cdFx0Y29sb3JTdHJpbmcgPSBjb2xvclN0cmluZy5zcGxpdCgnJykubWFwKGZ1bmN0aW9uIChjaGFyKSB7XG5cdFx0XHRyZXR1cm4gY2hhciArIGNoYXI7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHR2YXIgaW50ZWdlciA9IHBhcnNlSW50KGNvbG9yU3RyaW5nLCAxNik7XG5cdHZhciByID0gKGludGVnZXIgPj4gMTYpICYgMHhGRjtcblx0dmFyIGcgPSAoaW50ZWdlciA+PiA4KSAmIDB4RkY7XG5cdHZhciBiID0gaW50ZWdlciAmIDB4RkY7XG5cblx0cmV0dXJuIFtyLCBnLCBiXTtcbn07XG5cbmNvbnZlcnQucmdiLmhjZyA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblx0dmFyIG1heCA9IE1hdGgubWF4KE1hdGgubWF4KHIsIGcpLCBiKTtcblx0dmFyIG1pbiA9IE1hdGgubWluKE1hdGgubWluKHIsIGcpLCBiKTtcblx0dmFyIGNocm9tYSA9IChtYXggLSBtaW4pO1xuXHR2YXIgZ3JheXNjYWxlO1xuXHR2YXIgaHVlO1xuXG5cdGlmIChjaHJvbWEgPCAxKSB7XG5cdFx0Z3JheXNjYWxlID0gbWluIC8gKDEgLSBjaHJvbWEpO1xuXHR9IGVsc2Uge1xuXHRcdGdyYXlzY2FsZSA9IDA7XG5cdH1cblxuXHRpZiAoY2hyb21hIDw9IDApIHtcblx0XHRodWUgPSAwO1xuXHR9IGVsc2Vcblx0aWYgKG1heCA9PT0gcikge1xuXHRcdGh1ZSA9ICgoZyAtIGIpIC8gY2hyb21hKSAlIDY7XG5cdH0gZWxzZVxuXHRpZiAobWF4ID09PSBnKSB7XG5cdFx0aHVlID0gMiArIChiIC0gcikgLyBjaHJvbWE7XG5cdH0gZWxzZSB7XG5cdFx0aHVlID0gNCArIChyIC0gZykgLyBjaHJvbWEgKyA0O1xuXHR9XG5cblx0aHVlIC89IDY7XG5cdGh1ZSAlPSAxO1xuXG5cdHJldHVybiBbaHVlICogMzYwLCBjaHJvbWEgKiAxMDAsIGdyYXlzY2FsZSAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhzbC5oY2cgPSBmdW5jdGlvbiAoaHNsKSB7XG5cdHZhciBzID0gaHNsWzFdIC8gMTAwO1xuXHR2YXIgbCA9IGhzbFsyXSAvIDEwMDtcblx0dmFyIGMgPSAxO1xuXHR2YXIgZiA9IDA7XG5cblx0aWYgKGwgPCAwLjUpIHtcblx0XHRjID0gMi4wICogcyAqIGw7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IDIuMCAqIHMgKiAoMS4wIC0gbCk7XG5cdH1cblxuXHRpZiAoYyA8IDEuMCkge1xuXHRcdGYgPSAobCAtIDAuNSAqIGMpIC8gKDEuMCAtIGMpO1xuXHR9XG5cblx0cmV0dXJuIFtoc2xbMF0sIGMgKiAxMDAsIGYgKiAxMDBdO1xufTtcblxuY29udmVydC5oc3YuaGNnID0gZnVuY3Rpb24gKGhzdikge1xuXHR2YXIgcyA9IGhzdlsxXSAvIDEwMDtcblx0dmFyIHYgPSBoc3ZbMl0gLyAxMDA7XG5cblx0dmFyIGMgPSBzICogdjtcblx0dmFyIGYgPSAwO1xuXG5cdGlmIChjIDwgMS4wKSB7XG5cdFx0ZiA9ICh2IC0gYykgLyAoMSAtIGMpO1xuXHR9XG5cblx0cmV0dXJuIFtoc3ZbMF0sIGMgKiAxMDAsIGYgKiAxMDBdO1xufTtcblxuY29udmVydC5oY2cucmdiID0gZnVuY3Rpb24gKGhjZykge1xuXHR2YXIgaCA9IGhjZ1swXSAvIDM2MDtcblx0dmFyIGMgPSBoY2dbMV0gLyAxMDA7XG5cdHZhciBnID0gaGNnWzJdIC8gMTAwO1xuXG5cdGlmIChjID09PSAwLjApIHtcblx0XHRyZXR1cm4gW2cgKiAyNTUsIGcgKiAyNTUsIGcgKiAyNTVdO1xuXHR9XG5cblx0dmFyIHB1cmUgPSBbMCwgMCwgMF07XG5cdHZhciBoaSA9IChoICUgMSkgKiA2O1xuXHR2YXIgdiA9IGhpICUgMTtcblx0dmFyIHcgPSAxIC0gdjtcblx0dmFyIG1nID0gMDtcblxuXHRzd2l0Y2ggKE1hdGguZmxvb3IoaGkpKSB7XG5cdFx0Y2FzZSAwOlxuXHRcdFx0cHVyZVswXSA9IDE7IHB1cmVbMV0gPSB2OyBwdXJlWzJdID0gMDsgYnJlYWs7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0cHVyZVswXSA9IHc7IHB1cmVbMV0gPSAxOyBwdXJlWzJdID0gMDsgYnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0cHVyZVswXSA9IDA7IHB1cmVbMV0gPSAxOyBwdXJlWzJdID0gdjsgYnJlYWs7XG5cdFx0Y2FzZSAzOlxuXHRcdFx0cHVyZVswXSA9IDA7IHB1cmVbMV0gPSB3OyBwdXJlWzJdID0gMTsgYnJlYWs7XG5cdFx0Y2FzZSA0OlxuXHRcdFx0cHVyZVswXSA9IHY7IHB1cmVbMV0gPSAwOyBwdXJlWzJdID0gMTsgYnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHB1cmVbMF0gPSAxOyBwdXJlWzFdID0gMDsgcHVyZVsyXSA9IHc7XG5cdH1cblxuXHRtZyA9ICgxLjAgLSBjKSAqIGc7XG5cblx0cmV0dXJuIFtcblx0XHQoYyAqIHB1cmVbMF0gKyBtZykgKiAyNTUsXG5cdFx0KGMgKiBwdXJlWzFdICsgbWcpICogMjU1LFxuXHRcdChjICogcHVyZVsyXSArIG1nKSAqIDI1NVxuXHRdO1xufTtcblxuY29udmVydC5oY2cuaHN2ID0gZnVuY3Rpb24gKGhjZykge1xuXHR2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcblx0dmFyIGcgPSBoY2dbMl0gLyAxMDA7XG5cblx0dmFyIHYgPSBjICsgZyAqICgxLjAgLSBjKTtcblx0dmFyIGYgPSAwO1xuXG5cdGlmICh2ID4gMC4wKSB7XG5cdFx0ZiA9IGMgLyB2O1xuXHR9XG5cblx0cmV0dXJuIFtoY2dbMF0sIGYgKiAxMDAsIHYgKiAxMDBdO1xufTtcblxuY29udmVydC5oY2cuaHNsID0gZnVuY3Rpb24gKGhjZykge1xuXHR2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcblx0dmFyIGcgPSBoY2dbMl0gLyAxMDA7XG5cblx0dmFyIGwgPSBnICogKDEuMCAtIGMpICsgMC41ICogYztcblx0dmFyIHMgPSAwO1xuXG5cdGlmIChsID4gMC4wICYmIGwgPCAwLjUpIHtcblx0XHRzID0gYyAvICgyICogbCk7XG5cdH0gZWxzZVxuXHRpZiAobCA+PSAwLjUgJiYgbCA8IDEuMCkge1xuXHRcdHMgPSBjIC8gKDIgKiAoMSAtIGwpKTtcblx0fVxuXG5cdHJldHVybiBbaGNnWzBdLCBzICogMTAwLCBsICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaGNnLmh3YiA9IGZ1bmN0aW9uIChoY2cpIHtcblx0dmFyIGMgPSBoY2dbMV0gLyAxMDA7XG5cdHZhciBnID0gaGNnWzJdIC8gMTAwO1xuXHR2YXIgdiA9IGMgKyBnICogKDEuMCAtIGMpO1xuXHRyZXR1cm4gW2hjZ1swXSwgKHYgLSBjKSAqIDEwMCwgKDEgLSB2KSAqIDEwMF07XG59O1xuXG5jb252ZXJ0Lmh3Yi5oY2cgPSBmdW5jdGlvbiAoaHdiKSB7XG5cdHZhciB3ID0gaHdiWzFdIC8gMTAwO1xuXHR2YXIgYiA9IGh3YlsyXSAvIDEwMDtcblx0dmFyIHYgPSAxIC0gYjtcblx0dmFyIGMgPSB2IC0gdztcblx0dmFyIGcgPSAwO1xuXG5cdGlmIChjIDwgMSkge1xuXHRcdGcgPSAodiAtIGMpIC8gKDEgLSBjKTtcblx0fVxuXG5cdHJldHVybiBbaHdiWzBdLCBjICogMTAwLCBnICogMTAwXTtcbn07XG5cbmNvbnZlcnQuYXBwbGUucmdiID0gZnVuY3Rpb24gKGFwcGxlKSB7XG5cdHJldHVybiBbKGFwcGxlWzBdIC8gNjU1MzUpICogMjU1LCAoYXBwbGVbMV0gLyA2NTUzNSkgKiAyNTUsIChhcHBsZVsyXSAvIDY1NTM1KSAqIDI1NV07XG59O1xuXG5jb252ZXJ0LnJnYi5hcHBsZSA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0cmV0dXJuIFsocmdiWzBdIC8gMjU1KSAqIDY1NTM1LCAocmdiWzFdIC8gMjU1KSAqIDY1NTM1LCAocmdiWzJdIC8gMjU1KSAqIDY1NTM1XTtcbn07XG5cbmNvbnZlcnQuZ3JheS5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHRyZXR1cm4gW2FyZ3NbMF0gLyAxMDAgKiAyNTUsIGFyZ3NbMF0gLyAxMDAgKiAyNTUsIGFyZ3NbMF0gLyAxMDAgKiAyNTVdO1xufTtcblxuY29udmVydC5ncmF5LmhzbCA9IGNvbnZlcnQuZ3JheS5oc3YgPSBmdW5jdGlvbiAoYXJncykge1xuXHRyZXR1cm4gWzAsIDAsIGFyZ3NbMF1dO1xufTtcblxuY29udmVydC5ncmF5Lmh3YiA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHJldHVybiBbMCwgMTAwLCBncmF5WzBdXTtcbn07XG5cbmNvbnZlcnQuZ3JheS5jbXlrID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0cmV0dXJuIFswLCAwLCAwLCBncmF5WzBdXTtcbn07XG5cbmNvbnZlcnQuZ3JheS5sYWIgPSBmdW5jdGlvbiAoZ3JheSkge1xuXHRyZXR1cm4gW2dyYXlbMF0sIDAsIDBdO1xufTtcblxuY29udmVydC5ncmF5LmhleCA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHZhciB2YWwgPSBNYXRoLnJvdW5kKGdyYXlbMF0gLyAxMDAgKiAyNTUpICYgMHhGRjtcblx0dmFyIGludGVnZXIgPSAodmFsIDw8IDE2KSArICh2YWwgPDwgOCkgKyB2YWw7XG5cblx0dmFyIHN0cmluZyA9IGludGVnZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdHJldHVybiAnMDAwMDAwJy5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59O1xuXG5jb252ZXJ0LnJnYi5ncmF5ID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgdmFsID0gKHJnYlswXSArIHJnYlsxXSArIHJnYlsyXSkgLyAzO1xuXHRyZXR1cm4gW3ZhbCAvIDI1NSAqIDEwMF07XG59O1xufSk7XG52YXIgY29udmVyc2lvbnNfMSA9IGNvbnZlcnNpb25zLnJnYjtcbnZhciBjb252ZXJzaW9uc18yID0gY29udmVyc2lvbnMuaHNsO1xudmFyIGNvbnZlcnNpb25zXzMgPSBjb252ZXJzaW9ucy5oc3Y7XG52YXIgY29udmVyc2lvbnNfNCA9IGNvbnZlcnNpb25zLmh3YjtcbnZhciBjb252ZXJzaW9uc181ID0gY29udmVyc2lvbnMuY215aztcbnZhciBjb252ZXJzaW9uc182ID0gY29udmVyc2lvbnMueHl6O1xudmFyIGNvbnZlcnNpb25zXzcgPSBjb252ZXJzaW9ucy5sYWI7XG52YXIgY29udmVyc2lvbnNfOCA9IGNvbnZlcnNpb25zLmxjaDtcbnZhciBjb252ZXJzaW9uc185ID0gY29udmVyc2lvbnMuaGV4O1xudmFyIGNvbnZlcnNpb25zXzEwID0gY29udmVyc2lvbnMua2V5d29yZDtcbnZhciBjb252ZXJzaW9uc18xMSA9IGNvbnZlcnNpb25zLmFuc2kxNjtcbnZhciBjb252ZXJzaW9uc18xMiA9IGNvbnZlcnNpb25zLmFuc2kyNTY7XG52YXIgY29udmVyc2lvbnNfMTMgPSBjb252ZXJzaW9ucy5oY2c7XG52YXIgY29udmVyc2lvbnNfMTQgPSBjb252ZXJzaW9ucy5hcHBsZTtcbnZhciBjb252ZXJzaW9uc18xNSA9IGNvbnZlcnNpb25zLmdyYXk7XG5cbi8qXG5cdHRoaXMgZnVuY3Rpb24gcm91dGVzIGEgbW9kZWwgdG8gYWxsIG90aGVyIG1vZGVscy5cblxuXHRhbGwgZnVuY3Rpb25zIHRoYXQgYXJlIHJvdXRlZCBoYXZlIGEgcHJvcGVydHkgYC5jb252ZXJzaW9uYCBhdHRhY2hlZFxuXHR0byB0aGUgcmV0dXJuZWQgc3ludGhldGljIGZ1bmN0aW9uLiBUaGlzIHByb3BlcnR5IGlzIGFuIGFycmF5XG5cdG9mIHN0cmluZ3MsIGVhY2ggd2l0aCB0aGUgc3RlcHMgaW4gYmV0d2VlbiB0aGUgJ2Zyb20nIGFuZCAndG8nXG5cdGNvbG9yIG1vZGVscyAoaW5jbHVzaXZlKS5cblxuXHRjb252ZXJzaW9ucyB0aGF0IGFyZSBub3QgcG9zc2libGUgc2ltcGx5IGFyZSBub3QgaW5jbHVkZWQuXG4qL1xuXG5mdW5jdGlvbiBidWlsZEdyYXBoKCkge1xuXHR2YXIgZ3JhcGggPSB7fTtcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL29iamVjdC1rZXlzLXZzLWZvci1pbi13aXRoLWNsb3N1cmUvM1xuXHR2YXIgbW9kZWxzID0gT2JqZWN0LmtleXMoY29udmVyc2lvbnMpO1xuXG5cdGZvciAodmFyIGxlbiA9IG1vZGVscy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRncmFwaFttb2RlbHNbaV1dID0ge1xuXHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vMS12cy1pbmZpbml0eVxuXHRcdFx0Ly8gbWljcm8tb3B0LCBidXQgdGhpcyBpcyBzaW1wbGUuXG5cdFx0XHRkaXN0YW5jZTogLTEsXG5cdFx0XHRwYXJlbnQ6IG51bGxcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIGdyYXBoO1xufVxuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CcmVhZHRoLWZpcnN0X3NlYXJjaFxuZnVuY3Rpb24gZGVyaXZlQkZTKGZyb21Nb2RlbCkge1xuXHR2YXIgZ3JhcGggPSBidWlsZEdyYXBoKCk7XG5cdHZhciBxdWV1ZSA9IFtmcm9tTW9kZWxdOyAvLyB1bnNoaWZ0IC0+IHF1ZXVlIC0+IHBvcFxuXG5cdGdyYXBoW2Zyb21Nb2RlbF0uZGlzdGFuY2UgPSAwO1xuXG5cdHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcblx0XHR2YXIgY3VycmVudCA9IHF1ZXVlLnBvcCgpO1xuXHRcdHZhciBhZGphY2VudHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9uc1tjdXJyZW50XSk7XG5cblx0XHRmb3IgKHZhciBsZW4gPSBhZGphY2VudHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR2YXIgYWRqYWNlbnQgPSBhZGphY2VudHNbaV07XG5cdFx0XHR2YXIgbm9kZSA9IGdyYXBoW2FkamFjZW50XTtcblxuXHRcdFx0aWYgKG5vZGUuZGlzdGFuY2UgPT09IC0xKSB7XG5cdFx0XHRcdG5vZGUuZGlzdGFuY2UgPSBncmFwaFtjdXJyZW50XS5kaXN0YW5jZSArIDE7XG5cdFx0XHRcdG5vZGUucGFyZW50ID0gY3VycmVudDtcblx0XHRcdFx0cXVldWUudW5zaGlmdChhZGphY2VudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGdyYXBoO1xufVxuXG5mdW5jdGlvbiBsaW5rKGZyb20sIHRvKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoYXJncykge1xuXHRcdHJldHVybiB0byhmcm9tKGFyZ3MpKTtcblx0fTtcbn1cblxuZnVuY3Rpb24gd3JhcENvbnZlcnNpb24odG9Nb2RlbCwgZ3JhcGgpIHtcblx0dmFyIHBhdGggPSBbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50LCB0b01vZGVsXTtcblx0dmFyIGZuID0gY29udmVyc2lvbnNbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50XVt0b01vZGVsXTtcblxuXHR2YXIgY3VyID0gZ3JhcGhbdG9Nb2RlbF0ucGFyZW50O1xuXHR3aGlsZSAoZ3JhcGhbY3VyXS5wYXJlbnQpIHtcblx0XHRwYXRoLnVuc2hpZnQoZ3JhcGhbY3VyXS5wYXJlbnQpO1xuXHRcdGZuID0gbGluayhjb252ZXJzaW9uc1tncmFwaFtjdXJdLnBhcmVudF1bY3VyXSwgZm4pO1xuXHRcdGN1ciA9IGdyYXBoW2N1cl0ucGFyZW50O1xuXHR9XG5cblx0Zm4uY29udmVyc2lvbiA9IHBhdGg7XG5cdHJldHVybiBmbjtcbn1cblxudmFyIHJvdXRlID0gZnVuY3Rpb24gKGZyb21Nb2RlbCkge1xuXHR2YXIgZ3JhcGggPSBkZXJpdmVCRlMoZnJvbU1vZGVsKTtcblx0dmFyIGNvbnZlcnNpb24gPSB7fTtcblxuXHR2YXIgbW9kZWxzID0gT2JqZWN0LmtleXMoZ3JhcGgpO1xuXHRmb3IgKHZhciBsZW4gPSBtb2RlbHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0dmFyIHRvTW9kZWwgPSBtb2RlbHNbaV07XG5cdFx0dmFyIG5vZGUgPSBncmFwaFt0b01vZGVsXTtcblxuXHRcdGlmIChub2RlLnBhcmVudCA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gbm8gcG9zc2libGUgY29udmVyc2lvbiwgb3IgdGhpcyBub2RlIGlzIHRoZSBzb3VyY2UgbW9kZWwuXG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb252ZXJzaW9uW3RvTW9kZWxdID0gd3JhcENvbnZlcnNpb24odG9Nb2RlbCwgZ3JhcGgpO1xuXHR9XG5cblx0cmV0dXJuIGNvbnZlcnNpb247XG59O1xuXG52YXIgY29udmVydCA9IHt9O1xuXG52YXIgbW9kZWxzID0gT2JqZWN0LmtleXMoY29udmVyc2lvbnMpO1xuXG5mdW5jdGlvbiB3cmFwUmF3KGZuKSB7XG5cdHZhciB3cmFwcGVkRm4gPSBmdW5jdGlvbiAoYXJncykge1xuXHRcdGlmIChhcmdzID09PSB1bmRlZmluZWQgfHwgYXJncyA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGFyZ3M7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZm4oYXJncyk7XG5cdH07XG5cblx0Ly8gcHJlc2VydmUgLmNvbnZlcnNpb24gcHJvcGVydHkgaWYgdGhlcmUgaXMgb25lXG5cdGlmICgnY29udmVyc2lvbicgaW4gZm4pIHtcblx0XHR3cmFwcGVkRm4uY29udmVyc2lvbiA9IGZuLmNvbnZlcnNpb247XG5cdH1cblxuXHRyZXR1cm4gd3JhcHBlZEZuO1xufVxuXG5mdW5jdGlvbiB3cmFwUm91bmRlZChmbikge1xuXHR2YXIgd3JhcHBlZEZuID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRpZiAoYXJncyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3MgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBhcmdzO1xuXHRcdH1cblxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlc3VsdCA9IGZuKGFyZ3MpO1xuXG5cdFx0Ly8gd2UncmUgYXNzdW1pbmcgdGhlIHJlc3VsdCBpcyBhbiBhcnJheSBoZXJlLlxuXHRcdC8vIHNlZSBub3RpY2UgaW4gY29udmVyc2lvbnMuanM7IGRvbid0IHVzZSBib3ggdHlwZXNcblx0XHQvLyBpbiBjb252ZXJzaW9uIGZ1bmN0aW9ucy5cblx0XHRpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGZvciAodmFyIGxlbiA9IHJlc3VsdC5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gTWF0aC5yb3VuZChyZXN1bHRbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gcHJlc2VydmUgLmNvbnZlcnNpb24gcHJvcGVydHkgaWYgdGhlcmUgaXMgb25lXG5cdGlmICgnY29udmVyc2lvbicgaW4gZm4pIHtcblx0XHR3cmFwcGVkRm4uY29udmVyc2lvbiA9IGZuLmNvbnZlcnNpb247XG5cdH1cblxuXHRyZXR1cm4gd3JhcHBlZEZuO1xufVxuXG5tb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAoZnJvbU1vZGVsKSB7XG5cdGNvbnZlcnRbZnJvbU1vZGVsXSA9IHt9O1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W2Zyb21Nb2RlbF0sICdjaGFubmVscycsIHt2YWx1ZTogY29udmVyc2lvbnNbZnJvbU1vZGVsXS5jaGFubmVsc30pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFtmcm9tTW9kZWxdLCAnbGFiZWxzJywge3ZhbHVlOiBjb252ZXJzaW9uc1tmcm9tTW9kZWxdLmxhYmVsc30pO1xuXG5cdHZhciByb3V0ZXMgPSByb3V0ZShmcm9tTW9kZWwpO1xuXHR2YXIgcm91dGVNb2RlbHMgPSBPYmplY3Qua2V5cyhyb3V0ZXMpO1xuXG5cdHJvdXRlTW9kZWxzLmZvckVhY2goZnVuY3Rpb24gKHRvTW9kZWwpIHtcblx0XHR2YXIgZm4gPSByb3V0ZXNbdG9Nb2RlbF07XG5cblx0XHRjb252ZXJ0W2Zyb21Nb2RlbF1bdG9Nb2RlbF0gPSB3cmFwUm91bmRlZChmbik7XG5cdFx0Y29udmVydFtmcm9tTW9kZWxdW3RvTW9kZWxdLnJhdyA9IHdyYXBSYXcoZm4pO1xuXHR9KTtcbn0pO1xuXG52YXIgY29sb3JDb252ZXJ0ID0gY29udmVydDtcblxudmFyIGNvbG9yTmFtZSQxID0ge1xyXG5cdFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcclxuXHRcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXHJcblx0XCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcclxuXHRcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcclxuXHRcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcclxuXHRcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXHJcblx0XCJibGFja1wiOiBbMCwgMCwgMF0sXHJcblx0XCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXHJcblx0XCJibHVlXCI6IFswLCAwLCAyNTVdLFxyXG5cdFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcclxuXHRcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXHJcblx0XCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxyXG5cdFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxyXG5cdFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxyXG5cdFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxyXG5cdFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXHJcblx0XCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXHJcblx0XCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXHJcblx0XCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXHJcblx0XCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcclxuXHRcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXHJcblx0XCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxyXG5cdFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxyXG5cdFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcclxuXHRcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXHJcblx0XCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxyXG5cdFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxyXG5cdFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcclxuXHRcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXHJcblx0XCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcclxuXHRcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXHJcblx0XCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXHJcblx0XCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxyXG5cdFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxyXG5cdFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXHJcblx0XCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxyXG5cdFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXHJcblx0XCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcclxuXHRcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcclxuXHRcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXHJcblx0XCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxyXG5cdFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXHJcblx0XCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXHJcblx0XCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXHJcblx0XCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxyXG5cdFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXHJcblx0XCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcclxuXHRcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxyXG5cdFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXHJcblx0XCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxyXG5cdFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxyXG5cdFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxyXG5cdFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxyXG5cdFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXHJcblx0XCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcclxuXHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXHJcblx0XCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxyXG5cdFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXHJcblx0XCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxyXG5cdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxyXG5cdFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxyXG5cdFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXHJcblx0XCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXHJcblx0XCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxyXG5cdFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcclxuXHRcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcclxuXHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcclxuXHRcImxpbWVcIjogWzAsIDI1NSwgMF0sXHJcblx0XCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcclxuXHRcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcclxuXHRcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcclxuXHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxyXG5cdFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcclxuXHRcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcclxuXHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXHJcblx0XCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcclxuXHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXHJcblx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxyXG5cdFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxyXG5cdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxyXG5cdFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXHJcblx0XCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxyXG5cdFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcclxuXHRcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcclxuXHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcclxuXHRcIm5hdnlcIjogWzAsIDAsIDEyOF0sXHJcblx0XCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcclxuXHRcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXHJcblx0XCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXHJcblx0XCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcclxuXHRcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXHJcblx0XCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxyXG5cdFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXHJcblx0XCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxyXG5cdFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXHJcblx0XCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcclxuXHRcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxyXG5cdFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcclxuXHRcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXHJcblx0XCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcclxuXHRcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxyXG5cdFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXHJcblx0XCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcclxuXHRcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXHJcblx0XCJyZWRcIjogWzI1NSwgMCwgMF0sXHJcblx0XCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxyXG5cdFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxyXG5cdFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcclxuXHRcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXHJcblx0XCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxyXG5cdFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcclxuXHRcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcclxuXHRcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxyXG5cdFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcclxuXHRcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxyXG5cdFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxyXG5cdFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcclxuXHRcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXHJcblx0XCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXHJcblx0XCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxyXG5cdFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxyXG5cdFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXHJcblx0XCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcclxuXHRcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcclxuXHRcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXHJcblx0XCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXHJcblx0XCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXHJcblx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcclxuXHRcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxyXG5cdFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cclxufTtcblxuLyogTUlUIGxpY2Vuc2UgKi9cblxuXG52YXIgY29sb3JTdHJpbmcgPSB7XG4gICBnZXRSZ2JhOiBnZXRSZ2JhLFxuICAgZ2V0SHNsYTogZ2V0SHNsYSxcbiAgIGdldFJnYjogZ2V0UmdiLFxuICAgZ2V0SHNsOiBnZXRIc2wsXG4gICBnZXRId2I6IGdldEh3YixcbiAgIGdldEFscGhhOiBnZXRBbHBoYSxcblxuICAgaGV4U3RyaW5nOiBoZXhTdHJpbmcsXG4gICByZ2JTdHJpbmc6IHJnYlN0cmluZyxcbiAgIHJnYmFTdHJpbmc6IHJnYmFTdHJpbmcsXG4gICBwZXJjZW50U3RyaW5nOiBwZXJjZW50U3RyaW5nLFxuICAgcGVyY2VudGFTdHJpbmc6IHBlcmNlbnRhU3RyaW5nLFxuICAgaHNsU3RyaW5nOiBoc2xTdHJpbmcsXG4gICBoc2xhU3RyaW5nOiBoc2xhU3RyaW5nLFxuICAgaHdiU3RyaW5nOiBod2JTdHJpbmcsXG4gICBrZXl3b3JkOiBrZXl3b3JkXG59O1xuXG5mdW5jdGlvbiBnZXRSZ2JhKHN0cmluZykge1xuICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBhYmJyID0gIC9eIyhbYS1mQS1GMC05XXszLDR9KSQvaSxcbiAgICAgICBoZXggPSAgL14jKFthLWZBLUYwLTldezZ9KFthLWZBLUYwLTldezJ9KT8pJC9pLFxuICAgICAgIHJnYmEgPSAvXnJnYmE/XFwoXFxzKihbKy1dP1xcZCspXFxzKixcXHMqKFsrLV0/XFxkKylcXHMqLFxccyooWystXT9cXGQrKVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkkL2ksXG4gICAgICAgcGVyID0gL15yZ2JhP1xcKFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpJC9pLFxuICAgICAgIGtleXdvcmQgPSAvKFxcdyspLztcblxuICAgdmFyIHJnYiA9IFswLCAwLCAwXSxcbiAgICAgICBhID0gMSxcbiAgICAgICBtYXRjaCA9IHN0cmluZy5tYXRjaChhYmJyKSxcbiAgICAgICBoZXhBbHBoYSA9IFwiXCI7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBoZXhBbHBoYSA9IG1hdGNoWzNdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHBhcnNlSW50KG1hdGNoW2ldICsgbWF0Y2hbaV0sIDE2KTtcbiAgICAgIH1cbiAgICAgIGlmIChoZXhBbHBoYSkge1xuICAgICAgICAgYSA9IE1hdGgucm91bmQoKHBhcnNlSW50KGhleEFscGhhICsgaGV4QWxwaGEsIDE2KSAvIDI1NSkgKiAxMDApIC8gMTAwO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goaGV4KSkge1xuICAgICAgaGV4QWxwaGEgPSBtYXRjaFsyXTtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2guc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KTtcbiAgICAgIH1cbiAgICAgIGlmIChoZXhBbHBoYSkge1xuICAgICAgICAgYSA9IE1hdGgucm91bmQoKHBhcnNlSW50KGhleEFscGhhLCAxNikgLyAyNTUpICogMTAwKSAvIDEwMDtcbiAgICAgIH1cbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHJnYmEpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaSArIDFdKTtcbiAgICAgIH1cbiAgICAgIGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHBlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobWF0Y2hbaSArIDFdKSAqIDIuNTUpO1xuICAgICAgfVxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goa2V5d29yZCkpIHtcbiAgICAgIGlmIChtYXRjaFsxXSA9PSBcInRyYW5zcGFyZW50XCIpIHtcbiAgICAgICAgIHJldHVybiBbMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgICByZ2IgPSBjb2xvck5hbWUkMVttYXRjaFsxXV07XG4gICAgICBpZiAoIXJnYikge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgfVxuXG4gICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgcmdiW2ldID0gc2NhbGUocmdiW2ldLCAwLCAyNTUpO1xuICAgfVxuICAgaWYgKCFhICYmIGEgIT0gMCkge1xuICAgICAgYSA9IDE7XG4gICB9XG4gICBlbHNlIHtcbiAgICAgIGEgPSBzY2FsZShhLCAwLCAxKTtcbiAgIH1cbiAgIHJnYlszXSA9IGE7XG4gICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBnZXRIc2xhKHN0cmluZykge1xuICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBoc2wgPSAvXmhzbGE/XFwoXFxzKihbKy1dP1xcZCspKD86ZGVnKT9cXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKS87XG4gICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHNsKTtcbiAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIGFscGhhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICAgICB2YXIgaCA9IHNjYWxlKHBhcnNlSW50KG1hdGNoWzFdKSwgMCwgMzYwKSxcbiAgICAgICAgICBzID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCksXG4gICAgICAgICAgbCA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApLFxuICAgICAgICAgIGEgPSBzY2FsZShpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuICAgICAgcmV0dXJuIFtoLCBzLCBsLCBhXTtcbiAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0SHdiKHN0cmluZykge1xuICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBod2IgPSAvXmh3YlxcKFxccyooWystXT9cXGQrKSg/OmRlZyk/XFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkvO1xuICAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKGh3Yik7XG4gICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgYWxwaGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgICAgIHZhciBoID0gc2NhbGUocGFyc2VJbnQobWF0Y2hbMV0pLCAwLCAzNjApLFxuICAgICAgICAgIHcgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzJdKSwgMCwgMTAwKSxcbiAgICAgICAgICBiID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFszXSksIDAsIDEwMCksXG4gICAgICAgICAgYSA9IHNjYWxlKGlzTmFOKGFscGhhKSA/IDEgOiBhbHBoYSwgMCwgMSk7XG4gICAgICByZXR1cm4gW2gsIHcsIGIsIGFdO1xuICAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZ2Ioc3RyaW5nKSB7XG4gICB2YXIgcmdiYSA9IGdldFJnYmEoc3RyaW5nKTtcbiAgIHJldHVybiByZ2JhICYmIHJnYmEuc2xpY2UoMCwgMyk7XG59XG5cbmZ1bmN0aW9uIGdldEhzbChzdHJpbmcpIHtcbiAgdmFyIGhzbGEgPSBnZXRIc2xhKHN0cmluZyk7XG4gIHJldHVybiBoc2xhICYmIGhzbGEuc2xpY2UoMCwgMyk7XG59XG5cbmZ1bmN0aW9uIGdldEFscGhhKHN0cmluZykge1xuICAgdmFyIHZhbHMgPSBnZXRSZ2JhKHN0cmluZyk7XG4gICBpZiAodmFscykge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG4gICBlbHNlIGlmICh2YWxzID0gZ2V0SHNsYShzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gdmFsc1szXTtcbiAgIH1cbiAgIGVsc2UgaWYgKHZhbHMgPSBnZXRId2Ioc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG59XG5cbi8vIGdlbmVyYXRvcnNcbmZ1bmN0aW9uIGhleFN0cmluZyhyZ2JhLCBhKSB7XG4gICB2YXIgYSA9IChhICE9PSB1bmRlZmluZWQgJiYgcmdiYS5sZW5ndGggPT09IDMpID8gYSA6IHJnYmFbM107XG4gICByZXR1cm4gXCIjXCIgKyBoZXhEb3VibGUocmdiYVswXSkgXG4gICAgICAgICAgICAgICsgaGV4RG91YmxlKHJnYmFbMV0pXG4gICAgICAgICAgICAgICsgaGV4RG91YmxlKHJnYmFbMl0pXG4gICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAoYSA+PSAwICYmIGEgPCAxKVxuICAgICAgICAgICAgICAgICA/IGhleERvdWJsZShNYXRoLnJvdW5kKGEgKiAyNTUpKVxuICAgICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgICAgKTtcbn1cblxuZnVuY3Rpb24gcmdiU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPCAxIHx8IChyZ2JhWzNdICYmIHJnYmFbM10gPCAxKSkge1xuICAgICAgcmV0dXJuIHJnYmFTdHJpbmcocmdiYSwgYWxwaGEpO1xuICAgfVxuICAgcmV0dXJuIFwicmdiKFwiICsgcmdiYVswXSArIFwiLCBcIiArIHJnYmFbMV0gKyBcIiwgXCIgKyByZ2JhWzJdICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIHJnYmFTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChyZ2JhWzNdICE9PSB1bmRlZmluZWQgPyByZ2JhWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiYVswXSArIFwiLCBcIiArIHJnYmFbMV0gKyBcIiwgXCIgKyByZ2JhWzJdXG4gICAgICAgICAgICsgXCIsIFwiICsgYWxwaGEgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gcGVyY2VudFN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAocmdiYVszXSAmJiByZ2JhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiBwZXJjZW50YVN0cmluZyhyZ2JhLCBhbHBoYSk7XG4gICB9XG4gICB2YXIgciA9IE1hdGgucm91bmQocmdiYVswXS8yNTUgKiAxMDApLFxuICAgICAgIGcgPSBNYXRoLnJvdW5kKHJnYmFbMV0vMjU1ICogMTAwKSxcbiAgICAgICBiID0gTWF0aC5yb3VuZChyZ2JhWzJdLzI1NSAqIDEwMCk7XG5cbiAgIHJldHVybiBcInJnYihcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlKVwiO1xufVxuXG5mdW5jdGlvbiBwZXJjZW50YVN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgdmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0vMjU1ICogMTAwKSxcbiAgICAgICBnID0gTWF0aC5yb3VuZChyZ2JhWzFdLzI1NSAqIDEwMCksXG4gICAgICAgYiA9IE1hdGgucm91bmQocmdiYVsyXS8yNTUgKiAxMDApO1xuICAgcmV0dXJuIFwicmdiYShcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlLCBcIiArIChhbHBoYSB8fCByZ2JhWzNdIHx8IDEpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGhzbFN0cmluZyhoc2xhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAoaHNsYVszXSAmJiBoc2xhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiBoc2xhU3RyaW5nKGhzbGEsIGFscGhhKTtcbiAgIH1cbiAgIHJldHVybiBcImhzbChcIiArIGhzbGFbMF0gKyBcIiwgXCIgKyBoc2xhWzFdICsgXCIlLCBcIiArIGhzbGFbMl0gKyBcIiUpXCI7XG59XG5cbmZ1bmN0aW9uIGhzbGFTdHJpbmcoaHNsYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChoc2xhWzNdICE9PSB1bmRlZmluZWQgPyBoc2xhWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJoc2xhKFwiICsgaHNsYVswXSArIFwiLCBcIiArIGhzbGFbMV0gKyBcIiUsIFwiICsgaHNsYVsyXSArIFwiJSwgXCJcbiAgICAgICAgICAgKyBhbHBoYSArIFwiKVwiO1xufVxuXG4vLyBod2IgaXMgYSBiaXQgZGlmZmVyZW50IHRoYW4gcmdiKGEpICYgaHNsKGEpIHNpbmNlIHRoZXJlIGlzIG5vIGFscGhhIHNwZWNpZmljIHN5bnRheFxuLy8gKGh3YiBoYXZlIGFscGhhIG9wdGlvbmFsICYgMSBpcyBkZWZhdWx0IHZhbHVlKVxuZnVuY3Rpb24gaHdiU3RyaW5nKGh3YiwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChod2JbM10gIT09IHVuZGVmaW5lZCA/IGh3YlszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHdiKFwiICsgaHdiWzBdICsgXCIsIFwiICsgaHdiWzFdICsgXCIlLCBcIiArIGh3YlsyXSArIFwiJVwiXG4gICAgICAgICAgICsgKGFscGhhICE9PSB1bmRlZmluZWQgJiYgYWxwaGEgIT09IDEgPyBcIiwgXCIgKyBhbHBoYSA6IFwiXCIpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQocmdiKSB7XG4gIHJldHVybiByZXZlcnNlTmFtZXNbcmdiLnNsaWNlKDAsIDMpXTtcbn1cblxuLy8gaGVscGVyc1xuZnVuY3Rpb24gc2NhbGUobnVtLCBtaW4sIG1heCkge1xuICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgbnVtKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gaGV4RG91YmxlKG51bSkge1xuICB2YXIgc3RyID0gbnVtLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICByZXR1cm4gKHN0ci5sZW5ndGggPCAyKSA/IFwiMFwiICsgc3RyIDogc3RyO1xufVxuXG5cbi8vY3JlYXRlIGEgbGlzdCBvZiByZXZlcnNlIGNvbG9yIG5hbWVzXG52YXIgcmV2ZXJzZU5hbWVzID0ge307XG5mb3IgKHZhciBuYW1lIGluIGNvbG9yTmFtZSQxKSB7XG4gICByZXZlcnNlTmFtZXNbY29sb3JOYW1lJDFbbmFtZV1dID0gbmFtZTtcbn1cblxuLyogTUlUIGxpY2Vuc2UgKi9cblxuXG5cbnZhciBDb2xvciA9IGZ1bmN0aW9uIChvYmopIHtcblx0aWYgKG9iaiBpbnN0YW5jZW9mIENvbG9yKSB7XG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29sb3IpKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihvYmopO1xuXHR9XG5cblx0dGhpcy52YWxpZCA9IGZhbHNlO1xuXHR0aGlzLnZhbHVlcyA9IHtcblx0XHRyZ2I6IFswLCAwLCAwXSxcblx0XHRoc2w6IFswLCAwLCAwXSxcblx0XHRoc3Y6IFswLCAwLCAwXSxcblx0XHRod2I6IFswLCAwLCAwXSxcblx0XHRjbXlrOiBbMCwgMCwgMCwgMF0sXG5cdFx0YWxwaGE6IDFcblx0fTtcblxuXHQvLyBwYXJzZSBDb2xvcigpIGFyZ3VtZW50XG5cdHZhciB2YWxzO1xuXHRpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcblx0XHR2YWxzID0gY29sb3JTdHJpbmcuZ2V0UmdiYShvYmopO1xuXHRcdGlmICh2YWxzKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzID0gY29sb3JTdHJpbmcuZ2V0SHNsYShvYmopKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzID0gY29sb3JTdHJpbmcuZ2V0SHdiKG9iaikpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCB2YWxzKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcblx0XHR2YWxzID0gb2JqO1xuXHRcdGlmICh2YWxzLnIgIT09IHVuZGVmaW5lZCB8fCB2YWxzLnJlZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLmwgIT09IHVuZGVmaW5lZCB8fCB2YWxzLmxpZ2h0bmVzcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLnYgIT09IHVuZGVmaW5lZCB8fCB2YWxzLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc3YnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMudyAhPT0gdW5kZWZpbmVkIHx8IHZhbHMud2hpdGVuZXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMuYyAhPT0gdW5kZWZpbmVkIHx8IHZhbHMuY3lhbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnY215aycsIHZhbHMpO1xuXHRcdH1cblx0fVxufTtcblxuQ29sb3IucHJvdG90eXBlID0ge1xuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsaWQ7XG5cdH0sXG5cdHJnYjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdyZ2InLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRoc2w6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnaHNsJywgYXJndW1lbnRzKTtcblx0fSxcblx0aHN2OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2hzdicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGh3YjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdod2InLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRjbXlrOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2NteWsnLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdHJnYkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLnJnYjtcblx0fSxcblx0aHNsQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuaHNsO1xuXHR9LFxuXHRoc3ZBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5oc3Y7XG5cdH0sXG5cdGh3YkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdGlmICh2YWx1ZXMuYWxwaGEgIT09IDEpIHtcblx0XHRcdHJldHVybiB2YWx1ZXMuaHdiLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZXMuaHdiO1xuXHR9LFxuXHRjbXlrQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuY215aztcblx0fSxcblx0cmdiYUFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdHJldHVybiB2YWx1ZXMucmdiLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdH0sXG5cdGhzbGFBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0XHRyZXR1cm4gdmFsdWVzLmhzbC5jb25jYXQoW3ZhbHVlcy5hbHBoYV0pO1xuXHR9LFxuXHRhbHBoYTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWVzLmFscGhhO1xuXHRcdH1cblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCB2YWwpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlZDogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ3JnYicsIDAsIHZhbCk7XG5cdH0sXG5cdGdyZWVuOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMSwgdmFsKTtcblx0fSxcblx0Ymx1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ3JnYicsIDIsIHZhbCk7XG5cdH0sXG5cdGh1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmICh2YWwpIHtcblx0XHRcdHZhbCAlPSAzNjA7XG5cdFx0XHR2YWwgPSB2YWwgPCAwID8gMzYwICsgdmFsIDogdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAwLCB2YWwpO1xuXHR9LFxuXHRzYXR1cmF0aW9uOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHNsJywgMSwgdmFsKTtcblx0fSxcblx0bGlnaHRuZXNzOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHNsJywgMiwgdmFsKTtcblx0fSxcblx0c2F0dXJhdGlvbnY6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc3YnLCAxLCB2YWwpO1xuXHR9LFxuXHR3aGl0ZW5lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdod2InLCAxLCB2YWwpO1xuXHR9LFxuXHRibGFja25lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdod2InLCAyLCB2YWwpO1xuXHR9LFxuXHR2YWx1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzdicsIDIsIHZhbCk7XG5cdH0sXG5cdGN5YW46IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMCwgdmFsKTtcblx0fSxcblx0bWFnZW50YTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAxLCB2YWwpO1xuXHR9LFxuXHR5ZWxsb3c6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMiwgdmFsKTtcblx0fSxcblx0YmxhY2s6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMywgdmFsKTtcblx0fSxcblxuXHRoZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaGV4U3RyaW5nKHRoaXMudmFsdWVzLnJnYik7XG5cdH0sXG5cdHJnYlN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5yZ2JTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdHJnYmFTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcucmdiYVN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0cGVyY2VudFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5wZXJjZW50U3RyaW5nKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRoc2xTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaHNsU3RyaW5nKHRoaXMudmFsdWVzLmhzbCwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRoc2xhU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLmhzbGFTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGh3YlN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5od2JTdHJpbmcodGhpcy52YWx1ZXMuaHdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGtleXdvcmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcua2V5d29yZCh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblxuXHRyZ2JOdW1iZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHJldHVybiAocmdiWzBdIDw8IDE2KSB8IChyZ2JbMV0gPDwgOCkgfCByZ2JbMl07XG5cdH0sXG5cblx0bHVtaW5vc2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHZhciBsdW0gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGNoYW4gPSByZ2JbaV0gLyAyNTU7XG5cdFx0XHRsdW1baV0gPSAoY2hhbiA8PSAwLjAzOTI4KSA/IGNoYW4gLyAxMi45MiA6IE1hdGgucG93KCgoY2hhbiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuMjEyNiAqIGx1bVswXSArIDAuNzE1MiAqIGx1bVsxXSArIDAuMDcyMiAqIGx1bVsyXTtcblx0fSxcblxuXHRjb250cmFzdDogZnVuY3Rpb24gKGNvbG9yMikge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jY29udHJhc3QtcmF0aW9kZWZcblx0XHR2YXIgbHVtMSA9IHRoaXMubHVtaW5vc2l0eSgpO1xuXHRcdHZhciBsdW0yID0gY29sb3IyLmx1bWlub3NpdHkoKTtcblx0XHRpZiAobHVtMSA+IGx1bTIpIHtcblx0XHRcdHJldHVybiAobHVtMSArIDAuMDUpIC8gKGx1bTIgKyAwLjA1KTtcblx0XHR9XG5cdFx0cmV0dXJuIChsdW0yICsgMC4wNSkgLyAobHVtMSArIDAuMDUpO1xuXHR9LFxuXG5cdGxldmVsOiBmdW5jdGlvbiAoY29sb3IyKSB7XG5cdFx0dmFyIGNvbnRyYXN0UmF0aW8gPSB0aGlzLmNvbnRyYXN0KGNvbG9yMik7XG5cdFx0aWYgKGNvbnRyYXN0UmF0aW8gPj0gNy4xKSB7XG5cdFx0XHRyZXR1cm4gJ0FBQSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChjb250cmFzdFJhdGlvID49IDQuNSkgPyAnQUEnIDogJyc7XG5cdH0sXG5cblx0ZGFyazogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFlJUSBlcXVhdGlvbiBmcm9tIGh0dHA6Ly8yNHdheXMub3JnLzIwMTAvY2FsY3VsYXRpbmctY29sb3ItY29udHJhc3Rcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHZhciB5aXEgPSAocmdiWzBdICogMjk5ICsgcmdiWzFdICogNTg3ICsgcmdiWzJdICogMTE0KSAvIDEwMDA7XG5cdFx0cmV0dXJuIHlpcSA8IDEyODtcblx0fSxcblxuXHRsaWdodDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5kYXJrKCk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2JbaV0gPSAyNTUgLSB0aGlzLnZhbHVlcy5yZ2JbaV07XG5cdFx0fVxuXHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCByZ2IpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGxpZ2h0ZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzJdICs9IGhzbFsyXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGRhcmtlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMl0gLT0gaHNsWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2F0dXJhdGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzFdICs9IGhzbFsxXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGRlc2F0dXJhdGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzFdIC09IGhzbFsxXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdoaXRlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGh3YiA9IHRoaXMudmFsdWVzLmh3Yjtcblx0XHRod2JbMV0gKz0gaHdiWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIGh3Yik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YmxhY2tlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGh3YiA9IHRoaXMudmFsdWVzLmh3Yjtcblx0XHRod2JbMl0gKz0gaHdiWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIGh3Yik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z3JleXNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcblx0XHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYXlzY2FsZSNDb252ZXJ0aW5nX2NvbG9yX3RvX2dyYXlzY2FsZVxuXHRcdHZhciB2YWwgPSByZ2JbMF0gKiAwLjMgKyByZ2JbMV0gKiAwLjU5ICsgcmdiWzJdICogMC4xMTtcblx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgW3ZhbCwgdmFsLCB2YWxdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbGVhcmVyOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgYWxwaGEgPSB0aGlzLnZhbHVlcy5hbHBoYTtcblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCBhbHBoYSAtIChhbHBoYSAqIHJhdGlvKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0b3BhcXVlcjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGFscGhhID0gdGhpcy52YWx1ZXMuYWxwaGE7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2FscGhhJywgYWxwaGEgKyAoYWxwaGEgKiByYXRpbykpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24gKGRlZ3JlZXMpIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdHZhciBodWUgPSAoaHNsWzBdICsgZGVncmVlcykgJSAzNjA7XG5cdFx0aHNsWzBdID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogUG9ydGVkIGZyb20gc2FzcyBpbXBsZW1lbnRhdGlvbiBpbiBDXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zYXNzL2xpYnNhc3MvYmxvYi8wZTZiNGEyODUwMDkyMzU2YWEzZWNlMDdjNmIyNDlmMDIyMWNhY2VkL2Z1bmN0aW9ucy5jcHAjTDIwOVxuXHQgKi9cblx0bWl4OiBmdW5jdGlvbiAobWl4aW5Db2xvciwgd2VpZ2h0KSB7XG5cdFx0dmFyIGNvbG9yMSA9IHRoaXM7XG5cdFx0dmFyIGNvbG9yMiA9IG1peGluQ29sb3I7XG5cdFx0dmFyIHAgPSB3ZWlnaHQgPT09IHVuZGVmaW5lZCA/IDAuNSA6IHdlaWdodDtcblxuXHRcdHZhciB3ID0gMiAqIHAgLSAxO1xuXHRcdHZhciBhID0gY29sb3IxLmFscGhhKCkgLSBjb2xvcjIuYWxwaGEoKTtcblxuXHRcdHZhciB3MSA9ICgoKHcgKiBhID09PSAtMSkgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuXHRcdHZhciB3MiA9IDEgLSB3MTtcblxuXHRcdHJldHVybiB0aGlzXG5cdFx0XHQucmdiKFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5yZWQoKSArIHcyICogY29sb3IyLnJlZCgpLFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5ncmVlbigpICsgdzIgKiBjb2xvcjIuZ3JlZW4oKSxcblx0XHRcdFx0dzEgKiBjb2xvcjEuYmx1ZSgpICsgdzIgKiBjb2xvcjIuYmx1ZSgpXG5cdFx0XHQpXG5cdFx0XHQuYWxwaGEoY29sb3IxLmFscGhhKCkgKiBwICsgY29sb3IyLmFscGhhKCkgKiAoMSAtIHApKTtcblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZ2IoKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIE5PVEUoU0IpOiB1c2luZyBub2RlLWNsb25lIGNyZWF0ZXMgYSBkZXBlbmRlbmN5IHRvIEJ1ZmZlciB3aGVuIHVzaW5nIGJyb3dzZXJpZnksXG5cdFx0Ly8gbWFraW5nIHRoZSBmaW5hbCBidWlsZCB3YXkgdG8gYmlnIHRvIGVtYmVkIGluIENoYXJ0LmpzLiBTbyBsZXQncyBkbyBpdCBtYW51YWxseSxcblx0XHQvLyBhc3N1bWluZyB0aGF0IHZhbHVlcyB0byBjbG9uZSBhcmUgMSBkaW1lbnNpb24gYXJyYXlzIGNvbnRhaW5pbmcgb25seSBudW1iZXJzLFxuXHRcdC8vIGV4Y2VwdCAnYWxwaGEnIHdoaWNoIGlzIGEgbnVtYmVyLlxuXHRcdHZhciByZXN1bHQgPSBuZXcgQ29sb3IoKTtcblx0XHR2YXIgc291cmNlID0gdGhpcy52YWx1ZXM7XG5cdFx0dmFyIHRhcmdldCA9IHJlc3VsdC52YWx1ZXM7XG5cdFx0dmFyIHZhbHVlLCB0eXBlO1xuXG5cdFx0Zm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcblx0XHRcdGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0dmFsdWUgPSBzb3VyY2VbcHJvcF07XG5cdFx0XHRcdHR5cGUgPSAoe30pLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuXHRcdFx0XHRcdHRhcmdldFtwcm9wXSA9IHZhbHVlLnNsaWNlKDApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcigndW5leHBlY3RlZCBjb2xvciB2YWx1ZTonLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc3BhY2VzID0ge1xuXHRyZ2I6IFsncmVkJywgJ2dyZWVuJywgJ2JsdWUnXSxcblx0aHNsOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcyddLFxuXHRoc3Y6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAndmFsdWUnXSxcblx0aHdiOiBbJ2h1ZScsICd3aGl0ZW5lc3MnLCAnYmxhY2tuZXNzJ10sXG5cdGNteWs6IFsnY3lhbicsICdtYWdlbnRhJywgJ3llbGxvdycsICdibGFjayddXG59O1xuXG5Db2xvci5wcm90b3R5cGUubWF4ZXMgPSB7XG5cdHJnYjogWzI1NSwgMjU1LCAyNTVdLFxuXHRoc2w6IFszNjAsIDEwMCwgMTAwXSxcblx0aHN2OiBbMzYwLCAxMDAsIDEwMF0sXG5cdGh3YjogWzM2MCwgMTAwLCAxMDBdLFxuXHRjbXlrOiBbMTAwLCAxMDAsIDEwMCwgMTAwXVxufTtcblxuQ29sb3IucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uIChzcGFjZSkge1xuXHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdHZhciB2YWxzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdHZhbHNbc3BhY2UuY2hhckF0KGkpXSA9IHZhbHVlc1tzcGFjZV1baV07XG5cdH1cblxuXHRpZiAodmFsdWVzLmFscGhhICE9PSAxKSB7XG5cdFx0dmFscy5hID0gdmFsdWVzLmFscGhhO1xuXHR9XG5cblx0Ly8ge3I6IDI1NSwgZzogMjU1LCBiOiAyNTUsIGE6IDAuNH1cblx0cmV0dXJuIHZhbHM7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24gKHNwYWNlLCB2YWxzKSB7XG5cdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0dmFyIHNwYWNlcyA9IHRoaXMuc3BhY2VzO1xuXHR2YXIgbWF4ZXMgPSB0aGlzLm1heGVzO1xuXHR2YXIgYWxwaGEgPSAxO1xuXHR2YXIgaTtcblxuXHR0aGlzLnZhbGlkID0gdHJ1ZTtcblxuXHRpZiAoc3BhY2UgPT09ICdhbHBoYScpIHtcblx0XHRhbHBoYSA9IHZhbHM7XG5cdH0gZWxzZSBpZiAodmFscy5sZW5ndGgpIHtcblx0XHQvLyBbMTAsIDEwLCAxMF1cblx0XHR2YWx1ZXNbc3BhY2VdID0gdmFscy5zbGljZSgwLCBzcGFjZS5sZW5ndGgpO1xuXHRcdGFscGhhID0gdmFsc1tzcGFjZS5sZW5ndGhdO1xuXHR9IGVsc2UgaWYgKHZhbHNbc3BhY2UuY2hhckF0KDApXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8ge3I6IDEwLCBnOiAxMCwgYjogMTB9XG5cdFx0Zm9yIChpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YWx1ZXNbc3BhY2VdW2ldID0gdmFsc1tzcGFjZS5jaGFyQXQoaSldO1xuXHRcdH1cblxuXHRcdGFscGhhID0gdmFscy5hO1xuXHR9IGVsc2UgaWYgKHZhbHNbc3BhY2VzW3NwYWNlXVswXV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIHtyZWQ6IDEwLCBncmVlbjogMTAsIGJsdWU6IDEwfVxuXHRcdHZhciBjaGFucyA9IHNwYWNlc1tzcGFjZV07XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhbHVlc1tzcGFjZV1baV0gPSB2YWxzW2NoYW5zW2ldXTtcblx0XHR9XG5cblx0XHRhbHBoYSA9IHZhbHMuYWxwaGE7XG5cdH1cblxuXHR2YWx1ZXMuYWxwaGEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoYWxwaGEgPT09IHVuZGVmaW5lZCA/IHZhbHVlcy5hbHBoYSA6IGFscGhhKSkpO1xuXG5cdGlmIChzcGFjZSA9PT0gJ2FscGhhJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBjYXBwZWQ7XG5cblx0Ly8gY2FwIHZhbHVlcyBvZiB0aGUgc3BhY2UgcHJpb3IgY29udmVydGluZyBhbGwgdmFsdWVzXG5cdGZvciAoaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdGNhcHBlZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heGVzW3NwYWNlXVtpXSwgdmFsdWVzW3NwYWNlXVtpXSkpO1xuXHRcdHZhbHVlc1tzcGFjZV1baV0gPSBNYXRoLnJvdW5kKGNhcHBlZCk7XG5cdH1cblxuXHQvLyBjb252ZXJ0IHRvIGFsbCB0aGUgb3RoZXIgY29sb3Igc3BhY2VzXG5cdGZvciAodmFyIHNuYW1lIGluIHNwYWNlcykge1xuXHRcdGlmIChzbmFtZSAhPT0gc3BhY2UpIHtcblx0XHRcdHZhbHVlc1tzbmFtZV0gPSBjb2xvckNvbnZlcnRbc3BhY2VdW3NuYW1lXSh2YWx1ZXNbc3BhY2VdKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRTcGFjZSA9IGZ1bmN0aW9uIChzcGFjZSwgYXJncykge1xuXHR2YXIgdmFscyA9IGFyZ3NbMF07XG5cblx0aWYgKHZhbHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIGNvbG9yLnJnYigpXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VmFsdWVzKHNwYWNlKTtcblx0fVxuXG5cdC8vIGNvbG9yLnJnYigxMCwgMTAsIDEwKVxuXHRpZiAodHlwZW9mIHZhbHMgPT09ICdudW1iZXInKSB7XG5cdFx0dmFscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuXHR9XG5cblx0dGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHZhbHMpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRDaGFubmVsID0gZnVuY3Rpb24gKHNwYWNlLCBpbmRleCwgdmFsKSB7XG5cdHZhciBzdmFsdWVzID0gdGhpcy52YWx1ZXNbc3BhY2VdO1xuXHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHQvLyBjb2xvci5yZWQoKVxuXHRcdHJldHVybiBzdmFsdWVzW2luZGV4XTtcblx0fSBlbHNlIGlmICh2YWwgPT09IHN2YWx1ZXNbaW5kZXhdKSB7XG5cdFx0Ly8gY29sb3IucmVkKGNvbG9yLnJlZCgpKVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gY29sb3IucmVkKDEwMClcblx0c3ZhbHVlc1tpbmRleF0gPSB2YWw7XG5cdHRoaXMuc2V0VmFsdWVzKHNwYWNlLCBzdmFsdWVzKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHR3aW5kb3cuQ29sb3IgPSBDb2xvcjtcbn1cblxudmFyIGNoYXJ0anNDb2xvciA9IENvbG9yO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVyc1xuICovXG52YXIgaGVscGVycyA9IHtcblx0LyoqXG5cdCAqIEFuIGVtcHR5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBmb3Igb3B0aW9uYWwgY2FsbGJhY2suXG5cdCAqL1xuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdW5pcXVlIGlkLCBzZXF1ZW50aWFsbHkgZ2VuZXJhdGVkIGZyb20gYSBnbG9iYWwgdmFyaWFibGUuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0dWlkOiAoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlkID0gMDtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gaWQrKztcblx0XHR9O1xuXHR9KCkpLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBuZWl0aGVyIG51bGwgbm9yIHVuZGVmaW5lZCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGlzTnVsbE9yVW5kZWY6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IChpbmNsdWRpbmcgdHlwZWQgYXJyYXlzKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGlzQXJyYXk6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHR2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdFx0aWYgKHR5cGUuc3Vic3RyKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zdWJzdHIoLTYpID09PSAnQXJyYXldJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IChleGNsdWRpbmcgbnVsbCksIGVsc2UgcmV0dXJucyBmYWxzZS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRpc09iamVjdDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSByZXR1cm5zIGZhbHNlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNGaW5pdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHZhbHVlYCBpZiBkZWZpbmVkLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGRlZmluZWQuXG5cdCAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVgIGlzIHVuZGVmaW5lZC5cblx0ICogQHJldHVybnMgeyp9XG5cdCAqL1xuXHR2YWx1ZU9yRGVmYXVsdDogZnVuY3Rpb24odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdmFsdWUgYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gYXJyYXkgaWYgZGVmaW5lZCwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuXHQgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSAtIFRoZSBhcnJheSB0byBsb29rdXAgZm9yIHZhbHVlIGF0IGBpbmRleGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbiBgdmFsdWVgIHRvIGxvb2t1cCBmb3IgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVbaW5kZXhdYCBpcyB1bmRlZmluZWQuXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0dmFsdWVBdEluZGV4T3JEZWZhdWx0OiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdHJldHVybiBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KGhlbHBlcnMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVtpbmRleF0gOiB2YWx1ZSwgZGVmYXVsdFZhbHVlKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2FsbHMgYGZuYCB3aXRoIHRoZSBnaXZlbiBgYXJnc2AgaW4gdGhlIHNjb3BlIGRlZmluZWQgYnkgYHRoaXNBcmdgIGFuZCByZXR1cm5zIHRoZVxuXHQgKiB2YWx1ZSByZXR1cm5lZCBieSBgZm5gLiBJZiBgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uLCB0aGlzIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZC5cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cblx0ICogQHBhcmFtIHtBcnJheXx1bmRlZmluZWR8bnVsbH0gYXJncyAtIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCBgZm5gIHNob3VsZCBiZSBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGNhbGxiYWNrOiBmdW5jdGlvbihmbiwgYXJncywgdGhpc0FyZykge1xuXHRcdGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTm90ZShTQikgZm9yIHBlcmZvcm1hbmNlIHNha2UsIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBsb29wYWJsZSB0eXBlXG5cdCAqIGlzIHVua25vd24gb3IgaW4gbm9uZSBpbnRlbnNpdmUgY29kZSAobm90IGNhbGxlZCBvZnRlbiBhbmQgc21hbGwgbG9vcGFibGUpLiBFbHNlXG5cdCAqIGl0J3MgcHJlZmVyYWJsZSB0byB1c2UgYSByZWd1bGFyIGZvcigpIGxvb3AgYW5kIHNhdmUgZXh0cmEgZnVuY3Rpb24gY2FsbHMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fSBsb29wYWJsZSAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgaXRlcmF0ZWQuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaXRlbS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIC0gSWYgdHJ1ZSwgaXRlcmF0ZXMgYmFja3dhcmQgb24gdGhlIGxvb3BhYmxlLlxuXHQgKi9cblx0ZWFjaDogZnVuY3Rpb24obG9vcGFibGUsIGZuLCB0aGlzQXJnLCByZXZlcnNlKSB7XG5cdFx0dmFyIGksIGxlbiwga2V5cztcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KGxvb3BhYmxlKSkge1xuXHRcdFx0bGVuID0gbG9vcGFibGUubGVuZ3RoO1xuXHRcdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdFx0Zm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGhlbHBlcnMuaXNPYmplY3QobG9vcGFibGUpKSB7XG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuXHRcdFx0bGVuID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNDg1Mzk3NFxuXHQgKiBAcGFyYW0ge0FycmF5fSBhMCAtIFRoZSBhcnJheSB0byBjb21wYXJlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGExIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRhcnJheUVxdWFsczogZnVuY3Rpb24oYTAsIGExKSB7XG5cdFx0dmFyIGksIGlsZW4sIHYwLCB2MTtcblxuXHRcdGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0djAgPSBhMFtpXTtcblx0XHRcdHYxID0gYTFbaV07XG5cblx0XHRcdGlmICh2MCBpbnN0YW5jZW9mIEFycmF5ICYmIHYxIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0aWYgKCFoZWxwZXJzLmFycmF5RXF1YWxzKHYwLCB2MSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodjAgIT09IHYxKSB7XG5cdFx0XHRcdC8vIE5PVEU6IHR3byBkaWZmZXJlbnQgb2JqZWN0IGluc3RhbmNlcyB3aWxsIG5ldmVyIGJlIGVxdWFsOiB7eDoyMH0gIT0ge3g6MjB9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGRlZXAgY29weSBvZiBgc291cmNlYCB3aXRob3V0IGtlZXBpbmcgcmVmZXJlbmNlcyBvbiBvYmplY3RzIGFuZCBhcnJheXMuXG5cdCAqIEBwYXJhbSB7Kn0gc291cmNlIC0gVGhlIHZhbHVlIHRvIGNsb25lLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGNsb25lOiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KHNvdXJjZSkpIHtcblx0XHRcdHJldHVybiBzb3VyY2UubWFwKGhlbHBlcnMuY2xvbmUpO1xuXHRcdH1cblxuXHRcdGlmIChoZWxwZXJzLmlzT2JqZWN0KHNvdXJjZSkpIHtcblx0XHRcdHZhciB0YXJnZXQgPSB7fTtcblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblx0XHRcdHZhciBrbGVuID0ga2V5cy5sZW5ndGg7XG5cdFx0XHR2YXIgayA9IDA7XG5cblx0XHRcdGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG5cdFx0XHRcdHRhcmdldFtrZXlzW2tdXSA9IGhlbHBlcnMuY2xvbmUoc291cmNlW2tleXNba11dKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gc291cmNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCBtZXJnZXIgd2hlbiBDaGFydC5oZWxwZXJzLm1lcmdlIGlzIGNhbGxlZCB3aXRob3V0IG1lcmdlciBvcHRpb24uXG5cdCAqIE5vdGUoU0IpOiBhbHNvIHVzZWQgYnkgbWVyZ2VDb25maWcgYW5kIG1lcmdlU2NhbGVDb25maWcgYXMgZmFsbGJhY2suXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfbWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XTtcblx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodHZhbCkgJiYgaGVscGVycy5pc09iamVjdChzdmFsKSkge1xuXHRcdFx0aGVscGVycy5tZXJnZSh0dmFsLCBzdmFsLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzLmNsb25lKHN2YWwpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTWVyZ2VzIHNvdXJjZVtrZXldIGluIHRhcmdldFtrZXldIG9ubHkgaWYgdGFyZ2V0W2tleV0gaXMgdW5kZWZpbmVkLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X21lcmdlcklmOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlKSB7XG5cdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XTtcblx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodHZhbCkgJiYgaGVscGVycy5pc09iamVjdChzdmFsKSkge1xuXHRcdFx0aGVscGVycy5tZXJnZUlmKHR2YWwsIHN2YWwpO1xuXHRcdH0gZWxzZSBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHR0YXJnZXRba2V5XSA9IGhlbHBlcnMuY2xvbmUoc3ZhbCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWN1cnNpdmVseSBkZWVwIGNvcGllcyBgc291cmNlYCBwcm9wZXJ0aWVzIGludG8gYHRhcmdldGAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuXHQgKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE1lcmdpbmcgb3B0aW9uczpcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMubWVyZ2VyXSAtIFRoZSBtZXJnZSBtZXRob2QgKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBgdGFyZ2V0YCBvYmplY3QuXG5cdCAqL1xuXHRtZXJnZTogZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHR2YXIgc291cmNlcyA9IGhlbHBlcnMuaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG5cdFx0dmFyIGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcblx0XHR2YXIgbWVyZ2UsIGksIGtleXMsIGtsZW4sIGs7XG5cblx0XHRpZiAoIWhlbHBlcnMuaXNPYmplY3QodGFyZ2V0KSkge1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRtZXJnZSA9IG9wdGlvbnMubWVyZ2VyIHx8IGhlbHBlcnMuX21lcmdlcjtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHNvdXJjZSA9IHNvdXJjZXNbaV07XG5cdFx0XHRpZiAoIWhlbHBlcnMuaXNPYmplY3Qoc291cmNlKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cdFx0XHRmb3IgKGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcblx0XHRcdFx0bWVyZ2Uoa2V5c1trXSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCAqb25seSogaWYgbm90IGRlZmluZWQgaW4gdGFyZ2V0LlxuXHQgKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cblx0ICovXG5cdG1lcmdlSWY6IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMubWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IGhlbHBlcnMuX21lcmdlcklmfSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGNvbnRlbnRzIG9mIHR3byBvciBtb3JlIG9iamVjdHMgdG9nZXRoZXIgaW50byB0aGUgZmlyc3Qgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIG9iamVjdHMgYXJlIG1lcmdlZCBpbnRvLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJnMSAtIE9iamVjdCBjb250YWluaW5nIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBtZXJnZSBpbiB0YXJnZXQuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmdOIC0gQWRkaXRpb25hbCBvYmplY3RzIGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBtZXJnZSBpbiB0YXJnZXQuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBgdGFyZ2V0YCBvYmplY3QuXG5cdCAqL1xuXHRleHRlbmQ6IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMubWVyZ2UodGFyZ2V0LCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIHtcblx0XHRcdG1lcmdlcjogZnVuY3Rpb24oa2V5LCBkc3QsIHNyYykge1xuXHRcdFx0XHRkc3Rba2V5XSA9IHNyY1trZXldO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBCYXNpYyBqYXZhc2NyaXB0IGluaGVyaXRhbmNlIGJhc2VkIG9uIHRoZSBtb2RlbCBjcmVhdGVkIGluIEJhY2tib25lLmpzXG5cdCAqL1xuXHRpbmhlcml0czogZnVuY3Rpb24oZXh0ZW5zaW9ucykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIENoYXJ0RWxlbWVudCA9IChleHRlbnNpb25zICYmIGV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkoJ2NvbnN0cnVjdG9yJykpID8gZXh0ZW5zaW9ucy5jb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuY29uc3RydWN0b3IgPSBDaGFydEVsZW1lbnQ7XG5cdFx0fTtcblxuXHRcdFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBtZS5wcm90b3R5cGU7XG5cdFx0Q2hhcnRFbGVtZW50LnByb3RvdHlwZSA9IG5ldyBTdXJyb2dhdGUoKTtcblx0XHRDaGFydEVsZW1lbnQuZXh0ZW5kID0gaGVscGVycy5pbmhlcml0cztcblxuXHRcdGlmIChleHRlbnNpb25zKSB7XG5cdFx0XHRoZWxwZXJzLmV4dGVuZChDaGFydEVsZW1lbnQucHJvdG90eXBlLCBleHRlbnNpb25zKTtcblx0XHR9XG5cblx0XHRDaGFydEVsZW1lbnQuX19zdXBlcl9fID0gbWUucHJvdG90eXBlO1xuXHRcdHJldHVybiBDaGFydEVsZW1lbnQ7XG5cdH0sXG5cblx0X2RlcHJlY2F0ZWQ6IGZ1bmN0aW9uKHNjb3BlLCB2YWx1ZSwgcHJldmlvdXMsIGN1cnJlbnQpIHtcblx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uc29sZS53YXJuKHNjb3BlICsgJzogXCInICsgcHJldmlvdXMgK1xuXHRcdFx0XHQnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBoZWxwZXJzX2NvcmUgPSBoZWxwZXJzO1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FsbGJhY2sgaW5zdGVhZC5cbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmNhbGxDYWxsYmFja1xuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5jYWxsQ2FsbGJhY2sgPSBoZWxwZXJzLmNhbGxiYWNrO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgaW5zdGVhZC5cbiAqIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIGNvbXBhdGliaWxpdHk6IENocm9tZSwgT3BlcmEsIFNhZmFyaSwgRkYxLjUrLCBJRTkrXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5pbmRleE9mXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgZnJvbUluZGV4KSB7XG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGFycmF5LCBpdGVtLCBmcm9tSW5kZXgpO1xufTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMudmFsdWVPckRlZmF1bHQgaW5zdGVhZC5cbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0ID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdDtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0IGluc3RlYWQuXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0ID0gaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQ7XG5cbi8qKlxuICogRWFzaW5nIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb20gUm9iZXJ0IFBlbm5lcidzIGVhc2luZyBlcXVhdGlvbnMuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuZWFzaW5nRWZmZWN0c1xuICogQHNlZSBodHRwOi8vd3d3LnJvYmVydHBlbm5lci5jb20vZWFzaW5nL1xuICovXG52YXIgZWZmZWN0cyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIHQ7XG5cdH0sXG5cblx0ZWFzZUluUXVhZDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdDtcblx0fSxcblxuXHRlYXNlT3V0UXVhZDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtdCAqICh0IC0gMik7XG5cdH0sXG5cblx0ZWFzZUluT3V0UXVhZDogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gLTAuNSAqICgoLS10KSAqICh0IC0gMikgLSAxKTtcblx0fSxcblxuXHRlYXNlSW5DdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdCAqIHQ7XG5cdH0sXG5cblx0ZWFzZU91dEN1YmljOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuICh0ID0gdCAtIDEpICogdCAqIHQgKyAxO1xuXHR9LFxuXG5cdGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKyAyKTtcblx0fSxcblxuXHRlYXNlSW5RdWFydDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdCAqIHQgKiB0O1xuXHR9LFxuXG5cdGVhc2VPdXRRdWFydDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtKCh0ID0gdCAtIDEpICogdCAqIHQgKiB0IC0gMSk7XG5cdH0sXG5cblx0ZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiB0ICogdCAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gLTAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAtIDIpO1xuXHR9LFxuXG5cdGVhc2VJblF1aW50OiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xuXHR9LFxuXG5cdGVhc2VPdXRRdWludDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxO1xuXHR9LFxuXG5cdGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdCAqIHQ7XG5cdFx0fVxuXHRcdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMik7XG5cdH0sXG5cblx0ZWFzZUluU2luZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtTWF0aC5jb3ModCAqIChNYXRoLlBJIC8gMikpICsgMTtcblx0fSxcblxuXHRlYXNlT3V0U2luZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiBNYXRoLnNpbih0ICogKE1hdGguUEkgLyAyKSk7XG5cdH0sXG5cblx0ZWFzZUluT3V0U2luZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtMC41ICogKE1hdGguY29zKE1hdGguUEkgKiB0KSAtIDEpO1xuXHR9LFxuXG5cdGVhc2VJbkV4cG86IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gKHQgPT09IDApID8gMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG5cdH0sXG5cblx0ZWFzZU91dEV4cG86IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gKHQgPT09IDEpID8gMSA6IC1NYXRoLnBvdygyLCAtMTAgKiB0KSArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0RXhwbzogZnVuY3Rpb24odCkge1xuXHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0aWYgKHQgPT09IDEpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAtLXQpICsgMik7XG5cdH0sXG5cblx0ZWFzZUluQ2lyYzogZnVuY3Rpb24odCkge1xuXHRcdGlmICh0ID49IDEpIHtcblx0XHRcdHJldHVybiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xuXHR9LFxuXG5cdGVhc2VPdXRDaXJjOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCgxIC0gKHQgPSB0IC0gMSkgKiB0KTtcblx0fSxcblxuXHRlYXNlSW5PdXRDaXJjOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpO1xuXHR9LFxuXG5cdGVhc2VJbkVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0dmFyIHAgPSAwO1xuXHRcdHZhciBhID0gMTtcblx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCFwKSB7XG5cdFx0XHRwID0gMC4zO1xuXHRcdH1cblx0XHRpZiAoYSA8IDEpIHtcblx0XHRcdGEgPSAxO1xuXHRcdFx0cyA9IHAgLyA0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcblx0fSxcblxuXHRlYXNlT3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHR2YXIgcCA9IDA7XG5cdFx0dmFyIGEgPSAxO1xuXHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0aWYgKHQgPT09IDEpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRpZiAoIXApIHtcblx0XHRcdHAgPSAwLjM7XG5cdFx0fVxuXHRcdGlmIChhIDwgMSkge1xuXHRcdFx0YSA9IDE7XG5cdFx0XHRzID0gcCAvIDQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XG5cdFx0fVxuXHRcdHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRFbGFzdGljOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHZhciBwID0gMDtcblx0XHR2YXIgYSA9IDE7XG5cdFx0aWYgKHQgPT09IDApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XHRpZiAoKHQgLz0gMC41KSA9PT0gMikge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdGlmICghcCkge1xuXHRcdFx0cCA9IDAuNDU7XG5cdFx0fVxuXHRcdGlmIChhIDwgMSkge1xuXHRcdFx0YSA9IDE7XG5cdFx0XHRzID0gcCAvIDQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XG5cdFx0fVxuXHRcdGlmICh0IDwgMSkge1xuXHRcdFx0cmV0dXJuIC0wLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG5cdFx0fVxuXHRcdHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG5cdH0sXG5cdGVhc2VJbkJhY2s6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0cmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG5cdH0sXG5cblx0ZWFzZU91dEJhY2s6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0cmV0dXJuICh0ID0gdCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRCYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSk7XG5cdFx0fVxuXHRcdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMik7XG5cdH0sXG5cblx0ZWFzZUluQm91bmNlOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIDEgLSBlZmZlY3RzLmVhc2VPdXRCb3VuY2UoMSAtIHQpO1xuXHR9LFxuXG5cdGVhc2VPdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA8ICgxIC8gMi43NSkpIHtcblx0XHRcdHJldHVybiA3LjU2MjUgKiB0ICogdDtcblx0XHR9XG5cdFx0aWYgKHQgPCAoMiAvIDIuNzUpKSB7XG5cdFx0XHRyZXR1cm4gNy41NjI1ICogKHQgLT0gKDEuNSAvIDIuNzUpKSAqIHQgKyAwLjc1O1xuXHRcdH1cblx0XHRpZiAodCA8ICgyLjUgLyAyLjc1KSkge1xuXHRcdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgyLjI1IC8gMi43NSkpICogdCArIDAuOTM3NTtcblx0XHR9XG5cdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgyLjYyNSAvIDIuNzUpKSAqIHQgKyAwLjk4NDM3NTtcblx0fSxcblxuXHRlYXNlSW5PdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA8IDAuNSkge1xuXHRcdFx0cmV0dXJuIGVmZmVjdHMuZWFzZUluQm91bmNlKHQgKiAyKSAqIDAuNTtcblx0XHR9XG5cdFx0cmV0dXJuIGVmZmVjdHMuZWFzZU91dEJvdW5jZSh0ICogMiAtIDEpICogMC41ICsgMC41O1xuXHR9XG59O1xuXG52YXIgaGVscGVyc19lYXNpbmcgPSB7XG5cdGVmZmVjdHM6IGVmZmVjdHNcbn07XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5lYXNpbmcuZWZmZWN0cyBpbnN0ZWFkLlxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuZWFzaW5nRWZmZWN0c1xuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVyc19jb3JlLmVhc2luZ0VmZmVjdHMgPSBlZmZlY3RzO1xuXG52YXIgUEkgPSBNYXRoLlBJO1xudmFyIFJBRF9QRVJfREVHID0gUEkgLyAxODA7XG52YXIgRE9VQkxFX1BJID0gUEkgKiAyO1xudmFyIEhBTEZfUEkgPSBQSSAvIDI7XG52YXIgUVVBUlRFUl9QSSA9IFBJIC8gNDtcbnZhciBUV09fVEhJUkRTX1BJID0gUEkgKiAyIC8gMztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuY2FudmFzXG4gKi9cbnZhciBleHBvcnRzJDEgPSB7XG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIGVudGlyZSBjYW52YXMgYXNzb2NpYXRlZCB0byB0aGUgZ2l2ZW4gYGNoYXJ0YC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgZm9yIHdoaWNoIHRvIGNsZWFyIHRoZSBjYW52YXMuXG5cdCAqL1xuXHRjbGVhcjogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRjaGFydC5jdHguY2xlYXJSZWN0KDAsIDAsIGNoYXJ0LndpZHRoLCBjaGFydC5oZWlnaHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgXCJwYXRoXCIgZm9yIGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzIGF0IHBvc2l0aW9uICh4LCB5KSB3aXRoIGFcblx0ICogZ2l2ZW4gc2l6ZSAod2lkdGgsIGhlaWdodCkgYW5kIHRoZSBzYW1lIGByYWRpdXNgIGZvciBhbGwgY29ybmVycy5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIFRoZSBjYW52YXMgMkQgQ29udGV4dC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBheGlzIG9mIHRoZSBjb29yZGluYXRlIGZvciB0aGUgcmVjdGFuZ2xlIHN0YXJ0aW5nIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGF4aXMgb2YgdGhlIGNvb3JkaW5hdGUgZm9yIHRoZSByZWN0YW5nbGUgc3RhcnRpbmcgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSByZWN0YW5nbGUncyB3aWR0aC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSByZWN0YW5nbGUncyBoZWlnaHQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgcm91bmRlZCBhbW91bnQgKGluIHBpeGVscykgZm9yIHRoZSBmb3VyIGNvcm5lcnMuXG5cdCAqIEB0b2RvIGhhbmRsZSBgcmFkaXVzYCBhcyB0b3AtbGVmdCwgdG9wLXJpZ2h0LCBib3R0b20tcmlnaHQsIGJvdHRvbS1sZWZ0IGFycmF5L29iamVjdD9cblx0ICovXG5cdHJvdW5kZWRSZWN0OiBmdW5jdGlvbihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuXHRcdGlmIChyYWRpdXMpIHtcblx0XHRcdHZhciByID0gTWF0aC5taW4ocmFkaXVzLCBoZWlnaHQgLyAyLCB3aWR0aCAvIDIpO1xuXHRcdFx0dmFyIGxlZnQgPSB4ICsgcjtcblx0XHRcdHZhciB0b3AgPSB5ICsgcjtcblx0XHRcdHZhciByaWdodCA9IHggKyB3aWR0aCAtIHI7XG5cdFx0XHR2YXIgYm90dG9tID0geSArIGhlaWdodCAtIHI7XG5cblx0XHRcdGN0eC5tb3ZlVG8oeCwgdG9wKTtcblx0XHRcdGlmIChsZWZ0IDwgcmlnaHQgJiYgdG9wIDwgYm90dG9tKSB7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgdG9wLCByLCAtUEksIC1IQUxGX1BJKTtcblx0XHRcdFx0Y3R4LmFyYyhyaWdodCwgdG9wLCByLCAtSEFMRl9QSSwgMCk7XG5cdFx0XHRcdGN0eC5hcmMocmlnaHQsIGJvdHRvbSwgciwgMCwgSEFMRl9QSSk7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCBIQUxGX1BJLCBQSSk7XG5cdFx0XHR9IGVsc2UgaWYgKGxlZnQgPCByaWdodCkge1xuXHRcdFx0XHRjdHgubW92ZVRvKGxlZnQsIHkpO1xuXHRcdFx0XHRjdHguYXJjKHJpZ2h0LCB0b3AsIHIsIC1IQUxGX1BJLCBIQUxGX1BJKTtcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCB0b3AsIHIsIEhBTEZfUEksIFBJICsgSEFMRl9QSSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRvcCA8IGJvdHRvbSkge1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIHRvcCwgciwgLVBJLCAwKTtcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCBib3R0b20sIHIsIDAsIFBJKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgdG9wLCByLCAtUEksIFBJKTtcblx0XHRcdH1cblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGN0eC5tb3ZlVG8oeCwgeSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXHRcdH1cblx0fSxcblxuXHRkcmF3UG9pbnQ6IGZ1bmN0aW9uKGN0eCwgc3R5bGUsIHJhZGl1cywgeCwgeSwgcm90YXRpb24pIHtcblx0XHR2YXIgdHlwZSwgeE9mZnNldCwgeU9mZnNldCwgc2l6ZSwgY29ybmVyUmFkaXVzO1xuXHRcdHZhciByYWQgPSAocm90YXRpb24gfHwgMCkgKiBSQURfUEVSX0RFRztcblxuXHRcdGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHR0eXBlID0gc3R5bGUudG9TdHJpbmcoKTtcblx0XHRcdGlmICh0eXBlID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJykge1xuXHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRjdHgudHJhbnNsYXRlKHgsIHkpO1xuXHRcdFx0XHRjdHgucm90YXRlKHJhZCk7XG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2Uoc3R5bGUsIC1zdHlsZS53aWR0aCAvIDIsIC1zdHlsZS5oZWlnaHQgLyAyLCBzdHlsZS53aWR0aCwgc3R5bGUuaGVpZ2h0KTtcblx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0c3dpdGNoIChzdHlsZSkge1xuXHRcdC8vIERlZmF1bHQgaW5jbHVkZXMgY2lyY2xlXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBET1VCTEVfUEkpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAndHJpYW5nbGUnOlxuXHRcdFx0Y3R4Lm1vdmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuXHRcdFx0cmFkICs9IFRXT19USElSRFNfUEk7XG5cdFx0XHRjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG5cdFx0XHRyYWQgKz0gVFdPX1RISVJEU19QSTtcblx0XHRcdGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3JlY3RSb3VuZGVkJzpcblx0XHRcdC8vIE5PVEU6IHRoZSByb3VuZGVkIHJlY3QgaW1wbGVtZW50YXRpb24gY2hhbmdlZCB0byB1c2UgYGFyY2AgaW5zdGVhZCBvZlxuXHRcdFx0Ly8gYHF1YWRyYXRpY0N1cnZlVG9gIHNpbmNlIGl0IGdlbmVyYXRlcyBiZXR0ZXIgcmVzdWx0cyB3aGVuIHJlY3QgaXNcblx0XHRcdC8vIGFsbW9zdCBhIGNpcmNsZS4gMC41MTYgKGluc3RlYWQgb2YgMC41KSBwcm9kdWNlcyByZXN1bHRzIHdpdGggdmlzdWFsbHlcblx0XHRcdC8vIGNsb3NlciBwcm9wb3J0aW9uIHRvIHRoZSBwcmV2aW91cyBpbXBsIGFuZCBpdCBpcyBpbnNjcmliZWQgaW4gdGhlXG5cdFx0XHQvLyBjaXJjbGUgd2l0aCBgcmFkaXVzYC4gRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSBmb2xsb3dpbmcgUFJzOlxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU1OTdcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81ODU4XG5cdFx0XHRjb3JuZXJSYWRpdXMgPSByYWRpdXMgKiAwLjUxNjtcblx0XHRcdHNpemUgPSByYWRpdXMgLSBjb3JuZXJSYWRpdXM7XG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcblx0XHRcdGN0eC5hcmMoeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIFBJLCByYWQgLSBIQUxGX1BJKTtcblx0XHRcdGN0eC5hcmMoeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIEhBTEZfUEksIHJhZCk7XG5cdFx0XHRjdHguYXJjKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQsIHJhZCArIEhBTEZfUEkpO1xuXHRcdFx0Y3R4LmFyYyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkICsgSEFMRl9QSSwgcmFkICsgUEkpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAncmVjdCc6XG5cdFx0XHRpZiAoIXJvdGF0aW9uKSB7XG5cdFx0XHRcdHNpemUgPSBNYXRoLlNRUlQxXzIgKiByYWRpdXM7XG5cdFx0XHRcdGN0eC5yZWN0KHggLSBzaXplLCB5IC0gc2l6ZSwgMiAqIHNpemUsIDIgKiBzaXplKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyYWQgKz0gUVVBUlRFUl9QSTtcblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRjYXNlICdyZWN0Um90Jzpcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdjcm9zc1JvdCc6XG5cdFx0XHRyYWQgKz0gUVVBUlRFUl9QSTtcblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRjYXNlICdjcm9zcyc6XG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnc3Rhcic6XG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuXHRcdFx0cmFkICs9IFFVQVJURVJfUEk7XG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbGluZSc6XG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnZGFzaCc6XG5cdFx0XHRjdHgubW92ZVRvKHgsIHkpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgTWF0aC5jb3MocmFkKSAqIHJhZGl1cywgeSArIE1hdGguc2luKHJhZCkgKiByYWRpdXMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0Y3R4LmZpbGwoKTtcblx0XHRjdHguc3Ryb2tlKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSByZWN0YW5nbGVcblx0ICogQHBhcmFtIHtvYmplY3R9IHBvaW50IC0gVGhlIHBvaW50IHRvIHRlc3Rcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZWEgLSBUaGUgcmVjdGFuZ2xlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2lzUG9pbnRJbkFyZWE6IGZ1bmN0aW9uKHBvaW50LCBhcmVhKSB7XG5cdFx0dmFyIGVwc2lsb24gPSAxZS02OyAvLyAxZS02IGlzIG1hcmdpbiBpbiBwaXhlbHMgZm9yIGFjY3VtdWxhdGVkIGVycm9yLlxuXG5cdFx0cmV0dXJuIHBvaW50LnggPiBhcmVhLmxlZnQgLSBlcHNpbG9uICYmIHBvaW50LnggPCBhcmVhLnJpZ2h0ICsgZXBzaWxvbiAmJlxuXHRcdFx0cG9pbnQueSA+IGFyZWEudG9wIC0gZXBzaWxvbiAmJiBwb2ludC55IDwgYXJlYS5ib3R0b20gKyBlcHNpbG9uO1xuXHR9LFxuXG5cdGNsaXBBcmVhOiBmdW5jdGlvbihjdHgsIGFyZWEpIHtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgucmVjdChhcmVhLmxlZnQsIGFyZWEudG9wLCBhcmVhLnJpZ2h0IC0gYXJlYS5sZWZ0LCBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcblx0XHRjdHguY2xpcCgpO1xuXHR9LFxuXG5cdHVuY2xpcEFyZWE6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH0sXG5cblx0bGluZVRvOiBmdW5jdGlvbihjdHgsIHByZXZpb3VzLCB0YXJnZXQsIGZsaXApIHtcblx0XHR2YXIgc3RlcHBlZCA9IHRhcmdldC5zdGVwcGVkTGluZTtcblx0XHRpZiAoc3RlcHBlZCkge1xuXHRcdFx0aWYgKHN0ZXBwZWQgPT09ICdtaWRkbGUnKSB7XG5cdFx0XHRcdHZhciBtaWRwb2ludCA9IChwcmV2aW91cy54ICsgdGFyZ2V0LngpIC8gMi4wO1xuXHRcdFx0XHRjdHgubGluZVRvKG1pZHBvaW50LCBmbGlwID8gdGFyZ2V0LnkgOiBwcmV2aW91cy55KTtcblx0XHRcdFx0Y3R4LmxpbmVUbyhtaWRwb2ludCwgZmxpcCA/IHByZXZpb3VzLnkgOiB0YXJnZXQueSk7XG5cdFx0XHR9IGVsc2UgaWYgKChzdGVwcGVkID09PSAnYWZ0ZXInICYmICFmbGlwKSB8fCAoc3RlcHBlZCAhPT0gJ2FmdGVyJyAmJiBmbGlwKSkge1xuXHRcdFx0XHRjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5saW5lVG8odGFyZ2V0LngsIHByZXZpb3VzLnkpO1xuXHRcdFx0fVxuXHRcdFx0Y3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGFyZ2V0LnRlbnNpb24pIHtcblx0XHRcdGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjdHguYmV6aWVyQ3VydmVUbyhcblx0XHRcdGZsaXAgPyBwcmV2aW91cy5jb250cm9sUG9pbnRQcmV2aW91c1ggOiBwcmV2aW91cy5jb250cm9sUG9pbnROZXh0WCxcblx0XHRcdGZsaXAgPyBwcmV2aW91cy5jb250cm9sUG9pbnRQcmV2aW91c1kgOiBwcmV2aW91cy5jb250cm9sUG9pbnROZXh0WSxcblx0XHRcdGZsaXAgPyB0YXJnZXQuY29udHJvbFBvaW50TmV4dFggOiB0YXJnZXQuY29udHJvbFBvaW50UHJldmlvdXNYLFxuXHRcdFx0ZmxpcCA/IHRhcmdldC5jb250cm9sUG9pbnROZXh0WSA6IHRhcmdldC5jb250cm9sUG9pbnRQcmV2aW91c1ksXG5cdFx0XHR0YXJnZXQueCxcblx0XHRcdHRhcmdldC55KTtcblx0fVxufTtcblxudmFyIGhlbHBlcnNfY2FudmFzID0gZXhwb3J0cyQxO1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FudmFzLmNsZWFyIGluc3RlYWQuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuY2xlYXJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnNfY29yZS5jbGVhciA9IGV4cG9ydHMkMS5jbGVhcjtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FudmFzLnJvdW5kZWRSZWN0IGluc3RlYWQuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuZHJhd1JvdW5kZWRSZWN0YW5nbGVcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnNfY29yZS5kcmF3Um91bmRlZFJlY3RhbmdsZSA9IGZ1bmN0aW9uKGN0eCkge1xuXHRjdHguYmVnaW5QYXRoKCk7XG5cdGV4cG9ydHMkMS5yb3VuZGVkUmVjdC5hcHBseShleHBvcnRzJDEsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgZGVmYXVsdHMgPSB7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3NldDogZnVuY3Rpb24oc2NvcGUsIHZhbHVlcykge1xuXHRcdHJldHVybiBoZWxwZXJzX2NvcmUubWVyZ2UodGhpc1tzY29wZV0gfHwgKHRoaXNbc2NvcGVdID0ge30pLCB2YWx1ZXMpO1xuXHR9XG59O1xuXG4vLyBUT0RPKHYzKTogcmVtb3ZlICdnbG9iYWwnIGZyb20gbmFtZXNwYWNlLiAgYWxsIGRlZmF1bHQgYXJlIGdsb2JhbCBhbmRcbi8vIHRoZXJlJ3MgaW5jb25zaXN0ZW5jeSBhcm91bmQgd2hpY2ggb3B0aW9ucyBhcmUgdW5kZXIgJ2dsb2JhbCdcbmRlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZGVmYXVsdENvbG9yOiAncmdiYSgwLDAsMCwwLjEpJyxcblx0ZGVmYXVsdEZvbnRDb2xvcjogJyM2NjYnLFxuXHRkZWZhdWx0Rm9udEZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuXHRkZWZhdWx0Rm9udFNpemU6IDEyLFxuXHRkZWZhdWx0Rm9udFN0eWxlOiAnbm9ybWFsJyxcblx0ZGVmYXVsdExpbmVIZWlnaHQ6IDEuMixcblx0c2hvd0xpbmVzOiB0cnVlXG59KTtcblxudmFyIGNvcmVfZGVmYXVsdHMgPSBkZWZhdWx0cztcblxudmFyIHZhbHVlT3JEZWZhdWx0ID0gaGVscGVyc19jb3JlLnZhbHVlT3JEZWZhdWx0O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBmb250IG9iamVjdCBpbnRvIGEgQ1NTIGZvbnQgc3RyaW5nLlxuICogQHBhcmFtIHtvYmplY3R9IGZvbnQgLSBBIGZvbnQgb2JqZWN0LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgQ1NTIGZvbnQgc3RyaW5nLiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250KSB7XG5cdGlmICghZm9udCB8fCBoZWxwZXJzX2NvcmUuaXNOdWxsT3JVbmRlZihmb250LnNpemUpIHx8IGhlbHBlcnNfY29yZS5pc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcblx0XHQrIGZvbnQuc2l6ZSArICdweCAnXG5cdFx0KyBmb250LmZhbWlseTtcbn1cblxuLyoqXG4gKiBAYWxpYXMgQ2hhcnQuaGVscGVycy5vcHRpb25zXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBoZWxwZXJzX29wdGlvbnMgPSB7XG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbGluZSBoZWlnaHQgYHZhbHVlYCBpbiBwaXhlbHMgZm9yIGEgc3BlY2lmaWMgZm9udCBgc2l6ZWAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWUgLSBUaGUgbGluZUhlaWdodCB0byBwYXJzZSAoZWcuIDEuNiwgJzE0cHgnLCAnNzUlJywgJzEuNmVtJykuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIC0gVGhlIGZvbnQgc2l6ZSAoaW4gcGl4ZWxzKSB1c2VkIHRvIHJlc29sdmUgcmVsYXRpdmUgYHZhbHVlYC5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBpbiBwaXhlbHMgKHNpemUgKiAxLjIgaWYgdmFsdWUgaXMgaW52YWxpZCkuXG5cdCAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2xpbmUtaGVpZ2h0XG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0dG9MaW5lSGVpZ2h0OiBmdW5jdGlvbih2YWx1ZSwgc2l6ZSkge1xuXHRcdHZhciBtYXRjaGVzID0gKCcnICsgdmFsdWUpLm1hdGNoKC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvKTtcblx0XHRpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcblx0XHRcdHJldHVybiBzaXplICogMS4yO1xuXHRcdH1cblxuXHRcdHZhbHVlID0gK21hdGNoZXNbMl07XG5cblx0XHRzd2l0Y2ggKG1hdGNoZXNbM10pIHtcblx0XHRjYXNlICdweCc6XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0Y2FzZSAnJSc6XG5cdFx0XHR2YWx1ZSAvPSAxMDA7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gc2l6ZSAqIHZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIHBhZGRpbmcgb2JqZWN0IHdpdGggcHJlLWNvbXB1dGVkIHdpZHRoL2hlaWdodC5cblx0ICogQHBhcmFtIHtudW1iZXJ8b2JqZWN0fSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcblx0ICogIGVsc2UsIGlmIGFuZCBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHQpXG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0dG9QYWRkaW5nOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciB0LCByLCBiLCBsO1xuXG5cdFx0aWYgKGhlbHBlcnNfY29yZS5pc09iamVjdCh2YWx1ZSkpIHtcblx0XHRcdHQgPSArdmFsdWUudG9wIHx8IDA7XG5cdFx0XHRyID0gK3ZhbHVlLnJpZ2h0IHx8IDA7XG5cdFx0XHRiID0gK3ZhbHVlLmJvdHRvbSB8fCAwO1xuXHRcdFx0bCA9ICt2YWx1ZS5sZWZ0IHx8IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHQgPSByID0gYiA9IGwgPSArdmFsdWUgfHwgMDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiB0LFxuXHRcdFx0cmlnaHQ6IHIsXG5cdFx0XHRib3R0b206IGIsXG5cdFx0XHRsZWZ0OiBsLFxuXHRcdFx0aGVpZ2h0OiB0ICsgYixcblx0XHRcdHdpZHRoOiBsICsgclxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIFBhcnNlcyBmb250IG9wdGlvbnMgYW5kIHJldHVybnMgdGhlIGZvbnQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZm9udCBvcHRpb25zIHRvIGJlIHBhcnNlZC5cblx0ICogQHJldHVybiB7b2JqZWN0fSBUaGUgZm9udCBvYmplY3QuXG5cdCAqIEB0b2RvIFN1cHBvcnQgZm9udC4qIG9wdGlvbnMgYW5kIHJlbmFtZWQgdG8gdG9Gb250KCkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcGFyc2VGb250OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIHNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpO1xuXHRcdHZhciBmb250ID0ge1xuXHRcdFx0ZmFtaWx5OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KSxcblx0XHRcdGxpbmVIZWlnaHQ6IGhlbHBlcnNfY29yZS5vcHRpb25zLnRvTGluZUhlaWdodCh2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmxpbmVIZWlnaHQsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRMaW5lSGVpZ2h0KSwgc2l6ZSksXG5cdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0c3R5bGU6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHRcdHdlaWdodDogbnVsbCxcblx0XHRcdHN0cmluZzogJydcblx0XHR9O1xuXG5cdFx0Zm9udC5zdHJpbmcgPSB0b0ZvbnRTdHJpbmcoZm9udCk7XG5cdFx0cmV0dXJuIGZvbnQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gYGlucHV0c2Agc2VxdWVudGlhbGx5IGFuZCByZXR1cm5zIHRoZSBmaXJzdCBkZWZpbmVkIHZhbHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBpbnB1dHMgLSBBbiBhcnJheSBvZiB2YWx1ZXMsIGZhbGxpbmcgYmFjayB0byB0aGUgbGFzdCB2YWx1ZS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGEgZnVuY3Rpb24sIHRoZSB2YWx1ZVxuXHQgKiBpcyBjYWxsZWQgd2l0aCBgY29udGV4dGAgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHRoZSByZXN1bHQgYmVjb21lcyB0aGUgbmV3IGlucHV0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XSAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGFuIGFycmF5LCB0aGUgdmFsdWVcblx0ICogYXQgYGluZGV4YCBiZWNvbWUgdGhlIG5ldyBpbnB1dC5cblx0ICogQHBhcmFtIHtvYmplY3R9IFtpbmZvXSAtIG9iamVjdCB0byByZXR1cm4gaW5mb3JtYXRpb24gYWJvdXQgcmVzb2x1dGlvbiBpblxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmZvLmNhY2hlYWJsZV0gLSBXaWxsIGJlIHNldCB0byBgZmFsc2VgIGlmIG9wdGlvbiBpcyBub3QgY2FjaGVhYmxlLlxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdHJlc29sdmU6IGZ1bmN0aW9uKGlucHV0cywgY29udGV4dCwgaW5kZXgsIGluZm8pIHtcblx0XHR2YXIgY2FjaGVhYmxlID0gdHJ1ZTtcblx0XHR2YXIgaSwgaWxlbiwgdmFsdWU7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gaW5wdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0dmFsdWUgPSBpbnB1dHNbaV07XG5cdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUoY29udGV4dCk7XG5cdFx0XHRcdGNhY2hlYWJsZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaGVscGVyc19jb3JlLmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbaW5kZXhdO1xuXHRcdFx0XHRjYWNoZWFibGUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmIChpbmZvICYmICFjYWNoZWFibGUpIHtcblx0XHRcdFx0XHRpbmZvLmNhY2hlYWJsZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMubWF0aFxuICogQG5hbWVzcGFjZVxuICovXG52YXIgZXhwb3J0cyQyID0ge1xuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBmYWN0b3JzIHNvcnRlZCBmcm9tIDEgdG8gc3FydCh2YWx1ZSlcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9mYWN0b3JpemU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHZhciBzcXJ0ID0gTWF0aC5zcXJ0KHZhbHVlKTtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDE7IGkgPCBzcXJ0OyBpKyspIHtcblx0XHRcdGlmICh2YWx1ZSAlIGkgPT09IDApIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goaSk7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKHZhbHVlIC8gaSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzcXJ0ID09PSAoc3FydCB8IDApKSB7IC8vIGlmIHZhbHVlIGlzIGEgc3F1YXJlIG51bWJlclxuXHRcdFx0cmVzdWx0LnB1c2goc3FydCk7XG5cdFx0fVxuXG5cdFx0cmVzdWx0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgLSBiO1xuXHRcdH0pLnBvcCgpO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0bG9nMTA6IE1hdGgubG9nMTAgfHwgZnVuY3Rpb24oeCkge1xuXHRcdHZhciBleHBvbmVudCA9IE1hdGgubG9nKHgpICogTWF0aC5MT0cxMEU7IC8vIE1hdGguTE9HMTBFID0gMSAvIE1hdGguTE4xMC5cblx0XHQvLyBDaGVjayBmb3Igd2hvbGUgcG93ZXJzIG9mIDEwLFxuXHRcdC8vIHdoaWNoIGR1ZSB0byBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvciBzaG91bGQgYmUgY29ycmVjdGVkLlxuXHRcdHZhciBwb3dlck9mMTAgPSBNYXRoLnJvdW5kKGV4cG9uZW50KTtcblx0XHR2YXIgaXNQb3dlck9mMTAgPSB4ID09PSBNYXRoLnBvdygxMCwgcG93ZXJPZjEwKTtcblxuXHRcdHJldHVybiBpc1Bvd2VyT2YxMCA/IHBvd2VyT2YxMCA6IGV4cG9uZW50O1xuXHR9XG59O1xuXG52YXIgaGVscGVyc19tYXRoID0gZXhwb3J0cyQyO1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMubWF0aC5sb2cxMCBpbnN0ZWFkLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmxvZzEwXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOS4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzX2NvcmUubG9nMTAgPSBleHBvcnRzJDIubG9nMTA7XG5cbnZhciBnZXRSdGxBZGFwdGVyID0gZnVuY3Rpb24ocmVjdFgsIHdpZHRoKSB7XG5cdHJldHVybiB7XG5cdFx0eDogZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHJlY3RYICsgcmVjdFggKyB3aWR0aCAtIHg7XG5cdFx0fSxcblx0XHRzZXRXaWR0aDogZnVuY3Rpb24odykge1xuXHRcdFx0d2lkdGggPSB3O1xuXHRcdH0sXG5cdFx0dGV4dEFsaWduOiBmdW5jdGlvbihhbGlnbikge1xuXHRcdFx0aWYgKGFsaWduID09PSAnY2VudGVyJykge1xuXHRcdFx0XHRyZXR1cm4gYWxpZ247XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuXHRcdH0sXG5cdFx0eFBsdXM6IGZ1bmN0aW9uKHgsIHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4geCAtIHZhbHVlO1xuXHRcdH0sXG5cdFx0bGVmdEZvckx0cjogZnVuY3Rpb24oeCwgaXRlbVdpZHRoKSB7XG5cdFx0XHRyZXR1cm4geCAtIGl0ZW1XaWR0aDtcblx0XHR9LFxuXHR9O1xufTtcblxudmFyIGdldEx0ckFkYXB0ZXIgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtcblx0XHR4OiBmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4geDtcblx0XHR9LFxuXHRcdHNldFdpZHRoOiBmdW5jdGlvbih3KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblx0XHR9LFxuXHRcdHRleHRBbGlnbjogZnVuY3Rpb24oYWxpZ24pIHtcblx0XHRcdHJldHVybiBhbGlnbjtcblx0XHR9LFxuXHRcdHhQbHVzOiBmdW5jdGlvbih4LCB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHggKyB2YWx1ZTtcblx0XHR9LFxuXHRcdGxlZnRGb3JMdHI6IGZ1bmN0aW9uKHgsIF9pdGVtV2lkdGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXHRcdFx0cmV0dXJuIHg7XG5cdFx0fSxcblx0fTtcbn07XG5cbnZhciBnZXRBZGFwdGVyID0gZnVuY3Rpb24ocnRsLCByZWN0WCwgd2lkdGgpIHtcblx0cmV0dXJuIHJ0bCA/IGdldFJ0bEFkYXB0ZXIocmVjdFgsIHdpZHRoKSA6IGdldEx0ckFkYXB0ZXIoKTtcbn07XG5cbnZhciBvdmVycmlkZVRleHREaXJlY3Rpb24gPSBmdW5jdGlvbihjdHgsIGRpcmVjdGlvbikge1xuXHR2YXIgc3R5bGUsIG9yaWdpbmFsO1xuXHRpZiAoZGlyZWN0aW9uID09PSAnbHRyJyB8fCBkaXJlY3Rpb24gPT09ICdydGwnKSB7XG5cdFx0c3R5bGUgPSBjdHguY2FudmFzLnN0eWxlO1xuXHRcdG9yaWdpbmFsID0gW1xuXHRcdFx0c3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJyksXG5cdFx0XHRzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KCdkaXJlY3Rpb24nKSxcblx0XHRdO1xuXG5cdFx0c3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIGRpcmVjdGlvbiwgJ2ltcG9ydGFudCcpO1xuXHRcdGN0eC5wcmV2VGV4dERpcmVjdGlvbiA9IG9yaWdpbmFsO1xuXHR9XG59O1xuXG52YXIgcmVzdG9yZVRleHREaXJlY3Rpb24gPSBmdW5jdGlvbihjdHgpIHtcblx0dmFyIG9yaWdpbmFsID0gY3R4LnByZXZUZXh0RGlyZWN0aW9uO1xuXHRpZiAob3JpZ2luYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdGRlbGV0ZSBjdHgucHJldlRleHREaXJlY3Rpb247XG5cdFx0Y3R4LmNhbnZhcy5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgb3JpZ2luYWxbMF0sIG9yaWdpbmFsWzFdKTtcblx0fVxufTtcblxudmFyIGhlbHBlcnNfcnRsID0ge1xuXHRnZXRSdGxBZGFwdGVyOiBnZXRBZGFwdGVyLFxuXHRvdmVycmlkZVRleHREaXJlY3Rpb246IG92ZXJyaWRlVGV4dERpcmVjdGlvbixcblx0cmVzdG9yZVRleHREaXJlY3Rpb246IHJlc3RvcmVUZXh0RGlyZWN0aW9uLFxufTtcblxudmFyIGhlbHBlcnMkMSA9IGhlbHBlcnNfY29yZTtcbnZhciBlYXNpbmcgPSBoZWxwZXJzX2Vhc2luZztcbnZhciBjYW52YXMgPSBoZWxwZXJzX2NhbnZhcztcbnZhciBvcHRpb25zID0gaGVscGVyc19vcHRpb25zO1xudmFyIG1hdGggPSBoZWxwZXJzX21hdGg7XG52YXIgcnRsID0gaGVscGVyc19ydGw7XG5oZWxwZXJzJDEuZWFzaW5nID0gZWFzaW5nO1xuaGVscGVycyQxLmNhbnZhcyA9IGNhbnZhcztcbmhlbHBlcnMkMS5vcHRpb25zID0gb3B0aW9ucztcbmhlbHBlcnMkMS5tYXRoID0gbWF0aDtcbmhlbHBlcnMkMS5ydGwgPSBydGw7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKHN0YXJ0LCB2aWV3LCBtb2RlbCwgZWFzZSkge1xuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1vZGVsKTtcblx0dmFyIGksIGlsZW4sIGtleSwgYWN0dWFsLCBvcmlnaW4sIHRhcmdldCwgdHlwZSwgYzAsIGMxO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGtleSA9IGtleXNbaV07XG5cblx0XHR0YXJnZXQgPSBtb2RlbFtrZXldO1xuXG5cdFx0Ly8gaWYgYSB2YWx1ZSBpcyBhZGRlZCB0byB0aGUgbW9kZWwgYWZ0ZXIgcGl2b3QoKSBoYXMgYmVlbiBjYWxsZWQsIHRoZSB2aWV3XG5cdFx0Ly8gZG9lc24ndCBjb250YWluIGl0LCBzbyBsZXQncyBpbml0aWFsaXplIHRoZSB2aWV3IHRvIHRoZSB0YXJnZXQgdmFsdWUuXG5cdFx0aWYgKCF2aWV3Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHZpZXdba2V5XSA9IHRhcmdldDtcblx0XHR9XG5cblx0XHRhY3R1YWwgPSB2aWV3W2tleV07XG5cblx0XHRpZiAoYWN0dWFsID09PSB0YXJnZXQgfHwga2V5WzBdID09PSAnXycpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICghc3RhcnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0c3RhcnRba2V5XSA9IGFjdHVhbDtcblx0XHR9XG5cblx0XHRvcmlnaW4gPSBzdGFydFtrZXldO1xuXG5cdFx0dHlwZSA9IHR5cGVvZiB0YXJnZXQ7XG5cblx0XHRpZiAodHlwZSA9PT0gdHlwZW9mIG9yaWdpbikge1xuXHRcdFx0aWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGMwID0gY2hhcnRqc0NvbG9yKG9yaWdpbik7XG5cdFx0XHRcdGlmIChjMC52YWxpZCkge1xuXHRcdFx0XHRcdGMxID0gY2hhcnRqc0NvbG9yKHRhcmdldCk7XG5cdFx0XHRcdFx0aWYgKGMxLnZhbGlkKSB7XG5cdFx0XHRcdFx0XHR2aWV3W2tleV0gPSBjMS5taXgoYzAsIGVhc2UpLnJnYlN0cmluZygpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGhlbHBlcnMkMS5pc0Zpbml0ZShvcmlnaW4pICYmIGhlbHBlcnMkMS5pc0Zpbml0ZSh0YXJnZXQpKSB7XG5cdFx0XHRcdHZpZXdba2V5XSA9IG9yaWdpbiArICh0YXJnZXQgLSBvcmlnaW4pICogZWFzZTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmlld1trZXldID0gdGFyZ2V0O1xuXHR9XG59XG5cbnZhciBFbGVtZW50ID0gZnVuY3Rpb24oY29uZmlndXJhdGlvbikge1xuXHRoZWxwZXJzJDEuZXh0ZW5kKHRoaXMsIGNvbmZpZ3VyYXRpb24pO1xuXHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbmhlbHBlcnMkMS5leHRlbmQoRWxlbWVudC5wcm90b3R5cGUsIHtcblx0X3R5cGU6IHVuZGVmaW5lZCxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhpZGRlbiA9IGZhbHNlO1xuXHR9LFxuXG5cdHBpdm90OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGlmICghbWUuX3ZpZXcpIHtcblx0XHRcdG1lLl92aWV3ID0gaGVscGVycyQxLmV4dGVuZCh7fSwgbWUuX21vZGVsKTtcblx0XHR9XG5cdFx0bWUuX3N0YXJ0ID0ge307XG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2UpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtb2RlbCA9IG1lLl9tb2RlbDtcblx0XHR2YXIgc3RhcnQgPSBtZS5fc3RhcnQ7XG5cdFx0dmFyIHZpZXcgPSBtZS5fdmlldztcblxuXHRcdC8vIE5vIGFuaW1hdGlvbiAtPiBObyBUcmFuc2l0aW9uXG5cdFx0aWYgKCFtb2RlbCB8fCBlYXNlID09PSAxKSB7XG5cdFx0XHRtZS5fdmlldyA9IGhlbHBlcnMkMS5leHRlbmQoe30sIG1vZGVsKTtcblx0XHRcdG1lLl9zdGFydCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gbWU7XG5cdFx0fVxuXG5cdFx0aWYgKCF2aWV3KSB7XG5cdFx0XHR2aWV3ID0gbWUuX3ZpZXcgPSB7fTtcblx0XHR9XG5cblx0XHRpZiAoIXN0YXJ0KSB7XG5cdFx0XHRzdGFydCA9IG1lLl9zdGFydCA9IHt9O1xuXHRcdH1cblxuXHRcdGludGVycG9sYXRlKHN0YXJ0LCB2aWV3LCBtb2RlbCwgZWFzZSk7XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdGhpcy5fbW9kZWwueCxcblx0XHRcdHk6IHRoaXMuX21vZGVsLnlcblx0XHR9O1xuXHR9LFxuXG5cdGhhc1ZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gaGVscGVycyQxLmlzTnVtYmVyKHRoaXMuX21vZGVsLngpICYmIGhlbHBlcnMkMS5pc051bWJlcih0aGlzLl9tb2RlbC55KTtcblx0fVxufSk7XG5cbkVsZW1lbnQuZXh0ZW5kID0gaGVscGVycyQxLmluaGVyaXRzO1xuXG52YXIgY29yZV9lbGVtZW50ID0gRWxlbWVudDtcblxudmFyIGV4cG9ydHMkMyA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRjaGFydDogbnVsbCwgLy8gdGhlIGFuaW1hdGlvbiBhc3NvY2lhdGVkIGNoYXJ0IGluc3RhbmNlXG5cdGN1cnJlbnRTdGVwOiAwLCAvLyB0aGUgY3VycmVudCBhbmltYXRpb24gc3RlcFxuXHRudW1TdGVwczogNjAsIC8vIGRlZmF1bHQgbnVtYmVyIG9mIHN0ZXBzXG5cdGVhc2luZzogJycsIC8vIHRoZSBlYXNpbmcgdG8gdXNlIGZvciB0aGlzIGFuaW1hdGlvblxuXHRyZW5kZXI6IG51bGwsIC8vIHJlbmRlciBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBhbmltYXRpb24gc2VydmljZVxuXG5cdG9uQW5pbWF0aW9uUHJvZ3Jlc3M6IG51bGwsIC8vIHVzZXIgc3BlY2lmaWVkIGNhbGxiYWNrIHRvIGZpcmUgb24gZWFjaCBzdGVwIG9mIHRoZSBhbmltYXRpb25cblx0b25BbmltYXRpb25Db21wbGV0ZTogbnVsbCwgLy8gdXNlciBzcGVjaWZpZWQgY2FsbGJhY2sgdG8gZmlyZSB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXNcbn0pO1xuXG52YXIgY29yZV9hbmltYXRpb24gPSBleHBvcnRzJDM7XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuQW5pbWF0aW9uIGluc3RlYWRcbiAqIEBwcm9wIENoYXJ0LkFuaW1hdGlvbiNhbmltYXRpb25PYmplY3RcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMkMy5wcm90b3R5cGUsICdhbmltYXRpb25PYmplY3QnLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuQW5pbWF0aW9uI2NoYXJ0IGluc3RlYWRcbiAqIEBwcm9wIENoYXJ0LkFuaW1hdGlvbiNjaGFydEluc3RhbmNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzJDMucHJvdG90eXBlLCAnY2hhcnRJbnN0YW5jZScsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGFydDtcblx0fSxcblx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuY2hhcnQgPSB2YWx1ZTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRhbmltYXRpb246IHtcblx0XHRkdXJhdGlvbjogMTAwMCxcblx0XHRlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuXHRcdG9uUHJvZ3Jlc3M6IGhlbHBlcnMkMS5ub29wLFxuXHRcdG9uQ29tcGxldGU6IGhlbHBlcnMkMS5ub29wXG5cdH1cbn0pO1xuXG52YXIgY29yZV9hbmltYXRpb25zID0ge1xuXHRhbmltYXRpb25zOiBbXSxcblx0cmVxdWVzdDogbnVsbCxcblxuXHQvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgdG8gYW5pbWF0ZS5cblx0ICogQHBhcmFtIHtDaGFydC5BbmltYXRpb259IGFuaW1hdGlvbiAtIFRoZSBhbmltYXRpb24gdGhhdCB3ZSB3aWxsIGFuaW1hdGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbXMuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gbGF6eSAtIGlmIHRydWUsIHRoZSBjaGFydCBpcyBub3QgbWFya2VkIGFzIGFuaW1hdGluZyB0byBlbmFibGUgbW9yZSByZXNwb25zaXZlIGludGVyYWN0aW9uc1xuXHQgKi9cblx0YWRkQW5pbWF0aW9uOiBmdW5jdGlvbihjaGFydCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgbGF6eSkge1xuXHRcdHZhciBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0YW5pbWF0aW9uLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0YW5pbWF0aW9uLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cdFx0YW5pbWF0aW9uLmR1cmF0aW9uID0gZHVyYXRpb247XG5cblx0XHRpZiAoIWxhenkpIHtcblx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFuaW1hdGlvbnMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRpZiAoYW5pbWF0aW9uc1tpXS5jaGFydCA9PT0gY2hhcnQpIHtcblx0XHRcdFx0YW5pbWF0aW9uc1tpXSA9IGFuaW1hdGlvbjtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIG5vIGFuaW1hdGlvbnMgcXVldWVkLCBtYW51YWxseSBraWNrc3RhcnQgYSBkaWdlc3QsIGZvciBsYWNrIG9mIGEgYmV0dGVyIHdvcmRcblx0XHRpZiAoYW5pbWF0aW9ucy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNhbmNlbEFuaW1hdGlvbjogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgaW5kZXggPSBoZWxwZXJzJDEuZmluZEluZGV4KHRoaXMuYW5pbWF0aW9ucywgZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdFx0XHRyZXR1cm4gYW5pbWF0aW9uLmNoYXJ0ID09PSBjaGFydDtcblx0XHR9KTtcblxuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdHRoaXMuYW5pbWF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0Y2hhcnQuYW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdHJlcXVlc3RBbmltYXRpb25GcmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRpZiAobWUucmVxdWVzdCA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gU2tpcCBhbmltYXRpb24gZnJhbWUgcmVxdWVzdHMgdW50aWwgdGhlIGFjdGl2ZSBvbmUgaXMgZXhlY3V0ZWQuXG5cdFx0XHQvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiBwcm9jZXNzaW5nIG1vdXNlIGV2ZW50cywgZS5nLiAnbW91c2Vtb3ZlJ1xuXHRcdFx0Ly8gYW5kICdtb3VzZW91dCcgZXZlbnRzIHdpbGwgdHJpZ2dlciBtdWx0aXBsZSByZW5kZXJzLlxuXHRcdFx0bWUucmVxdWVzdCA9IGhlbHBlcnMkMS5yZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0bWUucmVxdWVzdCA9IG51bGw7XG5cdFx0XHRcdG1lLnN0YXJ0RGlnZXN0KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzdGFydERpZ2VzdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdG1lLmFkdmFuY2UoKTtcblxuXHRcdC8vIERvIHdlIGhhdmUgbW9yZSBzdHVmZiB0byBhbmltYXRlP1xuXHRcdGlmIChtZS5hbmltYXRpb25zLmxlbmd0aCA+IDApIHtcblx0XHRcdG1lLnJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGFkdmFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zO1xuXHRcdHZhciBhbmltYXRpb24sIGNoYXJ0LCBudW1TdGVwcywgbmV4dFN0ZXA7XG5cdFx0dmFyIGkgPSAwO1xuXG5cdFx0Ly8gMSBhbmltYXRpb24gcGVyIGNoYXJ0LCBzbyB3ZSBhcmUgbG9vcGluZyBjaGFydHMgaGVyZVxuXHRcdHdoaWxlIChpIDwgYW5pbWF0aW9ucy5sZW5ndGgpIHtcblx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbaV07XG5cdFx0XHRjaGFydCA9IGFuaW1hdGlvbi5jaGFydDtcblx0XHRcdG51bVN0ZXBzID0gYW5pbWF0aW9uLm51bVN0ZXBzO1xuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBjdXJyZW50U3RlcCBzdGFydHMgYXQgMVxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzYxMDRcblx0XHRcdG5leHRTdGVwID0gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSAtIGFuaW1hdGlvbi5zdGFydFRpbWUpIC8gYW5pbWF0aW9uLmR1cmF0aW9uICogbnVtU3RlcHMpICsgMTtcblx0XHRcdGFuaW1hdGlvbi5jdXJyZW50U3RlcCA9IE1hdGgubWluKG5leHRTdGVwLCBudW1TdGVwcyk7XG5cblx0XHRcdGhlbHBlcnMkMS5jYWxsYmFjayhhbmltYXRpb24ucmVuZGVyLCBbY2hhcnQsIGFuaW1hdGlvbl0sIGNoYXJ0KTtcblx0XHRcdGhlbHBlcnMkMS5jYWxsYmFjayhhbmltYXRpb24ub25BbmltYXRpb25Qcm9ncmVzcywgW2FuaW1hdGlvbl0sIGNoYXJ0KTtcblxuXHRcdFx0aWYgKGFuaW1hdGlvbi5jdXJyZW50U3RlcCA+PSBudW1TdGVwcykge1xuXHRcdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uLm9uQW5pbWF0aW9uQ29tcGxldGUsIFthbmltYXRpb25dLCBjaGFydCk7XG5cdFx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRhbmltYXRpb25zLnNwbGljZShpLCAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCsraTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbnZhciByZXNvbHZlID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcblxudmFyIGFycmF5RXZlbnRzID0gWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICdzcGxpY2UnLCAndW5zaGlmdCddO1xuXG4vKipcbiAqIEhvb2tzIHRoZSBhcnJheSBtZXRob2RzIHRoYXQgYWRkIG9yIHJlbW92ZSB2YWx1ZXMgKCdwdXNoJywgcG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsXG4gKiAndW5zaGlmdCcpIGFuZCBub3RpZnkgdGhlIGxpc3RlbmVyIEFGVEVSIHRoZSBhcnJheSBoYXMgYmVlbiBhbHRlcmVkLiBMaXN0ZW5lcnMgYXJlXG4gKiBjYWxsZWQgb24gdGhlICdvbkRhdGEqJyBjYWxsYmFja3MgKGUuZy4gb25EYXRhUHVzaCwgZXRjLikgd2l0aCBzYW1lIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG5cdGlmIChhcnJheS5fY2hhcnRqcykge1xuXHRcdGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksICdfY2hhcnRqcycsIHtcblx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0dmFsdWU6IHtcblx0XHRcdGxpc3RlbmVyczogW2xpc3RlbmVyXVxuXHRcdH1cblx0fSk7XG5cblx0YXJyYXlFdmVudHMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHR2YXIgbWV0aG9kID0gJ29uRGF0YScgKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7XG5cdFx0dmFyIGJhc2UgPSBhcnJheVtrZXldO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0XHRcdHZhciByZXMgPSBiYXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycywgZnVuY3Rpb24ob2JqZWN0KSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3RbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0b2JqZWN0W21ldGhvZF0uYXBwbHkob2JqZWN0LCBhcmdzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGdpdmVuIGFycmF5IGV2ZW50IGxpc3RlbmVyIGFuZCBjbGVhbnVwIGV4dHJhIGF0dGFjaGVkIHByb3BlcnRpZXMgKHN1Y2ggYXNcbiAqIHRoZSBfY2hhcnRqcyBzdHViIGFuZCBvdmVycmlkZGVuIG1ldGhvZHMpIGlmIGFycmF5IGRvZXNuJ3QgaGF2ZSBhbnkgbW9yZSBsaXN0ZW5lcnMuXG4gKi9cbmZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG5cdHZhciBzdHViID0gYXJyYXkuX2NoYXJ0anM7XG5cdGlmICghc3R1Yikge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcblx0dmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuXHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0bGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdH1cblxuXHRpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRhcnJheUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdGRlbGV0ZSBhcnJheVtrZXldO1xuXHR9KTtcblxuXHRkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5cbi8vIEJhc2UgY2xhc3MgZm9yIGFsbCBkYXRhc2V0IGNvbnRyb2xsZXJzIChsaW5lLCBiYXIsIGV0YylcbnZhciBEYXRhc2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcblx0dGhpcy5pbml0aWFsaXplKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xufTtcblxuaGVscGVycyQxLmV4dGVuZChEYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcblxuXHQvKipcblx0ICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGFzZXQgKGUuZy4gQ2hhcnQuZWxlbWVudC5MaW5lKS5cblx0ICogQHR5cGUge0NoYXJ0LmNvcmUuZWxlbWVudH1cblx0ICovXG5cdGRhdGFzZXRFbGVtZW50VHlwZTogbnVsbCxcblxuXHQvKipcblx0ICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGEgKGUuZy4gQ2hhcnQuZWxlbWVudC5Qb2ludCkuXG5cdCAqIEB0eXBlIHtDaGFydC5jb3JlLmVsZW1lbnR9XG5cdCAqL1xuXHRkYXRhRWxlbWVudFR5cGU6IG51bGwsXG5cblx0LyoqXG5cdCAqIERhdGFzZXQgZWxlbWVudCBvcHRpb24ga2V5cyB0byBiZSByZXNvbHZlZCBpbiBfcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucy5cblx0ICogQSBkZXJpdmVkIGNvbnRyb2xsZXIgbWF5IG92ZXJyaWRlIHRoaXMgdG8gcmVzb2x2ZSBjb250cm9sbGVyLXNwZWNpZmljIG9wdGlvbnMuXG5cdCAqIFRoZSBrZXlzIGRlZmluZWQgaGVyZSBhcmUgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIGxlZ2VuZCBzdHlsZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZGF0YXNldEVsZW1lbnRPcHRpb25zOiBbXG5cdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0J2JvcmRlckNhcFN0eWxlJyxcblx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdCdib3JkZXJEYXNoJyxcblx0XHQnYm9yZGVyRGFzaE9mZnNldCcsXG5cdFx0J2JvcmRlckpvaW5TdHlsZScsXG5cdFx0J2JvcmRlcldpZHRoJ1xuXHRdLFxuXG5cdC8qKlxuXHQgKiBEYXRhIGVsZW1lbnQgb3B0aW9uIGtleXMgdG8gYmUgcmVzb2x2ZWQgaW4gX3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMuXG5cdCAqIEEgZGVyaXZlZCBjb250cm9sbGVyIG1heSBvdmVycmlkZSB0aGlzIHRvIHJlc29sdmUgY29udHJvbGxlci1zcGVjaWZpYyBvcHRpb25zLlxuXHQgKiBUaGUga2V5cyBkZWZpbmVkIGhlcmUgYXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGZvciBsZWdlbmQgc3R5bGVzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2RhdGFFbGVtZW50T3B0aW9uczogW1xuXHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxuXHRcdCdib3JkZXJDb2xvcicsXG5cdFx0J2JvcmRlcldpZHRoJyxcblx0XHQncG9pbnRTdHlsZSdcblx0XSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihjaGFydCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRtZS5jaGFydCA9IGNoYXJ0O1xuXHRcdG1lLmluZGV4ID0gZGF0YXNldEluZGV4O1xuXHRcdG1lLmxpbmtTY2FsZXMoKTtcblx0XHRtZS5hZGRFbGVtZW50cygpO1xuXHRcdG1lLl90eXBlID0gbWUuZ2V0TWV0YSgpLnR5cGU7XG5cdH0sXG5cblx0dXBkYXRlSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG5cdH0sXG5cblx0bGlua1NjYWxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgc2NhbGVzID0gY2hhcnQuc2NhbGVzO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBzY2FsZXNPcHRzID0gY2hhcnQub3B0aW9ucy5zY2FsZXM7XG5cblx0XHRpZiAobWV0YS54QXhpc0lEID09PSBudWxsIHx8ICEobWV0YS54QXhpc0lEIGluIHNjYWxlcykgfHwgZGF0YXNldC54QXhpc0lEKSB7XG5cdFx0XHRtZXRhLnhBeGlzSUQgPSBkYXRhc2V0LnhBeGlzSUQgfHwgc2NhbGVzT3B0cy54QXhlc1swXS5pZDtcblx0XHR9XG5cdFx0aWYgKG1ldGEueUF4aXNJRCA9PT0gbnVsbCB8fCAhKG1ldGEueUF4aXNJRCBpbiBzY2FsZXMpIHx8IGRhdGFzZXQueUF4aXNJRCkge1xuXHRcdFx0bWV0YS55QXhpc0lEID0gZGF0YXNldC55QXhpc0lEIHx8IHNjYWxlc09wdHMueUF4ZXNbMF0uaWQ7XG5cdFx0fVxuXHR9LFxuXG5cdGdldERhdGFzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdGhpcy5pbmRleF07XG5cdH0sXG5cblx0Z2V0TWV0YTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG5cdH0sXG5cblx0Z2V0U2NhbGVGb3JJZDogZnVuY3Rpb24oc2NhbGVJRCkge1xuXHRcdHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlc1tzY2FsZUlEXTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRWYWx1ZVNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE1ldGEoKS55QXhpc0lEO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldEluZGV4U2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnhBeGlzSUQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0VmFsdWVTY2FsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U2NhbGVGb3JJZCh0aGlzLl9nZXRWYWx1ZVNjYWxlSWQoKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0SW5kZXhTY2FsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U2NhbGVGb3JJZCh0aGlzLl9nZXRJbmRleFNjYWxlSWQoKSk7XG5cdH0sXG5cblx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3VwZGF0ZSh0cnVlKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7XG5cdFx0XHR1bmxpc3RlbkFycmF5RXZlbnRzKHRoaXMuX2RhdGEsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRjcmVhdGVNZXRhRGF0YXNldDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdHlwZSA9IG1lLmRhdGFzZXRFbGVtZW50VHlwZTtcblx0XHRyZXR1cm4gdHlwZSAmJiBuZXcgdHlwZSh7XG5cdFx0XHRfY2hhcnQ6IG1lLmNoYXJ0LFxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9KTtcblx0fSxcblxuXHRjcmVhdGVNZXRhRGF0YTogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0eXBlID0gbWUuZGF0YUVsZW1lbnRUeXBlO1xuXHRcdHJldHVybiB0eXBlICYmIG5ldyB0eXBlKHtcblx0XHRcdF9jaGFydDogbWUuY2hhcnQsXG5cdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleCxcblx0XHRcdF9pbmRleDogaW5kZXhcblx0XHR9KTtcblx0fSxcblxuXHRhZGRFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhIHx8IFtdO1xuXHRcdHZhciBtZXRhRGF0YSA9IG1ldGEuZGF0YTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWV0YURhdGFbaV0gPSBtZXRhRGF0YVtpXSB8fCBtZS5jcmVhdGVNZXRhRGF0YShpKTtcblx0XHR9XG5cblx0XHRtZXRhLmRhdGFzZXQgPSBtZXRhLmRhdGFzZXQgfHwgbWUuY3JlYXRlTWV0YURhdGFzZXQoKTtcblx0fSxcblxuXHRhZGRFbGVtZW50QW5kUmVzZXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmNyZWF0ZU1ldGFEYXRhKGluZGV4KTtcblx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnNwbGljZShpbmRleCwgMCwgZWxlbWVudCk7XG5cdFx0dGhpcy51cGRhdGVFbGVtZW50KGVsZW1lbnQsIGluZGV4LCB0cnVlKTtcblx0fSxcblxuXHRidWlsZE9yVXBkYXRlRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcblxuXHRcdC8vIEluIG9yZGVyIHRvIGNvcnJlY3RseSBoYW5kbGUgZGF0YSBhZGRpdGlvbi9kZWxldGlvbiBhbmltYXRpb24gKGFuIHRodXMgc2ltdWxhdGVcblx0XHQvLyByZWFsLXRpbWUgY2hhcnRzKSwgd2UgbmVlZCB0byBtb25pdG9yIHRoZXNlIGRhdGEgbW9kaWZpY2F0aW9ucyBhbmQgc3luY2hyb25pemVcblx0XHQvLyB0aGUgaW50ZXJuYWwgbWV0YSBkYXRhIGFjY29yZGluZ2x5LlxuXHRcdGlmIChtZS5fZGF0YSAhPT0gZGF0YSkge1xuXHRcdFx0aWYgKG1lLl9kYXRhKSB7XG5cdFx0XHRcdC8vIFRoaXMgY2FzZSBoYXBwZW5zIHdoZW4gdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgaW5zdGFuY2UuXG5cdFx0XHRcdHVubGlzdGVuQXJyYXlFdmVudHMobWUuX2RhdGEsIG1lKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuXHRcdFx0XHRsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCBtZSk7XG5cdFx0XHR9XG5cdFx0XHRtZS5fZGF0YSA9IGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gUmUtc3luYyBtZXRhIGRhdGEgaW4gY2FzZSB0aGUgdXNlciByZXBsYWNlZCB0aGUgZGF0YSBhcnJheSBvciBpZiB3ZSBtaXNzZWRcblx0XHQvLyBhbnkgdXBkYXRlcyBhbmQgc28gbWFrZSBzdXJlIHRoYXQgd2UgaGFuZGxlIG51bWJlciBvZiBkYXRhcG9pbnRzIGNoYW5naW5nLlxuXHRcdG1lLnJlc3luY0VsZW1lbnRzKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG1lcmdlZCB1c2VyLXN1cHBsaWVkIGFuZCBkZWZhdWx0IGRhdGFzZXQtbGV2ZWwgb3B0aW9uc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NvbmZpZ3VyZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRtZS5fY29uZmlnID0gaGVscGVycyQxLm1lcmdlKHt9LCBbXG5cdFx0XHRtZS5jaGFydC5vcHRpb25zLmRhdGFzZXRzW21lLl90eXBlXSxcblx0XHRcdG1lLmdldERhdGFzZXQoKSxcblx0XHRdLCB7XG5cdFx0XHRtZXJnZXI6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UpIHtcblx0XHRcdFx0aWYgKGtleSAhPT0gJ19tZXRhJyAmJiBrZXkgIT09ICdkYXRhJykge1xuXHRcdFx0XHRcdGhlbHBlcnMkMS5fbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdG1lLl9jb25maWd1cmUoKTtcblx0XHRtZS5fY2FjaGVkRGF0YU9wdHMgPSBudWxsO1xuXHRcdG1lLnVwZGF0ZShyZXNldCk7XG5cdH0sXG5cblx0dXBkYXRlOiBoZWxwZXJzJDEubm9vcCxcblxuXHR0cmFuc2l0aW9uOiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xuXHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0dmFyIGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBpbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRlbGVtZW50c1tpXS50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblx0XHR9XG5cblx0XHRpZiAobWV0YS5kYXRhc2V0KSB7XG5cdFx0XHRtZXRhLmRhdGFzZXQudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0dmFyIGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBpbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdGlmIChtZXRhLmRhdGFzZXQpIHtcblx0XHRcdG1ldGEuZGF0YXNldC5kcmF3KCk7XG5cdFx0fVxuXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGVsZW1lbnRzW2ldLmRyYXcoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzZXQgb2YgcHJlZGVmaW5lZCBzdHlsZSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBkYXRhc2V0XG5cdCAqIG9yIHRoZSBkYXRhIGlmIHRoZSBpbmRleCBpcyBzcGVjaWZpZWRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gZGF0YSBpbmRleFxuXHQgKiBAcmV0dXJuIHtJU3R5bGVJbnRlcmZhY2V9IHN0eWxlIG9iamVjdFxuXHQgKi9cblx0Z2V0U3R5bGU6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcblx0XHR2YXIgc3R5bGU7XG5cblx0XHRtZS5fY29uZmlndXJlKCk7XG5cdFx0aWYgKGRhdGFzZXQgJiYgaW5kZXggPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c3R5bGUgPSBtZS5fcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhkYXRhc2V0IHx8IHt9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5kZXggPSBpbmRleCB8fCAwO1xuXHRcdFx0c3R5bGUgPSBtZS5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhtZXRhLmRhdGFbaW5kZXhdIHx8IHt9LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0aWYgKHN0eWxlLmZpbGwgPT09IGZhbHNlIHx8IHN0eWxlLmZpbGwgPT09IG51bGwpIHtcblx0XHRcdHN0eWxlLmJhY2tncm91bmRDb2xvciA9IHN0eWxlLmJvcmRlckNvbG9yO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHlsZTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50LCBob3Zlcikge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXRPcHRzID0gbWUuX2NvbmZpZztcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzW21lLmRhdGFzZXRFbGVtZW50VHlwZS5wcm90b3R5cGUuX3R5cGVdIHx8IHt9O1xuXHRcdHZhciBlbGVtZW50T3B0aW9ucyA9IG1lLl9kYXRhc2V0RWxlbWVudE9wdGlvbnM7XG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdHZhciBpLCBpbGVuLCBrZXksIHJlYWRLZXk7XG5cblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcblx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdGRhdGFzZXQ6IG1lLmdldERhdGFzZXQoKSxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXgsXG5cdFx0XHRob3ZlcjogaG92ZXJcblx0XHR9O1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGVsZW1lbnRPcHRpb25zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0gZWxlbWVudE9wdGlvbnNbaV07XG5cdFx0XHRyZWFkS2V5ID0gaG92ZXIgPyAnaG92ZXInICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpIDoga2V5O1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlKFtcblx0XHRcdFx0Y3VzdG9tW3JlYWRLZXldLFxuXHRcdFx0XHRkYXRhc2V0T3B0c1tyZWFkS2V5XSxcblx0XHRcdFx0b3B0aW9uc1tyZWFkS2V5XVxuXHRcdFx0XSwgY29udGV4dCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQgJiYgZWxlbWVudC5jdXN0b207XG5cdFx0dmFyIGNhY2hlZCA9IG1lLl9jYWNoZWREYXRhT3B0cztcblx0XHRpZiAoY2FjaGVkICYmICFjdXN0b20pIHtcblx0XHRcdHJldHVybiBjYWNoZWQ7XG5cdFx0fVxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0T3B0cyA9IG1lLl9jb25maWc7XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzW21lLmRhdGFFbGVtZW50VHlwZS5wcm90b3R5cGUuX3R5cGVdIHx8IHt9O1xuXHRcdHZhciBlbGVtZW50T3B0aW9ucyA9IG1lLl9kYXRhRWxlbWVudE9wdGlvbnM7XG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogbWUuZ2V0RGF0YXNldCgpLFxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdH07XG5cblx0XHQvLyBgcmVzb2x2ZWAgc2V0cyBjYWNoZWFibGUgdG8gYGZhbHNlYCBpZiBhbnkgb3B0aW9uIGlzIGluZGV4ZWQgb3Igc2NyaXB0ZWRcblx0XHR2YXIgaW5mbyA9IHtjYWNoZWFibGU6ICFjdXN0b219O1xuXG5cdFx0dmFyIGtleXMsIGksIGlsZW4sIGtleTtcblxuXHRcdGN1c3RvbSA9IGN1c3RvbSB8fCB7fTtcblxuXHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheShlbGVtZW50T3B0aW9ucykpIHtcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBlbGVtZW50T3B0aW9ucy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0a2V5ID0gZWxlbWVudE9wdGlvbnNbaV07XG5cdFx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZShbXG5cdFx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdFx0ZGF0YXNldE9wdHNba2V5XSxcblx0XHRcdFx0XHRvcHRpb25zW2tleV1cblx0XHRcdFx0XSwgY29udGV4dCwgaW5kZXgsIGluZm8pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXMoZWxlbWVudE9wdGlvbnMpO1xuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZShbXG5cdFx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdFx0ZGF0YXNldE9wdHNbZWxlbWVudE9wdGlvbnNba2V5XV0sXG5cdFx0XHRcdFx0ZGF0YXNldE9wdHNba2V5XSxcblx0XHRcdFx0XHRvcHRpb25zW2tleV1cblx0XHRcdFx0XSwgY29udGV4dCwgaW5kZXgsIGluZm8pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpbmZvLmNhY2hlYWJsZSkge1xuXHRcdFx0bWUuX2NhY2hlZERhdGFPcHRzID0gT2JqZWN0LmZyZWV6ZSh2YWx1ZXMpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0cmVtb3ZlSG92ZXJTdHlsZTogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdGhlbHBlcnMkMS5tZXJnZShlbGVtZW50Ll9tb2RlbCwgZWxlbWVudC4kcHJldmlvdXNTdHlsZSB8fCB7fSk7XG5cdFx0ZGVsZXRlIGVsZW1lbnQuJHByZXZpb3VzU3R5bGU7XG5cdH0sXG5cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHZhciBkYXRhc2V0ID0gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2VsZW1lbnQuX2RhdGFzZXRJbmRleF07XG5cdFx0dmFyIGluZGV4ID0gZWxlbWVudC5faW5kZXg7XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBtb2RlbCA9IGVsZW1lbnQuX21vZGVsO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cblx0XHRlbGVtZW50LiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGhcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gcmVzb2x2ZShbY3VzdG9tLmhvdmVyQmFja2dyb3VuZENvbG9yLCBkYXRhc2V0LmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG1vZGVsLmJhY2tncm91bmRDb2xvcildLCB1bmRlZmluZWQsIGluZGV4KTtcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHJlc29sdmUoW2N1c3RvbS5ob3ZlckJvcmRlckNvbG9yLCBkYXRhc2V0LmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3IobW9kZWwuYm9yZGVyQ29sb3IpXSwgdW5kZWZpbmVkLCBpbmRleCk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSByZXNvbHZlKFtjdXN0b20uaG92ZXJCb3JkZXJXaWR0aCwgZGF0YXNldC5ob3ZlckJvcmRlcldpZHRoLCBtb2RlbC5ib3JkZXJXaWR0aF0sIHVuZGVmaW5lZCwgaW5kZXgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0TWV0YSgpLmRhdGFzZXQ7XG5cblx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0dGhpcy5yZW1vdmVIb3ZlclN0eWxlKGVsZW1lbnQpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9zZXREYXRhc2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldE1ldGEoKS5kYXRhc2V0O1xuXHRcdHZhciBwcmV2ID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleSwga2V5cywgaG92ZXJPcHRpb25zLCBtb2RlbDtcblxuXHRcdGlmICghZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG1vZGVsID0gZWxlbWVudC5fbW9kZWw7XG5cdFx0aG92ZXJPcHRpb25zID0gdGhpcy5fcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhlbGVtZW50LCB0cnVlKTtcblxuXHRcdGtleXMgPSBPYmplY3Qua2V5cyhob3Zlck9wdGlvbnMpO1xuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHByZXZba2V5XSA9IG1vZGVsW2tleV07XG5cdFx0XHRtb2RlbFtrZXldID0gaG92ZXJPcHRpb25zW2tleV07XG5cdFx0fVxuXG5cdFx0ZWxlbWVudC4kcHJldmlvdXNTdHlsZSA9IHByZXY7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRyZXN5bmNFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhO1xuXHRcdHZhciBudW1NZXRhID0gbWV0YS5kYXRhLmxlbmd0aDtcblx0XHR2YXIgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuXG5cdFx0aWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG5cdFx0XHRtZXRhLmRhdGEuc3BsaWNlKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcblx0XHR9IGVsc2UgaWYgKG51bURhdGEgPiBudW1NZXRhKSB7XG5cdFx0XHRtZS5pbnNlcnRFbGVtZW50cyhudW1NZXRhLCBudW1EYXRhIC0gbnVtTWV0YSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5zZXJ0RWxlbWVudHM6IGZ1bmN0aW9uKHN0YXJ0LCBjb3VudCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuXHRcdFx0dGhpcy5hZGRFbGVtZW50QW5kUmVzZXQoc3RhcnQgKyBpKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvbkRhdGFQdXNoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdHRoaXMuaW5zZXJ0RWxlbWVudHModGhpcy5nZXREYXRhc2V0KCkuZGF0YS5sZW5ndGggLSBjb3VudCwgY291bnQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25EYXRhUG9wOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnBvcCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25EYXRhU2hpZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEuc2hpZnQoKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9uRGF0YVNwbGljZTogZnVuY3Rpb24oc3RhcnQsIGNvdW50KSB7XG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcblx0XHR0aGlzLmluc2VydEVsZW1lbnRzKHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoIC0gMik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvbkRhdGFVbnNoaWZ0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmluc2VydEVsZW1lbnRzKDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuXHR9XG59KTtcblxuRGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kID0gaGVscGVycyQxLmluaGVyaXRzO1xuXG52YXIgY29yZV9kYXRhc2V0Q29udHJvbGxlciA9IERhdGFzZXRDb250cm9sbGVyO1xuXG52YXIgVEFVID0gTWF0aC5QSSAqIDI7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdGFyYzoge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogJyNmZmYnLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDIsXG5cdFx0XHRib3JkZXJBbGlnbjogJ2NlbnRlcidcblx0XHR9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBjbGlwQXJjKGN0eCwgYXJjKSB7XG5cdHZhciBzdGFydEFuZ2xlID0gYXJjLnN0YXJ0QW5nbGU7XG5cdHZhciBlbmRBbmdsZSA9IGFyYy5lbmRBbmdsZTtcblx0dmFyIHBpeGVsTWFyZ2luID0gYXJjLnBpeGVsTWFyZ2luO1xuXHR2YXIgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIGFyYy5vdXRlclJhZGl1cztcblx0dmFyIHggPSBhcmMueDtcblx0dmFyIHkgPSBhcmMueTtcblxuXHQvLyBEcmF3IGFuIGlubmVyIGJvcmRlciBieSBjbGlwaW5nIHRoZSBhcmMgYW5kIGRyYXdpbmcgYSBkb3VibGUtd2lkdGggYm9yZGVyXG5cdC8vIEVubGFyZ2UgdGhlIGNsaXBwaW5nIGFyYyBieSAwLjMzIHBpeGVscyB0byBlbGltaW5hdGUgZ2xpdGNoZXMgYmV0d2VlbiBib3JkZXJzXG5cdGN0eC5iZWdpblBhdGgoKTtcblx0Y3R4LmFyYyh4LCB5LCBhcmMub3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbik7XG5cdGlmIChhcmMuaW5uZXJSYWRpdXMgPiBwaXhlbE1hcmdpbikge1xuXHRcdGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBhcmMuaW5uZXJSYWRpdXM7XG5cdFx0Y3R4LmFyYyh4LCB5LCBhcmMuaW5uZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbiwgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcblx0fSBlbHNlIHtcblx0XHRjdHguYXJjKHgsIHksIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIE1hdGguUEkgLyAyLCBzdGFydEFuZ2xlIC0gTWF0aC5QSSAvIDIpO1xuXHR9XG5cdGN0eC5jbG9zZVBhdGgoKTtcblx0Y3R4LmNsaXAoKTtcbn1cblxuZnVuY3Rpb24gZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgdm0sIGFyYywgaW5uZXIpIHtcblx0dmFyIGVuZEFuZ2xlID0gYXJjLmVuZEFuZ2xlO1xuXHR2YXIgaTtcblxuXHRpZiAoaW5uZXIpIHtcblx0XHRhcmMuZW5kQW5nbGUgPSBhcmMuc3RhcnRBbmdsZSArIFRBVTtcblx0XHRjbGlwQXJjKGN0eCwgYXJjKTtcblx0XHRhcmMuZW5kQW5nbGUgPSBlbmRBbmdsZTtcblx0XHRpZiAoYXJjLmVuZEFuZ2xlID09PSBhcmMuc3RhcnRBbmdsZSAmJiBhcmMuZnVsbENpcmNsZXMpIHtcblx0XHRcdGFyYy5lbmRBbmdsZSArPSBUQVU7XG5cdFx0XHRhcmMuZnVsbENpcmNsZXMtLTtcblx0XHR9XG5cdH1cblxuXHRjdHguYmVnaW5QYXRoKCk7XG5cdGN0eC5hcmMoYXJjLngsIGFyYy55LCBhcmMuaW5uZXJSYWRpdXMsIGFyYy5zdGFydEFuZ2xlICsgVEFVLCBhcmMuc3RhcnRBbmdsZSwgdHJ1ZSk7XG5cdGZvciAoaSA9IDA7IGkgPCBhcmMuZnVsbENpcmNsZXM7ICsraSkge1xuXHRcdGN0eC5zdHJva2UoKTtcblx0fVxuXG5cdGN0eC5iZWdpblBhdGgoKTtcblx0Y3R4LmFyYyhhcmMueCwgYXJjLnksIHZtLm91dGVyUmFkaXVzLCBhcmMuc3RhcnRBbmdsZSwgYXJjLnN0YXJ0QW5nbGUgKyBUQVUpO1xuXHRmb3IgKGkgPSAwOyBpIDwgYXJjLmZ1bGxDaXJjbGVzOyArK2kpIHtcblx0XHRjdHguc3Ryb2tlKCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZHJhd0JvcmRlcihjdHgsIHZtLCBhcmMpIHtcblx0dmFyIGlubmVyID0gdm0uYm9yZGVyQWxpZ24gPT09ICdpbm5lcic7XG5cblx0aWYgKGlubmVyKSB7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9IHZtLmJvcmRlcldpZHRoICogMjtcblx0XHRjdHgubGluZUpvaW4gPSAncm91bmQnO1xuXHR9IGVsc2Uge1xuXHRcdGN0eC5saW5lV2lkdGggPSB2bS5ib3JkZXJXaWR0aDtcblx0XHRjdHgubGluZUpvaW4gPSAnYmV2ZWwnO1xuXHR9XG5cblx0aWYgKGFyYy5mdWxsQ2lyY2xlcykge1xuXHRcdGRyYXdGdWxsQ2lyY2xlQm9yZGVycyhjdHgsIHZtLCBhcmMsIGlubmVyKTtcblx0fVxuXG5cdGlmIChpbm5lcikge1xuXHRcdGNsaXBBcmMoY3R4LCBhcmMpO1xuXHR9XG5cblx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRjdHguYXJjKGFyYy54LCBhcmMueSwgdm0ub3V0ZXJSYWRpdXMsIGFyYy5zdGFydEFuZ2xlLCBhcmMuZW5kQW5nbGUpO1xuXHRjdHguYXJjKGFyYy54LCBhcmMueSwgYXJjLmlubmVyUmFkaXVzLCBhcmMuZW5kQW5nbGUsIGFyYy5zdGFydEFuZ2xlLCB0cnVlKTtcblx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRjdHguc3Ryb2tlKCk7XG59XG5cbnZhciBlbGVtZW50X2FyYyA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRfdHlwZTogJ2FyYycsXG5cblx0aW5MYWJlbFJhbmdlOiBmdW5jdGlvbihtb3VzZVgpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0aWYgKHZtKSB7XG5cdFx0XHRyZXR1cm4gKE1hdGgucG93KG1vdXNlWCAtIHZtLngsIDIpIDwgTWF0aC5wb3codm0ucmFkaXVzICsgdm0uaG92ZXJSYWRpdXMsIDIpKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGluUmFuZ2U6IGZ1bmN0aW9uKGNoYXJ0WCwgY2hhcnRZKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblxuXHRcdGlmICh2bSkge1xuXHRcdFx0dmFyIHBvaW50UmVsYXRpdmVQb3NpdGlvbiA9IGhlbHBlcnMkMS5nZXRBbmdsZUZyb21Qb2ludCh2bSwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XG5cdFx0XHR2YXIgYW5nbGUgPSBwb2ludFJlbGF0aXZlUG9zaXRpb24uYW5nbGU7XG5cdFx0XHR2YXIgZGlzdGFuY2UgPSBwb2ludFJlbGF0aXZlUG9zaXRpb24uZGlzdGFuY2U7XG5cblx0XHRcdC8vIFNhbml0aXNlIGFuZ2xlIHJhbmdlXG5cdFx0XHR2YXIgc3RhcnRBbmdsZSA9IHZtLnN0YXJ0QW5nbGU7XG5cdFx0XHR2YXIgZW5kQW5nbGUgPSB2bS5lbmRBbmdsZTtcblx0XHRcdHdoaWxlIChlbmRBbmdsZSA8IHN0YXJ0QW5nbGUpIHtcblx0XHRcdFx0ZW5kQW5nbGUgKz0gVEFVO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGFuZ2xlID4gZW5kQW5nbGUpIHtcblx0XHRcdFx0YW5nbGUgLT0gVEFVO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGFuZ2xlIDwgc3RhcnRBbmdsZSkge1xuXHRcdFx0XHRhbmdsZSArPSBUQVU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGlmIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgdGhlIG9wZW4vY2xvc2UgYW5nbGVcblx0XHRcdHZhciBiZXR3ZWVuQW5nbGVzID0gKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpO1xuXHRcdFx0dmFyIHdpdGhpblJhZGl1cyA9IChkaXN0YW5jZSA+PSB2bS5pbm5lclJhZGl1cyAmJiBkaXN0YW5jZSA8PSB2bS5vdXRlclJhZGl1cyk7XG5cblx0XHRcdHJldHVybiAoYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0Z2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIGhhbGZBbmdsZSA9ICh2bS5zdGFydEFuZ2xlICsgdm0uZW5kQW5nbGUpIC8gMjtcblx0XHR2YXIgaGFsZlJhZGl1cyA9ICh2bS5pbm5lclJhZGl1cyArIHZtLm91dGVyUmFkaXVzKSAvIDI7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHZtLnggKyBNYXRoLmNvcyhoYWxmQW5nbGUpICogaGFsZlJhZGl1cyxcblx0XHRcdHk6IHZtLnkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xuXHRcdH07XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gTWF0aC5QSSAqICgodm0uZW5kQW5nbGUgLSB2bS5zdGFydEFuZ2xlKSAvICgyICogTWF0aC5QSSkpICogKE1hdGgucG93KHZtLm91dGVyUmFkaXVzLCAyKSAtIE1hdGgucG93KHZtLmlubmVyUmFkaXVzLCAyKSk7XG5cdH0sXG5cblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBjZW50cmVBbmdsZSA9IHZtLnN0YXJ0QW5nbGUgKyAoKHZtLmVuZEFuZ2xlIC0gdm0uc3RhcnRBbmdsZSkgLyAyKTtcblx0XHR2YXIgcmFuZ2VGcm9tQ2VudHJlID0gKHZtLm91dGVyUmFkaXVzIC0gdm0uaW5uZXJSYWRpdXMpIC8gMiArIHZtLmlubmVyUmFkaXVzO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHZtLnggKyAoTWF0aC5jb3MoY2VudHJlQW5nbGUpICogcmFuZ2VGcm9tQ2VudHJlKSxcblx0XHRcdHk6IHZtLnkgKyAoTWF0aC5zaW4oY2VudHJlQW5nbGUpICogcmFuZ2VGcm9tQ2VudHJlKVxuXHRcdH07XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBwaXhlbE1hcmdpbiA9ICh2bS5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykgPyAwLjMzIDogMDtcblx0XHR2YXIgYXJjID0ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnksXG5cdFx0XHRpbm5lclJhZGl1czogdm0uaW5uZXJSYWRpdXMsXG5cdFx0XHRvdXRlclJhZGl1czogTWF0aC5tYXgodm0ub3V0ZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgMCksXG5cdFx0XHRwaXhlbE1hcmdpbjogcGl4ZWxNYXJnaW4sXG5cdFx0XHRzdGFydEFuZ2xlOiB2bS5zdGFydEFuZ2xlLFxuXHRcdFx0ZW5kQW5nbGU6IHZtLmVuZEFuZ2xlLFxuXHRcdFx0ZnVsbENpcmNsZXM6IE1hdGguZmxvb3Iodm0uY2lyY3VtZmVyZW5jZSAvIFRBVSlcblx0XHR9O1xuXHRcdHZhciBpO1xuXG5cdFx0Y3R4LnNhdmUoKTtcblxuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XG5cblx0XHRpZiAoYXJjLmZ1bGxDaXJjbGVzKSB7XG5cdFx0XHRhcmMuZW5kQW5nbGUgPSBhcmMuc3RhcnRBbmdsZSArIFRBVTtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5hcmMoYXJjLngsIGFyYy55LCBhcmMub3V0ZXJSYWRpdXMsIGFyYy5zdGFydEFuZ2xlLCBhcmMuZW5kQW5nbGUpO1xuXHRcdFx0Y3R4LmFyYyhhcmMueCwgYXJjLnksIGFyYy5pbm5lclJhZGl1cywgYXJjLmVuZEFuZ2xlLCBhcmMuc3RhcnRBbmdsZSwgdHJ1ZSk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgYXJjLmZ1bGxDaXJjbGVzOyArK2kpIHtcblx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdH1cblx0XHRcdGFyYy5lbmRBbmdsZSA9IGFyYy5zdGFydEFuZ2xlICsgdm0uY2lyY3VtZmVyZW5jZSAlIFRBVTtcblx0XHR9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyhhcmMueCwgYXJjLnksIGFyYy5vdXRlclJhZGl1cywgYXJjLnN0YXJ0QW5nbGUsIGFyYy5lbmRBbmdsZSk7XG5cdFx0Y3R4LmFyYyhhcmMueCwgYXJjLnksIGFyYy5pbm5lclJhZGl1cywgYXJjLmVuZEFuZ2xlLCBhcmMuc3RhcnRBbmdsZSwgdHJ1ZSk7XG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdGN0eC5maWxsKCk7XG5cblx0XHRpZiAodm0uYm9yZGVyV2lkdGgpIHtcblx0XHRcdGRyYXdCb3JkZXIoY3R4LCB2bSwgYXJjKTtcblx0XHR9XG5cblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9XG59KTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDEgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbnZhciBkZWZhdWx0Q29sb3IgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdGxpbmU6IHtcblx0XHRcdHRlbnNpb246IDAuNCxcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZGVmYXVsdENvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDMsXG5cdFx0XHRib3JkZXJDb2xvcjogZGVmYXVsdENvbG9yLFxuXHRcdFx0Ym9yZGVyQ2FwU3R5bGU6ICdidXR0Jyxcblx0XHRcdGJvcmRlckRhc2g6IFtdLFxuXHRcdFx0Ym9yZGVyRGFzaE9mZnNldDogMC4wLFxuXHRcdFx0Ym9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuXHRcdFx0Y2FwQmV6aWVyUG9pbnRzOiB0cnVlLFxuXHRcdFx0ZmlsbDogdHJ1ZSwgLy8gZG8gd2UgZmlsbCBpbiB0aGUgYXJlYSBiZXR3ZWVuIHRoZSBsaW5lIGFuZCBpdHMgYmFzZSBheGlzXG5cdFx0fVxuXHR9XG59KTtcblxudmFyIGVsZW1lbnRfbGluZSA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRfdHlwZTogJ2xpbmUnLFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHZtID0gbWUuX3ZpZXc7XG5cdFx0dmFyIGN0eCA9IG1lLl9jaGFydC5jdHg7XG5cdFx0dmFyIHNwYW5HYXBzID0gdm0uc3BhbkdhcHM7XG5cdFx0dmFyIHBvaW50cyA9IG1lLl9jaGlsZHJlbi5zbGljZSgpOyAvLyBjbG9uZSBhcnJheVxuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdHZhciBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMgPSBnbG9iYWxEZWZhdWx0cy5lbGVtZW50cy5saW5lO1xuXHRcdHZhciBsYXN0RHJhd25JbmRleCA9IC0xO1xuXHRcdHZhciBjbG9zZVBhdGggPSBtZS5fbG9vcDtcblx0XHR2YXIgaW5kZXgsIHByZXZpb3VzLCBjdXJyZW50Vk07XG5cblx0XHRpZiAoIXBvaW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAobWUuX2xvb3ApIHtcblx0XHRcdGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHBvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcblx0XHRcdFx0cHJldmlvdXMgPSBoZWxwZXJzJDEucHJldmlvdXNJdGVtKHBvaW50cywgaW5kZXgpO1xuXHRcdFx0XHQvLyBJZiB0aGUgbGluZSBoYXMgYW4gb3BlbiBwYXRoLCBzaGlmdCB0aGUgcG9pbnQgYXJyYXlcblx0XHRcdFx0aWYgKCFwb2ludHNbaW5kZXhdLl92aWV3LnNraXAgJiYgcHJldmlvdXMuX3ZpZXcuc2tpcCkge1xuXHRcdFx0XHRcdHBvaW50cyA9IHBvaW50cy5zbGljZShpbmRleCkuY29uY2F0KHBvaW50cy5zbGljZSgwLCBpbmRleCkpO1xuXHRcdFx0XHRcdGNsb3NlUGF0aCA9IHNwYW5HYXBzO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGUgbGluZSBoYXMgYSBjbG9zZSBwYXRoLCBhZGQgdGhlIGZpcnN0IHBvaW50IGFnYWluXG5cdFx0XHRpZiAoY2xvc2VQYXRoKSB7XG5cdFx0XHRcdHBvaW50cy5wdXNoKHBvaW50c1swXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y3R4LnNhdmUoKTtcblxuXHRcdC8vIFN0cm9rZSBMaW5lIE9wdGlvbnNcblx0XHRjdHgubGluZUNhcCA9IHZtLmJvcmRlckNhcFN0eWxlIHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJDYXBTdHlsZTtcblxuXHRcdC8vIElFIDkgYW5kIDEwIGRvIG5vdCBzdXBwb3J0IGxpbmUgZGFzaFxuXHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdGN0eC5zZXRMaW5lRGFzaCh2bS5ib3JkZXJEYXNoIHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJEYXNoKTtcblx0XHR9XG5cblx0XHRjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdCQxKHZtLmJvcmRlckRhc2hPZmZzZXQsIGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJEYXNoT2Zmc2V0KTtcblx0XHRjdHgubGluZUpvaW4gPSB2bS5ib3JkZXJKb2luU3R5bGUgfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckpvaW5TdHlsZTtcblx0XHRjdHgubGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQkMSh2bS5ib3JkZXJXaWR0aCwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlcldpZHRoKTtcblx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2bS5ib3JkZXJDb2xvciB8fCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Q29sb3I7XG5cblx0XHQvLyBTdHJva2UgTGluZVxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdC8vIEZpcnN0IHBvaW50IG1vdmVzIHRvIGl0J3Mgc3RhcnRpbmcgcG9zaXRpb24gbm8gbWF0dGVyIHdoYXRcblx0XHRjdXJyZW50Vk0gPSBwb2ludHNbMF0uX3ZpZXc7XG5cdFx0aWYgKCFjdXJyZW50Vk0uc2tpcCkge1xuXHRcdFx0Y3R4Lm1vdmVUbyhjdXJyZW50Vk0ueCwgY3VycmVudFZNLnkpO1xuXHRcdFx0bGFzdERyYXduSW5kZXggPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaW5kZXggPSAxOyBpbmRleCA8IHBvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcblx0XHRcdGN1cnJlbnRWTSA9IHBvaW50c1tpbmRleF0uX3ZpZXc7XG5cdFx0XHRwcmV2aW91cyA9IGxhc3REcmF3bkluZGV4ID09PSAtMSA/IGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpbmRleCkgOiBwb2ludHNbbGFzdERyYXduSW5kZXhdO1xuXG5cdFx0XHRpZiAoIWN1cnJlbnRWTS5za2lwKSB7XG5cdFx0XHRcdGlmICgobGFzdERyYXduSW5kZXggIT09IChpbmRleCAtIDEpICYmICFzcGFuR2FwcykgfHwgbGFzdERyYXduSW5kZXggPT09IC0xKSB7XG5cdFx0XHRcdFx0Ly8gVGhlcmUgd2FzIGEgZ2FwIGFuZCB0aGlzIGlzIHRoZSBmaXJzdCBwb2ludCBhZnRlciB0aGUgZ2FwXG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJyZW50Vk0ueCwgY3VycmVudFZNLnkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIExpbmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHRcdGhlbHBlcnMkMS5jYW52YXMubGluZVRvKGN0eCwgcHJldmlvdXMuX3ZpZXcsIGN1cnJlbnRWTSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGFzdERyYXduSW5kZXggPSBpbmRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY2xvc2VQYXRoKSB7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0fVxuXG5cdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH1cbn0pO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkMiA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxudmFyIGRlZmF1bHRDb2xvciQxID0gY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZWxlbWVudHM6IHtcblx0XHRwb2ludDoge1xuXHRcdFx0cmFkaXVzOiAzLFxuXHRcdFx0cG9pbnRTdHlsZTogJ2NpcmNsZScsXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGRlZmF1bHRDb2xvciQxLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IGRlZmF1bHRDb2xvciQxLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdFx0XHQvLyBIb3ZlclxuXHRcdFx0aGl0UmFkaXVzOiAxLFxuXHRcdFx0aG92ZXJSYWRpdXM6IDQsXG5cdFx0XHRob3ZlckJvcmRlcldpZHRoOiAxXG5cdFx0fVxuXHR9XG59KTtcblxuZnVuY3Rpb24geFJhbmdlKG1vdXNlWCkge1xuXHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRyZXR1cm4gdm0gPyAoTWF0aC5hYnMobW91c2VYIC0gdm0ueCkgPCB2bS5yYWRpdXMgKyB2bS5oaXRSYWRpdXMpIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHlSYW5nZShtb3VzZVkpIHtcblx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0cmV0dXJuIHZtID8gKE1hdGguYWJzKG1vdXNlWSAtIHZtLnkpIDwgdm0ucmFkaXVzICsgdm0uaGl0UmFkaXVzKSA6IGZhbHNlO1xufVxuXG52YXIgZWxlbWVudF9wb2ludCA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRfdHlwZTogJ3BvaW50JyxcblxuXHRpblJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIHZtID8gKChNYXRoLnBvdyhtb3VzZVggLSB2bS54LCAyKSArIE1hdGgucG93KG1vdXNlWSAtIHZtLnksIDIpKSA8IE1hdGgucG93KHZtLmhpdFJhZGl1cyArIHZtLnJhZGl1cywgMikpIDogZmFsc2U7XG5cdH0sXG5cblx0aW5MYWJlbFJhbmdlOiB4UmFuZ2UsXG5cdGluWFJhbmdlOiB4UmFuZ2UsXG5cdGluWVJhbmdlOiB5UmFuZ2UsXG5cblx0Z2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHZtLngsXG5cdFx0XHR5OiB2bS55XG5cdFx0fTtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTWF0aC5QSSAqIE1hdGgucG93KHRoaXMuX3ZpZXcucmFkaXVzLCAyKTtcblx0fSxcblxuXHR0b29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHZtLngsXG5cdFx0XHR5OiB2bS55LFxuXHRcdFx0cGFkZGluZzogdm0ucmFkaXVzICsgdm0uYm9yZGVyV2lkdGhcblx0XHR9O1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGNoYXJ0QXJlYSkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHR2YXIgcG9pbnRTdHlsZSA9IHZtLnBvaW50U3R5bGU7XG5cdFx0dmFyIHJvdGF0aW9uID0gdm0ucm90YXRpb247XG5cdFx0dmFyIHJhZGl1cyA9IHZtLnJhZGl1cztcblx0XHR2YXIgeCA9IHZtLng7XG5cdFx0dmFyIHkgPSB2bS55O1xuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdHZhciBkZWZhdWx0Q29sb3IgPSBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Q29sb3I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2hhZG93XG5cblx0XHRpZiAodm0uc2tpcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENsaXBwaW5nIGZvciBQb2ludHMuXG5cdFx0aWYgKGNoYXJ0QXJlYSA9PT0gdW5kZWZpbmVkIHx8IGhlbHBlcnMkMS5jYW52YXMuX2lzUG9pbnRJbkFyZWEodm0sIGNoYXJ0QXJlYSkpIHtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yIHx8IGRlZmF1bHRDb2xvcjtcblx0XHRcdGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQyKHZtLmJvcmRlcldpZHRoLCBnbG9iYWxEZWZhdWx0cy5lbGVtZW50cy5wb2ludC5ib3JkZXJXaWR0aCk7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yIHx8IGRlZmF1bHRDb2xvcjtcblx0XHRcdGhlbHBlcnMkMS5jYW52YXMuZHJhd1BvaW50KGN0eCwgcG9pbnRTdHlsZSwgcmFkaXVzLCB4LCB5LCByb3RhdGlvbik7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIGRlZmF1bHRDb2xvciQyID0gY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZWxlbWVudHM6IHtcblx0XHRyZWN0YW5nbGU6IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZGVmYXVsdENvbG9yJDIsXG5cdFx0XHRib3JkZXJDb2xvcjogZGVmYXVsdENvbG9yJDIsXG5cdFx0XHRib3JkZXJTa2lwcGVkOiAnYm90dG9tJyxcblx0XHRcdGJvcmRlcldpZHRoOiAwXG5cdFx0fVxuXHR9XG59KTtcblxuZnVuY3Rpb24gaXNWZXJ0aWNhbCh2bSkge1xuXHRyZXR1cm4gdm0gJiYgdm0ud2lkdGggIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBib3VuZHMgb2YgdGhlIGJhciByZWdhcmRsZXNzIG9mIHRoZSBvcmllbnRhdGlvblxuICogQHBhcmFtIGJhciB7Q2hhcnQuRWxlbWVudC5SZWN0YW5nbGV9IHRoZSBiYXJcbiAqIEByZXR1cm4ge0JvdW5kc30gYm91bmRzIG9mIHRoZSBiYXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEJhckJvdW5kcyh2bSkge1xuXHR2YXIgeDEsIHgyLCB5MSwgeTIsIGhhbGY7XG5cblx0aWYgKGlzVmVydGljYWwodm0pKSB7XG5cdFx0aGFsZiA9IHZtLndpZHRoIC8gMjtcblx0XHR4MSA9IHZtLnggLSBoYWxmO1xuXHRcdHgyID0gdm0ueCArIGhhbGY7XG5cdFx0eTEgPSBNYXRoLm1pbih2bS55LCB2bS5iYXNlKTtcblx0XHR5MiA9IE1hdGgubWF4KHZtLnksIHZtLmJhc2UpO1xuXHR9IGVsc2Uge1xuXHRcdGhhbGYgPSB2bS5oZWlnaHQgLyAyO1xuXHRcdHgxID0gTWF0aC5taW4odm0ueCwgdm0uYmFzZSk7XG5cdFx0eDIgPSBNYXRoLm1heCh2bS54LCB2bS5iYXNlKTtcblx0XHR5MSA9IHZtLnkgLSBoYWxmO1xuXHRcdHkyID0gdm0ueSArIGhhbGY7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGxlZnQ6IHgxLFxuXHRcdHRvcDogeTEsXG5cdFx0cmlnaHQ6IHgyLFxuXHRcdGJvdHRvbTogeTJcblx0fTtcbn1cblxuZnVuY3Rpb24gc3dhcChvcmlnLCB2MSwgdjIpIHtcblx0cmV0dXJuIG9yaWcgPT09IHYxID8gdjIgOiBvcmlnID09PSB2MiA/IHYxIDogb3JpZztcbn1cblxuZnVuY3Rpb24gcGFyc2VCb3JkZXJTa2lwcGVkKHZtKSB7XG5cdHZhciBlZGdlID0gdm0uYm9yZGVyU2tpcHBlZDtcblx0dmFyIHJlcyA9IHt9O1xuXG5cdGlmICghZWRnZSkge1xuXHRcdHJldHVybiByZXM7XG5cdH1cblxuXHRpZiAodm0uaG9yaXpvbnRhbCkge1xuXHRcdGlmICh2bS5iYXNlID4gdm0ueCkge1xuXHRcdFx0ZWRnZSA9IHN3YXAoZWRnZSwgJ2xlZnQnLCAncmlnaHQnKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodm0uYmFzZSA8IHZtLnkpIHtcblx0XHRlZGdlID0gc3dhcChlZGdlLCAnYm90dG9tJywgJ3RvcCcpO1xuXHR9XG5cblx0cmVzW2VkZ2VdID0gdHJ1ZTtcblx0cmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcGFyc2VCb3JkZXJXaWR0aCh2bSwgbWF4VywgbWF4SCkge1xuXHR2YXIgdmFsdWUgPSB2bS5ib3JkZXJXaWR0aDtcblx0dmFyIHNraXAgPSBwYXJzZUJvcmRlclNraXBwZWQodm0pO1xuXHR2YXIgdCwgciwgYiwgbDtcblxuXHRpZiAoaGVscGVycyQxLmlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdHQgPSArdmFsdWUudG9wIHx8IDA7XG5cdFx0ciA9ICt2YWx1ZS5yaWdodCB8fCAwO1xuXHRcdGIgPSArdmFsdWUuYm90dG9tIHx8IDA7XG5cdFx0bCA9ICt2YWx1ZS5sZWZ0IHx8IDA7XG5cdH0gZWxzZSB7XG5cdFx0dCA9IHIgPSBiID0gbCA9ICt2YWx1ZSB8fCAwO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHR0OiBza2lwLnRvcCB8fCAodCA8IDApID8gMCA6IHQgPiBtYXhIID8gbWF4SCA6IHQsXG5cdFx0cjogc2tpcC5yaWdodCB8fCAociA8IDApID8gMCA6IHIgPiBtYXhXID8gbWF4VyA6IHIsXG5cdFx0Yjogc2tpcC5ib3R0b20gfHwgKGIgPCAwKSA/IDAgOiBiID4gbWF4SCA/IG1heEggOiBiLFxuXHRcdGw6IHNraXAubGVmdCB8fCAobCA8IDApID8gMCA6IGwgPiBtYXhXID8gbWF4VyA6IGxcblx0fTtcbn1cblxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyh2bSkge1xuXHR2YXIgYm91bmRzID0gZ2V0QmFyQm91bmRzKHZtKTtcblx0dmFyIHdpZHRoID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQ7XG5cdHZhciBoZWlnaHQgPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcDtcblx0dmFyIGJvcmRlciA9IHBhcnNlQm9yZGVyV2lkdGgodm0sIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cblx0cmV0dXJuIHtcblx0XHRvdXRlcjoge1xuXHRcdFx0eDogYm91bmRzLmxlZnQsXG5cdFx0XHR5OiBib3VuZHMudG9wLFxuXHRcdFx0dzogd2lkdGgsXG5cdFx0XHRoOiBoZWlnaHRcblx0XHR9LFxuXHRcdGlubmVyOiB7XG5cdFx0XHR4OiBib3VuZHMubGVmdCArIGJvcmRlci5sLFxuXHRcdFx0eTogYm91bmRzLnRvcCArIGJvcmRlci50LFxuXHRcdFx0dzogd2lkdGggLSBib3JkZXIubCAtIGJvcmRlci5yLFxuXHRcdFx0aDogaGVpZ2h0IC0gYm9yZGVyLnQgLSBib3JkZXIuYlxuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gaW5SYW5nZSh2bSwgeCwgeSkge1xuXHR2YXIgc2tpcFggPSB4ID09PSBudWxsO1xuXHR2YXIgc2tpcFkgPSB5ID09PSBudWxsO1xuXHR2YXIgYm91bmRzID0gIXZtIHx8IChza2lwWCAmJiBza2lwWSkgPyBmYWxzZSA6IGdldEJhckJvdW5kcyh2bSk7XG5cblx0cmV0dXJuIGJvdW5kc1xuXHRcdCYmIChza2lwWCB8fCB4ID49IGJvdW5kcy5sZWZ0ICYmIHggPD0gYm91bmRzLnJpZ2h0KVxuXHRcdCYmIChza2lwWSB8fCB5ID49IGJvdW5kcy50b3AgJiYgeSA8PSBib3VuZHMuYm90dG9tKTtcbn1cblxudmFyIGVsZW1lbnRfcmVjdGFuZ2xlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdF90eXBlOiAncmVjdGFuZ2xlJyxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIHJlY3RzID0gYm91bmRpbmdSZWN0cyh2bSk7XG5cdFx0dmFyIG91dGVyID0gcmVjdHMub3V0ZXI7XG5cdFx0dmFyIGlubmVyID0gcmVjdHMuaW5uZXI7XG5cblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xuXHRcdGN0eC5maWxsUmVjdChvdXRlci54LCBvdXRlci55LCBvdXRlci53LCBvdXRlci5oKTtcblxuXHRcdGlmIChvdXRlci53ID09PSBpbm5lci53ICYmIG91dGVyLmggPT09IGlubmVyLmgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgucmVjdChvdXRlci54LCBvdXRlci55LCBvdXRlci53LCBvdXRlci5oKTtcblx0XHRjdHguY2xpcCgpO1xuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5ib3JkZXJDb2xvcjtcblx0XHRjdHgucmVjdChpbm5lci54LCBpbm5lci55LCBpbm5lci53LCBpbm5lci5oKTtcblx0XHRjdHguZmlsbCgnZXZlbm9kZCcpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH0sXG5cblx0aGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB2bS5iYXNlIC0gdm0ueTtcblx0fSxcblxuXHRpblJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xuXHRcdHJldHVybiBpblJhbmdlKHRoaXMuX3ZpZXcsIG1vdXNlWCwgbW91c2VZKTtcblx0fSxcblxuXHRpbkxhYmVsUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCwgbW91c2VZKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gaXNWZXJ0aWNhbCh2bSlcblx0XHRcdD8gaW5SYW5nZSh2bSwgbW91c2VYLCBudWxsKVxuXHRcdFx0OiBpblJhbmdlKHZtLCBudWxsLCBtb3VzZVkpO1xuXHR9LFxuXG5cdGluWFJhbmdlOiBmdW5jdGlvbihtb3VzZVgpIHtcblx0XHRyZXR1cm4gaW5SYW5nZSh0aGlzLl92aWV3LCBtb3VzZVgsIG51bGwpO1xuXHR9LFxuXG5cdGluWVJhbmdlOiBmdW5jdGlvbihtb3VzZVkpIHtcblx0XHRyZXR1cm4gaW5SYW5nZSh0aGlzLl92aWV3LCBudWxsLCBtb3VzZVkpO1xuXHR9LFxuXG5cdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciB4LCB5O1xuXHRcdGlmIChpc1ZlcnRpY2FsKHZtKSkge1xuXHRcdFx0eCA9IHZtLng7XG5cdFx0XHR5ID0gKHZtLnkgKyB2bS5iYXNlKSAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHggPSAodm0ueCArIHZtLmJhc2UpIC8gMjtcblx0XHRcdHkgPSB2bS55O1xuXHRcdH1cblxuXHRcdHJldHVybiB7eDogeCwgeTogeX07XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblxuXHRcdHJldHVybiBpc1ZlcnRpY2FsKHZtKVxuXHRcdFx0PyB2bS53aWR0aCAqIE1hdGguYWJzKHZtLnkgLSB2bS5iYXNlKVxuXHRcdFx0OiB2bS5oZWlnaHQgKiBNYXRoLmFicyh2bS54IC0gdm0uYmFzZSk7XG5cdH0sXG5cblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54LFxuXHRcdFx0eTogdm0ueVxuXHRcdH07XG5cdH1cbn0pO1xuXG52YXIgZWxlbWVudHMgPSB7fTtcbnZhciBBcmMgPSBlbGVtZW50X2FyYztcbnZhciBMaW5lID0gZWxlbWVudF9saW5lO1xudmFyIFBvaW50ID0gZWxlbWVudF9wb2ludDtcbnZhciBSZWN0YW5nbGUgPSBlbGVtZW50X3JlY3RhbmdsZTtcbmVsZW1lbnRzLkFyYyA9IEFyYztcbmVsZW1lbnRzLkxpbmUgPSBMaW5lO1xuZWxlbWVudHMuUG9pbnQgPSBQb2ludDtcbmVsZW1lbnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcblxudmFyIGRlcHJlY2F0ZWQgPSBoZWxwZXJzJDEuX2RlcHJlY2F0ZWQ7XG52YXIgdmFsdWVPckRlZmF1bHQkMyA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdiYXInLCB7XG5cdGhvdmVyOiB7XG5cdFx0bW9kZTogJ2xhYmVsJ1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2NhdGVnb3J5Jyxcblx0XHRcdG9mZnNldDogdHJ1ZSxcblx0XHRcdGdyaWRMaW5lczoge1xuXHRcdFx0XHRvZmZzZXRHcmlkTGluZXM6IHRydWVcblx0XHRcdH1cblx0XHR9XSxcblxuXHRcdHlBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcidcblx0XHR9XVxuXHR9XG59KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGRhdGFzZXRzOiB7XG5cdFx0YmFyOiB7XG5cdFx0XHRjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcblx0XHRcdGJhclBlcmNlbnRhZ2U6IDAuOVxuXHRcdH1cblx0fVxufSk7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFwib3B0aW1hbFwiIHNhbXBsZSBzaXplIHRvIG1haW50YWluIGJhcnMgZXF1YWxseSBzaXplZCB3aGlsZSBwcmV2ZW50aW5nIG92ZXJsYXAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShzY2FsZSwgcGl4ZWxzKSB7XG5cdHZhciBtaW4gPSBzY2FsZS5fbGVuZ3RoO1xuXHR2YXIgcHJldiwgY3VyciwgaSwgaWxlbjtcblxuXHRmb3IgKGkgPSAxLCBpbGVuID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMocGl4ZWxzW2ldIC0gcGl4ZWxzW2kgLSAxXSkpO1xuXHR9XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHNjYWxlLmdldFRpY2tzKCkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0Y3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcblx0XHRtaW4gPSBpID4gMCA/IE1hdGgubWluKG1pbiwgTWF0aC5hYnMoY3VyciAtIHByZXYpKSA6IG1pbjtcblx0XHRwcmV2ID0gY3Vycjtcblx0fVxuXG5cdHJldHVybiBtaW47XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gXCJpZGVhbFwiIGNhdGVnb3J5IGJhc2VkIG9uIHRoZSBhYnNvbHV0ZSBiYXIgdGhpY2tuZXNzIG9yLCBpZiB1bmRlZmluZWQgb3IgbnVsbCxcbiAqIHVzZXMgdGhlIHNtYWxsZXN0IGludGVydmFsIChzZWUgY29tcHV0ZU1pblNhbXBsZVNpemUpIHRoYXQgcHJldmVudHMgYmFyIG92ZXJsYXBwaW5nLiBUaGlzXG4gKiBtb2RlIGN1cnJlbnRseSBhbHdheXMgZ2VuZXJhdGVzIGJhcnMgZXF1YWxseSBzaXplZCAodW50aWwgd2UgaW50cm9kdWNlIHNjcmlwdGFibGUgb3B0aW9ucz8pLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucykge1xuXHR2YXIgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG5cdHZhciBjb3VudCA9IHJ1bGVyLnN0YWNrQ291bnQ7XG5cdHZhciBjdXJyID0gcnVsZXIucGl4ZWxzW2luZGV4XTtcblx0dmFyIG1pbiA9IGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHRoaWNrbmVzcylcblx0XHQ/IGNvbXB1dGVNaW5TYW1wbGVTaXplKHJ1bGVyLnNjYWxlLCBydWxlci5waXhlbHMpXG5cdFx0OiAtMTtcblx0dmFyIHNpemUsIHJhdGlvO1xuXG5cdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG5cdFx0c2l6ZSA9IG1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXHRcdHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFdoZW4gYmFyIHRoaWNrbmVzcyBpcyBlbmZvcmNlZCwgY2F0ZWdvcnkgYW5kIGJhciBwZXJjZW50YWdlcyBhcmUgaWdub3JlZC5cblx0XHQvLyBOb3RlKFNCKTogd2UgY291bGQgYWRkIHN1cHBvcnQgZm9yIHJlbGF0aXZlIGJhciB0aGlja25lc3MgKGUuZy4gYmFyVGhpY2tuZXNzOiAnNTAlJylcblx0XHQvLyBhbmQgZGVwcmVjYXRlIGJhclBlcmNlbnRhZ2Ugc2luY2UgdGhpcyB2YWx1ZSBpcyBpZ25vcmVkIHdoZW4gdGhpY2tuZXNzIGlzIGFic29sdXRlLlxuXHRcdHNpemUgPSB0aGlja25lc3MgKiBjb3VudDtcblx0XHRyYXRpbyA9IDE7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGNodW5rOiBzaXplIC8gY291bnQsXG5cdFx0cmF0aW86IHJhdGlvLFxuXHRcdHN0YXJ0OiBjdXJyIC0gKHNpemUgLyAyKVxuXHR9O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwib3B0aW1hbFwiIGNhdGVnb3J5IHRoYXQgZ2xvYmFsbHkgYXJyYW5nZXMgYmFycyBzaWRlIGJ5IHNpZGUgKG5vIGdhcCB3aGVuXG4gKiBwZXJjZW50YWdlIG9wdGlvbnMgYXJlIDEpLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYW5kIGZvbGxvd2luZyBjYXRlZ29yaWVzLiBUaGlzIG1vZGVcbiAqIGdlbmVyYXRlcyBiYXJzIHdpdGggZGlmZmVyZW50IHdpZHRocyB3aGVuIGRhdGEgYXJlIG5vdCBldmVubHkgc3BhY2VkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMpIHtcblx0dmFyIHBpeGVscyA9IHJ1bGVyLnBpeGVscztcblx0dmFyIGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xuXHR2YXIgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcblx0dmFyIG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuXHR2YXIgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXHR2YXIgc3RhcnQsIHNpemU7XG5cblx0aWYgKHByZXYgPT09IG51bGwpIHtcblx0XHQvLyBmaXJzdCBkYXRhOiBpdHMgc2l6ZSBpcyBkb3VibGUgYmFzZWQgb24gdGhlIG5leHQgcG9pbnQgb3IsXG5cdFx0Ly8gaWYgaXQncyBhbHNvIHRoZSBsYXN0IGRhdGEsIHdlIHVzZSB0aGUgc2NhbGUgc2l6ZS5cblx0XHRwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XG5cdH1cblxuXHRpZiAobmV4dCA9PT0gbnVsbCkge1xuXHRcdC8vIGxhc3QgZGF0YTogaXRzIHNpemUgaXMgYWxzbyBkb3VibGUgYmFzZWQgb24gdGhlIHByZXZpb3VzIHBvaW50LlxuXHRcdG5leHQgPSBjdXJyICsgY3VyciAtIHByZXY7XG5cdH1cblxuXHRzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xuXHRzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG5cblx0cmV0dXJuIHtcblx0XHRjaHVuazogc2l6ZSAvIHJ1bGVyLnN0YWNrQ291bnQsXG5cdFx0cmF0aW86IG9wdGlvbnMuYmFyUGVyY2VudGFnZSxcblx0XHRzdGFydDogc3RhcnRcblx0fTtcbn1cblxudmFyIGNvbnRyb2xsZXJfYmFyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUmVjdGFuZ2xlLFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2RhdGFFbGVtZW50T3B0aW9uczogW1xuXHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxuXHRcdCdib3JkZXJDb2xvcicsXG5cdFx0J2JvcmRlclNraXBwZWQnLFxuXHRcdCdib3JkZXJXaWR0aCcsXG5cdFx0J2JhclBlcmNlbnRhZ2UnLFxuXHRcdCdiYXJUaGlja25lc3MnLFxuXHRcdCdjYXRlZ29yeVBlcmNlbnRhZ2UnLFxuXHRcdCdtYXhCYXJUaGlja25lc3MnLFxuXHRcdCdtaW5CYXJMZW5ndGgnXG5cdF0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSwgc2NhbGVPcHRzO1xuXG5cdFx0Y29yZV9kYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblxuXHRcdG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0bWV0YS5zdGFjayA9IG1lLmdldERhdGFzZXQoKS5zdGFjaztcblx0XHRtZXRhLmJhciA9IHRydWU7XG5cblx0XHRzY2FsZU9wdHMgPSBtZS5fZ2V0SW5kZXhTY2FsZSgpLm9wdGlvbnM7XG5cdFx0ZGVwcmVjYXRlZCgnYmFyIGNoYXJ0Jywgc2NhbGVPcHRzLmJhclBlcmNlbnRhZ2UsICdzY2FsZXMuW3gveV1BeGVzLmJhclBlcmNlbnRhZ2UnLCAnZGF0YXNldC5iYXJQZXJjZW50YWdlJyk7XG5cdFx0ZGVwcmVjYXRlZCgnYmFyIGNoYXJ0Jywgc2NhbGVPcHRzLmJhclRoaWNrbmVzcywgJ3NjYWxlcy5beC95XUF4ZXMuYmFyVGhpY2tuZXNzJywgJ2RhdGFzZXQuYmFyVGhpY2tuZXNzJyk7XG5cdFx0ZGVwcmVjYXRlZCgnYmFyIGNoYXJ0Jywgc2NhbGVPcHRzLmNhdGVnb3J5UGVyY2VudGFnZSwgJ3NjYWxlcy5beC95XUF4ZXMuY2F0ZWdvcnlQZXJjZW50YWdlJywgJ2RhdGFzZXQuY2F0ZWdvcnlQZXJjZW50YWdlJyk7XG5cdFx0ZGVwcmVjYXRlZCgnYmFyIGNoYXJ0JywgbWUuX2dldFZhbHVlU2NhbGUoKS5vcHRpb25zLm1pbkJhckxlbmd0aCwgJ3NjYWxlcy5beC95XUF4ZXMubWluQmFyTGVuZ3RoJywgJ2RhdGFzZXQubWluQmFyTGVuZ3RoJyk7XG5cdFx0ZGVwcmVjYXRlZCgnYmFyIGNoYXJ0Jywgc2NhbGVPcHRzLm1heEJhclRoaWNrbmVzcywgJ3NjYWxlcy5beC95XUF4ZXMubWF4QmFyVGhpY2tuZXNzJywgJ2RhdGFzZXQubWF4QmFyVGhpY2tuZXNzJyk7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHJlY3RzID0gbWUuZ2V0TWV0YSgpLmRhdGE7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHRtZS5fcnVsZXIgPSBtZS5nZXRSdWxlcigpO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHJlY3RzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWUudXBkYXRlRWxlbWVudChyZWN0c1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihyZWN0YW5nbGUsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhyZWN0YW5nbGUsIGluZGV4KTtcblxuXHRcdHJlY3RhbmdsZS5feFNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnhBeGlzSUQpO1xuXHRcdHJlY3RhbmdsZS5feVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdHJlY3RhbmdsZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0cmVjdGFuZ2xlLl9pbmRleCA9IGluZGV4O1xuXHRcdHJlY3RhbmdsZS5fbW9kZWwgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJTa2lwcGVkOiBvcHRpb25zLmJvcmRlclNraXBwZWQsXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdGRhdGFzZXRMYWJlbDogZGF0YXNldC5sYWJlbCxcblx0XHRcdGxhYmVsOiBtZS5jaGFydC5kYXRhLmxhYmVsc1tpbmRleF1cblx0XHR9O1xuXG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGRhdGFzZXQuZGF0YVtpbmRleF0pKSB7XG5cdFx0XHRyZWN0YW5nbGUuX21vZGVsLmJvcmRlclNraXBwZWQgPSBudWxsO1xuXHRcdH1cblxuXHRcdG1lLl91cGRhdGVFbGVtZW50R2VvbWV0cnkocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQsIG9wdGlvbnMpO1xuXG5cdFx0cmVjdGFuZ2xlLnBpdm90KCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfdXBkYXRlRWxlbWVudEdlb21ldHJ5OiBmdW5jdGlvbihyZWN0YW5nbGUsIGluZGV4LCByZXNldCwgb3B0aW9ucykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1vZGVsID0gcmVjdGFuZ2xlLl9tb2RlbDtcblx0XHR2YXIgdnNjYWxlID0gbWUuX2dldFZhbHVlU2NhbGUoKTtcblx0XHR2YXIgYmFzZSA9IHZzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcblx0XHR2YXIgaG9yaXpvbnRhbCA9IHZzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgcnVsZXIgPSBtZS5fcnVsZXIgfHwgbWUuZ2V0UnVsZXIoKTtcblx0XHR2YXIgdnBpeGVscyA9IG1lLmNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKG1lLmluZGV4LCBpbmRleCwgb3B0aW9ucyk7XG5cdFx0dmFyIGlwaXhlbHMgPSBtZS5jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhtZS5pbmRleCwgaW5kZXgsIHJ1bGVyLCBvcHRpb25zKTtcblxuXHRcdG1vZGVsLmhvcml6b250YWwgPSBob3Jpem9udGFsO1xuXHRcdG1vZGVsLmJhc2UgPSByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmJhc2U7XG5cdFx0bW9kZWwueCA9IGhvcml6b250YWwgPyByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcjtcblx0XHRtb2RlbC55ID0gaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogcmVzZXQgPyBiYXNlIDogdnBpeGVscy5oZWFkO1xuXHRcdG1vZGVsLmhlaWdodCA9IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiB1bmRlZmluZWQ7XG5cdFx0bW9kZWwud2lkdGggPSBob3Jpem9udGFsID8gdW5kZWZpbmVkIDogaXBpeGVscy5zaXplO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtsYXN0XSAtIFRoZSBkYXRhc2V0IGluZGV4XG5cdCAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGxpc3Qgb2Ygc3RhY2sgSURzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0U3RhY2tzOiBmdW5jdGlvbihsYXN0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0SW5kZXhTY2FsZSgpO1xuXHRcdHZhciBtZXRhc2V0cyA9IHNjYWxlLl9nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyhtZS5fdHlwZSk7XG5cdFx0dmFyIHN0YWNrZWQgPSBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG5cdFx0dmFyIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7XG5cdFx0dmFyIHN0YWNrcyA9IFtdO1xuXHRcdHZhciBpLCBtZXRhO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWV0YSA9IG1ldGFzZXRzW2ldO1xuXHRcdFx0Ly8gc3RhY2tlZCAgIHwgbWV0YS5zdGFja1xuXHRcdFx0Ly8gICAgICAgICAgIHwgZm91bmQgfCBub3QgZm91bmQgfCB1bmRlZmluZWRcblx0XHRcdC8vIGZhbHNlICAgICB8ICAgeCAgIHwgICAgIHggICAgIHwgICAgIHhcblx0XHRcdC8vIHRydWUgICAgICB8ICAgICAgIHwgICAgIHggICAgIHxcblx0XHRcdC8vIHVuZGVmaW5lZCB8ICAgICAgIHwgICAgIHggICAgIHwgICAgIHhcblx0XHRcdGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpKSB7XG5cdFx0XHRcdHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1ldGEuaW5kZXggPT09IGxhc3QpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0YWNrcztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIG51bWJlciBvZiBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFN0YWNrQ291bnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRTdGFja3MoKS5sZW5ndGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrIGluZGV4IGZvciB0aGUgZ2l2ZW4gZGF0YXNldCBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFzZXRJbmRleF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gVGhlIHN0YWNrIG5hbWUgdG8gZmluZFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc3RhY2sgaW5kZXhcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFN0YWNrSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgbmFtZSkge1xuXHRcdHZhciBzdGFja3MgPSB0aGlzLl9nZXRTdGFja3MoZGF0YXNldEluZGV4KTtcblx0XHR2YXIgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0PyBzdGFja3MuaW5kZXhPZihuYW1lKVxuXHRcdFx0OiAtMTsgLy8gaW5kZXhPZiByZXR1cm5zIC0xIGlmIGVsZW1lbnQgaXMgbm90IHByZXNlbnRcblxuXHRcdHJldHVybiAoaW5kZXggPT09IC0xKVxuXHRcdFx0PyBzdGFja3MubGVuZ3RoIC0gMVxuXHRcdFx0OiBpbmRleDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFJ1bGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBzY2FsZSA9IG1lLl9nZXRJbmRleFNjYWxlKCk7XG5cdFx0dmFyIHBpeGVscyA9IFtdO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmdldE1ldGEoKS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cGl4ZWxzLnB1c2goc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShudWxsLCBpLCBtZS5pbmRleCkpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRwaXhlbHM6IHBpeGVscyxcblx0XHRcdHN0YXJ0OiBzY2FsZS5fc3RhcnRQaXhlbCxcblx0XHRcdGVuZDogc2NhbGUuX2VuZFBpeGVsLFxuXHRcdFx0c3RhY2tDb3VudDogbWUuZ2V0U3RhY2tDb3VudCgpLFxuXHRcdFx0c2NhbGU6IHNjYWxlXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogTm90ZTogcGl4ZWwgdmFsdWVzIGFyZSBub3QgY2xhbXBlZCB0byB0aGUgc2NhbGUgYXJlYS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgsIGluZGV4LCBvcHRpb25zKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0VmFsdWVTY2FsZSgpO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBtZXRhc2V0cyA9IHNjYWxlLl9nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyhtZS5fdHlwZSk7XG5cdFx0dmFyIHZhbHVlID0gc2NhbGUuX3BhcnNlVmFsdWUoZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XG5cdFx0dmFyIG1pbkJhckxlbmd0aCA9IG9wdGlvbnMubWluQmFyTGVuZ3RoO1xuXHRcdHZhciBzdGFja2VkID0gc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuXHRcdHZhciBzdGFjayA9IG1lLmdldE1ldGEoKS5zdGFjaztcblx0XHR2YXIgc3RhcnQgPSB2YWx1ZS5zdGFydCA9PT0gdW5kZWZpbmVkID8gMCA6IHZhbHVlLm1heCA+PSAwICYmIHZhbHVlLm1pbiA+PSAwID8gdmFsdWUubWluIDogdmFsdWUubWF4O1xuXHRcdHZhciBsZW5ndGggPSB2YWx1ZS5zdGFydCA9PT0gdW5kZWZpbmVkID8gdmFsdWUuZW5kIDogdmFsdWUubWF4ID49IDAgJiYgdmFsdWUubWluID49IDAgPyB2YWx1ZS5tYXggLSB2YWx1ZS5taW4gOiB2YWx1ZS5taW4gLSB2YWx1ZS5tYXg7XG5cdFx0dmFyIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7XG5cdFx0dmFyIGksIGltZXRhLCBpdmFsdWUsIGJhc2UsIGhlYWQsIHNpemUsIHN0YWNrTGVuZ3RoO1xuXG5cdFx0aWYgKHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBzdGFjayAhPT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRpbWV0YSA9IG1ldGFzZXRzW2ldO1xuXG5cdFx0XHRcdGlmIChpbWV0YS5pbmRleCA9PT0gZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaW1ldGEuc3RhY2sgPT09IHN0YWNrKSB7XG5cdFx0XHRcdFx0c3RhY2tMZW5ndGggPSBzY2FsZS5fcGFyc2VWYWx1ZShkYXRhc2V0c1tpbWV0YS5pbmRleF0uZGF0YVtpbmRleF0pO1xuXHRcdFx0XHRcdGl2YWx1ZSA9IHN0YWNrTGVuZ3RoLnN0YXJ0ID09PSB1bmRlZmluZWQgPyBzdGFja0xlbmd0aC5lbmQgOiBzdGFja0xlbmd0aC5taW4gPj0gMCAmJiBzdGFja0xlbmd0aC5tYXggPj0gMCA/IHN0YWNrTGVuZ3RoLm1heCA6IHN0YWNrTGVuZ3RoLm1pbjtcblxuXHRcdFx0XHRcdGlmICgodmFsdWUubWluIDwgMCAmJiBpdmFsdWUgPCAwKSB8fCAodmFsdWUubWF4ID49IDAgJiYgaXZhbHVlID4gMCkpIHtcblx0XHRcdFx0XHRcdHN0YXJ0ICs9IGl2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRiYXNlID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCk7XG5cdFx0aGVhZCA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnQgKyBsZW5ndGgpO1xuXHRcdHNpemUgPSBoZWFkIC0gYmFzZTtcblxuXHRcdGlmIChtaW5CYXJMZW5ndGggIT09IHVuZGVmaW5lZCAmJiBNYXRoLmFicyhzaXplKSA8IG1pbkJhckxlbmd0aCkge1xuXHRcdFx0c2l6ZSA9IG1pbkJhckxlbmd0aDtcblx0XHRcdGlmIChsZW5ndGggPj0gMCAmJiAhaXNIb3Jpem9udGFsIHx8IGxlbmd0aCA8IDAgJiYgaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdGhlYWQgPSBiYXNlIC0gbWluQmFyTGVuZ3RoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGVhZCA9IGJhc2UgKyBtaW5CYXJMZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRiYXNlOiBiYXNlLFxuXHRcdFx0aGVhZDogaGVhZCxcblx0XHRcdGNlbnRlcjogaGVhZCArIHNpemUgLyAyXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNhbGN1bGF0ZUJhckluZGV4UGl4ZWxzOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgsIGluZGV4LCBydWxlciwgb3B0aW9ucykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuXHRcdFx0PyBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucylcblx0XHRcdDogY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucyk7XG5cblx0XHR2YXIgc3RhY2tJbmRleCA9IG1lLmdldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4LCBtZS5nZXRNZXRhKCkuc3RhY2spO1xuXHRcdHZhciBjZW50ZXIgPSByYW5nZS5zdGFydCArIChyYW5nZS5jaHVuayAqIHN0YWNrSW5kZXgpICsgKHJhbmdlLmNodW5rIC8gMik7XG5cdFx0dmFyIHNpemUgPSBNYXRoLm1pbihcblx0XHRcdHZhbHVlT3JEZWZhdWx0JDMob3B0aW9ucy5tYXhCYXJUaGlja25lc3MsIEluZmluaXR5KSxcblx0XHRcdHJhbmdlLmNodW5rICogcmFuZ2UucmF0aW8pO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGJhc2U6IGNlbnRlciAtIHNpemUgLyAyLFxuXHRcdFx0aGVhZDogY2VudGVyICsgc2l6ZSAvIDIsXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcblx0XHRcdHNpemU6IHNpemVcblx0XHR9O1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIHNjYWxlID0gbWUuX2dldFZhbHVlU2NhbGUoKTtcblx0XHR2YXIgcmVjdHMgPSBtZS5nZXRNZXRhKCkuZGF0YTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgaWxlbiA9IHJlY3RzLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHRoZWxwZXJzJDEuY2FudmFzLmNsaXBBcmVhKGNoYXJ0LmN0eCwgY2hhcnQuY2hhcnRBcmVhKTtcblxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHR2YXIgdmFsID0gc2NhbGUuX3BhcnNlVmFsdWUoZGF0YXNldC5kYXRhW2ldKTtcblx0XHRcdGlmICghaXNOYU4odmFsLm1pbikgJiYgIWlzTmFOKHZhbC5tYXgpKSB7XG5cdFx0XHRcdHJlY3RzW2ldLmRyYXcoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoZWxwZXJzJDEuY2FudmFzLnVuY2xpcEFyZWEoY2hhcnQuY3R4KTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB2YWx1ZXMgPSBoZWxwZXJzJDEuZXh0ZW5kKHt9LCBjb3JlX2RhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucy5hcHBseShtZSwgYXJndW1lbnRzKSk7XG5cdFx0dmFyIGluZGV4T3B0cyA9IG1lLl9nZXRJbmRleFNjYWxlKCkub3B0aW9ucztcblx0XHR2YXIgdmFsdWVPcHRzID0gbWUuX2dldFZhbHVlU2NhbGUoKS5vcHRpb25zO1xuXG5cdFx0dmFsdWVzLmJhclBlcmNlbnRhZ2UgPSB2YWx1ZU9yRGVmYXVsdCQzKGluZGV4T3B0cy5iYXJQZXJjZW50YWdlLCB2YWx1ZXMuYmFyUGVyY2VudGFnZSk7XG5cdFx0dmFsdWVzLmJhclRoaWNrbmVzcyA9IHZhbHVlT3JEZWZhdWx0JDMoaW5kZXhPcHRzLmJhclRoaWNrbmVzcywgdmFsdWVzLmJhclRoaWNrbmVzcyk7XG5cdFx0dmFsdWVzLmNhdGVnb3J5UGVyY2VudGFnZSA9IHZhbHVlT3JEZWZhdWx0JDMoaW5kZXhPcHRzLmNhdGVnb3J5UGVyY2VudGFnZSwgdmFsdWVzLmNhdGVnb3J5UGVyY2VudGFnZSk7XG5cdFx0dmFsdWVzLm1heEJhclRoaWNrbmVzcyA9IHZhbHVlT3JEZWZhdWx0JDMoaW5kZXhPcHRzLm1heEJhclRoaWNrbmVzcywgdmFsdWVzLm1heEJhclRoaWNrbmVzcyk7XG5cdFx0dmFsdWVzLm1pbkJhckxlbmd0aCA9IHZhbHVlT3JEZWZhdWx0JDModmFsdWVPcHRzLm1pbkJhckxlbmd0aCwgdmFsdWVzLm1pbkJhckxlbmd0aCk7XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9XG5cbn0pO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkNCA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcbnZhciByZXNvbHZlJDEgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2J1YmJsZScsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnc2luZ2xlJ1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcicsIC8vIGJ1YmJsZSBzaG91bGQgcHJvYmFibHkgdXNlIGEgbGluZWFyIHNjYWxlIGJ5IGRlZmF1bHRcblx0XHRcdHBvc2l0aW9uOiAnYm90dG9tJyxcblx0XHRcdGlkOiAneC1heGlzLTAnIC8vIG5lZWQgYW4gSUQgc28gZGF0YXNldHMgY2FuIHJlZmVyZW5jZSB0aGUgc2NhbGVcblx0XHR9XSxcblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0cG9zaXRpb246ICdsZWZ0Jyxcblx0XHRcdGlkOiAneS1heGlzLTAnXG5cdFx0fV1cblx0fSxcblxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBUaXRsZSBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIHNjYXR0ZXIgc2luY2Ugd2UgZm9ybWF0IHRoZSBkYXRhIGFzIGEgcG9pbnRcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBkYXRhc2V0TGFiZWwgPSBkYXRhLmRhdGFzZXRzW2l0ZW0uZGF0YXNldEluZGV4XS5sYWJlbCB8fCAnJztcblx0XHRcdFx0dmFyIGRhdGFQb2ludCA9IGRhdGEuZGF0YXNldHNbaXRlbS5kYXRhc2V0SW5kZXhdLmRhdGFbaXRlbS5pbmRleF07XG5cdFx0XHRcdHJldHVybiBkYXRhc2V0TGFiZWwgKyAnOiAoJyArIGl0ZW0ueExhYmVsICsgJywgJyArIGl0ZW0ueUxhYmVsICsgJywgJyArIGRhdGFQb2ludC5yICsgJyknO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBjb250cm9sbGVyX2J1YmJsZSA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUG9pbnQsXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZGF0YUVsZW1lbnRPcHRpb25zOiBbXG5cdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0J2JvcmRlckNvbG9yJyxcblx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0J2hvdmVyQm9yZGVyQ29sb3InLFxuXHRcdCdob3ZlckJvcmRlcldpZHRoJyxcblx0XHQnaG92ZXJSYWRpdXMnLFxuXHRcdCdoaXRSYWRpdXMnLFxuXHRcdCdwb2ludFN0eWxlJyxcblx0XHQncm90YXRpb24nXG5cdF0sXG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGE7XG5cblx0XHQvLyBVcGRhdGUgUG9pbnRzXG5cdFx0aGVscGVycyQxLmVhY2gocG9pbnRzLCBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGluZGV4LCByZXNldCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0dmFyIHhTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcblx0XHR2YXIgeVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMocG9pbnQsIGluZGV4KTtcblx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhW2luZGV4XTtcblx0XHR2YXIgZHNJbmRleCA9IG1lLmluZGV4O1xuXG5cdFx0dmFyIHggPSByZXNldCA/IHhTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IHhTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGEgOiBOYU4sIGluZGV4LCBkc0luZGV4KTtcblx0XHR2YXIgeSA9IHJlc2V0ID8geVNjYWxlLmdldEJhc2VQaXhlbCgpIDogeVNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZGF0YSwgaW5kZXgsIGRzSW5kZXgpO1xuXG5cdFx0cG9pbnQuX3hTY2FsZSA9IHhTY2FsZTtcblx0XHRwb2ludC5feVNjYWxlID0geVNjYWxlO1xuXHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gZHNJbmRleDtcblx0XHRwb2ludC5faW5kZXggPSBpbmRleDtcblx0XHRwb2ludC5fbW9kZWwgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdGhpdFJhZGl1czogb3B0aW9ucy5oaXRSYWRpdXMsXG5cdFx0XHRwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG5cdFx0XHRyb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcblx0XHRcdHJhZGl1czogcmVzZXQgPyAwIDogb3B0aW9ucy5yYWRpdXMsXG5cdFx0XHRza2lwOiBjdXN0b20uc2tpcCB8fCBpc05hTih4KSB8fCBpc05hTih5KSxcblx0XHRcdHg6IHgsXG5cdFx0XHR5OiB5LFxuXHRcdH07XG5cblx0XHRwb2ludC5waXZvdCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBtb2RlbCA9IHBvaW50Ll9tb2RlbDtcblx0XHR2YXIgb3B0aW9ucyA9IHBvaW50Ll9vcHRpb25zO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cblx0XHRwb2ludC4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxuXHRcdFx0cmFkaXVzOiBtb2RlbC5yYWRpdXNcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ0KG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQ0KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdFx0bW9kZWwucmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhvdmVyUmFkaXVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVEYXRhRWxlbWVudE9wdGlvbnM6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgZGF0YSA9IGRhdGFzZXQuZGF0YVtpbmRleF0gfHwge307XG5cdFx0dmFyIHZhbHVlcyA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLl9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0Ly8gSW4gY2FzZSB2YWx1ZXMgd2VyZSBjYWNoZWQgKGFuZCB0aHVzIGZyb3plbiksIHdlIG5lZWQgdG8gY2xvbmUgdGhlIHZhbHVlc1xuXHRcdGlmIChtZS5fY2FjaGVkRGF0YU9wdHMgPT09IHZhbHVlcykge1xuXHRcdFx0dmFsdWVzID0gaGVscGVycyQxLmV4dGVuZCh7fSwgdmFsdWVzKTtcblx0XHR9XG5cblx0XHQvLyBDdXN0b20gcmFkaXVzIHJlc29sdXRpb25cblx0XHR2YWx1ZXMucmFkaXVzID0gcmVzb2x2ZSQxKFtcblx0XHRcdGN1c3RvbS5yYWRpdXMsXG5cdFx0XHRkYXRhLnIsXG5cdFx0XHRtZS5fY29uZmlnLnJhZGl1cyxcblx0XHRcdGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucG9pbnQucmFkaXVzXG5cdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fVxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ1ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG52YXIgUEkkMSA9IE1hdGguUEk7XG52YXIgRE9VQkxFX1BJJDEgPSBQSSQxICogMjtcbnZhciBIQUxGX1BJJDEgPSBQSSQxIC8gMjtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdkb3VnaG51dCcsIHtcblx0YW5pbWF0aW9uOiB7XG5cdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIERvdWdobnV0XG5cdFx0YW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcblx0XHQvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHNjYWxpbmcgdGhlIERvdWdobnV0IGZyb20gdGhlIGNlbnRyZVxuXHRcdGFuaW1hdGVTY2FsZTogZmFsc2Vcblx0fSxcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnc2luZ2xlJ1xuXHR9LFxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG5cdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGxhYmVscyA9IGRhdGEubGFiZWxzO1xuXHRcdHZhciBpLCBpbGVuLCBsaXN0SXRlbSwgbGlzdEl0ZW1TcGFuO1xuXG5cdFx0bGlzdC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2hhcnQuaWQgKyAnLWxlZ2VuZCcpO1xuXHRcdGlmIChkYXRhc2V0cy5sZW5ndGgpIHtcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0c1swXS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRsaXN0SXRlbSA9IGxpc3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKSk7XG5cdFx0XHRcdGxpc3RJdGVtU3BhbiA9IGxpc3RJdGVtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSk7XG5cdFx0XHRcdGxpc3RJdGVtU3Bhbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0c1swXS5iYWNrZ3JvdW5kQ29sb3JbaV07XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0pIHtcblx0XHRcdFx0XHRsaXN0SXRlbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsYWJlbHNbaV0pKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBsaXN0Lm91dGVySFRNTDtcblx0fSxcblx0bGVnZW5kOiB7XG5cdFx0bGFiZWxzOiB7XG5cdFx0XHRnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdFx0XHRpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEubGFiZWxzLm1hcChmdW5jdGlvbihsYWJlbCwgaSkge1xuXHRcdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcblx0XHRcdFx0XHRcdHZhciBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0dGV4dDogbGFiZWwsXG5cdFx0XHRcdFx0XHRcdGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG5cdFx0XHRcdFx0XHRcdGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdFx0XHRcdGhpZGRlbjogaXNOYU4oZGF0YS5kYXRhc2V0c1swXS5kYXRhW2ldKSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuLFxuXG5cdFx0XHRcdFx0XHRcdC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuXHRcdFx0XHRcdFx0XHRpbmRleDogaVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uQ2xpY2s6IGZ1bmN0aW9uKGUsIGxlZ2VuZEl0ZW0pIHtcblx0XHRcdHZhciBpbmRleCA9IGxlZ2VuZEl0ZW0uaW5kZXg7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXHRcdFx0dmFyIGksIGlsZW4sIG1ldGE7XG5cblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0Ly8gdG9nZ2xlIHZpc2liaWxpdHkgb2YgaW5kZXggaWYgZXhpc3RzXG5cdFx0XHRcdGlmIChtZXRhLmRhdGFbaW5kZXhdKSB7XG5cdFx0XHRcdFx0bWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gPSAhbWV0YS5kYXRhW2luZGV4XS5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y2hhcnQudXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaGFydCB0aGF0IHdlIGN1dCBvdXQgb2YgdGhlIG1pZGRsZS5cblx0Y3V0b3V0UGVyY2VudGFnZTogNTAsXG5cblx0Ly8gVGhlIHJvdGF0aW9uIG9mIHRoZSBjaGFydCwgd2hlcmUgdGhlIGZpcnN0IGRhdGEgYXJjIGJlZ2lucy5cblx0cm90YXRpb246IC1IQUxGX1BJJDEsXG5cblx0Ly8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuXHRjaXJjdW1mZXJlbmNlOiBET1VCTEVfUEkkMSxcblxuXHQvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcblx0dG9vbHRpcHM6IHtcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgZGF0YUxhYmVsID0gZGF0YS5sYWJlbHNbdG9vbHRpcEl0ZW0uaW5kZXhdO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSAnOiAnICsgZGF0YS5kYXRhc2V0c1t0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXhdLmRhdGFbdG9vbHRpcEl0ZW0uaW5kZXhdO1xuXG5cdFx0XHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheShkYXRhTGFiZWwpKSB7XG5cdFx0XHRcdFx0Ly8gc2hvdyB2YWx1ZSBvbiBmaXJzdCBsaW5lIG9mIG11bHRpbGluZSBsYWJlbFxuXHRcdFx0XHRcdC8vIG5lZWQgdG8gY2xvbmUgYmVjYXVzZSB3ZSBhcmUgY2hhbmdpbmcgdGhlIHZhbHVlXG5cdFx0XHRcdFx0ZGF0YUxhYmVsID0gZGF0YUxhYmVsLnNsaWNlKCk7XG5cdFx0XHRcdFx0ZGF0YUxhYmVsWzBdICs9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFMYWJlbCArPSB2YWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBkYXRhTGFiZWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIGNvbnRyb2xsZXJfZG91Z2hudXQgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5BcmMsXG5cblx0bGlua1NjYWxlczogaGVscGVycyQxLm5vb3AsXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZGF0YUVsZW1lbnRPcHRpb25zOiBbXG5cdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0J2JvcmRlckNvbG9yJyxcblx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdCdib3JkZXJBbGlnbicsXG5cdFx0J2hvdmVyQmFja2dyb3VuZENvbG9yJyxcblx0XHQnaG92ZXJCb3JkZXJDb2xvcicsXG5cdFx0J2hvdmVyQm9yZGVyV2lkdGgnLFxuXHRdLFxuXG5cdC8vIEdldCBpbmRleCBvZiB0aGUgZGF0YXNldCBpbiByZWxhdGlvbiB0byB0aGUgdmlzaWJsZSBkYXRhc2V0cy4gVGhpcyBhbGxvd3MgZGV0ZXJtaW5pbmcgdGhlIGlubmVyIGFuZCBvdXRlciByYWRpdXMgY29ycmVjdGx5XG5cdGdldFJpbmdJbmRleDogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIHJpbmdJbmRleCA9IDA7XG5cblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFzZXRJbmRleDsgKytqKSB7XG5cdFx0XHRpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGopKSB7XG5cdFx0XHRcdCsrcmluZ0luZGV4O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByaW5nSW5kZXg7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIHJhdGlvWCA9IDE7XG5cdFx0dmFyIHJhdGlvWSA9IDE7XG5cdFx0dmFyIG9mZnNldFggPSAwO1xuXHRcdHZhciBvZmZzZXRZID0gMDtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgYXJjcyA9IG1ldGEuZGF0YTtcblx0XHR2YXIgY3V0b3V0ID0gb3B0cy5jdXRvdXRQZXJjZW50YWdlIC8gMTAwIHx8IDA7XG5cdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSBvcHRzLmNpcmN1bWZlcmVuY2U7XG5cdFx0dmFyIGNoYXJ0V2VpZ2h0ID0gbWUuX2dldFJpbmdXZWlnaHQobWUuaW5kZXgpO1xuXHRcdHZhciBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBpLCBpbGVuO1xuXG5cdFx0Ly8gSWYgdGhlIGNoYXJ0J3MgY2lyY3VtZmVyZW5jZSBpc24ndCBhIGZ1bGwgY2lyY2xlLCBjYWxjdWxhdGUgc2l6ZSBhcyBhIHJhdGlvIG9mIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGFyY1xuXHRcdGlmIChjaXJjdW1mZXJlbmNlIDwgRE9VQkxFX1BJJDEpIHtcblx0XHRcdHZhciBzdGFydEFuZ2xlID0gb3B0cy5yb3RhdGlvbiAlIERPVUJMRV9QSSQxO1xuXHRcdFx0c3RhcnRBbmdsZSArPSBzdGFydEFuZ2xlID49IFBJJDEgPyAtRE9VQkxFX1BJJDEgOiBzdGFydEFuZ2xlIDwgLVBJJDEgPyBET1VCTEVfUEkkMSA6IDA7XG5cdFx0XHR2YXIgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZTtcblx0XHRcdHZhciBzdGFydFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcblx0XHRcdHZhciBzdGFydFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcblx0XHRcdHZhciBlbmRYID0gTWF0aC5jb3MoZW5kQW5nbGUpO1xuXHRcdFx0dmFyIGVuZFkgPSBNYXRoLnNpbihlbmRBbmdsZSk7XG5cdFx0XHR2YXIgY29udGFpbnMwID0gKHN0YXJ0QW5nbGUgPD0gMCAmJiBlbmRBbmdsZSA+PSAwKSB8fCBlbmRBbmdsZSA+PSBET1VCTEVfUEkkMTtcblx0XHRcdHZhciBjb250YWluczkwID0gKHN0YXJ0QW5nbGUgPD0gSEFMRl9QSSQxICYmIGVuZEFuZ2xlID49IEhBTEZfUEkkMSkgfHwgZW5kQW5nbGUgPj0gRE9VQkxFX1BJJDEgKyBIQUxGX1BJJDE7XG5cdFx0XHR2YXIgY29udGFpbnMxODAgPSBzdGFydEFuZ2xlID09PSAtUEkkMSB8fCBlbmRBbmdsZSA+PSBQSSQxO1xuXHRcdFx0dmFyIGNvbnRhaW5zMjcwID0gKHN0YXJ0QW5nbGUgPD0gLUhBTEZfUEkkMSAmJiBlbmRBbmdsZSA+PSAtSEFMRl9QSSQxKSB8fCBlbmRBbmdsZSA+PSBQSSQxICsgSEFMRl9QSSQxO1xuXHRcdFx0dmFyIG1pblggPSBjb250YWluczE4MCA/IC0xIDogTWF0aC5taW4oc3RhcnRYLCBzdGFydFggKiBjdXRvdXQsIGVuZFgsIGVuZFggKiBjdXRvdXQpO1xuXHRcdFx0dmFyIG1pblkgPSBjb250YWluczI3MCA/IC0xIDogTWF0aC5taW4oc3RhcnRZLCBzdGFydFkgKiBjdXRvdXQsIGVuZFksIGVuZFkgKiBjdXRvdXQpO1xuXHRcdFx0dmFyIG1heFggPSBjb250YWluczAgPyAxIDogTWF0aC5tYXgoc3RhcnRYLCBzdGFydFggKiBjdXRvdXQsIGVuZFgsIGVuZFggKiBjdXRvdXQpO1xuXHRcdFx0dmFyIG1heFkgPSBjb250YWluczkwID8gMSA6IE1hdGgubWF4KHN0YXJ0WSwgc3RhcnRZICogY3V0b3V0LCBlbmRZLCBlbmRZICogY3V0b3V0KTtcblx0XHRcdHJhdGlvWCA9IChtYXhYIC0gbWluWCkgLyAyO1xuXHRcdFx0cmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XG5cdFx0XHRvZmZzZXRYID0gLShtYXhYICsgbWluWCkgLyAyO1xuXHRcdFx0b2Zmc2V0WSA9IC0obWF4WSArIG1pblkpIC8gMjtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGFyY3NbaV0uX29wdGlvbnMgPSBtZS5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhhcmNzW2ldLCBpKTtcblx0XHR9XG5cblx0XHRjaGFydC5ib3JkZXJXaWR0aCA9IG1lLmdldE1heEJvcmRlcldpZHRoKCk7XG5cdFx0bWF4V2lkdGggPSAoY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQgLSBjaGFydC5ib3JkZXJXaWR0aCkgLyByYXRpb1g7XG5cdFx0bWF4SGVpZ2h0ID0gKGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wIC0gY2hhcnQuYm9yZGVyV2lkdGgpIC8gcmF0aW9ZO1xuXHRcdGNoYXJ0Lm91dGVyUmFkaXVzID0gTWF0aC5tYXgoTWF0aC5taW4obWF4V2lkdGgsIG1heEhlaWdodCkgLyAyLCAwKTtcblx0XHRjaGFydC5pbm5lclJhZGl1cyA9IE1hdGgubWF4KGNoYXJ0Lm91dGVyUmFkaXVzICogY3V0b3V0LCAwKTtcblx0XHRjaGFydC5yYWRpdXNMZW5ndGggPSAoY2hhcnQub3V0ZXJSYWRpdXMgLSBjaGFydC5pbm5lclJhZGl1cykgLyAobWUuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKSB8fCAxKTtcblx0XHRjaGFydC5vZmZzZXRYID0gb2Zmc2V0WCAqIGNoYXJ0Lm91dGVyUmFkaXVzO1xuXHRcdGNoYXJ0Lm9mZnNldFkgPSBvZmZzZXRZICogY2hhcnQub3V0ZXJSYWRpdXM7XG5cblx0XHRtZXRhLnRvdGFsID0gbWUuY2FsY3VsYXRlVG90YWwoKTtcblxuXHRcdG1lLm91dGVyUmFkaXVzID0gY2hhcnQub3V0ZXJSYWRpdXMgLSBjaGFydC5yYWRpdXNMZW5ndGggKiBtZS5fZ2V0UmluZ1dlaWdodE9mZnNldChtZS5pbmRleCk7XG5cdFx0bWUuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChtZS5vdXRlclJhZGl1cyAtIGNoYXJ0LnJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWUudXBkYXRlRWxlbWVudChhcmNzW2ldLCBpLCByZXNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGFyYywgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHR2YXIgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuXHRcdHZhciBjZW50ZXJYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG5cdFx0dmFyIGNlbnRlclkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcblx0XHR2YXIgc3RhcnRBbmdsZSA9IG9wdHMucm90YXRpb247IC8vIG5vbiByZXNldCBjYXNlIGhhbmRsZWQgbGF0ZXJcblx0XHR2YXIgZW5kQW5nbGUgPSBvcHRzLnJvdGF0aW9uOyAvLyBub24gcmVzZXQgY2FzZSBoYW5kbGVkIGxhdGVyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUgPyAwIDogYXJjLmhpZGRlbiA/IDAgOiBtZS5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKGRhdGFzZXQuZGF0YVtpbmRleF0pICogKG9wdHMuY2lyY3VtZmVyZW5jZSAvIERPVUJMRV9QSSQxKTtcblx0XHR2YXIgaW5uZXJSYWRpdXMgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSA/IDAgOiBtZS5pbm5lclJhZGl1cztcblx0XHR2YXIgb3V0ZXJSYWRpdXMgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSA/IDAgOiBtZS5vdXRlclJhZGl1cztcblx0XHR2YXIgb3B0aW9ucyA9IGFyYy5fb3B0aW9ucyB8fCB7fTtcblxuXHRcdGhlbHBlcnMkMS5leHRlbmQoYXJjLCB7XG5cdFx0XHQvLyBVdGlsaXR5XG5cdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleCxcblx0XHRcdF9pbmRleDogaW5kZXgsXG5cblx0XHRcdC8vIERlc2lyZWQgdmlldyBwcm9wZXJ0aWVzXG5cdFx0XHRfbW9kZWw6IHtcblx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0XHRib3JkZXJBbGlnbjogb3B0aW9ucy5ib3JkZXJBbGlnbixcblx0XHRcdFx0eDogY2VudGVyWCArIGNoYXJ0Lm9mZnNldFgsXG5cdFx0XHRcdHk6IGNlbnRlclkgKyBjaGFydC5vZmZzZXRZLFxuXHRcdFx0XHRzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuXHRcdFx0XHRlbmRBbmdsZTogZW5kQW5nbGUsXG5cdFx0XHRcdGNpcmN1bWZlcmVuY2U6IGNpcmN1bWZlcmVuY2UsXG5cdFx0XHRcdG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcblx0XHRcdFx0aW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuXHRcdFx0XHRsYWJlbDogaGVscGVycyQxLnZhbHVlQXRJbmRleE9yRGVmYXVsdChkYXRhc2V0LmxhYmVsLCBpbmRleCwgY2hhcnQuZGF0YS5sYWJlbHNbaW5kZXhdKVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dmFyIG1vZGVsID0gYXJjLl9tb2RlbDtcblxuXHRcdC8vIFNldCBjb3JyZWN0IGFuZ2xlcyBpZiBub3QgcmVzZXR0aW5nXG5cdFx0aWYgKCFyZXNldCB8fCAhYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XG5cdFx0XHRpZiAoaW5kZXggPT09IDApIHtcblx0XHRcdFx0bW9kZWwuc3RhcnRBbmdsZSA9IG9wdHMucm90YXRpb247XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtb2RlbC5zdGFydEFuZ2xlID0gbWUuZ2V0TWV0YSgpLmRhdGFbaW5kZXggLSAxXS5fbW9kZWwuZW5kQW5nbGU7XG5cdFx0XHR9XG5cblx0XHRcdG1vZGVsLmVuZEFuZ2xlID0gbW9kZWwuc3RhcnRBbmdsZSArIG1vZGVsLmNpcmN1bWZlcmVuY2U7XG5cdFx0fVxuXG5cdFx0YXJjLnBpdm90KCk7XG5cdH0sXG5cblx0Y2FsY3VsYXRlVG90YWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcblx0XHR2YXIgdG90YWwgPSAwO1xuXHRcdHZhciB2YWx1ZTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKG1ldGEuZGF0YSwgZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHRcdHZhbHVlID0gZGF0YXNldC5kYXRhW2luZGV4XTtcblx0XHRcdGlmICghaXNOYU4odmFsdWUpICYmICFlbGVtZW50LmhpZGRlbikge1xuXHRcdFx0XHR0b3RhbCArPSBNYXRoLmFicyh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKiBpZiAodG90YWwgPT09IDApIHtcblx0XHRcdHRvdGFsID0gTmFOO1xuXHRcdH0qL1xuXG5cdFx0cmV0dXJuIHRvdGFsO1xuXHR9LFxuXG5cdGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIHRvdGFsID0gdGhpcy5nZXRNZXRhKCkudG90YWw7XG5cdFx0aWYgKHRvdGFsID4gMCAmJiAhaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gRE9VQkxFX1BJJDEgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBnZXRzIHRoZSBtYXggYm9yZGVyIG9yIGhvdmVyIHdpZHRoIHRvIHByb3Blcmx5IHNjYWxlIHBpZSBjaGFydHNcblx0Z2V0TWF4Qm9yZGVyV2lkdGg6IGZ1bmN0aW9uKGFyY3MpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtYXggPSAwO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBpLCBpbGVuLCBtZXRhLCBhcmMsIGNvbnRyb2xsZXIsIG9wdGlvbnMsIGJvcmRlcldpZHRoLCBob3ZlcldpZHRoO1xuXG5cdFx0aWYgKCFhcmNzKSB7XG5cdFx0XHQvLyBGaW5kIHRoZSBvdXRtb3N0IHZpc2libGUgZGF0YXNldFxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRcdGFyY3MgPSBtZXRhLmRhdGE7XG5cdFx0XHRcdFx0aWYgKGkgIT09IG1lLmluZGV4KSB7XG5cdFx0XHRcdFx0XHRjb250cm9sbGVyID0gbWV0YS5jb250cm9sbGVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghYXJjcykge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRhcmMgPSBhcmNzW2ldO1xuXHRcdFx0aWYgKGNvbnRyb2xsZXIpIHtcblx0XHRcdFx0Y29udHJvbGxlci5fY29uZmlndXJlKCk7XG5cdFx0XHRcdG9wdGlvbnMgPSBjb250cm9sbGVyLl9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGFyYywgaSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb25zID0gYXJjLl9vcHRpb25zO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9wdGlvbnMuYm9yZGVyQWxpZ24gIT09ICdpbm5lcicpIHtcblx0XHRcdFx0Ym9yZGVyV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuXHRcdFx0XHRob3ZlcldpZHRoID0gb3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoO1xuXG5cdFx0XHRcdG1heCA9IGJvcmRlcldpZHRoID4gbWF4ID8gYm9yZGVyV2lkdGggOiBtYXg7XG5cdFx0XHRcdG1heCA9IGhvdmVyV2lkdGggPiBtYXggPyBob3ZlcldpZHRoIDogbWF4O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWF4O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihhcmMpIHtcblx0XHR2YXIgbW9kZWwgPSBhcmMuX21vZGVsO1xuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cblx0XHRhcmMuJHByZXZpb3VzU3R5bGUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ1KG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQ1KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCByYWRpdXMgbGVuZ3RoIG9mZnNldCBvZiB0aGUgZGF0YXNldCBpbiByZWxhdGlvbiB0byB0aGUgdmlzaWJsZSBkYXRhc2V0cyB3ZWlnaHRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRSaW5nV2VpZ2h0T2Zmc2V0OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgcmluZ1dlaWdodE9mZnNldCA9IDA7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG5cdFx0XHRpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRSaW5nV2VpZ2h0OiBmdW5jdGlvbihkYXRhU2V0SW5kZXgpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgodmFsdWVPckRlZmF1bHQkNSh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YVNldEluZGV4XS53ZWlnaHQsIDEpLCAwKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc3VtIG9mIGFsbCB2aXNpYmlsZSBkYXRhIHNldCB3ZWlnaHRzLiAgVGhpcyB2YWx1ZSBjYW4gYmUgMC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnaG9yaXpvbnRhbEJhcicsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnaW5kZXgnLFxuXHRcdGF4aXM6ICd5J1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRwb3NpdGlvbjogJ2JvdHRvbSdcblx0XHR9XSxcblxuXHRcdHlBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2NhdGVnb3J5Jyxcblx0XHRcdHBvc2l0aW9uOiAnbGVmdCcsXG5cdFx0XHRvZmZzZXQ6IHRydWUsXG5cdFx0XHRncmlkTGluZXM6IHtcblx0XHRcdFx0b2Zmc2V0R3JpZExpbmVzOiB0cnVlXG5cdFx0XHR9XG5cdFx0fV1cblx0fSxcblxuXHRlbGVtZW50czoge1xuXHRcdHJlY3RhbmdsZToge1xuXHRcdFx0Ym9yZGVyU2tpcHBlZDogJ2xlZnQnXG5cdFx0fVxuXHR9LFxuXG5cdHRvb2x0aXBzOiB7XG5cdFx0bW9kZTogJ2luZGV4Jyxcblx0XHRheGlzOiAneSdcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRkYXRhc2V0czoge1xuXHRcdGhvcml6b250YWxCYXI6IHtcblx0XHRcdGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuXHRcdFx0YmFyUGVyY2VudGFnZTogMC45XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIGNvbnRyb2xsZXJfaG9yaXpvbnRhbEJhciA9IGNvbnRyb2xsZXJfYmFyLmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnhBeGlzSUQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0SW5kZXhTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueUF4aXNJRDtcblx0fVxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ2ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHJlc29sdmUkMiA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG52YXIgaXNQb2ludEluQXJlYSA9IGhlbHBlcnMkMS5jYW52YXMuX2lzUG9pbnRJbkFyZWE7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnbGluZScsIHtcblx0c2hvd0xpbmVzOiB0cnVlLFxuXHRzcGFuR2FwczogZmFsc2UsXG5cblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnbGFiZWwnXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxuXHRcdFx0aWQ6ICd4LWF4aXMtMCdcblx0XHR9XSxcblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0aWQ6ICd5LWF4aXMtMCdcblx0XHR9XVxuXHR9XG59KTtcblxuZnVuY3Rpb24gc2NhbGVDbGlwKHNjYWxlLCBoYWxmQm9yZGVyV2lkdGgpIHtcblx0dmFyIHRpY2tPcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucy50aWNrcyB8fCB7fTtcblx0dmFyIHJldmVyc2UgPSB0aWNrT3B0cy5yZXZlcnNlO1xuXHR2YXIgbWluID0gdGlja09wdHMubWluID09PSB1bmRlZmluZWQgPyBoYWxmQm9yZGVyV2lkdGggOiAwO1xuXHR2YXIgbWF4ID0gdGlja09wdHMubWF4ID09PSB1bmRlZmluZWQgPyBoYWxmQm9yZGVyV2lkdGggOiAwO1xuXHRyZXR1cm4ge1xuXHRcdHN0YXJ0OiByZXZlcnNlID8gbWF4IDogbWluLFxuXHRcdGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxuXHR9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q2xpcCh4U2NhbGUsIHlTY2FsZSwgYm9yZGVyV2lkdGgpIHtcblx0dmFyIGhhbGZCb3JkZXJXaWR0aCA9IGJvcmRlcldpZHRoIC8gMjtcblx0dmFyIHggPSBzY2FsZUNsaXAoeFNjYWxlLCBoYWxmQm9yZGVyV2lkdGgpO1xuXHR2YXIgeSA9IHNjYWxlQ2xpcCh5U2NhbGUsIGhhbGZCb3JkZXJXaWR0aCk7XG5cblx0cmV0dXJuIHtcblx0XHR0b3A6IHkuZW5kLFxuXHRcdHJpZ2h0OiB4LmVuZCxcblx0XHRib3R0b206IHkuc3RhcnQsXG5cdFx0bGVmdDogeC5zdGFydFxuXHR9O1xufVxuXG5mdW5jdGlvbiB0b0NsaXAodmFsdWUpIHtcblx0dmFyIHQsIHIsIGIsIGw7XG5cblx0aWYgKGhlbHBlcnMkMS5pc09iamVjdCh2YWx1ZSkpIHtcblx0XHR0ID0gdmFsdWUudG9wO1xuXHRcdHIgPSB2YWx1ZS5yaWdodDtcblx0XHRiID0gdmFsdWUuYm90dG9tO1xuXHRcdGwgPSB2YWx1ZS5sZWZ0O1xuXHR9IGVsc2Uge1xuXHRcdHQgPSByID0gYiA9IGwgPSB2YWx1ZTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0dG9wOiB0LFxuXHRcdHJpZ2h0OiByLFxuXHRcdGJvdHRvbTogYixcblx0XHRsZWZ0OiBsXG5cdH07XG59XG5cblxudmFyIGNvbnRyb2xsZXJfbGluZSA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRkYXRhc2V0RWxlbWVudFR5cGU6IGVsZW1lbnRzLkxpbmUsXG5cblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5Qb2ludCxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9kYXRhc2V0RWxlbWVudE9wdGlvbnM6IFtcblx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHQnYm9yZGVyQ2FwU3R5bGUnLFxuXHRcdCdib3JkZXJDb2xvcicsXG5cdFx0J2JvcmRlckRhc2gnLFxuXHRcdCdib3JkZXJEYXNoT2Zmc2V0Jyxcblx0XHQnYm9yZGVySm9pblN0eWxlJyxcblx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdCdjdWJpY0ludGVycG9sYXRpb25Nb2RlJyxcblx0XHQnZmlsbCdcblx0XSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9kYXRhRWxlbWVudE9wdGlvbnM6IHtcblx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEJhY2tncm91bmRDb2xvcicsXG5cdFx0Ym9yZGVyQ29sb3I6ICdwb2ludEJvcmRlckNvbG9yJyxcblx0XHRib3JkZXJXaWR0aDogJ3BvaW50Qm9yZGVyV2lkdGgnLFxuXHRcdGhpdFJhZGl1czogJ3BvaW50SGl0UmFkaXVzJyxcblx0XHRob3ZlckJhY2tncm91bmRDb2xvcjogJ3BvaW50SG92ZXJCYWNrZ3JvdW5kQ29sb3InLFxuXHRcdGhvdmVyQm9yZGVyQ29sb3I6ICdwb2ludEhvdmVyQm9yZGVyQ29sb3InLFxuXHRcdGhvdmVyQm9yZGVyV2lkdGg6ICdwb2ludEhvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdGhvdmVyUmFkaXVzOiAncG9pbnRIb3ZlclJhZGl1cycsXG5cdFx0cG9pbnRTdHlsZTogJ3BvaW50U3R5bGUnLFxuXHRcdHJhZGl1czogJ3BvaW50UmFkaXVzJyxcblx0XHRyb3RhdGlvbjogJ3BvaW50Um90YXRpb24nXG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLmNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIGNvbmZpZyA9IG1lLl9jb25maWc7XG5cdFx0dmFyIHNob3dMaW5lID0gbWUuX3Nob3dMaW5lID0gdmFsdWVPckRlZmF1bHQkNihjb25maWcuc2hvd0xpbmUsIG9wdGlvbnMuc2hvd0xpbmVzKTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdG1lLl94U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueEF4aXNJRCk7XG5cdFx0bWUuX3lTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblxuXHRcdC8vIFVwZGF0ZSBMaW5lXG5cdFx0aWYgKHNob3dMaW5lKSB7XG5cdFx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXG5cdFx0XHRpZiAoY29uZmlnLnRlbnNpb24gIT09IHVuZGVmaW5lZCAmJiBjb25maWcubGluZVRlbnNpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25maWcubGluZVRlbnNpb24gPSBjb25maWcudGVuc2lvbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0bGluZS5fc2NhbGUgPSBtZS5feVNjYWxlO1xuXHRcdFx0bGluZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0XHQvLyBEYXRhXG5cdFx0XHRsaW5lLl9jaGlsZHJlbiA9IHBvaW50cztcblx0XHRcdC8vIE1vZGVsXG5cdFx0XHRsaW5lLl9tb2RlbCA9IG1lLl9yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKGxpbmUpO1xuXG5cdFx0XHRsaW5lLnBpdm90KCk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50c1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblxuXHRcdGlmIChzaG93TGluZSAmJiBsaW5lLl9tb2RlbC50ZW5zaW9uICE9PSAwKSB7XG5cdFx0XHRtZS51cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKCk7XG5cdFx0fVxuXG5cdFx0Ly8gTm93IHBpdm90IHRoZSBwb2ludCBmb3IgYW5pbWF0aW9uXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHBvaW50c1tpXS5waXZvdCgpO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihwb2ludCwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBkYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHR2YXIgdmFsdWUgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuXHRcdHZhciB4U2NhbGUgPSBtZS5feFNjYWxlO1xuXHRcdHZhciB5U2NhbGUgPSBtZS5feVNjYWxlO1xuXHRcdHZhciBsaW5lTW9kZWwgPSBtZXRhLmRhdGFzZXQuX21vZGVsO1xuXHRcdHZhciB4LCB5O1xuXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhwb2ludCwgaW5kZXgpO1xuXG5cdFx0eCA9IHhTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB2YWx1ZSA6IE5hTiwgaW5kZXgsIGRhdGFzZXRJbmRleCk7XG5cdFx0eSA9IHJlc2V0ID8geVNjYWxlLmdldEJhc2VQaXhlbCgpIDogbWUuY2FsY3VsYXRlUG9pbnRZKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KTtcblxuXHRcdC8vIFV0aWxpdHlcblx0XHRwb2ludC5feFNjYWxlID0geFNjYWxlO1xuXHRcdHBvaW50Ll95U2NhbGUgPSB5U2NhbGU7XG5cdFx0cG9pbnQuX29wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHBvaW50Ll9kYXRhc2V0SW5kZXggPSBkYXRhc2V0SW5kZXg7XG5cdFx0cG9pbnQuX2luZGV4ID0gaW5kZXg7XG5cblx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xuXHRcdHBvaW50Ll9tb2RlbCA9IHtcblx0XHRcdHg6IHgsXG5cdFx0XHR5OiB5LFxuXHRcdFx0c2tpcDogY3VzdG9tLnNraXAgfHwgaXNOYU4oeCkgfHwgaXNOYU4oeSksXG5cdFx0XHQvLyBBcHBlYXJhbmNlXG5cdFx0XHRyYWRpdXM6IG9wdGlvbnMucmFkaXVzLFxuXHRcdFx0cG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxuXHRcdFx0cm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdHRlbnNpb246IHZhbHVlT3JEZWZhdWx0JDYoY3VzdG9tLnRlbnNpb24sIGxpbmVNb2RlbCA/IGxpbmVNb2RlbC50ZW5zaW9uIDogMCksXG5cdFx0XHRzdGVwcGVkTGluZTogbGluZU1vZGVsID8gbGluZU1vZGVsLnN0ZXBwZWRMaW5lIDogZmFsc2UsXG5cdFx0XHQvLyBUb29sdGlwXG5cdFx0XHRoaXRSYWRpdXM6IG9wdGlvbnMuaGl0UmFkaXVzXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY29uZmlnID0gbWUuX2NvbmZpZztcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5jaGFydC5vcHRpb25zO1xuXHRcdHZhciBsaW5lT3B0aW9ucyA9IG9wdGlvbnMuZWxlbWVudHMubGluZTtcblx0XHR2YXIgdmFsdWVzID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuX3Jlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cblx0XHQvLyBUaGUgZGVmYXVsdCBiZWhhdmlvciBvZiBsaW5lcyBpcyB0byBicmVhayBhdCBudWxsIHZhbHVlcywgYWNjb3JkaW5nXG5cdFx0Ly8gdG8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI0MzUjaXNzdWVjb21tZW50LTIxNjcxODE1OFxuXHRcdC8vIFRoaXMgb3B0aW9uIGdpdmVzIGxpbmVzIHRoZSBhYmlsaXR5IHRvIHNwYW4gZ2Fwc1xuXHRcdHZhbHVlcy5zcGFuR2FwcyA9IHZhbHVlT3JEZWZhdWx0JDYoY29uZmlnLnNwYW5HYXBzLCBvcHRpb25zLnNwYW5HYXBzKTtcblx0XHR2YWx1ZXMudGVuc2lvbiA9IHZhbHVlT3JEZWZhdWx0JDYoY29uZmlnLmxpbmVUZW5zaW9uLCBsaW5lT3B0aW9ucy50ZW5zaW9uKTtcblx0XHR2YWx1ZXMuc3RlcHBlZExpbmUgPSByZXNvbHZlJDIoW2N1c3RvbS5zdGVwcGVkTGluZSwgY29uZmlnLnN0ZXBwZWRMaW5lLCBsaW5lT3B0aW9ucy5zdGVwcGVkXSk7XG5cdFx0dmFsdWVzLmNsaXAgPSB0b0NsaXAodmFsdWVPckRlZmF1bHQkNihjb25maWcuY2xpcCwgZGVmYXVsdENsaXAobWUuX3hTY2FsZSwgbWUuX3lTY2FsZSwgdmFsdWVzLmJvcmRlcldpZHRoKSkpO1xuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHRjYWxjdWxhdGVQb2ludFk6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgeVNjYWxlID0gbWUuX3lTY2FsZTtcblx0XHR2YXIgc3VtUG9zID0gMDtcblx0XHR2YXIgc3VtTmVnID0gMDtcblx0XHR2YXIgaSwgZHMsIGRzTWV0YSwgc3RhY2tlZFJpZ2h0VmFsdWUsIHJpZ2h0VmFsdWUsIG1ldGFzZXRzLCBpbGVuO1xuXG5cdFx0aWYgKHlTY2FsZS5vcHRpb25zLnN0YWNrZWQpIHtcblx0XHRcdHJpZ2h0VmFsdWUgPSAreVNjYWxlLmdldFJpZ2h0VmFsdWUodmFsdWUpO1xuXHRcdFx0bWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuXHRcdFx0aWxlbiA9IG1ldGFzZXRzLmxlbmd0aDtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRkc01ldGEgPSBtZXRhc2V0c1tpXTtcblx0XHRcdFx0aWYgKGRzTWV0YS5pbmRleCA9PT0gZGF0YXNldEluZGV4KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkcyA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbZHNNZXRhLmluZGV4XTtcblx0XHRcdFx0aWYgKGRzTWV0YS50eXBlID09PSAnbGluZScgJiYgZHNNZXRhLnlBeGlzSUQgPT09IHlTY2FsZS5pZCkge1xuXHRcdFx0XHRcdHN0YWNrZWRSaWdodFZhbHVlID0gK3lTY2FsZS5nZXRSaWdodFZhbHVlKGRzLmRhdGFbaW5kZXhdKTtcblx0XHRcdFx0XHRpZiAoc3RhY2tlZFJpZ2h0VmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRzdW1OZWcgKz0gc3RhY2tlZFJpZ2h0VmFsdWUgfHwgMDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3VtUG9zICs9IHN0YWNrZWRSaWdodFZhbHVlIHx8IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyaWdodFZhbHVlIDwgMCkge1xuXHRcdFx0XHRyZXR1cm4geVNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3VtTmVnICsgcmlnaHRWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geVNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3VtUG9zICsgcmlnaHRWYWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG5cdH0sXG5cblx0dXBkYXRlQmV6aWVyQ29udHJvbFBvaW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgbGluZU1vZGVsID0gbWV0YS5kYXRhc2V0Ll9tb2RlbDtcblx0XHR2YXIgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBpLCBpbGVuLCBtb2RlbCwgY29udHJvbFBvaW50cztcblxuXHRcdC8vIE9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgYXJlIGRyYXduIGluIGNhc2UgdGhlIHNwYW5HYXBzIG9wdGlvbiBpcyB1c2VkXG5cdFx0aWYgKGxpbmVNb2RlbC5zcGFuR2Fwcykge1xuXHRcdFx0cG9pbnRzID0gcG9pbnRzLmZpbHRlcihmdW5jdGlvbihwdCkge1xuXHRcdFx0XHRyZXR1cm4gIXB0Ll9tb2RlbC5za2lwO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2FwQ29udHJvbFBvaW50KHB0LCBtaW4sIG1heCkge1xuXHRcdFx0cmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xuXHRcdH1cblxuXHRcdGlmIChsaW5lTW9kZWwuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuXHRcdFx0aGVscGVycyQxLnNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bW9kZWwgPSBwb2ludHNbaV0uX21vZGVsO1xuXHRcdFx0XHRjb250cm9sUG9pbnRzID0gaGVscGVycyQxLnNwbGluZUN1cnZlKFxuXHRcdFx0XHRcdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpKS5fbW9kZWwsXG5cdFx0XHRcdFx0bW9kZWwsXG5cdFx0XHRcdFx0aGVscGVycyQxLm5leHRJdGVtKHBvaW50cywgaSkuX21vZGVsLFxuXHRcdFx0XHRcdGxpbmVNb2RlbC50ZW5zaW9uXG5cdFx0XHRcdCk7XG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY29udHJvbFBvaW50cy5wcmV2aW91cy55O1xuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IGNvbnRyb2xQb2ludHMubmV4dC54O1xuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IGNvbnRyb2xQb2ludHMubmV4dC55O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjaGFydC5vcHRpb25zLmVsZW1lbnRzLmxpbmUuY2FwQmV6aWVyUG9pbnRzKSB7XG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtb2RlbCA9IHBvaW50c1tpXS5fbW9kZWw7XG5cdFx0XHRcdGlmIChpc1BvaW50SW5BcmVhKG1vZGVsLCBhcmVhKSkge1xuXHRcdFx0XHRcdGlmIChpID4gMCAmJiBpc1BvaW50SW5BcmVhKHBvaW50c1tpIC0gMV0uX21vZGVsLCBhcmVhKSkge1xuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcblx0XHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpIDwgcG9pbnRzLmxlbmd0aCAtIDEgJiYgaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLl9tb2RlbCwgYXJlYSkpIHtcblx0XHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludE5leHRYLCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50TmV4dFksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgaWxlbiA9IHBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGNsaXA7XG5cblx0XHRpZiAobWUuX3Nob3dMaW5lKSB7XG5cdFx0XHRjbGlwID0gbWV0YS5kYXRhc2V0Ll9tb2RlbC5jbGlwO1xuXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsaXBBcmVhKGNoYXJ0LmN0eCwge1xuXHRcdFx0XHRsZWZ0OiBjbGlwLmxlZnQgPT09IGZhbHNlID8gMCA6IGFyZWEubGVmdCAtIGNsaXAubGVmdCxcblx0XHRcdFx0cmlnaHQ6IGNsaXAucmlnaHQgPT09IGZhbHNlID8gY2FudmFzLndpZHRoIDogYXJlYS5yaWdodCArIGNsaXAucmlnaHQsXG5cdFx0XHRcdHRvcDogY2xpcC50b3AgPT09IGZhbHNlID8gMCA6IGFyZWEudG9wIC0gY2xpcC50b3AsXG5cdFx0XHRcdGJvdHRvbTogY2xpcC5ib3R0b20gPT09IGZhbHNlID8gY2FudmFzLmhlaWdodCA6IGFyZWEuYm90dG9tICsgY2xpcC5ib3R0b21cblx0XHRcdH0pO1xuXG5cdFx0XHRtZXRhLmRhdGFzZXQuZHJhdygpO1xuXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLnVuY2xpcEFyZWEoY2hhcnQuY3R4KTtcblx0XHR9XG5cblx0XHQvLyBEcmF3IHRoZSBwb2ludHNcblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cG9pbnRzW2ldLmRyYXcoYXJlYSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBtb2RlbCA9IHBvaW50Ll9tb2RlbDtcblx0XHR2YXIgb3B0aW9ucyA9IHBvaW50Ll9vcHRpb25zO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cblx0XHRwb2ludC4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxuXHRcdFx0cmFkaXVzOiBtb2RlbC5yYWRpdXNcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkNihvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ2KG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQ2KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdFx0bW9kZWwucmFkaXVzID0gdmFsdWVPckRlZmF1bHQkNihvcHRpb25zLmhvdmVyUmFkaXVzLCBvcHRpb25zLnJhZGl1cyk7XG5cdH0sXG59KTtcblxudmFyIHJlc29sdmUkMyA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgncG9sYXJBcmVhJywge1xuXHRzY2FsZToge1xuXHRcdHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuXHRcdGFuZ2xlTGluZXM6IHtcblx0XHRcdGRpc3BsYXk6IGZhbHNlXG5cdFx0fSxcblx0XHRncmlkTGluZXM6IHtcblx0XHRcdGNpcmN1bGFyOiB0cnVlXG5cdFx0fSxcblx0XHRwb2ludExhYmVsczoge1xuXHRcdFx0ZGlzcGxheTogZmFsc2Vcblx0XHR9LFxuXHRcdHRpY2tzOiB7XG5cdFx0XHRiZWdpbkF0WmVybzogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBCb29sZWFuIC0gV2hldGhlciB0byBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnRcblx0YW5pbWF0aW9uOiB7XG5cdFx0YW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcblx0XHRhbmltYXRlU2NhbGU6IHRydWVcblx0fSxcblxuXHRzdGFydEFuZ2xlOiAtMC41ICogTWF0aC5QSSxcblx0bGVnZW5kQ2FsbGJhY2s6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuXHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBsYWJlbHMgPSBkYXRhLmxhYmVscztcblx0XHR2YXIgaSwgaWxlbiwgbGlzdEl0ZW0sIGxpc3RJdGVtU3BhbjtcblxuXHRcdGxpc3Quc2V0QXR0cmlidXRlKCdjbGFzcycsIGNoYXJ0LmlkICsgJy1sZWdlbmQnKTtcblx0XHRpZiAoZGF0YXNldHMubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHNbMF0uZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bGlzdEl0ZW0gPSBsaXN0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJykpO1xuXHRcdFx0XHRsaXN0SXRlbVNwYW4gPSBsaXN0SXRlbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJykpO1xuXHRcdFx0XHRsaXN0SXRlbVNwYW4uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gZGF0YXNldHNbMF0uYmFja2dyb3VuZENvbG9yW2ldO1xuXHRcdFx0XHRpZiAobGFiZWxzW2ldKSB7XG5cdFx0XHRcdFx0bGlzdEl0ZW0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWxzW2ldKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbGlzdC5vdXRlckhUTUw7XG5cdH0sXG5cdGxlZ2VuZDoge1xuXHRcdGxhYmVsczoge1xuXHRcdFx0Z2VuZXJhdGVMYWJlbHM6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHRcdFx0aWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhLmxhYmVscy5tYXAoZnVuY3Rpb24obGFiZWwsIGkpIHtcblx0XHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG5cdFx0XHRcdFx0XHR2YXIgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHRleHQ6IGxhYmVsLFxuXHRcdFx0XHRcdFx0XHRmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcblx0XHRcdFx0XHRcdFx0c3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuXHRcdFx0XHRcdFx0XHRsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuXHRcdFx0XHRcdFx0XHRoaWRkZW46IGlzTmFOKGRhdGEuZGF0YXNldHNbMF0uZGF0YVtpXSkgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbixcblxuXHRcdFx0XHRcdFx0XHQvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cblx0XHRcdFx0XHRcdFx0aW5kZXg6IGlcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRvbkNsaWNrOiBmdW5jdGlvbihlLCBsZWdlbmRJdGVtKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBsZWdlbmRJdGVtLmluZGV4O1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcblx0XHRcdHZhciBpLCBpbGVuLCBtZXRhO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRcdG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuID0gIW1ldGEuZGF0YVtpbmRleF0uaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGFydC51cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTmVlZCB0byBvdmVycmlkZSB0aGVzZSB0byBnaXZlIGEgbmljZSBkZWZhdWx0XG5cdHRvb2x0aXBzOiB7XG5cdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHR0aXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0sXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSwgZGF0YSkge1xuXHRcdFx0XHRyZXR1cm4gZGF0YS5sYWJlbHNbaXRlbS5pbmRleF0gKyAnOiAnICsgaXRlbS55TGFiZWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIGNvbnRyb2xsZXJfcG9sYXJBcmVhID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuQXJjLFxuXG5cdGxpbmtTY2FsZXM6IGhlbHBlcnMkMS5ub29wLFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2RhdGFFbGVtZW50T3B0aW9uczogW1xuXHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxuXHRcdCdib3JkZXJDb2xvcicsXG5cdFx0J2JvcmRlcldpZHRoJyxcblx0XHQnYm9yZGVyQWxpZ24nLFxuXHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0J2hvdmVyQm9yZGVyQ29sb3InLFxuXHRcdCdob3ZlckJvcmRlcldpZHRoJyxcblx0XSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRJbmRleFNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlLmlkO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuc2NhbGUuaWQ7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHN0YXJ0ID0gbWUuY2hhcnQub3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XG5cdFx0dmFyIHN0YXJ0cyA9IG1lLl9zdGFydHMgPSBbXTtcblx0XHR2YXIgYW5nbGVzID0gbWUuX2FuZ2xlcyA9IFtdO1xuXHRcdHZhciBhcmNzID0gbWV0YS5kYXRhO1xuXHRcdHZhciBpLCBpbGVuLCBhbmdsZTtcblxuXHRcdG1lLl91cGRhdGVSYWRpdXMoKTtcblxuXHRcdG1ldGEuY291bnQgPSBtZS5jb3VudFZpc2libGVFbGVtZW50cygpO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXQuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcblx0XHRcdHN0YXJ0c1tpXSA9IHN0YXJ0O1xuXHRcdFx0YW5nbGUgPSBtZS5fY29tcHV0ZUFuZ2xlKGkpO1xuXHRcdFx0YW5nbGVzW2ldID0gYW5nbGU7XG5cdFx0XHRzdGFydCArPSBhbmdsZTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGFyY3NbaV0uX29wdGlvbnMgPSBtZS5fcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhhcmNzW2ldLCBpKTtcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQoYXJjc1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF91cGRhdGVSYWRpdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIG1pblNpemUgPSBNYXRoLm1pbihjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCwgY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3ApO1xuXG5cdFx0Y2hhcnQub3V0ZXJSYWRpdXMgPSBNYXRoLm1heChtaW5TaXplIC8gMiwgMCk7XG5cdFx0Y2hhcnQuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyAoY2hhcnQub3V0ZXJSYWRpdXMgLyAxMDApICogKG9wdHMuY3V0b3V0UGVyY2VudGFnZSkgOiAxLCAwKTtcblx0XHRjaGFydC5yYWRpdXNMZW5ndGggPSAoY2hhcnQub3V0ZXJSYWRpdXMgLSBjaGFydC5pbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG5cblx0XHRtZS5vdXRlclJhZGl1cyA9IGNoYXJ0Lm91dGVyUmFkaXVzIC0gKGNoYXJ0LnJhZGl1c0xlbmd0aCAqIG1lLmluZGV4KTtcblx0XHRtZS5pbm5lclJhZGl1cyA9IG1lLm91dGVyUmFkaXVzIC0gY2hhcnQucmFkaXVzTGVuZ3RoO1xuXHR9LFxuXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGFyYywgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcblx0XHR2YXIgc2NhbGUgPSBjaGFydC5zY2FsZTtcblx0XHR2YXIgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHM7XG5cblx0XHR2YXIgY2VudGVyWCA9IHNjYWxlLnhDZW50ZXI7XG5cdFx0dmFyIGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xuXG5cdFx0Ly8gdmFyIG5lZ0hhbGZQSSA9IC0wLjUgKiBNYXRoLlBJO1xuXHRcdHZhciBkYXRhc2V0U3RhcnRBbmdsZSA9IG9wdHMuc3RhcnRBbmdsZTtcblx0XHR2YXIgZGlzdGFuY2UgPSBhcmMuaGlkZGVuID8gMCA6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKGRhdGFzZXQuZGF0YVtpbmRleF0pO1xuXHRcdHZhciBzdGFydEFuZ2xlID0gbWUuX3N0YXJ0c1tpbmRleF07XG5cdFx0dmFyIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIChhcmMuaGlkZGVuID8gMCA6IG1lLl9hbmdsZXNbaW5kZXhdKTtcblxuXHRcdHZhciByZXNldFJhZGl1cyA9IGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKGRhdGFzZXQuZGF0YVtpbmRleF0pO1xuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zIHx8IHt9O1xuXG5cdFx0aGVscGVycyQxLmV4dGVuZChhcmMsIHtcblx0XHRcdC8vIFV0aWxpdHlcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxuXHRcdFx0X2luZGV4OiBpbmRleCxcblx0XHRcdF9zY2FsZTogc2NhbGUsXG5cblx0XHRcdC8vIERlc2lyZWQgdmlldyBwcm9wZXJ0aWVzXG5cdFx0XHRfbW9kZWw6IHtcblx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0XHRib3JkZXJBbGlnbjogb3B0aW9ucy5ib3JkZXJBbGlnbixcblx0XHRcdFx0eDogY2VudGVyWCxcblx0XHRcdFx0eTogY2VudGVyWSxcblx0XHRcdFx0aW5uZXJSYWRpdXM6IDAsXG5cdFx0XHRcdG91dGVyUmFkaXVzOiByZXNldCA/IHJlc2V0UmFkaXVzIDogZGlzdGFuY2UsXG5cdFx0XHRcdHN0YXJ0QW5nbGU6IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSA/IGRhdGFzZXRTdGFydEFuZ2xlIDogc3RhcnRBbmdsZSxcblx0XHRcdFx0ZW5kQW5nbGU6IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSA/IGRhdGFzZXRTdGFydEFuZ2xlIDogZW5kQW5nbGUsXG5cdFx0XHRcdGxhYmVsOiBoZWxwZXJzJDEudmFsdWVBdEluZGV4T3JEZWZhdWx0KGxhYmVscywgaW5kZXgsIGxhYmVsc1tpbmRleF0pXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhcmMucGl2b3QoKTtcblx0fSxcblxuXHRjb3VudFZpc2libGVFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdHZhciBjb3VudCA9IDA7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChtZXRhLmRhdGEsIGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG5cdFx0XHRpZiAoIWlzTmFOKGRhdGFzZXQuZGF0YVtpbmRleF0pICYmICFlbGVtZW50LmhpZGRlbikge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNvdW50O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihhcmMpIHtcblx0XHR2YXIgbW9kZWwgPSBhcmMuX21vZGVsO1xuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cdFx0dmFyIHZhbHVlT3JEZWZhdWx0ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG5cdFx0YXJjLiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NvbXB1dGVBbmdsZTogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjb3VudCA9IHRoaXMuZ2V0TWV0YSgpLmNvdW50O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXG5cdFx0aWYgKGlzTmFOKGRhdGFzZXQuZGF0YVtpbmRleF0pIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcblx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdGNoYXJ0OiBtZS5jaGFydCxcblx0XHRcdGRhdGFJbmRleDogaW5kZXgsXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdH07XG5cblx0XHRyZXR1cm4gcmVzb2x2ZSQzKFtcblx0XHRcdG1lLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjLmFuZ2xlLFxuXHRcdFx0KDIgKiBNYXRoLlBJKSAvIGNvdW50XG5cdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHR9XG59KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdwaWUnLCBoZWxwZXJzJDEuY2xvbmUoY29yZV9kZWZhdWx0cy5kb3VnaG51dCkpO1xuY29yZV9kZWZhdWx0cy5fc2V0KCdwaWUnLCB7XG5cdGN1dG91dFBlcmNlbnRhZ2U6IDBcbn0pO1xuXG4vLyBQaWUgY2hhcnRzIGFyZSBEb3VnaG51dCBjaGFydCB3aXRoIGRpZmZlcmVudCBkZWZhdWx0c1xudmFyIGNvbnRyb2xsZXJfcGllID0gY29udHJvbGxlcl9kb3VnaG51dDtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDcgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgncmFkYXInLCB7XG5cdHNwYW5HYXBzOiBmYWxzZSxcblx0c2NhbGU6IHtcblx0XHR0eXBlOiAncmFkaWFsTGluZWFyJ1xuXHR9LFxuXHRlbGVtZW50czoge1xuXHRcdGxpbmU6IHtcblx0XHRcdGZpbGw6ICdzdGFydCcsXG5cdFx0XHR0ZW5zaW9uOiAwIC8vIG5vIGJlemllciBpbiByYWRhclxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBjb250cm9sbGVyX3JhZGFyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXHRkYXRhc2V0RWxlbWVudFR5cGU6IGVsZW1lbnRzLkxpbmUsXG5cblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5Qb2ludCxcblxuXHRsaW5rU2NhbGVzOiBoZWxwZXJzJDEubm9vcCxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9kYXRhc2V0RWxlbWVudE9wdGlvbnM6IFtcblx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdCdib3JkZXJDb2xvcicsXG5cdFx0J2JvcmRlckNhcFN0eWxlJyxcblx0XHQnYm9yZGVyRGFzaCcsXG5cdFx0J2JvcmRlckRhc2hPZmZzZXQnLFxuXHRcdCdib3JkZXJKb2luU3R5bGUnLFxuXHRcdCdmaWxsJ1xuXHRdLFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2RhdGFFbGVtZW50T3B0aW9uczoge1xuXHRcdGJhY2tncm91bmRDb2xvcjogJ3BvaW50QmFja2dyb3VuZENvbG9yJyxcblx0XHRib3JkZXJDb2xvcjogJ3BvaW50Qm9yZGVyQ29sb3InLFxuXHRcdGJvcmRlcldpZHRoOiAncG9pbnRCb3JkZXJXaWR0aCcsXG5cdFx0aGl0UmFkaXVzOiAncG9pbnRIaXRSYWRpdXMnLFxuXHRcdGhvdmVyQmFja2dyb3VuZENvbG9yOiAncG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0aG92ZXJCb3JkZXJDb2xvcjogJ3BvaW50SG92ZXJCb3JkZXJDb2xvcicsXG5cdFx0aG92ZXJCb3JkZXJXaWR0aDogJ3BvaW50SG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0aG92ZXJSYWRpdXM6ICdwb2ludEhvdmVyUmFkaXVzJyxcblx0XHRwb2ludFN0eWxlOiAncG9pbnRTdHlsZScsXG5cdFx0cmFkaXVzOiAncG9pbnRSYWRpdXMnLFxuXHRcdHJvdGF0aW9uOiAncG9pbnRSb3RhdGlvbidcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRJbmRleFNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlLmlkO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuc2NhbGUuaWQ7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgc2NhbGUgPSBtZS5jaGFydC5zY2FsZTtcblx0XHR2YXIgY29uZmlnID0gbWUuX2NvbmZpZztcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdC8vIENvbXBhdGliaWxpdHk6IElmIHRoZSBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIHdpdGggb25seSB0aGUgb2xkIG5hbWUsIHVzZSB0aG9zZSB2YWx1ZXNcblx0XHRpZiAoY29uZmlnLnRlbnNpb24gIT09IHVuZGVmaW5lZCAmJiBjb25maWcubGluZVRlbnNpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uZmlnLmxpbmVUZW5zaW9uID0gY29uZmlnLnRlbnNpb247XG5cdFx0fVxuXG5cdFx0Ly8gVXRpbGl0eVxuXHRcdGxpbmUuX3NjYWxlID0gc2NhbGU7XG5cdFx0bGluZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0Ly8gRGF0YVxuXHRcdGxpbmUuX2NoaWxkcmVuID0gcG9pbnRzO1xuXHRcdGxpbmUuX2xvb3AgPSB0cnVlO1xuXHRcdC8vIE1vZGVsXG5cdFx0bGluZS5fbW9kZWwgPSBtZS5fcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhsaW5lKTtcblxuXHRcdGxpbmUucGl2b3QoKTtcblxuXHRcdC8vIFVwZGF0ZSBQb2ludHNcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWUudXBkYXRlRWxlbWVudChwb2ludHNbaV0sIGksIHJlc2V0KTtcblx0XHR9XG5cblx0XHQvLyBVcGRhdGUgYmV6aWVyIGNvbnRyb2wgcG9pbnRzXG5cdFx0bWUudXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cygpO1xuXG5cdFx0Ly8gTm93IHBpdm90IHRoZSBwb2ludCBmb3IgYW5pbWF0aW9uXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHBvaW50c1tpXS5waXZvdCgpO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihwb2ludCwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBzY2FsZSA9IG1lLmNoYXJ0LnNjYWxlO1xuXHRcdHZhciBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCBkYXRhc2V0LmRhdGFbaW5kZXhdKTtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLl9yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHBvaW50LCBpbmRleCk7XG5cdFx0dmFyIGxpbmVNb2RlbCA9IG1lLmdldE1ldGEoKS5kYXRhc2V0Ll9tb2RlbDtcblx0XHR2YXIgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcblx0XHR2YXIgeSA9IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueTtcblxuXHRcdC8vIFV0aWxpdHlcblx0XHRwb2ludC5fc2NhbGUgPSBzY2FsZTtcblx0XHRwb2ludC5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0cG9pbnQuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdHBvaW50Ll9pbmRleCA9IGluZGV4O1xuXG5cdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRwb2ludC5fbW9kZWwgPSB7XG5cdFx0XHR4OiB4LCAvLyB2YWx1ZSBub3QgdXNlZCBpbiBkYXRhc2V0IHNjYWxlLCBidXQgd2Ugd2FudCBhIGNvbnNpc3RlbnQgQVBJIGJldHdlZW4gc2NhbGVzXG5cdFx0XHR5OiB5LFxuXHRcdFx0c2tpcDogY3VzdG9tLnNraXAgfHwgaXNOYU4oeCkgfHwgaXNOYU4oeSksXG5cdFx0XHQvLyBBcHBlYXJhbmNlXG5cdFx0XHRyYWRpdXM6IG9wdGlvbnMucmFkaXVzLFxuXHRcdFx0cG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxuXHRcdFx0cm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdHRlbnNpb246IHZhbHVlT3JEZWZhdWx0JDcoY3VzdG9tLnRlbnNpb24sIGxpbmVNb2RlbCA/IGxpbmVNb2RlbC50ZW5zaW9uIDogMCksXG5cblx0XHRcdC8vIFRvb2x0aXBcblx0XHRcdGhpdFJhZGl1czogb3B0aW9ucy5oaXRSYWRpdXNcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNvbmZpZyA9IG1lLl9jb25maWc7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5jaGFydC5vcHRpb25zO1xuXHRcdHZhciB2YWx1ZXMgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5fcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucy5hcHBseShtZSwgYXJndW1lbnRzKTtcblxuXHRcdHZhbHVlcy5zcGFuR2FwcyA9IHZhbHVlT3JEZWZhdWx0JDcoY29uZmlnLnNwYW5HYXBzLCBvcHRpb25zLnNwYW5HYXBzKTtcblx0XHR2YWx1ZXMudGVuc2lvbiA9IHZhbHVlT3JEZWZhdWx0JDcoY29uZmlnLmxpbmVUZW5zaW9uLCBvcHRpb25zLmVsZW1lbnRzLmxpbmUudGVuc2lvbik7XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdHVwZGF0ZUJlemllckNvbnRyb2xQb2ludHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGFyZWEgPSBtZS5jaGFydC5jaGFydEFyZWE7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgaSwgaWxlbiwgbW9kZWwsIGNvbnRyb2xQb2ludHM7XG5cblx0XHQvLyBPbmx5IGNvbnNpZGVyIHBvaW50cyB0aGF0IGFyZSBkcmF3biBpbiBjYXNlIHRoZSBzcGFuR2FwcyBvcHRpb24gaXMgdXNlZFxuXHRcdGlmIChtZXRhLmRhdGFzZXQuX21vZGVsLnNwYW5HYXBzKSB7XG5cdFx0XHRwb2ludHMgPSBwb2ludHMuZmlsdGVyKGZ1bmN0aW9uKHB0KSB7XG5cdFx0XHRcdHJldHVybiAhcHQuX21vZGVsLnNraXA7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4ocHQsIG1heCksIG1pbik7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1vZGVsID0gcG9pbnRzW2ldLl9tb2RlbDtcblx0XHRcdGNvbnRyb2xQb2ludHMgPSBoZWxwZXJzJDEuc3BsaW5lQ3VydmUoXG5cdFx0XHRcdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpLCB0cnVlKS5fbW9kZWwsXG5cdFx0XHRcdG1vZGVsLFxuXHRcdFx0XHRoZWxwZXJzJDEubmV4dEl0ZW0ocG9pbnRzLCBpLCB0cnVlKS5fbW9kZWwsXG5cdFx0XHRcdG1vZGVsLnRlbnNpb25cblx0XHRcdCk7XG5cblx0XHRcdC8vIFByZXZlbnQgdGhlIGJlemllciBnb2luZyBvdXRzaWRlIG9mIHRoZSBib3VuZHMgb2YgdGhlIGdyYXBoXG5cdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5wcmV2aW91cy54LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMucHJldmlvdXMueSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcblx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMubmV4dC54LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5uZXh0LnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0fVxuXHR9LFxuXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXHRcdHZhciBvcHRpb25zID0gcG9pbnQuX29wdGlvbnM7XG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcblxuXHRcdHBvaW50LiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXG5cdFx0XHRyYWRpdXM6IG1vZGVsLnJhZGl1c1xuXHRcdH07XG5cblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ3KG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDcob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDcob3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcblx0XHRtb2RlbC5yYWRpdXMgPSB2YWx1ZU9yRGVmYXVsdCQ3KG9wdGlvbnMuaG92ZXJSYWRpdXMsIG9wdGlvbnMucmFkaXVzKTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnc2NhdHRlcicsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnc2luZ2xlJ1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0aWQ6ICd4LWF4aXMtMScsICAgIC8vIG5lZWQgYW4gSUQgc28gZGF0YXNldHMgY2FuIHJlZmVyZW5jZSB0aGUgc2NhbGVcblx0XHRcdHR5cGU6ICdsaW5lYXInLCAgICAvLyBzY2F0dGVyIHNob3VsZCBub3QgdXNlIGEgY2F0ZWdvcnkgYXhpc1xuXHRcdFx0cG9zaXRpb246ICdib3R0b20nXG5cdFx0fV0sXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHRpZDogJ3ktYXhpcy0xJyxcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0cG9zaXRpb246ICdsZWZ0J1xuXHRcdH1dXG5cdH0sXG5cblx0dG9vbHRpcHM6IHtcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICcnOyAgICAgLy8gZG9lc24ndCBtYWtlIHNlbnNlIGZvciBzY2F0dGVyIHNpbmNlIGRhdGEgYXJlIGZvcm1hdHRlZCBhcyBhIHBvaW50XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0cmV0dXJuICcoJyArIGl0ZW0ueExhYmVsICsgJywgJyArIGl0ZW0ueUxhYmVsICsgJyknO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRkYXRhc2V0czoge1xuXHRcdHNjYXR0ZXI6IHtcblx0XHRcdHNob3dMaW5lOiBmYWxzZVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIFNjYXR0ZXIgY2hhcnRzIHVzZSBsaW5lIGNvbnRyb2xsZXJzXG52YXIgY29udHJvbGxlcl9zY2F0dGVyID0gY29udHJvbGxlcl9saW5lO1xuXG4vLyBOT1RFIGV4cG9ydCBhIG1hcCBpbiB3aGljaCB0aGUga2V5IHJlcHJlc2VudHMgdGhlIGNvbnRyb2xsZXIgdHlwZSwgbm90XG4vLyB0aGUgY2xhc3MsIGFuZCBzbyBtdXN0IGJlIENhbWVsQ2FzZSBpbiBvcmRlciB0byBiZSBjb3JyZWN0bHkgcmV0cmlldmVkXG4vLyBieSB0aGUgY29udHJvbGxlciBpbiBjb3JlLmNvbnRyb2xsZXIuanMgKGBjb250cm9sbGVyc1ttZXRhLnR5cGVdYCkuXG5cbnZhciBjb250cm9sbGVycyA9IHtcblx0YmFyOiBjb250cm9sbGVyX2Jhcixcblx0YnViYmxlOiBjb250cm9sbGVyX2J1YmJsZSxcblx0ZG91Z2hudXQ6IGNvbnRyb2xsZXJfZG91Z2hudXQsXG5cdGhvcml6b250YWxCYXI6IGNvbnRyb2xsZXJfaG9yaXpvbnRhbEJhcixcblx0bGluZTogY29udHJvbGxlcl9saW5lLFxuXHRwb2xhckFyZWE6IGNvbnRyb2xsZXJfcG9sYXJBcmVhLFxuXHRwaWU6IGNvbnRyb2xsZXJfcGllLFxuXHRyYWRhcjogY29udHJvbGxlcl9yYWRhcixcblx0c2NhdHRlcjogY29udHJvbGxlcl9zY2F0dGVyXG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgcmVsYXRpdmUgcG9zaXRpb24gZm9yIGFuIGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50fElFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gZ2V0IHRoZSBwb3NpdGlvbiBmb3JcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0XG4gKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgZXZlbnQgcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCkge1xuXHRpZiAoZS5uYXRpdmUpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogZS54LFxuXHRcdFx0eTogZS55XG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiBoZWxwZXJzJDEuZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHRyYXZlcnNlIGFsbCBvZiB0aGUgdmlzaWJsZSBlbGVtZW50cyBpbiB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gdGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgZm9yIGVhY2ggdmlzaWJsZSBpdGVtXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBoYW5kbGVyKSB7XG5cdHZhciBtZXRhc2V0cyA9IGNoYXJ0Ll9nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG5cdHZhciBtZXRhZGF0YSwgaSwgaiwgaWxlbiwgamxlbiwgZWxlbWVudDtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0bWV0YWRhdGEgPSBtZXRhc2V0c1tpXS5kYXRhO1xuXHRcdGZvciAoaiA9IDAsIGpsZW4gPSBtZXRhZGF0YS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcblx0XHRcdGVsZW1lbnQgPSBtZXRhZGF0YVtqXTtcblx0XHRcdGlmICghZWxlbWVudC5fdmlldy5za2lwKSB7XG5cdFx0XHRcdGhhbmRsZXIoZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIGV2ZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0NoYXJ0RWxlbWVudFtdfSBpdGVtcyAtIGVsZW1lbnRzIHRvIGZpbHRlclxuICogQHBhcmFtIHtvYmplY3R9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG9cbiAqIEByZXR1cm4ge0NoYXJ0RWxlbWVudFtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pIHtcblx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGNvbnNpZGVyaW5nIGFsbCB2aXNpYmxlIGl0ZW1zIGluIHRlaCBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge29iamVjdH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0b1xuICogQHBhcmFtIHtib29sZWFufSBpbnRlcnNlY3QgLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtmdW5jdGlvbn0gZGlzdGFuY2VNZXRyaWMgLSBmdW5jdGlvbiB0byBwcm92aWRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50c1xuICogQHJldHVybiB7Q2hhcnRFbGVtZW50W119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGludGVyc2VjdCwgZGlzdGFuY2VNZXRyaWMpIHtcblx0dmFyIG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHR2YXIgbmVhcmVzdEl0ZW1zID0gW107XG5cblx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRpZiAoaW50ZXJzZWN0ICYmICFlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCgpO1xuXHRcdHZhciBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xuXHRcdGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRuZWFyZXN0SXRlbXMgPSBbZWxlbWVudF07XG5cdFx0XHRtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHRcdH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHQvLyBDYW4gaGF2ZSBtdWx0aXBsZSBpdGVtcyBhdCB0aGUgc2FtZSBkaXN0YW5jZSBpbiB3aGljaCBjYXNlIHdlIHNvcnQgYnkgc2l6ZVxuXHRcdFx0bmVhcmVzdEl0ZW1zLnB1c2goZWxlbWVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gbmVhcmVzdEl0ZW1zO1xufVxuXG4vKipcbiAqIEdldCBhIGRpc3RhbmNlIG1ldHJpYyBmdW5jdGlvbiBmb3IgdHdvIHBvaW50cyBiYXNlZCBvbiB0aGVcbiAqIGF4aXMgbW9kZSBzZXR0aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eVxuICovXG5mdW5jdGlvbiBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcykge1xuXHR2YXIgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcblx0dmFyIHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG5cdFx0dmFyIGRlbHRhWCA9IHVzZVggPyBNYXRoLmFicyhwdDEueCAtIHB0Mi54KSA6IDA7XG5cdFx0dmFyIGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGluZGV4TW9kZShjaGFydCwgZSwgb3B0aW9ucykge1xuXHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0Ly8gRGVmYXVsdCBheGlzIGZvciBpbmRleCBtb2RlIGlzICd4JyB0byBtYXRjaCBvbGQgYmVoYXZpb3VyXG5cdG9wdGlvbnMuYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG5cdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xuXHR2YXIgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdCA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBmYWxzZSwgZGlzdGFuY2VNZXRyaWMpO1xuXHR2YXIgZWxlbWVudHMgPSBbXTtcblxuXHRpZiAoIWl0ZW1zLmxlbmd0aCkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdGNoYXJ0Ll9nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkuZm9yRWFjaChmdW5jdGlvbihtZXRhKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSBtZXRhLmRhdGFbaXRlbXNbMF0uX2luZGV4XTtcblxuXHRcdC8vIGRvbid0IGNvdW50IGl0ZW1zIHRoYXQgYXJlIHNraXBwZWQgKG51bGwgZGF0YSlcblx0XHRpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5fdmlldy5za2lwKSB7XG5cdFx0XHRlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgSUludGVyYWN0aW9uT3B0aW9uc1xuICovXG4vKipcbiAqIElmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvaW50XG4gKiBAbmFtZSBJSW50ZXJmYWNlT3B0aW9ucyNib29sZWFuXG4gKiBAdHlwZSBCb29sZWFuXG4gKi9cblxuLyoqXG4gKiBDb250YWlucyBpbnRlcmFjdGlvbiByZWxhdGVkIGZ1bmN0aW9uc1xuICogQG5hbWVzcGFjZSBDaGFydC5JbnRlcmFjdGlvblxuICovXG52YXIgY29yZV9pbnRlcmFjdGlvbiA9IHtcblx0Ly8gSGVscGVyIGZ1bmN0aW9uIGZvciBkaWZmZXJlbnQgbW9kZXNcblx0bW9kZXM6IHtcblx0XHRzaW5nbGU6IGZ1bmN0aW9uKGNoYXJ0LCBlKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdHZhciBlbGVtZW50cyA9IFtdO1xuXG5cdFx0XHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0ZWxlbWVudHMucHVzaChlbGVtZW50KTtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbWVudHM7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gZWxlbWVudHMuc2xpY2UoMCwgMSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5sYWJlbFxuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi40LjBcblx0XHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRsYWJlbDogaW5kZXhNb2RlLFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBpdGVtcyBhdCB0aGUgc2FtZSBpbmRleC4gSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IHBhcmFtZXRlciBpcyB0cnVlLCB3ZSBvbmx5IHJldHVybiBpdGVtcyBpZiB3ZSBpbnRlcnNlY3Qgc29tZXRoaW5nXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IG1vZGUgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBhdCB0aGUgc2FtZSBpbmRleCBhcyB0aGF0IGl0ZW1cblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW5kZXhcblx0XHQgKiBAc2luY2UgdjIuNC4wXG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZSBkdXJpbmcgaW50ZXJhY3Rpb25cblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0aW5kZXg6IGluZGV4TW9kZSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgaW4gdGhlIHNhbWUgZGF0YXNldC4gSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IHBhcmFtZXRlciBpcyB0cnVlLCB3ZSBvbmx5IHJldHVybiBpdGVtcyBpZiB3ZSBpbnRlcnNlY3Qgc29tZXRoaW5nXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgaW4gdGhhdCBkYXRhc2V0XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmRhdGFzZXRcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlIGR1cmluZyBpbnRlcmFjdGlvblxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHRkYXRhc2V0OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHRvcHRpb25zLmF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5Jztcblx0XHRcdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xuXHRcdFx0dmFyIGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3QgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgZmFsc2UsIGRpc3RhbmNlTWV0cmljKTtcblxuXHRcdFx0aWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0aXRlbXMgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpdGVtc1swXS5fZGF0YXNldEluZGV4KS5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy54LWF4aXNcblx0XHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNC4wLiBVc2UgaW5kZXggbW9kZSBhbmQgaW50ZXJzZWN0ID09IHRydWVcblx0XHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHQneC1heGlzJzogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHRcdHJldHVybiBpbmRleE1vZGUoY2hhcnQsIGUsIHtpbnRlcnNlY3Q6IGZhbHNlfSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBvaW50IG1vZGUgcmV0dXJucyBhbGwgZWxlbWVudHMgdGhhdCBoaXQgdGVzdCBiYXNlZCBvbiB0aGUgZXZlbnQgcG9zaXRpb25cblx0XHQgKiBvZiB0aGUgZXZlbnRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0cG9pbnQ6IGZ1bmN0aW9uKGNoYXJ0LCBlKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdHJldHVybiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBuZWFyZXN0IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudCBjbG9zZXN0IHRvIHRoZSBwb2ludFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdG5lYXJlc3Q6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdG9wdGlvbnMuYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuXHRcdFx0dmFyIGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKG9wdGlvbnMuYXhpcyk7XG5cdFx0XHRyZXR1cm4gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgb3B0aW9ucy5pbnRlcnNlY3QsIGRpc3RhbmNlTWV0cmljKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogeCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeCBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnhcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdHg6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdFx0dmFyIGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG5cblx0XHRcdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdGlmIChlbGVtZW50LmluWFJhbmdlKHBvc2l0aW9uLngpKSB7XG5cdFx0XHRcdFx0aXRlbXMucHVzaChlbGVtZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdFx0XHRpbnRlcnNlY3RzSXRlbSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJZiB3ZSB3YW50IHRvIHRyaWdnZXIgb24gYW4gaW50ZXJzZWN0IGFuZCB3ZSBkb24ndCBoYXZlIGFueSBpdGVtc1xuXHRcdFx0Ly8gdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uLCByZXR1cm4gbm90aGluZ1xuXHRcdFx0aWYgKG9wdGlvbnMuaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuXHRcdFx0XHRpdGVtcyA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiB5IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB5IGNvb3JkaW5hdGVcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueVxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0eTogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0XHR2YXIgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcblxuXHRcdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5ZUmFuZ2UocG9zaXRpb24ueSkpIHtcblx0XHRcdFx0XHRpdGVtcy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xuXHRcdFx0XHRcdGludGVyc2VjdHNJdGVtID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIElmIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBhbiBpbnRlcnNlY3QgYW5kIHdlIGRvbid0IGhhdmUgYW55IGl0ZW1zXG5cdFx0XHQvLyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb24sIHJldHVybiBub3RoaW5nXG5cdFx0XHRpZiAob3B0aW9ucy5pbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XG5cdFx0XHRcdGl0ZW1zID0gW107XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgZXh0ZW5kID0gaGVscGVycyQxLmV4dGVuZDtcblxuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcblx0cmV0dXJuIGhlbHBlcnMkMS53aGVyZShhcnJheSwgZnVuY3Rpb24odikge1xuXHRcdHJldHVybiB2LnBvcyA9PT0gcG9zaXRpb247XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcblx0cmV0dXJuIGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdHZhciB2MCA9IHJldmVyc2UgPyBiIDogYTtcblx0XHR2YXIgdjEgPSByZXZlcnNlID8gYSA6IGI7XG5cdFx0cmV0dXJuIHYwLndlaWdodCA9PT0gdjEud2VpZ2h0ID9cblx0XHRcdHYwLmluZGV4IC0gdjEuaW5kZXggOlxuXHRcdFx0djAud2VpZ2h0IC0gdjEud2VpZ2h0O1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gd3JhcEJveGVzKGJveGVzKSB7XG5cdHZhciBsYXlvdXRCb3hlcyA9IFtdO1xuXHR2YXIgaSwgaWxlbiwgYm94O1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSAoYm94ZXMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGJveCA9IGJveGVzW2ldO1xuXHRcdGxheW91dEJveGVzLnB1c2goe1xuXHRcdFx0aW5kZXg6IGksXG5cdFx0XHRib3g6IGJveCxcblx0XHRcdHBvczogYm94LnBvc2l0aW9uLFxuXHRcdFx0aG9yaXpvbnRhbDogYm94LmlzSG9yaXpvbnRhbCgpLFxuXHRcdFx0d2VpZ2h0OiBib3gud2VpZ2h0XG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIGxheW91dEJveGVzO1xufVxuXG5mdW5jdGlvbiBzZXRMYXlvdXREaW1zKGxheW91dHMsIHBhcmFtcykge1xuXHR2YXIgaSwgaWxlbiwgbGF5b3V0O1xuXHRmb3IgKGkgPSAwLCBpbGVuID0gbGF5b3V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRsYXlvdXQgPSBsYXlvdXRzW2ldO1xuXHRcdC8vIHN0b3JlIHdpZHRoIHVzZWQgaW5zdGVhZCBvZiBjaGFydEFyZWEudyBpbiBmaXRCb3hlc1xuXHRcdGxheW91dC53aWR0aCA9IGxheW91dC5ob3Jpem9udGFsXG5cdFx0XHQ/IGxheW91dC5ib3guZnVsbFdpZHRoICYmIHBhcmFtcy5hdmFpbGFibGVXaWR0aFxuXHRcdFx0OiBwYXJhbXMudkJveE1heFdpZHRoO1xuXHRcdC8vIHN0b3JlIGhlaWdodCB1c2VkIGluc3RlYWQgb2YgY2hhcnRBcmVhLmggaW4gZml0Qm94ZXNcblx0XHRsYXlvdXQuaGVpZ2h0ID0gbGF5b3V0Lmhvcml6b250YWwgJiYgcGFyYW1zLmhCb3hNYXhIZWlnaHQ7XG5cdH1cbn1cblxuZnVuY3Rpb24gYnVpbGRMYXlvdXRCb3hlcyhib3hlcykge1xuXHR2YXIgbGF5b3V0Qm94ZXMgPSB3cmFwQm94ZXMoYm94ZXMpO1xuXHR2YXIgbGVmdCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnbGVmdCcpLCB0cnVlKTtcblx0dmFyIHJpZ2h0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdyaWdodCcpKTtcblx0dmFyIHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xuXHR2YXIgYm90dG9tID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdib3R0b20nKSk7XG5cblx0cmV0dXJuIHtcblx0XHRsZWZ0QW5kVG9wOiBsZWZ0LmNvbmNhdCh0b3ApLFxuXHRcdHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoYm90dG9tKSxcblx0XHRjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcblx0XHR2ZXJ0aWNhbDogbGVmdC5jb25jYXQocmlnaHQpLFxuXHRcdGhvcml6b250YWw6IHRvcC5jb25jYXQoYm90dG9tKVxuXHR9O1xufVxuXG5mdW5jdGlvbiBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsIGEsIGIpIHtcblx0cmV0dXJuIE1hdGgubWF4KG1heFBhZGRpbmdbYV0sIGNoYXJ0QXJlYVthXSkgKyBNYXRoLm1heChtYXhQYWRkaW5nW2JdLCBjaGFydEFyZWFbYl0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQpIHtcblx0dmFyIGJveCA9IGxheW91dC5ib3g7XG5cdHZhciBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cdHZhciBuZXdXaWR0aCwgbmV3SGVpZ2h0O1xuXG5cdGlmIChsYXlvdXQuc2l6ZSkge1xuXHRcdC8vIHRoaXMgbGF5b3V0IHdhcyBhbHJlYWR5IGNvdW50ZWQgZm9yLCBsZXRzIGZpcnN0IHJlZHVjZSBvbGQgc2l6ZVxuXHRcdGNoYXJ0QXJlYVtsYXlvdXQucG9zXSAtPSBsYXlvdXQuc2l6ZTtcblx0fVxuXHRsYXlvdXQuc2l6ZSA9IGxheW91dC5ob3Jpem9udGFsID8gYm94LmhlaWdodCA6IGJveC53aWR0aDtcblx0Y2hhcnRBcmVhW2xheW91dC5wb3NdICs9IGxheW91dC5zaXplO1xuXG5cdGlmIChib3guZ2V0UGFkZGluZykge1xuXHRcdHZhciBib3hQYWRkaW5nID0gYm94LmdldFBhZGRpbmcoKTtcblx0XHRtYXhQYWRkaW5nLnRvcCA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wLCBib3hQYWRkaW5nLnRvcCk7XG5cdFx0bWF4UGFkZGluZy5sZWZ0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5sZWZ0LCBib3hQYWRkaW5nLmxlZnQpO1xuXHRcdG1heFBhZGRpbmcuYm90dG9tID0gTWF0aC5tYXgobWF4UGFkZGluZy5ib3R0b20sIGJveFBhZGRpbmcuYm90dG9tKTtcblx0XHRtYXhQYWRkaW5nLnJpZ2h0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCwgYm94UGFkZGluZy5yaWdodCk7XG5cdH1cblxuXHRuZXdXaWR0aCA9IHBhcmFtcy5vdXRlcldpZHRoIC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAnbGVmdCcsICdyaWdodCcpO1xuXHRuZXdIZWlnaHQgPSBwYXJhbXMub3V0ZXJIZWlnaHQgLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICd0b3AnLCAnYm90dG9tJyk7XG5cblx0aWYgKG5ld1dpZHRoICE9PSBjaGFydEFyZWEudyB8fCBuZXdIZWlnaHQgIT09IGNoYXJ0QXJlYS5oKSB7XG5cdFx0Y2hhcnRBcmVhLncgPSBuZXdXaWR0aDtcblx0XHRjaGFydEFyZWEuaCA9IG5ld0hlaWdodDtcblxuXHRcdC8vIHJldHVybiB0cnVlIGlmIGNoYXJ0IGFyZWEgY2hhbmdlZCBpbiBsYXlvdXQncyBkaXJlY3Rpb25cblx0XHRyZXR1cm4gbGF5b3V0Lmhvcml6b250YWwgPyBuZXdXaWR0aCAhPT0gY2hhcnRBcmVhLncgOiBuZXdIZWlnaHQgIT09IGNoYXJ0QXJlYS5oO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XG5cdHZhciBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cblx0ZnVuY3Rpb24gdXBkYXRlUG9zKHBvcykge1xuXHRcdHZhciBjaGFuZ2UgPSBNYXRoLm1heChtYXhQYWRkaW5nW3Bvc10gLSBjaGFydEFyZWFbcG9zXSwgMCk7XG5cdFx0Y2hhcnRBcmVhW3Bvc10gKz0gY2hhbmdlO1xuXHRcdHJldHVybiBjaGFuZ2U7XG5cdH1cblx0Y2hhcnRBcmVhLnkgKz0gdXBkYXRlUG9zKCd0b3AnKTtcblx0Y2hhcnRBcmVhLnggKz0gdXBkYXRlUG9zKCdsZWZ0Jyk7XG5cdHVwZGF0ZVBvcygncmlnaHQnKTtcblx0dXBkYXRlUG9zKCdib3R0b20nKTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFyZ2lucyhob3Jpem9udGFsLCBjaGFydEFyZWEpIHtcblx0dmFyIG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuXHRmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XG5cdFx0dmFyIG1hcmdpbiA9IHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9O1xuXHRcdHBvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvcykge1xuXHRcdFx0bWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gbWFyZ2luO1xuXHR9XG5cblx0cmV0dXJuIGhvcml6b250YWxcblx0XHQ/IG1hcmdpbkZvclBvc2l0aW9ucyhbJ2xlZnQnLCAncmlnaHQnXSlcblx0XHQ6IG1hcmdpbkZvclBvc2l0aW9ucyhbJ3RvcCcsICdib3R0b20nXSk7XG59XG5cbmZ1bmN0aW9uIGZpdEJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcykge1xuXHR2YXIgcmVmaXRCb3hlcyA9IFtdO1xuXHR2YXIgaSwgaWxlbiwgbGF5b3V0LCBib3gsIHJlZml0LCBjaGFuZ2VkO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBib3hlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRsYXlvdXQgPSBib3hlc1tpXTtcblx0XHRib3ggPSBsYXlvdXQuYm94O1xuXG5cdFx0Ym94LnVwZGF0ZShcblx0XHRcdGxheW91dC53aWR0aCB8fCBjaGFydEFyZWEudyxcblx0XHRcdGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsXG5cdFx0XHRnZXRNYXJnaW5zKGxheW91dC5ob3Jpem9udGFsLCBjaGFydEFyZWEpXG5cdFx0KTtcblx0XHRpZiAodXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0KSkge1xuXHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRpZiAocmVmaXRCb3hlcy5sZW5ndGgpIHtcblx0XHRcdFx0Ly8gRGltZW5zaW9ucyBjaGFuZ2VkIGFuZCB0aGVyZSB3ZXJlIG5vbiBmdWxsIHdpZHRoIGJveGVzIGJlZm9yZSB0aGlzXG5cdFx0XHRcdC8vIC0+IHdlIGhhdmUgdG8gcmVmaXQgdGhvc2Vcblx0XHRcdFx0cmVmaXQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIWJveC5mdWxsV2lkdGgpIHsgLy8gZnVsbFdpZHRoIGJveGVzIGRvbid0IG5lZWQgdG8gYmUgcmUtZml0dGVkIGluIGFueSBjYXNlXG5cdFx0XHRyZWZpdEJveGVzLnB1c2gobGF5b3V0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVmaXQgPyBmaXRCb3hlcyhyZWZpdEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcykgfHwgY2hhbmdlZCA6IGNoYW5nZWQ7XG59XG5cbmZ1bmN0aW9uIHBsYWNlQm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zKSB7XG5cdHZhciB1c2VyUGFkZGluZyA9IHBhcmFtcy5wYWRkaW5nO1xuXHR2YXIgeCA9IGNoYXJ0QXJlYS54O1xuXHR2YXIgeSA9IGNoYXJ0QXJlYS55O1xuXHR2YXIgaSwgaWxlbiwgbGF5b3V0LCBib3g7XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IGJveGVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGxheW91dCA9IGJveGVzW2ldO1xuXHRcdGJveCA9IGxheW91dC5ib3g7XG5cdFx0aWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG5cdFx0XHRib3gubGVmdCA9IGJveC5mdWxsV2lkdGggPyB1c2VyUGFkZGluZy5sZWZ0IDogY2hhcnRBcmVhLmxlZnQ7XG5cdFx0XHRib3gucmlnaHQgPSBib3guZnVsbFdpZHRoID8gcGFyYW1zLm91dGVyV2lkdGggLSB1c2VyUGFkZGluZy5yaWdodCA6IGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnc7XG5cdFx0XHRib3gudG9wID0geTtcblx0XHRcdGJveC5ib3R0b20gPSB5ICsgYm94LmhlaWdodDtcblx0XHRcdGJveC53aWR0aCA9IGJveC5yaWdodCAtIGJveC5sZWZ0O1xuXHRcdFx0eSA9IGJveC5ib3R0b207XG5cdFx0fSBlbHNlIHtcblx0XHRcdGJveC5sZWZ0ID0geDtcblx0XHRcdGJveC5yaWdodCA9IHggKyBib3gud2lkdGg7XG5cdFx0XHRib3gudG9wID0gY2hhcnRBcmVhLnRvcDtcblx0XHRcdGJveC5ib3R0b20gPSBjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmg7XG5cdFx0XHRib3guaGVpZ2h0ID0gYm94LmJvdHRvbSAtIGJveC50b3A7XG5cdFx0XHR4ID0gYm94LnJpZ2h0O1xuXHRcdH1cblx0fVxuXG5cdGNoYXJ0QXJlYS54ID0geDtcblx0Y2hhcnRBcmVhLnkgPSB5O1xufVxuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0bGF5b3V0OiB7XG5cdFx0cGFkZGluZzoge1xuXHRcdFx0dG9wOiAwLFxuXHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRib3R0b206IDAsXG5cdFx0XHRsZWZ0OiAwXG5cdFx0fVxuXHR9XG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIElMYXlvdXRJdGVtXG4gKiBAcHJvcCB7c3RyaW5nfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBpbiB0aGUgY2hhcnQgbGF5b3V0LiBQb3NzaWJsZSB2YWx1ZXMgYXJlXG4gKiAnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgYW5kICdjaGFydEFyZWEnXG4gKiBAcHJvcCB7bnVtYmVyfSB3ZWlnaHQgLSBUaGUgd2VpZ2h0IHVzZWQgdG8gc29ydCB0aGUgaXRlbS4gSGlnaGVyIHdlaWdodHMgYXJlIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBjaGFydCBhcmVhXG4gKiBAcHJvcCB7Ym9vbGVhbn0gZnVsbFdpZHRoIC0gaWYgdHJ1ZSwgYW5kIHRoZSBpdGVtIGlzIGhvcml6b250YWwsIHRoZW4gcHVzaCB2ZXJ0aWNhbCBib3hlcyBkb3duXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGlzSG9yaXpvbnRhbCAtIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGl0ZW0gaXMgaG9yaXpvbnRhbCAoaWUuIHRvcCBvciBib3R0b20pXG4gKiBAcHJvcCB7ZnVuY3Rpb259IHVwZGF0ZSAtIFRha2VzIHR3byBwYXJhbWV0ZXJzOiB3aWR0aCBhbmQgaGVpZ2h0LiBSZXR1cm5zIHNpemUgb2YgaXRlbVxuICogQHByb3Age2Z1bmN0aW9ufSBnZXRQYWRkaW5nIC0gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFkZGluZyBvbiB0aGUgZWRnZXNcbiAqIEBwcm9wIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGxlZnQgLSBMZWZ0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHRvcCAtIFRvcCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSByaWdodCAtIFJpZ2h0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IGJvdHRvbSAtIEJvdHRvbSBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKi9cblxuLy8gVGhlIGxheW91dCBzZXJ2aWNlIGlzIHZlcnkgc2VsZiBleHBsYW5hdG9yeS4gIEl0J3MgcmVzcG9uc2libGUgZm9yIHRoZSBsYXlvdXQgd2l0aGluIGEgY2hhcnQuXG4vLyBTY2FsZXMsIExlZ2VuZHMgYW5kIFBsdWdpbnMgYWxsIHJlbHkgb24gdGhlIGxheW91dCBzZXJ2aWNlIGFuZCBjYW4gZWFzaWx5IHJlZ2lzdGVyIHRvIGJlIHBsYWNlZCBhbnl3aGVyZSB0aGV5IG5lZWRcbi8vIEl0IGlzIHRoaXMgc2VydmljZSdzIHJlc3BvbnNpYmlsaXR5IG9mIGNhcnJ5aW5nIG91dCB0aGF0IGxheW91dC5cbnZhciBjb3JlX2xheW91dHMgPSB7XG5cdGRlZmF1bHRzOiB7fSxcblxuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cblx0ICogQSBib3ggaXMgc2ltcGx5IGEgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCB0aGF0IHJlcXVpcmVzIGxheW91dC4gZWcuIFNjYWxlcywgTGVnZW5kLCBUaXRsZS5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gdXNlXG5cdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBhZGQgdG8gYmUgbGF5ZWQgb3V0XG5cdCAqL1xuXHRhZGRCb3g6IGZ1bmN0aW9uKGNoYXJ0LCBpdGVtKSB7XG5cdFx0aWYgKCFjaGFydC5ib3hlcykge1xuXHRcdFx0Y2hhcnQuYm94ZXMgPSBbXTtcblx0XHR9XG5cblx0XHQvLyBpbml0aWFsaXplIGl0ZW0gd2l0aCBkZWZhdWx0IHZhbHVlc1xuXHRcdGl0ZW0uZnVsbFdpZHRoID0gaXRlbS5mdWxsV2lkdGggfHwgZmFsc2U7XG5cdFx0aXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XG5cdFx0aXRlbS53ZWlnaHQgPSBpdGVtLndlaWdodCB8fCAwO1xuXHRcdGl0ZW0uX2xheWVycyA9IGl0ZW0uX2xheWVycyB8fCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbe1xuXHRcdFx0XHR6OiAwLFxuXHRcdFx0XHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpdGVtLmRyYXcuYXBwbHkoaXRlbSwgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fV07XG5cdFx0fTtcblxuXHRcdGNoYXJ0LmJveGVzLnB1c2goaXRlbSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIGxheW91dEl0ZW0gZnJvbSBhIGNoYXJ0XG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIHJlbW92ZSB0aGUgYm94IGZyb21cblx0ICogQHBhcmFtIHtJTGF5b3V0SXRlbX0gbGF5b3V0SXRlbSAtIHRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsYXlvdXRcblx0ICovXG5cdHJlbW92ZUJveDogZnVuY3Rpb24oY2hhcnQsIGxheW91dEl0ZW0pIHtcblx0XHR2YXIgaW5kZXggPSBjaGFydC5ib3hlcyA/IGNoYXJ0LmJveGVzLmluZGV4T2YobGF5b3V0SXRlbSkgOiAtMTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRjaGFydC5ib3hlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0cyAob3IgdXBkYXRlcykgb3B0aW9ucyBvbiB0aGUgZ2l2ZW4gYGl0ZW1gLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCBpbiB3aGljaCB0aGUgaXRlbSBsaXZlcyAob3Igd2lsbCBiZSBhZGRlZCB0bylcblx0ICogQHBhcmFtIHtJTGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGNvbmZpZ3VyZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gdGhlIG5ldyBpdGVtIG9wdGlvbnMuXG5cdCAqL1xuXHRjb25maWd1cmU6IGZ1bmN0aW9uKGNoYXJ0LCBpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIHByb3BzID0gWydmdWxsV2lkdGgnLCAncG9zaXRpb24nLCAnd2VpZ2h0J107XG5cdFx0dmFyIGlsZW4gPSBwcm9wcy5sZW5ndGg7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciBwcm9wO1xuXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHByb3AgPSBwcm9wc1tpXTtcblx0XHRcdGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdFx0XHRcdGl0ZW1bcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogRml0cyBib3hlcyBvZiB0aGUgZ2l2ZW4gY2hhcnQgaW50byB0aGUgZ2l2ZW4gc2l6ZSBieSBoYXZpbmcgZWFjaCBib3ggbWVhc3VyZSBpdHNlbGZcblx0ICogdGhlbiBydW5uaW5nIGEgZml0dGluZyBhbGdvcml0aG1cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIHdpZHRoIHRvIGZpdCBpbnRvXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IHRvIGZpdCBpbnRvXG5cdCAqL1xuXHR1cGRhdGU6IGZ1bmN0aW9uKGNoYXJ0LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0aWYgKCFjaGFydCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBsYXlvdXRPcHRpb25zID0gY2hhcnQub3B0aW9ucy5sYXlvdXQgfHwge307XG5cdFx0dmFyIHBhZGRpbmcgPSBoZWxwZXJzJDEub3B0aW9ucy50b1BhZGRpbmcobGF5b3V0T3B0aW9ucy5wYWRkaW5nKTtcblxuXHRcdHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gcGFkZGluZy53aWR0aDtcblx0XHR2YXIgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQ7XG5cdFx0dmFyIGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XG5cdFx0dmFyIHZlcnRpY2FsQm94ZXMgPSBib3hlcy52ZXJ0aWNhbDtcblx0XHR2YXIgaG9yaXpvbnRhbEJveGVzID0gYm94ZXMuaG9yaXpvbnRhbDtcblxuXHRcdC8vIEVzc2VudGlhbGx5IHdlIG5vdyBoYXZlIGFueSBudW1iZXIgb2YgYm94ZXMgb24gZWFjaCBvZiB0aGUgNCBzaWRlcy5cblx0XHQvLyBPdXIgY2FudmFzIGxvb2tzIGxpa2UgdGhlIGZvbGxvd2luZy5cblx0XHQvLyBUaGUgYXJlYXMgTDEgYW5kIEwyIGFyZSB0aGUgbGVmdCBheGVzLiBSMSBpcyB0aGUgcmlnaHQgYXhpcywgVDEgaXMgdGhlIHRvcCBheGlzIGFuZFxuXHRcdC8vIEIxIGlzIHRoZSBib3R0b20gYXhpc1xuXHRcdC8vIFRoZXJlIGFyZSBhbHNvIDQgcXVhZHJhbnQtbGlrZSBsb2NhdGlvbnMgKGxlZnQgdG8gcmlnaHQgaW5zdGVhZCBvZiBjbG9ja3dpc2UpIHJlc2VydmVkIGZvciBjaGFydCBvdmVybGF5c1xuXHRcdC8vIFRoZXNlIGxvY2F0aW9ucyBhcmUgc2luZ2xlLWJveCBsb2NhdGlvbnMgb25seSwgd2hlbiB0cnlpbmcgdG8gcmVnaXN0ZXIgYSBjaGFydEFyZWEgbG9jYXRpb24gdGhhdCBpcyBhbHJlYWR5IHRha2VuLFxuXHRcdC8vIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuXHRcdC8vXG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0Ly8gfCAgICAgICAgICAgICAgICAgIFQxIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIFQyICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0Ly8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG5cdFx0Ly8gfCAgICB8ICAgIHwgQzEgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzIgfCAgICB8XG5cdFx0Ly8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0Ly8gfCBMMSB8IEwyIHwgICAgICAgICAgIENoYXJ0QXJlYSAoQzApICAgICAgICAgICAgfCBSMSB8XG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0Ly8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG5cdFx0Ly8gfCAgICB8ICAgIHwgQzMgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzQgfCAgICB8XG5cdFx0Ly8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIEIxICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0Ly8gfCAgICAgICAgICAgICAgICAgIEIyIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0Ly9cblxuXHRcdHZhciBwYXJhbXMgPSBPYmplY3QuZnJlZXplKHtcblx0XHRcdG91dGVyV2lkdGg6IHdpZHRoLFxuXHRcdFx0b3V0ZXJIZWlnaHQ6IGhlaWdodCxcblx0XHRcdHBhZGRpbmc6IHBhZGRpbmcsXG5cdFx0XHRhdmFpbGFibGVXaWR0aDogYXZhaWxhYmxlV2lkdGgsXG5cdFx0XHR2Qm94TWF4V2lkdGg6IGF2YWlsYWJsZVdpZHRoIC8gMiAvIHZlcnRpY2FsQm94ZXMubGVuZ3RoLFxuXHRcdFx0aEJveE1heEhlaWdodDogYXZhaWxhYmxlSGVpZ2h0IC8gMlxuXHRcdH0pO1xuXHRcdHZhciBjaGFydEFyZWEgPSBleHRlbmQoe1xuXHRcdFx0bWF4UGFkZGluZzogZXh0ZW5kKHt9LCBwYWRkaW5nKSxcblx0XHRcdHc6IGF2YWlsYWJsZVdpZHRoLFxuXHRcdFx0aDogYXZhaWxhYmxlSGVpZ2h0LFxuXHRcdFx0eDogcGFkZGluZy5sZWZ0LFxuXHRcdFx0eTogcGFkZGluZy50b3Bcblx0XHR9LCBwYWRkaW5nKTtcblxuXHRcdHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcblxuXHRcdC8vIEZpcnN0IGZpdCB2ZXJ0aWNhbCBib3hlc1xuXHRcdGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zKTtcblxuXHRcdC8vIFRoZW4gZml0IGhvcml6b250YWwgYm94ZXNcblx0XHRpZiAoZml0Qm94ZXMoaG9yaXpvbnRhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcykpIHtcblx0XHRcdC8vIGlmIHRoZSBhcmVhIGNoYW5nZWQsIHJlLWZpdCB2ZXJ0aWNhbCBib3hlc1xuXHRcdFx0Zml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMpO1xuXHRcdH1cblxuXHRcdGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKTtcblxuXHRcdC8vIEZpbmFsbHkgcGxhY2UgdGhlIGJveGVzIHRvIGNvcnJlY3QgY29vcmRpbmF0ZXNcblx0XHRwbGFjZUJveGVzKGJveGVzLmxlZnRBbmRUb3AsIGNoYXJ0QXJlYSwgcGFyYW1zKTtcblxuXHRcdC8vIE1vdmUgdG8gb3Bwb3NpdGUgc2lkZSBvZiBjaGFydFxuXHRcdGNoYXJ0QXJlYS54ICs9IGNoYXJ0QXJlYS53O1xuXHRcdGNoYXJ0QXJlYS55ICs9IGNoYXJ0QXJlYS5oO1xuXG5cdFx0cGxhY2VCb3hlcyhib3hlcy5yaWdodEFuZEJvdHRvbSwgY2hhcnRBcmVhLCBwYXJhbXMpO1xuXG5cdFx0Y2hhcnQuY2hhcnRBcmVhID0ge1xuXHRcdFx0bGVmdDogY2hhcnRBcmVhLmxlZnQsXG5cdFx0XHR0b3A6IGNoYXJ0QXJlYS50b3AsXG5cdFx0XHRyaWdodDogY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEudyxcblx0XHRcdGJvdHRvbTogY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5oXG5cdFx0fTtcblxuXHRcdC8vIEZpbmFsbHkgdXBkYXRlIGJveGVzIGluIGNoYXJ0QXJlYSAocmFkaWFsIHNjYWxlIGZvciBleGFtcGxlKVxuXHRcdGhlbHBlcnMkMS5lYWNoKGJveGVzLmNoYXJ0QXJlYSwgZnVuY3Rpb24obGF5b3V0KSB7XG5cdFx0XHR2YXIgYm94ID0gbGF5b3V0LmJveDtcblx0XHRcdGV4dGVuZChib3gsIGNoYXJ0LmNoYXJ0QXJlYSk7XG5cdFx0XHRib3gudXBkYXRlKGNoYXJ0QXJlYS53LCBjaGFydEFyZWEuaCk7XG5cdFx0fSk7XG5cdH1cbn07XG5cbi8qKlxuICogUGxhdGZvcm0gZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gKG1pbmltYWwpLlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1OTEjaXNzdWVjb21tZW50LTMxOTU3NTkzOVxuICovXG5cbnZhciBwbGF0Zm9ybV9iYXNpYyA9IHtcblx0YWNxdWlyZUNvbnRleHQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuXHRcdFx0Ly8gU3VwcG9ydCBmb3IgYW55IG9iamVjdCBhc3NvY2lhdGVkIHRvIGEgY2FudmFzIChpbmNsdWRpbmcgYSBjb250ZXh0MmQpXG5cdFx0XHRpdGVtID0gaXRlbS5jYW52YXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpIHx8IG51bGw7XG5cdH1cbn07XG5cbnZhciBwbGF0Zm9ybV9kb20gPSBcIi8qXFxuICogRE9NIGVsZW1lbnQgcmVuZGVyaW5nIGRldGVjdGlvblxcbiAqIGh0dHBzOi8vZGF2aWR3YWxzaC5uYW1lL2RldGVjdC1ub2RlLWluc2VydGlvblxcbiAqL1xcbkBrZXlmcmFtZXMgY2hhcnRqcy1yZW5kZXItYW5pbWF0aW9uIHtcXG5cXHRmcm9tIHsgb3BhY2l0eTogMC45OTsgfVxcblxcdHRvIHsgb3BhY2l0eTogMTsgfVxcbn1cXG5cXG4uY2hhcnRqcy1yZW5kZXItbW9uaXRvciB7XFxuXFx0YW5pbWF0aW9uOiBjaGFydGpzLXJlbmRlci1hbmltYXRpb24gMC4wMDFzO1xcbn1cXG5cXG4vKlxcbiAqIERPTSBlbGVtZW50IHJlc2l6aW5nIGRldGVjdGlvblxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjai9jc3MtZWxlbWVudC1xdWVyaWVzXFxuICovXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLFxcbi5jaGFydGpzLXNpemUtbW9uaXRvci1leHBhbmQsXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLXNocmluayB7XFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcblxcdGRpcmVjdGlvbjogbHRyO1xcblxcdGxlZnQ6IDA7XFxuXFx0dG9wOiAwO1xcblxcdHJpZ2h0OiAwO1xcblxcdGJvdHRvbTogMDtcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcblxcdHZpc2liaWxpdHk6IGhpZGRlbjtcXG5cXHR6LWluZGV4OiAtMTtcXG59XFxuXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLWV4cGFuZCA+IGRpdiB7XFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcblxcdHdpZHRoOiAxMDAwMDAwcHg7XFxuXFx0aGVpZ2h0OiAxMDAwMDAwcHg7XFxuXFx0bGVmdDogMDtcXG5cXHR0b3A6IDA7XFxufVxcblxcbi5jaGFydGpzLXNpemUtbW9uaXRvci1zaHJpbmsgPiBkaXYge1xcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cXHR3aWR0aDogMjAwJTtcXG5cXHRoZWlnaHQ6IDIwMCU7XFxuXFx0bGVmdDogMDtcXG5cXHR0b3A6IDA7XFxufVxcblwiO1xuXG52YXIgcGxhdGZvcm1fZG9tJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG4nZGVmYXVsdCc6IHBsYXRmb3JtX2RvbVxufSk7XG5cbnZhciBzdHlsZXNoZWV0ID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShwbGF0Zm9ybV9kb20kMSk7XG5cbnZhciBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG52YXIgQ1NTX1BSRUZJWCA9ICdjaGFydGpzLSc7XG52YXIgQ1NTX1NJWkVfTU9OSVRPUiA9IENTU19QUkVGSVggKyAnc2l6ZS1tb25pdG9yJztcbnZhciBDU1NfUkVOREVSX01PTklUT1IgPSBDU1NfUFJFRklYICsgJ3JlbmRlci1tb25pdG9yJztcbnZhciBDU1NfUkVOREVSX0FOSU1BVElPTiA9IENTU19QUkVGSVggKyAncmVuZGVyLWFuaW1hdGlvbic7XG52YXIgQU5JTUFUSU9OX1NUQVJUX0VWRU5UUyA9IFsnYW5pbWF0aW9uc3RhcnQnLCAnd2Via2l0QW5pbWF0aW9uU3RhcnQnXTtcblxuLyoqXG4gKiBET00gZXZlbnQgdHlwZXMgLT4gQ2hhcnQuanMgZXZlbnQgdHlwZXMuXG4gKiBOb3RlOiBvbmx5IGV2ZW50cyB3aXRoIGRpZmZlcmVudCB0eXBlcyBhcmUgbWFwcGVkLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHNcbiAqL1xudmFyIEVWRU5UX1RZUEVTID0ge1xuXHR0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcblx0dG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcblx0dG91Y2hlbmQ6ICdtb3VzZXVwJyxcblx0cG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG5cdHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcblx0cG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuXHRwb2ludGVydXA6ICdtb3VzZXVwJyxcblx0cG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuXHRwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuXG4vKipcbiAqIFRoZSBcInVzZWRcIiBzaXplIGlzIHRoZSBmaW5hbCB2YWx1ZSBvZiBhIGRpbWVuc2lvbiBwcm9wZXJ0eSBhZnRlciBhbGwgY2FsY3VsYXRpb25zIGhhdmVcbiAqIGJlZW4gcGVyZm9ybWVkLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjb21wdXRlZCBzdHlsZSBvZiBgZWxlbWVudGAgYnV0IHJldHVybnMgdW5kZWZpbmVkXG4gKiBpZiB0aGUgY29tcHV0ZWQgc3R5bGUgaXMgbm90IGV4cHJlc3NlZCBpbiBwaXhlbHMuIFRoYXQgY2FuIGhhcHBlbiBpbiBzb21lIGNhc2VzIHdoZXJlXG4gKiBgZWxlbWVudGAgaGFzIGEgc2l6ZSByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGFuZCB0aGlzIGxhc3Qgb25lIGlzIG5vdCB5ZXQgZGlzcGxheWVkLFxuICogZm9yIGV4YW1wbGUgYmVjYXVzZSBvZiBgZGlzcGxheTogbm9uZWAgb24gYSBwYXJlbnQgbm9kZS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3VzZWRfdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpemUgaW4gcGl4ZWxzIG9yIHVuZGVmaW5lZCBpZiB1bmtub3duLlxuICovXG5mdW5jdGlvbiByZWFkVXNlZFNpemUoZWxlbWVudCwgcHJvcGVydHkpIHtcblx0dmFyIHZhbHVlID0gaGVscGVycyQxLmdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcblx0dmFyIG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcblx0cmV0dXJuIG1hdGNoZXMgPyBOdW1iZXIobWF0Y2hlc1sxXSkgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBzdHlsZSBhbmQgcmVuZGVyIHNpemUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIGNhbnZhcyBkaXNwbGF5IHNpemUsXG4gKiBzaW5jZSByZXNwb25zaXZlbmVzcyBpcyBoYW5kbGVkIGJ5IHRoZSBjb250cm9sbGVyLnJlc2l6ZSgpIG1ldGhvZC4gVGhlIGNvbmZpZyBpcyB1c2VkXG4gKiB0byBkZXRlcm1pbmUgdGhlIGFzcGVjdCByYXRpbyB0byBhcHBseSBpbiBjYXNlIG5vIGV4cGxpY2l0IGhlaWdodCBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gKi9cbmZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBjb25maWcpIHtcblx0dmFyIHN0eWxlID0gY2FudmFzLnN0eWxlO1xuXG5cdC8vIE5PVEUoU0IpIGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgIT09IGNhbnZhcy53aWR0aDogaW4gdGhlIGZpcnN0IGNhc2UgaXRcblx0Ly8gcmV0dXJucyBudWxsIG9yICcnIGlmIG5vIGV4cGxpY2l0IHZhbHVlIGhhcyBiZWVuIHNldCB0byB0aGUgY2FudmFzIGF0dHJpYnV0ZS5cblx0dmFyIHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuXHR2YXIgcmVuZGVyV2lkdGggPSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuXG5cdC8vIENoYXJ0LmpzIG1vZGlmaWVzIHNvbWUgY2FudmFzIHZhbHVlcyB0aGF0IHdlIHdhbnQgdG8gcmVzdG9yZSBvbiBkZXN0cm95XG5cdGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XG5cdFx0aW5pdGlhbDoge1xuXHRcdFx0aGVpZ2h0OiByZW5kZXJIZWlnaHQsXG5cdFx0XHR3aWR0aDogcmVuZGVyV2lkdGgsXG5cdFx0XHRzdHlsZToge1xuXHRcdFx0XHRkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxuXHRcdFx0XHRoZWlnaHQ6IHN0eWxlLmhlaWdodCxcblx0XHRcdFx0d2lkdGg6IHN0eWxlLndpZHRoXG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEZvcmNlIGNhbnZhcyB0byBkaXNwbGF5IGFzIGJsb2NrIHRvIGF2b2lkIGV4dHJhIHNwYWNlIGNhdXNlZCBieSBpbmxpbmVcblx0Ly8gZWxlbWVudHMsIHdoaWNoIHdvdWxkIGludGVyZmVyZSB3aXRoIHRoZSByZXNwb25zaXZlIHJlc2l6ZSBwcm9jZXNzLlxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjUzOFxuXHRzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xuXG5cdGlmIChyZW5kZXJXaWR0aCA9PT0gbnVsbCB8fCByZW5kZXJXaWR0aCA9PT0gJycpIHtcblx0XHR2YXIgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG5cdFx0aWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHJlbmRlckhlaWdodCA9PT0gbnVsbCB8fCByZW5kZXJIZWlnaHQgPT09ICcnKSB7XG5cdFx0aWYgKGNhbnZhcy5zdHlsZS5oZWlnaHQgPT09ICcnKSB7XG5cdFx0XHQvLyBJZiBubyBleHBsaWNpdCByZW5kZXIgaGVpZ2h0IGFuZCBzdHlsZSBoZWlnaHQsIGxldCdzIGFwcGx5IHRoZSBhc3BlY3QgcmF0aW8sXG5cdFx0XHQvLyB3aGljaCBvbmUgY2FuIGJlIHNwZWNpZmllZCBieSB0aGUgdXNlciBidXQgYWxzbyBieSBjaGFydHMgYXMgZGVmYXVsdCBvcHRpb25cblx0XHRcdC8vIChpLmUuIG9wdGlvbnMuYXNwZWN0UmF0aW8pLiBJZiBub3Qgc3BlY2lmaWVkLCB1c2UgY2FudmFzIGFzcGVjdCByYXRpbyBvZiAyLlxuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChjb25maWcub3B0aW9ucy5hc3BlY3RSYXRpbyB8fCAyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG5cdFx0XHRpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNhbnZhcztcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHN1cHBvcnQgZm9yIG9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGluIGFkZEV2ZW50TGlzdGVuZXIuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcblx0dmFyIHN1cHBvcnRzID0gZmFsc2U7XG5cdHRyeSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdldHRlci1yZXR1cm5cblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHN1cHBvcnRzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZScsIG51bGwsIG9wdGlvbnMpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuXHR9XG5cdHJldHVybiBzdXBwb3J0cztcbn0oKSk7XG5cbi8vIERlZmF1bHQgcGFzc2l2ZSB0byB0cnVlIGFzIGV4cGVjdGVkIGJ5IENocm9tZSBmb3IgJ3RvdWNoc3RhcnQnIGFuZCAndG91Y2hlbmQnIGV2ZW50cy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80Mjg3XG52YXIgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihub2RlLCB0eXBlLCBsaXN0ZW5lcikge1xuXHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnQodHlwZSwgY2hhcnQsIHgsIHksIG5hdGl2ZUV2ZW50KSB7XG5cdHJldHVybiB7XG5cdFx0dHlwZTogdHlwZSxcblx0XHRjaGFydDogY2hhcnQsXG5cdFx0bmF0aXZlOiBuYXRpdmVFdmVudCB8fCBudWxsLFxuXHRcdHg6IHggIT09IHVuZGVmaW5lZCA/IHggOiBudWxsLFxuXHRcdHk6IHkgIT09IHVuZGVmaW5lZCA/IHkgOiBudWxsLFxuXHR9O1xufVxuXG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG5cdHZhciB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcblx0dmFyIHBvcyA9IGhlbHBlcnMkMS5nZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG5cdHJldHVybiBjcmVhdGVFdmVudCh0eXBlLCBjaGFydCwgcG9zLngsIHBvcy55LCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHRocm90dGxlZChmbiwgdGhpc0FyZykge1xuXHR2YXIgdGlja2luZyA9IGZhbHNlO1xuXHR2YXIgYXJncyA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHR0aGlzQXJnID0gdGhpc0FyZyB8fCB0aGlzO1xuXG5cdFx0aWYgKCF0aWNraW5nKSB7XG5cdFx0XHR0aWNraW5nID0gdHJ1ZTtcblx0XHRcdGhlbHBlcnMkMS5yZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGlja2luZyA9IGZhbHNlO1xuXHRcdFx0XHRmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGl2KGNscykge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ZWwuY2xhc3NOYW1lID0gY2xzIHx8ICcnO1xuXHRyZXR1cm4gZWw7XG59XG5cbi8vIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjai9jc3MtZWxlbWVudC1xdWVyaWVzXG5mdW5jdGlvbiBjcmVhdGVSZXNpemVyKGhhbmRsZXIpIHtcblx0dmFyIG1heFNpemUgPSAxMDAwMDAwO1xuXG5cdC8vIE5PVEUoU0IpIERvbid0IHVzZSBpbm5lckhUTUwgYmVjYXVzZSBpdCBjb3VsZCBiZSBjb25zaWRlcmVkIHVuc2FmZS5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU5MDJcblx0dmFyIHJlc2l6ZXIgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUik7XG5cdHZhciBleHBhbmQgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUiArICctZXhwYW5kJyk7XG5cdHZhciBzaHJpbmsgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUiArICctc2hyaW5rJyk7XG5cblx0ZXhwYW5kLmFwcGVuZENoaWxkKGNyZWF0ZURpdigpKTtcblx0c2hyaW5rLmFwcGVuZENoaWxkKGNyZWF0ZURpdigpKTtcblxuXHRyZXNpemVyLmFwcGVuZENoaWxkKGV4cGFuZCk7XG5cdHJlc2l6ZXIuYXBwZW5kQ2hpbGQoc2hyaW5rKTtcblx0cmVzaXplci5fcmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHRleHBhbmQuc2Nyb2xsTGVmdCA9IG1heFNpemU7XG5cdFx0ZXhwYW5kLnNjcm9sbFRvcCA9IG1heFNpemU7XG5cdFx0c2hyaW5rLnNjcm9sbExlZnQgPSBtYXhTaXplO1xuXHRcdHNocmluay5zY3JvbGxUb3AgPSBtYXhTaXplO1xuXHR9O1xuXG5cdHZhciBvblNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJlc2l6ZXIuX3Jlc2V0KCk7XG5cdFx0aGFuZGxlcigpO1xuXHR9O1xuXG5cdGFkZExpc3RlbmVyKGV4cGFuZCwgJ3Njcm9sbCcsIG9uU2Nyb2xsLmJpbmQoZXhwYW5kLCAnZXhwYW5kJykpO1xuXHRhZGRMaXN0ZW5lcihzaHJpbmssICdzY3JvbGwnLCBvblNjcm9sbC5iaW5kKHNocmluaywgJ3NocmluaycpKTtcblxuXHRyZXR1cm4gcmVzaXplcjtcbn1cblxuLy8gaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LW5vZGUtaW5zZXJ0aW9uXG5mdW5jdGlvbiB3YXRjaEZvclJlbmRlcihub2RlLCBoYW5kbGVyKSB7XG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwgKG5vZGVbRVhQQU5ET19LRVldID0ge30pO1xuXHR2YXIgcHJveHkgPSBleHBhbmRvLnJlbmRlclByb3h5ID0gZnVuY3Rpb24oZSkge1xuXHRcdGlmIChlLmFuaW1hdGlvbk5hbWUgPT09IENTU19SRU5ERVJfQU5JTUFUSU9OKSB7XG5cdFx0XHRoYW5kbGVyKCk7XG5cdFx0fVxuXHR9O1xuXG5cdGhlbHBlcnMkMS5lYWNoKEFOSU1BVElPTl9TVEFSVF9FVkVOVFMsIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRhZGRMaXN0ZW5lcihub2RlLCB0eXBlLCBwcm94eSk7XG5cdH0pO1xuXG5cdC8vICM0NzM3OiBDaHJvbWUgbWlnaHQgc2tpcCB0aGUgQ1NTIGFuaW1hdGlvbiB3aGVuIHRoZSBDU1NfUkVOREVSX01PTklUT1IgY2xhc3Ncblx0Ly8gaXMgcmVtb3ZlZCB0aGVuIGFkZGVkIGJhY2sgaW1tZWRpYXRlbHkgKHNhbWUgYW5pbWF0aW9uIGZyYW1lPykuIEFjY2Vzc2luZyB0aGVcblx0Ly8gYG9mZnNldFBhcmVudGAgcHJvcGVydHkgd2lsbCBmb3JjZSBhIHJlZmxvdyBhbmQgcmUtZXZhbHVhdGUgdGhlIENTUyBhbmltYXRpb24uXG5cdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81ZDUyZmIwODFiMzU3MGM4MWUzYSNib3gtbWV0cmljc1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDczN1xuXHRleHBhbmRvLnJlZmxvdyA9ICEhbm9kZS5vZmZzZXRQYXJlbnQ7XG5cblx0bm9kZS5jbGFzc0xpc3QuYWRkKENTU19SRU5ERVJfTU9OSVRPUik7XG59XG5cbmZ1bmN0aW9uIHVud2F0Y2hGb3JSZW5kZXIobm9kZSkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IHt9O1xuXHR2YXIgcHJveHkgPSBleHBhbmRvLnJlbmRlclByb3h5O1xuXG5cdGlmIChwcm94eSkge1xuXHRcdGhlbHBlcnMkMS5lYWNoKEFOSU1BVElPTl9TVEFSVF9FVkVOVFMsIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHJlbW92ZUxpc3RlbmVyKG5vZGUsIHR5cGUsIHByb3h5KTtcblx0XHR9KTtcblxuXHRcdGRlbGV0ZSBleHBhbmRvLnJlbmRlclByb3h5O1xuXHR9XG5cblx0bm9kZS5jbGFzc0xpc3QucmVtb3ZlKENTU19SRU5ERVJfTU9OSVRPUik7XG59XG5cbmZ1bmN0aW9uIGFkZFJlc2l6ZUxpc3RlbmVyKG5vZGUsIGxpc3RlbmVyLCBjaGFydCkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IChub2RlW0VYUEFORE9fS0VZXSA9IHt9KTtcblxuXHQvLyBMZXQncyBrZWVwIHRyYWNrIG9mIHRoaXMgYWRkZWQgcmVzaXplciBhbmQgdGh1cyBhdm9pZCBET00gcXVlcnkgd2hlbiByZW1vdmluZyBpdC5cblx0dmFyIHJlc2l6ZXIgPSBleHBhbmRvLnJlc2l6ZXIgPSBjcmVhdGVSZXNpemVyKHRocm90dGxlZChmdW5jdGlvbigpIHtcblx0XHRpZiAoZXhwYW5kby5yZXNpemVyKSB7XG5cdFx0XHR2YXIgY29udGFpbmVyID0gY2hhcnQub3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdHZhciB3ID0gY29udGFpbmVyID8gY29udGFpbmVyLmNsaWVudFdpZHRoIDogMDtcblx0XHRcdGxpc3RlbmVyKGNyZWF0ZUV2ZW50KCdyZXNpemUnLCBjaGFydCkpO1xuXHRcdFx0aWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIuY2xpZW50V2lkdGggPCB3ICYmIGNoYXJ0LmNhbnZhcykge1xuXHRcdFx0XHQvLyBJZiB0aGUgY29udGFpbmVyIHNpemUgc2hyYW5rIGR1cmluZyBjaGFydCByZXNpemUsIGxldCdzIGFzc3VtZVxuXHRcdFx0XHQvLyBzY3JvbGxiYXIgYXBwZWFyZWQuIFNvIHdlIHJlc2l6ZSBhZ2FpbiB3aXRoIHRoZSBzY3JvbGxiYXIgdmlzaWJsZSAtXG5cdFx0XHRcdC8vIGVmZmVjdGl2ZWx5IG1ha2luZyBjaGFydCBzbWFsbGVyIGFuZCB0aGUgc2Nyb2xsYmFyIGhpZGRlbiBhZ2Fpbi5cblx0XHRcdFx0Ly8gQmVjYXVzZSB3ZSBhcmUgaW5zaWRlIGB0aHJvdHRsZWRgLCBhbmQgY3VycmVudGx5IGB0aWNraW5nYCwgc2Nyb2xsXG5cdFx0XHRcdC8vIGV2ZW50cyBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyB3aG9sZSAyIHJlc2l6ZSBwcm9jZXNzLlxuXHRcdFx0XHQvLyBJZiB3ZSBhc3N1bWVkIHdyb25nIGFuZCBzb21ldGhpbmcgZWxzZSBoYXBwZW5lZCwgd2UgYXJlIHJlc2l6aW5nXG5cdFx0XHRcdC8vIHR3aWNlIGluIGEgZnJhbWUgKHBvdGVudGlhbCBwZXJmb3JtYW5jZSBpc3N1ZSlcblx0XHRcdFx0bGlzdGVuZXIoY3JlYXRlRXZlbnQoJ3Jlc2l6ZScsIGNoYXJ0KSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KSk7XG5cblx0Ly8gVGhlIHJlc2l6ZXIgbmVlZHMgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIG5vZGUgcGFyZW50LCBzbyB3ZSBmaXJzdCBuZWVkIHRvIGJlXG5cdC8vIHN1cmUgdGhhdCBgbm9kZWAgaXMgYXR0YWNoZWQgdG8gdGhlIERPTSBiZWZvcmUgaW5qZWN0aW5nIHRoZSByZXNpemVyIGVsZW1lbnQuXG5cdHdhdGNoRm9yUmVuZGVyKG5vZGUsIGZ1bmN0aW9uKCkge1xuXHRcdGlmIChleHBhbmRvLnJlc2l6ZXIpIHtcblx0XHRcdHZhciBjb250YWluZXIgPSBub2RlLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lciAhPT0gcmVzaXplci5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdGNvbnRhaW5lci5pbnNlcnRCZWZvcmUocmVzaXplciwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgY29udGFpbmVyIHNpemUgbWlnaHQgaGF2ZSBjaGFuZ2VkLCBsZXQncyByZXNldCB0aGUgcmVzaXplciBzdGF0ZS5cblx0XHRcdHJlc2l6ZXIuX3Jlc2V0KCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlUmVzaXplTGlzdGVuZXIobm9kZSkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IHt9O1xuXHR2YXIgcmVzaXplciA9IGV4cGFuZG8ucmVzaXplcjtcblxuXHRkZWxldGUgZXhwYW5kby5yZXNpemVyO1xuXHR1bndhdGNoRm9yUmVuZGVyKG5vZGUpO1xuXG5cdGlmIChyZXNpemVyICYmIHJlc2l6ZXIucGFyZW50Tm9kZSkge1xuXHRcdHJlc2l6ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyZXNpemVyKTtcblx0fVxufVxuXG4vKipcbiAqIEluamVjdHMgQ1NTIHN0eWxlcyBpbmxpbmUgaWYgdGhlIHN0eWxlcyBhcmUgbm90IGFscmVhZHkgcHJlc2VudC5cbiAqIEBwYXJhbSB7SFRNTERvY3VtZW50fFNoYWRvd1Jvb3R9IHJvb3ROb2RlIC0gdGhlIG5vZGUgdG8gY29udGFpbiB0aGUgPHN0eWxlPi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3MgLSB0aGUgQ1NTIHRvIGJlIGluamVjdGVkLlxuICovXG5mdW5jdGlvbiBpbmplY3RDU1Mocm9vdE5vZGUsIGNzcykge1xuXHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzkyMjEzOVxuXHR2YXIgZXhwYW5kbyA9IHJvb3ROb2RlW0VYUEFORE9fS0VZXSB8fCAocm9vdE5vZGVbRVhQQU5ET19LRVldID0ge30pO1xuXHRpZiAoIWV4cGFuZG8uY29udGFpbnNTdHlsZXMpIHtcblx0XHRleHBhbmRvLmNvbnRhaW5zU3R5bGVzID0gdHJ1ZTtcblx0XHRjc3MgPSAnLyogQ2hhcnQuanMgKi9cXG4nICsgY3NzO1xuXHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdFx0cm9vdE5vZGUuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9XG59XG5cbnZhciBwbGF0Zm9ybV9kb20kMiA9IHtcblx0LyoqXG5cdCAqIFdoZW4gYHRydWVgLCBwcmV2ZW50cyB0aGUgYXV0b21hdGljIGluamVjdGlvbiBvZiB0aGUgc3R5bGVzaGVldCByZXF1aXJlZCB0b1xuXHQgKiBjb3JyZWN0bHkgZGV0ZWN0IHdoZW4gdGhlIGNoYXJ0IGlzIGFkZGVkIHRvIHRoZSBET00gYW5kIHRoZW4gcmVzaXplZC4gVGhpc1xuXHQgKiBzd2l0Y2ggaGFzIGJlZW4gYWRkZWQgdG8gYWxsb3cgZXh0ZXJuYWwgc3R5bGVzaGVldCAoYGRpc3QvQ2hhcnQoLm1pbik/LmpzYClcblx0ICogdG8gYmUgbWFudWFsbHkgaW1wb3J0ZWQgdG8gbWFrZSB0aGlzIGxpYnJhcnkgY29tcGF0aWJsZSB3aXRoIGFueSBDU1AuXG5cdCAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTIwOFxuXHQgKi9cblx0ZGlzYWJsZUNTU0luamVjdGlvbjogZmFsc2UsXG5cblx0LyoqXG5cdCAqIFRoaXMgcHJvcGVydHkgaG9sZHMgd2hldGhlciB0aGlzIHBsYXRmb3JtIGlzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuXHQgKiBDdXJyZW50bHkgdXNlZCBieSBwbGF0Zm9ybS5qcyB0byBzZWxlY3QgdGhlIHByb3BlciBpbXBsZW1lbnRhdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbmFibGVkOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyByZXNvdXJjZXMgdGhhdCBkZXBlbmQgb24gcGxhdGZvcm0gb3B0aW9ucy5cblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gVGhlIENhbnZhcyBlbGVtZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2Vuc3VyZUxvYWRlZDogZnVuY3Rpb24oY2FudmFzKSB7XG5cdFx0aWYgKCF0aGlzLmRpc2FibGVDU1NJbmplY3Rpb24pIHtcblx0XHRcdC8vIElmIHRoZSBjYW52YXMgaXMgaW4gYSBzaGFkb3cgRE9NLCB0aGVuIHRoZSBzdHlsZXMgbXVzdCBhbHNvIGJlIGluc2VydGVkXG5cdFx0XHQvLyBpbnRvIHRoZSBzYW1lIHNoYWRvdyBET00uXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTc2M1xuXHRcdFx0dmFyIHJvb3QgPSBjYW52YXMuZ2V0Um9vdE5vZGUgPyBjYW52YXMuZ2V0Um9vdE5vZGUoKSA6IGRvY3VtZW50O1xuXHRcdFx0dmFyIHRhcmdldE5vZGUgPSByb290Lmhvc3QgPyByb290IDogZG9jdW1lbnQuaGVhZDtcblx0XHRcdGluamVjdENTUyh0YXJnZXROb2RlLCBzdHlsZXNoZWV0KTtcblx0XHR9XG5cdH0sXG5cblx0YWNxdWlyZUNvbnRleHQ6IGZ1bmN0aW9uKGl0ZW0sIGNvbmZpZykge1xuXHRcdGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcblx0XHR9IGVsc2UgaWYgKGl0ZW0ubGVuZ3RoKSB7XG5cdFx0XHQvLyBTdXBwb3J0IGZvciBhcnJheSBiYXNlZCBxdWVyaWVzIChzdWNoIGFzIGpRdWVyeSlcblx0XHRcdGl0ZW0gPSBpdGVtWzBdO1xuXHRcdH1cblxuXHRcdGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG5cdFx0XHQvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcblx0XHRcdGl0ZW0gPSBpdGVtLmNhbnZhcztcblx0XHR9XG5cblx0XHQvLyBUbyBwcmV2ZW50IGNhbnZhcyBmaW5nZXJwcmludGluZywgc29tZSBhZGQtb25zIHVuZGVmaW5lIHRoZSBnZXRDb250ZXh0XG5cdFx0Ly8gbWV0aG9kLCBmb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2trYXBzbmVyL0NhbnZhc0Jsb2NrZXJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuXHRcdHZhciBjb250ZXh0ID0gaXRlbSAmJiBpdGVtLmdldENvbnRleHQgJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpO1xuXG5cdFx0Ly8gYGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEYCBmYWlscyB3aGVuIHRoZSBpdGVtIGlzXG5cdFx0Ly8gaW5zaWRlIGFuIGlmcmFtZSBvciB3aGVuIHJ1bm5pbmcgaW4gYSBwcm90ZWN0ZWQgZW52aXJvbm1lbnQuIFdlIGNvdWxkIGd1ZXNzIHRoZVxuXHRcdC8vIHR5cGVzIGZyb20gdGhlaXIgdG9TdHJpbmcoKSB2YWx1ZSBidXQgbGV0J3Mga2VlcCB0aGluZ3MgZmxleGlibGUgYW5kIGFzc3VtZSBpdCdzXG5cdFx0Ly8gYSBzdWZmaWNpZW50IGNvbmRpdGlvbiBpZiB0aGUgaXRlbSBoYXMgYSBjb250ZXh0MkQgd2hpY2ggaGFzIGl0ZW0gYXMgYGNhbnZhc2AuXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM4ODdcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDEwMlxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTUyXG5cdFx0aWYgKGNvbnRleHQgJiYgY29udGV4dC5jYW52YXMgPT09IGl0ZW0pIHtcblx0XHRcdC8vIExvYWQgcGxhdGZvcm0gcmVzb3VyY2VzIG9uIGZpcnN0IGNoYXJ0IGNyZWF0aW9uLCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvXG5cdFx0XHQvLyBpbXBvcnQgdGhlIGxpYnJhcnkgYmVmb3JlIHNldHRpbmcgcGxhdGZvcm0gb3B0aW9ucy5cblx0XHRcdHRoaXMuX2Vuc3VyZUxvYWRlZChpdGVtKTtcblx0XHRcdGluaXRDYW52YXMoaXRlbSwgY29uZmlnKTtcblx0XHRcdHJldHVybiBjb250ZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdHJlbGVhc2VDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0dmFyIGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuXHRcdGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpbml0aWFsID0gY2FudmFzW0VYUEFORE9fS0VZXS5pbml0aWFsO1xuXHRcdFsnaGVpZ2h0JywgJ3dpZHRoJ10uZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBpbml0aWFsW3Byb3BdO1xuXHRcdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHZhbHVlKSkge1xuXHRcdFx0XHRjYW52YXMucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FudmFzLnNldEF0dHJpYnV0ZShwcm9wLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChpbml0aWFsLnN0eWxlIHx8IHt9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRjYW52YXMuc3R5bGVba2V5XSA9IHZhbHVlO1xuXHRcdH0pO1xuXG5cdFx0Ly8gVGhlIGNhbnZhcyByZW5kZXIgc2l6ZSBtaWdodCBoYXZlIGJlZW4gY2hhbmdlZCAoYW5kIHRodXMgdGhlIHN0YXRlIHN0YWNrIGRpc2NhcmRlZCksXG5cdFx0Ly8gd2UgY2FuJ3QgdXNlIHNhdmUoKSBhbmQgcmVzdG9yZSgpIHRvIHJlc3RvcmUgdGhlIGluaXRpYWwgc3RhdGUuIFNvIG1ha2Ugc3VyZSB0aGF0IGF0XG5cdFx0Ly8gbGVhc3QgdGhlIGNhbnZhcyBjb250ZXh0IGlzIHJlc2V0IHRvIHRoZSBkZWZhdWx0IHN0YXRlIGJ5IHNldHRpbmcgdGhlIGNhbnZhcyB3aWR0aC5cblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAxMS9XRC1odG1sNS0yMDExMDUyNS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbFxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuXHRcdGNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcblxuXHRcdGRlbGV0ZSBjYW52YXNbRVhQQU5ET19LRVldO1xuXHR9LFxuXG5cdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuXHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cdFx0aWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG5cdFx0XHQvLyBOb3RlOiB0aGUgcmVzaXplIGV2ZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gYWxsIGJyb3dzZXJzLlxuXHRcdFx0YWRkUmVzaXplTGlzdGVuZXIoY2FudmFzLCBsaXN0ZW5lciwgY2hhcnQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBleHBhbmRvID0gbGlzdGVuZXJbRVhQQU5ET19LRVldIHx8IChsaXN0ZW5lcltFWFBBTkRPX0tFWV0gPSB7fSk7XG5cdFx0dmFyIHByb3hpZXMgPSBleHBhbmRvLnByb3hpZXMgfHwgKGV4cGFuZG8ucHJveGllcyA9IHt9KTtcblx0XHR2YXIgcHJveHkgPSBwcm94aWVzW2NoYXJ0LmlkICsgJ18nICsgdHlwZV0gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0bGlzdGVuZXIoZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkpO1xuXHRcdH07XG5cblx0XHRhZGRMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcblx0fSxcblxuXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuXHRcdGlmICh0eXBlID09PSAncmVzaXplJykge1xuXHRcdFx0Ly8gTm90ZTogdGhlIHJlc2l6ZSBldmVudCBpcyBub3Qgc3VwcG9ydGVkIG9uIGFsbCBicm93c2Vycy5cblx0XHRcdHJlbW92ZVJlc2l6ZUxpc3RlbmVyKGNhbnZhcyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGV4cGFuZG8gPSBsaXN0ZW5lcltFWFBBTkRPX0tFWV0gfHwge307XG5cdFx0dmFyIHByb3hpZXMgPSBleHBhbmRvLnByb3hpZXMgfHwge307XG5cdFx0dmFyIHByb3h5ID0gcHJveGllc1tjaGFydC5pZCArICdfJyArIHR5cGVdO1xuXHRcdGlmICghcHJveHkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRyZW1vdmVMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcblx0fVxufTtcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyIGluc3RlYWQuXG4gKiBFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyIGNvbXBhdGliaWxpdHk6IENocm9tZSwgT3BlcmEgNywgU2FmYXJpLCBGRjEuNSssIElFOStcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXJcbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmFkZEV2ZW50XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzJDEuYWRkRXZlbnQgPSBhZGRMaXN0ZW5lcjtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIgaW5zdGVhZC5cbiAqIEV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIgY29tcGF0aWJpbGl0eTogQ2hyb21lLCBPcGVyYSA3LCBTYWZhcmksIEZGMS41KywgSUU5K1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMucmVtb3ZlRXZlbnRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMkMS5yZW1vdmVFdmVudCA9IHJlbW92ZUxpc3RlbmVyO1xuXG4vLyBAVE9ETyBNYWtlIHBvc3NpYmxlIHRvIHNlbGVjdCBhbm90aGVyIHBsYXRmb3JtIGF0IGJ1aWxkIHRpbWUuXG52YXIgaW1wbGVtZW50YXRpb24gPSBwbGF0Zm9ybV9kb20kMi5fZW5hYmxlZCA/IHBsYXRmb3JtX2RvbSQyIDogcGxhdGZvcm1fYmFzaWM7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5wbGF0Zm9ybVxuICogQHNlZSBodHRwczovL2NoYXJ0anMuZ2l0Ym9va3MuaW8vcHJvcG9zYWxzL2NvbnRlbnQvUGxhdGZvcm0uaHRtbFxuICogQHNpbmNlIDIuNC4wXG4gKi9cbnZhciBwbGF0Zm9ybSA9IGhlbHBlcnMkMS5leHRlbmQoe1xuXHQvKipcblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHt9LFxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgY29uc3RydWN0aW9uIHRpbWUsIHJldHVybnMgYSBjb250ZXh0MmQgaW5zdGFuY2UgaW1wbGVtZW50aW5nXG5cdCAqIHRoZSBbVzNDIENhbnZhcyAyRCBDb250ZXh0IEFQSSBzdGFuZGFyZF17QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC99LlxuXHQgKiBAcGFyYW0geyp9IGl0ZW0gLSBUaGUgbmF0aXZlIGl0ZW0gZnJvbSB3aGljaCB0byBhY3F1aXJlIGNvbnRleHQgKHBsYXRmb3JtIHNwZWNpZmljKVxuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFRoZSBjaGFydCBvcHRpb25zXG5cdCAqIEByZXR1cm5zIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQyZCBpbnN0YW5jZVxuXHQgKi9cblx0YWNxdWlyZUNvbnRleHQ6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBkZXN0cnVjdGlvbiB0aW1lLCByZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFzc29jaWF0ZWQgdG8gdGhlIGNvbnRleHRcblx0ICogcHJldmlvdXNseSByZXR1cm5lZCBieSB0aGUgYWNxdWlyZUNvbnRleHQoKSBtZXRob2QuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IC0gVGhlIGNvbnRleHQyZCBpbnN0YW5jZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgbWV0aG9kIHN1Y2NlZWRlZCwgZWxzZSBmYWxzZVxuXHQgKi9cblx0cmVsZWFzZUNvbnRleHQ6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIG9uIHRoZSBnaXZlbiBjaGFydC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBDaGFydCBmcm9tIHdoaWNoIHRvIGxpc3RlbiBmb3IgZXZlbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBJRXZlbnR9KSB0eXBlIHRvIGxpc3RlbiBmb3Jcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBSZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiAoYW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50c1xuXHQgKiB0aGUge0BsaW5rIElFdmVudH0gaW50ZXJmYWNlKSB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnMuXG5cdCAqL1xuXHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBDaGFydCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBJRXZlbnR9KSB0eXBlIHRvIHJlbW92ZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQgdGFyZ2V0LlxuXHQgKi9cblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7fVxuXG59LCBpbXBsZW1lbnRhdGlvbik7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRwbHVnaW5zOiB7fVxufSk7XG5cbi8qKlxuICogVGhlIHBsdWdpbiBzZXJ2aWNlIHNpbmdsZXRvblxuICogQG5hbWVzcGFjZSBDaGFydC5wbHVnaW5zXG4gKiBAc2luY2UgMi4xLjBcbiAqL1xudmFyIGNvcmVfcGx1Z2lucyA9IHtcblx0LyoqXG5cdCAqIEdsb2JhbGx5IHJlZ2lzdGVyZWQgcGx1Z2lucy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9wbHVnaW5zOiBbXSxcblxuXHQvKipcblx0ICogVGhpcyBpZGVudGlmaWVyIGlzIHVzZWQgdG8gaW52YWxpZGF0ZSB0aGUgZGVzY3JpcHRvcnMgY2FjaGUgYXR0YWNoZWQgdG8gZWFjaCBjaGFydFxuXHQgKiB3aGVuIGEgZ2xvYmFsIHBsdWdpbiBpcyByZWdpc3RlcmVkIG9yIHVucmVnaXN0ZXJlZC4gSW4gdGhpcyBjYXNlLCB0aGUgY2FjaGUgSUQgaXNcblx0ICogaW5jcmVtZW50ZWQgYW5kIGRlc2NyaXB0b3JzIGFyZSByZWdlbmVyYXRlZCBkdXJpbmcgZm9sbG93aW5nIEFQSSBjYWxscy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jYWNoZUlkOiAwLFxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgdGhlIGdpdmVuIHBsdWdpbihzKSBpZiBub3QgYWxyZWFkeSByZWdpc3RlcmVkLlxuXHQgKiBAcGFyYW0ge0lQbHVnaW5bXXxJUGx1Z2lufSBwbHVnaW5zIHBsdWdpbiBpbnN0YW5jZShzKS5cblx0ICovXG5cdHJlZ2lzdGVyOiBmdW5jdGlvbihwbHVnaW5zKSB7XG5cdFx0dmFyIHAgPSB0aGlzLl9wbHVnaW5zO1xuXHRcdChbXSkuY29uY2F0KHBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHRpZiAocC5pbmRleE9mKHBsdWdpbikgPT09IC0xKSB7XG5cdFx0XHRcdHAucHVzaChwbHVnaW4pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fY2FjaGVJZCsrO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVbnJlZ2lzdGVycyB0aGUgZ2l2ZW4gcGx1Z2luKHMpIG9ubHkgaWYgcmVnaXN0ZXJlZC5cblx0ICogQHBhcmFtIHtJUGx1Z2luW118SVBsdWdpbn0gcGx1Z2lucyBwbHVnaW4gaW5zdGFuY2UocykuXG5cdCAqL1xuXHR1bnJlZ2lzdGVyOiBmdW5jdGlvbihwbHVnaW5zKSB7XG5cdFx0dmFyIHAgPSB0aGlzLl9wbHVnaW5zO1xuXHRcdChbXSkuY29uY2F0KHBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHR2YXIgaWR4ID0gcC5pbmRleE9mKHBsdWdpbik7XG5cdFx0XHRpZiAoaWR4ICE9PSAtMSkge1xuXHRcdFx0XHRwLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fY2FjaGVJZCsrO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIHJlZ2lzdGVyZWQgcGx1Z2lucy5cblx0ICogQHNpbmNlIDIuMS41XG5cdCAqL1xuXHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcGx1Z2lucyA9IFtdO1xuXHRcdHRoaXMuX2NhY2hlSWQrKztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJlZ2lzdGVyZWQgcGx1Z2lucz9cblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICogQHNpbmNlIDIuMS41XG5cdCAqL1xuXHRjb3VudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BsdWdpbnMubGVuZ3RoO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFsbCByZWdpc3RlcmVkIHBsdWdpbiBpbnN0YW5jZXMuXG5cdCAqIEByZXR1cm5zIHtJUGx1Z2luW119IGFycmF5IG9mIHBsdWdpbiBvYmplY3RzLlxuXHQgKiBAc2luY2UgMi4xLjVcblx0ICovXG5cdGdldEFsbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BsdWdpbnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhbGxzIGVuYWJsZWQgcGx1Z2lucyBmb3IgYGNoYXJ0YCBvbiB0aGUgc3BlY2lmaWVkIGhvb2sgYW5kIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG5cdCAqIFRoaXMgbWV0aG9kIGltbWVkaWF0ZWx5IHJldHVybnMgYXMgc29vbiBhcyBhIHBsdWdpbiBleHBsaWNpdGx5IHJldHVybnMgZmFsc2UuIFRoZVxuXHQgKiByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgdXNlZCwgZm9yIGluc3RhbmNlLCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgYWN0aW9uLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZSBmb3Igd2hpY2ggcGx1Z2lucyBzaG91bGQgYmUgY2FsbGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaG9vayAtIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gbWV0aG9kIHRvIGNhbGwgKGUuZy4gJ2JlZm9yZVVwZGF0ZScpLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbYXJnc10gLSBFeHRyYSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGhvb2sgY2FsbC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHQgKi9cblx0bm90aWZ5OiBmdW5jdGlvbihjaGFydCwgaG9vaywgYXJncykge1xuXHRcdHZhciBkZXNjcmlwdG9ycyA9IHRoaXMuZGVzY3JpcHRvcnMoY2hhcnQpO1xuXHRcdHZhciBpbGVuID0gZGVzY3JpcHRvcnMubGVuZ3RoO1xuXHRcdHZhciBpLCBkZXNjcmlwdG9yLCBwbHVnaW4sIHBhcmFtcywgbWV0aG9kO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0ZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JzW2ldO1xuXHRcdFx0cGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XG5cdFx0XHRtZXRob2QgPSBwbHVnaW5baG9va107XG5cdFx0XHRpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRwYXJhbXMgPSBbY2hhcnRdLmNvbmNhdChhcmdzIHx8IFtdKTtcblx0XHRcdFx0cGFyYW1zLnB1c2goZGVzY3JpcHRvci5vcHRpb25zKTtcblx0XHRcdFx0aWYgKG1ldGhvZC5hcHBseShwbHVnaW4sIHBhcmFtcykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgZGVzY3JpcHRvcnMgb2YgZW5hYmxlZCBwbHVnaW5zIGZvciB0aGUgZ2l2ZW4gY2hhcnQuXG5cdCAqIEByZXR1cm5zIHtvYmplY3RbXX0gW3sgcGx1Z2luLCBvcHRpb25zIH1dXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkZXNjcmlwdG9yczogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgY2FjaGUgPSBjaGFydC4kcGx1Z2lucyB8fCAoY2hhcnQuJHBsdWdpbnMgPSB7fSk7XG5cdFx0aWYgKGNhY2hlLmlkID09PSB0aGlzLl9jYWNoZUlkKSB7XG5cdFx0XHRyZXR1cm4gY2FjaGUuZGVzY3JpcHRvcnM7XG5cdFx0fVxuXG5cdFx0dmFyIHBsdWdpbnMgPSBbXTtcblx0XHR2YXIgZGVzY3JpcHRvcnMgPSBbXTtcblx0XHR2YXIgY29uZmlnID0gKGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZykgfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSAoY29uZmlnLm9wdGlvbnMgJiYgY29uZmlnLm9wdGlvbnMucGx1Z2lucykgfHwge307XG5cblx0XHR0aGlzLl9wbHVnaW5zLmNvbmNhdChjb25maWcucGx1Z2lucyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdHZhciBpZHggPSBwbHVnaW5zLmluZGV4T2YocGx1Z2luKTtcblx0XHRcdGlmIChpZHggIT09IC0xKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGlkID0gcGx1Z2luLmlkO1xuXHRcdFx0dmFyIG9wdHMgPSBvcHRpb25zW2lkXTtcblx0XHRcdGlmIChvcHRzID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRzID09PSB0cnVlKSB7XG5cdFx0XHRcdG9wdHMgPSBoZWxwZXJzJDEuY2xvbmUoY29yZV9kZWZhdWx0cy5nbG9iYWwucGx1Z2luc1tpZF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRwbHVnaW5zLnB1c2gocGx1Z2luKTtcblx0XHRcdGRlc2NyaXB0b3JzLnB1c2goe1xuXHRcdFx0XHRwbHVnaW46IHBsdWdpbixcblx0XHRcdFx0b3B0aW9uczogb3B0cyB8fCB7fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHRjYWNoZS5kZXNjcmlwdG9ycyA9IGRlc2NyaXB0b3JzO1xuXHRcdGNhY2hlLmlkID0gdGhpcy5fY2FjaGVJZDtcblx0XHRyZXR1cm4gZGVzY3JpcHRvcnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEludmFsaWRhdGVzIGNhY2hlIGZvciB0aGUgZ2l2ZW4gY2hhcnQ6IGRlc2NyaXB0b3JzIGhvbGQgYSByZWZlcmVuY2Ugb24gcGx1Z2luIG9wdGlvbixcblx0ICogYnV0IGluIHNvbWUgY2FzZXMsIHRoaXMgcmVmZXJlbmNlIGNhbiBiZSBjaGFuZ2VkIGJ5IHRoZSB1c2VyIHdoZW4gdXBkYXRpbmcgb3B0aW9ucy5cblx0ICogaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzUxMTEjaXNzdWVjb21tZW50LTM1NTkzNDE2N1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2ludmFsaWRhdGU6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0ZGVsZXRlIGNoYXJ0LiRwbHVnaW5zO1xuXHR9XG59O1xuXG52YXIgY29yZV9zY2FsZVNlcnZpY2UgPSB7XG5cdC8vIFNjYWxlIHJlZ2lzdHJhdGlvbiBvYmplY3QuIEV4dGVuc2lvbnMgY2FuIHJlZ2lzdGVyIG5ldyBzY2FsZSB0eXBlcyAoc3VjaCBhcyBsb2cgb3IgREIgc2NhbGVzKSBhbmQgdGhlblxuXHQvLyB1c2UgdGhlIG5ldyBjaGFydCBvcHRpb25zIHRvIGdyYWIgdGhlIGNvcnJlY3Qgc2NhbGVcblx0Y29uc3RydWN0b3JzOiB7fSxcblx0Ly8gVXNlIGEgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIHNvIHRoYXQgd2UgY2FuIG1vdmUgdG8gYW4gRVM2IG1hcCB3aGVuIHdlIG5vIGxvbmdlciBuZWVkIHRvIHN1cHBvcnRcblx0Ly8gb2xkIGJyb3dzZXJzXG5cblx0Ly8gU2NhbGUgY29uZmlnIGRlZmF1bHRzXG5cdGRlZmF1bHRzOiB7fSxcblx0cmVnaXN0ZXJTY2FsZVR5cGU6IGZ1bmN0aW9uKHR5cGUsIHNjYWxlQ29uc3RydWN0b3IsIHNjYWxlRGVmYXVsdHMpIHtcblx0XHR0aGlzLmNvbnN0cnVjdG9yc1t0eXBlXSA9IHNjYWxlQ29uc3RydWN0b3I7XG5cdFx0dGhpcy5kZWZhdWx0c1t0eXBlXSA9IGhlbHBlcnMkMS5jbG9uZShzY2FsZURlZmF1bHRzKTtcblx0fSxcblx0Z2V0U2NhbGVDb25zdHJ1Y3RvcjogZnVuY3Rpb24odHlwZSkge1xuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9ycy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSA/IHRoaXMuY29uc3RydWN0b3JzW3R5cGVdIDogdW5kZWZpbmVkO1xuXHR9LFxuXHRnZXRTY2FsZURlZmF1bHRzOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0Ly8gUmV0dXJuIHRoZSBzY2FsZSBkZWZhdWx0cyBtZXJnZWQgd2l0aCB0aGUgZ2xvYmFsIHNldHRpbmdzIHNvIHRoYXQgd2UgYWx3YXlzIHVzZSB0aGUgbGF0ZXN0IG9uZXNcblx0XHRyZXR1cm4gdGhpcy5kZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSA/IGhlbHBlcnMkMS5tZXJnZSh7fSwgW2NvcmVfZGVmYXVsdHMuc2NhbGUsIHRoaXMuZGVmYXVsdHNbdHlwZV1dKSA6IHt9O1xuXHR9LFxuXHR1cGRhdGVTY2FsZURlZmF1bHRzOiBmdW5jdGlvbih0eXBlLCBhZGRpdGlvbnMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGlmIChtZS5kZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuXHRcdFx0bWUuZGVmYXVsdHNbdHlwZV0gPSBoZWxwZXJzJDEuZXh0ZW5kKG1lLmRlZmF1bHRzW3R5cGVdLCBhZGRpdGlvbnMpO1xuXHRcdH1cblx0fSxcblx0YWRkU2NhbGVzVG9MYXlvdXQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0Ly8gQWRkcyBlYWNoIHNjYWxlIHRvIHRoZSBjaGFydC5ib3hlcyBhcnJheSB0byBiZSBzaXplZCBhY2NvcmRpbmdseVxuXHRcdGhlbHBlcnMkMS5lYWNoKGNoYXJ0LnNjYWxlcywgZnVuY3Rpb24oc2NhbGUpIHtcblx0XHRcdC8vIFNldCBJTGF5b3V0SXRlbSBwYXJhbWV0ZXJzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0c2NhbGUuZnVsbFdpZHRoID0gc2NhbGUub3B0aW9ucy5mdWxsV2lkdGg7XG5cdFx0XHRzY2FsZS5wb3NpdGlvbiA9IHNjYWxlLm9wdGlvbnMucG9zaXRpb247XG5cdFx0XHRzY2FsZS53ZWlnaHQgPSBzY2FsZS5vcHRpb25zLndlaWdodDtcblx0XHRcdGNvcmVfbGF5b3V0cy5hZGRCb3goY2hhcnQsIHNjYWxlKTtcblx0XHR9KTtcblx0fVxufTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDggPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG52YXIgZ2V0UnRsSGVscGVyID0gaGVscGVycyQxLnJ0bC5nZXRSdGxBZGFwdGVyO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0dG9vbHRpcHM6IHtcblx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdGN1c3RvbTogbnVsbCxcblx0XHRtb2RlOiAnbmVhcmVzdCcsXG5cdFx0cG9zaXRpb246ICdhdmVyYWdlJyxcblx0XHRpbnRlcnNlY3Q6IHRydWUsXG5cdFx0YmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcblx0XHR0aXRsZUZvbnRTdHlsZTogJ2JvbGQnLFxuXHRcdHRpdGxlU3BhY2luZzogMixcblx0XHR0aXRsZU1hcmdpbkJvdHRvbTogNixcblx0XHR0aXRsZUZvbnRDb2xvcjogJyNmZmYnLFxuXHRcdHRpdGxlQWxpZ246ICdsZWZ0Jyxcblx0XHRib2R5U3BhY2luZzogMixcblx0XHRib2R5Rm9udENvbG9yOiAnI2ZmZicsXG5cdFx0Ym9keUFsaWduOiAnbGVmdCcsXG5cdFx0Zm9vdGVyRm9udFN0eWxlOiAnYm9sZCcsXG5cdFx0Zm9vdGVyU3BhY2luZzogMixcblx0XHRmb290ZXJNYXJnaW5Ub3A6IDYsXG5cdFx0Zm9vdGVyRm9udENvbG9yOiAnI2ZmZicsXG5cdFx0Zm9vdGVyQWxpZ246ICdsZWZ0Jyxcblx0XHR5UGFkZGluZzogNixcblx0XHR4UGFkZGluZzogNixcblx0XHRjYXJldFBhZGRpbmc6IDIsXG5cdFx0Y2FyZXRTaXplOiA1LFxuXHRcdGNvcm5lclJhZGl1czogNixcblx0XHRtdWx0aUtleUJhY2tncm91bmQ6ICcjZmZmJyxcblx0XHRkaXNwbGF5Q29sb3JzOiB0cnVlLFxuXHRcdGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXG5cdFx0Ym9yZGVyV2lkdGg6IDAsXG5cdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcblx0XHRcdGJlZm9yZVRpdGxlOiBoZWxwZXJzJDEubm9vcCxcblx0XHRcdHRpdGxlOiBmdW5jdGlvbih0b29sdGlwSXRlbXMsIGRhdGEpIHtcblx0XHRcdFx0dmFyIHRpdGxlID0gJyc7XG5cdFx0XHRcdHZhciBsYWJlbHMgPSBkYXRhLmxhYmVscztcblx0XHRcdFx0dmFyIGxhYmVsQ291bnQgPSBsYWJlbHMgPyBsYWJlbHMubGVuZ3RoIDogMDtcblxuXHRcdFx0XHRpZiAodG9vbHRpcEl0ZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR2YXIgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcblx0XHRcdFx0XHRpZiAoaXRlbS5sYWJlbCkge1xuXHRcdFx0XHRcdFx0dGl0bGUgPSBpdGVtLmxhYmVsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaXRlbS54TGFiZWwpIHtcblx0XHRcdFx0XHRcdHRpdGxlID0gaXRlbS54TGFiZWw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmluZGV4IDwgbGFiZWxDb3VudCkge1xuXHRcdFx0XHRcdFx0dGl0bGUgPSBsYWJlbHNbaXRlbS5pbmRleF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRpdGxlO1xuXHRcdFx0fSxcblx0XHRcdGFmdGVyVGl0bGU6IGhlbHBlcnMkMS5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcblx0XHRcdGJlZm9yZUJvZHk6IGhlbHBlcnMkMS5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRcdFx0YmVmb3JlTGFiZWw6IGhlbHBlcnMkMS5ub29wLFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBsYWJlbCA9IGRhdGEuZGF0YXNldHNbdG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4XS5sYWJlbCB8fCAnJztcblxuXHRcdFx0XHRpZiAobGFiZWwpIHtcblx0XHRcdFx0XHRsYWJlbCArPSAnOiAnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodG9vbHRpcEl0ZW0udmFsdWUpKSB7XG5cdFx0XHRcdFx0bGFiZWwgKz0gdG9vbHRpcEl0ZW0udmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGFiZWwgKz0gdG9vbHRpcEl0ZW0ueUxhYmVsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBsYWJlbDtcblx0XHRcdH0sXG5cdFx0XHRsYWJlbENvbG9yOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgY2hhcnQpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHR2YXIgYWN0aXZlRWxlbWVudCA9IG1ldGEuZGF0YVt0b29sdGlwSXRlbS5pbmRleF07XG5cdFx0XHRcdHZhciB2aWV3ID0gYWN0aXZlRWxlbWVudC5fdmlldztcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRib3JkZXJDb2xvcjogdmlldy5ib3JkZXJDb2xvcixcblx0XHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IHZpZXcuYmFja2dyb3VuZENvbG9yXG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWxUZXh0Q29sb3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fb3B0aW9ucy5ib2R5Rm9udENvbG9yO1xuXHRcdFx0fSxcblx0XHRcdGFmdGVyTGFiZWw6IGhlbHBlcnMkMS5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcblx0XHRcdGFmdGVyQm9keTogaGVscGVycyQxLm5vb3AsXG5cblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuXHRcdFx0YmVmb3JlRm9vdGVyOiBoZWxwZXJzJDEubm9vcCxcblx0XHRcdGZvb3RlcjogaGVscGVycyQxLm5vb3AsXG5cdFx0XHRhZnRlckZvb3RlcjogaGVscGVycyQxLm5vb3Bcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgcG9zaXRpb25lcnMgPSB7XG5cdC8qKlxuXHQgKiBBdmVyYWdlIG1vZGUgcGxhY2VzIHRoZSB0b29sdGlwIGF0IHRoZSBhdmVyYWdlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50cyBzaG93blxuXHQgKiBAZnVuY3Rpb24gQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVycy5hdmVyYWdlXG5cdCAqIEBwYXJhbSBlbGVtZW50cyB7Q2hhcnRFbGVtZW50W119IHRoZSBlbGVtZW50cyBiZWluZyBkaXNwbGF5ZWQgaW4gdGhlIHRvb2x0aXBcblx0ICogQHJldHVybnMge29iamVjdH0gdG9vbHRpcCBwb3NpdGlvblxuXHQgKi9cblx0YXZlcmFnZTogZnVuY3Rpb24oZWxlbWVudHMpIHtcblx0XHRpZiAoIWVsZW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBpLCBsZW47XG5cdFx0dmFyIHggPSAwO1xuXHRcdHZhciB5ID0gMDtcblx0XHR2YXIgY291bnQgPSAwO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0XHRcdHZhciBlbCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0aWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcblx0XHRcdFx0dmFyIHBvcyA9IGVsLnRvb2x0aXBQb3NpdGlvbigpO1xuXHRcdFx0XHR4ICs9IHBvcy54O1xuXHRcdFx0XHR5ICs9IHBvcy55O1xuXHRcdFx0XHQrK2NvdW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB4IC8gY291bnQsXG5cdFx0XHR5OiB5IC8gY291bnRcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB0b29sdGlwIHBvc2l0aW9uIG5lYXJlc3Qgb2YgdGhlIGl0ZW0gbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb25cblx0ICogQGZ1bmN0aW9uIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnMubmVhcmVzdFxuXHQgKiBAcGFyYW0gZWxlbWVudHMge0NoYXJ0LkVsZW1lbnRbXX0gdGhlIHRvb2x0aXAgZWxlbWVudHNcblx0ICogQHBhcmFtIGV2ZW50UG9zaXRpb24ge29iamVjdH0gdGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCBpbiBjYW52YXMgY29vcmRpbmF0ZXNcblx0ICogQHJldHVybnMge29iamVjdH0gdGhlIHRvb2x0aXAgcG9zaXRpb25cblx0ICovXG5cdG5lYXJlc3Q6IGZ1bmN0aW9uKGVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG5cdFx0dmFyIHggPSBldmVudFBvc2l0aW9uLng7XG5cdFx0dmFyIHkgPSBldmVudFBvc2l0aW9uLnk7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHRcdHZhciBpLCBsZW4sIG5lYXJlc3RFbGVtZW50O1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0XHRcdHZhciBlbCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0aWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcblx0XHRcdFx0dmFyIGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XG5cdFx0XHRcdHZhciBkID0gaGVscGVycyQxLmRpc3RhbmNlQmV0d2VlblBvaW50cyhldmVudFBvc2l0aW9uLCBjZW50ZXIpO1xuXG5cdFx0XHRcdGlmIChkIDwgbWluRGlzdGFuY2UpIHtcblx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IGQ7XG5cdFx0XHRcdFx0bmVhcmVzdEVsZW1lbnQgPSBlbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChuZWFyZXN0RWxlbWVudCkge1xuXHRcdFx0dmFyIHRwID0gbmVhcmVzdEVsZW1lbnQudG9vbHRpcFBvc2l0aW9uKCk7XG5cdFx0XHR4ID0gdHAueDtcblx0XHRcdHkgPSB0cC55O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB4LFxuXHRcdFx0eTogeVxuXHRcdH07XG5cdH1cbn07XG5cbi8vIEhlbHBlciB0byBwdXNoIG9yIGNvbmNhdCBiYXNlZCBvbiBpZiB0aGUgMm5kIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvciBub3RcbmZ1bmN0aW9uIHB1c2hPckNvbmNhdChiYXNlLCB0b1B1c2gpIHtcblx0aWYgKHRvUHVzaCkge1xuXHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0b1B1c2gpKSB7XG5cdFx0XHQvLyBiYXNlID0gYmFzZS5jb25jYXQodG9QdXNoKTtcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJhc2UsIHRvUHVzaCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGJhc2UucHVzaCh0b1B1c2gpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBiYXNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYXJyYXkgb2Ygc3RyaW5ncyBzcGxpdCBieSBuZXdsaW5lXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3BsaXQgYnkgbmV3bGluZS5cbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gdmFsdWUgaWYgbmV3bGluZSBwcmVzZW50IC0gUmV0dXJuZWQgZnJvbSBTdHJpbmcgc3BsaXQoKSBtZXRob2RcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBzcGxpdE5ld2xpbmVzKHN0cikge1xuXHRpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcblx0XHRyZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcblx0fVxuXHRyZXR1cm4gc3RyO1xufVxuXG5cbi8qKlxuICogUHJpdmF0ZSBoZWxwZXIgdG8gY3JlYXRlIGEgdG9vbHRpcCBpdGVtIG1vZGVsXG4gKiBAcGFyYW0gZWxlbWVudCAtIHRoZSBjaGFydCBlbGVtZW50IChwb2ludCwgYXJjLCBiYXIpIHRvIGNyZWF0ZSB0aGUgdG9vbHRpcCBpdGVtIGZvclxuICogQHJldHVybiBuZXcgdG9vbHRpcCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGVsZW1lbnQpIHtcblx0dmFyIHhTY2FsZSA9IGVsZW1lbnQuX3hTY2FsZTtcblx0dmFyIHlTY2FsZSA9IGVsZW1lbnQuX3lTY2FsZSB8fCBlbGVtZW50Ll9zY2FsZTsgLy8gaGFuZGxlIHJhZGFyIHx8IHBvbGFyQXJlYSBjaGFydHNcblx0dmFyIGluZGV4ID0gZWxlbWVudC5faW5kZXg7XG5cdHZhciBkYXRhc2V0SW5kZXggPSBlbGVtZW50Ll9kYXRhc2V0SW5kZXg7XG5cdHZhciBjb250cm9sbGVyID0gZWxlbWVudC5fY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuXHR2YXIgaW5kZXhTY2FsZSA9IGNvbnRyb2xsZXIuX2dldEluZGV4U2NhbGUoKTtcblx0dmFyIHZhbHVlU2NhbGUgPSBjb250cm9sbGVyLl9nZXRWYWx1ZVNjYWxlKCk7XG5cblx0cmV0dXJuIHtcblx0XHR4TGFiZWw6IHhTY2FsZSA/IHhTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXG5cdFx0eUxhYmVsOiB5U2NhbGUgPyB5U2NhbGUuZ2V0TGFiZWxGb3JJbmRleChpbmRleCwgZGF0YXNldEluZGV4KSA6ICcnLFxuXHRcdGxhYmVsOiBpbmRleFNjYWxlID8gJycgKyBpbmRleFNjYWxlLmdldExhYmVsRm9ySW5kZXgoaW5kZXgsIGRhdGFzZXRJbmRleCkgOiAnJyxcblx0XHR2YWx1ZTogdmFsdWVTY2FsZSA/ICcnICsgdmFsdWVTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXG5cdFx0aW5kZXg6IGluZGV4LFxuXHRcdGRhdGFzZXRJbmRleDogZGF0YXNldEluZGV4LFxuXHRcdHg6IGVsZW1lbnQuX21vZGVsLngsXG5cdFx0eTogZWxlbWVudC5fbW9kZWwueVxuXHR9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgdGhlIHJlc2V0IG1vZGVsIGZvciB0aGUgdG9vbHRpcFxuICogQHBhcmFtIHRvb2x0aXBPcHRzIHtvYmplY3R9IHRoZSB0b29sdGlwIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZ2V0QmFzZU1vZGVsKHRvb2x0aXBPcHRzKSB7XG5cdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXG5cdHJldHVybiB7XG5cdFx0Ly8gUG9zaXRpb25pbmdcblx0XHR4UGFkZGluZzogdG9vbHRpcE9wdHMueFBhZGRpbmcsXG5cdFx0eVBhZGRpbmc6IHRvb2x0aXBPcHRzLnlQYWRkaW5nLFxuXHRcdHhBbGlnbjogdG9vbHRpcE9wdHMueEFsaWduLFxuXHRcdHlBbGlnbjogdG9vbHRpcE9wdHMueUFsaWduLFxuXG5cdFx0Ly8gRHJhd2luZyBkaXJlY3Rpb24gYW5kIHRleHQgZGlyZWN0aW9uXG5cdFx0cnRsOiB0b29sdGlwT3B0cy5ydGwsXG5cdFx0dGV4dERpcmVjdGlvbjogdG9vbHRpcE9wdHMudGV4dERpcmVjdGlvbixcblxuXHRcdC8vIEJvZHlcblx0XHRib2R5Rm9udENvbG9yOiB0b29sdGlwT3B0cy5ib2R5Rm9udENvbG9yLFxuXHRcdF9ib2R5Rm9udEZhbWlseTogdmFsdWVPckRlZmF1bHQkOCh0b29sdGlwT3B0cy5ib2R5Rm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdF9ib2R5Rm9udFN0eWxlOiB2YWx1ZU9yRGVmYXVsdCQ4KHRvb2x0aXBPcHRzLmJvZHlGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdF9ib2R5QWxpZ246IHRvb2x0aXBPcHRzLmJvZHlBbGlnbixcblx0XHRib2R5Rm9udFNpemU6IHZhbHVlT3JEZWZhdWx0JDgodG9vbHRpcE9wdHMuYm9keUZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpLFxuXHRcdGJvZHlTcGFjaW5nOiB0b29sdGlwT3B0cy5ib2R5U3BhY2luZyxcblxuXHRcdC8vIFRpdGxlXG5cdFx0dGl0bGVGb250Q29sb3I6IHRvb2x0aXBPcHRzLnRpdGxlRm9udENvbG9yLFxuXHRcdF90aXRsZUZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDgodG9vbHRpcE9wdHMudGl0bGVGb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXG5cdFx0X3RpdGxlRm9udFN0eWxlOiB2YWx1ZU9yRGVmYXVsdCQ4KHRvb2x0aXBPcHRzLnRpdGxlRm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHR0aXRsZUZvbnRTaXplOiB2YWx1ZU9yRGVmYXVsdCQ4KHRvb2x0aXBPcHRzLnRpdGxlRm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXG5cdFx0X3RpdGxlQWxpZ246IHRvb2x0aXBPcHRzLnRpdGxlQWxpZ24sXG5cdFx0dGl0bGVTcGFjaW5nOiB0b29sdGlwT3B0cy50aXRsZVNwYWNpbmcsXG5cdFx0dGl0bGVNYXJnaW5Cb3R0b206IHRvb2x0aXBPcHRzLnRpdGxlTWFyZ2luQm90dG9tLFxuXG5cdFx0Ly8gRm9vdGVyXG5cdFx0Zm9vdGVyRm9udENvbG9yOiB0b29sdGlwT3B0cy5mb290ZXJGb250Q29sb3IsXG5cdFx0X2Zvb3RlckZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDgodG9vbHRpcE9wdHMuZm9vdGVyRm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdF9mb290ZXJGb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0JDgodG9vbHRpcE9wdHMuZm9vdGVyRm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHRmb290ZXJGb250U2l6ZTogdmFsdWVPckRlZmF1bHQkOCh0b29sdGlwT3B0cy5mb290ZXJGb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKSxcblx0XHRfZm9vdGVyQWxpZ246IHRvb2x0aXBPcHRzLmZvb3RlckFsaWduLFxuXHRcdGZvb3RlclNwYWNpbmc6IHRvb2x0aXBPcHRzLmZvb3RlclNwYWNpbmcsXG5cdFx0Zm9vdGVyTWFyZ2luVG9wOiB0b29sdGlwT3B0cy5mb290ZXJNYXJnaW5Ub3AsXG5cblx0XHQvLyBBcHBlYXJhbmNlXG5cdFx0Y2FyZXRTaXplOiB0b29sdGlwT3B0cy5jYXJldFNpemUsXG5cdFx0Y29ybmVyUmFkaXVzOiB0b29sdGlwT3B0cy5jb3JuZXJSYWRpdXMsXG5cdFx0YmFja2dyb3VuZENvbG9yOiB0b29sdGlwT3B0cy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0b3BhY2l0eTogMCxcblx0XHRsZWdlbmRDb2xvckJhY2tncm91bmQ6IHRvb2x0aXBPcHRzLm11bHRpS2V5QmFja2dyb3VuZCxcblx0XHRkaXNwbGF5Q29sb3JzOiB0b29sdGlwT3B0cy5kaXNwbGF5Q29sb3JzLFxuXHRcdGJvcmRlckNvbG9yOiB0b29sdGlwT3B0cy5ib3JkZXJDb2xvcixcblx0XHRib3JkZXJXaWR0aDogdG9vbHRpcE9wdHMuYm9yZGVyV2lkdGhcblx0fTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHRvb2x0aXBcbiAqL1xuZnVuY3Rpb24gZ2V0VG9vbHRpcFNpemUodG9vbHRpcCwgbW9kZWwpIHtcblx0dmFyIGN0eCA9IHRvb2x0aXAuX2NoYXJ0LmN0eDtcblxuXHR2YXIgaGVpZ2h0ID0gbW9kZWwueVBhZGRpbmcgKiAyOyAvLyBUb29sdGlwIFBhZGRpbmdcblx0dmFyIHdpZHRoID0gMDtcblxuXHQvLyBDb3VudCBvZiBhbGwgbGluZXMgaW4gdGhlIGJvZHlcblx0dmFyIGJvZHkgPSBtb2RlbC5ib2R5O1xuXHR2YXIgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoZnVuY3Rpb24oY291bnQsIGJvZHlJdGVtKSB7XG5cdFx0cmV0dXJuIGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aDtcblx0fSwgMCk7XG5cdGNvbWJpbmVkQm9keUxlbmd0aCArPSBtb2RlbC5iZWZvcmVCb2R5Lmxlbmd0aCArIG1vZGVsLmFmdGVyQm9keS5sZW5ndGg7XG5cblx0dmFyIHRpdGxlTGluZUNvdW50ID0gbW9kZWwudGl0bGUubGVuZ3RoO1xuXHR2YXIgZm9vdGVyTGluZUNvdW50ID0gbW9kZWwuZm9vdGVyLmxlbmd0aDtcblx0dmFyIHRpdGxlRm9udFNpemUgPSBtb2RlbC50aXRsZUZvbnRTaXplO1xuXHR2YXIgYm9keUZvbnRTaXplID0gbW9kZWwuYm9keUZvbnRTaXplO1xuXHR2YXIgZm9vdGVyRm9udFNpemUgPSBtb2RlbC5mb290ZXJGb250U2l6ZTtcblxuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgKiB0aXRsZUZvbnRTaXplOyAvLyBUaXRsZSBMaW5lc1xuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgPyAodGl0bGVMaW5lQ291bnQgLSAxKSAqIG1vZGVsLnRpdGxlU3BhY2luZyA6IDA7IC8vIFRpdGxlIExpbmUgU3BhY2luZ1xuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgPyBtb2RlbC50aXRsZU1hcmdpbkJvdHRvbSA6IDA7IC8vIFRpdGxlJ3MgYm90dG9tIE1hcmdpblxuXHRoZWlnaHQgKz0gY29tYmluZWRCb2R5TGVuZ3RoICogYm9keUZvbnRTaXplOyAvLyBCb2R5IExpbmVzXG5cdGhlaWdodCArPSBjb21iaW5lZEJvZHlMZW5ndGggPyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBtb2RlbC5ib2R5U3BhY2luZyA6IDA7IC8vIEJvZHkgTGluZSBTcGFjaW5nXG5cdGhlaWdodCArPSBmb290ZXJMaW5lQ291bnQgPyBtb2RlbC5mb290ZXJNYXJnaW5Ub3AgOiAwOyAvLyBGb290ZXIgTWFyZ2luXG5cdGhlaWdodCArPSBmb290ZXJMaW5lQ291bnQgKiAoZm9vdGVyRm9udFNpemUpOyAvLyBGb290ZXIgTGluZXNcblx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCA/IChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG1vZGVsLmZvb3RlclNwYWNpbmcgOiAwOyAvLyBGb290ZXIgTGluZSBTcGFjaW5nXG5cblx0Ly8gVGl0bGUgd2lkdGhcblx0dmFyIHdpZHRoUGFkZGluZyA9IDA7XG5cdHZhciBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcblx0fTtcblxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKHRpdGxlRm9udFNpemUsIG1vZGVsLl90aXRsZUZvbnRTdHlsZSwgbW9kZWwuX3RpdGxlRm9udEZhbWlseSk7XG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuXG5cdC8vIEJvZHkgd2lkdGhcblx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyhib2R5Rm9udFNpemUsIG1vZGVsLl9ib2R5Rm9udFN0eWxlLCBtb2RlbC5fYm9keUZvbnRGYW1pbHkpO1xuXHRoZWxwZXJzJDEuZWFjaChtb2RlbC5iZWZvcmVCb2R5LmNvbmNhdChtb2RlbC5hZnRlckJvZHkpLCBtYXhMaW5lV2lkdGgpO1xuXG5cdC8vIEJvZHkgbGluZXMgbWF5IGluY2x1ZGUgc29tZSBleHRyYSB3aWR0aCBkdWUgdG8gdGhlIGNvbG9yIGJveFxuXHR3aWR0aFBhZGRpbmcgPSBtb2RlbC5kaXNwbGF5Q29sb3JzID8gKGJvZHlGb250U2l6ZSArIDIpIDogMDtcblx0aGVscGVycyQxLmVhY2goYm9keSwgZnVuY3Rpb24oYm9keUl0ZW0pIHtcblx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XG5cdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG5cdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG5cdH0pO1xuXG5cdC8vIFJlc2V0IGJhY2sgdG8gMFxuXHR3aWR0aFBhZGRpbmcgPSAwO1xuXG5cdC8vIEZvb3RlciB3aWR0aFxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGZvb3RlckZvbnRTaXplLCBtb2RlbC5fZm9vdGVyRm9udFN0eWxlLCBtb2RlbC5fZm9vdGVyRm9udEZhbWlseSk7XG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLmZvb3RlciwgbWF4TGluZVdpZHRoKTtcblxuXHQvLyBBZGQgcGFkZGluZ1xuXHR3aWR0aCArPSAyICogbW9kZWwueFBhZGRpbmc7XG5cblx0cmV0dXJuIHtcblx0XHR3aWR0aDogd2lkdGgsXG5cdFx0aGVpZ2h0OiBoZWlnaHRcblx0fTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBhbGlnbm1lbnQgb2YgYSB0b29sdGlwIGdpdmVuIHRoZSBzaXplXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudCh0b29sdGlwLCBzaXplKSB7XG5cdHZhciBtb2RlbCA9IHRvb2x0aXAuX21vZGVsO1xuXHR2YXIgY2hhcnQgPSB0b29sdGlwLl9jaGFydDtcblx0dmFyIGNoYXJ0QXJlYSA9IHRvb2x0aXAuX2NoYXJ0LmNoYXJ0QXJlYTtcblx0dmFyIHhBbGlnbiA9ICdjZW50ZXInO1xuXHR2YXIgeUFsaWduID0gJ2NlbnRlcic7XG5cblx0aWYgKG1vZGVsLnkgPCBzaXplLmhlaWdodCkge1xuXHRcdHlBbGlnbiA9ICd0b3AnO1xuXHR9IGVsc2UgaWYgKG1vZGVsLnkgPiAoY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpKSB7XG5cdFx0eUFsaWduID0gJ2JvdHRvbSc7XG5cdH1cblxuXHR2YXIgbGYsIHJmOyAvLyBmdW5jdGlvbnMgdG8gZGV0ZXJtaW5lIGxlZnQsIHJpZ2h0IGFsaWdubWVudFxuXHR2YXIgb2xmLCBvcmY7IC8vIGZ1bmN0aW9ucyB0byBkZXRlcm1pbmUgaWYgbGVmdC9yaWdodCBhbGlnbm1lbnQgY2F1c2VzIHRvb2x0aXAgdG8gZ28gb3V0c2lkZSBjaGFydFxuXHR2YXIgeWY7IC8vIGZ1bmN0aW9uIHRvIGdldCB0aGUgeSBhbGlnbm1lbnQgaWYgdGhlIHRvb2x0aXAgZ29lcyBvdXRzaWRlIG9mIHRoZSBsZWZ0IG9yIHJpZ2h0IGVkZ2VzXG5cdHZhciBtaWRYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG5cdHZhciBtaWRZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG5cblx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRsZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiB4IDw9IG1pZFg7XG5cdFx0fTtcblx0XHRyZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiB4ID4gbWlkWDtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGxmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggPD0gKHNpemUud2lkdGggLyAyKTtcblx0XHR9O1xuXHRcdHJmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggPj0gKGNoYXJ0LndpZHRoIC0gKHNpemUud2lkdGggLyAyKSk7XG5cdFx0fTtcblx0fVxuXG5cdG9sZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRyZXR1cm4geCArIHNpemUud2lkdGggKyBtb2RlbC5jYXJldFNpemUgKyBtb2RlbC5jYXJldFBhZGRpbmcgPiBjaGFydC53aWR0aDtcblx0fTtcblx0b3JmID0gZnVuY3Rpb24oeCkge1xuXHRcdHJldHVybiB4IC0gc2l6ZS53aWR0aCAtIG1vZGVsLmNhcmV0U2l6ZSAtIG1vZGVsLmNhcmV0UGFkZGluZyA8IDA7XG5cdH07XG5cdHlmID0gZnVuY3Rpb24oeSkge1xuXHRcdHJldHVybiB5IDw9IG1pZFkgPyAndG9wJyA6ICdib3R0b20nO1xuXHR9O1xuXG5cdGlmIChsZihtb2RlbC54KSkge1xuXHRcdHhBbGlnbiA9ICdsZWZ0JztcblxuXHRcdC8vIElzIHRvb2x0aXAgdG9vIHdpZGUgYW5kIGdvZXMgb3ZlciB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgY2hhcnQuP1xuXHRcdGlmIChvbGYobW9kZWwueCkpIHtcblx0XHRcdHhBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0eUFsaWduID0geWYobW9kZWwueSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHJmKG1vZGVsLngpKSB7XG5cdFx0eEFsaWduID0gJ3JpZ2h0JztcblxuXHRcdC8vIElzIHRvb2x0aXAgdG9vIHdpZGUgYW5kIGdvZXMgb3V0c2lkZSBsZWZ0IGVkZ2Ugb2YgY2FudmFzP1xuXHRcdGlmIChvcmYobW9kZWwueCkpIHtcblx0XHRcdHhBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0eUFsaWduID0geWYobW9kZWwueSk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIG9wdHMgPSB0b29sdGlwLl9vcHRpb25zO1xuXHRyZXR1cm4ge1xuXHRcdHhBbGlnbjogb3B0cy54QWxpZ24gPyBvcHRzLnhBbGlnbiA6IHhBbGlnbixcblx0XHR5QWxpZ246IG9wdHMueUFsaWduID8gb3B0cy55QWxpZ24gOiB5QWxpZ25cblx0fTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBsb2NhdGlvbiBhIHRvb2x0aXAgbmVlZHMgdG8gYmUgcGxhY2VkIGF0IGdpdmVuIHRoZSBpbml0aWFsIHBvc2l0aW9uICh2aWEgdGhlIHZtKSBhbmQgdGhlIHNpemUgYW5kIGFsaWdubWVudFxuICovXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQodm0sIHNpemUsIGFsaWdubWVudCwgY2hhcnQpIHtcblx0Ly8gQmFja2dyb3VuZCBQb3NpdGlvblxuXHR2YXIgeCA9IHZtLng7XG5cdHZhciB5ID0gdm0ueTtcblxuXHR2YXIgY2FyZXRTaXplID0gdm0uY2FyZXRTaXplO1xuXHR2YXIgY2FyZXRQYWRkaW5nID0gdm0uY2FyZXRQYWRkaW5nO1xuXHR2YXIgY29ybmVyUmFkaXVzID0gdm0uY29ybmVyUmFkaXVzO1xuXHR2YXIgeEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcblx0dmFyIHlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cdHZhciBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcblx0dmFyIHJhZGl1c0FuZFBhZGRpbmcgPSBjb3JuZXJSYWRpdXMgKyBjYXJldFBhZGRpbmc7XG5cblx0aWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdHggLT0gc2l6ZS53aWR0aDtcblx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0eCAtPSAoc2l6ZS53aWR0aCAvIDIpO1xuXHRcdGlmICh4ICsgc2l6ZS53aWR0aCA+IGNoYXJ0LndpZHRoKSB7XG5cdFx0XHR4ID0gY2hhcnQud2lkdGggLSBzaXplLndpZHRoO1xuXHRcdH1cblx0XHRpZiAoeCA8IDApIHtcblx0XHRcdHggPSAwO1xuXHRcdH1cblx0fVxuXG5cdGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG5cdFx0eSArPSBwYWRkaW5nQW5kU2l6ZTtcblx0fSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG5cdFx0eSAtPSBzaXplLmhlaWdodCArIHBhZGRpbmdBbmRTaXplO1xuXHR9IGVsc2Uge1xuXHRcdHkgLT0gKHNpemUuaGVpZ2h0IC8gMik7XG5cdH1cblxuXHRpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuXHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0eCArPSBwYWRkaW5nQW5kU2l6ZTtcblx0XHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0eCAtPSBwYWRkaW5nQW5kU2l6ZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHR4IC09IHJhZGl1c0FuZFBhZGRpbmc7XG5cdH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0eCArPSByYWRpdXNBbmRQYWRkaW5nO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHR4OiB4LFxuXHRcdHk6IHlcblx0fTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodm0sIGFsaWduKSB7XG5cdHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcblx0XHQ/IHZtLnggKyB2bS53aWR0aCAvIDJcblx0XHQ6IGFsaWduID09PSAncmlnaHQnXG5cdFx0XHQ/IHZtLnggKyB2bS53aWR0aCAtIHZtLnhQYWRkaW5nXG5cdFx0XHQ6IHZtLnggKyB2bS54UGFkZGluZztcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gYnVpbGQgYmVmb3JlIGFuZCBhZnRlciBib2R5IGxpbmVzXG4gKi9cbmZ1bmN0aW9uIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKGNhbGxiYWNrKSB7XG5cdHJldHVybiBwdXNoT3JDb25jYXQoW10sIHNwbGl0TmV3bGluZXMoY2FsbGJhY2spKTtcbn1cblxudmFyIGV4cG9ydHMkNCA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9tb2RlbCA9IGdldEJhc2VNb2RlbCh0aGlzLl9vcHRpb25zKTtcblx0XHR0aGlzLl9sYXN0QWN0aXZlID0gW107XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSB0aXRsZVxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRnZXRUaXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLl9vcHRpb25zO1xuXHRcdHZhciBjYWxsYmFja3MgPSBvcHRzLmNhbGxiYWNrcztcblxuXHRcdHZhciBiZWZvcmVUaXRsZSA9IGNhbGxiYWNrcy5iZWZvcmVUaXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHR2YXIgdGl0bGUgPSBjYWxsYmFja3MudGl0bGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIGFmdGVyVGl0bGUgPSBjYWxsYmFja3MuYWZ0ZXJUaXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblxuXHRcdHZhciBsaW5lcyA9IFtdO1xuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG5cblx0XHRyZXR1cm4gbGluZXM7XG5cdH0sXG5cblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0QmVmb3JlQm9keTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLmJlZm9yZUJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0Qm9keTogZnVuY3Rpb24odG9vbHRpcEl0ZW1zLCBkYXRhKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2FsbGJhY2tzID0gbWUuX29wdGlvbnMuY2FsbGJhY2tzO1xuXHRcdHZhciBib2R5SXRlbXMgPSBbXTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKHRvb2x0aXBJdGVtcywgZnVuY3Rpb24odG9vbHRpcEl0ZW0pIHtcblx0XHRcdHZhciBib2R5SXRlbSA9IHtcblx0XHRcdFx0YmVmb3JlOiBbXSxcblx0XHRcdFx0bGluZXM6IFtdLFxuXHRcdFx0XHRhZnRlcjogW11cblx0XHRcdH07XG5cdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrcy5iZWZvcmVMYWJlbC5jYWxsKG1lLCB0b29sdGlwSXRlbSwgZGF0YSkpKTtcblx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgY2FsbGJhY2tzLmxhYmVsLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBkYXRhKSk7XG5cdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoY2FsbGJhY2tzLmFmdGVyTGFiZWwuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIGRhdGEpKSk7XG5cblx0XHRcdGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBib2R5SXRlbXM7XG5cdH0sXG5cblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0QWZ0ZXJCb2R5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXModGhpcy5fb3B0aW9ucy5jYWxsYmFja3MuYWZ0ZXJCb2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgZm9vdGVyIGFuZCBiZWZvcmVGb290ZXIgYW5kIGFmdGVyRm9vdGVyIGxpbmVzXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdGdldEZvb3RlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2FsbGJhY2tzID0gbWUuX29wdGlvbnMuY2FsbGJhY2tzO1xuXG5cdFx0dmFyIGJlZm9yZUZvb3RlciA9IGNhbGxiYWNrcy5iZWZvcmVGb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIGZvb3RlciA9IGNhbGxiYWNrcy5mb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIGFmdGVyRm9vdGVyID0gY2FsbGJhY2tzLmFmdGVyRm9vdGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXG5cdFx0dmFyIGxpbmVzID0gW107XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcblxuXHRcdHJldHVybiBsaW5lcztcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKGNoYW5nZWQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUuX29wdGlvbnM7XG5cblx0XHQvLyBOZWVkIHRvIHJlZ2VuZXJhdGUgdGhlIG1vZGVsIGJlY2F1c2UgaXRzIGZhc3RlciB0aGFuIHVzaW5nIGV4dGVuZCBhbmQgaXQgaXMgbmVjZXNzYXJ5IGR1ZSB0byB0aGUgb3B0aW1pemF0aW9uIGluIENoYXJ0LkVsZW1lbnQudHJhbnNpdGlvblxuXHRcdC8vIHRoYXQgZG9lcyBfdmlldyA9IF9tb2RlbCBpZiBlYXNlID09PSAxLiBUaGlzIGNhdXNlcyB0aGUgMm5kIHRvb2x0aXAgdXBkYXRlIHRvIHNldCBwcm9wZXJ0aWVzIGluIGJvdGggdGhlIHZpZXcgYW5kIG1vZGVsIGF0IHRoZSBzYW1lIHRpbWVcblx0XHQvLyB3aGljaCBicmVha3MgYW55IGFuaW1hdGlvbnMuXG5cdFx0dmFyIGV4aXN0aW5nTW9kZWwgPSBtZS5fbW9kZWw7XG5cdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsID0gZ2V0QmFzZU1vZGVsKG9wdHMpO1xuXHRcdHZhciBhY3RpdmUgPSBtZS5fYWN0aXZlO1xuXG5cdFx0dmFyIGRhdGEgPSBtZS5fZGF0YTtcblxuXHRcdC8vIEluIHRoZSBjYXNlIHdoZXJlIGFjdGl2ZS5sZW5ndGggPT09IDAgd2UgbmVlZCB0byBrZWVwIHRoZXNlIGF0IGV4aXN0aW5nIHZhbHVlcyBmb3IgZ29vZCBhbmltYXRpb25zXG5cdFx0dmFyIGFsaWdubWVudCA9IHtcblx0XHRcdHhBbGlnbjogZXhpc3RpbmdNb2RlbC54QWxpZ24sXG5cdFx0XHR5QWxpZ246IGV4aXN0aW5nTW9kZWwueUFsaWduXG5cdFx0fTtcblx0XHR2YXIgYmFja2dyb3VuZFBvaW50ID0ge1xuXHRcdFx0eDogZXhpc3RpbmdNb2RlbC54LFxuXHRcdFx0eTogZXhpc3RpbmdNb2RlbC55XG5cdFx0fTtcblx0XHR2YXIgdG9vbHRpcFNpemUgPSB7XG5cdFx0XHR3aWR0aDogZXhpc3RpbmdNb2RlbC53aWR0aCxcblx0XHRcdGhlaWdodDogZXhpc3RpbmdNb2RlbC5oZWlnaHRcblx0XHR9O1xuXHRcdHZhciB0b29sdGlwUG9zaXRpb24gPSB7XG5cdFx0XHR4OiBleGlzdGluZ01vZGVsLmNhcmV0WCxcblx0XHRcdHk6IGV4aXN0aW5nTW9kZWwuY2FyZXRZXG5cdFx0fTtcblxuXHRcdHZhciBpLCBsZW47XG5cblx0XHRpZiAoYWN0aXZlLmxlbmd0aCkge1xuXHRcdFx0bW9kZWwub3BhY2l0eSA9IDE7XG5cblx0XHRcdHZhciBsYWJlbENvbG9ycyA9IFtdO1xuXHRcdFx0dmFyIGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuXHRcdFx0dG9vbHRpcFBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0cy5wb3NpdGlvbl0uY2FsbChtZSwgYWN0aXZlLCBtZS5fZXZlbnRQb3NpdGlvbik7XG5cblx0XHRcdHZhciB0b29sdGlwSXRlbXMgPSBbXTtcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdFx0XHR0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbShhY3RpdmVbaV0pKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBmaWx0ZXIgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcblx0XHRcdGlmIChvcHRzLmZpbHRlcikge1xuXHRcdFx0XHR0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0cy5maWx0ZXIoYSwgZGF0YSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIHNvcnRpbmcgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcblx0XHRcdGlmIChvcHRzLml0ZW1Tb3J0KSB7XG5cdFx0XHRcdHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0cy5pdGVtU29ydChhLCBiLCBkYXRhKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERldGVybWluZSBjb2xvcnMgZm9yIGJveGVzXG5cdFx0XHRoZWxwZXJzJDEuZWFjaCh0b29sdGlwSXRlbXMsIGZ1bmN0aW9uKHRvb2x0aXBJdGVtKSB7XG5cdFx0XHRcdGxhYmVsQ29sb3JzLnB1c2gob3B0cy5jYWxsYmFja3MubGFiZWxDb2xvci5jYWxsKG1lLCB0b29sdGlwSXRlbSwgbWUuX2NoYXJ0KSk7XG5cdFx0XHRcdGxhYmVsVGV4dENvbG9ycy5wdXNoKG9wdHMuY2FsbGJhY2tzLmxhYmVsVGV4dENvbG9yLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBtZS5fY2hhcnQpKTtcblx0XHRcdH0pO1xuXG5cblx0XHRcdC8vIEJ1aWxkIHRoZSBUZXh0IExpbmVzXG5cdFx0XHRtb2RlbC50aXRsZSA9IG1lLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cdFx0XHRtb2RlbC5iZWZvcmVCb2R5ID0gbWUuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0bW9kZWwuYm9keSA9IG1lLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblx0XHRcdG1vZGVsLmFmdGVyQm9keSA9IG1lLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0bW9kZWwuZm9vdGVyID0gbWUuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cblx0XHRcdC8vIEluaXRpYWwgcG9zaXRpb25pbmcgYW5kIGNvbG9yc1xuXHRcdFx0bW9kZWwueCA9IHRvb2x0aXBQb3NpdGlvbi54O1xuXHRcdFx0bW9kZWwueSA9IHRvb2x0aXBQb3NpdGlvbi55O1xuXHRcdFx0bW9kZWwuY2FyZXRQYWRkaW5nID0gb3B0cy5jYXJldFBhZGRpbmc7XG5cdFx0XHRtb2RlbC5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuXHRcdFx0bW9kZWwubGFiZWxUZXh0Q29sb3JzID0gbGFiZWxUZXh0Q29sb3JzO1xuXG5cdFx0XHQvLyBkYXRhIHBvaW50c1xuXHRcdFx0bW9kZWwuZGF0YVBvaW50cyA9IHRvb2x0aXBJdGVtcztcblxuXHRcdFx0Ly8gV2UgbmVlZCB0byBkZXRlcm1pbmUgYWxpZ25tZW50IG9mIHRoZSB0b29sdGlwXG5cdFx0XHR0b29sdGlwU2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG1vZGVsKTtcblx0XHRcdGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLCB0b29sdGlwU2l6ZSk7XG5cdFx0XHQvLyBGaW5hbCBTaXplIGFuZCBQb3NpdGlvblxuXHRcdFx0YmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG1vZGVsLCB0b29sdGlwU2l6ZSwgYWxpZ25tZW50LCBtZS5fY2hhcnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtb2RlbC5vcGFjaXR5ID0gMDtcblx0XHR9XG5cblx0XHRtb2RlbC54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuXHRcdG1vZGVsLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cdFx0bW9kZWwueCA9IGJhY2tncm91bmRQb2ludC54O1xuXHRcdG1vZGVsLnkgPSBiYWNrZ3JvdW5kUG9pbnQueTtcblx0XHRtb2RlbC53aWR0aCA9IHRvb2x0aXBTaXplLndpZHRoO1xuXHRcdG1vZGVsLmhlaWdodCA9IHRvb2x0aXBTaXplLmhlaWdodDtcblxuXHRcdC8vIFBvaW50IHdoZXJlIHRoZSBjYXJldCBvbiB0aGUgdG9vbHRpcCBwb2ludHMgdG9cblx0XHRtb2RlbC5jYXJldFggPSB0b29sdGlwUG9zaXRpb24ueDtcblx0XHRtb2RlbC5jYXJldFkgPSB0b29sdGlwUG9zaXRpb24ueTtcblxuXHRcdG1lLl9tb2RlbCA9IG1vZGVsO1xuXG5cdFx0aWYgKGNoYW5nZWQgJiYgb3B0cy5jdXN0b20pIHtcblx0XHRcdG9wdHMuY3VzdG9tLmNhbGwobWUsIG1vZGVsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0ZHJhd0NhcmV0OiBmdW5jdGlvbih0b29sdGlwUG9pbnQsIHNpemUpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCB2bSk7XG5cblx0XHRjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuXHRcdGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG5cdFx0Y3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcblx0fSxcblx0Z2V0Q2FyZXRQb3NpdGlvbjogZnVuY3Rpb24odG9vbHRpcFBvaW50LCBzaXplLCB2bSkge1xuXHRcdHZhciB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xuXHRcdHZhciBjYXJldFNpemUgPSB2bS5jYXJldFNpemU7XG5cdFx0dmFyIGNvcm5lclJhZGl1cyA9IHZtLmNvcm5lclJhZGl1cztcblx0XHR2YXIgeEFsaWduID0gdm0ueEFsaWduO1xuXHRcdHZhciB5QWxpZ24gPSB2bS55QWxpZ247XG5cdFx0dmFyIHB0WCA9IHRvb2x0aXBQb2ludC54O1xuXHRcdHZhciBwdFkgPSB0b29sdGlwUG9pbnQueTtcblx0XHR2YXIgd2lkdGggPSBzaXplLndpZHRoO1xuXHRcdHZhciBoZWlnaHQgPSBzaXplLmhlaWdodDtcblxuXHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHR5MiA9IHB0WSArIChoZWlnaHQgLyAyKTtcblxuXHRcdFx0aWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdHgxID0gcHRYO1xuXHRcdFx0XHR4MiA9IHgxIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgxO1xuXG5cdFx0XHRcdHkxID0geTIgKyBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTIgLSBjYXJldFNpemU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4MSA9IHB0WCArIHdpZHRoO1xuXHRcdFx0XHR4MiA9IHgxICsgY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgxO1xuXG5cdFx0XHRcdHkxID0geTIgLSBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTIgKyBjYXJldFNpemU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0XHR4MiA9IHB0WCArIGNvcm5lclJhZGl1cyArIChjYXJldFNpemUpO1xuXHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xuXHRcdFx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdFx0eDIgPSBwdFggKyB3aWR0aCAtIGNvcm5lclJhZGl1cyAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eDEgPSB4MiAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eDMgPSB4MiArIGNhcmV0U2l6ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHgyID0gdm0uY2FyZXRYO1xuXHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcblx0XHRcdFx0eTEgPSBwdFk7XG5cdFx0XHRcdHkyID0geTEgLSBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR5MSA9IHB0WSArIGhlaWdodDtcblx0XHRcdFx0eTIgPSB5MSArIGNhcmV0U2l6ZTtcblx0XHRcdFx0eTMgPSB5MTtcblx0XHRcdFx0Ly8gaW52ZXJ0IGRyYXdpbmcgb3JkZXJcblx0XHRcdFx0dmFyIHRtcCA9IHgzO1xuXHRcdFx0XHR4MyA9IHgxO1xuXHRcdFx0XHR4MSA9IHRtcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHt4MTogeDEsIHgyOiB4MiwgeDM6IHgzLCB5MTogeTEsIHkyOiB5MiwgeTM6IHkzfTtcblx0fSxcblxuXHRkcmF3VGl0bGU6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4KSB7XG5cdFx0dmFyIHRpdGxlID0gdm0udGl0bGU7XG5cdFx0dmFyIGxlbmd0aCA9IHRpdGxlLmxlbmd0aDtcblx0XHR2YXIgdGl0bGVGb250U2l6ZSwgdGl0bGVTcGFjaW5nLCBpO1xuXG5cdFx0aWYgKGxlbmd0aCkge1xuXHRcdFx0dmFyIHJ0bEhlbHBlciA9IGdldFJ0bEhlbHBlcih2bS5ydGwsIHZtLngsIHZtLndpZHRoKTtcblxuXHRcdFx0cHQueCA9IGdldEFsaWduZWRYKHZtLCB2bS5fdGl0bGVBbGlnbik7XG5cblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKHZtLl90aXRsZUFsaWduKTtcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuXHRcdFx0dGl0bGVGb250U2l6ZSA9IHZtLnRpdGxlRm9udFNpemU7XG5cdFx0XHR0aXRsZVNwYWNpbmcgPSB2bS50aXRsZVNwYWNpbmc7XG5cblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS50aXRsZUZvbnRDb2xvcjtcblx0XHRcdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcodGl0bGVGb250U2l6ZSwgdm0uX3RpdGxlRm9udFN0eWxlLCB2bS5fdGl0bGVGb250RmFtaWx5KTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dCh0aXRsZVtpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyB0aXRsZUZvbnRTaXplIC8gMik7XG5cdFx0XHRcdHB0LnkgKz0gdGl0bGVGb250U2l6ZSArIHRpdGxlU3BhY2luZzsgLy8gTGluZSBIZWlnaHQgYW5kIHNwYWNpbmdcblxuXHRcdFx0XHRpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuXHRcdFx0XHRcdHB0LnkgKz0gdm0udGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7IC8vIElmIExhc3QsIGFkZCBtYXJnaW4sIHJlbW92ZSBzcGFjaW5nXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0ZHJhd0JvZHk6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4KSB7XG5cdFx0dmFyIGJvZHlGb250U2l6ZSA9IHZtLmJvZHlGb250U2l6ZTtcblx0XHR2YXIgYm9keVNwYWNpbmcgPSB2bS5ib2R5U3BhY2luZztcblx0XHR2YXIgYm9keUFsaWduID0gdm0uX2JvZHlBbGlnbjtcblx0XHR2YXIgYm9keSA9IHZtLmJvZHk7XG5cdFx0dmFyIGRyYXdDb2xvckJveGVzID0gdm0uZGlzcGxheUNvbG9ycztcblx0XHR2YXIgeExpbmVQYWRkaW5nID0gMDtcblx0XHR2YXIgY29sb3JYID0gZHJhd0NvbG9yQm94ZXMgPyBnZXRBbGlnbmVkWCh2bSwgJ2xlZnQnKSA6IDA7XG5cblx0XHR2YXIgcnRsSGVscGVyID0gZ2V0UnRsSGVscGVyKHZtLnJ0bCwgdm0ueCwgdm0ud2lkdGgpO1xuXG5cdFx0dmFyIGZpbGxMaW5lT2ZUZXh0ID0gZnVuY3Rpb24obGluZSkge1xuXHRcdFx0Y3R4LmZpbGxUZXh0KGxpbmUsIHJ0bEhlbHBlci54KHB0LnggKyB4TGluZVBhZGRpbmcpLCBwdC55ICsgYm9keUZvbnRTaXplIC8gMik7XG5cdFx0XHRwdC55ICs9IGJvZHlGb250U2l6ZSArIGJvZHlTcGFjaW5nO1xuXHRcdH07XG5cblx0XHR2YXIgYm9keUl0ZW0sIHRleHRDb2xvciwgbGFiZWxDb2xvcnMsIGxpbmVzLCBpLCBqLCBpbGVuLCBqbGVuO1xuXHRcdHZhciBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oYm9keUFsaWduKTtcblxuXHRcdGN0eC50ZXh0QWxpZ24gPSBib2R5QWxpZ247XG5cdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXHRcdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcoYm9keUZvbnRTaXplLCB2bS5fYm9keUZvbnRTdHlsZSwgdm0uX2JvZHlGb250RmFtaWx5KTtcblxuXHRcdHB0LnggPSBnZXRBbGlnbmVkWCh2bSwgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24pO1xuXG5cdFx0Ly8gQmVmb3JlIGJvZHkgbGluZXNcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYm9keUZvbnRDb2xvcjtcblx0XHRoZWxwZXJzJDEuZWFjaCh2bS5iZWZvcmVCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG5cblx0XHR4TGluZVBhZGRpbmcgPSBkcmF3Q29sb3JCb3hlcyAmJiBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiAhPT0gJ3JpZ2h0J1xuXHRcdFx0PyBib2R5QWxpZ24gPT09ICdjZW50ZXInID8gKGJvZHlGb250U2l6ZSAvIDIgKyAxKSA6IChib2R5Rm9udFNpemUgKyAyKVxuXHRcdFx0OiAwO1xuXG5cdFx0Ly8gRHJhdyBib2R5IGxpbmVzIG5vd1xuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0Ym9keUl0ZW0gPSBib2R5W2ldO1xuXHRcdFx0dGV4dENvbG9yID0gdm0ubGFiZWxUZXh0Q29sb3JzW2ldO1xuXHRcdFx0bGFiZWxDb2xvcnMgPSB2bS5sYWJlbENvbG9yc1tpXTtcblxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xuXG5cdFx0XHRsaW5lcyA9IGJvZHlJdGVtLmxpbmVzO1xuXHRcdFx0Zm9yIChqID0gMCwgamxlbiA9IGxpbmVzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuXHRcdFx0XHQvLyBEcmF3IExlZ2VuZC1saWtlIGJveGVzIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoZHJhd0NvbG9yQm94ZXMpIHtcblx0XHRcdFx0XHR2YXIgcnRsQ29sb3JYID0gcnRsSGVscGVyLngoY29sb3JYKTtcblxuXHRcdFx0XHRcdC8vIEZpbGwgYSB3aGl0ZSByZWN0IHNvIHRoYXQgY29sb3VycyBtZXJnZSBuaWNlbHkgaWYgdGhlIG9wYWNpdHkgaXMgPCAxXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmxlZ2VuZENvbG9yQmFja2dyb3VuZDtcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QocnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib2R5Rm9udFNpemUpLCBwdC55LCBib2R5Rm9udFNpemUsIGJvZHlGb250U2l6ZSk7XG5cblx0XHRcdFx0XHQvLyBCb3JkZXJcblx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gMTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9ycy5ib3JkZXJDb2xvcjtcblx0XHRcdFx0XHRjdHguc3Ryb2tlUmVjdChydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJvZHlGb250U2l6ZSksIHB0LnksIGJvZHlGb250U2l6ZSwgYm9keUZvbnRTaXplKTtcblxuXHRcdFx0XHRcdC8vIElubmVyIHNxdWFyZVxuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54UGx1cyhydGxDb2xvclgsIDEpLCBib2R5Rm9udFNpemUgLSAyKSwgcHQueSArIDEsIGJvZHlGb250U2l6ZSAtIDIsIGJvZHlGb250U2l6ZSAtIDIpO1xuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmaWxsTGluZU9mVGV4dChsaW5lc1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmFmdGVyLCBmaWxsTGluZU9mVGV4dCk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgYmFjayB0byAwIGZvciBhZnRlciBib2R5XG5cdFx0eExpbmVQYWRkaW5nID0gMDtcblxuXHRcdC8vIEFmdGVyIGJvZHkgbGluZXNcblx0XHRoZWxwZXJzJDEuZWFjaCh2bS5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcblx0XHRwdC55IC09IGJvZHlTcGFjaW5nOyAvLyBSZW1vdmUgbGFzdCBib2R5IHNwYWNpbmdcblx0fSxcblxuXHRkcmF3Rm9vdGVyOiBmdW5jdGlvbihwdCwgdm0sIGN0eCkge1xuXHRcdHZhciBmb290ZXIgPSB2bS5mb290ZXI7XG5cdFx0dmFyIGxlbmd0aCA9IGZvb3Rlci5sZW5ndGg7XG5cdFx0dmFyIGZvb3RlckZvbnRTaXplLCBpO1xuXG5cdFx0aWYgKGxlbmd0aCkge1xuXHRcdFx0dmFyIHJ0bEhlbHBlciA9IGdldFJ0bEhlbHBlcih2bS5ydGwsIHZtLngsIHZtLndpZHRoKTtcblxuXHRcdFx0cHQueCA9IGdldEFsaWduZWRYKHZtLCB2bS5fZm9vdGVyQWxpZ24pO1xuXHRcdFx0cHQueSArPSB2bS5mb290ZXJNYXJnaW5Ub3A7XG5cblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKHZtLl9mb290ZXJBbGlnbik7XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cblx0XHRcdGZvb3RlckZvbnRTaXplID0gdm0uZm9vdGVyRm9udFNpemU7XG5cblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS5mb290ZXJGb250Q29sb3I7XG5cdFx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGZvb3RlckZvbnRTaXplLCB2bS5fZm9vdGVyRm9udFN0eWxlLCB2bS5fZm9vdGVyRm9udEZhbWlseSk7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0XHRjdHguZmlsbFRleHQoZm9vdGVyW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIGZvb3RlckZvbnRTaXplIC8gMik7XG5cdFx0XHRcdHB0LnkgKz0gZm9vdGVyRm9udFNpemUgKyB2bS5mb290ZXJTcGFjaW5nO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRkcmF3QmFja2dyb3VuZDogZnVuY3Rpb24ocHQsIHZtLCBjdHgsIHRvb2x0aXBTaXplKSB7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJhY2tncm91bmRDb2xvcjtcblx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2bS5ib3JkZXJDb2xvcjtcblx0XHRjdHgubGluZVdpZHRoID0gdm0uYm9yZGVyV2lkdGg7XG5cdFx0dmFyIHhBbGlnbiA9IHZtLnhBbGlnbjtcblx0XHR2YXIgeUFsaWduID0gdm0ueUFsaWduO1xuXHRcdHZhciB4ID0gcHQueDtcblx0XHR2YXIgeSA9IHB0Lnk7XG5cdFx0dmFyIHdpZHRoID0gdG9vbHRpcFNpemUud2lkdGg7XG5cdFx0dmFyIGhlaWdodCA9IHRvb2x0aXBTaXplLmhlaWdodDtcblx0XHR2YXIgcmFkaXVzID0gdm0uY29ybmVyUmFkaXVzO1xuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG5cdFx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0fVxuXHRcdGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0XHR0aGlzLmRyYXdDYXJldChwdCwgdG9vbHRpcFNpemUpO1xuXHRcdH1cblx0XHRjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuXHRcdGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG5cdFx0XHR0aGlzLmRyYXdDYXJldChwdCwgdG9vbHRpcFNpemUpO1xuXHRcdH1cblx0XHRjdHgubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuXHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHR0aGlzLmRyYXdDYXJldChwdCwgdG9vbHRpcFNpemUpO1xuXHRcdH1cblx0XHRjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xuXHRcdGN0eC5jbG9zZVBhdGgoKTtcblxuXHRcdGN0eC5maWxsKCk7XG5cblx0XHRpZiAodm0uYm9yZGVyV2lkdGggPiAwKSB7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblxuXHRcdGlmICh2bS5vcGFjaXR5ID09PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRvb2x0aXBTaXplID0ge1xuXHRcdFx0d2lkdGg6IHZtLndpZHRoLFxuXHRcdFx0aGVpZ2h0OiB2bS5oZWlnaHRcblx0XHR9O1xuXHRcdHZhciBwdCA9IHtcblx0XHRcdHg6IHZtLngsXG5cdFx0XHR5OiB2bS55XG5cdFx0fTtcblxuXHRcdC8vIElFMTEvRWRnZSBkb2VzIG5vdCBsaWtlIHZlcnkgc21hbGwgb3BhY2l0aWVzLCBzbyBzbmFwIHRvIDBcblx0XHR2YXIgb3BhY2l0eSA9IE1hdGguYWJzKHZtLm9wYWNpdHkgPCAxZS0zKSA/IDAgOiB2bS5vcGFjaXR5O1xuXG5cdFx0Ly8gVHJ1dGh5L2ZhbHNleSB2YWx1ZSBmb3IgZW1wdHkgdG9vbHRpcFxuXHRcdHZhciBoYXNUb29sdGlwQ29udGVudCA9IHZtLnRpdGxlLmxlbmd0aCB8fCB2bS5iZWZvcmVCb2R5Lmxlbmd0aCB8fCB2bS5ib2R5Lmxlbmd0aCB8fCB2bS5hZnRlckJvZHkubGVuZ3RoIHx8IHZtLmZvb3Rlci5sZW5ndGg7XG5cblx0XHRpZiAodGhpcy5fb3B0aW9ucy5lbmFibGVkICYmIGhhc1Rvb2x0aXBDb250ZW50KSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcblxuXHRcdFx0Ly8gRHJhdyBCYWNrZ3JvdW5kXG5cdFx0XHR0aGlzLmRyYXdCYWNrZ3JvdW5kKHB0LCB2bSwgY3R4LCB0b29sdGlwU2l6ZSk7XG5cblx0XHRcdC8vIERyYXcgVGl0bGUsIEJvZHksIGFuZCBGb290ZXJcblx0XHRcdHB0LnkgKz0gdm0ueVBhZGRpbmc7XG5cblx0XHRcdGhlbHBlcnMkMS5ydGwub3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eCwgdm0udGV4dERpcmVjdGlvbik7XG5cblx0XHRcdC8vIFRpdGxlc1xuXHRcdFx0dGhpcy5kcmF3VGl0bGUocHQsIHZtLCBjdHgpO1xuXG5cdFx0XHQvLyBCb2R5XG5cdFx0XHR0aGlzLmRyYXdCb2R5KHB0LCB2bSwgY3R4KTtcblxuXHRcdFx0Ly8gRm9vdGVyXG5cdFx0XHR0aGlzLmRyYXdGb290ZXIocHQsIHZtLCBjdHgpO1xuXG5cdFx0XHRoZWxwZXJzJDEucnRsLnJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgdm0udGV4dERpcmVjdGlvbik7XG5cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdG9vbHRpcCBjaGFuZ2VkXG5cdCAqL1xuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fb3B0aW9ucztcblx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0bWUuX2xhc3RBY3RpdmUgPSBtZS5fbGFzdEFjdGl2ZSB8fCBbXTtcblxuXHRcdC8vIEZpbmQgQWN0aXZlIEVsZW1lbnRzIGZvciB0b29sdGlwc1xuXHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcblx0XHRcdG1lLl9hY3RpdmUgPSBbXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuX2FjdGl2ZSA9IG1lLl9jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucyk7XG5cdFx0XHRpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG5cdFx0XHRcdG1lLl9hY3RpdmUucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIExhc3QgQWN0aXZlc1xuXHRcdGNoYW5nZWQgPSAhaGVscGVycyQxLmFycmF5RXF1YWxzKG1lLl9hY3RpdmUsIG1lLl9sYXN0QWN0aXZlKTtcblxuXHRcdC8vIE9ubHkgaGFuZGxlIHRhcmdldCBldmVudCBvbiB0b29sdGlwIGNoYW5nZVxuXHRcdGlmIChjaGFuZ2VkKSB7XG5cdFx0XHRtZS5fbGFzdEFjdGl2ZSA9IG1lLl9hY3RpdmU7XG5cblx0XHRcdGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5jdXN0b20pIHtcblx0XHRcdFx0bWUuX2V2ZW50UG9zaXRpb24gPSB7XG5cdFx0XHRcdFx0eDogZS54LFxuXHRcdFx0XHRcdHk6IGUueVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdG1lLnVwZGF0ZSh0cnVlKTtcblx0XHRcdFx0bWUucGl2b3QoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2hhbmdlZDtcblx0fVxufSk7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzXG4gKi9cbnZhciBwb3NpdGlvbmVyc18xID0gcG9zaXRpb25lcnM7XG5cbnZhciBjb3JlX3Rvb2x0aXAgPSBleHBvcnRzJDQ7XG5jb3JlX3Rvb2x0aXAucG9zaXRpb25lcnMgPSBwb3NpdGlvbmVyc18xO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkOSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGVsZW1lbnRzOiB7fSxcblx0ZXZlbnRzOiBbXG5cdFx0J21vdXNlbW92ZScsXG5cdFx0J21vdXNlb3V0Jyxcblx0XHQnY2xpY2snLFxuXHRcdCd0b3VjaHN0YXJ0Jyxcblx0XHQndG91Y2htb3ZlJ1xuXHRdLFxuXHRob3Zlcjoge1xuXHRcdG9uSG92ZXI6IG51bGwsXG5cdFx0bW9kZTogJ25lYXJlc3QnLFxuXHRcdGludGVyc2VjdDogdHJ1ZSxcblx0XHRhbmltYXRpb25EdXJhdGlvbjogNDAwXG5cdH0sXG5cdG9uQ2xpY2s6IG51bGwsXG5cdG1haW50YWluQXNwZWN0UmF0aW86IHRydWUsXG5cdHJlc3BvbnNpdmU6IHRydWUsXG5cdHJlc3BvbnNpdmVBbmltYXRpb25EdXJhdGlvbjogMFxufSk7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgbWVyZ2UgdGhlIGdpdmVuIGNvbmZpZyBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgYHNjYWxlc2Agb3B0aW9uXG4gKiBieSBpbmNvcnBvcmF0aW5nIHNjYWxlIGRlZmF1bHRzIGluIGB4QXhlc2AgYW5kIGB5QXhlc2AgYXJyYXkgaXRlbXMsIHRoZW5cbiAqIHJldHVybnMgYSBkZWVwIGNvcHkgb2YgdGhlIHJlc3VsdCwgdGh1cyBkb2Vzbid0IGFsdGVyIGlucHV0cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VTY2FsZUNvbmZpZygvKiBjb25maWcgb2JqZWN0cyAuLi4gKi8pIHtcblx0cmV0dXJuIGhlbHBlcnMkMS5tZXJnZSh7fSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLCB7XG5cdFx0bWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0XHRpZiAoa2V5ID09PSAneEF4ZXMnIHx8IGtleSA9PT0gJ3lBeGVzJykge1xuXHRcdFx0XHR2YXIgc2xlbiA9IHNvdXJjZVtrZXldLmxlbmd0aDtcblx0XHRcdFx0dmFyIGksIHR5cGUsIHNjYWxlO1xuXG5cdFx0XHRcdGlmICghdGFyZ2V0W2tleV0pIHtcblx0XHRcdFx0XHR0YXJnZXRba2V5XSA9IFtdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHNsZW47ICsraSkge1xuXHRcdFx0XHRcdHNjYWxlID0gc291cmNlW2tleV1baV07XG5cdFx0XHRcdFx0dHlwZSA9IHZhbHVlT3JEZWZhdWx0JDkoc2NhbGUudHlwZSwga2V5ID09PSAneEF4ZXMnID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInKTtcblxuXHRcdFx0XHRcdGlmIChpID49IHRhcmdldFtrZXldLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W2tleV0ucHVzaCh7fSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCF0YXJnZXRba2V5XVtpXS50eXBlIHx8IChzY2FsZS50eXBlICYmIHNjYWxlLnR5cGUgIT09IHRhcmdldFtrZXldW2ldLnR5cGUpKSB7XG5cdFx0XHRcdFx0XHQvLyBuZXcvdW50eXBlZCBzY2FsZSBvciB0eXBlIGNoYW5nZWQ6IGxldCdzIGFwcGx5IHRoZSBuZXcgZGVmYXVsdHNcblx0XHRcdFx0XHRcdC8vIHRoZW4gbWVyZ2Ugc291cmNlIHNjYWxlIHRvIGNvcnJlY3RseSBvdmVyd3JpdGUgdGhlIGRlZmF1bHRzLlxuXHRcdFx0XHRcdFx0aGVscGVycyQxLm1lcmdlKHRhcmdldFtrZXldW2ldLCBbY29yZV9zY2FsZVNlcnZpY2UuZ2V0U2NhbGVEZWZhdWx0cyh0eXBlKSwgc2NhbGVdKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gc2NhbGVzIHR5cGUgYXJlIHRoZSBzYW1lXG5cdFx0XHRcdFx0XHRoZWxwZXJzJDEubWVyZ2UodGFyZ2V0W2tleV1baV0sIHNjYWxlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhlbHBlcnMkMS5fbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgbWVyZ2UgdGhlIGdpdmVuIGNvbmZpZyBvYmplY3RzIGFzIHRoZSByb290IG9wdGlvbnMgYnkgaGFuZGxpbmdcbiAqIGRlZmF1bHQgc2NhbGUgb3B0aW9ucyBmb3IgdGhlIGBzY2FsZXNgIGFuZCBgc2NhbGVgIHByb3BlcnRpZXMsIHRoZW4gcmV0dXJuc1xuICogYSBkZWVwIGNvcHkgb2YgdGhlIHJlc3VsdCwgdGh1cyBkb2Vzbid0IGFsdGVyIGlucHV0cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VDb25maWcoLyogY29uZmlnIG9iamVjdHMgLi4uICovKSB7XG5cdHJldHVybiBoZWxwZXJzJDEubWVyZ2Uoe30sIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwge1xuXHRcdG1lcmdlcjogZnVuY3Rpb24oa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XSB8fCB7fTtcblx0XHRcdHZhciBzdmFsID0gc291cmNlW2tleV07XG5cblx0XHRcdGlmIChrZXkgPT09ICdzY2FsZXMnKSB7XG5cdFx0XHRcdC8vIHNjYWxlIGNvbmZpZyBtZXJnaW5nIGlzIGNvbXBsZXguIEFkZCBvdXIgb3duIGZ1bmN0aW9uIGhlcmUgZm9yIHRoYXRcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBtZXJnZVNjYWxlQ29uZmlnKHR2YWwsIHN2YWwpO1xuXHRcdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzY2FsZScpIHtcblx0XHRcdFx0Ly8gdXNlZCBpbiBwb2xhciBhcmVhICYgcmFkYXIgY2hhcnRzIHNpbmNlIHRoZXJlIGlzIG9ubHkgb25lIHNjYWxlXG5cdFx0XHRcdHRhcmdldFtrZXldID0gaGVscGVycyQxLm1lcmdlKHR2YWwsIFtjb3JlX3NjYWxlU2VydmljZS5nZXRTY2FsZURlZmF1bHRzKHN2YWwudHlwZSksIHN2YWxdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhlbHBlcnMkMS5fbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIGluaXRDb25maWcoY29uZmlnKSB7XG5cdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHQvLyBEbyBOT1QgdXNlIG1lcmdlQ29uZmlnIGZvciB0aGUgZGF0YSBvYmplY3QgYmVjYXVzZSB0aGlzIG1ldGhvZCBtZXJnZXMgYXJyYXlzXG5cdC8vIGFuZCBzbyB3b3VsZCBjaGFuZ2UgcmVmZXJlbmNlcyB0byBsYWJlbHMgYW5kIGRhdGFzZXRzLCBwcmV2ZW50aW5nIGRhdGEgdXBkYXRlcy5cblx0dmFyIGRhdGEgPSBjb25maWcuZGF0YSA9IGNvbmZpZy5kYXRhIHx8IHt9O1xuXHRkYXRhLmRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cyB8fCBbXTtcblx0ZGF0YS5sYWJlbHMgPSBkYXRhLmxhYmVscyB8fCBbXTtcblxuXHRjb25maWcub3B0aW9ucyA9IG1lcmdlQ29uZmlnKFxuXHRcdGNvcmVfZGVmYXVsdHMuZ2xvYmFsLFxuXHRcdGNvcmVfZGVmYXVsdHNbY29uZmlnLnR5cGVdLFxuXHRcdGNvbmZpZy5vcHRpb25zIHx8IHt9KTtcblxuXHRyZXR1cm4gY29uZmlnO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb25maWcoY2hhcnQpIHtcblx0dmFyIG5ld09wdGlvbnMgPSBjaGFydC5vcHRpb25zO1xuXG5cdGhlbHBlcnMkMS5lYWNoKGNoYXJ0LnNjYWxlcywgZnVuY3Rpb24oc2NhbGUpIHtcblx0XHRjb3JlX2xheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBzY2FsZSk7XG5cdH0pO1xuXG5cdG5ld09wdGlvbnMgPSBtZXJnZUNvbmZpZyhcblx0XHRjb3JlX2RlZmF1bHRzLmdsb2JhbCxcblx0XHRjb3JlX2RlZmF1bHRzW2NoYXJ0LmNvbmZpZy50eXBlXSxcblx0XHRuZXdPcHRpb25zKTtcblxuXHRjaGFydC5vcHRpb25zID0gY2hhcnQuY29uZmlnLm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuXHRjaGFydC5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG5cdGNoYXJ0LmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcblxuXHQvLyBUb29sdGlwXG5cdGNoYXJ0LnRvb2x0aXAuX29wdGlvbnMgPSBuZXdPcHRpb25zLnRvb2x0aXBzO1xuXHRjaGFydC50b29sdGlwLmluaXRpYWxpemUoKTtcbn1cblxuZnVuY3Rpb24gbmV4dEF2YWlsYWJsZVNjYWxlSWQoYXhlc09wdHMsIHByZWZpeCwgaW5kZXgpIHtcblx0dmFyIGlkO1xuXHR2YXIgaGFzSWQgPSBmdW5jdGlvbihvYmopIHtcblx0XHRyZXR1cm4gb2JqLmlkID09PSBpZDtcblx0fTtcblxuXHRkbyB7XG5cdFx0aWQgPSBwcmVmaXggKyBpbmRleCsrO1xuXHR9IHdoaWxlIChoZWxwZXJzJDEuZmluZEluZGV4KGF4ZXNPcHRzLCBoYXNJZCkgPj0gMCk7XG5cblx0cmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbikge1xuXHRyZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJztcbn1cblxuZnVuY3Rpb24gY29tcGFyZTJMZXZlbChsMSwgbDIpIHtcblx0cmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRyZXR1cm4gYVtsMV0gPT09IGJbbDFdXG5cdFx0XHQ/IGFbbDJdIC0gYltsMl1cblx0XHRcdDogYVtsMV0gLSBiW2wxXTtcblx0fTtcbn1cblxudmFyIENoYXJ0ID0gZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XG5cdHRoaXMuY29uc3RydWN0KGl0ZW0sIGNvbmZpZyk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuaGVscGVycyQxLmV4dGVuZChDaGFydC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgQ2hhcnQgKi8ge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNvbnN0cnVjdDogZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGNvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcblxuXHRcdHZhciBjb250ZXh0ID0gcGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaXRlbSwgY29uZmlnKTtcblx0XHR2YXIgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcblx0XHR2YXIgaGVpZ2h0ID0gY2FudmFzICYmIGNhbnZhcy5oZWlnaHQ7XG5cdFx0dmFyIHdpZHRoID0gY2FudmFzICYmIGNhbnZhcy53aWR0aDtcblxuXHRcdG1lLmlkID0gaGVscGVycyQxLnVpZCgpO1xuXHRcdG1lLmN0eCA9IGNvbnRleHQ7XG5cdFx0bWUuY2FudmFzID0gY2FudmFzO1xuXHRcdG1lLmNvbmZpZyA9IGNvbmZpZztcblx0XHRtZS53aWR0aCA9IHdpZHRoO1xuXHRcdG1lLmhlaWdodCA9IGhlaWdodDtcblx0XHRtZS5hc3BlY3RSYXRpbyA9IGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogbnVsbDtcblx0XHRtZS5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG5cdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XG5cdFx0bWUuX2xheWVycyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIENoYXJ0IGFuZCBDaGFydC5Db250cm9sbGVyIGhhdmUgYmVlbiBtZXJnZWQsXG5cdFx0ICogdGhlIFwiaW5zdGFuY2VcIiBzdGlsbCBuZWVkIHRvIGJlIGRlZmluZWQgc2luY2UgaXQgbWlnaHQgYmUgY2FsbGVkIGZyb20gcGx1Z2lucy5cblx0XHQgKiBAcHJvcCBDaGFydCNjaGFydFxuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcblx0XHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRtZS5jaGFydCA9IG1lO1xuXHRcdG1lLmNvbnRyb2xsZXIgPSBtZTsgLy8gY2hhcnQuY2hhcnQuY29udHJvbGxlciAjaW5jZXB0aW9uXG5cblx0XHQvLyBBZGQgdGhlIGNoYXJ0IGluc3RhbmNlIHRvIHRoZSBnbG9iYWwgbmFtZXNwYWNlXG5cdFx0Q2hhcnQuaW5zdGFuY2VzW21lLmlkXSA9IG1lO1xuXG5cdFx0Ly8gRGVmaW5lIGFsaWFzIHRvIHRoZSBjb25maWcgZGF0YTogYGNoYXJ0LmRhdGEgPT09IGNoYXJ0LmNvbmZpZy5kYXRhYFxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ2RhdGEnLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbWUuY29uZmlnLmRhdGE7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRtZS5jb25maWcuZGF0YSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKCFjb250ZXh0IHx8ICFjYW52YXMpIHtcblx0XHRcdC8vIFRoZSBnaXZlbiBpdGVtIGlzIG5vdCBhIGNvbXBhdGlibGUgY29udGV4dDJkIGVsZW1lbnQsIGxldCdzIHJldHVybiBiZWZvcmUgZmluYWxpemluZ1xuXHRcdFx0Ly8gdGhlIGNoYXJ0IGluaXRpYWxpemF0aW9uIGJ1dCBhZnRlciBzZXR0aW5nIGJhc2ljIGNoYXJ0IC8gY29udHJvbGxlciBwcm9wZXJ0aWVzIHRoYXRcblx0XHRcdC8vIGNhbiBoZWxwIHRvIGZpZ3VyZSBvdXQgdGhhdCB0aGUgY2hhcnQgaXMgbm90IHZhbGlkIChlLmcgY2hhcnQuY2FudmFzICE9PSBudWxsKTtcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFydDogY2FuJ3QgYWNxdWlyZSBjb250ZXh0IGZyb20gdGhlIGdpdmVuIGl0ZW1cIik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bWUuaW5pdGlhbGl6ZSgpO1xuXHRcdG1lLnVwZGF0ZSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIEJlZm9yZSBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlSW5pdCcpO1xuXG5cdFx0aGVscGVycyQxLnJldGluYVNjYWxlKG1lLCBtZS5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuXG5cdFx0bWUuYmluZEV2ZW50cygpO1xuXG5cdFx0aWYgKG1lLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuXHRcdFx0Ly8gSW5pdGlhbCByZXNpemUgYmVmb3JlIGNoYXJ0IGRyYXdzIChtdXN0IGJlIHNpbGVudCB0byBwcmVzZXJ2ZSBpbml0aWFsIGFuaW1hdGlvbnMpLlxuXHRcdFx0bWUucmVzaXplKHRydWUpO1xuXHRcdH1cblxuXHRcdG1lLmluaXRUb29sVGlwKCk7XG5cblx0XHQvLyBBZnRlciBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJJbml0Jyk7XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYW52YXMuY2xlYXIodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gU3RvcHMgYW55IGN1cnJlbnQgYW5pbWF0aW9uIGxvb3Agb2NjdXJyaW5nXG5cdFx0Y29yZV9hbmltYXRpb25zLmNhbmNlbEFuaW1hdGlvbih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZXNpemU6IGZ1bmN0aW9uKHNpbGVudCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBjYW52YXMgPSBtZS5jYW52YXM7XG5cdFx0dmFyIGFzcGVjdFJhdGlvID0gKG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBtZS5hc3BlY3RSYXRpbykgfHwgbnVsbDtcblxuXHRcdC8vIHRoZSBjYW52YXMgcmVuZGVyIHdpZHRoIGFuZCBoZWlnaHQgd2lsbCBiZSBjYXN0ZWQgdG8gaW50ZWdlcnMgc28gbWFrZSBzdXJlIHRoYXRcblx0XHQvLyB0aGUgY2FudmFzIGRpc3BsYXkgc3R5bGUgdXNlcyB0aGUgc2FtZSBpbnRlZ2VyIHZhbHVlcyB0byBhdm9pZCBibHVycmluZyBlZmZlY3QuXG5cblx0XHQvLyBTZXQgdG8gMCBpbnN0ZWFkIG9mIGNhbnZhcy5zaXplIGJlY2F1c2UgdGhlIHNpemUgZGVmYXVsdHMgdG8gMzAweDE1MCBpZiB0aGUgZWxlbWVudCBpcyBjb2xsYXBzZWRcblx0XHR2YXIgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5nZXRNYXhpbXVtV2lkdGgoY2FudmFzKSkpO1xuXHRcdHZhciBuZXdIZWlnaHQgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKGFzcGVjdFJhdGlvID8gbmV3V2lkdGggLyBhc3BlY3RSYXRpbyA6IGhlbHBlcnMkMS5nZXRNYXhpbXVtSGVpZ2h0KGNhbnZhcykpKTtcblxuXHRcdGlmIChtZS53aWR0aCA9PT0gbmV3V2lkdGggJiYgbWUuaGVpZ2h0ID09PSBuZXdIZWlnaHQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjYW52YXMud2lkdGggPSBtZS53aWR0aCA9IG5ld1dpZHRoO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSBtZS5oZWlnaHQgPSBuZXdIZWlnaHQ7XG5cdFx0Y2FudmFzLnN0eWxlLndpZHRoID0gbmV3V2lkdGggKyAncHgnO1xuXHRcdGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBuZXdIZWlnaHQgKyAncHgnO1xuXG5cdFx0aGVscGVycyQxLnJldGluYVNjYWxlKG1lLCBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuXG5cdFx0aWYgKCFzaWxlbnQpIHtcblx0XHRcdC8vIE5vdGlmeSBhbnkgcGx1Z2lucyBhYm91dCB0aGUgcmVzaXplXG5cdFx0XHR2YXIgbmV3U2l6ZSA9IHt3aWR0aDogbmV3V2lkdGgsIGhlaWdodDogbmV3SGVpZ2h0fTtcblx0XHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdyZXNpemUnLCBbbmV3U2l6ZV0pO1xuXG5cdFx0XHQvLyBOb3RpZnkgb2YgcmVzaXplXG5cdFx0XHRpZiAob3B0aW9ucy5vblJlc2l6ZSkge1xuXHRcdFx0XHRvcHRpb25zLm9uUmVzaXplKG1lLCBuZXdTaXplKTtcblx0XHRcdH1cblxuXHRcdFx0bWUuc3RvcCgpO1xuXHRcdFx0bWUudXBkYXRlKHtcblx0XHRcdFx0ZHVyYXRpb246IG9wdGlvbnMucmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0ZW5zdXJlU2NhbGVzSGF2ZUlEczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdFx0dmFyIHNjYWxlc09wdGlvbnMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcblx0XHR2YXIgc2NhbGVPcHRpb25zID0gb3B0aW9ucy5zY2FsZTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKHNjYWxlc09wdGlvbnMueEF4ZXMsIGZ1bmN0aW9uKHhBeGlzT3B0aW9ucywgaW5kZXgpIHtcblx0XHRcdGlmICgheEF4aXNPcHRpb25zLmlkKSB7XG5cdFx0XHRcdHhBeGlzT3B0aW9ucy5pZCA9IG5leHRBdmFpbGFibGVTY2FsZUlkKHNjYWxlc09wdGlvbnMueEF4ZXMsICd4LWF4aXMtJywgaW5kZXgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aGVscGVycyQxLmVhY2goc2NhbGVzT3B0aW9ucy55QXhlcywgZnVuY3Rpb24oeUF4aXNPcHRpb25zLCBpbmRleCkge1xuXHRcdFx0aWYgKCF5QXhpc09wdGlvbnMuaWQpIHtcblx0XHRcdFx0eUF4aXNPcHRpb25zLmlkID0gbmV4dEF2YWlsYWJsZVNjYWxlSWQoc2NhbGVzT3B0aW9ucy55QXhlcywgJ3ktYXhpcy0nLCBpbmRleCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoc2NhbGVPcHRpb25zKSB7XG5cdFx0XHRzY2FsZU9wdGlvbnMuaWQgPSBzY2FsZU9wdGlvbnMuaWQgfHwgJ3NjYWxlJztcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEJ1aWxkcyBhIG1hcCBvZiBzY2FsZSBJRCB0byBzY2FsZSBvYmplY3QgZm9yIGZ1dHVyZSBsb29rdXAuXG5cdCAqL1xuXHRidWlsZE9yVXBkYXRlU2NhbGVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgc2NhbGVzID0gbWUuc2NhbGVzIHx8IHt9O1xuXHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdHZhciB1cGRhdGVkID0gT2JqZWN0LmtleXMoc2NhbGVzKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBpZCkge1xuXHRcdFx0b2JqW2lkXSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LCB7fSk7XG5cblx0XHRpZiAob3B0aW9ucy5zY2FsZXMpIHtcblx0XHRcdGl0ZW1zID0gaXRlbXMuY29uY2F0KFxuXHRcdFx0XHQob3B0aW9ucy5zY2FsZXMueEF4ZXMgfHwgW10pLm1hcChmdW5jdGlvbih4QXhpc09wdGlvbnMpIHtcblx0XHRcdFx0XHRyZXR1cm4ge29wdGlvbnM6IHhBeGlzT3B0aW9ucywgZHR5cGU6ICdjYXRlZ29yeScsIGRwb3NpdGlvbjogJ2JvdHRvbSd9O1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0KG9wdGlvbnMuc2NhbGVzLnlBeGVzIHx8IFtdKS5tYXAoZnVuY3Rpb24oeUF4aXNPcHRpb25zKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtvcHRpb25zOiB5QXhpc09wdGlvbnMsIGR0eXBlOiAnbGluZWFyJywgZHBvc2l0aW9uOiAnbGVmdCd9O1xuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5zY2FsZSkge1xuXHRcdFx0aXRlbXMucHVzaCh7XG5cdFx0XHRcdG9wdGlvbnM6IG9wdGlvbnMuc2NhbGUsXG5cdFx0XHRcdGR0eXBlOiAncmFkaWFsTGluZWFyJyxcblx0XHRcdFx0aXNEZWZhdWx0OiB0cnVlLFxuXHRcdFx0XHRkcG9zaXRpb246ICdjaGFydEFyZWEnXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRoZWxwZXJzJDEuZWFjaChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0dmFyIHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcblx0XHRcdHZhciBpZCA9IHNjYWxlT3B0aW9ucy5pZDtcblx0XHRcdHZhciBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdCQ5KHNjYWxlT3B0aW9ucy50eXBlLCBpdGVtLmR0eXBlKTtcblxuXHRcdFx0aWYgKHBvc2l0aW9uSXNIb3Jpem9udGFsKHNjYWxlT3B0aW9ucy5wb3NpdGlvbikgIT09IHBvc2l0aW9uSXNIb3Jpem9udGFsKGl0ZW0uZHBvc2l0aW9uKSkge1xuXHRcdFx0XHRzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlZFtpZF0gPSB0cnVlO1xuXHRcdFx0dmFyIHNjYWxlID0gbnVsbDtcblx0XHRcdGlmIChpZCBpbiBzY2FsZXMgJiYgc2NhbGVzW2lkXS50eXBlID09PSBzY2FsZVR5cGUpIHtcblx0XHRcdFx0c2NhbGUgPSBzY2FsZXNbaWRdO1xuXHRcdFx0XHRzY2FsZS5vcHRpb25zID0gc2NhbGVPcHRpb25zO1xuXHRcdFx0XHRzY2FsZS5jdHggPSBtZS5jdHg7XG5cdFx0XHRcdHNjYWxlLmNoYXJ0ID0gbWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgc2NhbGVDbGFzcyA9IGNvcmVfc2NhbGVTZXJ2aWNlLmdldFNjYWxlQ29uc3RydWN0b3Ioc2NhbGVUeXBlKTtcblx0XHRcdFx0aWYgKCFzY2FsZUNsYXNzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNjYWxlID0gbmV3IHNjYWxlQ2xhc3Moe1xuXHRcdFx0XHRcdGlkOiBpZCxcblx0XHRcdFx0XHR0eXBlOiBzY2FsZVR5cGUsXG5cdFx0XHRcdFx0b3B0aW9uczogc2NhbGVPcHRpb25zLFxuXHRcdFx0XHRcdGN0eDogbWUuY3R4LFxuXHRcdFx0XHRcdGNoYXJ0OiBtZVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xuXHRcdFx0fVxuXG5cdFx0XHRzY2FsZS5tZXJnZVRpY2tzT3B0aW9ucygpO1xuXG5cdFx0XHQvLyBUT0RPKFNCKTogSSB0aGluayB3ZSBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhpcyBjdXN0b20gY2FzZSAob3B0aW9ucy5zY2FsZSlcblx0XHRcdC8vIGFuZCBjb25zaWRlciBpdCBhcyBhIHJlZ3VsYXIgc2NhbGUgcGFydCBvZiB0aGUgXCJzY2FsZXNcIlwiIG1hcCBvbmx5ISBUaGlzIHdvdWxkXG5cdFx0XHQvLyBtYWtlIHRoZSBsb2dpYyBlYXNpZXIgYW5kIHJlbW92ZSBzb21lIHVzZWxlc3M/IGN1c3RvbSBjb2RlLlxuXHRcdFx0aWYgKGl0ZW0uaXNEZWZhdWx0KSB7XG5cdFx0XHRcdG1lLnNjYWxlID0gc2NhbGU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Ly8gY2xlYXIgdXAgZGlzY2FyZGVkIHNjYWxlc1xuXHRcdGhlbHBlcnMkMS5lYWNoKHVwZGF0ZWQsIGZ1bmN0aW9uKGhhc1VwZGF0ZWQsIGlkKSB7XG5cdFx0XHRpZiAoIWhhc1VwZGF0ZWQpIHtcblx0XHRcdFx0ZGVsZXRlIHNjYWxlc1tpZF07XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRtZS5zY2FsZXMgPSBzY2FsZXM7XG5cblx0XHRjb3JlX3NjYWxlU2VydmljZS5hZGRTY2FsZXNUb0xheW91dCh0aGlzKTtcblx0fSxcblxuXHRidWlsZE9yVXBkYXRlQ29udHJvbGxlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG5ld0NvbnRyb2xsZXJzID0gW107XG5cdFx0dmFyIGRhdGFzZXRzID0gbWUuZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcblx0XHRcdHZhciBkYXRhc2V0ID0gZGF0YXNldHNbaV07XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0dmFyIHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgbWUuY29uZmlnLnR5cGU7XG5cblx0XHRcdGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XG5cdFx0XHRcdG1lLmRlc3Ryb3lEYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0bWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0fVxuXHRcdFx0bWV0YS50eXBlID0gdHlwZTtcblx0XHRcdG1ldGEub3JkZXIgPSBkYXRhc2V0Lm9yZGVyIHx8IDA7XG5cdFx0XHRtZXRhLmluZGV4ID0gaTtcblxuXHRcdFx0aWYgKG1ldGEuY29udHJvbGxlcikge1xuXHRcdFx0XHRtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoaSk7XG5cdFx0XHRcdG1ldGEuY29udHJvbGxlci5saW5rU2NhbGVzKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgQ29udHJvbGxlckNsYXNzID0gY29udHJvbGxlcnNbbWV0YS50eXBlXTtcblx0XHRcdFx0aWYgKENvbnRyb2xsZXJDbGFzcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdcIicgKyBtZXRhLnR5cGUgKyAnXCIgaXMgbm90IGEgY2hhcnQgdHlwZS4nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1ldGEuY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyQ2xhc3MobWUsIGkpO1xuXHRcdFx0XHRuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXNldCB0aGUgZWxlbWVudHMgb2YgYWxsIGRhdGFzZXRzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRyZXNldEVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLnJlc2V0KCk7XG5cdFx0fSwgbWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJlc2V0cyB0aGUgY2hhcnQgYmFjayB0byBpdCdzIHN0YXRlIGJlZm9yZSB0aGUgaW5pdGlhbCBhbmltYXRpb25cblx0Ki9cblx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVzZXRFbGVtZW50cygpO1xuXHRcdHRoaXMudG9vbHRpcC5pbml0aWFsaXplKCk7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihjb25maWcpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0aWYgKCFjb25maWcgfHwgdHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCcpIHtcblx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRjb25maWcgPSB7XG5cdFx0XHRcdGR1cmF0aW9uOiBjb25maWcsXG5cdFx0XHRcdGxhenk6IGFyZ3VtZW50c1sxXVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR1cGRhdGVDb25maWcobWUpO1xuXG5cdFx0Ly8gcGx1Z2lucyBvcHRpb25zIHJlZmVyZW5jZXMgbWlnaHQgaGF2ZSBjaGFuZ2UsIGxldCdzIGludmFsaWRhdGUgdGhlIGNhY2hlXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzUxMTEjaXNzdWVjb21tZW50LTM1NTkzNDE2N1xuXHRcdGNvcmVfcGx1Z2lucy5faW52YWxpZGF0ZShtZSk7XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZVVwZGF0ZScpID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEluIGNhc2UgdGhlIGVudGlyZSBkYXRhIG9iamVjdCBjaGFuZ2VkXG5cdFx0bWUudG9vbHRpcC5fZGF0YSA9IG1lLmRhdGE7XG5cblx0XHQvLyBNYWtlIHN1cmUgZGF0YXNldCBjb250cm9sbGVycyBhcmUgdXBkYXRlZCBhbmQgbmV3IGNvbnRyb2xsZXJzIGFyZSByZXNldFxuXHRcdHZhciBuZXdDb250cm9sbGVycyA9IG1lLmJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGFsbCBkYXRhc2V0IGNvbnRyb2xsZXJzIGhhdmUgY29ycmVjdCBtZXRhIGRhdGEgY291bnRzXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG5cdFx0XHRtZS5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cygpO1xuXHRcdH1cblxuXHRcdG1lLnVwZGF0ZUxheW91dCgpO1xuXG5cdFx0Ly8gQ2FuIG9ubHkgcmVzZXQgdGhlIG5ldyBjb250cm9sbGVycyBhZnRlciB0aGUgc2NhbGVzIGhhdmUgYmVlbiB1cGRhdGVkXG5cdFx0aWYgKG1lLm9wdGlvbnMuYW5pbWF0aW9uICYmIG1lLm9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uKSB7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaChuZXdDb250cm9sbGVycywgZnVuY3Rpb24oY29udHJvbGxlcikge1xuXHRcdFx0XHRjb250cm9sbGVyLnJlc2V0KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRtZS51cGRhdGVEYXRhc2V0cygpO1xuXG5cdFx0Ly8gTmVlZCB0byByZXNldCB0b29sdGlwIGluIGNhc2UgaXQgaXMgZGlzcGxheWVkIHdpdGggZWxlbWVudHMgdGhhdCBhcmUgcmVtb3ZlZFxuXHRcdC8vIGFmdGVyIHVwZGF0ZS5cblx0XHRtZS50b29sdGlwLmluaXRpYWxpemUoKTtcblxuXHRcdC8vIExhc3QgYWN0aXZlIGNvbnRhaW5zIGl0ZW1zIHRoYXQgd2VyZSBwcmV2aW91c2x5IGluIHRoZSB0b29sdGlwLlxuXHRcdC8vIFdoZW4gd2UgcmVzZXQgdGhlIHRvb2x0aXAsIHdlIG5lZWQgdG8gY2xlYXIgaXRcblx0XHRtZS5sYXN0QWN0aXZlID0gW107XG5cblx0XHQvLyBEbyB0aGlzIGJlZm9yZSByZW5kZXIgc28gdGhhdCBhbnkgcGx1Z2lucyB0aGF0IG5lZWQgZmluYWwgc2NhbGUgdXBkYXRlcyBjYW4gdXNlIGl0XG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyVXBkYXRlJyk7XG5cblx0XHRtZS5fbGF5ZXJzLnNvcnQoY29tcGFyZTJMZXZlbCgneicsICdfaWR4JykpO1xuXG5cdFx0aWYgKG1lLl9idWZmZXJlZFJlbmRlcikge1xuXHRcdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IHtcblx0XHRcdFx0ZHVyYXRpb246IGNvbmZpZy5kdXJhdGlvbixcblx0XHRcdFx0ZWFzaW5nOiBjb25maWcuZWFzaW5nLFxuXHRcdFx0XHRsYXp5OiBjb25maWcubGF6eVxuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUucmVuZGVyKGNvbmZpZyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBjaGFydCBsYXlvdXQgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZUxheW91dGBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyTGF5b3V0YC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVwZGF0ZUxheW91dDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlTGF5b3V0JykgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29yZV9sYXlvdXRzLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cblx0XHRtZS5fbGF5ZXJzID0gW107XG5cdFx0aGVscGVycyQxLmVhY2gobWUuYm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0Ly8gX2NvbmZpZ3VyZSBpcyBjYWxsZWQgdHdpY2UsIG9uY2UgaW4gY29yZS5zY2FsZS51cGRhdGUgYW5kIG9uY2UgaGVyZS5cblx0XHRcdC8vIEhlcmUgdGhlIGJveGVzIGFyZSBmdWxseSB1cGRhdGVkIGFuZCBhdCB0aGVpciBmaW5hbCBwb3NpdGlvbnMuXG5cdFx0XHRpZiAoYm94Ll9jb25maWd1cmUpIHtcblx0XHRcdFx0Ym94Ll9jb25maWd1cmUoKTtcblx0XHRcdH1cblx0XHRcdG1lLl9sYXllcnMucHVzaC5hcHBseShtZS5fbGF5ZXJzLCBib3guX2xheWVycygpKTtcblx0XHR9LCBtZSk7XG5cblx0XHRtZS5fbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcblx0XHRcdGl0ZW0uX2lkeCA9IGluZGV4O1xuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBgYWZ0ZXJMYXlvdXRgIGluc3RlYWQuXG5cdFx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVyU2NhbGVVcGRhdGVcblx0XHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNS4wXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyU2NhbGVVcGRhdGUnKTtcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJMYXlvdXQnKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlcyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzVXBkYXRlYFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0c1VwZGF0ZWAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVEYXRhc2V0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRGF0YXNldHNVcGRhdGUnKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVEYXRhc2V0KGkpO1xuXHRcdH1cblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXRzVXBkYXRlJyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldFVwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldFVwZGF0ZWAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVEYXRhc2V0OiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cdFx0dmFyIGFyZ3MgPSB7XG5cdFx0XHRtZXRhOiBtZXRhLFxuXHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0fTtcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRGF0YXNldFVwZGF0ZScsIFthcmdzXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bWV0YS5jb250cm9sbGVyLl91cGRhdGUoKTtcblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXRVcGRhdGUnLCBbYXJnc10pO1xuXHR9LFxuXG5cdHJlbmRlcjogZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmICghY29uZmlnIHx8IHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XG5cdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0Y29uZmlnID0ge1xuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLFxuXHRcdFx0XHRsYXp5OiBhcmd1bWVudHNbMV1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dmFyIGFuaW1hdGlvbk9wdGlvbnMgPSBtZS5vcHRpb25zLmFuaW1hdGlvbjtcblx0XHR2YXIgZHVyYXRpb24gPSB2YWx1ZU9yRGVmYXVsdCQ5KGNvbmZpZy5kdXJhdGlvbiwgYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLmR1cmF0aW9uKTtcblx0XHR2YXIgbGF6eSA9IGNvbmZpZy5sYXp5O1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVSZW5kZXInKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb25Db21wbGV0ZSA9IGZ1bmN0aW9uKGFuaW1hdGlvbikge1xuXHRcdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyUmVuZGVyJyk7XG5cdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFthbmltYXRpb25dLCBtZSk7XG5cdFx0fTtcblxuXHRcdGlmIChhbmltYXRpb25PcHRpb25zICYmIGR1cmF0aW9uKSB7XG5cdFx0XHR2YXIgYW5pbWF0aW9uID0gbmV3IGNvcmVfYW5pbWF0aW9uKHtcblx0XHRcdFx0bnVtU3RlcHM6IGR1cmF0aW9uIC8gMTYuNjYsIC8vIDYwIGZwc1xuXHRcdFx0XHRlYXNpbmc6IGNvbmZpZy5lYXNpbmcgfHwgYW5pbWF0aW9uT3B0aW9ucy5lYXNpbmcsXG5cblx0XHRcdFx0cmVuZGVyOiBmdW5jdGlvbihjaGFydCwgYW5pbWF0aW9uT2JqZWN0KSB7XG5cdFx0XHRcdFx0dmFyIGVhc2luZ0Z1bmN0aW9uID0gaGVscGVycyQxLmVhc2luZy5lZmZlY3RzW2FuaW1hdGlvbk9iamVjdC5lYXNpbmddO1xuXHRcdFx0XHRcdHZhciBjdXJyZW50U3RlcCA9IGFuaW1hdGlvbk9iamVjdC5jdXJyZW50U3RlcDtcblx0XHRcdFx0XHR2YXIgc3RlcERlY2ltYWwgPSBjdXJyZW50U3RlcCAvIGFuaW1hdGlvbk9iamVjdC5udW1TdGVwcztcblxuXHRcdFx0XHRcdGNoYXJ0LmRyYXcoZWFzaW5nRnVuY3Rpb24oc3RlcERlY2ltYWwpLCBzdGVwRGVjaW1hbCwgY3VycmVudFN0ZXApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdG9uQW5pbWF0aW9uUHJvZ3Jlc3M6IGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcyxcblx0XHRcdFx0b25BbmltYXRpb25Db21wbGV0ZTogb25Db21wbGV0ZVxuXHRcdFx0fSk7XG5cblx0XHRcdGNvcmVfYW5pbWF0aW9ucy5hZGRBbmltYXRpb24obWUsIGFuaW1hdGlvbiwgZHVyYXRpb24sIGxhenkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5kcmF3KCk7XG5cblx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzc4MVxuXHRcdFx0b25Db21wbGV0ZShuZXcgY29yZV9hbmltYXRpb24oe251bVN0ZXBzOiAwLCBjaGFydDogbWV9KSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgaSwgbGF5ZXJzO1xuXG5cdFx0bWUuY2xlYXIoKTtcblxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihlYXNpbmdWYWx1ZSkpIHtcblx0XHRcdGVhc2luZ1ZhbHVlID0gMTtcblx0XHR9XG5cblx0XHRtZS50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblxuXHRcdGlmIChtZS53aWR0aCA8PSAwIHx8IG1lLmhlaWdodCA8PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEcmF3JywgW2Vhc2luZ1ZhbHVlXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQmVjYXVzZSBvZiBwbHVnaW4gaG9va3MgKGJlZm9yZS9hZnRlckRhdGFzZXRzRHJhdyksIGRhdGFzZXRzIGNhbid0XG5cdFx0Ly8gY3VycmVudGx5IGJlIHBhcnQgb2YgbGF5ZXJzLiBJbnN0ZWFkLCB3ZSBkcmF3XG5cdFx0Ly8gbGF5ZXJzIDw9IDAgYmVmb3JlKGRlZmF1bHQsIGJhY2t3YXJkIGNvbXBhdCksIGFuZCB0aGUgcmVzdCBhZnRlclxuXHRcdGxheWVycyA9IG1lLl9sYXllcnM7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGggJiYgbGF5ZXJzW2ldLnogPD0gMDsgKytpKSB7XG5cdFx0XHRsYXllcnNbaV0uZHJhdyhtZS5jaGFydEFyZWEpO1xuXHRcdH1cblxuXHRcdG1lLmRyYXdEYXRhc2V0cyhlYXNpbmdWYWx1ZSk7XG5cblx0XHQvLyBSZXN0IG9mIGxheWVyc1xuXHRcdGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRsYXllcnNbaV0uZHJhdyhtZS5jaGFydEFyZWEpO1xuXHRcdH1cblxuXHRcdG1lLl9kcmF3VG9vbHRpcChlYXNpbmdWYWx1ZSk7XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEcmF3JywgW2Vhc2luZ1ZhbHVlXSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR0cmFuc2l0aW9uOiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgaWxlbiA9IChtZS5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGlmIChtZS5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXIudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUudG9vbHRpcC50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRTb3J0ZWREYXRhc2V0TWV0YXM6IGZ1bmN0aW9uKGZpbHRlclZpc2libGUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBkYXRhc2V0cyA9IG1lLmRhdGEuZGF0YXNldHMgfHwgW107XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKCFmaWx0ZXJWaXNpYmxlIHx8IG1lLmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0cmVzdWx0LnB1c2gobWUuZ2V0RGF0YXNldE1ldGEoaSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJlc3VsdC5zb3J0KGNvbXBhcmUyTGV2ZWwoJ29yZGVyJywgJ2luZGV4JykpO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKHRydWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzRHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNEcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRyYXdEYXRhc2V0czogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhc2V0cywgaTtcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRGF0YXNldHNEcmF3JywgW2Vhc2luZ1ZhbHVlXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bWV0YXNldHMgPSBtZS5fZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuXHRcdGZvciAoaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG5cdFx0XHRtZS5kcmF3RGF0YXNldChtZXRhc2V0c1tpXSwgZWFzaW5nVmFsdWUpO1xuXHRcdH1cblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXRzRHJhdycsIFtlYXNpbmdWYWx1ZV0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3cyBkYXRhc2V0IGF0IGluZGV4IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0RHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldERyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZHJhd0RhdGFzZXQ6IGZ1bmN0aW9uKG1ldGEsIGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgYXJncyA9IHtcblx0XHRcdG1ldGE6IG1ldGEsXG5cdFx0XHRpbmRleDogbWV0YS5pbmRleCxcblx0XHRcdGVhc2luZ1ZhbHVlOiBlYXNpbmdWYWx1ZVxuXHRcdH07XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXREcmF3JywgW2FyZ3NdKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRtZXRhLmNvbnRyb2xsZXIuZHJhdyhlYXNpbmdWYWx1ZSk7XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0RHJhdycsIFthcmdzXSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXdzIHRvb2x0aXAgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZVRvb2x0aXBEcmF3YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJUb29sdGlwRHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZHJhd1Rvb2x0aXA6IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdG9vbHRpcCA9IG1lLnRvb2x0aXA7XG5cdFx0dmFyIGFyZ3MgPSB7XG5cdFx0XHR0b29sdGlwOiB0b29sdGlwLFxuXHRcdFx0ZWFzaW5nVmFsdWU6IGVhc2luZ1ZhbHVlXG5cdFx0fTtcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlVG9vbHRpcERyYXcnLCBbYXJnc10pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRvb2x0aXAuZHJhdygpO1xuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyVG9vbHRpcERyYXcnLCBbYXJnc10pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHNpbmdsZSBlbGVtZW50IHRoYXQgd2FzIGNsaWNrZWQgb25cblx0ICogQHJldHVybiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YXNldCBpbmRleCBhbmQgZWxlbWVudCBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgZWxlbWVudC4gQWxzbyBjb250YWlucyB0aGUgcmVjdGFuZ2xlIHRoYXQgd2FzIGRyYXdcblx0ICovXG5cdGdldEVsZW1lbnRBdEV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXMuc2luZ2xlKHRoaXMsIGUpO1xuXHR9LFxuXG5cdGdldEVsZW1lbnRzQXRFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHJldHVybiBjb3JlX2ludGVyYWN0aW9uLm1vZGVzLmxhYmVsKHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcblx0fSxcblxuXHRnZXRFbGVtZW50c0F0WEF4aXM6IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gY29yZV9pbnRlcmFjdGlvbi5tb2Rlc1sneC1heGlzJ10odGhpcywgZSwge2ludGVyc2VjdDogdHJ1ZX0pO1xuXHR9LFxuXG5cdGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGU6IGZ1bmN0aW9uKGUsIG1vZGUsIG9wdGlvbnMpIHtcblx0XHR2YXIgbWV0aG9kID0gY29yZV9pbnRlcmFjdGlvbi5tb2Rlc1ttb2RlXTtcblx0XHRpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIG1ldGhvZCh0aGlzLCBlLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gW107XG5cdH0sXG5cblx0Z2V0RGF0YXNldEF0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gY29yZV9pbnRlcmFjdGlvbi5tb2Rlcy5kYXRhc2V0KHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcblx0fSxcblxuXHRnZXREYXRhc2V0TWV0YTogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgZGF0YXNldCA9IG1lLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcblx0XHRpZiAoIWRhdGFzZXQuX21ldGEpIHtcblx0XHRcdGRhdGFzZXQuX21ldGEgPSB7fTtcblx0XHR9XG5cblx0XHR2YXIgbWV0YSA9IGRhdGFzZXQuX21ldGFbbWUuaWRdO1xuXHRcdGlmICghbWV0YSkge1xuXHRcdFx0bWV0YSA9IGRhdGFzZXQuX21ldGFbbWUuaWRdID0ge1xuXHRcdFx0XHR0eXBlOiBudWxsLFxuXHRcdFx0XHRkYXRhOiBbXSxcblx0XHRcdFx0ZGF0YXNldDogbnVsbCxcblx0XHRcdFx0Y29udHJvbGxlcjogbnVsbCxcblx0XHRcdFx0aGlkZGVuOiBudWxsLFx0XHRcdC8vIFNlZSBpc0RhdGFzZXRWaXNpYmxlKCkgY29tbWVudFxuXHRcdFx0XHR4QXhpc0lEOiBudWxsLFxuXHRcdFx0XHR5QXhpc0lEOiBudWxsLFxuXHRcdFx0XHRvcmRlcjogZGF0YXNldC5vcmRlciB8fCAwLFxuXHRcdFx0XHRpbmRleDogZGF0YXNldEluZGV4XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiBtZXRhO1xuXHR9LFxuXG5cdGdldFZpc2libGVEYXRhc2V0Q291bnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb3VudCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRpZiAodGhpcy5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjb3VudDtcblx0fSxcblxuXHRpc0RhdGFzZXRWaXNpYmxlOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblxuXHRcdC8vIG1ldGEuaGlkZGVuIGlzIGEgcGVyIGNoYXJ0IGRhdGFzZXQgaGlkZGVuIGZsYWcgb3ZlcnJpZGUgd2l0aCAzIHN0YXRlczogaWYgdHJ1ZSBvciBmYWxzZSxcblx0XHQvLyB0aGUgZGF0YXNldC5oaWRkZW4gdmFsdWUgaXMgaWdub3JlZCwgZWxzZSBpZiBudWxsLCB0aGUgZGF0YXNldCBoaWRkZW4gc3RhdGUgaXMgcmV0dXJuZWQuXG5cdFx0cmV0dXJuIHR5cGVvZiBtZXRhLmhpZGRlbiA9PT0gJ2Jvb2xlYW4nID8gIW1ldGEuaGlkZGVuIDogIXRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmhpZGRlbjtcblx0fSxcblxuXHRnZW5lcmF0ZUxlZ2VuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5sZWdlbmRDYWxsYmFjayh0aGlzKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRlc3Ryb3lEYXRhc2V0TWV0YTogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIGlkID0gdGhpcy5pZDtcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuXHRcdHZhciBtZXRhID0gZGF0YXNldC5fbWV0YSAmJiBkYXRhc2V0Ll9tZXRhW2lkXTtcblxuXHRcdGlmIChtZXRhKSB7XG5cdFx0XHRtZXRhLmNvbnRyb2xsZXIuZGVzdHJveSgpO1xuXHRcdFx0ZGVsZXRlIGRhdGFzZXQuX21ldGFbaWRdO1xuXHRcdH1cblx0fSxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjYW52YXMgPSBtZS5jYW52YXM7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHRtZS5zdG9wKCk7XG5cblx0XHQvLyBkYXRhc2V0IGNvbnRyb2xsZXJzIG5lZWQgdG8gY2xlYW51cCBhc3NvY2lhdGVkIGRhdGFcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbWUuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1lLmRlc3Ryb3lEYXRhc2V0TWV0YShpKTtcblx0XHR9XG5cblx0XHRpZiAoY2FudmFzKSB7XG5cdFx0XHRtZS51bmJpbmRFdmVudHMoKTtcblx0XHRcdGhlbHBlcnMkMS5jYW52YXMuY2xlYXIobWUpO1xuXHRcdFx0cGxhdGZvcm0ucmVsZWFzZUNvbnRleHQobWUuY3R4KTtcblx0XHRcdG1lLmNhbnZhcyA9IG51bGw7XG5cdFx0XHRtZS5jdHggPSBudWxsO1xuXHRcdH1cblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdkZXN0cm95Jyk7XG5cblx0XHRkZWxldGUgQ2hhcnQuaW5zdGFuY2VzW21lLmlkXTtcblx0fSxcblxuXHR0b0Jhc2U2NEltYWdlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdGluaXRUb29sVGlwOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdG1lLnRvb2x0aXAgPSBuZXcgY29yZV90b29sdGlwKHtcblx0XHRcdF9jaGFydDogbWUsXG5cdFx0XHRfY2hhcnRJbnN0YW5jZTogbWUsIC8vIGRlcHJlY2F0ZWQsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0XHRcdF9kYXRhOiBtZS5kYXRhLFxuXHRcdFx0X29wdGlvbnM6IG1lLm9wdGlvbnMudG9vbHRpcHNcblx0XHR9LCBtZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRiaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsaXN0ZW5lcnMgPSBtZS5fbGlzdGVuZXJzID0ge307XG5cdFx0dmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRtZS5ldmVudEhhbmRsZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLm9wdGlvbnMuZXZlbnRzLCBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKG1lLCB0eXBlLCBsaXN0ZW5lcik7XG5cdFx0XHRsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcblx0XHR9KTtcblxuXHRcdC8vIEVsZW1lbnRzIHVzZWQgdG8gZGV0ZWN0IHNpemUgY2hhbmdlIHNob3VsZCBub3QgYmUgaW5qZWN0ZWQgZm9yIG5vbiByZXNwb25zaXZlIGNoYXJ0cy5cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzIyMTBcblx0XHRpZiAobWUub3B0aW9ucy5yZXNwb25zaXZlKSB7XG5cdFx0XHRsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRtZS5yZXNpemUoKTtcblx0XHRcdH07XG5cblx0XHRcdHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIobWUsICdyZXNpemUnLCBsaXN0ZW5lcik7XG5cdFx0XHRsaXN0ZW5lcnMucmVzaXplID0gbGlzdGVuZXI7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dW5iaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsaXN0ZW5lcnMgPSBtZS5fbGlzdGVuZXJzO1xuXHRcdGlmICghbGlzdGVuZXJzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIG1lLl9saXN0ZW5lcnM7XG5cdFx0aGVscGVycyQxLmVhY2gobGlzdGVuZXJzLCBmdW5jdGlvbihsaXN0ZW5lciwgdHlwZSkge1xuXHRcdFx0cGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHVwZGF0ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnRzLCBtb2RlLCBlbmFibGVkKSB7XG5cdFx0dmFyIHByZWZpeCA9IGVuYWJsZWQgPyAnc2V0JyA6ICdyZW1vdmUnO1xuXHRcdHZhciBlbGVtZW50LCBpLCBpbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0dGhpcy5nZXREYXRhc2V0TWV0YShlbGVtZW50Ll9kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXJbcHJlZml4ICsgJ0hvdmVyU3R5bGUnXShlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG5cdFx0XHR0aGlzLmdldERhdGFzZXRNZXRhKGVsZW1lbnRzWzBdLl9kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXJbJ18nICsgcHJlZml4ICsgJ0RhdGFzZXRIb3ZlclN0eWxlJ10oKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRldmVudEhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0b29sdGlwID0gbWUudG9vbHRpcDtcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRXZlbnQnLCBbZV0pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEJ1ZmZlciBhbnkgdXBkYXRlIGNhbGxzIHNvIHRoYXQgcmVuZGVycyBkbyBub3Qgb2NjdXJcblx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSB0cnVlO1xuXHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG5cdFx0dmFyIGNoYW5nZWQgPSBtZS5oYW5kbGVFdmVudChlKTtcblx0XHQvLyBmb3Igc21vb3RoIHRvb2x0aXAgYW5pbWF0aW9ucyBpc3N1ZSAjNDk4OVxuXHRcdC8vIHRoZSB0b29sdGlwIHNob3VsZCBiZSB0aGUgc291cmNlIG9mIGNoYW5nZVxuXHRcdC8vIEFuaW1hdGlvbiBjaGVjayB3b3JrYXJvdW5kOlxuXHRcdC8vIHRvb2x0aXAuX3N0YXJ0IHdpbGwgYmUgbnVsbCB3aGVuIHRvb2x0aXAgaXNuJ3QgYW5pbWF0aW5nXG5cdFx0aWYgKHRvb2x0aXApIHtcblx0XHRcdGNoYW5nZWQgPSB0b29sdGlwLl9zdGFydFxuXHRcdFx0XHQ/IHRvb2x0aXAuaGFuZGxlRXZlbnQoZSlcblx0XHRcdFx0OiBjaGFuZ2VkIHwgdG9vbHRpcC5oYW5kbGVFdmVudChlKTtcblx0XHR9XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJFdmVudCcsIFtlXSk7XG5cblx0XHR2YXIgYnVmZmVyZWRSZXF1ZXN0ID0gbWUuX2J1ZmZlcmVkUmVxdWVzdDtcblx0XHRpZiAoYnVmZmVyZWRSZXF1ZXN0KSB7XG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGFuIHVwZGF0ZSB0aGF0IHdhcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gZG8gYSBub3JtYWwgcmVuZGVyXG5cdFx0XHRtZS5yZW5kZXIoYnVmZmVyZWRSZXF1ZXN0KTtcblx0XHR9IGVsc2UgaWYgKGNoYW5nZWQgJiYgIW1lLmFuaW1hdGluZykge1xuXHRcdFx0Ly8gSWYgZW50ZXJpbmcsIGxlYXZpbmcsIG9yIGNoYW5naW5nIGVsZW1lbnRzLCBhbmltYXRlIHRoZSBjaGFuZ2UgdmlhIHBpdm90XG5cdFx0XHRtZS5zdG9wKCk7XG5cblx0XHRcdC8vIFdlIG9ubHkgbmVlZCB0byByZW5kZXIgYXQgdGhpcyBwb2ludC4gVXBkYXRpbmcgd2lsbCBjYXVzZSBzY2FsZXMgdG8gYmVcblx0XHRcdC8vIHJlY29tcHV0ZWQgZ2VuZXJhdGluZyBmbGlja2VyICYgdXNpbmcgbW9yZSBtZW1vcnkgdGhhbiBuZWNlc3NhcnkuXG5cdFx0XHRtZS5yZW5kZXIoe1xuXHRcdFx0XHRkdXJhdGlvbjogbWUub3B0aW9ucy5ob3Zlci5hbmltYXRpb25EdXJhdGlvbixcblx0XHRcdFx0bGF6eTogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XG5cdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgdGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBjaGFydCBuZWVkcyB0byByZS1yZW5kZXJcblx0ICovXG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnMgfHwge307XG5cdFx0dmFyIGhvdmVyT3B0aW9ucyA9IG9wdGlvbnMuaG92ZXI7XG5cdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdG1lLmxhc3RBY3RpdmUgPSBtZS5sYXN0QWN0aXZlIHx8IFtdO1xuXG5cdFx0Ly8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIGhvdmVyIGFuZCB0b29sdGlwc1xuXHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcblx0XHRcdG1lLmFjdGl2ZSA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5hY3RpdmUgPSBtZS5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdC8vIEludm9rZSBvbkhvdmVyIGhvb2tcblx0XHQvLyBOZWVkIHRvIGNhbGwgd2l0aCBuYXRpdmUgZXZlbnQgaGVyZSB0byBub3QgYnJlYWsgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyIHx8IG9wdGlvbnMuaG92ZXIub25Ib3ZlciwgW2UubmF0aXZlLCBtZS5hY3RpdmVdLCBtZSk7XG5cblx0XHRpZiAoZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5vbkNsaWNrKSB7XG5cdFx0XHRcdC8vIFVzZSBlLm5hdGl2ZSBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRvcHRpb25zLm9uQ2xpY2suY2FsbChtZSwgZS5uYXRpdmUsIG1lLmFjdGl2ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHN0eWxpbmcgZm9yIGxhc3QgYWN0aXZlIChldmVuIGlmIGl0IG1heSBzdGlsbCBiZSBhY3RpdmUpXG5cdFx0aWYgKG1lLmxhc3RBY3RpdmUubGVuZ3RoKSB7XG5cdFx0XHRtZS51cGRhdGVIb3ZlclN0eWxlKG1lLmxhc3RBY3RpdmUsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQnVpbHQgaW4gaG92ZXIgc3R5bGluZ1xuXHRcdGlmIChtZS5hY3RpdmUubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG5cdFx0XHRtZS51cGRhdGVIb3ZlclN0eWxlKG1lLmFjdGl2ZSwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xuXHRcdH1cblxuXHRcdGNoYW5nZWQgPSAhaGVscGVycyQxLmFycmF5RXF1YWxzKG1lLmFjdGl2ZSwgbWUubGFzdEFjdGl2ZSk7XG5cblx0XHQvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcblx0XHRtZS5sYXN0QWN0aXZlID0gbWUuYWN0aXZlO1xuXG5cdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdH1cbn0pO1xuXG4vKipcbiAqIE5PVEUoU0IpIFdlIGFjdHVhbGx5IGRvbid0IHVzZSB0aGlzIGNvbnRhaW5lciBhbnltb3JlIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgaXRcbiAqIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBUaG91Z2gsIGl0IGNhbiBzdGlsbCBiZSB1c2VmdWwgZm9yIHBsdWdpbnMgdGhhdFxuICogd291bGQgbmVlZCB0byB3b3JrIG9uIG11bHRpcGxlIGNoYXJ0cz8hXG4gKi9cbkNoYXJ0Lmluc3RhbmNlcyA9IHt9O1xuXG52YXIgY29yZV9jb250cm9sbGVyID0gQ2hhcnQ7XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQgaW5zdGVhZC5cbiAqIEBjbGFzcyBDaGFydC5Db250cm9sbGVyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNlxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuQ2hhcnQuQ29udHJvbGxlciA9IENoYXJ0O1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXG4gKiBAbmFtZXNwYWNlIENoYXJ0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuQ2hhcnQudHlwZXMgPSB7fTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNvbmZpZ01lcmdlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzJDEuY29uZmlnTWVyZ2UgPSBtZXJnZUNvbmZpZztcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLnNjYWxlTWVyZ2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMkMS5zY2FsZU1lcmdlID0gbWVyZ2VTY2FsZUNvbmZpZztcblxudmFyIGNvcmVfaGVscGVycyA9IGZ1bmN0aW9uKCkge1xuXG5cdC8vIC0tIEJhc2ljIGpzIHV0aWxpdHkgbWV0aG9kc1xuXG5cdGhlbHBlcnMkMS53aGVyZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGZpbHRlckNhbGxiYWNrKSB7XG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGNvbGxlY3Rpb24pICYmIEFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHtcblx0XHRcdHJldHVybiBjb2xsZWN0aW9uLmZpbHRlcihmaWx0ZXJDYWxsYmFjayk7XG5cdFx0fVxuXHRcdHZhciBmaWx0ZXJlZCA9IFtdO1xuXG5cdFx0aGVscGVycyQxLmVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0aWYgKGZpbHRlckNhbGxiYWNrKGl0ZW0pKSB7XG5cdFx0XHRcdGZpbHRlcmVkLnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZmlsdGVyZWQ7XG5cdH07XG5cdGhlbHBlcnMkMS5maW5kSW5kZXggPSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4ID9cblx0XHRmdW5jdGlvbihhcnJheSwgY2FsbGJhY2ssIHNjb3BlKSB7XG5cdFx0XHRyZXR1cm4gYXJyYXkuZmluZEluZGV4KGNhbGxiYWNrLCBzY29wZSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrLCBzY29wZSkge1xuXHRcdFx0c2NvcGUgPSBzY29wZSA9PT0gdW5kZWZpbmVkID8gYXJyYXkgOiBzY29wZTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmIChjYWxsYmFjay5jYWxsKHNjb3BlLCBhcnJheVtpXSwgaSwgYXJyYXkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiAtMTtcblx0XHR9O1xuXHRoZWxwZXJzJDEuZmluZE5leHRXaGVyZSA9IGZ1bmN0aW9uKGFycmF5VG9TZWFyY2gsIGZpbHRlckNhbGxiYWNrLCBzdGFydEluZGV4KSB7XG5cdFx0Ly8gRGVmYXVsdCB0byBzdGFydCBvZiB0aGUgYXJyYXlcblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoc3RhcnRJbmRleCkpIHtcblx0XHRcdHN0YXJ0SW5kZXggPSAtMTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggKyAxOyBpIDwgYXJyYXlUb1NlYXJjaC5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGN1cnJlbnRJdGVtID0gYXJyYXlUb1NlYXJjaFtpXTtcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRJdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aGVscGVycyQxLmZpbmRQcmV2aW91c1doZXJlID0gZnVuY3Rpb24oYXJyYXlUb1NlYXJjaCwgZmlsdGVyQ2FsbGJhY2ssIHN0YXJ0SW5kZXgpIHtcblx0XHQvLyBEZWZhdWx0IHRvIGVuZCBvZiB0aGUgYXJyYXlcblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoc3RhcnRJbmRleCkpIHtcblx0XHRcdHN0YXJ0SW5kZXggPSBhcnJheVRvU2VhcmNoLmxlbmd0aDtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGN1cnJlbnRJdGVtID0gYXJyYXlUb1NlYXJjaFtpXTtcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRJdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvLyAtLSBNYXRoIG1ldGhvZHNcblx0aGVscGVycyQxLmlzTnVtYmVyID0gZnVuY3Rpb24obikge1xuXHRcdHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG5cdH07XG5cdGhlbHBlcnMkMS5hbG1vc3RFcXVhbHMgPSBmdW5jdGlvbih4LCB5LCBlcHNpbG9uKSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XG5cdH07XG5cdGhlbHBlcnMkMS5hbG1vc3RXaG9sZSA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcblx0XHR2YXIgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG5cdFx0cmV0dXJuICgocm91bmRlZCAtIGVwc2lsb24pIDw9IHgpICYmICgocm91bmRlZCArIGVwc2lsb24pID49IHgpO1xuXHR9O1xuXHRoZWxwZXJzJDEubWF4ID0gZnVuY3Rpb24oYXJyYXkpIHtcblx0XHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKG1heCwgdmFsdWUpIHtcblx0XHRcdGlmICghaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLm1heChtYXgsIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXg7XG5cdFx0fSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcblx0fTtcblx0aGVscGVycyQxLm1pbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdFx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihtaW4sIHZhbHVlKSB7XG5cdFx0XHRpZiAoIWlzTmFOKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5taW4obWluLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWluO1xuXHRcdH0sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG5cdH07XG5cdGhlbHBlcnMkMS5zaWduID0gTWF0aC5zaWduID9cblx0XHRmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5zaWduKHgpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKHgpIHtcblx0XHRcdHggPSAreDsgLy8gY29udmVydCB0byBhIG51bWJlclxuXHRcdFx0aWYgKHggPT09IDAgfHwgaXNOYU4oeCkpIHtcblx0XHRcdFx0cmV0dXJuIHg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geCA+IDAgPyAxIDogLTE7XG5cdFx0fTtcblx0aGVscGVycyQxLnRvUmFkaWFucyA9IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcblx0XHRyZXR1cm4gZGVncmVlcyAqIChNYXRoLlBJIC8gMTgwKTtcblx0fTtcblx0aGVscGVycyQxLnRvRGVncmVlcyA9IGZ1bmN0aW9uKHJhZGlhbnMpIHtcblx0XHRyZXR1cm4gcmFkaWFucyAqICgxODAgLyBNYXRoLlBJKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG5cdCAqIGkuZS4gdGhlIG51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQsIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIE51bWJlci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBBIG51bWJlci5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGhlbHBlcnMkMS5fZGVjaW1hbFBsYWNlcyA9IGZ1bmN0aW9uKHgpIHtcblx0XHRpZiAoIWhlbHBlcnMkMS5pc0Zpbml0ZSh4KSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgZSA9IDE7XG5cdFx0dmFyIHAgPSAwO1xuXHRcdHdoaWxlIChNYXRoLnJvdW5kKHggKiBlKSAvIGUgIT09IHgpIHtcblx0XHRcdGUgKj0gMTA7XG5cdFx0XHRwKys7XG5cdFx0fVxuXHRcdHJldHVybiBwO1xuXHR9O1xuXG5cdC8vIEdldHMgdGhlIGFuZ2xlIGZyb20gdmVydGljYWwgdXByaWdodCB0byB0aGUgcG9pbnQgYWJvdXQgYSBjZW50cmUuXG5cdGhlbHBlcnMkMS5nZXRBbmdsZUZyb21Qb2ludCA9IGZ1bmN0aW9uKGNlbnRyZVBvaW50LCBhbmdsZVBvaW50KSB7XG5cdFx0dmFyIGRpc3RhbmNlRnJvbVhDZW50ZXIgPSBhbmdsZVBvaW50LnggLSBjZW50cmVQb2ludC54O1xuXHRcdHZhciBkaXN0YW5jZUZyb21ZQ2VudGVyID0gYW5nbGVQb2ludC55IC0gY2VudHJlUG9pbnQueTtcblx0XHR2YXIgcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xuXG5cdFx0dmFyIGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcblxuXHRcdGlmIChhbmdsZSA8ICgtMC41ICogTWF0aC5QSSkpIHtcblx0XHRcdGFuZ2xlICs9IDIuMCAqIE1hdGguUEk7IC8vIG1ha2Ugc3VyZSB0aGUgcmV0dXJuZWQgYW5nbGUgaXMgaW4gdGhlIHJhbmdlIG9mICgtUEkvMiwgM1BJLzJdXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFuZ2xlOiBhbmdsZSxcblx0XHRcdGRpc3RhbmNlOiByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXJcblx0XHR9O1xuXHR9O1xuXHRoZWxwZXJzJDEuZGlzdGFuY2VCZXR3ZWVuUG9pbnRzID0gZnVuY3Rpb24ocHQxLCBwdDIpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHB0Mi54IC0gcHQxLngsIDIpICsgTWF0aC5wb3cocHQyLnkgLSBwdDEueSwgMikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlXG5cdCAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmFsaWFzUGl4ZWxcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdCAqL1xuXHRoZWxwZXJzJDEuYWxpYXNQaXhlbCA9IGZ1bmN0aW9uKHBpeGVsV2lkdGgpIHtcblx0XHRyZXR1cm4gKHBpeGVsV2lkdGggJSAyID09PSAwKSA/IDAgOiAwLjU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFsaWduZWQgcGl4ZWwgdmFsdWUgdG8gYXZvaWQgYW50aS1hbGlhc2luZyBibHVyXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWwgLSBBIHBpeGVsIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGVsZW1lbnQuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aGVscGVycyQxLl9hbGlnblBpeGVsID0gZnVuY3Rpb24oY2hhcnQsIHBpeGVsLCB3aWR0aCkge1xuXHRcdHZhciBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG5cdFx0dmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xuXHR9O1xuXG5cdGhlbHBlcnMkMS5zcGxpbmVDdXJ2ZSA9IGZ1bmN0aW9uKGZpcnN0UG9pbnQsIG1pZGRsZVBvaW50LCBhZnRlclBvaW50LCB0KSB7XG5cdFx0Ly8gUHJvcHMgdG8gUm9iIFNwZW5jZXIgYXQgc2NhbGVkIGlubm92YXRpb24gZm9yIGhpcyBwb3N0IG9uIHNwbGluaW5nIGJldHdlZW4gcG9pbnRzXG5cdFx0Ly8gaHR0cDovL3NjYWxlZGlubm92YXRpb24uY29tL2FuYWx5dGljcy9zcGxpbmVzL2Fib3V0U3BsaW5lcy5odG1sXG5cblx0XHQvLyBUaGlzIGZ1bmN0aW9uIG11c3QgYWxzbyByZXNwZWN0IFwic2tpcHBlZFwiIHBvaW50c1xuXG5cdFx0dmFyIHByZXZpb3VzID0gZmlyc3RQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBmaXJzdFBvaW50O1xuXHRcdHZhciBjdXJyZW50ID0gbWlkZGxlUG9pbnQ7XG5cdFx0dmFyIG5leHQgPSBhZnRlclBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGFmdGVyUG9pbnQ7XG5cblx0XHR2YXIgZDAxID0gTWF0aC5zcXJ0KE1hdGgucG93KGN1cnJlbnQueCAtIHByZXZpb3VzLngsIDIpICsgTWF0aC5wb3coY3VycmVudC55IC0gcHJldmlvdXMueSwgMikpO1xuXHRcdHZhciBkMTIgPSBNYXRoLnNxcnQoTWF0aC5wb3cobmV4dC54IC0gY3VycmVudC54LCAyKSArIE1hdGgucG93KG5leHQueSAtIGN1cnJlbnQueSwgMikpO1xuXG5cdFx0dmFyIHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuXHRcdHZhciBzMTIgPSBkMTIgLyAoZDAxICsgZDEyKTtcblxuXHRcdC8vIElmIGFsbCBwb2ludHMgYXJlIHRoZSBzYW1lLCBzMDEgJiBzMDIgd2lsbCBiZSBpbmZcblx0XHRzMDEgPSBpc05hTihzMDEpID8gMCA6IHMwMTtcblx0XHRzMTIgPSBpc05hTihzMTIpID8gMCA6IHMxMjtcblxuXHRcdHZhciBmYSA9IHQgKiBzMDE7IC8vIHNjYWxpbmcgZmFjdG9yIGZvciB0cmlhbmdsZSBUYVxuXHRcdHZhciBmYiA9IHQgKiBzMTI7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0cHJldmlvdXM6IHtcblx0XHRcdFx0eDogY3VycmVudC54IC0gZmEgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG5cdFx0XHRcdHk6IGN1cnJlbnQueSAtIGZhICogKG5leHQueSAtIHByZXZpb3VzLnkpXG5cdFx0XHR9LFxuXHRcdFx0bmV4dDoge1xuXHRcdFx0XHR4OiBjdXJyZW50LnggKyBmYiAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcblx0XHRcdFx0eTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXHRoZWxwZXJzJDEuRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuXHRoZWxwZXJzJDEuc3BsaW5lQ3VydmVNb25vdG9uZSA9IGZ1bmN0aW9uKHBvaW50cykge1xuXHRcdC8vIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyBCw6l6aWVyIGNvbnRyb2wgcG9pbnRzIGluIGEgc2ltaWxhciB3YXkgdGhhbiB8c3BsaW5lQ3VydmV8LFxuXHRcdC8vIGJ1dCBwcmVzZXJ2ZXMgbW9ub3RvbmljaXR5IG9mIHRoZSBwcm92aWRlZCBkYXRhIGFuZCBlbnN1cmVzIG5vIGxvY2FsIGV4dHJlbXVtcyBhcmUgYWRkZWRcblx0XHQvLyBiZXR3ZWVuIHRoZSBkYXRhc2V0IGRpc2NyZXRlIHBvaW50cyBkdWUgdG8gdGhlIGludGVycG9sYXRpb24uXG5cdFx0Ly8gU2VlIDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9ub3RvbmVfY3ViaWNfaW50ZXJwb2xhdGlvblxuXG5cdFx0dmFyIHBvaW50c1dpdGhUYW5nZW50cyA9IChwb2ludHMgfHwgW10pLm1hcChmdW5jdGlvbihwb2ludCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bW9kZWw6IHBvaW50Ll9tb2RlbCxcblx0XHRcdFx0ZGVsdGFLOiAwLFxuXHRcdFx0XHRtSzogMFxuXHRcdFx0fTtcblx0XHR9KTtcblxuXHRcdC8vIENhbGN1bGF0ZSBzbG9wZXMgKGRlbHRhSykgYW5kIGluaXRpYWxpemUgdGFuZ2VudHMgKG1LKVxuXHRcdHZhciBwb2ludHNMZW4gPSBwb2ludHNXaXRoVGFuZ2VudHMubGVuZ3RoO1xuXHRcdHZhciBpLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50LCBwb2ludEFmdGVyO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuXHRcdFx0cG9pbnRDdXJyZW50ID0gcG9pbnRzV2l0aFRhbmdlbnRzW2ldO1xuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRwb2ludEJlZm9yZSA9IGkgPiAwID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgLSAxXSA6IG51bGw7XG5cdFx0XHRwb2ludEFmdGVyID0gaSA8IHBvaW50c0xlbiAtIDEgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdIDogbnVsbDtcblx0XHRcdGlmIChwb2ludEFmdGVyICYmICFwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0dmFyIHNsb3BlRGVsdGFYID0gKHBvaW50QWZ0ZXIubW9kZWwueCAtIHBvaW50Q3VycmVudC5tb2RlbC54KTtcblxuXHRcdFx0XHQvLyBJbiB0aGUgY2FzZSBvZiB0d28gcG9pbnRzIHRoYXQgYXBwZWFyIGF0IHRoZSBzYW1lIHggcGl4ZWwsIHNsb3BlRGVsdGFYIGlzIDBcblx0XHRcdFx0cG9pbnRDdXJyZW50LmRlbHRhSyA9IHNsb3BlRGVsdGFYICE9PSAwID8gKHBvaW50QWZ0ZXIubW9kZWwueSAtIHBvaW50Q3VycmVudC5tb2RlbC55KSAvIHNsb3BlRGVsdGFYIDogMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFwb2ludEJlZm9yZSB8fCBwb2ludEJlZm9yZS5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0XHR9IGVsc2UgaWYgKCFwb2ludEFmdGVyIHx8IHBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEJlZm9yZS5kZWx0YUs7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuc2lnbihwb2ludEJlZm9yZS5kZWx0YUspICE9PSB0aGlzLnNpZ24ocG9pbnRDdXJyZW50LmRlbHRhSykpIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IChwb2ludEJlZm9yZS5kZWx0YUsgKyBwb2ludEN1cnJlbnQuZGVsdGFLKSAvIDI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRqdXN0IHRhbmdlbnRzIHRvIGVuc3VyZSBtb25vdG9uaWMgcHJvcGVydGllc1xuXHRcdHZhciBhbHBoYUssIGJldGFLLCB0YXVLLCBzcXVhcmVkTWFnbml0dWRlO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW4gLSAxOyArK2kpIHtcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcblx0XHRcdHBvaW50QWZ0ZXIgPSBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdO1xuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwIHx8IHBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGhlbHBlcnMkMS5hbG1vc3RFcXVhbHMocG9pbnRDdXJyZW50LmRlbHRhSywgMCwgdGhpcy5FUFNJTE9OKSkge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEFmdGVyLm1LID0gMDtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGFscGhhSyA9IHBvaW50Q3VycmVudC5tSyAvIHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0XHRiZXRhSyA9IHBvaW50QWZ0ZXIubUsgLyBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0c3F1YXJlZE1hZ25pdHVkZSA9IE1hdGgucG93KGFscGhhSywgMikgKyBNYXRoLnBvdyhiZXRhSywgMik7XG5cdFx0XHRpZiAoc3F1YXJlZE1hZ25pdHVkZSA8PSA5KSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR0YXVLID0gMyAvIE1hdGguc3FydChzcXVhcmVkTWFnbml0dWRlKTtcblx0XHRcdHBvaW50Q3VycmVudC5tSyA9IGFscGhhSyAqIHRhdUsgKiBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0cG9pbnRBZnRlci5tSyA9IGJldGFLICogdGF1SyAqIHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZSBjb250cm9sIHBvaW50c1xuXHRcdHZhciBkZWx0YVg7XG5cdFx0Zm9yIChpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG5cdFx0XHRwb2ludEN1cnJlbnQgPSBwb2ludHNXaXRoVGFuZ2VudHNbaV07XG5cdFx0XHRpZiAocG9pbnRDdXJyZW50Lm1vZGVsLnNraXApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHBvaW50QmVmb3JlID0gaSA+IDAgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSAtIDFdIDogbnVsbDtcblx0XHRcdHBvaW50QWZ0ZXIgPSBpIDwgcG9pbnRzTGVuIC0gMSA/IHBvaW50c1dpdGhUYW5nZW50c1tpICsgMV0gOiBudWxsO1xuXHRcdFx0aWYgKHBvaW50QmVmb3JlICYmICFwb2ludEJlZm9yZS5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGRlbHRhWCA9IChwb2ludEN1cnJlbnQubW9kZWwueCAtIHBvaW50QmVmb3JlLm1vZGVsLngpIC8gMztcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCA9IHBvaW50Q3VycmVudC5tb2RlbC54IC0gZGVsdGFYO1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gcG9pbnRDdXJyZW50Lm1vZGVsLnkgLSBkZWx0YVggKiBwb2ludEN1cnJlbnQubUs7XG5cdFx0XHR9XG5cdFx0XHRpZiAocG9pbnRBZnRlciAmJiAhcG9pbnRBZnRlci5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGRlbHRhWCA9IChwb2ludEFmdGVyLm1vZGVsLnggLSBwb2ludEN1cnJlbnQubW9kZWwueCkgLyAzO1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBwb2ludEN1cnJlbnQubW9kZWwueCArIGRlbHRhWDtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludE5leHRZID0gcG9pbnRDdXJyZW50Lm1vZGVsLnkgKyBkZWx0YVggKiBwb2ludEN1cnJlbnQubUs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRoZWxwZXJzJDEubmV4dEl0ZW0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpbmRleCwgbG9vcCkge1xuXHRcdGlmIChsb29wKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggPj0gY29sbGVjdGlvbi5sZW5ndGggLSAxID8gY29sbGVjdGlvblswXSA6IGNvbGxlY3Rpb25baW5kZXggKyAxXTtcblx0XHR9XG5cdFx0cmV0dXJuIGluZGV4ID49IGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSA/IGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXSA6IGNvbGxlY3Rpb25baW5kZXggKyAxXTtcblx0fTtcblx0aGVscGVycyQxLnByZXZpb3VzSXRlbSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGluZGV4LCBsb29wKSB7XG5cdFx0aWYgKGxvb3ApIHtcblx0XHRcdHJldHVybiBpbmRleCA8PSAwID8gY29sbGVjdGlvbltjb2xsZWN0aW9uLmxlbmd0aCAtIDFdIDogY29sbGVjdGlvbltpbmRleCAtIDFdO1xuXHRcdH1cblx0XHRyZXR1cm4gaW5kZXggPD0gMCA/IGNvbGxlY3Rpb25bMF0gOiBjb2xsZWN0aW9uW2luZGV4IC0gMV07XG5cdH07XG5cdC8vIEltcGxlbWVudGF0aW9uIG9mIHRoZSBuaWNlIG51bWJlciBhbGdvcml0aG0gdXNlZCBpbiBkZXRlcm1pbmluZyB3aGVyZSBheGlzIGxhYmVscyB3aWxsIGdvXG5cdGhlbHBlcnMkMS5uaWNlTnVtID0gZnVuY3Rpb24ocmFuZ2UsIHJvdW5kKSB7XG5cdFx0dmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAocmFuZ2UpKTtcblx0XHR2YXIgZnJhY3Rpb24gPSByYW5nZSAvIE1hdGgucG93KDEwLCBleHBvbmVudCk7XG5cdFx0dmFyIG5pY2VGcmFjdGlvbjtcblxuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0aWYgKGZyYWN0aW9uIDwgMS41KSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDwgMykge1xuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAyO1xuXHRcdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8IDcpIHtcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gNTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDEwO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gMS4wKSB7XG5cdFx0XHRuaWNlRnJhY3Rpb24gPSAxO1xuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gMikge1xuXHRcdFx0bmljZUZyYWN0aW9uID0gMjtcblx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDw9IDUpIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDEwO1xuXHRcdH1cblxuXHRcdHJldHVybiBuaWNlRnJhY3Rpb24gKiBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuXHR9O1xuXHQvLyBSZXF1ZXN0IGFuaW1hdGlvbiBwb2x5ZmlsbCAtIGh0dHBzOi8vd3d3LnBhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cblx0aGVscGVycyQxLnJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHR3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHR3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHR3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHRmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0XHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG5cdFx0XHR9O1xuXHR9KCkpO1xuXHQvLyAtLSBET00gbWV0aG9kc1xuXHRoZWxwZXJzJDEuZ2V0UmVsYXRpdmVQb3NpdGlvbiA9IGZ1bmN0aW9uKGV2dCwgY2hhcnQpIHtcblx0XHR2YXIgbW91c2VYLCBtb3VzZVk7XG5cdFx0dmFyIGUgPSBldnQub3JpZ2luYWxFdmVudCB8fCBldnQ7XG5cdFx0dmFyIGNhbnZhcyA9IGV2dC50YXJnZXQgfHwgZXZ0LnNyY0VsZW1lbnQ7XG5cdFx0dmFyIGJvdW5kaW5nUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdHZhciB0b3VjaGVzID0gZS50b3VjaGVzO1xuXHRcdGlmICh0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0bW91c2VYID0gdG91Y2hlc1swXS5jbGllbnRYO1xuXHRcdFx0bW91c2VZID0gdG91Y2hlc1swXS5jbGllbnRZO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1vdXNlWCA9IGUuY2xpZW50WDtcblx0XHRcdG1vdXNlWSA9IGUuY2xpZW50WTtcblx0XHR9XG5cblx0XHQvLyBTY2FsZSBtb3VzZSBjb29yZGluYXRlcyBpbnRvIGNhbnZhcyBjb29yZGluYXRlc1xuXHRcdC8vIGJ5IGZvbGxvd2luZyB0aGUgcGF0dGVybiBsYWlkIG91dCBieSAnamVycnlqJyBpbiB0aGUgY29tbWVudHMgb2Zcblx0XHQvLyBodHRwczovL3d3dy5odG1sNWNhbnZhc3R1dG9yaWFscy5jb20vYWR2YW5jZWQvaHRtbDUtY2FudmFzLW1vdXNlLWNvb3JkaW5hdGVzL1xuXHRcdHZhciBwYWRkaW5nTGVmdCA9IHBhcnNlRmxvYXQoaGVscGVycyQxLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctbGVmdCcpKTtcblx0XHR2YXIgcGFkZGluZ1RvcCA9IHBhcnNlRmxvYXQoaGVscGVycyQxLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctdG9wJykpO1xuXHRcdHZhciBwYWRkaW5nUmlnaHQgPSBwYXJzZUZsb2F0KGhlbHBlcnMkMS5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLXJpZ2h0JykpO1xuXHRcdHZhciBwYWRkaW5nQm90dG9tID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1ib3R0b20nKSk7XG5cdFx0dmFyIHdpZHRoID0gYm91bmRpbmdSZWN0LnJpZ2h0IC0gYm91bmRpbmdSZWN0LmxlZnQgLSBwYWRkaW5nTGVmdCAtIHBhZGRpbmdSaWdodDtcblx0XHR2YXIgaGVpZ2h0ID0gYm91bmRpbmdSZWN0LmJvdHRvbSAtIGJvdW5kaW5nUmVjdC50b3AgLSBwYWRkaW5nVG9wIC0gcGFkZGluZ0JvdHRvbTtcblxuXHRcdC8vIFdlIGRpdmlkZSBieSB0aGUgY3VycmVudCBkZXZpY2UgcGl4ZWwgcmF0aW8sIGJlY2F1c2UgdGhlIGNhbnZhcyBpcyBzY2FsZWQgdXAgYnkgdGhhdCBhbW91bnQgaW4gZWFjaCBkaXJlY3Rpb24uIEhvd2V2ZXJcblx0XHQvLyB0aGUgYmFja2VuZCBtb2RlbCBpcyBpbiB1bnNjYWxlZCBjb29yZGluYXRlcy4gU2luY2Ugd2UgYXJlIGdvaW5nIHRvIGRlYWwgd2l0aCBvdXIgbW9kZWwgY29vcmRpbmF0ZXMsIHdlIGdvIGJhY2sgaGVyZVxuXHRcdG1vdXNlWCA9IE1hdGgucm91bmQoKG1vdXNlWCAtIGJvdW5kaW5nUmVjdC5sZWZ0IC0gcGFkZGluZ0xlZnQpIC8gKHdpZHRoKSAqIGNhbnZhcy53aWR0aCAvIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKTtcblx0XHRtb3VzZVkgPSBNYXRoLnJvdW5kKChtb3VzZVkgLSBib3VuZGluZ1JlY3QudG9wIC0gcGFkZGluZ1RvcCkgLyAoaGVpZ2h0KSAqIGNhbnZhcy5oZWlnaHQgLyBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogbW91c2VYLFxuXHRcdFx0eTogbW91c2VZXG5cdFx0fTtcblxuXHR9O1xuXG5cdC8vIFByaXZhdGUgaGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgbWF4LXdpZHRoL21heC1oZWlnaHQgdmFsdWVzIHRoYXQgbWF5IGJlIHBlcmNlbnRhZ2VzIGludG8gYSBudW1iZXJcblx0ZnVuY3Rpb24gcGFyc2VNYXhTdHlsZShzdHlsZVZhbHVlLCBub2RlLCBwYXJlbnRQcm9wZXJ0eSkge1xuXHRcdHZhciB2YWx1ZUluUGl4ZWxzO1xuXHRcdGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhbHVlSW5QaXhlbHMgPSBwYXJzZUludChzdHlsZVZhbHVlLCAxMCk7XG5cblx0XHRcdGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcblx0XHRcdFx0Ly8gcGVyY2VudGFnZSAqIHNpemUgaW4gZGltZW5zaW9uXG5cdFx0XHRcdHZhbHVlSW5QaXhlbHMgPSB2YWx1ZUluUGl4ZWxzIC8gMTAwICogbm9kZS5wYXJlbnROb2RlW3BhcmVudFByb3BlcnR5XTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWVJblBpeGVscyA9IHN0eWxlVmFsdWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlSW5QaXhlbHM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBpZiB0aGUgZ2l2ZW4gdmFsdWUgY29udGFpbnMgYW4gZWZmZWN0aXZlIGNvbnN0cmFpbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0NvbnN0cmFpbmVkVmFsdWUodmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gJ25vbmUnO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG1heCB3aWR0aCBvciBoZWlnaHQgb2YgdGhlIGdpdmVuIERPTSBub2RlIGluIGEgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmxlIGZhc2hpb25cblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tTm9kZSAtIHRoZSBub2RlIHRvIGNoZWNrIHRoZSBjb25zdHJhaW50IG9uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtYXhTdHlsZSAtIHRoZSBzdHlsZSB0aGF0IGRlZmluZXMgdGhlIG1heGltdW0gZm9yIHRoZSBkaXJlY3Rpb24gd2UgYXJlIHVzaW5nICgnbWF4LXdpZHRoJyAvICdtYXgtaGVpZ2h0Jylcblx0ICogQHBhcmFtIHtzdHJpbmd9IHBlcmNlbnRhZ2VQcm9wZXJ0eSAtIHByb3BlcnR5IG9mIHBhcmVudCB0byB1c2Ugd2hlbiBjYWxjdWxhdGluZyB3aWR0aCBhcyBhIHBlcmNlbnRhZ2Vcblx0ICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cubmF0aGFuYWVsam9uZXMuY29tL2Jsb2cvMjAxMy9yZWFkaW5nLW1heC13aWR0aC1jcm9zcy1icm93c2VyfVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCBtYXhTdHlsZSwgcGVyY2VudGFnZVByb3BlcnR5KSB7XG5cdFx0dmFyIHZpZXcgPSBkb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHR2YXIgcGFyZW50Tm9kZSA9IGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZShkb21Ob2RlKTtcblx0XHR2YXIgY29uc3RyYWluZWROb2RlID0gdmlldy5nZXRDb21wdXRlZFN0eWxlKGRvbU5vZGUpW21heFN0eWxlXTtcblx0XHR2YXIgY29uc3RyYWluZWRDb250YWluZXIgPSB2aWV3LmdldENvbXB1dGVkU3R5bGUocGFyZW50Tm9kZSlbbWF4U3R5bGVdO1xuXHRcdHZhciBoYXNDTm9kZSA9IGlzQ29uc3RyYWluZWRWYWx1ZShjb25zdHJhaW5lZE5vZGUpO1xuXHRcdHZhciBoYXNDQ29udGFpbmVyID0gaXNDb25zdHJhaW5lZFZhbHVlKGNvbnN0cmFpbmVkQ29udGFpbmVyKTtcblx0XHR2YXIgaW5maW5pdHkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cblx0XHRpZiAoaGFzQ05vZGUgfHwgaGFzQ0NvbnRhaW5lcikge1xuXHRcdFx0cmV0dXJuIE1hdGgubWluKFxuXHRcdFx0XHRoYXNDTm9kZSA/IHBhcnNlTWF4U3R5bGUoY29uc3RyYWluZWROb2RlLCBkb21Ob2RlLCBwZXJjZW50YWdlUHJvcGVydHkpIDogaW5maW5pdHksXG5cdFx0XHRcdGhhc0NDb250YWluZXIgPyBwYXJzZU1heFN0eWxlKGNvbnN0cmFpbmVkQ29udGFpbmVyLCBwYXJlbnROb2RlLCBwZXJjZW50YWdlUHJvcGVydHkpIDogaW5maW5pdHkpO1xuXHRcdH1cblxuXHRcdHJldHVybiAnbm9uZSc7XG5cdH1cblx0Ly8gcmV0dXJucyBOdW1iZXIgb3IgdW5kZWZpbmVkIGlmIG5vIGNvbnN0cmFpbnRcblx0aGVscGVycyQxLmdldENvbnN0cmFpbnRXaWR0aCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHRyZXR1cm4gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCAnbWF4LXdpZHRoJywgJ2NsaWVudFdpZHRoJyk7XG5cdH07XG5cdC8vIHJldHVybnMgTnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBubyBjb25zdHJhaW50XG5cdGhlbHBlcnMkMS5nZXRDb25zdHJhaW50SGVpZ2h0ID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHJldHVybiBnZXRDb25zdHJhaW50RGltZW5zaW9uKGRvbU5vZGUsICdtYXgtaGVpZ2h0JywgJ2NsaWVudEhlaWdodCcpO1xuXHR9O1xuXHQvKipcblx0ICogQHByaXZhdGVcbiBcdCAqL1xuXHRoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcgPSBmdW5jdGlvbihjb250YWluZXIsIHBhZGRpbmcsIHBhcmVudERpbWVuc2lvbikge1xuXHRcdHBhZGRpbmcgPSBoZWxwZXJzJDEuZ2V0U3R5bGUoY29udGFpbmVyLCBwYWRkaW5nKTtcblxuXHRcdHJldHVybiBwYWRkaW5nLmluZGV4T2YoJyUnKSA+IC0xID8gcGFyZW50RGltZW5zaW9uICogcGFyc2VJbnQocGFkZGluZywgMTApIC8gMTAwIDogcGFyc2VJbnQocGFkZGluZywgMTApO1xuXHR9O1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZSA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHR2YXIgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuXHRcdGlmIChwYXJlbnQgJiYgcGFyZW50LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNoYWRvd1Jvb3RdJykge1xuXHRcdFx0cGFyZW50ID0gcGFyZW50Lmhvc3Q7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJlbnQ7XG5cdH07XG5cdGhlbHBlcnMkMS5nZXRNYXhpbXVtV2lkdGggPSBmdW5jdGlvbihkb21Ob2RlKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZShkb21Ob2RlKTtcblx0XHRpZiAoIWNvbnRhaW5lcikge1xuXHRcdFx0cmV0dXJuIGRvbU5vZGUuY2xpZW50V2lkdGg7XG5cdFx0fVxuXG5cdFx0dmFyIGNsaWVudFdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuXHRcdHZhciBwYWRkaW5nTGVmdCA9IGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyhjb250YWluZXIsICdwYWRkaW5nLWxlZnQnLCBjbGllbnRXaWR0aCk7XG5cdFx0dmFyIHBhZGRpbmdSaWdodCA9IGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyhjb250YWluZXIsICdwYWRkaW5nLXJpZ2h0JywgY2xpZW50V2lkdGgpO1xuXG5cdFx0dmFyIHcgPSBjbGllbnRXaWR0aCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0O1xuXHRcdHZhciBjdyA9IGhlbHBlcnMkMS5nZXRDb25zdHJhaW50V2lkdGgoZG9tTm9kZSk7XG5cdFx0cmV0dXJuIGlzTmFOKGN3KSA/IHcgOiBNYXRoLm1pbih3LCBjdyk7XG5cdH07XG5cdGhlbHBlcnMkMS5nZXRNYXhpbXVtSGVpZ2h0ID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHZhciBjb250YWluZXIgPSBoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUoZG9tTm9kZSk7XG5cdFx0aWYgKCFjb250YWluZXIpIHtcblx0XHRcdHJldHVybiBkb21Ob2RlLmNsaWVudEhlaWdodDtcblx0XHR9XG5cblx0XHR2YXIgY2xpZW50SGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcblx0XHR2YXIgcGFkZGluZ1RvcCA9IGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyhjb250YWluZXIsICdwYWRkaW5nLXRvcCcsIGNsaWVudEhlaWdodCk7XG5cdFx0dmFyIHBhZGRpbmdCb3R0b20gPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy1ib3R0b20nLCBjbGllbnRIZWlnaHQpO1xuXG5cdFx0dmFyIGggPSBjbGllbnRIZWlnaHQgLSBwYWRkaW5nVG9wIC0gcGFkZGluZ0JvdHRvbTtcblx0XHR2YXIgY2ggPSBoZWxwZXJzJDEuZ2V0Q29uc3RyYWludEhlaWdodChkb21Ob2RlKTtcblx0XHRyZXR1cm4gaXNOYU4oY2gpID8gaCA6IE1hdGgubWluKGgsIGNoKTtcblx0fTtcblx0aGVscGVycyQxLmdldFN0eWxlID0gZnVuY3Rpb24oZWwsIHByb3BlcnR5KSB7XG5cdFx0cmV0dXJuIGVsLmN1cnJlbnRTdHlsZSA/XG5cdFx0XHRlbC5jdXJyZW50U3R5bGVbcHJvcGVydHldIDpcblx0XHRcdGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuXHR9O1xuXHRoZWxwZXJzJDEucmV0aW5hU2NhbGUgPSBmdW5jdGlvbihjaGFydCwgZm9yY2VSYXRpbykge1xuXHRcdHZhciBwaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBmb3JjZVJhdGlvIHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgfHwgMTtcblx0XHRpZiAocGl4ZWxSYXRpbyA9PT0gMSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cdFx0dmFyIGhlaWdodCA9IGNoYXJ0LmhlaWdodDtcblx0XHR2YXIgd2lkdGggPSBjaGFydC53aWR0aDtcblxuXHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuXHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcblx0XHRjaGFydC5jdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG5cblx0XHQvLyBJZiBubyBzdHlsZSBoYXMgYmVlbiBzZXQgb24gdGhlIGNhbnZhcywgdGhlIHJlbmRlciBzaXplIGlzIHVzZWQgYXMgZGlzcGxheSBzaXplLFxuXHRcdC8vIG1ha2luZyB0aGUgY2hhcnQgdmlzdWFsbHkgYmlnZ2VyLCBzbyBsZXQncyBlbmZvcmNlIGl0IHRvIHRoZSBcImNvcnJlY3RcIiB2YWx1ZXMuXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zNTc1XG5cdFx0aWYgKCFjYW52YXMuc3R5bGUuaGVpZ2h0ICYmICFjYW52YXMuc3R5bGUud2lkdGgpIHtcblx0XHRcdGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXHRcdFx0Y2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXHRcdH1cblx0fTtcblx0Ly8gLS0gQ2FudmFzIG1ldGhvZHNcblx0aGVscGVycyQxLmZvbnRTdHJpbmcgPSBmdW5jdGlvbihwaXhlbFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSkge1xuXHRcdHJldHVybiBmb250U3R5bGUgKyAnICcgKyBwaXhlbFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG5cdH07XG5cdGhlbHBlcnMkMS5sb25nZXN0VGV4dCA9IGZ1bmN0aW9uKGN0eCwgZm9udCwgYXJyYXlPZlRoaW5ncywgY2FjaGUpIHtcblx0XHRjYWNoZSA9IGNhY2hlIHx8IHt9O1xuXHRcdHZhciBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XG5cdFx0dmFyIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcblxuXHRcdGlmIChjYWNoZS5mb250ICE9PSBmb250KSB7XG5cdFx0XHRkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xuXHRcdFx0Z2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IFtdO1xuXHRcdFx0Y2FjaGUuZm9udCA9IGZvbnQ7XG5cdFx0fVxuXG5cdFx0Y3R4LmZvbnQgPSBmb250O1xuXHRcdHZhciBsb25nZXN0ID0gMDtcblx0XHR2YXIgaWxlbiA9IGFycmF5T2ZUaGluZ3MubGVuZ3RoO1xuXHRcdHZhciBpLCBqLCBqbGVuLCB0aGluZywgbmVzdGVkVGhpbmc7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47IGkrKykge1xuXHRcdFx0dGhpbmcgPSBhcnJheU9mVGhpbmdzW2ldO1xuXG5cdFx0XHQvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcblx0XHRcdGlmICh0aGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaW5nICE9PSBudWxsICYmIGhlbHBlcnMkMS5pc0FycmF5KHRoaW5nKSAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRsb25nZXN0ID0gaGVscGVycyQxLm1lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHRoaW5nKTtcblx0XHRcdH0gZWxzZSBpZiAoaGVscGVycyQxLmlzQXJyYXkodGhpbmcpKSB7XG5cdFx0XHRcdC8vIGlmIGl0IGlzIGFuIGFycmF5IGxldHMgbWVhc3VyZSBlYWNoIGVsZW1lbnRcblx0XHRcdFx0Ly8gdG8gZG8gbWF5YmUgc2ltcGxpZnkgdGhpcyBmdW5jdGlvbiBhIGJpdCBzbyB3ZSBjYW4gZG8gdGhpcyBtb3JlIHJlY3Vyc2l2ZWx5P1xuXHRcdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gdGhpbmcubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG5cdFx0XHRcdFx0bmVzdGVkVGhpbmcgPSB0aGluZ1tqXTtcblx0XHRcdFx0XHQvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcblx0XHRcdFx0XHRpZiAobmVzdGVkVGhpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRUaGluZyAhPT0gbnVsbCAmJiAhaGVscGVycyQxLmlzQXJyYXkobmVzdGVkVGhpbmcpKSB7XG5cdFx0XHRcdFx0XHRsb25nZXN0ID0gaGVscGVycyQxLm1lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIG5lc3RlZFRoaW5nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuXHRcdGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xuXHRcdFx0XHRkZWxldGUgZGF0YVtnY1tpXV07XG5cdFx0XHR9XG5cdFx0XHRnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9uZ2VzdDtcblx0fTtcblx0aGVscGVycyQxLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24oY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgc3RyaW5nKSB7XG5cdFx0dmFyIHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXTtcblx0XHRpZiAoIXRleHRXaWR0aCkge1xuXHRcdFx0dGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG5cdFx0XHRnYy5wdXNoKHN0cmluZyk7XG5cdFx0fVxuXHRcdGlmICh0ZXh0V2lkdGggPiBsb25nZXN0KSB7XG5cdFx0XHRsb25nZXN0ID0gdGV4dFdpZHRoO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9uZ2VzdDtcblx0fTtcblxuXHQvKipcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdGhlbHBlcnMkMS5udW1iZXJPZkxhYmVsTGluZXMgPSBmdW5jdGlvbihhcnJheU9mVGhpbmdzKSB7XG5cdFx0dmFyIG51bWJlck9mTGluZXMgPSAxO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGFycmF5T2ZUaGluZ3MsIGZ1bmN0aW9uKHRoaW5nKSB7XG5cdFx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkodGhpbmcpKSB7XG5cdFx0XHRcdGlmICh0aGluZy5sZW5ndGggPiBudW1iZXJPZkxpbmVzKSB7XG5cdFx0XHRcdFx0bnVtYmVyT2ZMaW5lcyA9IHRoaW5nLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBudW1iZXJPZkxpbmVzO1xuXHR9O1xuXG5cdGhlbHBlcnMkMS5jb2xvciA9ICFjaGFydGpzQ29sb3IgP1xuXHRcdGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdDb2xvci5qcyBub3QgZm91bmQhJyk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdC8qIGdsb2JhbCBDYW52YXNHcmFkaWVudCAqL1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQ2FudmFzR3JhZGllbnQpIHtcblx0XHRcdFx0dmFsdWUgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjaGFydGpzQ29sb3IodmFsdWUpO1xuXHRcdH07XG5cblx0aGVscGVycyQxLmdldEhvdmVyQ29sb3IgPSBmdW5jdGlvbihjb2xvclZhbHVlKSB7XG5cdFx0LyogZ2xvYmFsIENhbnZhc1BhdHRlcm4gKi9cblx0XHRyZXR1cm4gKGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBDYW52YXNQYXR0ZXJuIHx8IGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudCkgP1xuXHRcdFx0Y29sb3JWYWx1ZSA6XG5cdFx0XHRoZWxwZXJzJDEuY29sb3IoY29sb3JWYWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5yZ2JTdHJpbmcoKTtcblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFic3RyYWN0KCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0J1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogZWl0aGVyIG5vIGFkYXB0ZXIgY2FuICcgK1xuXHRcdCdiZSBmb3VuZCBvciBhbiBpbmNvbXBsZXRlIGludGVncmF0aW9uIHdhcyBwcm92aWRlZC4nXG5cdCk7XG59XG5cbi8qKlxuICogRGF0ZSBhZGFwdGVyIChjdXJyZW50IHVzZWQgYnkgdGhlIHRpbWUgc2NhbGUpXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZVxuICogQG1lbWJlcm9mIENoYXJ0Ll9hZGFwdGVyc1xuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIEN1cnJlbnRseSBzdXBwb3J0ZWQgdW5pdCBzdHJpbmcgdmFsdWVzLlxuICogQHR5cGVkZWYgeygnbWlsbGlzZWNvbmQnfCdzZWNvbmQnfCdtaW51dGUnfCdob3VyJ3wnZGF5J3wnd2Vlayd8J21vbnRoJ3wncXVhcnRlcid8J3llYXInKX1cbiAqIEBtZW1iZXJvZiBDaGFydC5fYWRhcHRlcnMuX2RhdGVcbiAqIEBuYW1lIFVuaXRcbiAqL1xuXG4vKipcbiAqIEBjbGFzc1xuICovXG5mdW5jdGlvbiBEYXRlQWRhcHRlcihvcHRpb25zKSB7XG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG59XG5cbmhlbHBlcnMkMS5leHRlbmQoRGF0ZUFkYXB0ZXIucHJvdG90eXBlLCAvKiogQGxlbmRzIERhdGVBZGFwdGVyICovIHtcblx0LyoqXG5cdCAqIFJldHVybnMgYSBtYXAgb2YgdGltZSBmb3JtYXRzIGZvciB0aGUgc3VwcG9ydGVkIGZvcm1hdHRpbmcgdW5pdHMgZGVmaW5lZFxuXHQgKiBpbiBVbml0IGFzIHdlbGwgYXMgJ2RhdGV0aW1lJyByZXByZXNlbnRpbmcgYSBkZXRhaWxlZCBkYXRlL3RpbWUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7e3N0cmluZzogc3RyaW5nfX1cblx0ICovXG5cdGZvcm1hdHM6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgdGhlIGdpdmVuIGB2YWx1ZWAgYW5kIHJldHVybiB0aGUgYXNzb2NpYXRlZCB0aW1lc3RhbXAuXG5cdCAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBwYXJzZSAodXN1YWxseSBjb21lcyBmcm9tIHRoZSBkYXRhKVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2Zvcm1hdF0gLSB0aGUgZXhwZWN0ZWQgZGF0YSBmb3JtYXRcblx0ICogQHJldHVybnMgeyhudW1iZXJ8bnVsbCl9XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0cGFyc2U6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBmb3JtYXR0ZWQgZGF0ZSBpbiB0aGUgc3BlY2lmaWVkIGBmb3JtYXRgIGZvciBhIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIHRpbWVzdGFtcCB0byBmb3JtYXRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIHRoZSBkYXRlL3RpbWUgdG9rZW5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGZvcm1hdDogYWJzdHJhY3QsXG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHNwZWNpZmllZCBgYW1vdW50YCBvZiBgdW5pdGAgdG8gdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuXHQgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCB0byBhZGRcblx0ICogQHBhcmFtIHtVbml0fSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRhZGQ6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYHVuaXRgIGJldHdlZW4gdGhlIGdpdmVuIHRpbWVzdGFtcHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSB0aGUgaW5wdXQgdGltZXN0YW1wIChyZWZlcmVuY2UpXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSB0aGUgdGltZXN0YW1wIHRvIHN1YnN0cmFjdFxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGRpZmY6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHN0YXJ0IG9mIGB1bml0YCBmb3IgdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3ZWVrZGF5XSAtIHRoZSBJU08gZGF5IG9mIHRoZSB3ZWVrIHdpdGggMSBiZWluZyBNb25kYXlcblx0ICogYW5kIDcgYmVpbmcgU3VuZGF5IChvbmx5IG5lZWRlZCBpZiBwYXJhbSAqdW5pdCogaXMgYGlzb1dlZWtgKS5cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRzdGFydE9mOiBhYnN0cmFjdCxcblxuXHQvKipcblx0ICogUmV0dXJucyBlbmQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG5cdCAqIEBwYXJhbSB7VW5pdH0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGVuZE9mOiBhYnN0cmFjdCxcblxuXHQvLyBERVBSRUNBVElPTlNcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIHNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoKSxcblx0ICogdGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4gb25seSBieSB0aGUgbW9tZW50IGFkYXB0ZXIuXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NyZWF0ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cbn0pO1xuXG5EYXRlQWRhcHRlci5vdmVycmlkZSA9IGZ1bmN0aW9uKG1lbWJlcnMpIHtcblx0aGVscGVycyQxLmV4dGVuZChEYXRlQWRhcHRlci5wcm90b3R5cGUsIG1lbWJlcnMpO1xufTtcblxudmFyIF9kYXRlID0gRGF0ZUFkYXB0ZXI7XG5cbnZhciBjb3JlX2FkYXB0ZXJzID0ge1xuXHRfZGF0ZTogX2RhdGVcbn07XG5cbi8qKlxuICogTmFtZXNwYWNlIHRvIGhvbGQgc3RhdGljIHRpY2sgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3NcbiAqL1xudmFyIGNvcmVfdGlja3MgPSB7XG5cdC8qKlxuXHQgKiBOYW1lc3BhY2UgdG8gaG9sZCBmb3JtYXR0ZXJzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgdGlja3Ncblx0ICogQG5hbWVzcGFjZSBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzXG5cdCAqL1xuXHRmb3JtYXR0ZXJzOiB7XG5cdFx0LyoqXG5cdFx0ICogRm9ybWF0dGVyIGZvciB2YWx1ZSBsYWJlbHNcblx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMudmFsdWVzXG5cdFx0ICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBkaXNwbGF5XG5cdFx0ICogQHJldHVybiB7c3RyaW5nfHN0cmluZ1tdfSB0aGUgbGFiZWwgdG8gZGlzcGxheVxuXHRcdCAqL1xuXHRcdHZhbHVlczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiBoZWxwZXJzJDEuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6ICcnICsgdmFsdWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZvcm1hdHRlciBmb3IgbGluZWFyIG51bWVyaWMgdGlja3Ncblx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubGluZWFyXG5cdFx0ICogQHBhcmFtIHRpY2tWYWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG5cdFx0ICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlciBpbiB0aGUgdGlja3MgYXJyYXlcblx0XHQgKiBAcGFyYW0gdGlja3Mge251bWJlcltdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuXHRcdCAqL1xuXHRcdGxpbmVhcjogZnVuY3Rpb24odGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcblx0XHRcdC8vIElmIHdlIGhhdmUgbG90cyBvZiB0aWNrcywgZG9uJ3QgdXNlIHRoZSBvbmVzXG5cdFx0XHR2YXIgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0gLSB0aWNrc1sxXSA6IHRpY2tzWzFdIC0gdGlja3NbMF07XG5cblx0XHRcdC8vIElmIHdlIGhhdmUgYSBudW1iZXIgbGlrZSAyLjUgYXMgdGhlIGRlbHRhLCBmaWd1cmUgb3V0IGhvdyBtYW55IGRlY2ltYWwgcGxhY2VzIHdlIG5lZWRcblx0XHRcdGlmIChNYXRoLmFicyhkZWx0YSkgPiAxKSB7XG5cdFx0XHRcdGlmICh0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuXHRcdFx0XHRcdC8vIG5vdCBhbiBpbnRlZ2VyXG5cdFx0XHRcdFx0ZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIGxvZ0RlbHRhID0gaGVscGVycyQxLmxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG5cdFx0XHR2YXIgdGlja1N0cmluZyA9ICcnO1xuXG5cdFx0XHRpZiAodGlja1ZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdHZhciBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0pLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSkpO1xuXHRcdFx0XHRpZiAobWF4VGljayA8IDFlLTQpIHsgLy8gYWxsIHRpY2tzIGFyZSBzbWFsbCBudW1iZXJzOyB1c2Ugc2NpZW50aWZpYyBub3RhdGlvblxuXHRcdFx0XHRcdHZhciBsb2dUaWNrID0gaGVscGVycyQxLmxvZzEwKE1hdGguYWJzKHRpY2tWYWx1ZSkpO1xuXHRcdFx0XHRcdHZhciBudW1FeHBvbmVudGlhbCA9IE1hdGguZmxvb3IobG9nVGljaykgLSBNYXRoLmZsb29yKGxvZ0RlbHRhKTtcblx0XHRcdFx0XHRudW1FeHBvbmVudGlhbCA9IE1hdGgubWF4KE1hdGgubWluKG51bUV4cG9uZW50aWFsLCAyMCksIDApO1xuXHRcdFx0XHRcdHRpY2tTdHJpbmcgPSB0aWNrVmFsdWUudG9FeHBvbmVudGlhbChudW1FeHBvbmVudGlhbCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIG51bURlY2ltYWwgPSAtMSAqIE1hdGguZmxvb3IobG9nRGVsdGEpO1xuXHRcdFx0XHRcdG51bURlY2ltYWwgPSBNYXRoLm1heChNYXRoLm1pbihudW1EZWNpbWFsLCAyMCksIDApOyAvLyB0b0ZpeGVkIGhhcyBhIG1heCBvZiAyMCBkZWNpbWFsIHBsYWNlc1xuXHRcdFx0XHRcdHRpY2tTdHJpbmcgPSB0aWNrVmFsdWUudG9GaXhlZChudW1EZWNpbWFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGlja1N0cmluZyA9ICcwJzsgLy8gbmV2ZXIgc2hvdyBkZWNpbWFsIHBsYWNlcyBmb3IgMFxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGlja1N0cmluZztcblx0XHR9LFxuXG5cdFx0bG9nYXJpdGhtaWM6IGZ1bmN0aW9uKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG5cdFx0XHR2YXIgcmVtYWluID0gdGlja1ZhbHVlIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMCh0aWNrVmFsdWUpKSkpO1xuXG5cdFx0XHRpZiAodGlja1ZhbHVlID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAnMCc7XG5cdFx0XHR9IGVsc2UgaWYgKHJlbWFpbiA9PT0gMSB8fCByZW1haW4gPT09IDIgfHwgcmVtYWluID09PSA1IHx8IGluZGV4ID09PSAwIHx8IGluZGV4ID09PSB0aWNrcy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdHJldHVybiB0aWNrVmFsdWUudG9FeHBvbmVudGlhbCgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0fVxufTtcblxudmFyIGlzQXJyYXkgPSBoZWxwZXJzJDEuaXNBcnJheTtcbnZhciBpc051bGxPclVuZGVmID0gaGVscGVycyQxLmlzTnVsbE9yVW5kZWY7XG52YXIgdmFsdWVPckRlZmF1bHQkYSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcbnZhciB2YWx1ZUF0SW5kZXhPckRlZmF1bHQgPSBoZWxwZXJzJDEudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3NjYWxlJywge1xuXHRkaXNwbGF5OiB0cnVlLFxuXHRwb3NpdGlvbjogJ2xlZnQnLFxuXHRvZmZzZXQ6IGZhbHNlLFxuXG5cdC8vIGdyaWQgbGluZSBzZXR0aW5nc1xuXHRncmlkTGluZXM6IHtcblx0XHRkaXNwbGF5OiB0cnVlLFxuXHRcdGNvbG9yOiAncmdiYSgwLDAsMCwwLjEpJyxcblx0XHRsaW5lV2lkdGg6IDEsXG5cdFx0ZHJhd0JvcmRlcjogdHJ1ZSxcblx0XHRkcmF3T25DaGFydEFyZWE6IHRydWUsXG5cdFx0ZHJhd1RpY2tzOiB0cnVlLFxuXHRcdHRpY2tNYXJrTGVuZ3RoOiAxMCxcblx0XHR6ZXJvTGluZVdpZHRoOiAxLFxuXHRcdHplcm9MaW5lQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMjUpJyxcblx0XHR6ZXJvTGluZUJvcmRlckRhc2g6IFtdLFxuXHRcdHplcm9MaW5lQm9yZGVyRGFzaE9mZnNldDogMC4wLFxuXHRcdG9mZnNldEdyaWRMaW5lczogZmFsc2UsXG5cdFx0Ym9yZGVyRGFzaDogW10sXG5cdFx0Ym9yZGVyRGFzaE9mZnNldDogMC4wXG5cdH0sXG5cblx0Ly8gc2NhbGUgbGFiZWxcblx0c2NhbGVMYWJlbDoge1xuXHRcdC8vIGRpc3BsYXkgcHJvcGVydHlcblx0XHRkaXNwbGF5OiBmYWxzZSxcblxuXHRcdC8vIGFjdHVhbCBsYWJlbFxuXHRcdGxhYmVsU3RyaW5nOiAnJyxcblxuXHRcdC8vIHRvcC9ib3R0b20gcGFkZGluZ1xuXHRcdHBhZGRpbmc6IHtcblx0XHRcdHRvcDogNCxcblx0XHRcdGJvdHRvbTogNFxuXHRcdH1cblx0fSxcblxuXHQvLyBsYWJlbCBzZXR0aW5nc1xuXHR0aWNrczoge1xuXHRcdGJlZ2luQXRaZXJvOiBmYWxzZSxcblx0XHRtaW5Sb3RhdGlvbjogMCxcblx0XHRtYXhSb3RhdGlvbjogNTAsXG5cdFx0bWlycm9yOiBmYWxzZSxcblx0XHRwYWRkaW5nOiAwLFxuXHRcdHJldmVyc2U6IGZhbHNlLFxuXHRcdGRpc3BsYXk6IHRydWUsXG5cdFx0YXV0b1NraXA6IHRydWUsXG5cdFx0YXV0b1NraXBQYWRkaW5nOiAwLFxuXHRcdGxhYmVsT2Zmc2V0OiAwLFxuXHRcdC8vIFdlIHBhc3MgdGhyb3VnaCBhcnJheXMgdG8gYmUgcmVuZGVyZWQgYXMgbXVsdGlsaW5lIGxhYmVscywgd2UgY29udmVydCBPdGhlcnMgdG8gc3RyaW5ncyBoZXJlLlxuXHRcdGNhbGxiYWNrOiBjb3JlX3RpY2tzLmZvcm1hdHRlcnMudmFsdWVzLFxuXHRcdG1pbm9yOiB7fSxcblx0XHRtYWpvcjoge31cblx0fVxufSk7XG5cbi8qKiBSZXR1cm5zIGEgbmV3IGFycmF5IGNvbnRhaW5pbmcgbnVtSXRlbXMgZnJvbSBhcnIgKi9cbmZ1bmN0aW9uIHNhbXBsZShhcnIsIG51bUl0ZW1zKSB7XG5cdHZhciByZXN1bHQgPSBbXTtcblx0dmFyIGluY3JlbWVudCA9IGFyci5sZW5ndGggLyBudW1JdGVtcztcblx0dmFyIGkgPSAwO1xuXHR2YXIgbGVuID0gYXJyLmxlbmd0aDtcblxuXHRmb3IgKDsgaSA8IGxlbjsgaSArPSBpbmNyZW1lbnQpIHtcblx0XHRyZXN1bHQucHVzaChhcnJbTWF0aC5mbG9vcihpKV0pO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcblx0dmFyIGxlbmd0aCA9IHNjYWxlLmdldFRpY2tzKCkubGVuZ3RoO1xuXHR2YXIgdmFsaWRJbmRleCA9IE1hdGgubWluKGluZGV4LCBsZW5ndGggLSAxKTtcblx0dmFyIGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4KTtcblx0dmFyIHN0YXJ0ID0gc2NhbGUuX3N0YXJ0UGl4ZWw7XG5cdHZhciBlbmQgPSBzY2FsZS5fZW5kUGl4ZWw7XG5cdHZhciBlcHNpbG9uID0gMWUtNjsgLy8gMWUtNiBpcyBtYXJnaW4gaW4gcGl4ZWxzIGZvciBhY2N1bXVsYXRlZCBlcnJvci5cblx0dmFyIG9mZnNldDtcblxuXHRpZiAob2Zmc2V0R3JpZExpbmVzKSB7XG5cdFx0aWYgKGxlbmd0aCA9PT0gMSkge1xuXHRcdFx0b2Zmc2V0ID0gTWF0aC5tYXgobGluZVZhbHVlIC0gc3RhcnQsIGVuZCAtIGxpbmVWYWx1ZSk7XG5cdFx0fSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0b2Zmc2V0ID0gKHNjYWxlLmdldFBpeGVsRm9yVGljaygxKSAtIGxpbmVWYWx1ZSkgLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXggLSAxKSkgLyAyO1xuXHRcdH1cblx0XHRsaW5lVmFsdWUgKz0gdmFsaWRJbmRleCA8IGluZGV4ID8gb2Zmc2V0IDogLW9mZnNldDtcblxuXHRcdC8vIFJldHVybiB1bmRlZmluZWQgaWYgdGhlIHBpeGVsIGlzIG91dCBvZiB0aGUgcmFuZ2Vcblx0XHRpZiAobGluZVZhbHVlIDwgc3RhcnQgLSBlcHNpbG9uIHx8IGxpbmVWYWx1ZSA+IGVuZCArIGVwc2lsb24pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGxpbmVWYWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcblx0aGVscGVycyQxLmVhY2goY2FjaGVzLCBmdW5jdGlvbihjYWNoZSkge1xuXHRcdHZhciBnYyA9IGNhY2hlLmdjO1xuXHRcdHZhciBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG5cdFx0dmFyIGk7XG5cdFx0aWYgKGdjTGVuID4gbGVuZ3RoKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZ2NMZW47ICsraSkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGUuZGF0YVtnY1tpXV07XG5cdFx0XHR9XG5cdFx0XHRnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB7d2lkdGgsIGhlaWdodCwgb2Zmc2V0fSBvYmplY3RzIGZvciB0aGUgZmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdCB0aWNrXG4gKiBsYWJlbHMgd2hlcmUgb2Zmc2V0IGluZGljYXRlcyB0aGUgYW5jaG9yIHBvaW50IG9mZnNldCBmcm9tIHRoZSB0b3AgaW4gcGl4ZWxzLlxuICovXG5mdW5jdGlvbiBjb21wdXRlTGFiZWxTaXplcyhjdHgsIHRpY2tGb250cywgdGlja3MsIGNhY2hlcykge1xuXHR2YXIgbGVuZ3RoID0gdGlja3MubGVuZ3RoO1xuXHR2YXIgd2lkdGhzID0gW107XG5cdHZhciBoZWlnaHRzID0gW107XG5cdHZhciBvZmZzZXRzID0gW107XG5cdHZhciBpLCBqLCBqbGVuLCBsYWJlbCwgdGlja0ZvbnQsIGZvbnRTdHJpbmcsIGNhY2hlLCBsaW5lSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBuZXN0ZWRMYWJlbCwgd2lkZXN0LCBoaWdoZXN0O1xuXG5cdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdGxhYmVsID0gdGlja3NbaV0ubGFiZWw7XG5cdFx0dGlja0ZvbnQgPSB0aWNrc1tpXS5tYWpvciA/IHRpY2tGb250cy5tYWpvciA6IHRpY2tGb250cy5taW5vcjtcblx0XHRjdHguZm9udCA9IGZvbnRTdHJpbmcgPSB0aWNrRm9udC5zdHJpbmc7XG5cdFx0Y2FjaGUgPSBjYWNoZXNbZm9udFN0cmluZ10gPSBjYWNoZXNbZm9udFN0cmluZ10gfHwge2RhdGE6IHt9LCBnYzogW119O1xuXHRcdGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xuXHRcdHdpZHRoID0gaGVpZ2h0ID0gMDtcblx0XHQvLyBVbmRlZmluZWQgbGFiZWxzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuXHRcdGlmICghaXNOdWxsT3JVbmRlZihsYWJlbCkgJiYgIWlzQXJyYXkobGFiZWwpKSB7XG5cdFx0XHR3aWR0aCA9IGhlbHBlcnMkMS5tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbGFiZWwpO1xuXHRcdFx0aGVpZ2h0ID0gbGluZUhlaWdodDtcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXkobGFiZWwpKSB7XG5cdFx0XHQvLyBpZiBpdCBpcyBhbiBhcnJheSBsZXQncyBtZWFzdXJlIGVhY2ggZWxlbWVudFxuXHRcdFx0Zm9yIChqID0gMCwgamxlbiA9IGxhYmVsLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuXHRcdFx0XHRuZXN0ZWRMYWJlbCA9IGxhYmVsW2pdO1xuXHRcdFx0XHQvLyBVbmRlZmluZWQgbGFiZWxzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuXHRcdFx0XHRpZiAoIWlzTnVsbE9yVW5kZWYobmVzdGVkTGFiZWwpICYmICFpc0FycmF5KG5lc3RlZExhYmVsKSkge1xuXHRcdFx0XHRcdHdpZHRoID0gaGVscGVycyQxLm1lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBuZXN0ZWRMYWJlbCk7XG5cdFx0XHRcdFx0aGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0d2lkdGhzLnB1c2god2lkdGgpO1xuXHRcdGhlaWdodHMucHVzaChoZWlnaHQpO1xuXHRcdG9mZnNldHMucHVzaChsaW5lSGVpZ2h0IC8gMik7XG5cdH1cblx0Z2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpO1xuXG5cdHdpZGVzdCA9IHdpZHRocy5pbmRleE9mKE1hdGgubWF4LmFwcGx5KG51bGwsIHdpZHRocykpO1xuXHRoaWdoZXN0ID0gaGVpZ2h0cy5pbmRleE9mKE1hdGgubWF4LmFwcGx5KG51bGwsIGhlaWdodHMpKTtcblxuXHRmdW5jdGlvbiB2YWx1ZUF0KGlkeCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogd2lkdGhzW2lkeF0gfHwgMCxcblx0XHRcdGhlaWdodDogaGVpZ2h0c1tpZHhdIHx8IDAsXG5cdFx0XHRvZmZzZXQ6IG9mZnNldHNbaWR4XSB8fCAwXG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Zmlyc3Q6IHZhbHVlQXQoMCksXG5cdFx0bGFzdDogdmFsdWVBdChsZW5ndGggLSAxKSxcblx0XHR3aWRlc3Q6IHZhbHVlQXQod2lkZXN0KSxcblx0XHRoaWdoZXN0OiB2YWx1ZUF0KGhpZ2hlc3QpXG5cdH07XG59XG5cbmZ1bmN0aW9uIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMpIHtcblx0cmV0dXJuIG9wdGlvbnMuZHJhd1RpY2tzID8gb3B0aW9ucy50aWNrTWFya0xlbmd0aCA6IDA7XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlTGFiZWxIZWlnaHQob3B0aW9ucykge1xuXHR2YXIgZm9udCwgcGFkZGluZztcblxuXHRpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Zm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQob3B0aW9ucyk7XG5cdHBhZGRpbmcgPSBoZWxwZXJzJDEub3B0aW9ucy50b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcblxuXHRyZXR1cm4gZm9udC5saW5lSGVpZ2h0ICsgcGFkZGluZy5oZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRm9udE9wdGlvbnMob3B0aW9ucywgbmVzdGVkT3B0cykge1xuXHRyZXR1cm4gaGVscGVycyQxLmV4dGVuZChoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHtcblx0XHRmb250RmFtaWx5OiB2YWx1ZU9yRGVmYXVsdCRhKG5lc3RlZE9wdHMuZm9udEZhbWlseSwgb3B0aW9ucy5mb250RmFtaWx5KSxcblx0XHRmb250U2l6ZTogdmFsdWVPckRlZmF1bHQkYShuZXN0ZWRPcHRzLmZvbnRTaXplLCBvcHRpb25zLmZvbnRTaXplKSxcblx0XHRmb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0JGEobmVzdGVkT3B0cy5mb250U3R5bGUsIG9wdGlvbnMuZm9udFN0eWxlKSxcblx0XHRsaW5lSGVpZ2h0OiB2YWx1ZU9yRGVmYXVsdCRhKG5lc3RlZE9wdHMubGluZUhlaWdodCwgb3B0aW9ucy5saW5lSGVpZ2h0KVxuXHR9KSwge1xuXHRcdGNvbG9yOiBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlKFtuZXN0ZWRPcHRzLmZvbnRDb2xvciwgb3B0aW9ucy5mb250Q29sb3IsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250Q29sb3JdKVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaWNrRm9udE9wdGlvbnMob3B0aW9ucykge1xuXHR2YXIgbWlub3IgPSBwYXJzZUZvbnRPcHRpb25zKG9wdGlvbnMsIG9wdGlvbnMubWlub3IpO1xuXHR2YXIgbWFqb3IgPSBvcHRpb25zLm1ham9yLmVuYWJsZWQgPyBwYXJzZUZvbnRPcHRpb25zKG9wdGlvbnMsIG9wdGlvbnMubWFqb3IpIDogbWlub3I7XG5cblx0cmV0dXJuIHttaW5vcjogbWlub3IsIG1ham9yOiBtYWpvcn07XG59XG5cbmZ1bmN0aW9uIG5vblNraXBwZWQodGlja3NUb0ZpbHRlcikge1xuXHR2YXIgZmlsdGVyZWQgPSBbXTtcblx0dmFyIGl0ZW0sIGluZGV4LCBsZW47XG5cdGZvciAoaW5kZXggPSAwLCBsZW4gPSB0aWNrc1RvRmlsdGVyLmxlbmd0aDsgaW5kZXggPCBsZW47ICsraW5kZXgpIHtcblx0XHRpdGVtID0gdGlja3NUb0ZpbHRlcltpbmRleF07XG5cdFx0aWYgKHR5cGVvZiBpdGVtLl9pbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdGZpbHRlcmVkLnB1c2goaXRlbSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmaWx0ZXJlZDtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlblNwYWNpbmcoYXJyKSB7XG5cdHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuXHR2YXIgaSwgZGlmZjtcblxuXHRpZiAobGVuIDwgMikge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZvciAoZGlmZiA9IGFyclswXSwgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuXHRcdGlmIChhcnJbaV0gLSBhcnJbaSAtIDFdICE9PSBkaWZmKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkaWZmO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIGF4aXNMZW5ndGgsIHRpY2tzTGltaXQpIHtcblx0dmFyIGV2ZW5NYWpvclNwYWNpbmcgPSBnZXRFdmVuU3BhY2luZyhtYWpvckluZGljZXMpO1xuXHR2YXIgc3BhY2luZyA9ICh0aWNrcy5sZW5ndGggLSAxKSAvIHRpY2tzTGltaXQ7XG5cdHZhciBmYWN0b3JzLCBmYWN0b3IsIGksIGlsZW47XG5cblx0Ly8gSWYgdGhlIG1ham9yIHRpY2tzIGFyZSBldmVubHkgc3BhY2VkIGFwYXJ0LCBwbGFjZSB0aGUgbWlub3IgdGlja3Ncblx0Ly8gc28gdGhhdCB0aGV5IGRpdmlkZSB0aGUgbWFqb3IgdGlja3MgaW50byBldmVuIGNodW5rc1xuXHRpZiAoIWV2ZW5NYWpvclNwYWNpbmcpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG5cdH1cblxuXHRmYWN0b3JzID0gaGVscGVycyQxLm1hdGguX2ZhY3Rvcml6ZShldmVuTWFqb3JTcGFjaW5nKTtcblx0Zm9yIChpID0gMCwgaWxlbiA9IGZhY3RvcnMubGVuZ3RoIC0gMTsgaSA8IGlsZW47IGkrKykge1xuXHRcdGZhY3RvciA9IGZhY3RvcnNbaV07XG5cdFx0aWYgKGZhY3RvciA+IHNwYWNpbmcpIHtcblx0XHRcdHJldHVybiBmYWN0b3I7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSB7XG5cdHZhciByZXN1bHQgPSBbXTtcblx0dmFyIGksIGlsZW47XG5cdGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcblx0XHRpZiAodGlja3NbaV0ubWFqb3IpIHtcblx0XHRcdHJlc3VsdC5wdXNoKGkpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBza2lwTWFqb3JzKHRpY2tzLCBtYWpvckluZGljZXMsIHNwYWNpbmcpIHtcblx0dmFyIGNvdW50ID0gMDtcblx0dmFyIG5leHQgPSBtYWpvckluZGljZXNbMF07XG5cdHZhciBpLCB0aWNrO1xuXG5cdHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG5cdGZvciAoaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdHRpY2sgPSB0aWNrc1tpXTtcblx0XHRpZiAoaSA9PT0gbmV4dCkge1xuXHRcdFx0dGljay5faW5kZXggPSBpO1xuXHRcdFx0Y291bnQrKztcblx0XHRcdG5leHQgPSBtYWpvckluZGljZXNbY291bnQgKiBzcGFjaW5nXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIHRpY2subGFiZWw7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNraXAodGlja3MsIHNwYWNpbmcsIG1ham9yU3RhcnQsIG1ham9yRW5kKSB7XG5cdHZhciBzdGFydCA9IHZhbHVlT3JEZWZhdWx0JGEobWFqb3JTdGFydCwgMCk7XG5cdHZhciBlbmQgPSBNYXRoLm1pbih2YWx1ZU9yRGVmYXVsdCRhKG1ham9yRW5kLCB0aWNrcy5sZW5ndGgpLCB0aWNrcy5sZW5ndGgpO1xuXHR2YXIgY291bnQgPSAwO1xuXHR2YXIgbGVuZ3RoLCBpLCB0aWNrLCBuZXh0O1xuXG5cdHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG5cdGlmIChtYWpvckVuZCkge1xuXHRcdGxlbmd0aCA9IG1ham9yRW5kIC0gbWFqb3JTdGFydDtcblx0XHRzcGFjaW5nID0gbGVuZ3RoIC8gTWF0aC5mbG9vcihsZW5ndGggLyBzcGFjaW5nKTtcblx0fVxuXG5cdG5leHQgPSBzdGFydDtcblxuXHR3aGlsZSAobmV4dCA8IDApIHtcblx0XHRjb3VudCsrO1xuXHRcdG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcblx0fVxuXG5cdGZvciAoaSA9IE1hdGgubWF4KHN0YXJ0LCAwKTsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0dGljayA9IHRpY2tzW2ldO1xuXHRcdGlmIChpID09PSBuZXh0KSB7XG5cdFx0XHR0aWNrLl9pbmRleCA9IGk7XG5cdFx0XHRjb3VudCsrO1xuXHRcdFx0bmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgdGljay5sYWJlbDtcblx0XHR9XG5cdH1cbn1cblxudmFyIFNjYWxlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cblx0emVyb0xpbmVJbmRleDogMCxcblxuXHQvKipcblx0ICogR2V0IHRoZSBwYWRkaW5nIG5lZWRlZCBmb3IgdGhlIHNjYWxlXG5cdCAqIEBtZXRob2QgZ2V0UGFkZGluZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcmV0dXJucyB7UGFkZGluZ30gdGhlIG5lY2Vzc2FyeSBwYWRkaW5nXG5cdCAqL1xuXHRnZXRQYWRkaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHJldHVybiB7XG5cdFx0XHRsZWZ0OiBtZS5wYWRkaW5nTGVmdCB8fCAwLFxuXHRcdFx0dG9wOiBtZS5wYWRkaW5nVG9wIHx8IDAsXG5cdFx0XHRyaWdodDogbWUucGFkZGluZ1JpZ2h0IHx8IDAsXG5cdFx0XHRib3R0b206IG1lLnBhZGRpbmdCb3R0b20gfHwgMFxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHNjYWxlIHRpY2sgb2JqZWN0cyAoe2xhYmVsLCBtYWpvcn0pXG5cdCAqIEBzaW5jZSAyLjdcblx0ICovXG5cdGdldFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGlja3M7XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X2dldExhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbHMgfHwgKHRoaXMuaXNIb3Jpem9udGFsKCkgPyBkYXRhLnhMYWJlbHMgOiBkYXRhLnlMYWJlbHMpIHx8IGRhdGEubGFiZWxzIHx8IFtdO1xuXHR9LFxuXG5cdC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5bGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cblx0Ly8gQW55IGZ1bmN0aW9uIGRlZmluZWQgaGVyZSBpcyBpbmhlcml0ZWQgYnkgYWxsIHNjYWxlIHR5cGVzLlxuXHQvLyBBbnkgZnVuY3Rpb24gY2FuIGJlIGV4dGVuZGVkIGJ5IHRoZSBzY2FsZSB0eXBlXG5cblx0LyoqXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcblx0ICogQGZ1bmN0aW9uIENoYXJ0LlNjYWxlLm1lcmdlVGlja3NPcHRpb25zXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKi9cblx0bWVyZ2VUaWNrc09wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIG5vb3Bcblx0fSxcblxuXHRiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4V2lkdGggLSB0aGUgbWF4IHdpZHRoIGluIHBpeGVsc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0IC0gdGhlIG1heCBoZWlnaHQgaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtYXJnaW5zIC0gdGhlIHNwYWNlIGJldHdlZW4gdGhlIGVkZ2Ugb2YgdGhlIG90aGVyIHNjYWxlcyBhbmQgZWRnZSBvZiB0aGUgY2hhcnRcblx0ICogICBUaGlzIHNwYWNlIGNvbWVzIGZyb20gdHdvIHNvdXJjZXM6XG5cdCAqICAgICAtIHBhZGRpbmcgLSBzcGFjZSB0aGF0J3MgcmVxdWlyZWQgdG8gc2hvdyB0aGUgbGFiZWxzIGF0IHRoZSBlZGdlcyBvZiB0aGUgc2NhbGVcblx0ICogICAgIC0gdGhpY2tuZXNzIG9mIHNjYWxlcyBvciBsZWdlbmRzIGluIGFub3RoZXIgb3JpZW50YXRpb25cblx0ICovXG5cdHVwZGF0ZTogZnVuY3Rpb24obWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgc2FtcGxlU2l6ZSA9IHRpY2tPcHRzLnNhbXBsZVNpemU7XG5cdFx0dmFyIGksIGlsZW4sIGxhYmVscywgdGlja3MsIHNhbXBsaW5nRW5hYmxlZDtcblxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRtZS5tYXJnaW5zID0gaGVscGVycyQxLmV4dGVuZCh7XG5cdFx0XHRsZWZ0OiAwLFxuXHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHR0b3A6IDAsXG5cdFx0XHRib3R0b206IDBcblx0XHR9LCBtYXJnaW5zKTtcblxuXHRcdG1lLl90aWNrcyA9IG51bGw7XG5cdFx0bWUudGlja3MgPSBudWxsO1xuXHRcdG1lLl9sYWJlbFNpemVzID0gbnVsbDtcblx0XHRtZS5fbWF4TGFiZWxMaW5lcyA9IDA7XG5cdFx0bWUubG9uZ2VzdExhYmVsV2lkdGggPSAwO1xuXHRcdG1lLmxvbmdlc3RUZXh0Q2FjaGUgPSBtZS5sb25nZXN0VGV4dENhY2hlIHx8IHt9O1xuXHRcdG1lLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcblx0XHRtZS5fbGFiZWxJdGVtcyA9IG51bGw7XG5cblx0XHQvLyBEaW1lbnNpb25zXG5cdFx0bWUuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLnNldERpbWVuc2lvbnMoKTtcblx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcblxuXHRcdC8vIERhdGEgbWluL21heFxuXHRcdG1lLmJlZm9yZURhdGFMaW1pdHMoKTtcblx0XHRtZS5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG5cdFx0bWUuYWZ0ZXJEYXRhTGltaXRzKCk7XG5cblx0XHQvLyBUaWNrcyAtIGB0aGlzLnRpY2tzYCBpcyBub3cgREVQUkVDQVRFRCFcblx0XHQvLyBJbnRlcm5hbCB0aWNrcyBhcmUgbm93IHN0b3JlZCBhcyBvYmplY3RzIGluIHRoZSBQUklWQVRFIGB0aGlzLl90aWNrc2AgbWVtYmVyXG5cdFx0Ly8gYW5kIG11c3Qgbm90IGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gb3V0c2lkZSB0aGlzIGNsYXNzLiBgdGhpcy50aWNrc2AgYmVpbmdcblx0XHQvLyBhcm91bmQgZm9yIGxvbmcgdGltZSBhbmQgbm90IG1hcmtlZCBhcyBwcml2YXRlLCB3ZSBjYW4ndCBjaGFuZ2UgaXRzIHN0cnVjdHVyZVxuXHRcdC8vIHdpdGhvdXQgdW5leHBlY3RlZCBicmVha2luZyBjaGFuZ2VzLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNjYWxlIHRpY2tzLFxuXHRcdC8vIHVzZSBzY2FsZS5nZXRUaWNrcygpIGluc3RlYWQuXG5cblx0XHRtZS5iZWZvcmVCdWlsZFRpY2tzKCk7XG5cblx0XHQvLyBOZXcgaW1wbGVtZW50YXRpb25zIHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0cyBidXQgZm9yIEJBQ0tXQVJEIENPTVBBVCxcblx0XHQvLyB3ZSBzdGlsbCBzdXBwb3J0IG5vIHJldHVybiAoYHRoaXMudGlja3NgIGludGVybmFsbHkgc2V0IGJ5IGNhbGxpbmcgdGhpcyBtZXRob2QpLlxuXHRcdHRpY2tzID0gbWUuYnVpbGRUaWNrcygpIHx8IFtdO1xuXG5cdFx0Ly8gQWxsb3cgbW9kaWZpY2F0aW9uIG9mIHRpY2tzIGluIGNhbGxiYWNrLlxuXHRcdHRpY2tzID0gbWUuYWZ0ZXJCdWlsZFRpY2tzKHRpY2tzKSB8fCB0aWNrcztcblxuXHRcdC8vIEVuc3VyZSB0aWNrcyBjb250YWlucyB0aWNrcyBpbiBuZXcgdGljayBmb3JtYXRcblx0XHRpZiAoKCF0aWNrcyB8fCAhdGlja3MubGVuZ3RoKSAmJiBtZS50aWNrcykge1xuXHRcdFx0dGlja3MgPSBbXTtcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBtZS50aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0dGlja3MucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1lLnRpY2tzW2ldLFxuXHRcdFx0XHRcdG1ham9yOiBmYWxzZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZS5fdGlja3MgPSB0aWNrcztcblxuXHRcdC8vIENvbXB1dGUgdGljayByb3RhdGlvbiBhbmQgZml0IHVzaW5nIGEgc2FtcGxlZCBzdWJzZXQgb2YgbGFiZWxzXG5cdFx0Ly8gV2UgZ2VuZXJhbGx5IGRvbid0IG5lZWQgdG8gY29tcHV0ZSB0aGUgc2l6ZSBvZiBldmVyeSBzaW5nbGUgbGFiZWwgZm9yIGRldGVybWluaW5nIHNjYWxlIHNpemVcblx0XHRzYW1wbGluZ0VuYWJsZWQgPSBzYW1wbGVTaXplIDwgdGlja3MubGVuZ3RoO1xuXHRcdGxhYmVscyA9IG1lLl9jb252ZXJ0VGlja3NUb0xhYmVscyhzYW1wbGluZ0VuYWJsZWQgPyBzYW1wbGUodGlja3MsIHNhbXBsZVNpemUpIDogdGlja3MpO1xuXG5cdFx0Ly8gX2NvbmZpZ3VyZSBpcyBjYWxsZWQgdHdpY2UsIG9uY2UgaGVyZSwgb25jZSBmcm9tIGNvcmUuY29udHJvbGxlci51cGRhdGVMYXlvdXQuXG5cdFx0Ly8gSGVyZSB3ZSBoYXZlbid0IGJlZW4gcG9zaXRpb25lZCB5ZXQsIGJ1dCBkaW1lbnNpb25zIGFyZSBjb3JyZWN0LlxuXHRcdC8vIFZhcmlhYmxlcyBzZXQgaW4gX2NvbmZpZ3VyZSBhcmUgbmVlZGVkIGZvciBjYWxjdWxhdGVUaWNrUm90YXRpb24sIGFuZFxuXHRcdC8vIGl0J3Mgb2sgdGhhdCBjb29yZGluYXRlcyBhcmUgbm90IGNvcnJlY3QgdGhlcmUsIG9ubHkgZGltZW5zaW9ucyBtYXR0ZXIuXG5cdFx0bWUuX2NvbmZpZ3VyZSgpO1xuXG5cdFx0Ly8gVGljayBSb3RhdGlvblxuXHRcdG1lLmJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbigpO1xuXHRcdG1lLmNhbGN1bGF0ZVRpY2tSb3RhdGlvbigpO1xuXHRcdG1lLmFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XG5cblx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRtZS5maXQoKTtcblx0XHRtZS5hZnRlckZpdCgpO1xuXG5cdFx0Ly8gQXV0by1za2lwXG5cdFx0bWUuX3RpY2tzVG9EcmF3ID0gdGlja09wdHMuZGlzcGxheSAmJiAodGlja09wdHMuYXV0b1NraXAgfHwgdGlja09wdHMuc291cmNlID09PSAnYXV0bycpID8gbWUuX2F1dG9Ta2lwKHRpY2tzKSA6IHRpY2tzO1xuXG5cdFx0aWYgKHNhbXBsaW5nRW5hYmxlZCkge1xuXHRcdFx0Ly8gR2VuZXJhdGUgbGFiZWxzIHVzaW5nIGFsbCBub24tc2tpcHBlZCB0aWNrc1xuXHRcdFx0bGFiZWxzID0gbWUuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKG1lLl90aWNrc1RvRHJhdyk7XG5cdFx0fVxuXG5cdFx0bWUudGlja3MgPSBsYWJlbHM7ICAgLy8gQkFDS1dBUkQgQ09NUEFUSUJJTElUWVxuXG5cdFx0Ly8gSU1QT1JUQU5UOiBhZnRlciB0aGlzIHBvaW50LCB3ZSBjb25zaWRlciB0aGF0IGB0aGlzLnRpY2tzYCB3aWxsIE5FVkVSIGNoYW5nZSFcblxuXHRcdG1lLmFmdGVyVXBkYXRlKCk7XG5cblx0XHQvLyBUT0RPKHYzKTogcmVtb3ZlIG1pblNpemUgYXMgYSBwdWJsaWMgcHJvcGVydHkgYW5kIHJldHVybiB2YWx1ZSBmcm9tIGFsbCBsYXlvdXQgYm94ZXMuIEl0IGlzIHVudXNlZFxuXHRcdC8vIG1ha2UgbWF4V2lkdGggYW5kIG1heEhlaWdodCBwcml2YXRlXG5cdFx0cmV0dXJuIG1lLm1pblNpemU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfY29uZmlndXJlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciByZXZlcnNlUGl4ZWxzID0gbWUub3B0aW9ucy50aWNrcy5yZXZlcnNlO1xuXHRcdHZhciBzdGFydFBpeGVsLCBlbmRQaXhlbDtcblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0c3RhcnRQaXhlbCA9IG1lLmxlZnQ7XG5cdFx0XHRlbmRQaXhlbCA9IG1lLnJpZ2h0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdGFydFBpeGVsID0gbWUudG9wO1xuXHRcdFx0ZW5kUGl4ZWwgPSBtZS5ib3R0b207XG5cdFx0XHQvLyBieSBkZWZhdWx0IHZlcnRpY2FsIHNjYWxlcyBhcmUgZnJvbSBib3R0b20gdG8gdG9wLCBzbyBwaXhlbHMgYXJlIHJldmVyc2VkXG5cdFx0XHRyZXZlcnNlUGl4ZWxzID0gIXJldmVyc2VQaXhlbHM7XG5cdFx0fVxuXHRcdG1lLl9zdGFydFBpeGVsID0gc3RhcnRQaXhlbDtcblx0XHRtZS5fZW5kUGl4ZWwgPSBlbmRQaXhlbDtcblx0XHRtZS5fcmV2ZXJzZVBpeGVscyA9IHJldmVyc2VQaXhlbHM7XG5cdFx0bWUuX2xlbmd0aCA9IGVuZFBpeGVsIC0gc3RhcnRQaXhlbDtcblx0fSxcblxuXHRhZnRlclVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcblx0fSxcblxuXHQvL1xuXG5cdGJlZm9yZVNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcblx0fSxcblx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xuXHRcdFx0bWUubGVmdCA9IDA7XG5cdFx0XHRtZS5yaWdodCA9IG1lLndpZHRoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XG5cblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0bWUudG9wID0gMDtcblx0XHRcdG1lLmJvdHRvbSA9IG1lLmhlaWdodDtcblx0XHR9XG5cblx0XHQvLyBSZXNldCBwYWRkaW5nXG5cdFx0bWUucGFkZGluZ0xlZnQgPSAwO1xuXHRcdG1lLnBhZGRpbmdUb3AgPSAwO1xuXHRcdG1lLnBhZGRpbmdSaWdodCA9IDA7XG5cdFx0bWUucGFkZGluZ0JvdHRvbSA9IDA7XG5cdH0sXG5cdGFmdGVyU2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG5cdH0sXG5cblx0Ly8gRGF0YSBsaW1pdHNcblx0YmVmb3JlRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVEYXRhTGltaXRzLCBbdGhpc10pO1xuXHR9LFxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBoZWxwZXJzJDEubm9vcCxcblx0YWZ0ZXJEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyRGF0YUxpbWl0cywgW3RoaXNdKTtcblx0fSxcblxuXHQvL1xuXHRiZWZvcmVCdWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUJ1aWxkVGlja3MsIFt0aGlzXSk7XG5cdH0sXG5cdGJ1aWxkVGlja3M6IGhlbHBlcnMkMS5ub29wLFxuXHRhZnRlckJ1aWxkVGlja3M6IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyB0aWNrcyBpcyBlbXB0eSBmb3Igb2xkIGF4aXMgaW1wbGVtZW50YXRpb25zIGhlcmVcblx0XHRpZiAoaXNBcnJheSh0aWNrcykgJiYgdGlja3MubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gaGVscGVycyQxLmNhbGxiYWNrKG1lLm9wdGlvbnMuYWZ0ZXJCdWlsZFRpY2tzLCBbbWUsIHRpY2tzXSk7XG5cdFx0fVxuXHRcdC8vIFN1cHBvcnQgb2xkIGltcGxlbWVudGF0aW9ucyAodGhhdCBtb2RpZmllZCBgdGhpcy50aWNrc2AgZGlyZWN0bHkgaW4gYnVpbGRUaWNrcylcblx0XHRtZS50aWNrcyA9IGhlbHBlcnMkMS5jYWxsYmFjayhtZS5vcHRpb25zLmFmdGVyQnVpbGRUaWNrcywgW21lLCBtZS50aWNrc10pIHx8IG1lLnRpY2tzO1xuXHRcdHJldHVybiB0aWNrcztcblx0fSxcblxuXHRiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb246IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuXHR9LFxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyBDb252ZXJ0IHRpY2tzIHRvIHN0cmluZ3Ncblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdG1lLnRpY2tzID0gbWUudGlja3MubWFwKHRpY2tPcHRzLnVzZXJDYWxsYmFjayB8fCB0aWNrT3B0cy5jYWxsYmFjaywgdGhpcyk7XG5cdH0sXG5cdGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cblx0YmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgW3RoaXNdKTtcblx0fSxcblx0Y2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuXHRcdHZhciBudW1UaWNrcyA9IG1lLmdldFRpY2tzKCkubGVuZ3RoO1xuXHRcdHZhciBtaW5Sb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XG5cdFx0dmFyIG1heFJvdGF0aW9uID0gdGlja09wdHMubWF4Um90YXRpb247XG5cdFx0dmFyIGxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcblx0XHR2YXIgbGFiZWxTaXplcywgbWF4TGFiZWxXaWR0aCwgbWF4TGFiZWxIZWlnaHQsIG1heFdpZHRoLCB0aWNrV2lkdGgsIG1heEhlaWdodCwgbWF4TGFiZWxEaWFnb25hbDtcblxuXHRcdGlmICghbWUuX2lzVmlzaWJsZSgpIHx8ICF0aWNrT3B0cy5kaXNwbGF5IHx8IG1pblJvdGF0aW9uID49IG1heFJvdGF0aW9uIHx8IG51bVRpY2tzIDw9IDEgfHwgIW1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRtZS5sYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bGFiZWxTaXplcyA9IG1lLl9nZXRMYWJlbFNpemVzKCk7XG5cdFx0bWF4TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuXHRcdG1heExhYmVsSGVpZ2h0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAtIGxhYmVsU2l6ZXMuaGlnaGVzdC5vZmZzZXQ7XG5cblx0XHQvLyBFc3RpbWF0ZSB0aGUgd2lkdGggb2YgZWFjaCBncmlkIGJhc2VkIG9uIHRoZSBjYW52YXMgd2lkdGgsIHRoZSBtYXhpbXVtXG5cdFx0Ly8gbGFiZWwgd2lkdGggYW5kIHRoZSBudW1iZXIgb2YgdGljayBpbnRlcnZhbHNcblx0XHRtYXhXaWR0aCA9IE1hdGgubWluKG1lLm1heFdpZHRoLCBtZS5jaGFydC53aWR0aCAtIG1heExhYmVsV2lkdGgpO1xuXHRcdHRpY2tXaWR0aCA9IG9wdGlvbnMub2Zmc2V0ID8gbWUubWF4V2lkdGggLyBudW1UaWNrcyA6IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gMSk7XG5cblx0XHQvLyBBbGxvdyAzIHBpeGVscyB4MiBwYWRkaW5nIGVpdGhlciBzaWRlIGZvciBsYWJlbCByZWFkYWJpbGl0eVxuXHRcdGlmIChtYXhMYWJlbFdpZHRoICsgNiA+IHRpY2tXaWR0aCkge1xuXHRcdFx0dGlja1dpZHRoID0gbWF4V2lkdGggLyAobnVtVGlja3MgLSAob3B0aW9ucy5vZmZzZXQgPyAwLjUgOiAxKSk7XG5cdFx0XHRtYXhIZWlnaHQgPSBtZS5tYXhIZWlnaHQgLSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWRMaW5lcylcblx0XHRcdFx0LSB0aWNrT3B0cy5wYWRkaW5nIC0gZ2V0U2NhbGVMYWJlbEhlaWdodChvcHRpb25zLnNjYWxlTGFiZWwpO1xuXHRcdFx0bWF4TGFiZWxEaWFnb25hbCA9IE1hdGguc3FydChtYXhMYWJlbFdpZHRoICogbWF4TGFiZWxXaWR0aCArIG1heExhYmVsSGVpZ2h0ICogbWF4TGFiZWxIZWlnaHQpO1xuXHRcdFx0bGFiZWxSb3RhdGlvbiA9IGhlbHBlcnMkMS50b0RlZ3JlZXMoTWF0aC5taW4oXG5cdFx0XHRcdE1hdGguYXNpbihNYXRoLm1pbigobGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIDYpIC8gdGlja1dpZHRoLCAxKSksXG5cdFx0XHRcdE1hdGguYXNpbihNYXRoLm1pbihtYXhIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAxKSkgLSBNYXRoLmFzaW4obWF4TGFiZWxIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsKVxuXHRcdFx0KSk7XG5cdFx0XHRsYWJlbFJvdGF0aW9uID0gTWF0aC5tYXgobWluUm90YXRpb24sIE1hdGgubWluKG1heFJvdGF0aW9uLCBsYWJlbFJvdGF0aW9uKSk7XG5cdFx0fVxuXG5cdFx0bWUubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG5cdH0sXG5cdGFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cblx0YmVmb3JlRml0OiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcblx0fSxcblx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIFJlc2V0XG5cdFx0dmFyIG1pblNpemUgPSBtZS5taW5TaXplID0ge1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDBcblx0XHR9O1xuXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cdFx0dmFyIHNjYWxlTGFiZWxPcHRzID0gb3B0cy5zY2FsZUxhYmVsO1xuXHRcdHZhciBncmlkTGluZU9wdHMgPSBvcHRzLmdyaWRMaW5lcztcblx0XHR2YXIgZGlzcGxheSA9IG1lLl9pc1Zpc2libGUoKTtcblx0XHR2YXIgaXNCb3R0b20gPSBvcHRzLnBvc2l0aW9uID09PSAnYm90dG9tJztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHQvLyBXaWR0aFxuXHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdG1pblNpemUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHR9IGVsc2UgaWYgKGRpc3BsYXkpIHtcblx0XHRcdG1pblNpemUud2lkdGggPSBnZXRUaWNrTWFya0xlbmd0aChncmlkTGluZU9wdHMpICsgZ2V0U2NhbGVMYWJlbEhlaWdodChzY2FsZUxhYmVsT3B0cyk7XG5cdFx0fVxuXG5cdFx0Ly8gaGVpZ2h0XG5cdFx0aWYgKCFpc0hvcml6b250YWwpIHtcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG5cdFx0fSBlbHNlIGlmIChkaXNwbGF5KSB7XG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRMaW5lT3B0cykgKyBnZXRTY2FsZUxhYmVsSGVpZ2h0KHNjYWxlTGFiZWxPcHRzKTtcblx0XHR9XG5cblx0XHQvLyBEb24ndCBib3RoZXIgZml0dGluZyB0aGUgdGlja3MgaWYgd2UgYXJlIG5vdCBzaG93aW5nIHRoZSBsYWJlbHNcblx0XHRpZiAodGlja09wdHMuZGlzcGxheSAmJiBkaXNwbGF5KSB7XG5cdFx0XHR2YXIgdGlja0ZvbnRzID0gcGFyc2VUaWNrRm9udE9wdGlvbnModGlja09wdHMpO1xuXHRcdFx0dmFyIGxhYmVsU2l6ZXMgPSBtZS5fZ2V0TGFiZWxTaXplcygpO1xuXHRcdFx0dmFyIGZpcnN0TGFiZWxTaXplID0gbGFiZWxTaXplcy5maXJzdDtcblx0XHRcdHZhciBsYXN0TGFiZWxTaXplID0gbGFiZWxTaXplcy5sYXN0O1xuXHRcdFx0dmFyIHdpZGVzdExhYmVsU2l6ZSA9IGxhYmVsU2l6ZXMud2lkZXN0O1xuXHRcdFx0dmFyIGhpZ2hlc3RMYWJlbFNpemUgPSBsYWJlbFNpemVzLmhpZ2hlc3Q7XG5cdFx0XHR2YXIgbGluZVNwYWNlID0gdGlja0ZvbnRzLm1pbm9yLmxpbmVIZWlnaHQgKiAwLjQ7XG5cdFx0XHR2YXIgdGlja1BhZGRpbmcgPSB0aWNrT3B0cy5wYWRkaW5nO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdC8vIEEgaG9yaXpvbnRhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIGhlaWdodC5cblx0XHRcdFx0dmFyIGlzUm90YXRlZCA9IG1lLmxhYmVsUm90YXRpb24gIT09IDA7XG5cdFx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXHRcdFx0XHR2YXIgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0XHR2YXIgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuXG5cdFx0XHRcdHZhciBsYWJlbEhlaWdodCA9IHNpblJvdGF0aW9uICogd2lkZXN0TGFiZWxTaXplLndpZHRoXG5cdFx0XHRcdFx0KyBjb3NSb3RhdGlvbiAqIChoaWdoZXN0TGFiZWxTaXplLmhlaWdodCAtIChpc1JvdGF0ZWQgPyBoaWdoZXN0TGFiZWxTaXplLm9mZnNldCA6IDApKVxuXHRcdFx0XHRcdCsgKGlzUm90YXRlZCA/IDAgOiBsaW5lU3BhY2UpOyAvLyBwYWRkaW5nXG5cblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBNYXRoLm1pbihtZS5tYXhIZWlnaHQsIG1pblNpemUuaGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyB0aWNrUGFkZGluZyk7XG5cblx0XHRcdFx0dmFyIG9mZnNldExlZnQgPSBtZS5nZXRQaXhlbEZvclRpY2soMCkgLSBtZS5sZWZ0O1xuXHRcdFx0XHR2YXIgb2Zmc2V0UmlnaHQgPSBtZS5yaWdodCAtIG1lLmdldFBpeGVsRm9yVGljayhtZS5nZXRUaWNrcygpLmxlbmd0aCAtIDEpO1xuXHRcdFx0XHR2YXIgcGFkZGluZ0xlZnQsIHBhZGRpbmdSaWdodDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhhdCBvdXIgdGlja3MgYXJlIGFsd2F5cyBpbnNpZGUgdGhlIGNhbnZhcy4gV2hlbiByb3RhdGVkLCB0aWNrcyBhcmUgcmlnaHQgYWxpZ25lZFxuXHRcdFx0XHQvLyB3aGljaCBtZWFucyB0aGF0IHRoZSByaWdodCBwYWRkaW5nIGlzIGRvbWluYXRlZCBieSB0aGUgZm9udCBoZWlnaHRcblx0XHRcdFx0aWYgKGlzUm90YXRlZCkge1xuXHRcdFx0XHRcdHBhZGRpbmdMZWZ0ID0gaXNCb3R0b20gP1xuXHRcdFx0XHRcdFx0Y29zUm90YXRpb24gKiBmaXJzdExhYmVsU2l6ZS53aWR0aCArIHNpblJvdGF0aW9uICogZmlyc3RMYWJlbFNpemUub2Zmc2V0IDpcblx0XHRcdFx0XHRcdHNpblJvdGF0aW9uICogKGZpcnN0TGFiZWxTaXplLmhlaWdodCAtIGZpcnN0TGFiZWxTaXplLm9mZnNldCk7XG5cdFx0XHRcdFx0cGFkZGluZ1JpZ2h0ID0gaXNCb3R0b20gP1xuXHRcdFx0XHRcdFx0c2luUm90YXRpb24gKiAobGFzdExhYmVsU2l6ZS5oZWlnaHQgLSBsYXN0TGFiZWxTaXplLm9mZnNldCkgOlxuXHRcdFx0XHRcdFx0Y29zUm90YXRpb24gKiBsYXN0TGFiZWxTaXplLndpZHRoICsgc2luUm90YXRpb24gKiBsYXN0TGFiZWxTaXplLm9mZnNldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYWRkaW5nTGVmdCA9IGZpcnN0TGFiZWxTaXplLndpZHRoIC8gMjtcblx0XHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBsYXN0TGFiZWxTaXplLndpZHRoIC8gMjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkanVzdCBwYWRkaW5nIHRha2luZyBpbnRvIGFjY291bnQgY2hhbmdlcyBpbiBvZmZzZXRzXG5cdFx0XHRcdC8vIGFuZCBhZGQgMyBweCB0byBtb3ZlIGF3YXkgZnJvbSBjYW52YXMgZWRnZXNcblx0XHRcdFx0bWUucGFkZGluZ0xlZnQgPSBNYXRoLm1heCgocGFkZGluZ0xlZnQgLSBvZmZzZXRMZWZ0KSAqIG1lLndpZHRoIC8gKG1lLndpZHRoIC0gb2Zmc2V0TGVmdCksIDApICsgMztcblx0XHRcdFx0bWUucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0KSAqIG1lLndpZHRoIC8gKG1lLndpZHRoIC0gb2Zmc2V0UmlnaHQpLCAwKSArIDM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBBIHZlcnRpY2FsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgd2lkdGguIExhYmVscyBhcmUgdGhlXG5cdFx0XHRcdC8vIGRvbWluYW50IGZhY3RvciBoZXJlLCBzbyBnZXQgdGhhdCBsZW5ndGggZmlyc3QgYW5kIGFjY291bnQgZm9yIHBhZGRpbmdcblx0XHRcdFx0dmFyIGxhYmVsV2lkdGggPSB0aWNrT3B0cy5taXJyb3IgPyAwIDpcblx0XHRcdFx0XHQvLyB1c2UgbGluZVNwYWNlIGZvciBjb25zaXN0ZW5jeSB3aXRoIGhvcml6b250YWwgYXhpc1xuXHRcdFx0XHRcdC8vIHRpY2tQYWRkaW5nIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgaG9yaXpvbnRhbFxuXHRcdFx0XHRcdHdpZGVzdExhYmVsU2l6ZS53aWR0aCArIHRpY2tQYWRkaW5nICsgbGluZVNwYWNlO1xuXG5cdFx0XHRcdG1pblNpemUud2lkdGggPSBNYXRoLm1pbihtZS5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhYmVsV2lkdGgpO1xuXG5cdFx0XHRcdG1lLnBhZGRpbmdUb3AgPSBmaXJzdExhYmVsU2l6ZS5oZWlnaHQgLyAyO1xuXHRcdFx0XHRtZS5wYWRkaW5nQm90dG9tID0gbGFzdExhYmVsU2l6ZS5oZWlnaHQgLyAyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lLmhhbmRsZU1hcmdpbnMoKTtcblxuXHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdG1lLndpZHRoID0gbWUuX2xlbmd0aCA9IGNoYXJ0LndpZHRoIC0gbWUubWFyZ2lucy5sZWZ0IC0gbWUubWFyZ2lucy5yaWdodDtcblx0XHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS53aWR0aCA9IG1pblNpemUud2lkdGg7XG5cdFx0XHRtZS5oZWlnaHQgPSBtZS5fbGVuZ3RoID0gY2hhcnQuaGVpZ2h0IC0gbWUubWFyZ2lucy50b3AgLSBtZS5tYXJnaW5zLmJvdHRvbTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZSBtYXJnaW5zIGFuZCBwYWRkaW5nIGludGVyYWN0aW9uc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aGFuZGxlTWFyZ2luczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRpZiAobWUubWFyZ2lucykge1xuXHRcdFx0bWUubWFyZ2lucy5sZWZ0ID0gTWF0aC5tYXgobWUucGFkZGluZ0xlZnQsIG1lLm1hcmdpbnMubGVmdCk7XG5cdFx0XHRtZS5tYXJnaW5zLnRvcCA9IE1hdGgubWF4KG1lLnBhZGRpbmdUb3AsIG1lLm1hcmdpbnMudG9wKTtcblx0XHRcdG1lLm1hcmdpbnMucmlnaHQgPSBNYXRoLm1heChtZS5wYWRkaW5nUmlnaHQsIG1lLm1hcmdpbnMucmlnaHQpO1xuXHRcdFx0bWUubWFyZ2lucy5ib3R0b20gPSBNYXRoLm1heChtZS5wYWRkaW5nQm90dG9tLCBtZS5tYXJnaW5zLmJvdHRvbSk7XG5cdFx0fVxuXHR9LFxuXG5cdGFmdGVyRml0OiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vIFNoYXJlZCBNZXRob2RzXG5cdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcblx0XHRyZXR1cm4gcG9zID09PSAndG9wJyB8fCBwb3MgPT09ICdib3R0b20nO1xuXHR9LFxuXHRpc0Z1bGxXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5mdWxsV2lkdGg7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBjb3JyZWN0IHZhbHVlLiBOYU4gYmFkIGlucHV0cywgSWYgdGhlIHZhbHVlIHR5cGUgaXMgb2JqZWN0IGdldCB0aGUgeCBvciB5IGJhc2VkIG9uIHdoZXRoZXIgd2UgYXJlIGhvcml6b250YWwgb3Igbm90XG5cdGdldFJpZ2h0VmFsdWU6IGZ1bmN0aW9uKHJhd1ZhbHVlKSB7XG5cdFx0Ly8gTnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBmaXJzdFxuXHRcdGlmIChpc051bGxPclVuZGVmKHJhd1ZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIE5hTjtcblx0XHR9XG5cdFx0Ly8gaXNOYU4ob2JqZWN0KSByZXR1cm5zIHRydWUsIHNvIG1ha2Ugc3VyZSBOYU4gaXMgY2hlY2tpbmcgZm9yIGEgbnVtYmVyOyBEaXNjYXJkIEluZmluaXRlIHZhbHVlc1xuXHRcdGlmICgodHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyB8fCByYXdWYWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKHJhd1ZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIE5hTjtcblx0XHR9XG5cblx0XHQvLyBJZiBpdCBpcyBpbiBmYWN0IGFuIG9iamVjdCwgZGl2ZSBpbiBvbmUgbW9yZSBsZXZlbFxuXHRcdGlmIChyYXdWYWx1ZSkge1xuXHRcdFx0aWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0aWYgKHJhd1ZhbHVlLnggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUueCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAocmF3VmFsdWUueSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUueSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gVmFsdWUgaXMgZ29vZCwgcmV0dXJuIGl0XG5cdFx0cmV0dXJuIHJhd1ZhbHVlO1xuXHR9LFxuXG5cdF9jb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsYWJlbHMsIGksIGlsZW47XG5cblx0XHRtZS50aWNrcyA9IHRpY2tzLm1hcChmdW5jdGlvbih0aWNrKSB7XG5cdFx0XHRyZXR1cm4gdGljay52YWx1ZTtcblx0XHR9KTtcblxuXHRcdG1lLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuXG5cdFx0Ly8gTmV3IGltcGxlbWVudGF0aW9ucyBzaG91bGQgcmV0dXJuIHRoZSBmb3JtYXR0ZWQgdGljayBsYWJlbHMgYnV0IGZvciBCQUNLV0FSRFxuXHRcdC8vIENPTVBBVCwgd2Ugc3RpbGwgc3VwcG9ydCBubyByZXR1cm4gKGB0aGlzLnRpY2tzYCBpbnRlcm5hbGx5IGNoYW5nZWQgYnkgY2FsbGluZ1xuXHRcdC8vIHRoaXMgbWV0aG9kIGFuZCBzdXBwb3NlZCB0byBjb250YWluIG9ubHkgc3RyaW5nIHZhbHVlcykuXG5cdFx0bGFiZWxzID0gbWUuY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHx8IG1lLnRpY2tzO1xuXG5cdFx0bWUuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcblxuXHRcdC8vIEJBQ0tXQVJEIENPTVBBVDogc3luY2hyb25pemUgYF90aWNrc2Agd2l0aCBsYWJlbHMgKHNvIHBvdGVudGlhbGx5IGB0aGlzLnRpY2tzYClcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHR0aWNrc1tpXS5sYWJlbCA9IGxhYmVsc1tpXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGFiZWxzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldExhYmVsU2l6ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGxhYmVsU2l6ZXMgPSBtZS5fbGFiZWxTaXplcztcblxuXHRcdGlmICghbGFiZWxTaXplcykge1xuXHRcdFx0bWUuX2xhYmVsU2l6ZXMgPSBsYWJlbFNpemVzID0gY29tcHV0ZUxhYmVsU2l6ZXMobWUuY3R4LCBwYXJzZVRpY2tGb250T3B0aW9ucyhtZS5vcHRpb25zLnRpY2tzKSwgbWUuZ2V0VGlja3MoKSwgbWUubG9uZ2VzdFRleHRDYWNoZSk7XG5cdFx0XHRtZS5sb25nZXN0TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuXHRcdH1cblxuXHRcdHJldHVybiBsYWJlbFNpemVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3BhcnNlVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIHN0YXJ0LCBlbmQsIG1pbiwgbWF4O1xuXG5cdFx0aWYgKGlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRzdGFydCA9ICt0aGlzLmdldFJpZ2h0VmFsdWUodmFsdWVbMF0pO1xuXHRcdFx0ZW5kID0gK3RoaXMuZ2V0UmlnaHRWYWx1ZSh2YWx1ZVsxXSk7XG5cdFx0XHRtaW4gPSBNYXRoLm1pbihzdGFydCwgZW5kKTtcblx0XHRcdG1heCA9IE1hdGgubWF4KHN0YXJ0LCBlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9ICt0aGlzLmdldFJpZ2h0VmFsdWUodmFsdWUpO1xuXHRcdFx0c3RhcnQgPSB1bmRlZmluZWQ7XG5cdFx0XHRlbmQgPSB2YWx1ZTtcblx0XHRcdG1pbiA9IHZhbHVlO1xuXHRcdFx0bWF4ID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdG1pbjogbWluLFxuXHRcdFx0bWF4OiBtYXgsXG5cdFx0XHRzdGFydDogc3RhcnQsXG5cdFx0XHRlbmQ6IGVuZFxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCogQHByaXZhdGVcblx0Ki9cblx0X2dldFNjYWxlTGFiZWw6IGZ1bmN0aW9uKHJhd1ZhbHVlKSB7XG5cdFx0dmFyIHYgPSB0aGlzLl9wYXJzZVZhbHVlKHJhd1ZhbHVlKTtcblx0XHRpZiAodi5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gJ1snICsgdi5zdGFydCArICcsICcgKyB2LmVuZCArICddJztcblx0XHR9XG5cblx0XHRyZXR1cm4gK3RoaXMuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gZ2V0IHRoZSB2YWx1ZSB0byBkaXNwbGF5IGluIHRoZSB0b29sdGlwIGZvciB0aGUgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqIEBwYXJhbSBkYXRhc2V0SW5kZXhcblx0ICovXG5cdGdldExhYmVsRm9ySW5kZXg6IGhlbHBlcnMkMS5ub29wLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgZ2l2ZW4gZGF0YSBwb2ludC4gVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHZhbHVlXG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKiBAcGFyYW0gZGF0YXNldEluZGV4XG5cdCAqL1xuXHRnZXRQaXhlbEZvclZhbHVlOiBoZWxwZXJzJDEubm9vcCxcblxuXHQvKipcblx0ICogVXNlZCB0byBnZXQgdGhlIGRhdGEgdmFsdWUgZnJvbSBhIGdpdmVuIHBpeGVsLiBUaGlzIGlzIHRoZSBpbnZlcnNlIG9mIGdldFBpeGVsRm9yVmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSBwaXhlbFxuXHQgKi9cblx0Z2V0VmFsdWVGb3JQaXhlbDogaGVscGVycyQxLm5vb3AsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSB0aWNrIGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICovXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvZmZzZXQgPSBtZS5vcHRpb25zLm9mZnNldDtcblx0XHR2YXIgbnVtVGlja3MgPSBtZS5fdGlja3MubGVuZ3RoO1xuXHRcdHZhciB0aWNrV2lkdGggPSAxIC8gTWF0aC5tYXgobnVtVGlja3MgLSAob2Zmc2V0ID8gMCA6IDEpLCAxKTtcblxuXHRcdHJldHVybiBpbmRleCA8IDAgfHwgaW5kZXggPiBudW1UaWNrcyAtIDFcblx0XHRcdD8gbnVsbFxuXHRcdFx0OiBtZS5nZXRQaXhlbEZvckRlY2ltYWwoaW5kZXggKiB0aWNrV2lkdGggKyAob2Zmc2V0ID8gdGlja1dpZHRoIC8gMiA6IDApKTtcblx0fSxcblxuXHQvKipcblx0ICogVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgcGl4ZWwgbG9jYXRpb24gb2YgYSBwZXJjZW50YWdlIG9mIHNjYWxlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKi9cblx0Z2V0UGl4ZWxGb3JEZWNpbWFsOiBmdW5jdGlvbihkZWNpbWFsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmIChtZS5fcmV2ZXJzZVBpeGVscykge1xuXHRcdFx0ZGVjaW1hbCA9IDEgLSBkZWNpbWFsO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZS5fc3RhcnRQaXhlbCArIGRlY2ltYWwgKiBtZS5fbGVuZ3RoO1xuXHR9LFxuXG5cdGdldERlY2ltYWxGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHR2YXIgZGVjaW1hbCA9IChwaXhlbCAtIHRoaXMuX3N0YXJ0UGl4ZWwpIC8gdGhpcy5fbGVuZ3RoO1xuXHRcdHJldHVybiB0aGlzLl9yZXZlcnNlUGl4ZWxzID8gMSAtIGRlY2ltYWwgOiBkZWNpbWFsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwaXhlbCBmb3IgdGhlIG1pbmltdW0gY2hhcnQgdmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqL1xuXHRnZXRCYXNlUGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XG5cdH0sXG5cblx0Z2V0QmFzZVZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtaW4gPSBtZS5taW47XG5cdFx0dmFyIG1heCA9IG1lLm1heDtcblxuXHRcdHJldHVybiBtZS5iZWdpbkF0WmVybyA/IDAgOlxuXHRcdFx0bWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcblx0XHRcdG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG5cdFx0XHQwO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3Vic2V0IG9mIHRpY2tzIHRvIGJlIHBsb3R0ZWQgdG8gYXZvaWQgb3ZlcmxhcHBpbmcgbGFiZWxzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2F1dG9Ta2lwOiBmdW5jdGlvbih0aWNrcykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgYXhpc0xlbmd0aCA9IG1lLl9sZW5ndGg7XG5cdFx0dmFyIHRpY2tzTGltaXQgPSB0aWNrT3B0cy5tYXhUaWNrc0xpbWl0IHx8IGF4aXNMZW5ndGggLyBtZS5fdGlja1NpemUoKSArIDE7XG5cdFx0dmFyIG1ham9ySW5kaWNlcyA9IHRpY2tPcHRzLm1ham9yLmVuYWJsZWQgPyBnZXRNYWpvckluZGljZXModGlja3MpIDogW107XG5cdFx0dmFyIG51bU1ham9ySW5kaWNlcyA9IG1ham9ySW5kaWNlcy5sZW5ndGg7XG5cdFx0dmFyIGZpcnN0ID0gbWFqb3JJbmRpY2VzWzBdO1xuXHRcdHZhciBsYXN0ID0gbWFqb3JJbmRpY2VzW251bU1ham9ySW5kaWNlcyAtIDFdO1xuXHRcdHZhciBpLCBpbGVuLCBzcGFjaW5nLCBhdmdNYWpvclNwYWNpbmc7XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgdG9vIG1hbnkgbWFqb3IgdGlja3MgdG8gZGlzcGxheSB0aGVtIGFsbFxuXHRcdGlmIChudW1NYWpvckluZGljZXMgPiB0aWNrc0xpbWl0KSB7XG5cdFx0XHRza2lwTWFqb3JzKHRpY2tzLCBtYWpvckluZGljZXMsIG51bU1ham9ySW5kaWNlcyAvIHRpY2tzTGltaXQpO1xuXHRcdFx0cmV0dXJuIG5vblNraXBwZWQodGlja3MpO1xuXHRcdH1cblxuXHRcdHNwYWNpbmcgPSBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIGF4aXNMZW5ndGgsIHRpY2tzTGltaXQpO1xuXG5cdFx0aWYgKG51bU1ham9ySW5kaWNlcyA+IDApIHtcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBudW1NYWpvckluZGljZXMgLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG5cdFx0XHRcdHNraXAodGlja3MsIHNwYWNpbmcsIG1ham9ySW5kaWNlc1tpXSwgbWFqb3JJbmRpY2VzW2kgKyAxXSk7XG5cdFx0XHR9XG5cdFx0XHRhdmdNYWpvclNwYWNpbmcgPSBudW1NYWpvckluZGljZXMgPiAxID8gKGxhc3QgLSBmaXJzdCkgLyAobnVtTWFqb3JJbmRpY2VzIC0gMSkgOiBudWxsO1xuXHRcdFx0c2tpcCh0aWNrcywgc3BhY2luZywgaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IDAgOiBmaXJzdCAtIGF2Z01ham9yU3BhY2luZywgZmlyc3QpO1xuXHRcdFx0c2tpcCh0aWNrcywgc3BhY2luZywgbGFzdCwgaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IHRpY2tzLmxlbmd0aCA6IGxhc3QgKyBhdmdNYWpvclNwYWNpbmcpO1xuXHRcdFx0cmV0dXJuIG5vblNraXBwZWQodGlja3MpO1xuXHRcdH1cblx0XHRza2lwKHRpY2tzLCBzcGFjaW5nKTtcblx0XHRyZXR1cm4gbm9uU2tpcHBlZCh0aWNrcyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfdGlja1NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvblRpY2tzID0gbWUub3B0aW9ucy50aWNrcztcblxuXHRcdC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgYnkgbGFiZWwgaW4gYXhpcyBkaXJlY3Rpb24uXG5cdFx0dmFyIHJvdCA9IGhlbHBlcnMkMS50b1JhZGlhbnMobWUubGFiZWxSb3RhdGlvbik7XG5cdFx0dmFyIGNvcyA9IE1hdGguYWJzKE1hdGguY29zKHJvdCkpO1xuXHRcdHZhciBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3QpKTtcblxuXHRcdHZhciBsYWJlbFNpemVzID0gbWUuX2dldExhYmVsU2l6ZXMoKTtcblx0XHR2YXIgcGFkZGluZyA9IG9wdGlvblRpY2tzLmF1dG9Ta2lwUGFkZGluZyB8fCAwO1xuXHRcdHZhciB3ID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoICsgcGFkZGluZyA6IDA7XG5cdFx0dmFyIGggPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIHBhZGRpbmcgOiAwO1xuXG5cdFx0Ly8gQ2FsY3VsYXRlIHNwYWNlIG5lZWRlZCBmb3IgMSB0aWNrIGluIGF4aXMgZGlyZWN0aW9uLlxuXHRcdHJldHVybiBtZS5pc0hvcml6b250YWwoKVxuXHRcdFx0PyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luXG5cdFx0XHQ6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkaXNwbGF5ID0gbWUub3B0aW9ucy5kaXNwbGF5O1xuXHRcdHZhciBpLCBpbGVuLCBtZXRhO1xuXG5cdFx0aWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xuXHRcdFx0cmV0dXJuICEhZGlzcGxheTtcblx0XHR9XG5cblx0XHQvLyBXaGVuICdhdXRvJywgdGhlIHNjYWxlIGlzIHZpc2libGUgaWYgYXQgbGVhc3Qgb25lIGFzc29jaWF0ZWQgZGF0YXNldCBpcyB2aXNpYmxlLlxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRpZiAobWV0YS54QXhpc0lEID09PSBtZS5pZCB8fCBtZXRhLnlBeGlzSUQgPT09IG1lLmlkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfY29tcHV0ZUdyaWRMaW5lSXRlbXM6IGZ1bmN0aW9uKGNoYXJ0QXJlYSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBncmlkTGluZXMgPSBvcHRpb25zLmdyaWRMaW5lcztcblx0XHR2YXIgcG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuXHRcdHZhciBvZmZzZXRHcmlkTGluZXMgPSBncmlkTGluZXMub2Zmc2V0R3JpZExpbmVzO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgdGlja3MgPSBtZS5fdGlja3NUb0RyYXc7XG5cdFx0dmFyIHRpY2tzTGVuZ3RoID0gdGlja3MubGVuZ3RoICsgKG9mZnNldEdyaWRMaW5lcyA/IDEgOiAwKTtcblxuXHRcdHZhciB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRMaW5lcyk7XG5cdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0dmFyIGF4aXNXaWR0aCA9IGdyaWRMaW5lcy5kcmF3Qm9yZGVyID8gdmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5saW5lV2lkdGgsIDAsIDApIDogMDtcblx0XHR2YXIgYXhpc0hhbGZXaWR0aCA9IGF4aXNXaWR0aCAvIDI7XG5cdFx0dmFyIGFsaWduUGl4ZWwgPSBoZWxwZXJzJDEuX2FsaWduUGl4ZWw7XG5cdFx0dmFyIGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xuXHRcdFx0cmV0dXJuIGFsaWduUGl4ZWwoY2hhcnQsIHBpeGVsLCBheGlzV2lkdGgpO1xuXHRcdH07XG5cdFx0dmFyIGJvcmRlclZhbHVlLCBpLCB0aWNrLCBsaW5lVmFsdWUsIGFsaWduZWRMaW5lVmFsdWU7XG5cdFx0dmFyIHR4MSwgdHkxLCB0eDIsIHR5MiwgeDEsIHkxLCB4MiwgeTIsIGxpbmVXaWR0aCwgbGluZUNvbG9yLCBib3JkZXJEYXNoLCBib3JkZXJEYXNoT2Zmc2V0O1xuXG5cdFx0aWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKG1lLmJvdHRvbSk7XG5cdFx0XHR0eTEgPSBtZS5ib3R0b20gLSB0bDtcblx0XHRcdHR5MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcblx0XHRcdHkxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEudG9wKSArIGF4aXNIYWxmV2lkdGg7XG5cdFx0XHR5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZShtZS50b3ApO1xuXHRcdFx0eTEgPSBjaGFydEFyZWEudG9wO1xuXHRcdFx0eTIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5ib3R0b20pIC0gYXhpc0hhbGZXaWR0aDtcblx0XHRcdHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcblx0XHRcdHR5MiA9IG1lLnRvcCArIHRsO1xuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKG1lLnJpZ2h0KTtcblx0XHRcdHR4MSA9IG1lLnJpZ2h0IC0gdGw7XG5cdFx0XHR0eDIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG5cdFx0XHR4MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmxlZnQpICsgYXhpc0hhbGZXaWR0aDtcblx0XHRcdHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUobWUubGVmdCk7XG5cdFx0XHR4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuXHRcdFx0eDIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5yaWdodCkgLSBheGlzSGFsZldpZHRoO1xuXHRcdFx0dHgxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuXHRcdFx0dHgyID0gbWUubGVmdCArIHRsO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aWNrc0xlbmd0aDsgKytpKSB7XG5cdFx0XHR0aWNrID0gdGlja3NbaV0gfHwge307XG5cblx0XHRcdC8vIGF1dG9za2lwcGVyIHNraXBwZWQgdGhpcyB0aWNrICgjNDYzNSlcblx0XHRcdGlmIChpc051bGxPclVuZGVmKHRpY2subGFiZWwpICYmIGkgPCB0aWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpID09PSBtZS56ZXJvTGluZUluZGV4ICYmIG9wdGlvbnMub2Zmc2V0ID09PSBvZmZzZXRHcmlkTGluZXMpIHtcblx0XHRcdFx0Ly8gRHJhdyB0aGUgZmlyc3QgaW5kZXggc3BlY2lhbGx5XG5cdFx0XHRcdGxpbmVXaWR0aCA9IGdyaWRMaW5lcy56ZXJvTGluZVdpZHRoO1xuXHRcdFx0XHRsaW5lQ29sb3IgPSBncmlkTGluZXMuemVyb0xpbmVDb2xvcjtcblx0XHRcdFx0Ym9yZGVyRGFzaCA9IGdyaWRMaW5lcy56ZXJvTGluZUJvcmRlckRhc2ggfHwgW107XG5cdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQgPSBncmlkTGluZXMuemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0IHx8IDAuMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxpbmVXaWR0aCA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCBpLCAxKTtcblx0XHRcdFx0bGluZUNvbG9yID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5jb2xvciwgaSwgJ3JnYmEoMCwwLDAsMC4xKScpO1xuXHRcdFx0XHRib3JkZXJEYXNoID0gZ3JpZExpbmVzLmJvcmRlckRhc2ggfHwgW107XG5cdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQgPSBncmlkTGluZXMuYm9yZGVyRGFzaE9mZnNldCB8fCAwLjA7XG5cdFx0XHR9XG5cblx0XHRcdGxpbmVWYWx1ZSA9IGdldFBpeGVsRm9yR3JpZExpbmUobWUsIHRpY2suX2luZGV4IHx8IGksIG9mZnNldEdyaWRMaW5lcyk7XG5cblx0XHRcdC8vIFNraXAgaWYgdGhlIHBpeGVsIGlzIG91dCBvZiB0aGUgcmFuZ2Vcblx0XHRcdGlmIChsaW5lVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0YWxpZ25lZExpbmVWYWx1ZSA9IGFsaWduUGl4ZWwoY2hhcnQsIGxpbmVWYWx1ZSwgbGluZVdpZHRoKTtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHR0eDEgPSB0eDIgPSB4MSA9IHgyID0gYWxpZ25lZExpbmVWYWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5MSA9IHR5MiA9IHkxID0geTIgPSBhbGlnbmVkTGluZVZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpdGVtcy5wdXNoKHtcblx0XHRcdFx0dHgxOiB0eDEsXG5cdFx0XHRcdHR5MTogdHkxLFxuXHRcdFx0XHR0eDI6IHR4Mixcblx0XHRcdFx0dHkyOiB0eTIsXG5cdFx0XHRcdHgxOiB4MSxcblx0XHRcdFx0eTE6IHkxLFxuXHRcdFx0XHR4MjogeDIsXG5cdFx0XHRcdHkyOiB5Mixcblx0XHRcdFx0d2lkdGg6IGxpbmVXaWR0aCxcblx0XHRcdFx0Y29sb3I6IGxpbmVDb2xvcixcblx0XHRcdFx0Ym9yZGVyRGFzaDogYm9yZGVyRGFzaCxcblx0XHRcdFx0Ym9yZGVyRGFzaE9mZnNldDogYm9yZGVyRGFzaE9mZnNldCxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGl0ZW1zLnRpY2tzTGVuZ3RoID0gdGlja3NMZW5ndGg7XG5cdFx0aXRlbXMuYm9yZGVyVmFsdWUgPSBib3JkZXJWYWx1ZTtcblxuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jb21wdXRlTGFiZWxJdGVtczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIG9wdGlvblRpY2tzID0gb3B0aW9ucy50aWNrcztcblx0XHR2YXIgcG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuXHRcdHZhciBpc01pcnJvcmVkID0gb3B0aW9uVGlja3MubWlycm9yO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgdGlja3MgPSBtZS5fdGlja3NUb0RyYXc7XG5cdFx0dmFyIGZvbnRzID0gcGFyc2VUaWNrRm9udE9wdGlvbnMob3B0aW9uVGlja3MpO1xuXHRcdHZhciB0aWNrUGFkZGluZyA9IG9wdGlvblRpY2tzLnBhZGRpbmc7XG5cdFx0dmFyIHRsID0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkTGluZXMpO1xuXHRcdHZhciByb3RhdGlvbiA9IC1oZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdHZhciBpLCBpbGVuLCB0aWNrLCBsYWJlbCwgeCwgeSwgdGV4dEFsaWduLCBwaXhlbCwgZm9udCwgbGluZUhlaWdodCwgbGluZUNvdW50LCB0ZXh0T2Zmc2V0O1xuXG5cdFx0aWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuXHRcdFx0eSA9IG1lLmJvdHRvbSAtIHRsIC0gdGlja1BhZGRpbmc7XG5cdFx0XHR0ZXh0QWxpZ24gPSAhcm90YXRpb24gPyAnY2VudGVyJyA6ICdsZWZ0Jztcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuXHRcdFx0eSA9IG1lLnRvcCArIHRsICsgdGlja1BhZGRpbmc7XG5cdFx0XHR0ZXh0QWxpZ24gPSAhcm90YXRpb24gPyAnY2VudGVyJyA6ICdyaWdodCc7XG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHR4ID0gbWUucmlnaHQgLSAoaXNNaXJyb3JlZCA/IDAgOiB0bCkgLSB0aWNrUGFkZGluZztcblx0XHRcdHRleHRBbGlnbiA9IGlzTWlycm9yZWQgPyAnbGVmdCcgOiAncmlnaHQnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gbWUubGVmdCArIChpc01pcnJvcmVkID8gMCA6IHRsKSArIHRpY2tQYWRkaW5nO1xuXHRcdFx0dGV4dEFsaWduID0gaXNNaXJyb3JlZCA/ICdyaWdodCcgOiAnbGVmdCc7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0dGljayA9IHRpY2tzW2ldO1xuXHRcdFx0bGFiZWwgPSB0aWNrLmxhYmVsO1xuXG5cdFx0XHQvLyBhdXRvc2tpcHBlciBza2lwcGVkIHRoaXMgdGljayAoIzQ2MzUpXG5cdFx0XHRpZiAoaXNOdWxsT3JVbmRlZihsYWJlbCkpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHBpeGVsID0gbWUuZ2V0UGl4ZWxGb3JUaWNrKHRpY2suX2luZGV4IHx8IGkpICsgb3B0aW9uVGlja3MubGFiZWxPZmZzZXQ7XG5cdFx0XHRmb250ID0gdGljay5tYWpvciA/IGZvbnRzLm1ham9yIDogZm9udHMubWlub3I7XG5cdFx0XHRsaW5lSGVpZ2h0ID0gZm9udC5saW5lSGVpZ2h0O1xuXHRcdFx0bGluZUNvdW50ID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbC5sZW5ndGggOiAxO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdHggPSBwaXhlbDtcblx0XHRcdFx0dGV4dE9mZnNldCA9IHBvc2l0aW9uID09PSAndG9wJ1xuXHRcdFx0XHRcdD8gKCghcm90YXRpb24gPyAwLjUgOiAxKSAtIGxpbmVDb3VudCkgKiBsaW5lSGVpZ2h0XG5cdFx0XHRcdFx0OiAoIXJvdGF0aW9uID8gMC41IDogMCkgKiBsaW5lSGVpZ2h0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eSA9IHBpeGVsO1xuXHRcdFx0XHR0ZXh0T2Zmc2V0ID0gKDEgLSBsaW5lQ291bnQpICogbGluZUhlaWdodCAvIDI7XG5cdFx0XHR9XG5cblx0XHRcdGl0ZW1zLnB1c2goe1xuXHRcdFx0XHR4OiB4LFxuXHRcdFx0XHR5OiB5LFxuXHRcdFx0XHRyb3RhdGlvbjogcm90YXRpb24sXG5cdFx0XHRcdGxhYmVsOiBsYWJlbCxcblx0XHRcdFx0Zm9udDogZm9udCxcblx0XHRcdFx0dGV4dE9mZnNldDogdGV4dE9mZnNldCxcblx0XHRcdFx0dGV4dEFsaWduOiB0ZXh0QWxpZ25cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9kcmF3R3JpZDogZnVuY3Rpb24oY2hhcnRBcmVhKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgZ3JpZExpbmVzID0gbWUub3B0aW9ucy5ncmlkTGluZXM7XG5cblx0XHRpZiAoIWdyaWRMaW5lcy5kaXNwbGF5KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGN0eCA9IG1lLmN0eDtcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgYWxpZ25QaXhlbCA9IGhlbHBlcnMkMS5fYWxpZ25QaXhlbDtcblx0XHR2YXIgYXhpc1dpZHRoID0gZ3JpZExpbmVzLmRyYXdCb3JkZXIgPyB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgMCwgMCkgOiAwO1xuXHRcdHZhciBpdGVtcyA9IG1lLl9ncmlkTGluZUl0ZW1zIHx8IChtZS5fZ3JpZExpbmVJdGVtcyA9IG1lLl9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpKTtcblx0XHR2YXIgd2lkdGgsIGNvbG9yLCBpLCBpbGVuLCBpdGVtO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0d2lkdGggPSBpdGVtLndpZHRoO1xuXHRcdFx0Y29sb3IgPSBpdGVtLmNvbG9yO1xuXG5cdFx0XHRpZiAod2lkdGggJiYgY29sb3IpIHtcblx0XHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcblx0XHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChpdGVtLmJvcmRlckRhc2gpO1xuXHRcdFx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IGl0ZW0uYm9yZGVyRGFzaE9mZnNldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdFx0XHRpZiAoZ3JpZExpbmVzLmRyYXdUaWNrcykge1xuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oaXRlbS50eDEsIGl0ZW0udHkxKTtcblx0XHRcdFx0XHRjdHgubGluZVRvKGl0ZW0udHgyLCBpdGVtLnR5Mik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZ3JpZExpbmVzLmRyYXdPbkNoYXJ0QXJlYSkge1xuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oaXRlbS54MSwgaXRlbS55MSk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyhpdGVtLngyLCBpdGVtLnkyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoYXhpc1dpZHRoKSB7XG5cdFx0XHQvLyBEcmF3IHRoZSBsaW5lIGF0IHRoZSBlZGdlIG9mIHRoZSBheGlzXG5cdFx0XHR2YXIgZmlyc3RMaW5lV2lkdGggPSBheGlzV2lkdGg7XG5cdFx0XHR2YXIgbGFzdExpbmVXaWR0aCA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCBpdGVtcy50aWNrc0xlbmd0aCAtIDEsIDEpO1xuXHRcdFx0dmFyIGJvcmRlclZhbHVlID0gaXRlbXMuYm9yZGVyVmFsdWU7XG5cdFx0XHR2YXIgeDEsIHgyLCB5MSwgeTI7XG5cblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHR4MSA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLmxlZnQsIGZpcnN0TGluZVdpZHRoKSAtIGZpcnN0TGluZVdpZHRoIC8gMjtcblx0XHRcdFx0eDIgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5yaWdodCwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcblx0XHRcdFx0eTEgPSB5MiA9IGJvcmRlclZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eTEgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS50b3AsIGZpcnN0TGluZVdpZHRoKSAtIGZpcnN0TGluZVdpZHRoIC8gMjtcblx0XHRcdFx0eTIgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5ib3R0b20sIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG5cdFx0XHRcdHgxID0geDIgPSBib3JkZXJWYWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IGF4aXNXaWR0aDtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMuY29sb3IsIDApO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4MSwgeTEpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4MiwgeTIpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9kcmF3TGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25UaWNrcyA9IG1lLm9wdGlvbnMudGlja3M7XG5cblx0XHRpZiAoIW9wdGlvblRpY2tzLmRpc3BsYXkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXHRcdHZhciBpdGVtcyA9IG1lLl9sYWJlbEl0ZW1zIHx8IChtZS5fbGFiZWxJdGVtcyA9IG1lLl9jb21wdXRlTGFiZWxJdGVtcygpKTtcblx0XHR2YXIgaSwgaiwgaWxlbiwgamxlbiwgaXRlbSwgdGlja0ZvbnQsIGxhYmVsLCB5O1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0dGlja0ZvbnQgPSBpdGVtLmZvbnQ7XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBkcmF3IHRleHQgaW4gdGhlIGNvcnJlY3QgY29sb3IgYW5kIGZvbnRcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHgudHJhbnNsYXRlKGl0ZW0ueCwgaXRlbS55KTtcblx0XHRcdGN0eC5yb3RhdGUoaXRlbS5yb3RhdGlvbik7XG5cdFx0XHRjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB0aWNrRm9udC5jb2xvcjtcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBpdGVtLnRleHRBbGlnbjtcblxuXHRcdFx0bGFiZWwgPSBpdGVtLmxhYmVsO1xuXHRcdFx0eSA9IGl0ZW0udGV4dE9mZnNldDtcblx0XHRcdGlmIChpc0FycmF5KGxhYmVsKSkge1xuXHRcdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gbGFiZWwubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG5cdFx0XHRcdFx0Ly8gV2UganVzdCBtYWtlIHN1cmUgdGhlIG11bHRpbGluZSBlbGVtZW50IGlzIGEgc3RyaW5nIGhlcmUuLlxuXHRcdFx0XHRcdGN0eC5maWxsVGV4dCgnJyArIGxhYmVsW2pdLCAwLCB5KTtcblx0XHRcdFx0XHR5ICs9IHRpY2tGb250LmxpbmVIZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dChsYWJlbCwgMCwgeSk7XG5cdFx0XHR9XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9kcmF3VGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGN0eCA9IG1lLmN0eDtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHNjYWxlTGFiZWwgPSBvcHRpb25zLnNjYWxlTGFiZWw7XG5cblx0XHRpZiAoIXNjYWxlTGFiZWwuZGlzcGxheSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzY2FsZUxhYmVsRm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkYShzY2FsZUxhYmVsLmZvbnRDb2xvciwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0dmFyIHNjYWxlTGFiZWxGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChzY2FsZUxhYmVsKTtcblx0XHR2YXIgc2NhbGVMYWJlbFBhZGRpbmcgPSBoZWxwZXJzJDEub3B0aW9ucy50b1BhZGRpbmcoc2NhbGVMYWJlbC5wYWRkaW5nKTtcblx0XHR2YXIgaGFsZkxpbmVIZWlnaHQgPSBzY2FsZUxhYmVsRm9udC5saW5lSGVpZ2h0IC8gMjtcblx0XHR2YXIgcG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuXHRcdHZhciByb3RhdGlvbiA9IDA7XG5cdFx0dmFyIHNjYWxlTGFiZWxYLCBzY2FsZUxhYmVsWTtcblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0c2NhbGVMYWJlbFggPSBtZS5sZWZ0ICsgbWUud2lkdGggLyAyOyAvLyBtaWRwb2ludCBvZiB0aGUgd2lkdGhcblx0XHRcdHNjYWxlTGFiZWxZID0gcG9zaXRpb24gPT09ICdib3R0b20nXG5cdFx0XHRcdD8gbWUuYm90dG9tIC0gaGFsZkxpbmVIZWlnaHQgLSBzY2FsZUxhYmVsUGFkZGluZy5ib3R0b21cblx0XHRcdFx0OiBtZS50b3AgKyBoYWxmTGluZUhlaWdodCArIHNjYWxlTGFiZWxQYWRkaW5nLnRvcDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGlzTGVmdCA9IHBvc2l0aW9uID09PSAnbGVmdCc7XG5cdFx0XHRzY2FsZUxhYmVsWCA9IGlzTGVmdFxuXHRcdFx0XHQ/IG1lLmxlZnQgKyBoYWxmTGluZUhlaWdodCArIHNjYWxlTGFiZWxQYWRkaW5nLnRvcFxuXHRcdFx0XHQ6IG1lLnJpZ2h0IC0gaGFsZkxpbmVIZWlnaHQgLSBzY2FsZUxhYmVsUGFkZGluZy50b3A7XG5cdFx0XHRzY2FsZUxhYmVsWSA9IG1lLnRvcCArIG1lLmhlaWdodCAvIDI7XG5cdFx0XHRyb3RhdGlvbiA9IGlzTGVmdCA/IC0wLjUgKiBNYXRoLlBJIDogMC41ICogTWF0aC5QSTtcblx0XHR9XG5cblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC50cmFuc2xhdGUoc2NhbGVMYWJlbFgsIHNjYWxlTGFiZWxZKTtcblx0XHRjdHgucm90YXRlKHJvdGF0aW9uKTtcblx0XHRjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXHRcdGN0eC5maWxsU3R5bGUgPSBzY2FsZUxhYmVsRm9udENvbG9yOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcblx0XHRjdHguZm9udCA9IHNjYWxlTGFiZWxGb250LnN0cmluZztcblx0XHRjdHguZmlsbFRleHQoc2NhbGVMYWJlbC5sYWJlbFN0cmluZywgMCwgMCk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbihjaGFydEFyZWEpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKCFtZS5faXNWaXNpYmxlKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRtZS5fZHJhd0dyaWQoY2hhcnRBcmVhKTtcblx0XHRtZS5fZHJhd1RpdGxlKCk7XG5cdFx0bWUuX2RyYXdMYWJlbHMoKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9sYXllcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0eiA9IG9wdHMudGlja3MgJiYgb3B0cy50aWNrcy56IHx8IDA7XG5cdFx0dmFyIGd6ID0gb3B0cy5ncmlkTGluZXMgJiYgb3B0cy5ncmlkTGluZXMueiB8fCAwO1xuXG5cdFx0aWYgKCFtZS5faXNWaXNpYmxlKCkgfHwgdHogPT09IGd6IHx8IG1lLmRyYXcgIT09IG1lLl9kcmF3KSB7XG5cdFx0XHQvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBkcmF3IGhhcyBiZWVuIG92ZXJyaWRkZW4gYnkgY3VzdG9tIHNjYWxlXG5cdFx0XHRyZXR1cm4gW3tcblx0XHRcdFx0ejogdHosXG5cdFx0XHRcdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdG1lLmRyYXcuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdH1dO1xuXHRcdH1cblxuXHRcdHJldHVybiBbe1xuXHRcdFx0ejogZ3osXG5cdFx0XHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bWUuX2RyYXdHcmlkLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRtZS5fZHJhd1RpdGxlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH0sIHtcblx0XHRcdHo6IHR6LFxuXHRcdFx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG1lLl9kcmF3TGFiZWxzLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH1dO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldE1hdGNoaW5nVmlzaWJsZU1ldGFzOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0cmV0dXJuIG1lLmNoYXJ0Ll9nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKClcblx0XHRcdC5maWx0ZXIoZnVuY3Rpb24obWV0YSkge1xuXHRcdFx0XHRyZXR1cm4gKCF0eXBlIHx8IG1ldGEudHlwZSA9PT0gdHlwZSlcblx0XHRcdFx0XHQmJiAoaXNIb3Jpem9udGFsID8gbWV0YS54QXhpc0lEID09PSBtZS5pZCA6IG1ldGEueUF4aXNJRCA9PT0gbWUuaWQpO1xuXHRcdFx0fSk7XG5cdH1cbn0pO1xuXG5TY2FsZS5wcm90b3R5cGUuX2RyYXcgPSBTY2FsZS5wcm90b3R5cGUuZHJhdztcblxudmFyIGNvcmVfc2NhbGUgPSBTY2FsZTtcblxudmFyIGlzTnVsbE9yVW5kZWYkMSA9IGhlbHBlcnMkMS5pc051bGxPclVuZGVmO1xuXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcblx0cG9zaXRpb246ICdib3R0b20nXG59O1xuXG52YXIgc2NhbGVfY2F0ZWdvcnkgPSBjb3JlX3NjYWxlLmV4dGVuZCh7XG5cdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGxhYmVscyA9IG1lLl9nZXRMYWJlbHMoKTtcblx0XHR2YXIgdGlja3NPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgbWluID0gdGlja3NPcHRzLm1pbjtcblx0XHR2YXIgbWF4ID0gdGlja3NPcHRzLm1heDtcblx0XHR2YXIgbWluSW5kZXggPSAwO1xuXHRcdHZhciBtYXhJbmRleCA9IGxhYmVscy5sZW5ndGggLSAxO1xuXHRcdHZhciBmaW5kSW5kZXg7XG5cblx0XHRpZiAobWluICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIHVzZXIgc3BlY2lmaWVkIG1pbiB2YWx1ZVxuXHRcdFx0ZmluZEluZGV4ID0gbGFiZWxzLmluZGV4T2YobWluKTtcblx0XHRcdGlmIChmaW5kSW5kZXggPj0gMCkge1xuXHRcdFx0XHRtaW5JbmRleCA9IGZpbmRJbmRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobWF4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIHVzZXIgc3BlY2lmaWVkIG1heCB2YWx1ZVxuXHRcdFx0ZmluZEluZGV4ID0gbGFiZWxzLmluZGV4T2YobWF4KTtcblx0XHRcdGlmIChmaW5kSW5kZXggPj0gMCkge1xuXHRcdFx0XHRtYXhJbmRleCA9IGZpbmRJbmRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZS5taW5JbmRleCA9IG1pbkluZGV4O1xuXHRcdG1lLm1heEluZGV4ID0gbWF4SW5kZXg7XG5cdFx0bWUubWluID0gbGFiZWxzW21pbkluZGV4XTtcblx0XHRtZS5tYXggPSBsYWJlbHNbbWF4SW5kZXhdO1xuXHR9LFxuXG5cdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGxhYmVscyA9IG1lLl9nZXRMYWJlbHMoKTtcblx0XHR2YXIgbWluSW5kZXggPSBtZS5taW5JbmRleDtcblx0XHR2YXIgbWF4SW5kZXggPSBtZS5tYXhJbmRleDtcblxuXHRcdC8vIElmIHdlIGFyZSB2aWV3aW5nIHNvbWUgc3Vic2V0IG9mIGxhYmVscywgc2xpY2UgdGhlIG9yaWdpbmFsIGFycmF5XG5cdFx0bWUudGlja3MgPSAobWluSW5kZXggPT09IDAgJiYgbWF4SW5kZXggPT09IGxhYmVscy5sZW5ndGggLSAxKSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtaW5JbmRleCwgbWF4SW5kZXggKyAxKTtcblx0fSxcblxuXHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblxuXHRcdGlmIChjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIuX2dldFZhbHVlU2NhbGVJZCgpID09PSBtZS5pZCkge1xuXHRcdFx0cmV0dXJuIG1lLmdldFJpZ2h0VmFsdWUoY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWUuX2dldExhYmVscygpW2luZGV4XTtcblx0fSxcblxuXHRfY29uZmlndXJlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvZmZzZXQgPSBtZS5vcHRpb25zLm9mZnNldDtcblx0XHR2YXIgdGlja3MgPSBtZS50aWNrcztcblxuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLl9jb25maWd1cmUuY2FsbChtZSk7XG5cblx0XHRpZiAoIW1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHQvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdmVydGljYWwgY2F0ZWdvcnkgc2NhbGUgcmV2ZXJzZSBpcyBpbnZlcnRlZC5cblx0XHRcdG1lLl9yZXZlcnNlUGl4ZWxzID0gIW1lLl9yZXZlcnNlUGl4ZWxzO1xuXHRcdH1cblxuXHRcdGlmICghdGlja3MpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRtZS5fc3RhcnRWYWx1ZSA9IG1lLm1pbkluZGV4IC0gKG9mZnNldCA/IDAuNSA6IDApO1xuXHRcdG1lLl92YWx1ZVJhbmdlID0gTWF0aC5tYXgodGlja3MubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSwgMSk7XG5cdH0sXG5cblx0Ly8gVXNlZCB0byBnZXQgZGF0YSB2YWx1ZSBsb2NhdGlvbnMuICBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG5cdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdmFsdWVDYXRlZ29yeSwgbGFiZWxzLCBpZHg7XG5cblx0XHRpZiAoIWlzTnVsbE9yVW5kZWYkMShpbmRleCkgJiYgIWlzTnVsbE9yVW5kZWYkMShkYXRhc2V0SW5kZXgpKSB7XG5cdFx0XHR2YWx1ZSA9IG1lLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XTtcblx0XHR9XG5cblx0XHQvLyBJZiB2YWx1ZSBpcyBhIGRhdGEgb2JqZWN0LCB0aGVuIGluZGV4IGlzIHRoZSBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSxcblx0XHQvLyBub3QgdGhlIGluZGV4IG9mIHRoZSBzY2FsZS4gV2UgbmVlZCB0byBjaGFuZ2UgdGhhdC5cblx0XHRpZiAoIWlzTnVsbE9yVW5kZWYkMSh2YWx1ZSkpIHtcblx0XHRcdHZhbHVlQ2F0ZWdvcnkgPSBtZS5pc0hvcml6b250YWwoKSA/IHZhbHVlLnggOiB2YWx1ZS55O1xuXHRcdH1cblx0XHRpZiAodmFsdWVDYXRlZ29yeSAhPT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGlzTmFOKGluZGV4KSkpIHtcblx0XHRcdGxhYmVscyA9IG1lLl9nZXRMYWJlbHMoKTtcblx0XHRcdHZhbHVlID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0KHZhbHVlQ2F0ZWdvcnksIHZhbHVlKTtcblx0XHRcdGlkeCA9IGxhYmVscy5pbmRleE9mKHZhbHVlKTtcblx0XHRcdGluZGV4ID0gaWR4ICE9PSAtMSA/IGlkeCA6IGluZGV4O1xuXHRcdFx0aWYgKGlzTmFOKGluZGV4KSkge1xuXHRcdFx0XHRpbmRleCA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWUuZ2V0UGl4ZWxGb3JEZWNpbWFsKChpbmRleCAtIG1lLl9zdGFydFZhbHVlKSAvIG1lLl92YWx1ZVJhbmdlKTtcblx0fSxcblxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIHRpY2tzID0gdGhpcy50aWNrcztcblx0XHRyZXR1cm4gaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMVxuXHRcdFx0PyBudWxsXG5cdFx0XHQ6IHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0sIGluZGV4ICsgdGhpcy5taW5JbmRleCk7XG5cdH0sXG5cblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB2YWx1ZSA9IE1hdGgucm91bmQobWUuX3N0YXJ0VmFsdWUgKyBtZS5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogbWUuX3ZhbHVlUmFuZ2UpO1xuXHRcdHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgMCksIG1lLnRpY2tzLmxlbmd0aCAtIDEpO1xuXHR9LFxuXG5cdGdldEJhc2VQaXhlbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYm90dG9tO1xuXHR9XG59KTtcblxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXG52YXIgX2RlZmF1bHRzID0gZGVmYXVsdENvbmZpZztcbnNjYWxlX2NhdGVnb3J5Ll9kZWZhdWx0cyA9IF9kZWZhdWx0cztcblxudmFyIG5vb3AgPSBoZWxwZXJzJDEubm9vcDtcbnZhciBpc051bGxPclVuZGVmJDIgPSBoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZjtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsaW5lYXIgdGlja3NcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gYXJyYXkgb2YgdGljayB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG5cdHZhciB0aWNrcyA9IFtdO1xuXHQvLyBUbyBnZXQgYSBcIm5pY2VcIiB2YWx1ZSBmb3IgdGhlIHRpY2sgc3BhY2luZywgd2Ugd2lsbCB1c2UgdGhlIGFwcHJvcHJpYXRlbHkgbmFtZWRcblx0Ly8gXCJuaWNlIG51bWJlclwiIGFsZ29yaXRobS4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg1MDY4ODEvbmljZS1sYWJlbC1hbGdvcml0aG0tZm9yLWNoYXJ0cy13aXRoLW1pbmltdW0tdGlja3Ncblx0Ly8gZm9yIGRldGFpbHMuXG5cblx0dmFyIE1JTl9TUEFDSU5HID0gMWUtMTQ7XG5cdHZhciBzdGVwU2l6ZSA9IGdlbmVyYXRpb25PcHRpb25zLnN0ZXBTaXplO1xuXHR2YXIgdW5pdCA9IHN0ZXBTaXplIHx8IDE7XG5cdHZhciBtYXhOdW1TcGFjZXMgPSBnZW5lcmF0aW9uT3B0aW9ucy5tYXhUaWNrcyAtIDE7XG5cdHZhciBtaW4gPSBnZW5lcmF0aW9uT3B0aW9ucy5taW47XG5cdHZhciBtYXggPSBnZW5lcmF0aW9uT3B0aW9ucy5tYXg7XG5cdHZhciBwcmVjaXNpb24gPSBnZW5lcmF0aW9uT3B0aW9ucy5wcmVjaXNpb247XG5cdHZhciBybWluID0gZGF0YVJhbmdlLm1pbjtcblx0dmFyIHJtYXggPSBkYXRhUmFuZ2UubWF4O1xuXHR2YXIgc3BhY2luZyA9IGhlbHBlcnMkMS5uaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhOdW1TcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG5cdHZhciBmYWN0b3IsIG5pY2VNaW4sIG5pY2VNYXgsIG51bVNwYWNlcztcblxuXHQvLyBCZXlvbmQgTUlOX1NQQUNJTkcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyBiZWluZyB0byBsb3NlIHByZWNpc2lvblxuXHQvLyBzdWNoIHRoYXQgd2UgY2FuJ3QgZG8gdGhlIG1hdGggbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIHRpY2tzXG5cdGlmIChzcGFjaW5nIDwgTUlOX1NQQUNJTkcgJiYgaXNOdWxsT3JVbmRlZiQyKG1pbikgJiYgaXNOdWxsT3JVbmRlZiQyKG1heCkpIHtcblx0XHRyZXR1cm4gW3JtaW4sIHJtYXhdO1xuXHR9XG5cblx0bnVtU3BhY2VzID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAtIE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpO1xuXHRpZiAobnVtU3BhY2VzID4gbWF4TnVtU3BhY2VzKSB7XG5cdFx0Ly8gSWYgdGhlIGNhbGN1bGF0ZWQgbnVtIG9mIHNwYWNlcyBleGNlZWRzIG1heE51bVNwYWNlcywgcmVjYWxjdWxhdGUgaXRcblx0XHRzcGFjaW5nID0gaGVscGVycyQxLm5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heE51bVNwYWNlcyAvIHVuaXQpICogdW5pdDtcblx0fVxuXG5cdGlmIChzdGVwU2l6ZSB8fCBpc051bGxPclVuZGVmJDIocHJlY2lzaW9uKSkge1xuXHRcdC8vIElmIGEgcHJlY2lzaW9uIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSBmYWN0b3IgYmFzZWQgb24gc3BhY2luZ1xuXHRcdGZhY3RvciA9IE1hdGgucG93KDEwLCBoZWxwZXJzJDEuX2RlY2ltYWxQbGFjZXMoc3BhY2luZykpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHRoZSB1c2VyIHNwZWNpZmllZCBhIHByZWNpc2lvbiwgcm91bmQgdG8gdGhhdCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcblx0XHRmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcblx0XHRzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcgKiBmYWN0b3IpIC8gZmFjdG9yO1xuXHR9XG5cblx0bmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcblx0bmljZU1heCA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgKiBzcGFjaW5nO1xuXG5cdC8vIElmIG1pbiwgbWF4IGFuZCBzdGVwU2l6ZSBpcyBzZXQgYW5kIHRoZXkgbWFrZSBhbiBldmVubHkgc3BhY2VkIHNjYWxlIHVzZSBpdC5cblx0aWYgKHN0ZXBTaXplKSB7XG5cdFx0Ly8gSWYgdmVyeSBjbG9zZSB0byBvdXIgd2hvbGUgbnVtYmVyLCB1c2UgaXQuXG5cdFx0aWYgKCFpc051bGxPclVuZGVmJDIobWluKSAmJiBoZWxwZXJzJDEuYWxtb3N0V2hvbGUobWluIC8gc3BhY2luZywgc3BhY2luZyAvIDEwMDApKSB7XG5cdFx0XHRuaWNlTWluID0gbWluO1xuXHRcdH1cblx0XHRpZiAoIWlzTnVsbE9yVW5kZWYkMihtYXgpICYmIGhlbHBlcnMkMS5hbG1vc3RXaG9sZShtYXggLyBzcGFjaW5nLCBzcGFjaW5nIC8gMTAwMCkpIHtcblx0XHRcdG5pY2VNYXggPSBtYXg7XG5cdFx0fVxuXHR9XG5cblx0bnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XG5cdC8vIElmIHZlcnkgY2xvc2UgdG8gb3VyIHJvdW5kZWQgdmFsdWUsIHVzZSBpdC5cblx0aWYgKGhlbHBlcnMkMS5hbG1vc3RFcXVhbHMobnVtU3BhY2VzLCBNYXRoLnJvdW5kKG51bVNwYWNlcyksIHNwYWNpbmcgLyAxMDAwKSkge1xuXHRcdG51bVNwYWNlcyA9IE1hdGgucm91bmQobnVtU3BhY2VzKTtcblx0fSBlbHNlIHtcblx0XHRudW1TcGFjZXMgPSBNYXRoLmNlaWwobnVtU3BhY2VzKTtcblx0fVxuXG5cdG5pY2VNaW4gPSBNYXRoLnJvdW5kKG5pY2VNaW4gKiBmYWN0b3IpIC8gZmFjdG9yO1xuXHRuaWNlTWF4ID0gTWF0aC5yb3VuZChuaWNlTWF4ICogZmFjdG9yKSAvIGZhY3Rvcjtcblx0dGlja3MucHVzaChpc051bGxPclVuZGVmJDIobWluKSA/IG5pY2VNaW4gOiBtaW4pO1xuXHRmb3IgKHZhciBqID0gMTsgaiA8IG51bVNwYWNlczsgKytqKSB7XG5cdFx0dGlja3MucHVzaChNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3Rvcik7XG5cdH1cblx0dGlja3MucHVzaChpc051bGxPclVuZGVmJDIobWF4KSA/IG5pY2VNYXggOiBtYXgpO1xuXG5cdHJldHVybiB0aWNrcztcbn1cblxudmFyIHNjYWxlX2xpbmVhcmJhc2UgPSBjb3JlX3NjYWxlLmV4dGVuZCh7XG5cdGdldFJpZ2h0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiArdmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiBjb3JlX3NjYWxlLnByb3RvdHlwZS5nZXRSaWdodFZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuXHR9LFxuXG5cdGhhbmRsZVRpY2tSYW5nZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0XHQvLyBJZiB3ZSBhcmUgZm9yY2luZyBpdCB0byBiZWdpbiBhdCAwLCBidXQgMCB3aWxsIGFscmVhZHkgYmUgcmVuZGVyZWQgb24gdGhlIGNoYXJ0LFxuXHRcdC8vIGRvIG5vdGhpbmcgc2luY2UgdGhhdCB3b3VsZCBtYWtlIHRoZSBjaGFydCB3ZWlyZC4gSWYgdGhlIHVzZXIgcmVhbGx5IHdhbnRzIGEgd2VpcmQgY2hhcnRcblx0XHQvLyBheGlzLCB0aGV5IGNhbiBtYW51YWxseSBvdmVycmlkZSBpdFxuXHRcdGlmICh0aWNrT3B0cy5iZWdpbkF0WmVybykge1xuXHRcdFx0dmFyIG1pblNpZ24gPSBoZWxwZXJzJDEuc2lnbihtZS5taW4pO1xuXHRcdFx0dmFyIG1heFNpZ24gPSBoZWxwZXJzJDEuc2lnbihtZS5tYXgpO1xuXG5cdFx0XHRpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcblx0XHRcdFx0Ly8gbW92ZSB0aGUgdG9wIHVwIHRvIDBcblx0XHRcdFx0bWUubWF4ID0gMDtcblx0XHRcdH0gZWxzZSBpZiAobWluU2lnbiA+IDAgJiYgbWF4U2lnbiA+IDApIHtcblx0XHRcdFx0Ly8gbW92ZSB0aGUgYm90dG9tIGRvd24gdG8gMFxuXHRcdFx0XHRtZS5taW4gPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBzZXRNaW4gPSB0aWNrT3B0cy5taW4gIT09IHVuZGVmaW5lZCB8fCB0aWNrT3B0cy5zdWdnZXN0ZWRNaW4gIT09IHVuZGVmaW5lZDtcblx0XHR2YXIgc2V0TWF4ID0gdGlja09wdHMubWF4ICE9PSB1bmRlZmluZWQgfHwgdGlja09wdHMuc3VnZ2VzdGVkTWF4ICE9PSB1bmRlZmluZWQ7XG5cblx0XHRpZiAodGlja09wdHMubWluICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdG1lLm1pbiA9IHRpY2tPcHRzLm1pbjtcblx0XHR9IGVsc2UgaWYgKHRpY2tPcHRzLnN1Z2dlc3RlZE1pbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZiAobWUubWluID09PSBudWxsKSB7XG5cdFx0XHRcdG1lLm1pbiA9IHRpY2tPcHRzLnN1Z2dlc3RlZE1pbjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLm1pbiA9IE1hdGgubWluKG1lLm1pbiwgdGlja09wdHMuc3VnZ2VzdGVkTWluKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGlja09wdHMubWF4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdG1lLm1heCA9IHRpY2tPcHRzLm1heDtcblx0XHR9IGVsc2UgaWYgKHRpY2tPcHRzLnN1Z2dlc3RlZE1heCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XG5cdFx0XHRcdG1lLm1heCA9IHRpY2tPcHRzLnN1Z2dlc3RlZE1heDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLm1heCA9IE1hdGgubWF4KG1lLm1heCwgdGlja09wdHMuc3VnZ2VzdGVkTWF4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoc2V0TWluICE9PSBzZXRNYXgpIHtcblx0XHRcdC8vIFdlIHNldCB0aGUgbWluIG9yIHRoZSBtYXggYnV0IG5vdCBib3RoLlxuXHRcdFx0Ly8gU28gZW5zdXJlIHRoYXQgb3VyIHJhbmdlIGlzIGdvb2Rcblx0XHRcdC8vIEludmVydGVkIG9yIDAgbGVuZ3RoIHJhbmdlIGNhbiBoYXBwZW4gd2hlblxuXHRcdFx0Ly8gdGlja3MubWluIGlzIHNldCwgYW5kIG5vIGRhdGFzZXRzIGFyZSB2aXNpYmxlXG5cdFx0XHRpZiAobWUubWluID49IG1lLm1heCkge1xuXHRcdFx0XHRpZiAoc2V0TWluKSB7XG5cdFx0XHRcdFx0bWUubWF4ID0gbWUubWluICsgMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtZS5taW4gPSBtZS5tYXggLSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG1lLm1pbiA9PT0gbWUubWF4KSB7XG5cdFx0XHRtZS5tYXgrKztcblxuXHRcdFx0aWYgKCF0aWNrT3B0cy5iZWdpbkF0WmVybykge1xuXHRcdFx0XHRtZS5taW4tLTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Z2V0VGlja0xpbWl0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIHN0ZXBTaXplID0gdGlja09wdHMuc3RlcFNpemU7XG5cdFx0dmFyIG1heFRpY2tzTGltaXQgPSB0aWNrT3B0cy5tYXhUaWNrc0xpbWl0O1xuXHRcdHZhciBtYXhUaWNrcztcblxuXHRcdGlmIChzdGVwU2l6ZSkge1xuXHRcdFx0bWF4VGlja3MgPSBNYXRoLmNlaWwobWUubWF4IC8gc3RlcFNpemUpIC0gTWF0aC5mbG9vcihtZS5taW4gLyBzdGVwU2l6ZSkgKyAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXhUaWNrcyA9IG1lLl9jb21wdXRlVGlja0xpbWl0KCk7XG5cdFx0XHRtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcblx0XHR9XG5cblx0XHRpZiAobWF4VGlja3NMaW1pdCkge1xuXHRcdFx0bWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1heFRpY2tzO1xuXHR9LFxuXG5cdF9jb21wdXRlVGlja0xpbWl0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHR9LFxuXG5cdGhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlczogbm9vcCxcblxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG5cdFx0Ly8gRmlndXJlIG91dCB3aGF0IHRoZSBtYXggbnVtYmVyIG9mIHRpY2tzIHdlIGNhbiBzdXBwb3J0IGl0IGlzIGJhc2VkIG9uIHRoZSBzaXplIG9mXG5cdFx0Ly8gdGhlIGF4aXMgYXJlYS4gRm9yIG5vdywgd2Ugc2F5IHRoYXQgdGhlIG1pbmltdW0gdGljayBzcGFjaW5nIGluIHBpeGVscyBtdXN0IGJlIDQwXG5cdFx0Ly8gV2UgYWxzbyBsaW1pdCB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgdG8gMTEgd2hpY2ggZ2l2ZXMgYSBuaWNlIDEwIHNxdWFyZXMgb25cblx0XHQvLyB0aGUgZ3JhcGguIE1ha2Ugc3VyZSB3ZSBhbHdheXMgaGF2ZSBhdCBsZWFzdCAyIHRpY2tzXG5cdFx0dmFyIG1heFRpY2tzID0gbWUuZ2V0VGlja0xpbWl0KCk7XG5cdFx0bWF4VGlja3MgPSBNYXRoLm1heCgyLCBtYXhUaWNrcyk7XG5cblx0XHR2YXIgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG5cdFx0XHRtYXhUaWNrczogbWF4VGlja3MsXG5cdFx0XHRtaW46IHRpY2tPcHRzLm1pbixcblx0XHRcdG1heDogdGlja09wdHMubWF4LFxuXHRcdFx0cHJlY2lzaW9uOiB0aWNrT3B0cy5wcmVjaXNpb24sXG5cdFx0XHRzdGVwU2l6ZTogaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZpeGVkU3RlcFNpemUsIHRpY2tPcHRzLnN0ZXBTaXplKVxuXHRcdH07XG5cdFx0dmFyIHRpY2tzID0gbWUudGlja3MgPSBnZW5lcmF0ZVRpY2tzKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBtZSk7XG5cblx0XHRtZS5oYW5kbGVEaXJlY3Rpb25hbENoYW5nZXMoKTtcblxuXHRcdC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBtYXggYW5kIG1pbiBnaXZlbiB0aGUgdGljayB2YWx1ZXMgc2luY2Ugd2UgaGF2ZSBleHBhbmRlZCB0aGVcblx0XHQvLyByYW5nZSBvZiB0aGUgc2NhbGVcblx0XHRtZS5tYXggPSBoZWxwZXJzJDEubWF4KHRpY2tzKTtcblx0XHRtZS5taW4gPSBoZWxwZXJzJDEubWluKHRpY2tzKTtcblxuXHRcdGlmICh0aWNrT3B0cy5yZXZlcnNlKSB7XG5cdFx0XHR0aWNrcy5yZXZlcnNlKCk7XG5cblx0XHRcdG1lLnN0YXJ0ID0gbWUubWF4O1xuXHRcdFx0bWUuZW5kID0gbWUubWluO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5zdGFydCA9IG1lLm1pbjtcblx0XHRcdG1lLmVuZCA9IG1lLm1heDtcblx0XHR9XG5cdH0sXG5cblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0bWUudGlja3NBc051bWJlcnMgPSBtZS50aWNrcy5zbGljZSgpO1xuXHRcdG1lLnplcm9MaW5lSW5kZXggPSBtZS50aWNrcy5pbmRleE9mKDApO1xuXG5cdFx0Y29yZV9zY2FsZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbChtZSk7XG5cdH0sXG5cblx0X2NvbmZpZ3VyZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja3MgPSBtZS5nZXRUaWNrcygpO1xuXHRcdHZhciBzdGFydCA9IG1lLm1pbjtcblx0XHR2YXIgZW5kID0gbWUubWF4O1xuXHRcdHZhciBvZmZzZXQ7XG5cblx0XHRjb3JlX3NjYWxlLnByb3RvdHlwZS5fY29uZmlndXJlLmNhbGwobWUpO1xuXG5cdFx0aWYgKG1lLm9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xuXHRcdFx0b2Zmc2V0ID0gKGVuZCAtIHN0YXJ0KSAvIE1hdGgubWF4KHRpY2tzLmxlbmd0aCAtIDEsIDEpIC8gMjtcblx0XHRcdHN0YXJ0IC09IG9mZnNldDtcblx0XHRcdGVuZCArPSBvZmZzZXQ7XG5cdFx0fVxuXHRcdG1lLl9zdGFydFZhbHVlID0gc3RhcnQ7XG5cdFx0bWUuX2VuZFZhbHVlID0gZW5kO1xuXHRcdG1lLl92YWx1ZVJhbmdlID0gZW5kIC0gc3RhcnQ7XG5cdH1cbn0pO1xuXG52YXIgZGVmYXVsdENvbmZpZyQxID0ge1xuXHRwb3NpdGlvbjogJ2xlZnQnLFxuXHR0aWNrczoge1xuXHRcdGNhbGxiYWNrOiBjb3JlX3RpY2tzLmZvcm1hdHRlcnMubGluZWFyXG5cdH1cbn07XG5cbnZhciBERUZBVUxUX01JTiA9IDA7XG52YXIgREVGQVVMVF9NQVggPSAxO1xuXG5mdW5jdGlvbiBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywgc3RhY2tlZCwgbWV0YSkge1xuXHR2YXIga2V5ID0gW1xuXHRcdG1ldGEudHlwZSxcblx0XHQvLyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3RhY2sgZm9yIHN0YWNrPXVuZGVmaW5lZCBkYXRhc2V0cyB3aGVuIHRoZSBvcHRzLnN0YWNrZWQgaXMgdW5kZWZpbmVkXG5cdFx0c3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCA/IG1ldGEuaW5kZXggOiAnJyxcblx0XHRtZXRhLnN0YWNrXG5cdF0uam9pbignLicpO1xuXG5cdGlmIChzdGFja3Nba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0c3RhY2tzW2tleV0gPSB7XG5cdFx0XHRwb3M6IFtdLFxuXHRcdFx0bmVnOiBbXVxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gc3RhY2tzW2tleV07XG59XG5cbmZ1bmN0aW9uIHN0YWNrRGF0YShzY2FsZSwgc3RhY2tzLCBtZXRhLCBkYXRhKSB7XG5cdHZhciBvcHRzID0gc2NhbGUub3B0aW9ucztcblx0dmFyIHN0YWNrZWQgPSBvcHRzLnN0YWNrZWQ7XG5cdHZhciBzdGFjayA9IGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja2VkLCBtZXRhKTtcblx0dmFyIHBvcyA9IHN0YWNrLnBvcztcblx0dmFyIG5lZyA9IHN0YWNrLm5lZztcblx0dmFyIGlsZW4gPSBkYXRhLmxlbmd0aDtcblx0dmFyIGksIHZhbHVlO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcblx0XHR2YWx1ZSA9IHNjYWxlLl9wYXJzZVZhbHVlKGRhdGFbaV0pO1xuXHRcdGlmIChpc05hTih2YWx1ZS5taW4pIHx8IGlzTmFOKHZhbHVlLm1heCkgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbikge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0cG9zW2ldID0gcG9zW2ldIHx8IDA7XG5cdFx0bmVnW2ldID0gbmVnW2ldIHx8IDA7XG5cblx0XHRpZiAob3B0cy5yZWxhdGl2ZVBvaW50cykge1xuXHRcdFx0cG9zW2ldID0gMTAwO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUubWluIDwgMCB8fCB2YWx1ZS5tYXggPCAwKSB7XG5cdFx0XHRuZWdbaV0gKz0gdmFsdWUubWluO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb3NbaV0gKz0gdmFsdWUubWF4O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVNaW5NYXgoc2NhbGUsIG1ldGEsIGRhdGEpIHtcblx0dmFyIGlsZW4gPSBkYXRhLmxlbmd0aDtcblx0dmFyIGksIHZhbHVlO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcblx0XHR2YWx1ZSA9IHNjYWxlLl9wYXJzZVZhbHVlKGRhdGFbaV0pO1xuXHRcdGlmIChpc05hTih2YWx1ZS5taW4pIHx8IGlzTmFOKHZhbHVlLm1heCkgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbikge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0c2NhbGUubWluID0gTWF0aC5taW4oc2NhbGUubWluLCB2YWx1ZS5taW4pO1xuXHRcdHNjYWxlLm1heCA9IE1hdGgubWF4KHNjYWxlLm1heCwgdmFsdWUubWF4KTtcblx0fVxufVxuXG52YXIgc2NhbGVfbGluZWFyID0gc2NhbGVfbGluZWFyYmFzZS5leHRlbmQoe1xuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBtZXRhc2V0cyA9IG1lLl9nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuXHRcdHZhciBoYXNTdGFja3MgPSBvcHRzLnN0YWNrZWQ7XG5cdFx0dmFyIHN0YWNrcyA9IHt9O1xuXHRcdHZhciBpbGVuID0gbWV0YXNldHMubGVuZ3RoO1xuXHRcdHZhciBpLCBtZXRhLCBkYXRhLCB2YWx1ZXM7XG5cblx0XHRtZS5taW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdFx0bWUubWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG5cdFx0aWYgKGhhc1N0YWNrcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyAhaGFzU3RhY2tzICYmIGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWV0YSA9IG1ldGFzZXRzW2ldO1xuXHRcdFx0XHRoYXNTdGFja3MgPSBtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWV0YSA9IG1ldGFzZXRzW2ldO1xuXHRcdFx0ZGF0YSA9IGRhdGFzZXRzW21ldGEuaW5kZXhdLmRhdGE7XG5cdFx0XHRpZiAoaGFzU3RhY2tzKSB7XG5cdFx0XHRcdHN0YWNrRGF0YShtZSwgc3RhY2tzLCBtZXRhLCBkYXRhKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHVwZGF0ZU1pbk1heChtZSwgbWV0YSwgZGF0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGVscGVycyQxLmVhY2goc3RhY2tzLCBmdW5jdGlvbihzdGFja1ZhbHVlcykge1xuXHRcdFx0dmFsdWVzID0gc3RhY2tWYWx1ZXMucG9zLmNvbmNhdChzdGFja1ZhbHVlcy5uZWcpO1xuXHRcdFx0bWUubWluID0gTWF0aC5taW4obWUubWluLCBoZWxwZXJzJDEubWluKHZhbHVlcykpO1xuXHRcdFx0bWUubWF4ID0gTWF0aC5tYXgobWUubWF4LCBoZWxwZXJzJDEubWF4KHZhbHVlcykpO1xuXHRcdH0pO1xuXG5cdFx0bWUubWluID0gaGVscGVycyQxLmlzRmluaXRlKG1lLm1pbikgJiYgIWlzTmFOKG1lLm1pbikgPyBtZS5taW4gOiBERUZBVUxUX01JTjtcblx0XHRtZS5tYXggPSBoZWxwZXJzJDEuaXNGaW5pdGUobWUubWF4KSAmJiAhaXNOYU4obWUubWF4KSA/IG1lLm1heCA6IERFRkFVTFRfTUFYO1xuXG5cdFx0Ly8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIHRpY2tzLm1pbiwgdGlja3MubWF4LCB0aWNrcy5iZWdpbkF0WmVyb1xuXHRcdG1lLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcblx0fSxcblxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXG5cdF9jb21wdXRlVGlja0xpbWl0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrRm9udDtcblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0cmV0dXJuIE1hdGguY2VpbChtZS53aWR0aCAvIDQwKTtcblx0XHR9XG5cdFx0dGlja0ZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KG1lLm9wdGlvbnMudGlja3MpO1xuXHRcdHJldHVybiBNYXRoLmNlaWwobWUuaGVpZ2h0IC8gdGlja0ZvbnQubGluZUhlaWdodCk7XG5cdH0sXG5cblx0Ly8gQ2FsbGVkIGFmdGVyIHRoZSB0aWNrcyBhcmUgYnVpbHQuIFdlIG5lZWRcblx0aGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdC8vIFdlIGFyZSBpbiBhIHZlcnRpY2FsIG9yaWVudGF0aW9uLiBUaGUgdG9wIHZhbHVlIGlzIHRoZSBoaWdoZXN0LiBTbyByZXZlcnNlIHRoZSBhcnJheVxuXHRcdFx0dGhpcy50aWNrcy5yZXZlcnNlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldExhYmVsRm9ySW5kZXg6IGZ1bmN0aW9uKGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0U2NhbGVMYWJlbCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XG5cdH0sXG5cblx0Ly8gVXRpbHNcblx0Z2V0UGl4ZWxGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHJldHVybiBtZS5nZXRQaXhlbEZvckRlY2ltYWwoKCttZS5nZXRSaWdodFZhbHVlKHZhbHVlKSAtIG1lLl9zdGFydFZhbHVlKSAvIG1lLl92YWx1ZVJhbmdlKTtcblx0fSxcblxuXHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xuXHRcdHJldHVybiB0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZTtcblx0fSxcblxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIHRpY2tzID0gdGhpcy50aWNrc0FzTnVtYmVycztcblx0XHRpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdKTtcblx0fVxufSk7XG5cbi8vIElOVEVSTkFMOiBzdGF0aWMgZGVmYXVsdCBvcHRpb25zLCByZWdpc3RlcmVkIGluIHNyYy9pbmRleC5qc1xudmFyIF9kZWZhdWx0cyQxID0gZGVmYXVsdENvbmZpZyQxO1xuc2NhbGVfbGluZWFyLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQxO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkYiA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcbnZhciBsb2cxMCA9IGhlbHBlcnMkMS5tYXRoLmxvZzEwO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc2V0IG9mIGxvZ2FyaXRobWljIHRpY2tzXG4gKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGlja3NcbiAqIEBwYXJhbSBkYXRhUmFuZ2UgdGhlIHJhbmdlIG9mIHRoZSBkYXRhXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IGFycmF5IG9mIHRpY2sgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG5cdHZhciB0aWNrcyA9IFtdO1xuXG5cdHZhciB0aWNrVmFsID0gdmFsdWVPckRlZmF1bHQkYihnZW5lcmF0aW9uT3B0aW9ucy5taW4sIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5taW4pKSkpO1xuXG5cdHZhciBlbmRFeHAgPSBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5tYXgpKTtcblx0dmFyIGVuZFNpZ25pZmljYW5kID0gTWF0aC5jZWlsKGRhdGFSYW5nZS5tYXggLyBNYXRoLnBvdygxMCwgZW5kRXhwKSk7XG5cdHZhciBleHAsIHNpZ25pZmljYW5kO1xuXG5cdGlmICh0aWNrVmFsID09PSAwKSB7XG5cdFx0ZXhwID0gTWF0aC5mbG9vcihsb2cxMChkYXRhUmFuZ2UubWluTm90WmVybykpO1xuXHRcdHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcihkYXRhUmFuZ2UubWluTm90WmVybyAvIE1hdGgucG93KDEwLCBleHApKTtcblxuXHRcdHRpY2tzLnB1c2godGlja1ZhbCk7XG5cdFx0dGlja1ZhbCA9IHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCk7XG5cdH0gZWxzZSB7XG5cdFx0ZXhwID0gTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsKSk7XG5cdFx0c2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKHRpY2tWYWwgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG5cdH1cblx0dmFyIHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xuXG5cdGRvIHtcblx0XHR0aWNrcy5wdXNoKHRpY2tWYWwpO1xuXG5cdFx0KytzaWduaWZpY2FuZDtcblx0XHRpZiAoc2lnbmlmaWNhbmQgPT09IDEwKSB7XG5cdFx0XHRzaWduaWZpY2FuZCA9IDE7XG5cdFx0XHQrK2V4cDtcblx0XHRcdHByZWNpc2lvbiA9IGV4cCA+PSAwID8gMSA6IHByZWNpc2lvbjtcblx0XHR9XG5cblx0XHR0aWNrVmFsID0gTWF0aC5yb3VuZChzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcblx0fSB3aGlsZSAoZXhwIDwgZW5kRXhwIHx8IChleHAgPT09IGVuZEV4cCAmJiBzaWduaWZpY2FuZCA8IGVuZFNpZ25pZmljYW5kKSk7XG5cblx0dmFyIGxhc3RUaWNrID0gdmFsdWVPckRlZmF1bHQkYihnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIHRpY2tWYWwpO1xuXHR0aWNrcy5wdXNoKGxhc3RUaWNrKTtcblxuXHRyZXR1cm4gdGlja3M7XG59XG5cbnZhciBkZWZhdWx0Q29uZmlnJDIgPSB7XG5cdHBvc2l0aW9uOiAnbGVmdCcsXG5cblx0Ly8gbGFiZWwgc2V0dGluZ3Ncblx0dGlja3M6IHtcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljXG5cdH1cbn07XG5cbi8vIFRPRE8odjMpOiBjaGFuZ2UgdGhpcyB0byBwb3NpdGl2ZU9yRGVmYXVsdFxuZnVuY3Rpb24gbm9uTmVnYXRpdmVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXHRyZXR1cm4gaGVscGVycyQxLmlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+PSAwID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbnZhciBzY2FsZV9sb2dhcml0aG1pYyA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0ZnVuY3Rpb24gSURNYXRjaGVzKG1ldGEpIHtcblx0XHRcdHJldHVybiBpc0hvcml6b250YWwgPyBtZXRhLnhBeGlzSUQgPT09IG1lLmlkIDogbWV0YS55QXhpc0lEID09PSBtZS5pZDtcblx0XHR9XG5cdFx0dmFyIGRhdGFzZXRJbmRleCwgbWV0YSwgdmFsdWUsIGRhdGEsIGksIGlsZW47XG5cblx0XHQvLyBDYWxjdWxhdGUgUmFuZ2Vcblx0XHRtZS5taW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdFx0bWUubWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXHRcdG1lLm1pbk5vdFplcm8gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cblx0XHR2YXIgaGFzU3RhY2tzID0gb3B0cy5zdGFja2VkO1xuXHRcdGlmIChoYXNTdGFja3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Zm9yIChkYXRhc2V0SW5kZXggPSAwOyBkYXRhc2V0SW5kZXggPCBkYXRhc2V0cy5sZW5ndGg7IGRhdGFzZXRJbmRleCsrKSB7XG5cdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSAmJlxuXHRcdFx0XHRcdG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGhhc1N0YWNrcyA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAob3B0cy5zdGFja2VkIHx8IGhhc1N0YWNrcykge1xuXHRcdFx0dmFyIHZhbHVlc1BlclN0YWNrID0ge307XG5cblx0XHRcdGZvciAoZGF0YXNldEluZGV4ID0gMDsgZGF0YXNldEluZGV4IDwgZGF0YXNldHMubGVuZ3RoOyBkYXRhc2V0SW5kZXgrKykge1xuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0dmFyIGtleSA9IFtcblx0XHRcdFx0XHRtZXRhLnR5cGUsXG5cdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhIHNlcGFyYXRlIHN0YWNrIGZvciBzdGFjaz11bmRlZmluZWQgZGF0YXNldHMgd2hlbiB0aGUgb3B0cy5zdGFja2VkIGlzIHVuZGVmaW5lZFxuXHRcdFx0XHRcdCgob3B0cy5zdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayA9PT0gdW5kZWZpbmVkKSA/IGRhdGFzZXRJbmRleCA6ICcnKSxcblx0XHRcdFx0XHRtZXRhLnN0YWNrXG5cdFx0XHRcdF0uam9pbignLicpO1xuXG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlc1BlclN0YWNrW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dmFsdWVzUGVyU3RhY2tba2V5XSA9IFtdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRhdGEgPSBkYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGE7XG5cdFx0XHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XTtcblx0XHRcdFx0XHRcdHZhbHVlID0gbWUuX3BhcnNlVmFsdWUoZGF0YVtpXSk7XG5cdFx0XHRcdFx0XHQvLyBpbnZhbGlkLCBoaWRkZW4gYW5kIG5lZ2F0aXZlIHZhbHVlcyBhcmUgaWdub3JlZFxuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlLm1pbikgfHwgaXNOYU4odmFsdWUubWF4KSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuIHx8IHZhbHVlLm1pbiA8IDAgfHwgdmFsdWUubWF4IDwgMCkge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhbHVlc1tpXSA9IHZhbHVlc1tpXSB8fCAwO1xuXHRcdFx0XHRcdFx0dmFsdWVzW2ldICs9IHZhbHVlLm1heDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aGVscGVycyQxLmVhY2godmFsdWVzUGVyU3RhY2ssIGZ1bmN0aW9uKHZhbHVlc0ZvclR5cGUpIHtcblx0XHRcdFx0aWYgKHZhbHVlc0ZvclR5cGUubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHZhciBtaW5WYWwgPSBoZWxwZXJzJDEubWluKHZhbHVlc0ZvclR5cGUpO1xuXHRcdFx0XHRcdHZhciBtYXhWYWwgPSBoZWxwZXJzJDEubWF4KHZhbHVlc0ZvclR5cGUpO1xuXHRcdFx0XHRcdG1lLm1pbiA9IE1hdGgubWluKG1lLm1pbiwgbWluVmFsKTtcblx0XHRcdFx0XHRtZS5tYXggPSBNYXRoLm1heChtZS5tYXgsIG1heFZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoZGF0YXNldEluZGV4ID0gMDsgZGF0YXNldEluZGV4IDwgZGF0YXNldHMubGVuZ3RoOyBkYXRhc2V0SW5kZXgrKykge1xuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkpIHtcblx0XHRcdFx0XHRkYXRhID0gZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhO1xuXHRcdFx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBtZS5fcGFyc2VWYWx1ZShkYXRhW2ldKTtcblx0XHRcdFx0XHRcdC8vIGludmFsaWQsIGhpZGRlbiBhbmQgbmVnYXRpdmUgdmFsdWVzIGFyZSBpZ25vcmVkXG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUubWluKSB8fCBpc05hTih2YWx1ZS5tYXgpIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4gfHwgdmFsdWUubWluIDwgMCB8fCB2YWx1ZS5tYXggPCAwKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRtZS5taW4gPSBNYXRoLm1pbih2YWx1ZS5taW4sIG1lLm1pbik7XG5cdFx0XHRcdFx0XHRtZS5tYXggPSBNYXRoLm1heCh2YWx1ZS5tYXgsIG1lLm1heCk7XG5cblx0XHRcdFx0XHRcdGlmICh2YWx1ZS5taW4gIT09IDApIHtcblx0XHRcdFx0XHRcdFx0bWUubWluTm90WmVybyA9IE1hdGgubWluKHZhbHVlLm1pbiwgbWUubWluTm90WmVybyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUubWluID0gaGVscGVycyQxLmlzRmluaXRlKG1lLm1pbikgPyBtZS5taW4gOiBudWxsO1xuXHRcdG1lLm1heCA9IGhlbHBlcnMkMS5pc0Zpbml0ZShtZS5tYXgpID8gbWUubWF4IDogbnVsbDtcblx0XHRtZS5taW5Ob3RaZXJvID0gaGVscGVycyQxLmlzRmluaXRlKG1lLm1pbk5vdFplcm8pID8gbWUubWluTm90WmVybyA6IG51bGw7XG5cblx0XHQvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGlja3MubWluLCB0aWNrcy5tYXhcblx0XHR0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcblx0fSxcblxuXHRoYW5kbGVUaWNrUmFuZ2VPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIERFRkFVTFRfTUlOID0gMTtcblx0XHR2YXIgREVGQVVMVF9NQVggPSAxMDtcblxuXHRcdG1lLm1pbiA9IG5vbk5lZ2F0aXZlT3JEZWZhdWx0KHRpY2tPcHRzLm1pbiwgbWUubWluKTtcblx0XHRtZS5tYXggPSBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5tYXgsIG1lLm1heCk7XG5cblx0XHRpZiAobWUubWluID09PSBtZS5tYXgpIHtcblx0XHRcdGlmIChtZS5taW4gIT09IDAgJiYgbWUubWluICE9PSBudWxsKSB7XG5cdFx0XHRcdG1lLm1pbiA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKG1lLm1pbikpIC0gMSk7XG5cdFx0XHRcdG1lLm1heCA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKG1lLm1heCkpICsgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5taW4gPSBERUZBVUxUX01JTjtcblx0XHRcdFx0bWUubWF4ID0gREVGQVVMVF9NQVg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtZS5taW4gPT09IG51bGwpIHtcblx0XHRcdG1lLm1pbiA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKG1lLm1heCkpIC0gMSk7XG5cdFx0fVxuXHRcdGlmIChtZS5tYXggPT09IG51bGwpIHtcblx0XHRcdG1lLm1heCA9IG1lLm1pbiAhPT0gMFxuXHRcdFx0XHQ/IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKG1lLm1pbikpICsgMSlcblx0XHRcdFx0OiBERUZBVUxUX01BWDtcblx0XHR9XG5cdFx0aWYgKG1lLm1pbk5vdFplcm8gPT09IG51bGwpIHtcblx0XHRcdGlmIChtZS5taW4gPiAwKSB7XG5cdFx0XHRcdG1lLm1pbk5vdFplcm8gPSBtZS5taW47XG5cdFx0XHR9IGVsc2UgaWYgKG1lLm1heCA8IDEpIHtcblx0XHRcdFx0bWUubWluTm90WmVybyA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKG1lLm1heCkpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLm1pbk5vdFplcm8gPSBERUZBVUxUX01JTjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciByZXZlcnNlID0gIW1lLmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0dmFyIGdlbmVyYXRpb25PcHRpb25zID0ge1xuXHRcdFx0bWluOiBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5taW4pLFxuXHRcdFx0bWF4OiBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5tYXgpXG5cdFx0fTtcblx0XHR2YXIgdGlja3MgPSBtZS50aWNrcyA9IGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgbWUpO1xuXG5cdFx0Ly8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyBzaW5jZSB3ZSBoYXZlIGV4cGFuZGVkIHRoZVxuXHRcdC8vIHJhbmdlIG9mIHRoZSBzY2FsZVxuXHRcdG1lLm1heCA9IGhlbHBlcnMkMS5tYXgodGlja3MpO1xuXHRcdG1lLm1pbiA9IGhlbHBlcnMkMS5taW4odGlja3MpO1xuXG5cdFx0aWYgKHRpY2tPcHRzLnJldmVyc2UpIHtcblx0XHRcdHJldmVyc2UgPSAhcmV2ZXJzZTtcblx0XHRcdG1lLnN0YXJ0ID0gbWUubWF4O1xuXHRcdFx0bWUuZW5kID0gbWUubWluO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5zdGFydCA9IG1lLm1pbjtcblx0XHRcdG1lLmVuZCA9IG1lLm1heDtcblx0XHR9XG5cdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdHRpY2tzLnJldmVyc2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGlja1ZhbHVlcyA9IHRoaXMudGlja3Muc2xpY2UoKTtcblxuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwodGhpcyk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBjb3JyZWN0IHRvb2x0aXAgbGFiZWxcblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRTY2FsZUxhYmVsKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0fSxcblxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIHRpY2tzID0gdGhpcy50aWNrVmFsdWVzO1xuXHRcdGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgdGljay5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIG1pbmltdW0gbm90IHplcm8gdmFsdWUuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGZpcnN0IHRpY2sgdmFsdWUuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0Rmlyc3RUaWNrVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIGV4cCA9IE1hdGguZmxvb3IobG9nMTAodmFsdWUpKTtcblx0XHR2YXIgc2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKHZhbHVlIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuXG5cdFx0cmV0dXJuIHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCk7XG5cdH0sXG5cblx0X2NvbmZpZ3VyZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgc3RhcnQgPSBtZS5taW47XG5cdFx0dmFyIG9mZnNldCA9IDA7XG5cblx0XHRjb3JlX3NjYWxlLnByb3RvdHlwZS5fY29uZmlndXJlLmNhbGwobWUpO1xuXG5cdFx0aWYgKHN0YXJ0ID09PSAwKSB7XG5cdFx0XHRzdGFydCA9IG1lLl9nZXRGaXJzdFRpY2tWYWx1ZShtZS5taW5Ob3RaZXJvKTtcblx0XHRcdG9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JGIobWUub3B0aW9ucy50aWNrcy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKSAvIG1lLl9sZW5ndGg7XG5cdFx0fVxuXG5cdFx0bWUuX3N0YXJ0VmFsdWUgPSBsb2cxMChzdGFydCk7XG5cdFx0bWUuX3ZhbHVlT2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdG1lLl92YWx1ZVJhbmdlID0gKGxvZzEwKG1lLm1heCkgLSBsb2cxMChzdGFydCkpIC8gKDEgLSBvZmZzZXQpO1xuXHR9LFxuXG5cdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgZGVjaW1hbCA9IDA7XG5cblx0XHR2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHZhbHVlKTtcblxuXHRcdGlmICh2YWx1ZSA+IG1lLm1pbiAmJiB2YWx1ZSA+IDApIHtcblx0XHRcdGRlY2ltYWwgPSAobG9nMTAodmFsdWUpIC0gbWUuX3N0YXJ0VmFsdWUpIC8gbWUuX3ZhbHVlUmFuZ2UgKyBtZS5fdmFsdWVPZmZzZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZS5nZXRQaXhlbEZvckRlY2ltYWwoZGVjaW1hbCk7XG5cdH0sXG5cblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBkZWNpbWFsID0gbWUuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKTtcblx0XHRyZXR1cm4gZGVjaW1hbCA9PT0gMCAmJiBtZS5taW4gPT09IDBcblx0XHRcdD8gMFxuXHRcdFx0OiBNYXRoLnBvdygxMCwgbWUuX3N0YXJ0VmFsdWUgKyAoZGVjaW1hbCAtIG1lLl92YWx1ZU9mZnNldCkgKiBtZS5fdmFsdWVSYW5nZSk7XG5cdH1cbn0pO1xuXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcbnZhciBfZGVmYXVsdHMkMiA9IGRlZmF1bHRDb25maWckMjtcbnNjYWxlX2xvZ2FyaXRobWljLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQyO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkYyA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcbnZhciB2YWx1ZUF0SW5kZXhPckRlZmF1bHQkMSA9IGhlbHBlcnMkMS52YWx1ZUF0SW5kZXhPckRlZmF1bHQ7XG52YXIgcmVzb2x2ZSQ0ID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcblxudmFyIGRlZmF1bHRDb25maWckMyA9IHtcblx0ZGlzcGxheTogdHJ1ZSxcblxuXHQvLyBCb29sZWFuIC0gV2hldGhlciB0byBhbmltYXRlIHNjYWxpbmcgdGhlIGNoYXJ0IGZyb20gdGhlIGNlbnRyZVxuXHRhbmltYXRlOiB0cnVlLFxuXHRwb3NpdGlvbjogJ2NoYXJ0QXJlYScsXG5cblx0YW5nbGVMaW5lczoge1xuXHRcdGRpc3BsYXk6IHRydWUsXG5cdFx0Y29sb3I6ICdyZ2JhKDAsMCwwLDAuMSknLFxuXHRcdGxpbmVXaWR0aDogMSxcblx0XHRib3JkZXJEYXNoOiBbXSxcblx0XHRib3JkZXJEYXNoT2Zmc2V0OiAwLjBcblx0fSxcblxuXHRncmlkTGluZXM6IHtcblx0XHRjaXJjdWxhcjogZmFsc2Vcblx0fSxcblxuXHQvLyBsYWJlbCBzZXR0aW5nc1xuXHR0aWNrczoge1xuXHRcdC8vIEJvb2xlYW4gLSBTaG93IGEgYmFja2Ryb3AgdG8gdGhlIHNjYWxlIGxhYmVsXG5cdFx0c2hvd0xhYmVsQmFja2Ryb3A6IHRydWUsXG5cblx0XHQvLyBTdHJpbmcgLSBUaGUgY29sb3VyIG9mIHRoZSBsYWJlbCBiYWNrZHJvcFxuXHRcdGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNzUpJyxcblxuXHRcdC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIGFib3ZlICYgYmVsb3cgdGhlIGxhYmVsIGluIHBpeGVsc1xuXHRcdGJhY2tkcm9wUGFkZGluZ1k6IDIsXG5cblx0XHQvLyBOdW1iZXIgLSBUaGUgYmFja2Ryb3AgcGFkZGluZyB0byB0aGUgc2lkZSBvZiB0aGUgbGFiZWwgaW4gcGl4ZWxzXG5cdFx0YmFja2Ryb3BQYWRkaW5nWDogMixcblxuXHRcdGNhbGxiYWNrOiBjb3JlX3RpY2tzLmZvcm1hdHRlcnMubGluZWFyXG5cdH0sXG5cblx0cG9pbnRMYWJlbHM6IHtcblx0XHQvLyBCb29sZWFuIC0gaWYgdHJ1ZSwgc2hvdyBwb2ludCBsYWJlbHNcblx0XHRkaXNwbGF5OiB0cnVlLFxuXG5cdFx0Ly8gTnVtYmVyIC0gUG9pbnQgbGFiZWwgZm9udCBzaXplIGluIHBpeGVsc1xuXHRcdGZvbnRTaXplOiAxMCxcblxuXHRcdC8vIEZ1bmN0aW9uIC0gVXNlZCB0byBjb252ZXJ0IHBvaW50IGxhYmVsc1xuXHRcdGNhbGxiYWNrOiBmdW5jdGlvbihsYWJlbCkge1xuXHRcdFx0cmV0dXJuIGxhYmVsO1xuXHRcdH1cblx0fVxufTtcblxuZnVuY3Rpb24gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIHtcblx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuXHRpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcblx0XHRyZXR1cm4gdmFsdWVPckRlZmF1bHQkYyh0aWNrT3B0cy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKSArIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1kgKiAyO1xuXHR9XG5cdHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgbGluZUhlaWdodCwgbGFiZWwpIHtcblx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGxhYmVsKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR3OiBoZWxwZXJzJDEubG9uZ2VzdFRleHQoY3R4LCBjdHguZm9udCwgbGFiZWwpLFxuXHRcdFx0aDogbGFiZWwubGVuZ3RoICogbGluZUhlaWdodFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHc6IGN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGgsXG5cdFx0aDogbGluZUhlaWdodFxuXHR9O1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvcywgc2l6ZSwgbWluLCBtYXgpIHtcblx0aWYgKGFuZ2xlID09PSBtaW4gfHwgYW5nbGUgPT09IG1heCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzdGFydDogcG9zIC0gKHNpemUgLyAyKSxcblx0XHRcdGVuZDogcG9zICsgKHNpemUgLyAyKVxuXHRcdH07XG5cdH0gZWxzZSBpZiAoYW5nbGUgPCBtaW4gfHwgYW5nbGUgPiBtYXgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhcnQ6IHBvcyAtIHNpemUsXG5cdFx0XHRlbmQ6IHBvc1xuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHN0YXJ0OiBwb3MsXG5cdFx0ZW5kOiBwb3MgKyBzaXplXG5cdH07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGZpdCBhIHJhZGlhbCBsaW5lYXIgc2NhbGUgd2l0aCBwb2ludCBsYWJlbHNcbiAqL1xuZnVuY3Rpb24gZml0V2l0aFBvaW50TGFiZWxzKHNjYWxlKSB7XG5cblx0Ly8gUmlnaHQsIHRoaXMgaXMgcmVhbGx5IGNvbmZ1c2luZyBhbmQgdGhlcmUgaXMgYSBsb3Qgb2YgbWF0aHMgZ29pbmcgb24gaGVyZVxuXHQvLyBUaGUgZ2lzdCBvZiB0aGUgcHJvYmxlbSBpcyBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ubm5pY2svNjk2Y2M5YzU1ZjRiMGJlYjhmZTlcblx0Ly9cblx0Ly8gUmVhY3Rpb246IGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3Rvb211Y2hzY2llbmNlLmdpZlxuXHQvL1xuXHQvLyBTb2x1dGlvbjpcblx0Ly9cblx0Ly8gV2UgYXNzdW1lIHRoZSByYWRpdXMgb2YgdGhlIHBvbHlnb24gaXMgaGFsZiB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzIGF0IGZpcnN0XG5cdC8vIGF0IGVhY2ggaW5kZXggd2UgY2hlY2sgaWYgdGhlIHRleHQgb3ZlcmxhcHMuXG5cdC8vXG5cdC8vIFdoZXJlIGl0IGRvZXMsIHdlIHN0b3JlIHRoYXQgYW5nbGUgYW5kIHRoYXQgaW5kZXguXG5cdC8vXG5cdC8vIEFmdGVyIGZpbmRpbmcgdGhlIGxhcmdlc3QgaW5kZXggYW5kIGFuZ2xlIHdlIGNhbGN1bGF0ZSBob3cgbXVjaCB3ZSBuZWVkIHRvIHJlbW92ZVxuXHQvLyBmcm9tIHRoZSBzaGFwZSByYWRpdXMgdG8gbW92ZSB0aGUgcG9pbnQgaW53YXJkcyBieSB0aGF0IHguXG5cdC8vXG5cdC8vIFdlIGF2ZXJhZ2UgdGhlIGxlZnQgYW5kIHJpZ2h0IGRpc3RhbmNlcyB0byBnZXQgdGhlIG1heGltdW0gc2hhcGUgcmFkaXVzIHRoYXQgY2FuIGZpdCBpbiB0aGUgYm94XG5cdC8vIGFsb25nIHdpdGggbGFiZWxzLlxuXHQvL1xuXHQvLyBPbmNlIHdlIGhhdmUgdGhhdCwgd2UgY2FuIGZpbmQgdGhlIGNlbnRyZSBwb2ludCBmb3IgdGhlIGNoYXJ0LCBieSB0YWtpbmcgdGhlIHggdGV4dCBwcm90cnVzaW9uXG5cdC8vIG9uIGVhY2ggc2lkZSwgcmVtb3ZpbmcgdGhhdCBmcm9tIHRoZSBzaXplLCBoYWx2aW5nIGl0IGFuZCBhZGRpbmcgdGhlIGxlZnQgeCBwcm90cnVzaW9uIHdpZHRoLlxuXHQvL1xuXHQvLyBUaGlzIHdpbGwgbWVhbiB3ZSBoYXZlIGEgc2hhcGUgZml0dGVkIHRvIHRoZSBjYW52YXMsIGFzIGxhcmdlIGFzIGl0IGNhbiBiZSB3aXRoIHRoZSBsYWJlbHNcblx0Ly8gYW5kIHBvc2l0aW9uIGl0IGluIHRoZSBtb3N0IHNwYWNlIGVmZmljaWVudCBtYW5uZXJcblx0Ly9cblx0Ly8gaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMveWVhaHNjaWVuY2UuZ2lmXG5cblx0dmFyIHBsRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQoc2NhbGUub3B0aW9ucy5wb2ludExhYmVscyk7XG5cblx0Ly8gR2V0IG1heGltdW0gcmFkaXVzIG9mIHRoZSBwb2x5Z29uLiBFaXRoZXIgaGFsZiB0aGUgaGVpZ2h0IChtaW51cyB0aGUgdGV4dCB3aWR0aCkgb3IgaGFsZiB0aGUgd2lkdGguXG5cdC8vIFVzZSB0aGlzIHRvIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0ICsgY2hhbmdlLiAtIE1ha2Ugc3VyZSBML1IgcHJvdHJ1c2lvbiBpcyBhdCBsZWFzdCAwIHRvIHN0b3AgaXNzdWVzIHdpdGggY2VudHJlIHBvaW50c1xuXHR2YXIgZnVydGhlc3RMaW1pdHMgPSB7XG5cdFx0bDogMCxcblx0XHRyOiBzY2FsZS53aWR0aCxcblx0XHR0OiAwLFxuXHRcdGI6IHNjYWxlLmhlaWdodCAtIHNjYWxlLnBhZGRpbmdUb3Bcblx0fTtcblx0dmFyIGZ1cnRoZXN0QW5nbGVzID0ge307XG5cdHZhciBpLCB0ZXh0U2l6ZSwgcG9pbnRQb3NpdGlvbjtcblxuXHRzY2FsZS5jdHguZm9udCA9IHBsRm9udC5zdHJpbmc7XG5cdHNjYWxlLl9wb2ludExhYmVsU2l6ZXMgPSBbXTtcblxuXHR2YXIgdmFsdWVDb3VudCA9IHNjYWxlLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aDtcblx0Zm9yIChpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuXHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgNSk7XG5cdFx0dGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LmxpbmVIZWlnaHQsIHNjYWxlLnBvaW50TGFiZWxzW2ldKTtcblx0XHRzY2FsZS5fcG9pbnRMYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG5cblx0XHQvLyBBZGQgcXVhcnRlciBjaXJjbGUgdG8gbWFrZSBkZWdyZWUgMCBtZWFuIHRvcCBvZiBjaXJjbGVcblx0XHR2YXIgYW5nbGVSYWRpYW5zID0gc2NhbGUuZ2V0SW5kZXhBbmdsZShpKTtcblx0XHR2YXIgYW5nbGUgPSBoZWxwZXJzJDEudG9EZWdyZWVzKGFuZ2xlUmFkaWFucykgJSAzNjA7XG5cdFx0dmFyIGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcblx0XHR2YXIgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcblxuXHRcdGlmIChoTGltaXRzLnN0YXJ0IDwgZnVydGhlc3RMaW1pdHMubCkge1xuXHRcdFx0ZnVydGhlc3RMaW1pdHMubCA9IGhMaW1pdHMuc3RhcnQ7XG5cdFx0XHRmdXJ0aGVzdEFuZ2xlcy5sID0gYW5nbGVSYWRpYW5zO1xuXHRcdH1cblxuXHRcdGlmIChoTGltaXRzLmVuZCA+IGZ1cnRoZXN0TGltaXRzLnIpIHtcblx0XHRcdGZ1cnRoZXN0TGltaXRzLnIgPSBoTGltaXRzLmVuZDtcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLnIgPSBhbmdsZVJhZGlhbnM7XG5cdFx0fVxuXG5cdFx0aWYgKHZMaW1pdHMuc3RhcnQgPCBmdXJ0aGVzdExpbWl0cy50KSB7XG5cdFx0XHRmdXJ0aGVzdExpbWl0cy50ID0gdkxpbWl0cy5zdGFydDtcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLnQgPSBhbmdsZVJhZGlhbnM7XG5cdFx0fVxuXG5cdFx0aWYgKHZMaW1pdHMuZW5kID4gZnVydGhlc3RMaW1pdHMuYikge1xuXHRcdFx0ZnVydGhlc3RMaW1pdHMuYiA9IHZMaW1pdHMuZW5kO1xuXHRcdFx0ZnVydGhlc3RBbmdsZXMuYiA9IGFuZ2xlUmFkaWFucztcblx0XHR9XG5cdH1cblxuXHRzY2FsZS5zZXRSZWR1Y3Rpb25zKHNjYWxlLmRyYXdpbmdBcmVhLCBmdXJ0aGVzdExpbWl0cywgZnVydGhlc3RBbmdsZXMpO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xuXHRpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuXHRcdHJldHVybiAnY2VudGVyJztcblx0fSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuXHRcdHJldHVybiAnbGVmdCc7XG5cdH1cblxuXHRyZXR1cm4gJ3JpZ2h0Jztcbn1cblxuZnVuY3Rpb24gZmlsbFRleHQoY3R4LCB0ZXh0LCBwb3NpdGlvbiwgbGluZUhlaWdodCkge1xuXHR2YXIgeSA9IHBvc2l0aW9uLnkgKyBsaW5lSGVpZ2h0IC8gMjtcblx0dmFyIGksIGlsZW47XG5cblx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRleHQpKSB7XG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRleHQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRjdHguZmlsbFRleHQodGV4dFtpXSwgcG9zaXRpb24ueCwgeSk7XG5cdFx0XHR5ICs9IGxpbmVIZWlnaHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGN0eC5maWxsVGV4dCh0ZXh0LCBwb3NpdGlvbi54LCB5KTtcblx0fVxufVxuXG5mdW5jdGlvbiBhZGp1c3RQb2ludFBvc2l0aW9uRm9yTGFiZWxIZWlnaHQoYW5nbGUsIHRleHRTaXplLCBwb3NpdGlvbikge1xuXHRpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcblx0XHRwb3NpdGlvbi55IC09ICh0ZXh0U2l6ZS5oIC8gMik7XG5cdH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuXHRcdHBvc2l0aW9uLnkgLT0gdGV4dFNpemUuaDtcblx0fVxufVxuXG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUpIHtcblx0dmFyIGN0eCA9IHNjYWxlLmN0eDtcblx0dmFyIG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuXHR2YXIgcG9pbnRMYWJlbE9wdHMgPSBvcHRzLnBvaW50TGFiZWxzO1xuXHR2YXIgdGlja0JhY2tkcm9wSGVpZ2h0ID0gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpO1xuXHR2YXIgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG9wdHMudGlja3MucmV2ZXJzZSA/IHNjYWxlLm1pbiA6IHNjYWxlLm1heCk7XG5cdHZhciBwbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHBvaW50TGFiZWxPcHRzKTtcblxuXHRjdHguc2F2ZSgpO1xuXG5cdGN0eC5mb250ID0gcGxGb250LnN0cmluZztcblx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG5cdGZvciAodmFyIGkgPSBzY2FsZS5jaGFydC5kYXRhLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdC8vIEV4dHJhIHBpeGVscyBvdXQgZm9yIHNvbWUgbGFiZWwgc3BhY2luZ1xuXHRcdHZhciBleHRyYSA9IChpID09PSAwID8gdGlja0JhY2tkcm9wSGVpZ2h0IC8gMiA6IDApO1xuXHRcdHZhciBwb2ludExhYmVsUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIG91dGVyRGlzdGFuY2UgKyBleHRyYSArIDUpO1xuXG5cdFx0Ly8gS2VlcCB0aGlzIGluIGxvb3Agc2luY2Ugd2UgbWF5IHN1cHBvcnQgYXJyYXkgcHJvcGVydGllcyBoZXJlXG5cdFx0dmFyIHBvaW50TGFiZWxGb250Q29sb3IgPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQkMShwb2ludExhYmVsT3B0cy5mb250Q29sb3IsIGksIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250Q29sb3IpO1xuXHRcdGN0eC5maWxsU3R5bGUgPSBwb2ludExhYmVsRm9udENvbG9yO1xuXG5cdFx0dmFyIGFuZ2xlUmFkaWFucyA9IHNjYWxlLmdldEluZGV4QW5nbGUoaSk7XG5cdFx0dmFyIGFuZ2xlID0gaGVscGVycyQxLnRvRGVncmVlcyhhbmdsZVJhZGlhbnMpO1xuXHRcdGN0eC50ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSk7XG5cdFx0YWRqdXN0UG9pbnRQb3NpdGlvbkZvckxhYmVsSGVpZ2h0KGFuZ2xlLCBzY2FsZS5fcG9pbnRMYWJlbFNpemVzW2ldLCBwb2ludExhYmVsUG9zaXRpb24pO1xuXHRcdGZpbGxUZXh0KGN0eCwgc2NhbGUucG9pbnRMYWJlbHNbaV0sIHBvaW50TGFiZWxQb3NpdGlvbiwgcGxGb250LmxpbmVIZWlnaHQpO1xuXHR9XG5cdGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdSYWRpdXNMaW5lKHNjYWxlLCBncmlkTGluZU9wdHMsIHJhZGl1cywgaW5kZXgpIHtcblx0dmFyIGN0eCA9IHNjYWxlLmN0eDtcblx0dmFyIGNpcmN1bGFyID0gZ3JpZExpbmVPcHRzLmNpcmN1bGFyO1xuXHR2YXIgdmFsdWVDb3VudCA9IHNjYWxlLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aDtcblx0dmFyIGxpbmVDb2xvciA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxKGdyaWRMaW5lT3B0cy5jb2xvciwgaW5kZXggLSAxKTtcblx0dmFyIGxpbmVXaWR0aCA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxKGdyaWRMaW5lT3B0cy5saW5lV2lkdGgsIGluZGV4IC0gMSk7XG5cdHZhciBwb2ludFBvc2l0aW9uO1xuXG5cdGlmICgoIWNpcmN1bGFyICYmICF2YWx1ZUNvdW50KSB8fCAhbGluZUNvbG9yIHx8ICFsaW5lV2lkdGgpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjdHguc2F2ZSgpO1xuXHRjdHguc3Ryb2tlU3R5bGUgPSBsaW5lQ29sb3I7XG5cdGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRjdHguc2V0TGluZURhc2goZ3JpZExpbmVPcHRzLmJvcmRlckRhc2ggfHwgW10pO1xuXHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0IHx8IDAuMDtcblx0fVxuXG5cdGN0eC5iZWdpblBhdGgoKTtcblx0aWYgKGNpcmN1bGFyKSB7XG5cdFx0Ly8gRHJhdyBjaXJjdWxhciBhcmNzIGJldHdlZW4gdGhlIHBvaW50c1xuXHRcdGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gRHJhdyBzdHJhaWdodCBsaW5lcyBjb25uZWN0aW5nIGVhY2ggaW5kZXhcblx0XHRwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuXHRcdGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcblx0XHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHJhZGl1cyk7XG5cdFx0XHRjdHgubGluZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcblx0XHR9XG5cdH1cblx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRjdHguc3Ryb2tlKCk7XG5cdGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlck9yWmVybyhwYXJhbSkge1xuXHRyZXR1cm4gaGVscGVycyQxLmlzTnVtYmVyKHBhcmFtKSA/IHBhcmFtIDogMDtcbn1cblxudmFyIHNjYWxlX3JhZGlhbExpbmVhciA9IHNjYWxlX2xpbmVhcmJhc2UuZXh0ZW5kKHtcblx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XG5cdFx0bWUucGFkZGluZ1RvcCA9IGdldFRpY2tCYWNrZHJvcEhlaWdodChtZS5vcHRpb25zKSAvIDI7XG5cdFx0bWUueENlbnRlciA9IE1hdGguZmxvb3IobWUud2lkdGggLyAyKTtcblx0XHRtZS55Q2VudGVyID0gTWF0aC5mbG9vcigobWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCkgLyAyKTtcblx0XHRtZS5kcmF3aW5nQXJlYSA9IE1hdGgubWluKG1lLmhlaWdodCAtIG1lLnBhZGRpbmdUb3AsIG1lLndpZHRoKSAvIDI7XG5cdH0sXG5cblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHRcdHZhciBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChjaGFydC5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtaW4gPSBNYXRoLm1pbih2YWx1ZSwgbWluKTtcblx0XHRcdFx0XHRtYXggPSBNYXRoLm1heCh2YWx1ZSwgbWF4KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRtZS5taW4gPSAobWluID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPyAwIDogbWluKTtcblx0XHRtZS5tYXggPSAobWF4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPyAwIDogbWF4KTtcblxuXHRcdC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSB0aWNrcy5taW4sIHRpY2tzLm1heCwgdGlja3MuYmVnaW5BdFplcm9cblx0XHRtZS5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG5cdH0sXG5cblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgYmFzZWQgb24gdGhlIHNjYWxlIGRpbWVuc2lvblxuXHRfY29tcHV0ZVRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xuXHR9LFxuXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0c2NhbGVfbGluZWFyYmFzZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbChtZSk7XG5cblx0XHQvLyBQb2ludCBsYWJlbHNcblx0XHRtZS5wb2ludExhYmVscyA9IG1lLmNoYXJ0LmRhdGEubGFiZWxzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBsYWJlbCA9IGhlbHBlcnMkMS5jYWxsYmFjayhtZS5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBhcmd1bWVudHMsIG1lKTtcblx0XHRcdHJldHVybiBsYWJlbCB8fCBsYWJlbCA9PT0gMCA/IGxhYmVsIDogJyc7XG5cdFx0fSk7XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0fSxcblxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcblx0XHRcdGZpdFdpdGhQb2ludExhYmVscyhtZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0IHJhZGl1cyByZWR1Y3Rpb25zIGFuZCBkZXRlcm1pbmUgbmV3IHJhZGl1cyBhbmQgY2VudGVyIHBvaW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzZXRSZWR1Y3Rpb25zOiBmdW5jdGlvbihsYXJnZXN0UG9zc2libGVSYWRpdXMsIGZ1cnRoZXN0TGltaXRzLCBmdXJ0aGVzdEFuZ2xlcykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBmdXJ0aGVzdExpbWl0cy5sIC8gTWF0aC5zaW4oZnVydGhlc3RBbmdsZXMubCk7XG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuciAtIG1lLndpZHRoLCAwKSAvIE1hdGguc2luKGZ1cnRoZXN0QW5nbGVzLnIpO1xuXHRcdHZhciByYWRpdXNSZWR1Y3Rpb25Ub3AgPSAtZnVydGhlc3RMaW1pdHMudCAvIE1hdGguY29zKGZ1cnRoZXN0QW5nbGVzLnQpO1xuXHRcdHZhciByYWRpdXNSZWR1Y3Rpb25Cb3R0b20gPSAtTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuYiAtIChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSwgMCkgLyBNYXRoLmNvcyhmdXJ0aGVzdEFuZ2xlcy5iKTtcblxuXHRcdHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uTGVmdCk7XG5cdFx0cmFkaXVzUmVkdWN0aW9uUmlnaHQgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uUmlnaHQpO1xuXHRcdHJhZGl1c1JlZHVjdGlvblRvcCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Ub3ApO1xuXHRcdHJhZGl1c1JlZHVjdGlvbkJvdHRvbSA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Cb3R0b20pO1xuXG5cdFx0bWUuZHJhd2luZ0FyZWEgPSBNYXRoLm1pbihcblx0XHRcdE1hdGguZmxvb3IobGFyZ2VzdFBvc3NpYmxlUmFkaXVzIC0gKHJhZGl1c1JlZHVjdGlvbkxlZnQgKyByYWRpdXNSZWR1Y3Rpb25SaWdodCkgLyAyKSxcblx0XHRcdE1hdGguZmxvb3IobGFyZ2VzdFBvc3NpYmxlUmFkaXVzIC0gKHJhZGl1c1JlZHVjdGlvblRvcCArIHJhZGl1c1JlZHVjdGlvbkJvdHRvbSkgLyAyKSk7XG5cdFx0bWUuc2V0Q2VudGVyUG9pbnQocmFkaXVzUmVkdWN0aW9uTGVmdCwgcmFkaXVzUmVkdWN0aW9uUmlnaHQsIHJhZGl1c1JlZHVjdGlvblRvcCwgcmFkaXVzUmVkdWN0aW9uQm90dG9tKTtcblx0fSxcblxuXHRzZXRDZW50ZXJQb2ludDogZnVuY3Rpb24obGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtYXhSaWdodCA9IG1lLndpZHRoIC0gcmlnaHRNb3ZlbWVudCAtIG1lLmRyYXdpbmdBcmVhO1xuXHRcdHZhciBtYXhMZWZ0ID0gbGVmdE1vdmVtZW50ICsgbWUuZHJhd2luZ0FyZWE7XG5cdFx0dmFyIG1heFRvcCA9IHRvcE1vdmVtZW50ICsgbWUuZHJhd2luZ0FyZWE7XG5cdFx0dmFyIG1heEJvdHRvbSA9IChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSAtIGJvdHRvbU1vdmVtZW50IC0gbWUuZHJhd2luZ0FyZWE7XG5cblx0XHRtZS54Q2VudGVyID0gTWF0aC5mbG9vcigoKG1heExlZnQgKyBtYXhSaWdodCkgLyAyKSArIG1lLmxlZnQpO1xuXHRcdG1lLnlDZW50ZXIgPSBNYXRoLmZsb29yKCgobWF4VG9wICsgbWF4Qm90dG9tKSAvIDIpICsgbWUudG9wICsgbWUucGFkZGluZ1RvcCk7XG5cdH0sXG5cblx0Z2V0SW5kZXhBbmdsZTogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXHRcdHZhciBhbmdsZU11bHRpcGxpZXIgPSAzNjAgLyBjaGFydC5kYXRhLmxhYmVscy5sZW5ndGg7XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zIHx8IHt9O1xuXHRcdHZhciBzdGFydEFuZ2xlID0gb3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XG5cblx0XHQvLyBTdGFydCBmcm9tIHRoZSB0b3AgaW5zdGVhZCBvZiByaWdodCwgc28gcmVtb3ZlIGEgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG5cdFx0dmFyIGFuZ2xlID0gKGluZGV4ICogYW5nbGVNdWx0aXBsaWVyICsgc3RhcnRBbmdsZSkgJSAzNjA7XG5cblx0XHRyZXR1cm4gKGFuZ2xlIDwgMCA/IGFuZ2xlICsgMzYwIDogYW5nbGUpICogTWF0aC5QSSAqIDIgLyAzNjA7XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcblx0XHRcdHJldHVybiBOYU47XG5cdFx0fVxuXG5cdFx0Ly8gVGFrZSBpbnRvIGFjY291bnQgaGFsZiBmb250IHNpemUgKyB0aGUgeVBhZGRpbmcgb2YgdGhlIHRvcCB2YWx1ZVxuXHRcdHZhciBzY2FsaW5nRmFjdG9yID0gbWUuZHJhd2luZ0FyZWEgLyAobWUubWF4IC0gbWUubWluKTtcblx0XHRpZiAobWUub3B0aW9ucy50aWNrcy5yZXZlcnNlKSB7XG5cdFx0XHRyZXR1cm4gKG1lLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG5cdFx0fVxuXHRcdHJldHVybiAodmFsdWUgLSBtZS5taW4pICogc2NhbGluZ0ZhY3Rvcjtcblx0fSxcblxuXHRnZXRQb2ludFBvc2l0aW9uOiBmdW5jdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGhpc0FuZ2xlID0gbWUuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSAoTWF0aC5QSSAvIDIpO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBNYXRoLmNvcyh0aGlzQW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgbWUueENlbnRlcixcblx0XHRcdHk6IE1hdGguc2luKHRoaXNBbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyBtZS55Q2VudGVyXG5cdFx0fTtcblx0fSxcblxuXHRnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWU6IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcblx0fSxcblxuXHRnZXRCYXNlUG9zaXRpb246IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWluID0gbWUubWluO1xuXHRcdHZhciBtYXggPSBtZS5tYXg7XG5cblx0XHRyZXR1cm4gbWUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4IHx8IDAsXG5cdFx0XHRtZS5iZWdpbkF0WmVybyA/IDAgOlxuXHRcdFx0bWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcblx0XHRcdG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG5cdFx0XHQwKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9kcmF3R3JpZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgZ3JpZExpbmVPcHRzID0gb3B0cy5ncmlkTGluZXM7XG5cdFx0dmFyIGFuZ2xlTGluZU9wdHMgPSBvcHRzLmFuZ2xlTGluZXM7XG5cdFx0dmFyIGxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JGMoYW5nbGVMaW5lT3B0cy5saW5lV2lkdGgsIGdyaWRMaW5lT3B0cy5saW5lV2lkdGgpO1xuXHRcdHZhciBsaW5lQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCRjKGFuZ2xlTGluZU9wdHMuY29sb3IsIGdyaWRMaW5lT3B0cy5jb2xvcik7XG5cdFx0dmFyIGksIG9mZnNldCwgcG9zaXRpb247XG5cblx0XHRpZiAob3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG5cdFx0XHRkcmF3UG9pbnRMYWJlbHMobWUpO1xuXHRcdH1cblxuXHRcdGlmIChncmlkTGluZU9wdHMuZGlzcGxheSkge1xuXHRcdFx0aGVscGVycyQxLmVhY2gobWUudGlja3MsIGZ1bmN0aW9uKGxhYmVsLCBpbmRleCkge1xuXHRcdFx0XHRpZiAoaW5kZXggIT09IDApIHtcblx0XHRcdFx0XHRvZmZzZXQgPSBtZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShtZS50aWNrc0FzTnVtYmVyc1tpbmRleF0pO1xuXHRcdFx0XHRcdGRyYXdSYWRpdXNMaW5lKG1lLCBncmlkTGluZU9wdHMsIG9mZnNldCwgaW5kZXgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoYW5nbGVMaW5lT3B0cy5kaXNwbGF5ICYmIGxpbmVXaWR0aCAmJiBsaW5lQ29sb3IpIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gbGluZUNvbG9yO1xuXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRjdHguc2V0TGluZURhc2gocmVzb2x2ZSQ0KFthbmdsZUxpbmVPcHRzLmJvcmRlckRhc2gsIGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoLCBbXV0pKTtcblx0XHRcdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gcmVzb2x2ZSQ0KFthbmdsZUxpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQsIGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0LCAwLjBdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gbWUuY2hhcnQuZGF0YS5sYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0b2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gbWUubWluIDogbWUubWF4KTtcblx0XHRcdFx0cG9zaXRpb24gPSBtZS5nZXRQb2ludFBvc2l0aW9uKGksIG9mZnNldCk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4Lm1vdmVUbyhtZS54Q2VudGVyLCBtZS55Q2VudGVyKTtcblx0XHRcdFx0Y3R4LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9kcmF3TGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjdHggPSBtZS5jdHg7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0XHRpZiAoIXRpY2tPcHRzLmRpc3BsYXkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgc3RhcnRBbmdsZSA9IG1lLmdldEluZGV4QW5nbGUoMCk7XG5cdFx0dmFyIHRpY2tGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udCh0aWNrT3B0cyk7XG5cdFx0dmFyIHRpY2tGb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCRjKHRpY2tPcHRzLmZvbnRDb2xvciwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0dmFyIG9mZnNldCwgd2lkdGg7XG5cblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuXHRcdGN0eC50cmFuc2xhdGUobWUueENlbnRlciwgbWUueUNlbnRlcik7XG5cdFx0Y3R4LnJvdGF0ZShzdGFydEFuZ2xlKTtcblx0XHRjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG5cdFx0aGVscGVycyQxLmVhY2gobWUudGlja3MsIGZ1bmN0aW9uKGxhYmVsLCBpbmRleCkge1xuXHRcdFx0aWYgKGluZGV4ID09PSAwICYmICF0aWNrT3B0cy5yZXZlcnNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0b2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUobWUudGlja3NBc051bWJlcnNbaW5kZXhdKTtcblxuXHRcdFx0aWYgKHRpY2tPcHRzLnNob3dMYWJlbEJhY2tkcm9wKSB7XG5cdFx0XHRcdHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRpY2tPcHRzLmJhY2tkcm9wQ29sb3I7XG5cblx0XHRcdFx0Y3R4LmZpbGxSZWN0KFxuXHRcdFx0XHRcdC13aWR0aCAvIDIgLSB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdYLFxuXHRcdFx0XHRcdC1vZmZzZXQgLSB0aWNrRm9udC5zaXplIC8gMiAtIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1ksXG5cdFx0XHRcdFx0d2lkdGggKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdYICogMixcblx0XHRcdFx0XHR0aWNrRm9udC5zaXplICsgdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWSAqIDJcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRpY2tGb250Q29sb3I7XG5cdFx0XHRjdHguZmlsbFRleHQobGFiZWwsIDAsIC1vZmZzZXQpO1xuXHRcdH0pO1xuXG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9kcmF3VGl0bGU6IGhlbHBlcnMkMS5ub29wXG59KTtcblxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXG52YXIgX2RlZmF1bHRzJDMgPSBkZWZhdWx0Q29uZmlnJDM7XG5zY2FsZV9yYWRpYWxMaW5lYXIuX2RlZmF1bHRzID0gX2RlZmF1bHRzJDM7XG5cbnZhciBkZXByZWNhdGVkJDEgPSBoZWxwZXJzJDEuX2RlcHJlY2F0ZWQ7XG52YXIgcmVzb2x2ZSQ1ID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcbnZhciB2YWx1ZU9yRGVmYXVsdCRkID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG4vLyBJbnRlZ2VyIGNvbnN0YW50cyBhcmUgZnJvbSB0aGUgRVM2IHNwZWMuXG52YXIgTUlOX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB8fCAtOTAwNzE5OTI1NDc0MDk5MTtcbnZhciBNQVhfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbnZhciBJTlRFUlZBTFMgPSB7XG5cdG1pbGxpc2Vjb25kOiB7XG5cdFx0Y29tbW9uOiB0cnVlLFxuXHRcdHNpemU6IDEsXG5cdFx0c3RlcHM6IDEwMDBcblx0fSxcblx0c2Vjb25kOiB7XG5cdFx0Y29tbW9uOiB0cnVlLFxuXHRcdHNpemU6IDEwMDAsXG5cdFx0c3RlcHM6IDYwXG5cdH0sXG5cdG1pbnV0ZToge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiA2MDAwMCxcblx0XHRzdGVwczogNjBcblx0fSxcblx0aG91cjoge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiAzNjAwMDAwLFxuXHRcdHN0ZXBzOiAyNFxuXHR9LFxuXHRkYXk6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogODY0MDAwMDAsXG5cdFx0c3RlcHM6IDMwXG5cdH0sXG5cdHdlZWs6IHtcblx0XHRjb21tb246IGZhbHNlLFxuXHRcdHNpemU6IDYwNDgwMDAwMCxcblx0XHRzdGVwczogNFxuXHR9LFxuXHRtb250aDoge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiAyLjYyOGU5LFxuXHRcdHN0ZXBzOiAxMlxuXHR9LFxuXHRxdWFydGVyOiB7XG5cdFx0Y29tbW9uOiBmYWxzZSxcblx0XHRzaXplOiA3Ljg4NGU5LFxuXHRcdHN0ZXBzOiA0XG5cdH0sXG5cdHllYXI6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMy4xNTRlMTBcblx0fVxufTtcblxudmFyIFVOSVRTID0gT2JqZWN0LmtleXMoSU5URVJWQUxTKTtcblxuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcblx0cmV0dXJuIGEgLSBiO1xufVxuXG5mdW5jdGlvbiBhcnJheVVuaXF1ZShpdGVtcykge1xuXHR2YXIgaGFzaCA9IHt9O1xuXHR2YXIgb3V0ID0gW107XG5cdHZhciBpLCBpbGVuLCBpdGVtO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRpdGVtID0gaXRlbXNbaV07XG5cdFx0aWYgKCFoYXNoW2l0ZW1dKSB7XG5cdFx0XHRoYXNoW2l0ZW1dID0gdHJ1ZTtcblx0XHRcdG91dC5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGdldE1pbihvcHRpb25zKSB7XG5cdHJldHVybiBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQob3B0aW9ucy50aW1lLm1pbiwgb3B0aW9ucy50aWNrcy5taW4pO1xufVxuXG5mdW5jdGlvbiBnZXRNYXgob3B0aW9ucykge1xuXHRyZXR1cm4gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGltZS5tYXgsIG9wdGlvbnMudGlja3MubWF4KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHt0aW1lLCBwb3N9IG9iamVjdHMgdXNlZCB0byBpbnRlcnBvbGF0ZSBhIHNwZWNpZmljIGB0aW1lYCBvciBwb3NpdGlvblxuICogKGBwb3NgKSBvbiB0aGUgc2NhbGUsIGJ5IHNlYXJjaGluZyBlbnRyaWVzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHJlcXVlc3RlZCB2YWx1ZS4gYHBvc2AgaXNcbiAqIGEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDE6IDAgYmVpbmcgdGhlIHN0YXJ0IG9mIHRoZSBzY2FsZSAobGVmdCBvciB0b3ApIGFuZCAxIHRoZSBvdGhlclxuICogZXh0cmVtaXR5IChsZWZ0ICsgd2lkdGggb3IgdG9wICsgaGVpZ2h0KS4gTm90ZSB0aGF0IGl0IHdvdWxkIGJlIG1vcmUgb3B0aW1pemVkIHRvIGRpcmVjdGx5XG4gKiBzdG9yZSBwcmUtY29tcHV0ZWQgcGl4ZWxzLCBidXQgdGhlIHNjYWxlIGRpbWVuc2lvbnMgYXJlIG5vdCBndWFyYW50ZWVkIGF0IHRoZSB0aW1lIHdlIG5lZWRcbiAqIHRvIGNyZWF0ZSB0aGUgbG9va3VwIHRhYmxlLiBUaGUgdGFibGUgQUxXQVlTIGNvbnRhaW5zIGF0IGxlYXN0IHR3byBpdGVtczogbWluIGFuZCBtYXguXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gdGltZXN0YW1wcyAtIHRpbWVzdGFtcHMgc29ydGVkIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzdHJpYnV0aW9uIC0gSWYgJ2xpbmVhcicsIHRpbWVzdGFtcHMgd2lsbCBiZSBzcHJlYWQgbGluZWFybHkgYWxvbmcgdGhlIG1pblxuICogYW5kIG1heCByYW5nZSwgc28gYmFzaWNhbGx5LCB0aGUgdGFibGUgd2lsbCBjb250YWlucyBvbmx5IHR3byBpdGVtczoge21pbiwgMH0gYW5kIHttYXgsIDF9LlxuICogSWYgJ3NlcmllcycsIHRpbWVzdGFtcHMgd2lsbCBiZSBwb3NpdGlvbmVkIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlci4gSW4gdGhpc1xuICogY2FzZSwgb25seSB0aW1lc3RhbXBzIHRoYXQgYnJlYWsgdGhlIHRpbWUgbGluZWFyaXR5IGFyZSByZWdpc3RlcmVkLCBtZWFuaW5nIHRoYXQgaW4gdGhlXG4gKiBiZXN0IGNhc2UsIGFsbCB0aW1lc3RhbXBzIGFyZSBsaW5lYXIsIHRoZSB0YWJsZSBjb250YWlucyBvbmx5IG1pbiBhbmQgbWF4LlxuICovXG5mdW5jdGlvbiBidWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMsIG1pbiwgbWF4LCBkaXN0cmlidXRpb24pIHtcblx0aWYgKGRpc3RyaWJ1dGlvbiA9PT0gJ2xpbmVhcicgfHwgIXRpbWVzdGFtcHMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdHt0aW1lOiBtaW4sIHBvczogMH0sXG5cdFx0XHR7dGltZTogbWF4LCBwb3M6IDF9XG5cdFx0XTtcblx0fVxuXG5cdHZhciB0YWJsZSA9IFtdO1xuXHR2YXIgaXRlbXMgPSBbbWluXTtcblx0dmFyIGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0Y3VyciA9IHRpbWVzdGFtcHNbaV07XG5cdFx0aWYgKGN1cnIgPiBtaW4gJiYgY3VyciA8IG1heCkge1xuXHRcdFx0aXRlbXMucHVzaChjdXJyKTtcblx0XHR9XG5cdH1cblxuXHRpdGVtcy5wdXNoKG1heCk7XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdG5leHQgPSBpdGVtc1tpICsgMV07XG5cdFx0cHJldiA9IGl0ZW1zW2kgLSAxXTtcblx0XHRjdXJyID0gaXRlbXNbaV07XG5cblx0XHQvLyBvbmx5IGFkZCBwb2ludHMgdGhhdCBicmVha3MgdGhlIHNjYWxlIGxpbmVhcml0eVxuXHRcdGlmIChwcmV2ID09PSB1bmRlZmluZWQgfHwgbmV4dCA9PT0gdW5kZWZpbmVkIHx8IE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG5cdFx0XHR0YWJsZS5wdXNoKHt0aW1lOiBjdXJyLCBwb3M6IGkgLyAoaWxlbiAtIDEpfSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRhYmxlO1xufVxuXG4vLyBAc2VlIGFkYXB0ZWQgZnJvbSBodHRwczovL3d3dy5hbnVqZ2FraGFyLmNvbS8yMDE0LzAzLzAxL2JpbmFyeS1zZWFyY2gtaW4tamF2YXNjcmlwdC9cbmZ1bmN0aW9uIGxvb2t1cCh0YWJsZSwga2V5LCB2YWx1ZSkge1xuXHR2YXIgbG8gPSAwO1xuXHR2YXIgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuXHR2YXIgbWlkLCBpMCwgaTE7XG5cblx0d2hpbGUgKGxvID49IDAgJiYgbG8gPD0gaGkpIHtcblx0XHRtaWQgPSAobG8gKyBoaSkgPj4gMTtcblx0XHRpMCA9IHRhYmxlW21pZCAtIDFdIHx8IG51bGw7XG5cdFx0aTEgPSB0YWJsZVttaWRdO1xuXG5cdFx0aWYgKCFpMCkge1xuXHRcdFx0Ly8gZ2l2ZW4gdmFsdWUgaXMgb3V0c2lkZSB0YWJsZSAoYmVmb3JlIGZpcnN0IGl0ZW0pXG5cdFx0XHRyZXR1cm4ge2xvOiBudWxsLCBoaTogaTF9O1xuXHRcdH0gZWxzZSBpZiAoaTFba2V5XSA8IHZhbHVlKSB7XG5cdFx0XHRsbyA9IG1pZCArIDE7XG5cdFx0fSBlbHNlIGlmIChpMFtrZXldID4gdmFsdWUpIHtcblx0XHRcdGhpID0gbWlkIC0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHtsbzogaTAsIGhpOiBpMX07XG5cdFx0fVxuXHR9XG5cblx0Ly8gZ2l2ZW4gdmFsdWUgaXMgb3V0c2lkZSB0YWJsZSAoYWZ0ZXIgbGFzdCBpdGVtKVxuXHRyZXR1cm4ge2xvOiBpMSwgaGk6IG51bGx9O1xufVxuXG4vKipcbiAqIExpbmVhcmx5IGludGVycG9sYXRlcyB0aGUgZ2l2ZW4gc291cmNlIGB2YWx1ZWAgdXNpbmcgdGhlIHRhYmxlIGl0ZW1zIGBza2V5YCB2YWx1ZXMgYW5kXG4gKiByZXR1cm5zIHRoZSBhc3NvY2lhdGVkIGB0a2V5YCB2YWx1ZS4gRm9yIGV4YW1wbGUsIGludGVycG9sYXRlKHRhYmxlLCAndGltZScsIDQyLCAncG9zJylcbiAqIHJldHVybnMgdGhlIHBvc2l0aW9uIGZvciBhIHRpbWVzdGFtcCBlcXVhbCB0byA0Mi4gSWYgdmFsdWUgaXMgb3V0IG9mIGJvdW5kcywgdmFsdWVzIGF0XG4gKiBpbmRleCBbMCwgMV0gb3IgW24gLSAxLCBuXSBhcmUgdXNlZCBmb3IgdGhlIGludGVycG9sYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlJDEodGFibGUsIHNrZXksIHN2YWwsIHRrZXkpIHtcblx0dmFyIHJhbmdlID0gbG9va3VwKHRhYmxlLCBza2V5LCBzdmFsKTtcblxuXHQvLyBOb3RlOiB0aGUgbG9va3VwIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCAyIGl0ZW1zIChtaW4gYW5kIG1heClcblx0dmFyIHByZXYgPSAhcmFuZ2UubG8gPyB0YWJsZVswXSA6ICFyYW5nZS5oaSA/IHRhYmxlW3RhYmxlLmxlbmd0aCAtIDJdIDogcmFuZ2UubG87XG5cdHZhciBuZXh0ID0gIXJhbmdlLmxvID8gdGFibGVbMV0gOiAhcmFuZ2UuaGkgPyB0YWJsZVt0YWJsZS5sZW5ndGggLSAxXSA6IHJhbmdlLmhpO1xuXG5cdHZhciBzcGFuID0gbmV4dFtza2V5XSAtIHByZXZbc2tleV07XG5cdHZhciByYXRpbyA9IHNwYW4gPyAoc3ZhbCAtIHByZXZbc2tleV0pIC8gc3BhbiA6IDA7XG5cdHZhciBvZmZzZXQgPSAobmV4dFt0a2V5XSAtIHByZXZbdGtleV0pICogcmF0aW87XG5cblx0cmV0dXJuIHByZXZbdGtleV0gKyBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIHRvVGltZXN0YW1wKHNjYWxlLCBpbnB1dCkge1xuXHR2YXIgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuXHR2YXIgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnMudGltZTtcblx0dmFyIHBhcnNlciA9IG9wdGlvbnMucGFyc2VyO1xuXHR2YXIgZm9ybWF0ID0gcGFyc2VyIHx8IG9wdGlvbnMuZm9ybWF0O1xuXHR2YXIgdmFsdWUgPSBpbnB1dDtcblxuXHRpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcblx0fVxuXG5cdC8vIE9ubHkgcGFyc2UgaWYgaXRzIG5vdCBhIHRpbWVzdGFtcCBhbHJlYWR5XG5cdGlmICghaGVscGVycyQxLmlzRmluaXRlKHZhbHVlKSkge1xuXHRcdHZhbHVlID0gdHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZydcblx0XHRcdD8gYWRhcHRlci5wYXJzZSh2YWx1ZSwgZm9ybWF0KVxuXHRcdFx0OiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcblx0fVxuXG5cdGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuXHRcdHJldHVybiArdmFsdWU7XG5cdH1cblxuXHQvLyBMYWJlbHMgYXJlIGluIGFuIGluY29tcGF0aWJsZSBmb3JtYXQgYW5kIG5vIGBwYXJzZXJgIGhhcyBiZWVuIHByb3ZpZGVkLlxuXHQvLyBUaGUgdXNlciBtaWdodCBzdGlsbCB1c2UgdGhlIGRlcHJlY2F0ZWQgYGZvcm1hdGAgb3B0aW9uIGZvciBwYXJzaW5nLlxuXHRpZiAoIXBhcnNlciAmJiB0eXBlb2YgZm9ybWF0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFsdWUgPSBmb3JtYXQoaW5wdXQpO1xuXG5cdFx0Ly8gYGZvcm1hdGAgY291bGQgcmV0dXJuIHNvbWV0aGluZyBlbHNlIHRoYW4gYSB0aW1lc3RhbXAsIGlmIHNvLCBwYXJzZSBpdFxuXHRcdGlmICghaGVscGVycyQxLmlzRmluaXRlKHZhbHVlKSkge1xuXHRcdFx0dmFsdWUgPSBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHNjYWxlLCBpbnB1dCkge1xuXHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoaW5wdXQpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnMudGltZTtcblx0dmFyIHZhbHVlID0gdG9UaW1lc3RhbXAoc2NhbGUsIHNjYWxlLmdldFJpZ2h0VmFsdWUoaW5wdXQpKTtcblx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0aWYgKG9wdGlvbnMucm91bmQpIHtcblx0XHR2YWx1ZSA9ICtzY2FsZS5fYWRhcHRlci5zdGFydE9mKHZhbHVlLCBvcHRpb25zLnJvdW5kKTtcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBGaWd1cmVzIG91dCB3aGF0IHVuaXQgcmVzdWx0cyBpbiBhbiBhcHByb3ByaWF0ZSBudW1iZXIgb2YgYXV0by1nZW5lcmF0ZWQgdGlja3NcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcblx0dmFyIGlsZW4gPSBVTklUUy5sZW5ndGg7XG5cdHZhciBpLCBpbnRlcnZhbCwgZmFjdG9yO1xuXG5cdGZvciAoaSA9IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGkgPCBpbGVuIC0gMTsgKytpKSB7XG5cdFx0aW50ZXJ2YWwgPSBJTlRFUlZBTFNbVU5JVFNbaV1dO1xuXHRcdGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHMgOiBNQVhfSU5URUdFUjtcblxuXHRcdGlmIChpbnRlcnZhbC5jb21tb24gJiYgTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKGZhY3RvciAqIGludGVydmFsLnNpemUpKSA8PSBjYXBhY2l0eSkge1xuXHRcdFx0cmV0dXJuIFVOSVRTW2ldO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBVTklUU1tpbGVuIC0gMV07XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHRvIGZvcm1hdCBhIHNldCBvZiB0aWNrcyB3aXRoXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHNjYWxlLCBudW1UaWNrcywgbWluVW5pdCwgbWluLCBtYXgpIHtcblx0dmFyIGksIHVuaXQ7XG5cblx0Zm9yIChpID0gVU5JVFMubGVuZ3RoIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pIHtcblx0XHR1bml0ID0gVU5JVFNbaV07XG5cdFx0aWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gbnVtVGlja3MgLSAxKSB7XG5cdFx0XHRyZXR1cm4gdW5pdDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gVU5JVFNbbWluVW5pdCA/IFVOSVRTLmluZGV4T2YobWluVW5pdCkgOiAwXTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcblx0Zm9yICh2YXIgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0aWYgKElOVEVSVkFMU1tVTklUU1tpXV0uY29tbW9uKSB7XG5cdFx0XHRyZXR1cm4gVU5JVFNbaV07XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbWF4aW11bSBvZiBgY2FwYWNpdHlgIHRpbWVzdGFtcHMgYmV0d2VlbiBtaW4gYW5kIG1heCwgcm91bmRlZCB0byB0aGVcbiAqIGBtaW5vcmAgdW5pdCB1c2luZyB0aGUgZ2l2ZW4gc2NhbGUgdGltZSBgb3B0aW9uc2AuXG4gKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG4gKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGluZyBjb2RlIHRvIGNsYW1wIHZhbHVlcyBpZiBuZWVkZWQuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlKHNjYWxlLCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcblx0dmFyIGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xuXHR2YXIgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG5cdHZhciBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpO1xuXHR2YXIgc3RlcFNpemUgPSByZXNvbHZlJDUoW3RpbWVPcHRzLnN0ZXBTaXplLCB0aW1lT3B0cy51bml0U3RlcFNpemUsIDFdKTtcblx0dmFyIHdlZWtkYXkgPSBtaW5vciA9PT0gJ3dlZWsnID8gdGltZU9wdHMuaXNvV2Vla2RheSA6IGZhbHNlO1xuXHR2YXIgZmlyc3QgPSBtaW47XG5cdHZhciB0aWNrcyA9IFtdO1xuXHR2YXIgdGltZTtcblxuXHQvLyBGb3IgJ3dlZWsnIHVuaXQsIGhhbmRsZSB0aGUgZmlyc3QgZGF5IG9mIHdlZWsgb3B0aW9uXG5cdGlmICh3ZWVrZGF5KSB7XG5cdFx0Zmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xuXHR9XG5cblx0Ly8gQWxpZ24gZmlyc3QgdGlja3Mgb24gdW5pdFxuXHRmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsIHdlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcblxuXHQvLyBQcmV2ZW50IGJyb3dzZXIgZnJvbSBmcmVlemluZyBpbiBjYXNlIHVzZXIgb3B0aW9ucyByZXF1ZXN0IG1pbGxpb25zIG9mIG1pbGxpc2Vjb25kc1xuXHRpZiAoYWRhcHRlci5kaWZmKG1heCwgbWluLCBtaW5vcikgPiAxMDAwMDAgKiBzdGVwU2l6ZSkge1xuXHRcdHRocm93IG1pbiArICcgYW5kICcgKyBtYXggKyAnIGFyZSB0b28gZmFyIGFwYXJ0IHdpdGggc3RlcFNpemUgb2YgJyArIHN0ZXBTaXplICsgJyAnICsgbWlub3I7XG5cdH1cblxuXHRmb3IgKHRpbWUgPSBmaXJzdDsgdGltZSA8IG1heDsgdGltZSA9ICthZGFwdGVyLmFkZCh0aW1lLCBzdGVwU2l6ZSwgbWlub3IpKSB7XG5cdFx0dGlja3MucHVzaCh0aW1lKTtcblx0fVxuXG5cdGlmICh0aW1lID09PSBtYXggfHwgb3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycpIHtcblx0XHR0aWNrcy5wdXNoKHRpbWUpO1xuXHR9XG5cblx0cmV0dXJuIHRpY2tzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cyBmcm9tIGVkZ2VzIGluIHRoZSBmb3JtIG9mIHtzdGFydCwgZW5kfVxuICogd2hlcmUgZWFjaCB2YWx1ZSBpcyBhIHJlbGF0aXZlIHdpZHRoIHRvIHRoZSBzY2FsZSBhbmQgcmFuZ2VzIGJldHdlZW4gMCBhbmQgMS5cbiAqIFRoZXkgYWRkIGV4dHJhIG1hcmdpbnMgb24gdGhlIGJvdGggc2lkZXMgYnkgc2NhbGluZyBkb3duIHRoZSBvcmlnaW5hbCBzY2FsZS5cbiAqIE9mZnNldHMgYXJlIGFkZGVkIHdoZW4gdGhlIGBvZmZzZXRgIG9wdGlvbiBpcyB0cnVlLlxuICovXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyh0YWJsZSwgdGlja3MsIG1pbiwgbWF4LCBvcHRpb25zKSB7XG5cdHZhciBzdGFydCA9IDA7XG5cdHZhciBlbmQgPSAwO1xuXHR2YXIgZmlyc3QsIGxhc3Q7XG5cblx0aWYgKG9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xuXHRcdGZpcnN0ID0gaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1swXSwgJ3BvcycpO1xuXHRcdGlmICh0aWNrcy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHN0YXJ0ID0gMSAtIGZpcnN0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdGFydCA9IChpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzWzFdLCAncG9zJykgLSBmaXJzdCkgLyAyO1xuXHRcdH1cblx0XHRsYXN0ID0gaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSwgJ3BvcycpO1xuXHRcdGlmICh0aWNrcy5sZW5ndGggPT09IDEpIHtcblx0XHRcdGVuZCA9IGxhc3Q7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVuZCA9IChsYXN0IC0gaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1t0aWNrcy5sZW5ndGggLSAyXSwgJ3BvcycpKSAvIDI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHtzdGFydDogc3RhcnQsIGVuZDogZW5kLCBmYWN0b3I6IDEgLyAoc3RhcnQgKyAxICsgZW5kKX07XG59XG5cbmZ1bmN0aW9uIHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCkge1xuXHR2YXIgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuXHR2YXIgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKHRpY2tzWzBdLnZhbHVlLCBtYWpvclVuaXQpO1xuXHR2YXIgbGFzdCA9IHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlO1xuXHR2YXIgbWFqb3IsIGluZGV4O1xuXG5cdGZvciAobWFqb3IgPSBmaXJzdDsgbWFqb3IgPD0gbGFzdDsgbWFqb3IgPSArYWRhcHRlci5hZGQobWFqb3IsIDEsIG1ham9yVW5pdCkpIHtcblx0XHRpbmRleCA9IG1hcFttYWpvcl07XG5cdFx0aWYgKGluZGV4ID49IDApIHtcblx0XHRcdHRpY2tzW2luZGV4XS5tYWpvciA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0aWNrcztcbn1cblxuZnVuY3Rpb24gdGlja3NGcm9tVGltZXN0YW1wcyhzY2FsZSwgdmFsdWVzLCBtYWpvclVuaXQpIHtcblx0dmFyIHRpY2tzID0gW107XG5cdHZhciBtYXAgPSB7fTtcblx0dmFyIGlsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuXHR2YXIgaSwgdmFsdWU7XG5cblx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuXHRcdHZhbHVlID0gdmFsdWVzW2ldO1xuXHRcdG1hcFt2YWx1ZV0gPSBpO1xuXG5cdFx0dGlja3MucHVzaCh7XG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRtYWpvcjogZmFsc2Vcblx0XHR9KTtcblx0fVxuXG5cdC8vIFdlIHNldCB0aGUgbWFqb3IgdGlja3Mgc2VwYXJhdGVseSBmcm9tIHRoZSBhYm92ZSBsb29wIGJlY2F1c2UgY2FsbGluZyBzdGFydE9mIGZvciBldmVyeSB0aWNrXG5cdC8vIGlzIGV4cGVuc2l2ZSB3aGVuIHRoZXJlIGlzIGEgbGFyZ2UgbnVtYmVyIG9mIHRpY2tzXG5cdHJldHVybiAoaWxlbiA9PT0gMCB8fCAhbWFqb3JVbml0KSA/IHRpY2tzIDogc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KTtcbn1cblxudmFyIGRlZmF1bHRDb25maWckNCA9IHtcblx0cG9zaXRpb246ICdib3R0b20nLFxuXG5cdC8qKlxuXHQgKiBEYXRhIGRpc3RyaWJ1dGlvbiBhbG9uZyB0aGUgc2NhbGU6XG5cdCAqIC0gJ2xpbmVhcic6IGRhdGEgYXJlIHNwcmVhZCBhY2NvcmRpbmcgdG8gdGhlaXIgdGltZSAoZGlzdGFuY2VzIGNhbiB2YXJ5KSxcblx0ICogLSAnc2VyaWVzJzogZGF0YSBhcmUgc3ByZWFkIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlci5cblx0ICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1MDdcblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRkaXN0cmlidXRpb246ICdsaW5lYXInLFxuXG5cdC8qKlxuXHQgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXG5cdCAqIC0gYGRhdGFgOiBtYWtlIHN1cmUgZGF0YSBhcmUgZnVsbHkgdmlzaWJsZSwgdGlja3Mgb3V0c2lkZSBhcmUgcmVtb3ZlZFxuXHQgKiAtIGB0aWNrc2A6IG1ha2Ugc3VyZSB0aWNrcyBhcmUgZnVsbHkgdmlzaWJsZSwgZGF0YSBvdXRzaWRlIGFyZSB0cnVuY2F0ZWRcblx0ICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRib3VuZHM6ICdkYXRhJyxcblxuXHRhZGFwdGVyczoge30sXG5cdHRpbWU6IHtcblx0XHRwYXJzZXI6IGZhbHNlLCAvLyBmYWxzZSA9PSBhIHBhdHRlcm4gc3RyaW5nIGZyb20gaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL3BhcnNpbmcvc3RyaW5nLWZvcm1hdC8gb3IgYSBjdXN0b20gY2FsbGJhY2sgdGhhdCBjb252ZXJ0cyBpdHMgYXJndW1lbnQgdG8gYSBtb21lbnRcblx0XHR1bml0OiBmYWxzZSwgLy8gZmFsc2UgPT0gYXV0b21hdGljIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cblx0XHRyb3VuZDogZmFsc2UsIC8vIG5vbmUsIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cblx0XHRkaXNwbGF5Rm9ybWF0OiBmYWxzZSwgLy8gREVQUkVDQVRFRFxuXHRcdGlzb1dlZWtkYXk6IGZhbHNlLCAvLyBvdmVycmlkZSB3ZWVrIHN0YXJ0IGRheSAtIHNlZSBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvZ2V0LXNldC9pc28td2Vla2RheS9cblx0XHRtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxuXHRcdGRpc3BsYXlGb3JtYXRzOiB7fVxuXHR9LFxuXHR0aWNrczoge1xuXHRcdGF1dG9Ta2lwOiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCAqIFRpY2tzIGdlbmVyYXRpb24gaW5wdXQgdmFsdWVzOlxuXHRcdCAqIC0gJ2F1dG8nOiBnZW5lcmF0ZXMgXCJvcHRpbWFsXCIgdGlja3MgYmFzZWQgb24gc2NhbGUgc2l6ZSBhbmQgdGltZSBvcHRpb25zLlxuXHRcdCAqIC0gJ2RhdGEnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSBkYXRhIChpbmNsdWRpbmcgbGFiZWxzIGZyb20gZGF0YSB7dHx4fHl9IG9iamVjdHMpLlxuXHRcdCAqIC0gJ2xhYmVscyc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIHVzZXIgZ2l2ZW4gYGRhdGEubGFiZWxzYCB2YWx1ZXMgT05MWS5cblx0XHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xuXHRcdCAqIEBzaW5jZSAyLjcuMFxuXHRcdCAqL1xuXHRcdHNvdXJjZTogJ2F1dG8nLFxuXG5cdFx0bWFqb3I6IHtcblx0XHRcdGVuYWJsZWQ6IGZhbHNlXG5cdFx0fVxuXHR9XG59O1xuXG52YXIgc2NhbGVfdGltZSA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5tZXJnZVRpY2tzT3B0aW9ucygpO1xuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzKTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0aW1lID0gb3B0aW9ucy50aW1lIHx8IChvcHRpb25zLnRpbWUgPSB7fSk7XG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlciA9IG5ldyBjb3JlX2FkYXB0ZXJzLl9kYXRlKG9wdGlvbnMuYWRhcHRlcnMuZGF0ZSk7XG5cblx0XHQvLyBERVBSRUNBVElPTlM6IG91dHB1dCBhIG1lc3NhZ2Ugb25seSBvbmUgdGltZSBwZXIgdXBkYXRlXG5cdFx0ZGVwcmVjYXRlZCQxKCd0aW1lIHNjYWxlJywgdGltZS5mb3JtYXQsICd0aW1lLmZvcm1hdCcsICd0aW1lLnBhcnNlcicpO1xuXHRcdGRlcHJlY2F0ZWQkMSgndGltZSBzY2FsZScsIHRpbWUubWluLCAndGltZS5taW4nLCAndGlja3MubWluJyk7XG5cdFx0ZGVwcmVjYXRlZCQxKCd0aW1lIHNjYWxlJywgdGltZS5tYXgsICd0aW1lLm1heCcsICd0aWNrcy5tYXgnKTtcblxuXHRcdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGJlZm9yZSBpbnRyb2R1Y2luZyBhZGFwdGVyLCBgZGlzcGxheUZvcm1hdHNgIHdhc1xuXHRcdC8vIHN1cHBvc2VkIHRvIGNvbnRhaW4gKmFsbCogdW5pdC9zdHJpbmcgcGFpcnMgYnV0IHRoaXMgY2FuJ3QgYmUgcmVzb2x2ZWRcblx0XHQvLyB3aGVuIGxvYWRpbmcgdGhlIHNjYWxlIChhZGFwdGVycyBhcmUgbG9hZGVkIGFmdGVyd2FyZCksIHNvIGxldCdzIHBvcHVsYXRlXG5cdFx0Ly8gbWlzc2luZyBmb3JtYXRzIG9uIHVwZGF0ZVxuXHRcdGhlbHBlcnMkMS5tZXJnZUlmKHRpbWUuZGlzcGxheUZvcm1hdHMsIGFkYXB0ZXIuZm9ybWF0cygpKTtcblxuXHRcdHJldHVybiBjb3JlX3NjYWxlLnByb3RvdHlwZS51cGRhdGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFsbG93cyBkYXRhIHRvIGJlIHJlZmVyZW5jZWQgdmlhICd0JyBhdHRyaWJ1dGVcblx0ICovXG5cdGdldFJpZ2h0VmFsdWU6IGZ1bmN0aW9uKHJhd1ZhbHVlKSB7XG5cdFx0aWYgKHJhd1ZhbHVlICYmIHJhd1ZhbHVlLnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmF3VmFsdWUgPSByYXdWYWx1ZS50O1xuXHRcdH1cblx0XHRyZXR1cm4gY29yZV9zY2FsZS5wcm90b3R5cGUuZ2V0UmlnaHRWYWx1ZS5jYWxsKHRoaXMsIHJhd1ZhbHVlKTtcblx0fSxcblxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBhZGFwdGVyID0gbWUuX2FkYXB0ZXI7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB1bml0ID0gb3B0aW9ucy50aW1lLnVuaXQgfHwgJ2RheSc7XG5cdFx0dmFyIG1pbiA9IE1BWF9JTlRFR0VSO1xuXHRcdHZhciBtYXggPSBNSU5fSU5URUdFUjtcblx0XHR2YXIgdGltZXN0YW1wcyA9IFtdO1xuXHRcdHZhciBkYXRhc2V0cyA9IFtdO1xuXHRcdHZhciBsYWJlbHMgPSBbXTtcblx0XHR2YXIgaSwgaiwgaWxlbiwgamxlbiwgZGF0YSwgdGltZXN0YW1wLCBsYWJlbHNBZGRlZDtcblx0XHR2YXIgZGF0YUxhYmVscyA9IG1lLl9nZXRMYWJlbHMoKTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhTGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bGFiZWxzLnB1c2gocGFyc2UobWUsIGRhdGFMYWJlbHNbaV0pKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0ZGF0YSA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbaV0uZGF0YTtcblxuXHRcdFx0XHQvLyBMZXQncyBjb25zaWRlciB0aGF0IGFsbCBkYXRhIGhhdmUgdGhlIHNhbWUgZm9ybWF0LlxuXHRcdFx0XHRpZiAoaGVscGVycyQxLmlzT2JqZWN0KGRhdGFbMF0pKSB7XG5cdFx0XHRcdFx0ZGF0YXNldHNbaV0gPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoaiA9IDAsIGpsZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuXHRcdFx0XHRcdFx0dGltZXN0YW1wID0gcGFyc2UobWUsIGRhdGFbal0pO1xuXHRcdFx0XHRcdFx0dGltZXN0YW1wcy5wdXNoKHRpbWVzdGFtcCk7XG5cdFx0XHRcdFx0XHRkYXRhc2V0c1tpXVtqXSA9IHRpbWVzdGFtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YXNldHNbaV0gPSBsYWJlbHMuc2xpY2UoMCk7XG5cdFx0XHRcdFx0aWYgKCFsYWJlbHNBZGRlZCkge1xuXHRcdFx0XHRcdFx0dGltZXN0YW1wcyA9IHRpbWVzdGFtcHMuY29uY2F0KGxhYmVscyk7XG5cdFx0XHRcdFx0XHRsYWJlbHNBZGRlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhc2V0c1tpXSA9IFtdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChsYWJlbHMubGVuZ3RoKSB7XG5cdFx0XHRtaW4gPSBNYXRoLm1pbihtaW4sIGxhYmVsc1swXSk7XG5cdFx0XHRtYXggPSBNYXRoLm1heChtYXgsIGxhYmVsc1tsYWJlbHMubGVuZ3RoIC0gMV0pO1xuXHRcdH1cblxuXHRcdGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuXHRcdFx0dGltZXN0YW1wcyA9IGlsZW4gPiAxID8gYXJyYXlVbmlxdWUodGltZXN0YW1wcykuc29ydChzb3J0ZXIpIDogdGltZXN0YW1wcy5zb3J0KHNvcnRlcik7XG5cdFx0XHRtaW4gPSBNYXRoLm1pbihtaW4sIHRpbWVzdGFtcHNbMF0pO1xuXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuXHRcdH1cblxuXHRcdG1pbiA9IHBhcnNlKG1lLCBnZXRNaW4ob3B0aW9ucykpIHx8IG1pbjtcblx0XHRtYXggPSBwYXJzZShtZSwgZ2V0TWF4KG9wdGlvbnMpKSB8fCBtYXg7XG5cblx0XHQvLyBJbiBjYXNlIHRoZXJlIGlzIG5vIHZhbGlkIG1pbi9tYXgsIHNldCBsaW1pdHMgYmFzZWQgb24gdW5pdCB0aW1lIG9wdGlvblxuXHRcdG1pbiA9IG1pbiA9PT0gTUFYX0lOVEVHRVIgPyArYWRhcHRlci5zdGFydE9mKERhdGUubm93KCksIHVuaXQpIDogbWluO1xuXHRcdG1heCA9IG1heCA9PT0gTUlOX0lOVEVHRVIgPyArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDEgOiBtYXg7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBtYXggaXMgc3RyaWN0bHkgaGlnaGVyIHRoYW4gbWluIChyZXF1aXJlZCBieSB0aGUgbG9va3VwIHRhYmxlKVxuXHRcdG1lLm1pbiA9IE1hdGgubWluKG1pbiwgbWF4KTtcblx0XHRtZS5tYXggPSBNYXRoLm1heChtaW4gKyAxLCBtYXgpO1xuXG5cdFx0Ly8gUFJJVkFURVxuXHRcdG1lLl90YWJsZSA9IFtdO1xuXHRcdG1lLl90aW1lc3RhbXBzID0ge1xuXHRcdFx0ZGF0YTogdGltZXN0YW1wcyxcblx0XHRcdGRhdGFzZXRzOiBkYXRhc2V0cyxcblx0XHRcdGxhYmVsczogbGFiZWxzXG5cdFx0fTtcblx0fSxcblxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtaW4gPSBtZS5taW47XG5cdFx0dmFyIG1heCA9IG1lLm1heDtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcblx0XHR2YXIgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG5cdFx0dmFyIHRpbWVzdGFtcHMgPSBtZS5fdGltZXN0YW1wcztcblx0XHR2YXIgdGlja3MgPSBbXTtcblx0XHR2YXIgY2FwYWNpdHkgPSBtZS5nZXRMYWJlbENhcGFjaXR5KG1pbik7XG5cdFx0dmFyIHNvdXJjZSA9IHRpY2tPcHRzLnNvdXJjZTtcblx0XHR2YXIgZGlzdHJpYnV0aW9uID0gb3B0aW9ucy5kaXN0cmlidXRpb247XG5cdFx0dmFyIGksIGlsZW4sIHRpbWVzdGFtcDtcblxuXHRcdGlmIChzb3VyY2UgPT09ICdkYXRhJyB8fCAoc291cmNlID09PSAnYXV0bycgJiYgZGlzdHJpYnV0aW9uID09PSAnc2VyaWVzJykpIHtcblx0XHRcdHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmRhdGE7XG5cdFx0fSBlbHNlIGlmIChzb3VyY2UgPT09ICdsYWJlbHMnKSB7XG5cdFx0XHR0aW1lc3RhbXBzID0gdGltZXN0YW1wcy5sYWJlbHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRpbWVzdGFtcHMgPSBnZW5lcmF0ZShtZSwgbWluLCBtYXgsIGNhcGFjaXR5KTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcblx0XHRcdG1pbiA9IHRpbWVzdGFtcHNbMF07XG5cdFx0XHRtYXggPSB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG5cdFx0fVxuXG5cdFx0Ly8gRW5mb3JjZSBsaW1pdHMgd2l0aCB1c2VyIG1pbi9tYXggb3B0aW9uc1xuXHRcdG1pbiA9IHBhcnNlKG1lLCBnZXRNaW4ob3B0aW9ucykpIHx8IG1pbjtcblx0XHRtYXggPSBwYXJzZShtZSwgZ2V0TWF4KG9wdGlvbnMpKSB8fCBtYXg7XG5cblx0XHQvLyBSZW1vdmUgdGlja3Mgb3V0c2lkZSB0aGUgbWluL21heCByYW5nZVxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0dGltZXN0YW1wID0gdGltZXN0YW1wc1tpXTtcblx0XHRcdGlmICh0aW1lc3RhbXAgPj0gbWluICYmIHRpbWVzdGFtcCA8PSBtYXgpIHtcblx0XHRcdFx0dGlja3MucHVzaCh0aW1lc3RhbXApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lLm1pbiA9IG1pbjtcblx0XHRtZS5tYXggPSBtYXg7XG5cblx0XHQvLyBQUklWQVRFXG5cdFx0Ly8gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcgcmVsaWVzIG9uIHRoZSBudW1iZXIgb2YgdGlja3Mgc28gd2UgZG9uJ3QgdXNlIGl0IHdoZW5cblx0XHQvLyBhdXRvU2tpcCBpcyBlbmFibGVkIGJlY2F1c2Ugd2UgZG9uJ3QgeWV0IGtub3cgd2hhdCB0aGUgZmluYWwgbnVtYmVyIG9mIHRpY2tzIHdpbGwgYmVcblx0XHRtZS5fdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgKHRpY2tPcHRzLmF1dG9Ta2lwXG5cdFx0XHQ/IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgbWUubWluLCBtZS5tYXgsIGNhcGFjaXR5KVxuXHRcdFx0OiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhtZSwgdGlja3MubGVuZ3RoLCB0aW1lT3B0cy5taW5Vbml0LCBtZS5taW4sIG1lLm1heCkpO1xuXHRcdG1lLl9tYWpvclVuaXQgPSAhdGlja09wdHMubWFqb3IuZW5hYmxlZCB8fCBtZS5fdW5pdCA9PT0gJ3llYXInID8gdW5kZWZpbmVkXG5cdFx0XHQ6IGRldGVybWluZU1ham9yVW5pdChtZS5fdW5pdCk7XG5cdFx0bWUuX3RhYmxlID0gYnVpbGRMb29rdXBUYWJsZShtZS5fdGltZXN0YW1wcy5kYXRhLCBtaW4sIG1heCwgZGlzdHJpYnV0aW9uKTtcblx0XHRtZS5fb2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKG1lLl90YWJsZSwgdGlja3MsIG1pbiwgbWF4LCBvcHRpb25zKTtcblxuXHRcdGlmICh0aWNrT3B0cy5yZXZlcnNlKSB7XG5cdFx0XHR0aWNrcy5yZXZlcnNlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHMobWUsIHRpY2tzLCBtZS5fbWFqb3JVbml0KTtcblx0fSxcblxuXHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgYWRhcHRlciA9IG1lLl9hZGFwdGVyO1xuXHRcdHZhciBkYXRhID0gbWUuY2hhcnQuZGF0YTtcblx0XHR2YXIgdGltZU9wdHMgPSBtZS5vcHRpb25zLnRpbWU7XG5cdFx0dmFyIGxhYmVsID0gZGF0YS5sYWJlbHMgJiYgaW5kZXggPCBkYXRhLmxhYmVscy5sZW5ndGggPyBkYXRhLmxhYmVsc1tpbmRleF0gOiAnJztcblx0XHR2YXIgdmFsdWUgPSBkYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF07XG5cblx0XHRpZiAoaGVscGVycyQxLmlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdFx0bGFiZWwgPSBtZS5nZXRSaWdodFZhbHVlKHZhbHVlKTtcblx0XHR9XG5cdFx0aWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcblx0XHRcdHJldHVybiBhZGFwdGVyLmZvcm1hdCh0b1RpbWVzdGFtcChtZSwgbGFiZWwpLCB0aW1lT3B0cy50b29sdGlwRm9ybWF0KTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBsYWJlbDtcblx0XHR9XG5cdFx0cmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHRvVGltZXN0YW1wKG1lLCBsYWJlbCksIHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzLmRhdGV0aW1lKTtcblx0fSxcblxuXHQvKipcblx0ICogRnVuY3Rpb24gdG8gZm9ybWF0IGFuIGluZGl2aWR1YWwgdGljayBtYXJrXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR0aWNrRm9ybWF0RnVuY3Rpb246IGZ1bmN0aW9uKHRpbWUsIGluZGV4LCB0aWNrcywgZm9ybWF0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgYWRhcHRlciA9IG1lLl9hZGFwdGVyO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcblx0XHR2YXIgbWlub3JGb3JtYXQgPSBmb3JtYXRzW21lLl91bml0XTtcblx0XHR2YXIgbWFqb3JVbml0ID0gbWUuX21ham9yVW5pdDtcblx0XHR2YXIgbWFqb3JGb3JtYXQgPSBmb3JtYXRzW21ham9yVW5pdF07XG5cdFx0dmFyIHRpY2sgPSB0aWNrc1tpbmRleF07XG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcblx0XHR2YXIgbWFqb3IgPSBtYWpvclVuaXQgJiYgbWFqb3JGb3JtYXQgJiYgdGljayAmJiB0aWNrLm1ham9yO1xuXHRcdHZhciBsYWJlbCA9IGFkYXB0ZXIuZm9ybWF0KHRpbWUsIGZvcm1hdCA/IGZvcm1hdCA6IG1ham9yID8gbWFqb3JGb3JtYXQgOiBtaW5vckZvcm1hdCk7XG5cdFx0dmFyIG5lc3RlZFRpY2tPcHRzID0gbWFqb3IgPyB0aWNrT3B0cy5tYWpvciA6IHRpY2tPcHRzLm1pbm9yO1xuXHRcdHZhciBmb3JtYXR0ZXIgPSByZXNvbHZlJDUoW1xuXHRcdFx0bmVzdGVkVGlja09wdHMuY2FsbGJhY2ssXG5cdFx0XHRuZXN0ZWRUaWNrT3B0cy51c2VyQ2FsbGJhY2ssXG5cdFx0XHR0aWNrT3B0cy5jYWxsYmFjayxcblx0XHRcdHRpY2tPcHRzLnVzZXJDYWxsYmFja1xuXHRcdF0pO1xuXG5cdFx0cmV0dXJuIGZvcm1hdHRlciA/IGZvcm1hdHRlcihsYWJlbCwgaW5kZXgsIHRpY2tzKSA6IGxhYmVsO1xuXHR9LFxuXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbih0aWNrcykge1xuXHRcdHZhciBsYWJlbHMgPSBbXTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGxhYmVscy5wdXNoKHRoaXMudGlja0Zvcm1hdEZ1bmN0aW9uKHRpY2tzW2ldLnZhbHVlLCBpLCB0aWNrcykpO1xuXHRcdH1cblxuXHRcdHJldHVybiBsYWJlbHM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRQaXhlbEZvck9mZnNldDogZnVuY3Rpb24odGltZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9mZnNldHMgPSBtZS5fb2Zmc2V0cztcblx0XHR2YXIgcG9zID0gaW50ZXJwb2xhdGUkMShtZS5fdGFibGUsICd0aW1lJywgdGltZSwgJ3BvcycpO1xuXHRcdHJldHVybiBtZS5nZXRQaXhlbEZvckRlY2ltYWwoKG9mZnNldHMuc3RhcnQgKyBwb3MpICogb2Zmc2V0cy5mYWN0b3IpO1xuXHR9LFxuXG5cdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGltZSA9IG51bGw7XG5cblx0XHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0SW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGltZSA9IG1lLl90aW1lc3RhbXBzLmRhdGFzZXRzW2RhdGFzZXRJbmRleF1baW5kZXhdO1xuXHRcdH1cblxuXHRcdGlmICh0aW1lID09PSBudWxsKSB7XG5cdFx0XHR0aW1lID0gcGFyc2UobWUsIHZhbHVlKTtcblx0XHR9XG5cblx0XHRpZiAodGltZSAhPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG1lLmdldFBpeGVsRm9yT2Zmc2V0KHRpbWUpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIHRpY2tzID0gdGhpcy5nZXRUaWNrcygpO1xuXHRcdHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoID9cblx0XHRcdHRoaXMuZ2V0UGl4ZWxGb3JPZmZzZXQodGlja3NbaW5kZXhdLnZhbHVlKSA6XG5cdFx0XHRudWxsO1xuXHR9LFxuXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb2Zmc2V0cyA9IG1lLl9vZmZzZXRzO1xuXHRcdHZhciBwb3MgPSBtZS5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcblx0XHR2YXIgdGltZSA9IGludGVycG9sYXRlJDEobWUuX3RhYmxlLCAncG9zJywgcG9zLCAndGltZScpO1xuXG5cdFx0Ly8gREVQUkVDQVRJT04sIHdlIHNob3VsZCByZXR1cm4gdGltZSBkaXJlY3RseVxuXHRcdHJldHVybiBtZS5fYWRhcHRlci5fY3JlYXRlKHRpbWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldExhYmVsU2l6ZTogZnVuY3Rpb24obGFiZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrc09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciB0aWNrTGFiZWxXaWR0aCA9IG1lLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG5cdFx0dmFyIGFuZ2xlID0gaGVscGVycyQxLnRvUmFkaWFucyhtZS5pc0hvcml6b250YWwoKSA/IHRpY2tzT3B0cy5tYXhSb3RhdGlvbiA6IHRpY2tzT3B0cy5taW5Sb3RhdGlvbik7XG5cdFx0dmFyIGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdHZhciBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHR2YXIgdGlja0ZvbnRTaXplID0gdmFsdWVPckRlZmF1bHQkZCh0aWNrc09wdHMuZm9udFNpemUsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250U2l6ZSk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dzogKHRpY2tMYWJlbFdpZHRoICogY29zUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIHNpblJvdGF0aW9uKSxcblx0XHRcdGg6ICh0aWNrTGFiZWxXaWR0aCAqIHNpblJvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBjb3NSb3RhdGlvbilcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcnVkZSBhcHByb3hpbWF0aW9uIG9mIHdoYXQgdGhlIGxhYmVsIHdpZHRoIG1pZ2h0IGJlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRMYWJlbFdpZHRoOiBmdW5jdGlvbihsYWJlbCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRMYWJlbFNpemUobGFiZWwpLnc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRMYWJlbENhcGFjaXR5OiBmdW5jdGlvbihleGFtcGxlVGltZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpbWVPcHRzID0gbWUub3B0aW9ucy50aW1lO1xuXHRcdHZhciBkaXNwbGF5Rm9ybWF0cyA9IHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzO1xuXG5cdFx0Ly8gcGljayB0aGUgbG9uZ2VzdCBmb3JtYXQgKG1pbGxpc2Vjb25kcykgZm9yIGd1ZXN0aW1hdGlvblxuXHRcdHZhciBmb3JtYXQgPSBkaXNwbGF5Rm9ybWF0c1t0aW1lT3B0cy51bml0XSB8fCBkaXNwbGF5Rm9ybWF0cy5taWxsaXNlY29uZDtcblx0XHR2YXIgZXhhbXBsZUxhYmVsID0gbWUudGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCB0aWNrc0Zyb21UaW1lc3RhbXBzKG1lLCBbZXhhbXBsZVRpbWVdLCBtZS5fbWFqb3JVbml0KSwgZm9ybWF0KTtcblx0XHR2YXIgc2l6ZSA9IG1lLl9nZXRMYWJlbFNpemUoZXhhbXBsZUxhYmVsKTtcblx0XHR2YXIgY2FwYWNpdHkgPSBNYXRoLmZsb29yKG1lLmlzSG9yaXpvbnRhbCgpID8gbWUud2lkdGggLyBzaXplLncgOiBtZS5oZWlnaHQgLyBzaXplLmgpO1xuXG5cdFx0aWYgKG1lLm9wdGlvbnMub2Zmc2V0KSB7XG5cdFx0XHRjYXBhY2l0eS0tO1xuXHRcdH1cblxuXHRcdHJldHVybiBjYXBhY2l0eSA+IDAgPyBjYXBhY2l0eSA6IDE7XG5cdH1cbn0pO1xuXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcbnZhciBfZGVmYXVsdHMkNCA9IGRlZmF1bHRDb25maWckNDtcbnNjYWxlX3RpbWUuX2RlZmF1bHRzID0gX2RlZmF1bHRzJDQ7XG5cbnZhciBzY2FsZXMgPSB7XG5cdGNhdGVnb3J5OiBzY2FsZV9jYXRlZ29yeSxcblx0bGluZWFyOiBzY2FsZV9saW5lYXIsXG5cdGxvZ2FyaXRobWljOiBzY2FsZV9sb2dhcml0aG1pYyxcblx0cmFkaWFsTGluZWFyOiBzY2FsZV9yYWRpYWxMaW5lYXIsXG5cdHRpbWU6IHNjYWxlX3RpbWVcbn07XG5cbnZhciBGT1JNQVRTID0ge1xuXHRkYXRldGltZTogJ01NTSBELCBZWVlZLCBoOm1tOnNzIGEnLFxuXHRtaWxsaXNlY29uZDogJ2g6bW06c3MuU1NTIGEnLFxuXHRzZWNvbmQ6ICdoOm1tOnNzIGEnLFxuXHRtaW51dGU6ICdoOm1tIGEnLFxuXHRob3VyOiAnaEEnLFxuXHRkYXk6ICdNTU0gRCcsXG5cdHdlZWs6ICdsbCcsXG5cdG1vbnRoOiAnTU1NIFlZWVknLFxuXHRxdWFydGVyOiAnW1FdUSAtIFlZWVknLFxuXHR5ZWFyOiAnWVlZWSdcbn07XG5cbmNvcmVfYWRhcHRlcnMuX2RhdGUub3ZlcnJpZGUodHlwZW9mIG1vbWVudCA9PT0gJ2Z1bmN0aW9uJyA/IHtcblx0X2lkOiAnbW9tZW50JywgLy8gREVCVUcgT05MWVxuXG5cdGZvcm1hdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBGT1JNQVRTO1xuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0KSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhbHVlID0gbW9tZW50KHZhbHVlLCBmb3JtYXQpO1xuXHRcdH0gZWxzZSBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIG1vbWVudCkpIHtcblx0XHRcdHZhbHVlID0gbW9tZW50KHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlLmlzVmFsaWQoKSA/IHZhbHVlLnZhbHVlT2YoKSA6IG51bGw7XG5cdH0sXG5cblx0Zm9ybWF0OiBmdW5jdGlvbih0aW1lLCBmb3JtYXQpIHtcblx0XHRyZXR1cm4gbW9tZW50KHRpbWUpLmZvcm1hdChmb3JtYXQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24odGltZSwgYW1vdW50LCB1bml0KSB7XG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5hZGQoYW1vdW50LCB1bml0KS52YWx1ZU9mKCk7XG5cdH0sXG5cblx0ZGlmZjogZnVuY3Rpb24obWF4LCBtaW4sIHVuaXQpIHtcblx0XHRyZXR1cm4gbW9tZW50KG1heCkuZGlmZihtb21lbnQobWluKSwgdW5pdCk7XG5cdH0sXG5cblx0c3RhcnRPZjogZnVuY3Rpb24odGltZSwgdW5pdCwgd2Vla2RheSkge1xuXHRcdHRpbWUgPSBtb21lbnQodGltZSk7XG5cdFx0aWYgKHVuaXQgPT09ICdpc29XZWVrJykge1xuXHRcdFx0cmV0dXJuIHRpbWUuaXNvV2Vla2RheSh3ZWVrZGF5KS52YWx1ZU9mKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aW1lLnN0YXJ0T2YodW5pdCkudmFsdWVPZigpO1xuXHR9LFxuXG5cdGVuZE9mOiBmdW5jdGlvbih0aW1lLCB1bml0KSB7XG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5lbmRPZih1bml0KS52YWx1ZU9mKCk7XG5cdH0sXG5cblx0Ly8gREVQUkVDQVRJT05TXG5cblx0LyoqXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggc2NhbGUuZ2V0VmFsdWVGb3JQaXhlbCgpLlxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRyZXR1cm4gbW9tZW50KHRpbWUpO1xuXHR9LFxufSA6IHt9KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHBsdWdpbnM6IHtcblx0XHRmaWxsZXI6IHtcblx0XHRcdHByb3BhZ2F0ZTogdHJ1ZVxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBtYXBwZXJzID0ge1xuXHRkYXRhc2V0OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHR2YXIgaW5kZXggPSBzb3VyY2UuZmlsbDtcblx0XHR2YXIgY2hhcnQgPSBzb3VyY2UuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cdFx0dmFyIHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuXHRcdHZhciBwb2ludHMgPSAodmlzaWJsZSAmJiBtZXRhLmRhdGFzZXQuX2NoaWxkcmVuKSB8fCBbXTtcblx0XHR2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCB8fCAwO1xuXG5cdFx0cmV0dXJuICFsZW5ndGggPyBudWxsIDogZnVuY3Rpb24ocG9pbnQsIGkpIHtcblx0XHRcdHJldHVybiAoaSA8IGxlbmd0aCAmJiBwb2ludHNbaV0uX3ZpZXcpIHx8IG51bGw7XG5cdFx0fTtcblx0fSxcblxuXHRib3VuZGFyeTogZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0dmFyIGJvdW5kYXJ5ID0gc291cmNlLmJvdW5kYXJ5O1xuXHRcdHZhciB4ID0gYm91bmRhcnkgPyBib3VuZGFyeS54IDogbnVsbDtcblx0XHR2YXIgeSA9IGJvdW5kYXJ5ID8gYm91bmRhcnkueSA6IG51bGw7XG5cblx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkoYm91bmRhcnkpKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24ocG9pbnQsIGkpIHtcblx0XHRcdFx0cmV0dXJuIGJvdW5kYXJ5W2ldO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IHggPT09IG51bGwgPyBwb2ludC54IDogeCxcblx0XHRcdFx0eTogeSA9PT0gbnVsbCA/IHBvaW50LnkgOiB5LFxuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG59O1xuXG4vLyBAdG9kbyBpZiAoZmlsbFswXSA9PT0gJyMnKVxuZnVuY3Rpb24gZGVjb2RlRmlsbChlbCwgaW5kZXgsIGNvdW50KSB7XG5cdHZhciBtb2RlbCA9IGVsLl9tb2RlbCB8fCB7fTtcblx0dmFyIGZpbGwgPSBtb2RlbC5maWxsO1xuXHR2YXIgdGFyZ2V0O1xuXG5cdGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcblx0XHRmaWxsID0gISFtb2RlbC5iYWNrZ3JvdW5kQ29sb3I7XG5cdH1cblxuXHRpZiAoZmlsbCA9PT0gZmFsc2UgfHwgZmlsbCA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChmaWxsID09PSB0cnVlKSB7XG5cdFx0cmV0dXJuICdvcmlnaW4nO1xuXHR9XG5cblx0dGFyZ2V0ID0gcGFyc2VGbG9hdChmaWxsLCAxMCk7XG5cdGlmIChpc0Zpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG5cdFx0aWYgKGZpbGxbMF0gPT09ICctJyB8fCBmaWxsWzBdID09PSAnKycpIHtcblx0XHRcdHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuXHRcdH1cblxuXHRcdGlmICh0YXJnZXQgPT09IGluZGV4IHx8IHRhcmdldCA8IDAgfHwgdGFyZ2V0ID49IGNvdW50KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdHN3aXRjaCAoZmlsbCkge1xuXHQvLyBjb21wYXRpYmlsaXR5XG5cdGNhc2UgJ2JvdHRvbSc6XG5cdFx0cmV0dXJuICdzdGFydCc7XG5cdGNhc2UgJ3RvcCc6XG5cdFx0cmV0dXJuICdlbmQnO1xuXHRjYXNlICd6ZXJvJzpcblx0XHRyZXR1cm4gJ29yaWdpbic7XG5cdC8vIHN1cHBvcnRlZCBib3VuZGFyaWVzXG5cdGNhc2UgJ29yaWdpbic6XG5cdGNhc2UgJ3N0YXJ0Jzpcblx0Y2FzZSAnZW5kJzpcblx0XHRyZXR1cm4gZmlsbDtcblx0Ly8gaW52YWxpZCBmaWxsIHZhbHVlc1xuXHRkZWZhdWx0OlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5mdW5jdGlvbiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKSB7XG5cdHZhciBtb2RlbCA9IHNvdXJjZS5lbC5fbW9kZWwgfHwge307XG5cdHZhciBzY2FsZSA9IHNvdXJjZS5lbC5fc2NhbGUgfHwge307XG5cdHZhciBmaWxsID0gc291cmNlLmZpbGw7XG5cdHZhciB0YXJnZXQgPSBudWxsO1xuXHR2YXIgaG9yaXpvbnRhbDtcblxuXHRpZiAoaXNGaW5pdGUoZmlsbCkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHVudGlsIHYzLCB3ZSBzdGlsbCBuZWVkIHRvIHN1cHBvcnQgYm91bmRhcnkgdmFsdWVzIHNldCBvblxuXHQvLyB0aGUgbW9kZWwgKHNjYWxlVG9wLCBzY2FsZUJvdHRvbSBhbmQgc2NhbGVaZXJvKSBiZWNhdXNlIHNvbWUgZXh0ZXJuYWwgcGx1Z2lucyBhbmRcblx0Ly8gY29udHJvbGxlcnMgbWlnaHQgc3RpbGwgdXNlIGl0IChlLmcuIHRoZSBTbWl0aCBjaGFydCkuXG5cblx0aWYgKGZpbGwgPT09ICdzdGFydCcpIHtcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZUJvdHRvbSA9PT0gdW5kZWZpbmVkID8gc2NhbGUuYm90dG9tIDogbW9kZWwuc2NhbGVCb3R0b207XG5cdH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVRvcCA9PT0gdW5kZWZpbmVkID8gc2NhbGUudG9wIDogbW9kZWwuc2NhbGVUb3A7XG5cdH0gZWxzZSBpZiAobW9kZWwuc2NhbGVaZXJvICE9PSB1bmRlZmluZWQpIHtcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVplcm87XG5cdH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG5cdFx0dGFyZ2V0ID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG5cdH1cblxuXHRpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0ICE9PSBudWxsKSB7XG5cdFx0aWYgKHRhcmdldC54ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRpZiAoaGVscGVycyQxLmlzRmluaXRlKHRhcmdldCkpIHtcblx0XHRcdGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IGhvcml6b250YWwgPyB0YXJnZXQgOiBudWxsLFxuXHRcdFx0XHR5OiBob3Jpem9udGFsID8gbnVsbCA6IHRhcmdldFxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKSB7XG5cdHZhciBzY2FsZSA9IHNvdXJjZS5lbC5fc2NhbGU7XG5cdHZhciBvcHRpb25zID0gc2NhbGUub3B0aW9ucztcblx0dmFyIGxlbmd0aCA9IHNjYWxlLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aDtcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0dmFyIHRhcmdldCA9IFtdO1xuXHR2YXIgc3RhcnQsIGVuZCwgY2VudGVyLCBpLCBwb2ludDtcblxuXHRpZiAoIWxlbmd0aCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0c3RhcnQgPSBvcHRpb25zLnRpY2tzLnJldmVyc2UgPyBzY2FsZS5tYXggOiBzY2FsZS5taW47XG5cdGVuZCA9IG9wdGlvbnMudGlja3MucmV2ZXJzZSA/IHNjYWxlLm1pbiA6IHNjYWxlLm1heDtcblx0Y2VudGVyID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsIHN0YXJ0KTtcblx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0cG9pbnQgPSBmaWxsID09PSAnc3RhcnQnIHx8IGZpbGwgPT09ICdlbmQnXG5cdFx0XHQ/IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCBmaWxsID09PSAnc3RhcnQnID8gc3RhcnQgOiBlbmQpXG5cdFx0XHQ6IHNjYWxlLmdldEJhc2VQb3NpdGlvbihpKTtcblx0XHRpZiAob3B0aW9ucy5ncmlkTGluZXMuY2lyY3VsYXIpIHtcblx0XHRcdHBvaW50LmN4ID0gY2VudGVyLng7XG5cdFx0XHRwb2ludC5jeSA9IGNlbnRlci55O1xuXHRcdFx0cG9pbnQuYW5nbGUgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKGkpIC0gTWF0aC5QSSAvIDI7XG5cdFx0fVxuXHRcdHRhcmdldC5wdXNoKHBvaW50KTtcblx0fVxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG5cdHZhciBzY2FsZSA9IHNvdXJjZS5lbC5fc2NhbGUgfHwge307XG5cblx0aWYgKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSkge1xuXHRcdHJldHVybiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpO1xuXHR9XG5cdHJldHVybiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG5cdHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0dmFyIHZpc2l0ZWQgPSBbaW5kZXhdO1xuXHR2YXIgdGFyZ2V0O1xuXG5cdGlmICghcHJvcGFnYXRlKSB7XG5cdFx0cmV0dXJuIGZpbGw7XG5cdH1cblxuXHR3aGlsZSAoZmlsbCAhPT0gZmFsc2UgJiYgdmlzaXRlZC5pbmRleE9mKGZpbGwpID09PSAtMSkge1xuXHRcdGlmICghaXNGaW5pdGUoZmlsbCkpIHtcblx0XHRcdHJldHVybiBmaWxsO1xuXHRcdH1cblxuXHRcdHRhcmdldCA9IHNvdXJjZXNbZmlsbF07XG5cdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAodGFyZ2V0LnZpc2libGUpIHtcblx0XHRcdHJldHVybiBmaWxsO1xuXHRcdH1cblxuXHRcdHZpc2l0ZWQucHVzaChmaWxsKTtcblx0XHRmaWxsID0gdGFyZ2V0LmZpbGw7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcHBlcihzb3VyY2UpIHtcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0dmFyIHR5cGUgPSAnZGF0YXNldCc7XG5cblx0aWYgKGZpbGwgPT09IGZhbHNlKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRpZiAoIWlzRmluaXRlKGZpbGwpKSB7XG5cdFx0dHlwZSA9ICdib3VuZGFyeSc7XG5cdH1cblxuXHRyZXR1cm4gbWFwcGVyc1t0eXBlXShzb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBpc0RyYXdhYmxlKHBvaW50KSB7XG5cdHJldHVybiBwb2ludCAmJiAhcG9pbnQuc2tpcDtcbn1cblxuZnVuY3Rpb24gZHJhd0FyZWEoY3R4LCBjdXJ2ZTAsIGN1cnZlMSwgbGVuMCwgbGVuMSkge1xuXHR2YXIgaSwgY3gsIGN5LCByO1xuXG5cdGlmICghbGVuMCB8fCAhbGVuMSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIGJ1aWxkaW5nIGZpcnN0IGFyZWEgY3VydmUgKG5vcm1hbClcblx0Y3R4Lm1vdmVUbyhjdXJ2ZTBbMF0ueCwgY3VydmUwWzBdLnkpO1xuXHRmb3IgKGkgPSAxOyBpIDwgbGVuMDsgKytpKSB7XG5cdFx0aGVscGVycyQxLmNhbnZhcy5saW5lVG8oY3R4LCBjdXJ2ZTBbaSAtIDFdLCBjdXJ2ZTBbaV0pO1xuXHR9XG5cblx0aWYgKGN1cnZlMVswXS5hbmdsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Y3ggPSBjdXJ2ZTFbMF0uY3g7XG5cdFx0Y3kgPSBjdXJ2ZTFbMF0uY3k7XG5cdFx0ciA9IE1hdGguc3FydChNYXRoLnBvdyhjdXJ2ZTFbMF0ueCAtIGN4LCAyKSArIE1hdGgucG93KGN1cnZlMVswXS55IC0gY3ksIDIpKTtcblx0XHRmb3IgKGkgPSBsZW4xIC0gMTsgaSA+IDA7IC0taSkge1xuXHRcdFx0Y3R4LmFyYyhjeCwgY3ksIHIsIGN1cnZlMVtpXS5hbmdsZSwgY3VydmUxW2kgLSAxXS5hbmdsZSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIGpvaW5pbmcgdGhlIHR3byBhcmVhIGN1cnZlc1xuXHRjdHgubGluZVRvKGN1cnZlMVtsZW4xIC0gMV0ueCwgY3VydmUxW2xlbjEgLSAxXS55KTtcblxuXHQvLyBidWlsZGluZyBvcHBvc2l0ZSBhcmVhIGN1cnZlIChyZXZlcnNlKVxuXHRmb3IgKGkgPSBsZW4xIC0gMTsgaSA+IDA7IC0taSkge1xuXHRcdGhlbHBlcnMkMS5jYW52YXMubGluZVRvKGN0eCwgY3VydmUxW2ldLCBjdXJ2ZTFbaSAtIDFdLCB0cnVlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBwb2ludHMsIG1hcHBlciwgdmlldywgY29sb3IsIGxvb3ApIHtcblx0dmFyIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcblx0dmFyIHNwYW4gPSB2aWV3LnNwYW5HYXBzO1xuXHR2YXIgY3VydmUwID0gW107XG5cdHZhciBjdXJ2ZTEgPSBbXTtcblx0dmFyIGxlbjAgPSAwO1xuXHR2YXIgbGVuMSA9IDA7XG5cdHZhciBpLCBpbGVuLCBpbmRleCwgcDAsIHAxLCBkMCwgZDEsIGxvb3BPZmZzZXQ7XG5cblx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGluZGV4ID0gaSAlIGNvdW50O1xuXHRcdHAwID0gcG9pbnRzW2luZGV4XS5fdmlldztcblx0XHRwMSA9IG1hcHBlcihwMCwgaW5kZXgsIHZpZXcpO1xuXHRcdGQwID0gaXNEcmF3YWJsZShwMCk7XG5cdFx0ZDEgPSBpc0RyYXdhYmxlKHAxKTtcblxuXHRcdGlmIChsb29wICYmIGxvb3BPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBkMCkge1xuXHRcdFx0bG9vcE9mZnNldCA9IGkgKyAxO1xuXHRcdFx0aWxlbiA9IGNvdW50ICsgbG9vcE9mZnNldDtcblx0XHR9XG5cblx0XHRpZiAoZDAgJiYgZDEpIHtcblx0XHRcdGxlbjAgPSBjdXJ2ZTAucHVzaChwMCk7XG5cdFx0XHRsZW4xID0gY3VydmUxLnB1c2gocDEpO1xuXHRcdH0gZWxzZSBpZiAobGVuMCAmJiBsZW4xKSB7XG5cdFx0XHRpZiAoIXNwYW4pIHtcblx0XHRcdFx0ZHJhd0FyZWEoY3R4LCBjdXJ2ZTAsIGN1cnZlMSwgbGVuMCwgbGVuMSk7XG5cdFx0XHRcdGxlbjAgPSBsZW4xID0gMDtcblx0XHRcdFx0Y3VydmUwID0gW107XG5cdFx0XHRcdGN1cnZlMSA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGQwKSB7XG5cdFx0XHRcdFx0Y3VydmUwLnB1c2gocDApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkMSkge1xuXHRcdFx0XHRcdGN1cnZlMS5wdXNoKHAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpO1xuXG5cdGN0eC5jbG9zZVBhdGgoKTtcblx0Y3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuXHRjdHguZmlsbCgpO1xufVxuXG52YXIgcGx1Z2luX2ZpbGxlciA9IHtcblx0aWQ6ICdmaWxsZXInLFxuXG5cdGFmdGVyRGF0YXNldHNVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0LCBvcHRpb25zKSB7XG5cdFx0dmFyIGNvdW50ID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDtcblx0XHR2YXIgcHJvcGFnYXRlID0gb3B0aW9ucy5wcm9wYWdhdGU7XG5cdFx0dmFyIHNvdXJjZXMgPSBbXTtcblx0XHR2YXIgbWV0YSwgaSwgZWwsIHNvdXJjZTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRlbCA9IG1ldGEuZGF0YXNldDtcblx0XHRcdHNvdXJjZSA9IG51bGw7XG5cblx0XHRcdGlmIChlbCAmJiBlbC5fbW9kZWwgJiYgZWwgaW5zdGFuY2VvZiBlbGVtZW50cy5MaW5lKSB7XG5cdFx0XHRcdHNvdXJjZSA9IHtcblx0XHRcdFx0XHR2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuXHRcdFx0XHRcdGZpbGw6IGRlY29kZUZpbGwoZWwsIGksIGNvdW50KSxcblx0XHRcdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRcdFx0ZWw6IGVsXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcblx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2UpO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdFx0XHRzb3VyY2UgPSBzb3VyY2VzW2ldO1xuXHRcdFx0aWYgKCFzb3VyY2UpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNvdXJjZS5maWxsID0gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpLCBwcm9wYWdhdGUpO1xuXHRcdFx0c291cmNlLmJvdW5kYXJ5ID0gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSk7XG5cdFx0XHRzb3VyY2UubWFwcGVyID0gY3JlYXRlTWFwcGVyKHNvdXJjZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGJlZm9yZURhdGFzZXRzRHJhdzogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgbWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuXHRcdHZhciBjdHggPSBjaGFydC5jdHg7XG5cdFx0dmFyIG1ldGEsIGksIGVsLCB2aWV3LCBwb2ludHMsIG1hcHBlciwgY29sb3I7XG5cblx0XHRmb3IgKGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuXHRcdFx0bWV0YSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG5cblx0XHRcdGlmICghbWV0YSB8fCAhbWV0YS52aXNpYmxlKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRlbCA9IG1ldGEuZWw7XG5cdFx0XHR2aWV3ID0gZWwuX3ZpZXc7XG5cdFx0XHRwb2ludHMgPSBlbC5fY2hpbGRyZW4gfHwgW107XG5cdFx0XHRtYXBwZXIgPSBtZXRhLm1hcHBlcjtcblx0XHRcdGNvbG9yID0gdmlldy5iYWNrZ3JvdW5kQ29sb3IgfHwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xuXG5cdFx0XHRpZiAobWFwcGVyICYmIGNvbG9yICYmIHBvaW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aGVscGVycyQxLmNhbnZhcy5jbGlwQXJlYShjdHgsIGNoYXJ0LmNoYXJ0QXJlYSk7XG5cdFx0XHRcdGRvRmlsbChjdHgsIHBvaW50cywgbWFwcGVyLCB2aWV3LCBjb2xvciwgZWwuX2xvb3ApO1xuXHRcdFx0XHRoZWxwZXJzJDEuY2FudmFzLnVuY2xpcEFyZWEoY3R4KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbnZhciBnZXRSdGxIZWxwZXIkMSA9IGhlbHBlcnMkMS5ydGwuZ2V0UnRsQWRhcHRlcjtcbnZhciBub29wJDEgPSBoZWxwZXJzJDEubm9vcDtcbnZhciB2YWx1ZU9yRGVmYXVsdCRlID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0bGVnZW5kOiB7XG5cdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRwb3NpdGlvbjogJ3RvcCcsXG5cdFx0YWxpZ246ICdjZW50ZXInLFxuXHRcdGZ1bGxXaWR0aDogdHJ1ZSxcblx0XHRyZXZlcnNlOiBmYWxzZSxcblx0XHR3ZWlnaHQ6IDEwMDAsXG5cblx0XHQvLyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBoYW5kbGVcblx0XHRvbkNsaWNrOiBmdW5jdGlvbihlLCBsZWdlbmRJdGVtKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcblx0XHRcdHZhciBjaSA9IHRoaXMuY2hhcnQ7XG5cdFx0XHR2YXIgbWV0YSA9IGNpLmdldERhdGFzZXRNZXRhKGluZGV4KTtcblxuXHRcdFx0Ly8gU2VlIGNvbnRyb2xsZXIuaXNEYXRhc2V0VmlzaWJsZSBjb21tZW50XG5cdFx0XHRtZXRhLmhpZGRlbiA9IG1ldGEuaGlkZGVuID09PSBudWxsID8gIWNpLmRhdGEuZGF0YXNldHNbaW5kZXhdLmhpZGRlbiA6IG51bGw7XG5cblx0XHRcdC8vIFdlIGhpZCBhIGRhdGFzZXQgLi4uIHJlcmVuZGVyIHRoZSBjaGFydFxuXHRcdFx0Y2kudXBkYXRlKCk7XG5cdFx0fSxcblxuXHRcdG9uSG92ZXI6IG51bGwsXG5cdFx0b25MZWF2ZTogbnVsbCxcblxuXHRcdGxhYmVsczoge1xuXHRcdFx0Ym94V2lkdGg6IDQwLFxuXHRcdFx0cGFkZGluZzogMTAsXG5cdFx0XHQvLyBHZW5lcmF0ZXMgbGFiZWxzIHNob3duIGluIHRoZSBsZWdlbmRcblx0XHRcdC8vIFZhbGlkIHByb3BlcnRpZXMgdG8gcmV0dXJuOlxuXHRcdFx0Ly8gdGV4dCA6IHRleHQgdG8gZGlzcGxheVxuXHRcdFx0Ly8gZmlsbFN0eWxlIDogZmlsbCBvZiBjb2xvdXJlZCBib3hcblx0XHRcdC8vIHN0cm9rZVN0eWxlOiBzdHJva2Ugb2YgY29sb3VyZWQgYm94XG5cdFx0XHQvLyBoaWRkZW4gOiBpZiB0aGlzIGxlZ2VuZCBpdGVtIHJlZmVycyB0byBhIGhpZGRlbiBpdGVtXG5cdFx0XHQvLyBsaW5lQ2FwIDogY2FwIHN0eWxlIGZvciBsaW5lXG5cdFx0XHQvLyBsaW5lRGFzaFxuXHRcdFx0Ly8gbGluZURhc2hPZmZzZXQgOlxuXHRcdFx0Ly8gbGluZUpvaW4gOlxuXHRcdFx0Ly8gbGluZVdpZHRoIDpcblx0XHRcdGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuXHRcdFx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMubGVnZW5kIHx8IHt9O1xuXHRcdFx0XHR2YXIgdXNlUG9pbnRTdHlsZSA9IG9wdGlvbnMubGFiZWxzICYmIG9wdGlvbnMubGFiZWxzLnVzZVBvaW50U3R5bGU7XG5cblx0XHRcdFx0cmV0dXJuIGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKS5tYXAoZnVuY3Rpb24obWV0YSkge1xuXHRcdFx0XHRcdHZhciBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh1c2VQb2ludFN0eWxlID8gMCA6IHVuZGVmaW5lZCk7XG5cblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dGV4dDogZGF0YXNldHNbbWV0YS5pbmRleF0ubGFiZWwsXG5cdFx0XHRcdFx0XHRmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcblx0XHRcdFx0XHRcdGhpZGRlbjogIWNoYXJ0LmlzRGF0YXNldFZpc2libGUobWV0YS5pbmRleCksXG5cdFx0XHRcdFx0XHRsaW5lQ2FwOiBzdHlsZS5ib3JkZXJDYXBTdHlsZSxcblx0XHRcdFx0XHRcdGxpbmVEYXNoOiBzdHlsZS5ib3JkZXJEYXNoLFxuXHRcdFx0XHRcdFx0bGluZURhc2hPZmZzZXQ6IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsXG5cdFx0XHRcdFx0XHRsaW5lSm9pbjogc3R5bGUuYm9yZGVySm9pblN0eWxlLFxuXHRcdFx0XHRcdFx0bGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcblx0XHRcdFx0XHRcdHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcblx0XHRcdFx0XHRcdHBvaW50U3R5bGU6IHN0eWxlLnBvaW50U3R5bGUsXG5cdFx0XHRcdFx0XHRyb3RhdGlvbjogc3R5bGUucm90YXRpb24sXG5cblx0XHRcdFx0XHRcdC8vIEJlbG93IGlzIGV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGRhdGFzZXRzXG5cdFx0XHRcdFx0XHRkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXhcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9LCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0bGVnZW5kQ2FsbGJhY2s6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuXHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGksIGlsZW4sIGxpc3RJdGVtLCBsaXN0SXRlbVNwYW47XG5cblx0XHRsaXN0LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjaGFydC5pZCArICctbGVnZW5kJyk7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG5cdFx0XHRsaXN0SXRlbSA9IGxpc3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKSk7XG5cdFx0XHRsaXN0SXRlbVNwYW4gPSBsaXN0SXRlbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJykpO1xuXHRcdFx0bGlzdEl0ZW1TcGFuLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGRhdGFzZXRzW2ldLmJhY2tncm91bmRDb2xvcjtcblx0XHRcdGlmIChkYXRhc2V0c1tpXS5sYWJlbCkge1xuXHRcdFx0XHRsaXN0SXRlbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhc2V0c1tpXS5sYWJlbCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBsaXN0Lm91dGVySFRNTDtcblx0fVxufSk7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm94IHdpZHRoIGJhc2VkIG9uIHRoZSB1c2VQb2ludFN0eWxlIG9wdGlvblxuICogQHBhcmFtIHtvYmplY3R9IGxhYmVsb3B0cyAtIHRoZSBsYWJlbCBvcHRpb25zIG9uIHRoZSBsZWdlbmRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb250U2l6ZSAtIHRoZSBsYWJlbCBmb250IHNpemVcbiAqIEByZXR1cm4ge251bWJlcn0gd2lkdGggb2YgdGhlIGNvbG9yIGJveCBhcmVhXG4gKi9cbmZ1bmN0aW9uIGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpIHtcblx0cmV0dXJuIGxhYmVsT3B0cy51c2VQb2ludFN0eWxlICYmIGxhYmVsT3B0cy5ib3hXaWR0aCA+IGZvbnRTaXplID9cblx0XHRmb250U2l6ZSA6XG5cdFx0bGFiZWxPcHRzLmJveFdpZHRoO1xufVxuXG4vKipcbiAqIElNUE9SVEFOVDogdGhpcyBjbGFzcyBpcyBleHBvc2VkIHB1YmxpY2x5IGFzIENoYXJ0LkxlZ2VuZCwgYmFja3dhcmQgY29tcGF0aWJpbGl0eSByZXF1aXJlZCFcbiAqL1xudmFyIExlZ2VuZCA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aGVscGVycyQxLmV4dGVuZChtZSwgY29uZmlnKTtcblxuXHRcdC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxuXHRcdG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG5cblx0XHQvKipcbiBcdFx0ICogQHByaXZhdGVcbiBcdFx0ICovXG5cdFx0bWUuX2hvdmVyZWRJdGVtID0gbnVsbDtcblxuXHRcdC8vIEFyZSB3ZSBpbiBkb3VnaG51dCBtb2RlIHdoaWNoIGhhcyBhIGRpZmZlcmVudCBkYXRhIHR5cGVcblx0XHRtZS5kb3VnaG51dE1vZGUgPSBmYWxzZTtcblx0fSxcblxuXHQvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxuXHQvLyBBbnkgZnVuY3Rpb24gZGVmaW5lZCBoZXJlIGlzIGluaGVyaXRlZCBieSBhbGwgbGVnZW5kIHR5cGVzLlxuXHQvLyBBbnkgZnVuY3Rpb24gY2FuIGJlIGV4dGVuZGVkIGJ5IHRoZSBsZWdlbmQgdHlwZVxuXG5cdGJlZm9yZVVwZGF0ZTogbm9vcCQxLFxuXHR1cGRhdGU6IGZ1bmN0aW9uKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Ly8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcblx0XHRtZS5iZWZvcmVVcGRhdGUoKTtcblxuXHRcdC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuXHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0bWUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuXHRcdG1lLm1hcmdpbnMgPSBtYXJnaW5zO1xuXG5cdFx0Ly8gRGltZW5zaW9uc1xuXHRcdG1lLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcblx0XHRtZS5zZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG5cdFx0Ly8gTGFiZWxzXG5cdFx0bWUuYmVmb3JlQnVpbGRMYWJlbHMoKTtcblx0XHRtZS5idWlsZExhYmVscygpO1xuXHRcdG1lLmFmdGVyQnVpbGRMYWJlbHMoKTtcblxuXHRcdC8vIEZpdFxuXHRcdG1lLmJlZm9yZUZpdCgpO1xuXHRcdG1lLmZpdCgpO1xuXHRcdG1lLmFmdGVyRml0KCk7XG5cdFx0Ly9cblx0XHRtZS5hZnRlclVwZGF0ZSgpO1xuXG5cdFx0cmV0dXJuIG1lLm1pblNpemU7XG5cdH0sXG5cdGFmdGVyVXBkYXRlOiBub29wJDEsXG5cblx0Ly9cblxuXHRiZWZvcmVTZXREaW1lbnNpb25zOiBub29wJDEsXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRcdG1lLmxlZnQgPSAwO1xuXHRcdFx0bWUucmlnaHQgPSBtZS53aWR0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuXG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLnRvcCA9IDA7XG5cdFx0XHRtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgcGFkZGluZ1xuXHRcdG1lLnBhZGRpbmdMZWZ0ID0gMDtcblx0XHRtZS5wYWRkaW5nVG9wID0gMDtcblx0XHRtZS5wYWRkaW5nUmlnaHQgPSAwO1xuXHRcdG1lLnBhZGRpbmdCb3R0b20gPSAwO1xuXG5cdFx0Ly8gUmVzZXQgbWluU2l6ZVxuXHRcdG1lLm1pblNpemUgPSB7XG5cdFx0XHR3aWR0aDogMCxcblx0XHRcdGhlaWdodDogMFxuXHRcdH07XG5cdH0sXG5cdGFmdGVyU2V0RGltZW5zaW9uczogbm9vcCQxLFxuXG5cdC8vXG5cblx0YmVmb3JlQnVpbGRMYWJlbHM6IG5vb3AkMSxcblx0YnVpbGRMYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGxhYmVsT3B0cyA9IG1lLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xuXHRcdHZhciBsZWdlbmRJdGVtcyA9IGhlbHBlcnMkMS5jYWxsYmFjayhsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFttZS5jaGFydF0sIG1lKSB8fCBbXTtcblxuXHRcdGlmIChsYWJlbE9wdHMuZmlsdGVyKSB7XG5cdFx0XHRsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHJldHVybiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIG1lLmNoYXJ0LmRhdGEpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1lLm9wdGlvbnMucmV2ZXJzZSkge1xuXHRcdFx0bGVnZW5kSXRlbXMucmV2ZXJzZSgpO1xuXHRcdH1cblxuXHRcdG1lLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG5cdH0sXG5cdGFmdGVyQnVpbGRMYWJlbHM6IG5vb3AkMSxcblxuXHQvL1xuXG5cdGJlZm9yZUZpdDogbm9vcCQxLFxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBsYWJlbE9wdHMgPSBvcHRzLmxhYmVscztcblx0XHR2YXIgZGlzcGxheSA9IG9wdHMuZGlzcGxheTtcblxuXHRcdHZhciBjdHggPSBtZS5jdHg7XG5cblx0XHR2YXIgbGFiZWxGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChsYWJlbE9wdHMpO1xuXHRcdHZhciBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuXG5cdFx0Ly8gUmVzZXQgaGl0IGJveGVzXG5cdFx0dmFyIGhpdGJveGVzID0gbWUubGVnZW5kSGl0Qm94ZXMgPSBbXTtcblxuXHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZTtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRtaW5TaXplLndpZHRoID0gbWUubWF4V2lkdGg7IC8vIGZpbGwgYWxsIHRoZSB3aWR0aFxuXHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBkaXNwbGF5ID8gMTAgOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtaW5TaXplLndpZHRoID0gZGlzcGxheSA/IDEwIDogMDtcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG5cdFx0fVxuXG5cdFx0Ly8gSW5jcmVhc2Ugc2l6ZXMgaGVyZVxuXHRcdGlmICghZGlzcGxheSkge1xuXHRcdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoID0gbWUuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQgPSAwO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG5cblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHQvLyBMYWJlbHNcblxuXHRcdFx0Ly8gV2lkdGggb2YgZWFjaCBsaW5lIG9mIGxlZ2VuZCBib3hlcy4gTGFiZWxzIHdyYXAgb250byBtdWx0aXBsZSBsaW5lcyB3aGVuIHRoZXJlIGFyZSB0b28gbWFueSB0byBmaXQgb24gb25lXG5cdFx0XHR2YXIgbGluZVdpZHRocyA9IG1lLmxpbmVXaWR0aHMgPSBbMF07XG5cdFx0XHR2YXIgdG90YWxIZWlnaHQgPSAwO1xuXG5cdFx0XHRjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xuXHRcdFx0XHR2YXIgYm94V2lkdGggPSBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKTtcblx0XHRcdFx0dmFyIHdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXG5cdFx0XHRcdGlmIChpID09PSAwIHx8IGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArIHdpZHRoICsgMiAqIGxhYmVsT3B0cy5wYWRkaW5nID4gbWluU2l6ZS53aWR0aCkge1xuXHRcdFx0XHRcdHRvdGFsSGVpZ2h0ICs9IGZvbnRTaXplICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0bGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIChpID4gMCA/IDAgOiAxKV0gPSAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3RvcmUgdGhlIGhpdGJveCB3aWR0aCBhbmQgaGVpZ2h0IGhlcmUuIEZpbmFsIHBvc2l0aW9uIHdpbGwgYmUgdXBkYXRlZCBpbiBgZHJhd2Bcblx0XHRcdFx0aGl0Ym94ZXNbaV0gPSB7XG5cdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogZm9udFNpemVcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdH0pO1xuXG5cdFx0XHRtaW5TaXplLmhlaWdodCArPSB0b3RhbEhlaWdodDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdlBhZGRpbmcgPSBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdHZhciBjb2x1bW5XaWR0aHMgPSBtZS5jb2x1bW5XaWR0aHMgPSBbXTtcblx0XHRcdHZhciBjb2x1bW5IZWlnaHRzID0gbWUuY29sdW1uSGVpZ2h0cyA9IFtdO1xuXHRcdFx0dmFyIHRvdGFsV2lkdGggPSBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdHZhciBjdXJyZW50Q29sV2lkdGggPSAwO1xuXHRcdFx0dmFyIGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xuXHRcdFx0XHR2YXIgYm94V2lkdGggPSBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKTtcblx0XHRcdFx0dmFyIGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcblxuXHRcdFx0XHQvLyBJZiB0b28gdGFsbCwgZ28gdG8gbmV3IGNvbHVtblxuXHRcdFx0XHRpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGZvbnRTaXplICsgMiAqIHZQYWRkaW5nID4gbWluU2l6ZS5oZWlnaHQpIHtcblx0XHRcdFx0XHR0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdGNvbHVtbldpZHRocy5wdXNoKGN1cnJlbnRDb2xXaWR0aCk7IC8vIHByZXZpb3VzIGNvbHVtbiB3aWR0aFxuXHRcdFx0XHRcdGNvbHVtbkhlaWdodHMucHVzaChjdXJyZW50Q29sSGVpZ2h0KTtcblx0XHRcdFx0XHRjdXJyZW50Q29sV2lkdGggPSAwO1xuXHRcdFx0XHRcdGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IG1heCB3aWR0aFxuXHRcdFx0XHRjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XG5cdFx0XHRcdGN1cnJlbnRDb2xIZWlnaHQgKz0gZm9udFNpemUgKyB2UGFkZGluZztcblxuXHRcdFx0XHQvLyBTdG9yZSB0aGUgaGl0Ym94IHdpZHRoIGFuZCBoZWlnaHQgaGVyZS4gRmluYWwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkIGluIGBkcmF3YFxuXHRcdFx0XHRoaXRib3hlc1tpXSA9IHtcblx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0XHR3aWR0aDogaXRlbVdpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogZm9udFNpemVcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcblx0XHRcdGNvbHVtbldpZHRocy5wdXNoKGN1cnJlbnRDb2xXaWR0aCk7XG5cdFx0XHRjb2x1bW5IZWlnaHRzLnB1c2goY3VycmVudENvbEhlaWdodCk7XG5cdFx0XHRtaW5TaXplLndpZHRoICs9IHRvdGFsV2lkdGg7XG5cdFx0fVxuXG5cdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xuXHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuXHR9LFxuXHRhZnRlckZpdDogbm9vcCQxLFxuXG5cdC8vIFNoYXJlZCBNZXRob2RzXG5cdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcblx0fSxcblxuXHQvLyBBY3R1YWxseSBkcmF3IHRoZSBsZWdlbmQgb24gdGhlIGNhbnZhc1xuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgbGFiZWxPcHRzID0gb3B0cy5sYWJlbHM7XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIGRlZmF1bHRDb2xvciA9IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjtcblx0XHR2YXIgbGluZURlZmF1bHQgPSBnbG9iYWxEZWZhdWx0cy5lbGVtZW50cy5saW5lO1xuXHRcdHZhciBsZWdlbmRIZWlnaHQgPSBtZS5oZWlnaHQ7XG5cdFx0dmFyIGNvbHVtbkhlaWdodHMgPSBtZS5jb2x1bW5IZWlnaHRzO1xuXHRcdHZhciBsZWdlbmRXaWR0aCA9IG1lLndpZHRoO1xuXHRcdHZhciBsaW5lV2lkdGhzID0gbWUubGluZVdpZHRocztcblxuXHRcdGlmICghb3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHJ0bEhlbHBlciA9IGdldFJ0bEhlbHBlciQxKG9wdHMucnRsLCBtZS5sZWZ0LCBtZS5taW5TaXplLndpZHRoKTtcblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXHRcdHZhciBmb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCRlKGxhYmVsT3B0cy5mb250Q29sb3IsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250Q29sb3IpO1xuXHRcdHZhciBsYWJlbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KGxhYmVsT3B0cyk7XG5cdFx0dmFyIGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG5cdFx0dmFyIGN1cnNvcjtcblxuXHRcdC8vIENhbnZhcyBzZXR1cFxuXHRcdGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKCdsZWZ0Jyk7XG5cdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXHRcdGN0eC5saW5lV2lkdGggPSAwLjU7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gZm9udENvbG9yOyAvLyBmb3Igc3RyaWtldGhyb3VnaCBlZmZlY3Rcblx0XHRjdHguZmlsbFN0eWxlID0gZm9udENvbG9yOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcblx0XHRjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG5cblx0XHR2YXIgYm94V2lkdGggPSBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKTtcblx0XHR2YXIgaGl0Ym94ZXMgPSBtZS5sZWdlbmRIaXRCb3hlcztcblxuXHRcdC8vIGN1cnJlbnQgcG9zaXRpb25cblx0XHR2YXIgZHJhd0xlZ2VuZEJveCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcblx0XHRcdGlmIChpc05hTihib3hXaWR0aCkgfHwgYm94V2lkdGggPD0gMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgY3R4IGZvciB0aGUgYm94XG5cdFx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0XHR2YXIgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQkZShsZWdlbmRJdGVtLmxpbmVXaWR0aCwgbGluZURlZmF1bHQuYm9yZGVyV2lkdGgpO1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZhbHVlT3JEZWZhdWx0JGUobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG5cdFx0XHRjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0JGUobGVnZW5kSXRlbS5saW5lQ2FwLCBsaW5lRGVmYXVsdC5ib3JkZXJDYXBTdHlsZSk7XG5cdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdCRlKGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIGxpbmVEZWZhdWx0LmJvcmRlckRhc2hPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQkZShsZWdlbmRJdGVtLmxpbmVKb2luLCBsaW5lRGVmYXVsdC5ib3JkZXJKb2luU3R5bGUpO1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0JGUobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcblxuXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHQvLyBJRSA5IGFuZCAxMCBkbyBub3Qgc3VwcG9ydCBsaW5lIGRhc2hcblx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0JGUobGVnZW5kSXRlbS5saW5lRGFzaCwgbGluZURlZmF1bHQuYm9yZGVyRGFzaCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobGFiZWxPcHRzICYmIGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG5cdFx0XHRcdC8vIFJlY2FsY3VsYXRlIHggYW5kIHkgZm9yIGRyYXdQb2ludCgpIGJlY2F1c2UgaXRzIGV4cGVjdGluZ1xuXHRcdFx0XHQvLyB4IGFuZCB5IHRvIGJlIGNlbnRlciBvZiBmaWd1cmUgKGluc3RlYWQgb2YgdG9wIGxlZnQpXG5cdFx0XHRcdHZhciByYWRpdXMgPSBib3hXaWR0aCAqIE1hdGguU1FSVDIgLyAyO1xuXHRcdFx0XHR2YXIgY2VudGVyWCA9IHJ0bEhlbHBlci54UGx1cyh4LCBib3hXaWR0aCAvIDIpO1xuXHRcdFx0XHR2YXIgY2VudGVyWSA9IHkgKyBmb250U2l6ZSAvIDI7XG5cblx0XHRcdFx0Ly8gRHJhdyBwb2ludFN0eWxlIGFzIGxlZ2VuZCBzeW1ib2xcblx0XHRcdFx0aGVscGVycyQxLmNhbnZhcy5kcmF3UG9pbnQoY3R4LCBsZWdlbmRJdGVtLnBvaW50U3R5bGUsIHJhZGl1cywgY2VudGVyWCwgY2VudGVyWSwgbGVnZW5kSXRlbS5yb3RhdGlvbik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBEcmF3IGJveCBhcyBsZWdlbmQgc3ltYm9sXG5cdFx0XHRcdGN0eC5maWxsUmVjdChydGxIZWxwZXIubGVmdEZvckx0cih4LCBib3hXaWR0aCksIHksIGJveFdpZHRoLCBmb250U2l6ZSk7XG5cdFx0XHRcdGlmIChsaW5lV2lkdGggIT09IDApIHtcblx0XHRcdFx0XHRjdHguc3Ryb2tlUmVjdChydGxIZWxwZXIubGVmdEZvckx0cih4LCBib3hXaWR0aCksIHksIGJveFdpZHRoLCBmb250U2l6ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9O1xuXG5cdFx0dmFyIGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSwgdGV4dFdpZHRoKSB7XG5cdFx0XHR2YXIgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xuXHRcdFx0dmFyIHhMZWZ0ID0gcnRsSGVscGVyLnhQbHVzKHgsIGJveFdpZHRoICsgaGFsZkZvbnRTaXplKTtcblx0XHRcdHZhciB5TWlkZGxlID0geSArIGhhbGZGb250U2l6ZTtcblxuXHRcdFx0Y3R4LmZpbGxUZXh0KGxlZ2VuZEl0ZW0udGV4dCwgeExlZnQsIHlNaWRkbGUpO1xuXG5cdFx0XHRpZiAobGVnZW5kSXRlbS5oaWRkZW4pIHtcblx0XHRcdFx0Ly8gU3RyaWtldGhyb3VnaCB0aGUgdGV4dCBpZiBoaWRkZW5cblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHgubGluZVdpZHRoID0gMjtcblx0XHRcdFx0Y3R4Lm1vdmVUbyh4TGVmdCwgeU1pZGRsZSk7XG5cdFx0XHRcdGN0eC5saW5lVG8ocnRsSGVscGVyLnhQbHVzKHhMZWZ0LCB0ZXh0V2lkdGgpLCB5TWlkZGxlKTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgYWxpZ25tZW50T2Zmc2V0ID0gZnVuY3Rpb24oZGltZW5zaW9uLCBibG9ja1NpemUpIHtcblx0XHRcdHN3aXRjaCAob3B0cy5hbGlnbikge1xuXHRcdFx0Y2FzZSAnc3RhcnQnOlxuXHRcdFx0XHRyZXR1cm4gbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRjYXNlICdlbmQnOlxuXHRcdFx0XHRyZXR1cm4gZGltZW5zaW9uIC0gYmxvY2tTaXplO1xuXHRcdFx0ZGVmYXVsdDogLy8gY2VudGVyXG5cdFx0XHRcdHJldHVybiAoZGltZW5zaW9uIC0gYmxvY2tTaXplICsgbGFiZWxPcHRzLnBhZGRpbmcpIC8gMjtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gSG9yaXpvbnRhbFxuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRjdXJzb3IgPSB7XG5cdFx0XHRcdHg6IG1lLmxlZnQgKyBhbGlnbm1lbnRPZmZzZXQobGVnZW5kV2lkdGgsIGxpbmVXaWR0aHNbMF0pLFxuXHRcdFx0XHR5OiBtZS50b3AgKyBsYWJlbE9wdHMucGFkZGluZyxcblx0XHRcdFx0bGluZTogMFxuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3Vyc29yID0ge1xuXHRcdFx0XHR4OiBtZS5sZWZ0ICsgbGFiZWxPcHRzLnBhZGRpbmcsXG5cdFx0XHRcdHk6IG1lLnRvcCArIGFsaWdubWVudE9mZnNldChsZWdlbmRIZWlnaHQsIGNvbHVtbkhlaWdodHNbMF0pLFxuXHRcdFx0XHRsaW5lOiAwXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGhlbHBlcnMkMS5ydGwub3ZlcnJpZGVUZXh0RGlyZWN0aW9uKG1lLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcblxuXHRcdHZhciBpdGVtSGVpZ2h0ID0gZm9udFNpemUgKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRoZWxwZXJzJDEuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xuXHRcdFx0dmFyIHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXHRcdFx0dmFyIHdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIHRleHRXaWR0aDtcblx0XHRcdHZhciB4ID0gY3Vyc29yLng7XG5cdFx0XHR2YXIgeSA9IGN1cnNvci55O1xuXG5cdFx0XHRydGxIZWxwZXIuc2V0V2lkdGgobWUubWluU2l6ZS53aWR0aCk7XG5cblx0XHRcdC8vIFVzZSAobWUubGVmdCArIG1lLm1pblNpemUud2lkdGgpIGFuZCAobWUudG9wICsgbWUubWluU2l6ZS5oZWlnaHQpXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIG1lLnJpZ2h0IGFuZCBtZS5ib3R0b20gYmVjYXVzZSBtZS53aWR0aCBhbmQgbWUuaGVpZ2h0XG5cdFx0XHQvLyBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQgc2luY2UgbWUubWluU2l6ZSB3YXMgY2FsY3VsYXRlZFxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmcgPiBtZS5sZWZ0ICsgbWUubWluU2l6ZS53aWR0aCkge1xuXHRcdFx0XHRcdHkgPSBjdXJzb3IueSArPSBpdGVtSGVpZ2h0O1xuXHRcdFx0XHRcdGN1cnNvci5saW5lKys7XG5cdFx0XHRcdFx0eCA9IGN1cnNvci54ID0gbWUubGVmdCArIGFsaWdubWVudE9mZnNldChsZWdlbmRXaWR0aCwgbGluZVdpZHRoc1tjdXJzb3IubGluZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBpdGVtSGVpZ2h0ID4gbWUudG9wICsgbWUubWluU2l6ZS5oZWlnaHQpIHtcblx0XHRcdFx0eCA9IGN1cnNvci54ID0geCArIG1lLmNvbHVtbldpZHRoc1tjdXJzb3IubGluZV0gKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0Y3Vyc29yLmxpbmUrKztcblx0XHRcdFx0eSA9IGN1cnNvci55ID0gbWUudG9wICsgYWxpZ25tZW50T2Zmc2V0KGxlZ2VuZEhlaWdodCwgY29sdW1uSGVpZ2h0c1tjdXJzb3IubGluZV0pO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcmVhbFggPSBydGxIZWxwZXIueCh4KTtcblxuXHRcdFx0ZHJhd0xlZ2VuZEJveChyZWFsWCwgeSwgbGVnZW5kSXRlbSk7XG5cblx0XHRcdGhpdGJveGVzW2ldLmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihyZWFsWCwgaGl0Ym94ZXNbaV0ud2lkdGgpO1xuXHRcdFx0aGl0Ym94ZXNbaV0udG9wID0geTtcblxuXHRcdFx0Ly8gRmlsbCB0aGUgYWN0dWFsIGxhYmVsXG5cdFx0XHRmaWxsVGV4dChyZWFsWCwgeSwgbGVnZW5kSXRlbSwgdGV4dFdpZHRoKTtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRjdXJzb3IueCArPSB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3Vyc29yLnkgKz0gaXRlbUhlaWdodDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGhlbHBlcnMkMS5ydGwucmVzdG9yZVRleHREaXJlY3Rpb24obWUuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldExlZ2VuZEl0ZW1BdDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGksIGhpdEJveCwgbGg7XG5cblx0XHRpZiAoeCA+PSBtZS5sZWZ0ICYmIHggPD0gbWUucmlnaHQgJiYgeSA+PSBtZS50b3AgJiYgeSA8PSBtZS5ib3R0b20pIHtcblx0XHRcdC8vIFNlZSBpZiB3ZSBhcmUgdG91Y2hpbmcgb25lIG9mIHRoZSBkYXRhc2V0IGJveGVzXG5cdFx0XHRsaCA9IG1lLmxlZ2VuZEhpdEJveGVzO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxoLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGhpdEJveCA9IGxoW2ldO1xuXG5cdFx0XHRcdGlmICh4ID49IGhpdEJveC5sZWZ0ICYmIHggPD0gaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGggJiYgeSA+PSBoaXRCb3gudG9wICYmIHkgPD0gaGl0Qm94LnRvcCArIGhpdEJveC5oZWlnaHQpIHtcblx0XHRcdFx0XHQvLyBUb3VjaGluZyBhbiBlbGVtZW50XG5cdFx0XHRcdFx0cmV0dXJuIG1lLmxlZ2VuZEl0ZW1zW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqL1xuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0eXBlID0gZS50eXBlID09PSAnbW91c2V1cCcgPyAnY2xpY2snIDogZS50eXBlO1xuXHRcdHZhciBob3ZlcmVkSXRlbTtcblxuXHRcdGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuXHRcdFx0aWYgKCFvcHRzLm9uSG92ZXIgJiYgIW9wdHMub25MZWF2ZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRpZiAoIW9wdHMub25DbGljaykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDaGFydCBldmVudCBhbHJlYWR5IGhhcyByZWxhdGl2ZSBwb3NpdGlvbiBpbiBpdFxuXHRcdGhvdmVyZWRJdGVtID0gbWUuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG5cblx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0aWYgKGhvdmVyZWRJdGVtICYmIG9wdHMub25DbGljaykge1xuXHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdG9wdHMub25DbGljay5jYWxsKG1lLCBlLm5hdGl2ZSwgaG92ZXJlZEl0ZW0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAob3B0cy5vbkxlYXZlICYmIGhvdmVyZWRJdGVtICE9PSBtZS5faG92ZXJlZEl0ZW0pIHtcblx0XHRcdFx0aWYgKG1lLl9ob3ZlcmVkSXRlbSkge1xuXHRcdFx0XHRcdG9wdHMub25MZWF2ZS5jYWxsKG1lLCBlLm5hdGl2ZSwgbWUuX2hvdmVyZWRJdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZS5faG92ZXJlZEl0ZW0gPSBob3ZlcmVkSXRlbTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMub25Ib3ZlciAmJiBob3ZlcmVkSXRlbSkge1xuXHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdG9wdHMub25Ib3Zlci5jYWxsKG1lLCBlLm5hdGl2ZSwgaG92ZXJlZEl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cykge1xuXHR2YXIgbGVnZW5kID0gbmV3IExlZ2VuZCh7XG5cdFx0Y3R4OiBjaGFydC5jdHgsXG5cdFx0b3B0aW9uczogbGVnZW5kT3B0cyxcblx0XHRjaGFydDogY2hhcnRcblx0fSk7XG5cblx0Y29yZV9sYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBsZWdlbmRPcHRzKTtcblx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcblx0Y2hhcnQubGVnZW5kID0gbGVnZW5kO1xufVxuXG52YXIgcGx1Z2luX2xlZ2VuZCA9IHtcblx0aWQ6ICdsZWdlbmQnLFxuXG5cdC8qKlxuXHQgKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBzaW5jZSAyLjEuNSwgdGhlIGxlZ2VuZCBpcyByZWdpc3RlcmVkIGFzIGEgcGx1Z2luLCBtYWtpbmdcblx0ICogQ2hhcnQuTGVnZW5kIG9ic29sZXRlLiBUbyBhdm9pZCBhIGJyZWFraW5nIGNoYW5nZSwgd2UgZXhwb3J0IHRoZSBMZWdlbmQgYXMgcGFydCBvZlxuXHQgKiB0aGUgcGx1Z2luLCB3aGljaCBvbmUgd2lsbCBiZSByZS1leHBvc2VkIGluIHRoZSBjaGFydC5qcyBmaWxlLlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzI2NDBcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbGVtZW50OiBMZWdlbmQsXG5cblx0YmVmb3JlSW5pdDogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgbGVnZW5kT3B0cyA9IGNoYXJ0Lm9wdGlvbnMubGVnZW5kO1xuXG5cdFx0aWYgKGxlZ2VuZE9wdHMpIHtcblx0XHRcdGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cyk7XG5cdFx0fVxuXHR9LFxuXG5cdGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgbGVnZW5kT3B0cyA9IGNoYXJ0Lm9wdGlvbnMubGVnZW5kO1xuXHRcdHZhciBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG5cblx0XHRpZiAobGVnZW5kT3B0cykge1xuXHRcdFx0aGVscGVycyQxLm1lcmdlSWYobGVnZW5kT3B0cywgY29yZV9kZWZhdWx0cy5nbG9iYWwubGVnZW5kKTtcblxuXHRcdFx0aWYgKGxlZ2VuZCkge1xuXHRcdFx0XHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIGxlZ2VuZE9wdHMpO1xuXHRcdFx0XHRsZWdlbmQub3B0aW9ucyA9IGxlZ2VuZE9wdHM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2goY2hhcnQsIGxlZ2VuZE9wdHMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobGVnZW5kKSB7XG5cdFx0XHRjb3JlX2xheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBsZWdlbmQpO1xuXHRcdFx0ZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcblx0XHR9XG5cdH0sXG5cblx0YWZ0ZXJFdmVudDogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHR2YXIgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuXHRcdGlmIChsZWdlbmQpIHtcblx0XHRcdGxlZ2VuZC5oYW5kbGVFdmVudChlKTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBub29wJDIgPSBoZWxwZXJzJDEubm9vcDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHRpdGxlOiB7XG5cdFx0ZGlzcGxheTogZmFsc2UsXG5cdFx0Zm9udFN0eWxlOiAnYm9sZCcsXG5cdFx0ZnVsbFdpZHRoOiB0cnVlLFxuXHRcdHBhZGRpbmc6IDEwLFxuXHRcdHBvc2l0aW9uOiAndG9wJyxcblx0XHR0ZXh0OiAnJyxcblx0XHR3ZWlnaHQ6IDIwMDAgICAgICAgICAvLyBieSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZWdlbmQgKDEwMDApIHRvIGJlIGFib3ZlXG5cdH1cbn0pO1xuXG4vKipcbiAqIElNUE9SVEFOVDogdGhpcyBjbGFzcyBpcyBleHBvc2VkIHB1YmxpY2x5IGFzIENoYXJ0LkxlZ2VuZCwgYmFja3dhcmQgY29tcGF0aWJpbGl0eSByZXF1aXJlZCFcbiAqL1xudmFyIFRpdGxlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aGVscGVycyQxLmV4dGVuZChtZSwgY29uZmlnKTtcblxuXHRcdC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxuXHRcdG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG5cdH0sXG5cblx0Ly8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3ljbGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cblxuXHRiZWZvcmVVcGRhdGU6IG5vb3AkMixcblx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRtZS5tYXJnaW5zID0gbWFyZ2lucztcblxuXHRcdC8vIERpbWVuc2lvbnNcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuc2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXHRcdC8vIExhYmVsc1xuXHRcdG1lLmJlZm9yZUJ1aWxkTGFiZWxzKCk7XG5cdFx0bWUuYnVpbGRMYWJlbHMoKTtcblx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XG5cblx0XHQvLyBGaXRcblx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRtZS5maXQoKTtcblx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdC8vXG5cdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdHJldHVybiBtZS5taW5TaXplO1xuXG5cdH0sXG5cdGFmdGVyVXBkYXRlOiBub29wJDIsXG5cblx0Ly9cblxuXHRiZWZvcmVTZXREaW1lbnNpb25zOiBub29wJDIsXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRcdG1lLmxlZnQgPSAwO1xuXHRcdFx0bWUucmlnaHQgPSBtZS53aWR0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuXG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLnRvcCA9IDA7XG5cdFx0XHRtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgcGFkZGluZ1xuXHRcdG1lLnBhZGRpbmdMZWZ0ID0gMDtcblx0XHRtZS5wYWRkaW5nVG9wID0gMDtcblx0XHRtZS5wYWRkaW5nUmlnaHQgPSAwO1xuXHRcdG1lLnBhZGRpbmdCb3R0b20gPSAwO1xuXG5cdFx0Ly8gUmVzZXQgbWluU2l6ZVxuXHRcdG1lLm1pblNpemUgPSB7XG5cdFx0XHR3aWR0aDogMCxcblx0XHRcdGhlaWdodDogMFxuXHRcdH07XG5cdH0sXG5cdGFmdGVyU2V0RGltZW5zaW9uczogbm9vcCQyLFxuXG5cdC8vXG5cblx0YmVmb3JlQnVpbGRMYWJlbHM6IG5vb3AkMixcblx0YnVpbGRMYWJlbHM6IG5vb3AkMixcblx0YWZ0ZXJCdWlsZExhYmVsczogbm9vcCQyLFxuXG5cdC8vXG5cblx0YmVmb3JlRml0OiBub29wJDIsXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIG1pblNpemUgPSBtZS5taW5TaXplID0ge307XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciBsaW5lQ291bnQsIHRleHRTaXplO1xuXG5cdFx0aWYgKCFvcHRzLmRpc3BsYXkpIHtcblx0XHRcdG1lLndpZHRoID0gbWluU2l6ZS53aWR0aCA9IG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0ID0gMDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsaW5lQ291bnQgPSBoZWxwZXJzJDEuaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XG5cdFx0dGV4dFNpemUgPSBsaW5lQ291bnQgKiBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KG9wdHMpLmxpbmVIZWlnaHQgKyBvcHRzLnBhZGRpbmcgKiAyO1xuXG5cdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoID0gaXNIb3Jpem9udGFsID8gbWUubWF4V2lkdGggOiB0ZXh0U2l6ZTtcblx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodCA9IGlzSG9yaXpvbnRhbCA/IHRleHRTaXplIDogbWUubWF4SGVpZ2h0O1xuXHR9LFxuXHRhZnRlckZpdDogbm9vcCQyLFxuXG5cdC8vIFNoYXJlZCBNZXRob2RzXG5cdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcblx0XHRyZXR1cm4gcG9zID09PSAndG9wJyB8fCBwb3MgPT09ICdib3R0b20nO1xuXHR9LFxuXG5cdC8vIEFjdHVhbGx5IGRyYXcgdGhlIHRpdGxlIGJsb2NrIG9uIHRoZSBjYW52YXNcblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblxuXHRcdGlmICghb3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGZvbnRPcHRzID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChvcHRzKTtcblx0XHR2YXIgbGluZUhlaWdodCA9IGZvbnRPcHRzLmxpbmVIZWlnaHQ7XG5cdFx0dmFyIG9mZnNldCA9IGxpbmVIZWlnaHQgLyAyICsgb3B0cy5wYWRkaW5nO1xuXHRcdHZhciByb3RhdGlvbiA9IDA7XG5cdFx0dmFyIHRvcCA9IG1lLnRvcDtcblx0XHR2YXIgbGVmdCA9IG1lLmxlZnQ7XG5cdFx0dmFyIGJvdHRvbSA9IG1lLmJvdHRvbTtcblx0XHR2YXIgcmlnaHQgPSBtZS5yaWdodDtcblx0XHR2YXIgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChvcHRzLmZvbnRDb2xvciwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXHRcdGN0eC5mb250ID0gZm9udE9wdHMuc3RyaW5nO1xuXG5cdFx0Ly8gSG9yaXpvbnRhbFxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0dGl0bGVYID0gbGVmdCArICgocmlnaHQgLSBsZWZ0KSAvIDIpOyAvLyBtaWRwb2ludCBvZiB0aGUgd2lkdGhcblx0XHRcdHRpdGxlWSA9IHRvcCArIG9mZnNldDtcblx0XHRcdG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aXRsZVggPSBvcHRzLnBvc2l0aW9uID09PSAnbGVmdCcgPyBsZWZ0ICsgb2Zmc2V0IDogcmlnaHQgLSBvZmZzZXQ7XG5cdFx0XHR0aXRsZVkgPSB0b3AgKyAoKGJvdHRvbSAtIHRvcCkgLyAyKTtcblx0XHRcdG1heFdpZHRoID0gYm90dG9tIC0gdG9wO1xuXHRcdFx0cm90YXRpb24gPSBNYXRoLlBJICogKG9wdHMucG9zaXRpb24gPT09ICdsZWZ0JyA/IC0wLjUgOiAwLjUpO1xuXHRcdH1cblxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0Y3R4LnRyYW5zbGF0ZSh0aXRsZVgsIHRpdGxlWSk7XG5cdFx0Y3R4LnJvdGF0ZShyb3RhdGlvbik7XG5cdFx0Y3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuXHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuXHRcdHZhciB0ZXh0ID0gb3B0cy50ZXh0O1xuXHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0ZXh0KSkge1xuXHRcdFx0dmFyIHkgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0W2ldLCAwLCB5LCBtYXhXaWR0aCk7XG5cdFx0XHRcdHkgKz0gbGluZUhlaWdodDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3R4LmZpbGxUZXh0KHRleHQsIDAsIDAsIG1heFdpZHRoKTtcblx0XHR9XG5cblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKSB7XG5cdHZhciB0aXRsZSA9IG5ldyBUaXRsZSh7XG5cdFx0Y3R4OiBjaGFydC5jdHgsXG5cdFx0b3B0aW9uczogdGl0bGVPcHRzLFxuXHRcdGNoYXJ0OiBjaGFydFxuXHR9KTtcblxuXHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgdGl0bGVPcHRzKTtcblx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuXHRjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG59XG5cbnZhciBwbHVnaW5fdGl0bGUgPSB7XG5cdGlkOiAndGl0bGUnLFxuXG5cdC8qKlxuXHQgKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBzaW5jZSAyLjEuNSwgdGhlIHRpdGxlIGlzIHJlZ2lzdGVyZWQgYXMgYSBwbHVnaW4sIG1ha2luZ1xuXHQgKiBDaGFydC5UaXRsZSBvYnNvbGV0ZS4gVG8gYXZvaWQgYSBicmVha2luZyBjaGFuZ2UsIHdlIGV4cG9ydCB0aGUgVGl0bGUgYXMgcGFydCBvZlxuXHQgKiB0aGUgcGx1Z2luLCB3aGljaCBvbmUgd2lsbCBiZSByZS1leHBvc2VkIGluIHRoZSBjaGFydC5qcyBmaWxlLlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzI2NDBcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbGVtZW50OiBUaXRsZSxcblxuXHRiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0aXRsZU9wdHMgPSBjaGFydC5vcHRpb25zLnRpdGxlO1xuXG5cdFx0aWYgKHRpdGxlT3B0cykge1xuXHRcdFx0Y3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKTtcblx0XHR9XG5cdH0sXG5cblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0aXRsZU9wdHMgPSBjaGFydC5vcHRpb25zLnRpdGxlO1xuXHRcdHZhciB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcblxuXHRcdGlmICh0aXRsZU9wdHMpIHtcblx0XHRcdGhlbHBlcnMkMS5tZXJnZUlmKHRpdGxlT3B0cywgY29yZV9kZWZhdWx0cy5nbG9iYWwudGl0bGUpO1xuXG5cdFx0XHRpZiAodGl0bGVCbG9jaykge1xuXHRcdFx0XHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZUJsb2NrLCB0aXRsZU9wdHMpO1xuXHRcdFx0XHR0aXRsZUJsb2NrLm9wdGlvbnMgPSB0aXRsZU9wdHM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGl0bGVCbG9jaykge1xuXHRcdFx0Y29yZV9sYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG5cdFx0XHRkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcblx0XHR9XG5cdH1cbn07XG5cbnZhciBwbHVnaW5zID0ge307XG52YXIgZmlsbGVyID0gcGx1Z2luX2ZpbGxlcjtcbnZhciBsZWdlbmQgPSBwbHVnaW5fbGVnZW5kO1xudmFyIHRpdGxlID0gcGx1Z2luX3RpdGxlO1xucGx1Z2lucy5maWxsZXIgPSBmaWxsZXI7XG5wbHVnaW5zLmxlZ2VuZCA9IGxlZ2VuZDtcbnBsdWdpbnMudGl0bGUgPSB0aXRsZTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0XG4gKi9cblxuXG5jb3JlX2NvbnRyb2xsZXIuaGVscGVycyA9IGhlbHBlcnMkMTtcblxuLy8gQHRvZG8gZGlzcGF0Y2ggdGhlc2UgaGVscGVycyBpbnRvIGFwcHJvcHJpYXRlZCBoZWxwZXJzL2hlbHBlcnMuKiBmaWxlIGFuZCB3cml0ZSB1bml0IHRlc3RzIVxuY29yZV9oZWxwZXJzKCk7XG5cbmNvcmVfY29udHJvbGxlci5fYWRhcHRlcnMgPSBjb3JlX2FkYXB0ZXJzO1xuY29yZV9jb250cm9sbGVyLkFuaW1hdGlvbiA9IGNvcmVfYW5pbWF0aW9uO1xuY29yZV9jb250cm9sbGVyLmFuaW1hdGlvblNlcnZpY2UgPSBjb3JlX2FuaW1hdGlvbnM7XG5jb3JlX2NvbnRyb2xsZXIuY29udHJvbGxlcnMgPSBjb250cm9sbGVycztcbmNvcmVfY29udHJvbGxlci5EYXRhc2V0Q29udHJvbGxlciA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXI7XG5jb3JlX2NvbnRyb2xsZXIuZGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzO1xuY29yZV9jb250cm9sbGVyLkVsZW1lbnQgPSBjb3JlX2VsZW1lbnQ7XG5jb3JlX2NvbnRyb2xsZXIuZWxlbWVudHMgPSBlbGVtZW50cztcbmNvcmVfY29udHJvbGxlci5JbnRlcmFjdGlvbiA9IGNvcmVfaW50ZXJhY3Rpb247XG5jb3JlX2NvbnRyb2xsZXIubGF5b3V0cyA9IGNvcmVfbGF5b3V0cztcbmNvcmVfY29udHJvbGxlci5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuY29yZV9jb250cm9sbGVyLnBsdWdpbnMgPSBjb3JlX3BsdWdpbnM7XG5jb3JlX2NvbnRyb2xsZXIuU2NhbGUgPSBjb3JlX3NjYWxlO1xuY29yZV9jb250cm9sbGVyLnNjYWxlU2VydmljZSA9IGNvcmVfc2NhbGVTZXJ2aWNlO1xuY29yZV9jb250cm9sbGVyLlRpY2tzID0gY29yZV90aWNrcztcbmNvcmVfY29udHJvbGxlci5Ub29sdGlwID0gY29yZV90b29sdGlwO1xuXG4vLyBSZWdpc3RlciBidWlsdC1pbiBzY2FsZXNcblxuY29yZV9jb250cm9sbGVyLmhlbHBlcnMuZWFjaChzY2FsZXMsIGZ1bmN0aW9uKHNjYWxlLCB0eXBlKSB7XG5cdGNvcmVfY29udHJvbGxlci5zY2FsZVNlcnZpY2UucmVnaXN0ZXJTY2FsZVR5cGUodHlwZSwgc2NhbGUsIHNjYWxlLl9kZWZhdWx0cyk7XG59KTtcblxuLy8gTG9hZCB0byByZWdpc3RlciBidWlsdC1pbiBhZGFwdGVycyAoYXMgc2lkZSBlZmZlY3RzKVxuXG5cbi8vIExvYWRpbmcgYnVpbHQtaW4gcGx1Z2luc1xuXG5mb3IgKHZhciBrIGluIHBsdWdpbnMpIHtcblx0aWYgKHBsdWdpbnMuaGFzT3duUHJvcGVydHkoaykpIHtcblx0XHRjb3JlX2NvbnRyb2xsZXIucGx1Z2lucy5yZWdpc3RlcihwbHVnaW5zW2tdKTtcblx0fVxufVxuXG5jb3JlX2NvbnRyb2xsZXIucGxhdGZvcm0uaW5pdGlhbGl6ZSgpO1xuXG52YXIgc3JjID0gY29yZV9jb250cm9sbGVyO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdHdpbmRvdy5DaGFydCA9IGNvcmVfY29udHJvbGxlcjtcbn1cblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuICogQG5hbWVzcGFjZSBDaGFydC5DaGFydFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLkNoYXJ0ID0gY29yZV9jb250cm9sbGVyO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuTGVnZW5kXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS41XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIuTGVnZW5kID0gcGx1Z2lucy5sZWdlbmQuX2VsZW1lbnQ7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuICogQG5hbWVzcGFjZSBDaGFydC5UaXRsZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjEuNVxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLlRpdGxlID0gcGx1Z2lucy50aXRsZS5fZWxlbWVudDtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LnBsdWdpbnMgaW5zdGVhZFxuICogQG5hbWVzcGFjZSBDaGFydC5wbHVnaW5TZXJ2aWNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS41XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIucGx1Z2luU2VydmljZSA9IGNvcmVfY29udHJvbGxlci5wbHVnaW5zO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpbmhlcml0aW5nIGZyb20gQ2hhcnQuUGx1Z2luZ0Jhc2UgaGFzIG5vXG4gKiBlZmZlY3QsIGluc3RlYWQgc2ltcGx5IGNyZWF0ZS9yZWdpc3RlciBwbHVnaW5zIHZpYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKiBAaW50ZXJmYWNlIENoYXJ0LlBsdWdpbkJhc2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5QbHVnaW5CYXNlID0gY29yZV9jb250cm9sbGVyLkVsZW1lbnQuZXh0ZW5kKHt9KTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FudmFzIGluc3RlYWQuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmNhbnZhc0hlbHBlcnNcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5jYW52YXNIZWxwZXJzID0gY29yZV9jb250cm9sbGVyLmhlbHBlcnMuY2FudmFzO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQubGF5b3V0cyBpbnN0ZWFkLlxuICogQG5hbWVzcGFjZSBDaGFydC5sYXlvdXRTZXJ2aWNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4zXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIubGF5b3V0U2VydmljZSA9IGNvcmVfY29udHJvbGxlci5sYXlvdXRzO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkxpbmVhclNjYWxlQmFzZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjhcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5MaW5lYXJTY2FsZUJhc2UgPSBzY2FsZV9saW5lYXJiYXNlO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpbnN0ZWFkIHdlIHNob3VsZCBjcmVhdGUgYSBuZXcgQ2hhcnRcbiAqIGJ5IHNldHRpbmcgdGhlIHR5cGUgaW4gdGhlIGNvbmZpZyAoYG5ldyBDaGFydChpZCwge3R5cGU6ICd7Y2hhcnQtdHlwZX0nfWApLlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICovXG5jb3JlX2NvbnRyb2xsZXIuaGVscGVycy5lYWNoKFxuXHRbXG5cdFx0J0JhcicsXG5cdFx0J0J1YmJsZScsXG5cdFx0J0RvdWdobnV0Jyxcblx0XHQnTGluZScsXG5cdFx0J1BvbGFyQXJlYScsXG5cdFx0J1JhZGFyJyxcblx0XHQnU2NhdHRlcidcblx0XSxcblx0ZnVuY3Rpb24oa2xhc3MpIHtcblx0XHRjb3JlX2NvbnRyb2xsZXJba2xhc3NdID0gZnVuY3Rpb24oY3R4LCBjZmcpIHtcblx0XHRcdHJldHVybiBuZXcgY29yZV9jb250cm9sbGVyKGN0eCwgY29yZV9jb250cm9sbGVyLmhlbHBlcnMubWVyZ2UoY2ZnIHx8IHt9LCB7XG5cdFx0XHRcdHR5cGU6IGtsYXNzLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsga2xhc3Muc2xpY2UoMSlcblx0XHRcdH0pKTtcblx0XHR9O1xuXHR9XG4pO1xuXG5yZXR1cm4gc3JjO1xuXG59KSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///165\n")},173:function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(174);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(4).default\nvar update = add(\"52f15586\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzP2U1ZWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsR0FBOEM7QUFDcEU7QUFDQSw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLENBQWdEO0FBQ2xFLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6IjE3My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbGVhZmxldC5jc3NcIik7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vLi4vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI1MmYxNTU4NlwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2xlYWZsZXQuY3NzXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9sZWFmbGV0LmNzc1wiKTtcbiAgICAgaWYobmV3Q29udGVudC5fX2VzTW9kdWxlKSBuZXdDb250ZW50ID0gbmV3Q29udGVudC5kZWZhdWx0O1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///173\n")},174:function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3);\nvar ___CSS_LOADER_GET_URL_IMPORT___ = __webpack_require__(24);\nvar ___CSS_LOADER_URL_IMPORT_0___ = __webpack_require__(175);\nvar ___CSS_LOADER_URL_IMPORT_1___ = __webpack_require__(176);\nvar ___CSS_LOADER_URL_IMPORT_2___ = __webpack_require__(177);\nexports = ___CSS_LOADER_API_IMPORT___(false);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);\n// Module\nexports.push([module.i, "/* required styles */\\r\\n\\r\\n.leaflet-pane,\\r\\n.leaflet-tile,\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow,\\r\\n.leaflet-tile-container,\\r\\n.leaflet-pane > svg,\\r\\n.leaflet-pane > canvas,\\r\\n.leaflet-zoom-box,\\r\\n.leaflet-image-layer,\\r\\n.leaflet-layer {\\r\\n\\tposition: absolute;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n\\t}\\r\\n.leaflet-container {\\r\\n\\toverflow: hidden;\\r\\n\\t}\\r\\n.leaflet-tile,\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow {\\r\\n\\t-webkit-user-select: none;\\r\\n\\t   -moz-user-select: none;\\r\\n\\t        user-select: none;\\r\\n\\t  -webkit-user-drag: none;\\r\\n\\t}\\r\\n/* Prevents IE11 from highlighting tiles in blue */\\r\\n.leaflet-tile::selection {\\r\\n\\tbackground: transparent;\\r\\n}\\r\\n/* Safari renders non-retina tile on retina better with this, but Chrome is worse */\\r\\n.leaflet-safari .leaflet-tile {\\r\\n\\timage-rendering: -webkit-optimize-contrast;\\r\\n\\t}\\r\\n/* hack that prevents hw layers \\"stretching\\" when loading new tiles */\\r\\n.leaflet-safari .leaflet-tile-container {\\r\\n\\twidth: 1600px;\\r\\n\\theight: 1600px;\\r\\n\\t-webkit-transform-origin: 0 0;\\r\\n\\t}\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow {\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */\\r\\n/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */\\r\\n.leaflet-container .leaflet-overlay-pane svg,\\r\\n.leaflet-container .leaflet-marker-pane img,\\r\\n.leaflet-container .leaflet-shadow-pane img,\\r\\n.leaflet-container .leaflet-tile-pane img,\\r\\n.leaflet-container img.leaflet-image-layer,\\r\\n.leaflet-container .leaflet-tile {\\r\\n\\tmax-width: none !important;\\r\\n\\tmax-height: none !important;\\r\\n\\t}\\r\\n\\r\\n.leaflet-container.leaflet-touch-zoom {\\r\\n\\t-ms-touch-action: pan-x pan-y;\\r\\n\\ttouch-action: pan-x pan-y;\\r\\n\\t}\\r\\n.leaflet-container.leaflet-touch-drag {\\r\\n\\t-ms-touch-action: pinch-zoom;\\r\\n\\t/* Fallback for FF which doesn\'t support pinch-zoom */\\r\\n\\ttouch-action: none;\\r\\n\\ttouch-action: pinch-zoom;\\r\\n}\\r\\n.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {\\r\\n\\t-ms-touch-action: none;\\r\\n\\ttouch-action: none;\\r\\n}\\r\\n.leaflet-container {\\r\\n\\t-webkit-tap-highlight-color: transparent;\\r\\n}\\r\\n.leaflet-container a {\\r\\n\\t-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);\\r\\n}\\r\\n.leaflet-tile {\\r\\n\\tfilter: inherit;\\r\\n\\tvisibility: hidden;\\r\\n\\t}\\r\\n.leaflet-tile-loaded {\\r\\n\\tvisibility: inherit;\\r\\n\\t}\\r\\n.leaflet-zoom-box {\\r\\n\\twidth: 0;\\r\\n\\theight: 0;\\r\\n\\t-moz-box-sizing: border-box;\\r\\n\\t     box-sizing: border-box;\\r\\n\\tz-index: 800;\\r\\n\\t}\\r\\n/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */\\r\\n.leaflet-overlay-pane svg {\\r\\n\\t-moz-user-select: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-pane         { z-index: 400; }\\r\\n\\r\\n.leaflet-tile-pane    { z-index: 200; }\\r\\n.leaflet-overlay-pane { z-index: 400; }\\r\\n.leaflet-shadow-pane  { z-index: 500; }\\r\\n.leaflet-marker-pane  { z-index: 600; }\\r\\n.leaflet-tooltip-pane   { z-index: 650; }\\r\\n.leaflet-popup-pane   { z-index: 700; }\\r\\n\\r\\n.leaflet-map-pane canvas { z-index: 100; }\\r\\n.leaflet-map-pane svg    { z-index: 200; }\\r\\n\\r\\n.leaflet-vml-shape {\\r\\n\\twidth: 1px;\\r\\n\\theight: 1px;\\r\\n\\t}\\r\\n.lvml {\\r\\n\\tbehavior: url(#default#VML);\\r\\n\\tdisplay: inline-block;\\r\\n\\tposition: absolute;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* control positioning */\\r\\n\\r\\n.leaflet-control {\\r\\n\\tposition: relative;\\r\\n\\tz-index: 800;\\r\\n\\tpointer-events: visiblePainted; /* IE 9-10 doesn\'t have auto */\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n.leaflet-top,\\r\\n.leaflet-bottom {\\r\\n\\tposition: absolute;\\r\\n\\tz-index: 1000;\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n.leaflet-top {\\r\\n\\ttop: 0;\\r\\n\\t}\\r\\n.leaflet-right {\\r\\n\\tright: 0;\\r\\n\\t}\\r\\n.leaflet-bottom {\\r\\n\\tbottom: 0;\\r\\n\\t}\\r\\n.leaflet-left {\\r\\n\\tleft: 0;\\r\\n\\t}\\r\\n.leaflet-control {\\r\\n\\tfloat: left;\\r\\n\\tclear: both;\\r\\n\\t}\\r\\n.leaflet-right .leaflet-control {\\r\\n\\tfloat: right;\\r\\n\\t}\\r\\n.leaflet-top .leaflet-control {\\r\\n\\tmargin-top: 10px;\\r\\n\\t}\\r\\n.leaflet-bottom .leaflet-control {\\r\\n\\tmargin-bottom: 10px;\\r\\n\\t}\\r\\n.leaflet-left .leaflet-control {\\r\\n\\tmargin-left: 10px;\\r\\n\\t}\\r\\n.leaflet-right .leaflet-control {\\r\\n\\tmargin-right: 10px;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* zoom and fade animations */\\r\\n\\r\\n.leaflet-fade-anim .leaflet-tile {\\r\\n\\twill-change: opacity;\\r\\n\\t}\\r\\n.leaflet-fade-anim .leaflet-popup {\\r\\n\\topacity: 0;\\r\\n\\t-webkit-transition: opacity 0.2s linear;\\r\\n\\t   -moz-transition: opacity 0.2s linear;\\r\\n\\t        transition: opacity 0.2s linear;\\r\\n\\t}\\r\\n.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {\\r\\n\\topacity: 1;\\r\\n\\t}\\r\\n.leaflet-zoom-animated {\\r\\n\\t-webkit-transform-origin: 0 0;\\r\\n\\t    -ms-transform-origin: 0 0;\\r\\n\\t        transform-origin: 0 0;\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-zoom-animated {\\r\\n\\twill-change: transform;\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-zoom-animated {\\r\\n\\t-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t   -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t        transition:         transform 0.25s cubic-bezier(0,0,0.25,1);\\r\\n\\t}\\r\\n.leaflet-zoom-anim .leaflet-tile,\\r\\n.leaflet-pan-anim .leaflet-tile {\\r\\n\\t-webkit-transition: none;\\r\\n\\t   -moz-transition: none;\\r\\n\\t        transition: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-zoom-anim .leaflet-zoom-hide {\\r\\n\\tvisibility: hidden;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* cursors */\\r\\n\\r\\n.leaflet-interactive {\\r\\n\\tcursor: pointer;\\r\\n\\t}\\r\\n.leaflet-grab {\\r\\n\\tcursor: -webkit-grab;\\r\\n\\tcursor:    -moz-grab;\\r\\n\\tcursor:         grab;\\r\\n\\t}\\r\\n.leaflet-crosshair,\\r\\n.leaflet-crosshair .leaflet-interactive {\\r\\n\\tcursor: crosshair;\\r\\n\\t}\\r\\n.leaflet-popup-pane,\\r\\n.leaflet-control {\\r\\n\\tcursor: auto;\\r\\n\\t}\\r\\n.leaflet-dragging .leaflet-grab,\\r\\n.leaflet-dragging .leaflet-grab .leaflet-interactive,\\r\\n.leaflet-dragging .leaflet-marker-draggable {\\r\\n\\tcursor: move;\\r\\n\\tcursor: -webkit-grabbing;\\r\\n\\tcursor:    -moz-grabbing;\\r\\n\\tcursor:         grabbing;\\r\\n\\t}\\r\\n\\r\\n/* marker & overlays interactivity */\\r\\n.leaflet-marker-icon,\\r\\n.leaflet-marker-shadow,\\r\\n.leaflet-image-layer,\\r\\n.leaflet-pane > svg path,\\r\\n.leaflet-tile-container {\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n\\r\\n.leaflet-marker-icon.leaflet-interactive,\\r\\n.leaflet-image-layer.leaflet-interactive,\\r\\n.leaflet-pane > svg path.leaflet-interactive,\\r\\nsvg.leaflet-image-layer.leaflet-interactive path {\\r\\n\\tpointer-events: visiblePainted; /* IE 9-10 doesn\'t have auto */\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n\\r\\n/* visual tweaks */\\r\\n\\r\\n.leaflet-container {\\r\\n\\tbackground: #ddd;\\r\\n\\toutline: 0;\\r\\n\\t}\\r\\n.leaflet-container a {\\r\\n\\tcolor: #0078A8;\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-active {\\r\\n\\toutline: 2px solid orange;\\r\\n\\t}\\r\\n.leaflet-zoom-box {\\r\\n\\tborder: 2px dotted #38f;\\r\\n\\tbackground: rgba(255,255,255,0.5);\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* general typography */\\r\\n.leaflet-container {\\r\\n\\tfont: 12px/1.5 \\"Helvetica Neue\\", Arial, Helvetica, sans-serif;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* general toolbar styles */\\r\\n\\r\\n.leaflet-bar {\\r\\n\\tbox-shadow: 0 1px 5px rgba(0,0,0,0.65);\\r\\n\\tborder-radius: 4px;\\r\\n\\t}\\r\\n.leaflet-bar a,\\r\\n.leaflet-bar a:hover {\\r\\n\\tbackground-color: #fff;\\r\\n\\tborder-bottom: 1px solid #ccc;\\r\\n\\twidth: 26px;\\r\\n\\theight: 26px;\\r\\n\\tline-height: 26px;\\r\\n\\tdisplay: block;\\r\\n\\ttext-align: center;\\r\\n\\ttext-decoration: none;\\r\\n\\tcolor: black;\\r\\n\\t}\\r\\n.leaflet-bar a,\\r\\n.leaflet-control-layers-toggle {\\r\\n\\tbackground-position: 50% 50%;\\r\\n\\tbackground-repeat: no-repeat;\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n.leaflet-bar a:hover {\\r\\n\\tbackground-color: #f4f4f4;\\r\\n\\t}\\r\\n.leaflet-bar a:first-child {\\r\\n\\tborder-top-left-radius: 4px;\\r\\n\\tborder-top-right-radius: 4px;\\r\\n\\t}\\r\\n.leaflet-bar a:last-child {\\r\\n\\tborder-bottom-left-radius: 4px;\\r\\n\\tborder-bottom-right-radius: 4px;\\r\\n\\tborder-bottom: none;\\r\\n\\t}\\r\\n.leaflet-bar a.leaflet-disabled {\\r\\n\\tcursor: default;\\r\\n\\tbackground-color: #f4f4f4;\\r\\n\\tcolor: #bbb;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-bar a {\\r\\n\\twidth: 30px;\\r\\n\\theight: 30px;\\r\\n\\tline-height: 30px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-bar a:first-child {\\r\\n\\tborder-top-left-radius: 2px;\\r\\n\\tborder-top-right-radius: 2px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-bar a:last-child {\\r\\n\\tborder-bottom-left-radius: 2px;\\r\\n\\tborder-bottom-right-radius: 2px;\\r\\n\\t}\\r\\n\\r\\n/* zoom control */\\r\\n\\r\\n.leaflet-control-zoom-in,\\r\\n.leaflet-control-zoom-out {\\r\\n\\tfont: bold 18px \'Lucida Console\', Monaco, monospace;\\r\\n\\ttext-indent: 1px;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {\\r\\n\\tfont-size: 22px;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* layers control */\\r\\n\\r\\n.leaflet-control-layers {\\r\\n\\tbox-shadow: 0 1px 5px rgba(0,0,0,0.4);\\r\\n\\tbackground: #fff;\\r\\n\\tborder-radius: 5px;\\r\\n\\t}\\r\\n.leaflet-control-layers-toggle {\\r\\n\\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\\r\\n\\twidth: 36px;\\r\\n\\theight: 36px;\\r\\n\\t}\\r\\n.leaflet-retina .leaflet-control-layers-toggle {\\r\\n\\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ");\\r\\n\\tbackground-size: 26px 26px;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-control-layers-toggle {\\r\\n\\twidth: 44px;\\r\\n\\theight: 44px;\\r\\n\\t}\\r\\n.leaflet-control-layers .leaflet-control-layers-list,\\r\\n.leaflet-control-layers-expanded .leaflet-control-layers-toggle {\\r\\n\\tdisplay: none;\\r\\n\\t}\\r\\n.leaflet-control-layers-expanded .leaflet-control-layers-list {\\r\\n\\tdisplay: block;\\r\\n\\tposition: relative;\\r\\n\\t}\\r\\n.leaflet-control-layers-expanded {\\r\\n\\tpadding: 6px 10px 6px 6px;\\r\\n\\tcolor: #333;\\r\\n\\tbackground: #fff;\\r\\n\\t}\\r\\n.leaflet-control-layers-scrollbar {\\r\\n\\toverflow-y: scroll;\\r\\n\\toverflow-x: hidden;\\r\\n\\tpadding-right: 5px;\\r\\n\\t}\\r\\n.leaflet-control-layers-selector {\\r\\n\\tmargin-top: 2px;\\r\\n\\tposition: relative;\\r\\n\\ttop: 1px;\\r\\n\\t}\\r\\n.leaflet-control-layers label {\\r\\n\\tdisplay: block;\\r\\n\\t}\\r\\n.leaflet-control-layers-separator {\\r\\n\\theight: 0;\\r\\n\\tborder-top: 1px solid #ddd;\\r\\n\\tmargin: 5px -10px 5px -6px;\\r\\n\\t}\\r\\n\\r\\n/* Default icon URLs */\\r\\n.leaflet-default-icon-path {\\r\\n\\tbackground-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ");\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* attribution and scale controls */\\r\\n\\r\\n.leaflet-container .leaflet-control-attribution {\\r\\n\\tbackground: #fff;\\r\\n\\tbackground: rgba(255, 255, 255, 0.7);\\r\\n\\tmargin: 0;\\r\\n\\t}\\r\\n.leaflet-control-attribution,\\r\\n.leaflet-control-scale-line {\\r\\n\\tpadding: 0 5px;\\r\\n\\tcolor: #333;\\r\\n\\t}\\r\\n.leaflet-control-attribution a {\\r\\n\\ttext-decoration: none;\\r\\n\\t}\\r\\n.leaflet-control-attribution a:hover {\\r\\n\\ttext-decoration: underline;\\r\\n\\t}\\r\\n.leaflet-container .leaflet-control-attribution,\\r\\n.leaflet-container .leaflet-control-scale {\\r\\n\\tfont-size: 11px;\\r\\n\\t}\\r\\n.leaflet-left .leaflet-control-scale {\\r\\n\\tmargin-left: 5px;\\r\\n\\t}\\r\\n.leaflet-bottom .leaflet-control-scale {\\r\\n\\tmargin-bottom: 5px;\\r\\n\\t}\\r\\n.leaflet-control-scale-line {\\r\\n\\tborder: 2px solid #777;\\r\\n\\tborder-top: none;\\r\\n\\tline-height: 1.1;\\r\\n\\tpadding: 2px 5px 1px;\\r\\n\\tfont-size: 11px;\\r\\n\\twhite-space: nowrap;\\r\\n\\toverflow: hidden;\\r\\n\\t-moz-box-sizing: border-box;\\r\\n\\t     box-sizing: border-box;\\r\\n\\r\\n\\tbackground: #fff;\\r\\n\\tbackground: rgba(255, 255, 255, 0.5);\\r\\n\\t}\\r\\n.leaflet-control-scale-line:not(:first-child) {\\r\\n\\tborder-top: 2px solid #777;\\r\\n\\tborder-bottom: none;\\r\\n\\tmargin-top: -2px;\\r\\n\\t}\\r\\n.leaflet-control-scale-line:not(:first-child):not(:last-child) {\\r\\n\\tborder-bottom: 2px solid #777;\\r\\n\\t}\\r\\n\\r\\n.leaflet-touch .leaflet-control-attribution,\\r\\n.leaflet-touch .leaflet-control-layers,\\r\\n.leaflet-touch .leaflet-bar {\\r\\n\\tbox-shadow: none;\\r\\n\\t}\\r\\n.leaflet-touch .leaflet-control-layers,\\r\\n.leaflet-touch .leaflet-bar {\\r\\n\\tborder: 2px solid rgba(0,0,0,0.2);\\r\\n\\tbackground-clip: padding-box;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* popup */\\r\\n\\r\\n.leaflet-popup {\\r\\n\\tposition: absolute;\\r\\n\\ttext-align: center;\\r\\n\\tmargin-bottom: 20px;\\r\\n\\t}\\r\\n.leaflet-popup-content-wrapper {\\r\\n\\tpadding: 1px;\\r\\n\\ttext-align: left;\\r\\n\\tborder-radius: 12px;\\r\\n\\t}\\r\\n.leaflet-popup-content {\\r\\n\\tmargin: 13px 19px;\\r\\n\\tline-height: 1.4;\\r\\n\\t}\\r\\n.leaflet-popup-content p {\\r\\n\\tmargin: 18px 0;\\r\\n\\t}\\r\\n.leaflet-popup-tip-container {\\r\\n\\twidth: 40px;\\r\\n\\theight: 20px;\\r\\n\\tposition: absolute;\\r\\n\\tleft: 50%;\\r\\n\\tmargin-left: -20px;\\r\\n\\toverflow: hidden;\\r\\n\\tpointer-events: none;\\r\\n\\t}\\r\\n.leaflet-popup-tip {\\r\\n\\twidth: 17px;\\r\\n\\theight: 17px;\\r\\n\\tpadding: 1px;\\r\\n\\r\\n\\tmargin: -10px auto 0;\\r\\n\\r\\n\\t-webkit-transform: rotate(45deg);\\r\\n\\t   -moz-transform: rotate(45deg);\\r\\n\\t    -ms-transform: rotate(45deg);\\r\\n\\t        transform: rotate(45deg);\\r\\n\\t}\\r\\n.leaflet-popup-content-wrapper,\\r\\n.leaflet-popup-tip {\\r\\n\\tbackground: white;\\r\\n\\tcolor: #333;\\r\\n\\tbox-shadow: 0 3px 14px rgba(0,0,0,0.4);\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-popup-close-button {\\r\\n\\tposition: absolute;\\r\\n\\ttop: 0;\\r\\n\\tright: 0;\\r\\n\\tpadding: 4px 4px 0 0;\\r\\n\\tborder: none;\\r\\n\\ttext-align: center;\\r\\n\\twidth: 18px;\\r\\n\\theight: 14px;\\r\\n\\tfont: 16px/14px Tahoma, Verdana, sans-serif;\\r\\n\\tcolor: #c3c3c3;\\r\\n\\ttext-decoration: none;\\r\\n\\tfont-weight: bold;\\r\\n\\tbackground: transparent;\\r\\n\\t}\\r\\n.leaflet-container a.leaflet-popup-close-button:hover {\\r\\n\\tcolor: #999;\\r\\n\\t}\\r\\n.leaflet-popup-scrolled {\\r\\n\\toverflow: auto;\\r\\n\\tborder-bottom: 1px solid #ddd;\\r\\n\\tborder-top: 1px solid #ddd;\\r\\n\\t}\\r\\n\\r\\n.leaflet-oldie .leaflet-popup-content-wrapper {\\r\\n\\tzoom: 1;\\r\\n\\t}\\r\\n.leaflet-oldie .leaflet-popup-tip {\\r\\n\\twidth: 24px;\\r\\n\\tmargin: 0 auto;\\r\\n\\r\\n\\t-ms-filter: \\"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)\\";\\r\\n\\tfilter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);\\r\\n\\t}\\r\\n.leaflet-oldie .leaflet-popup-tip-container {\\r\\n\\tmargin-top: -1px;\\r\\n\\t}\\r\\n\\r\\n.leaflet-oldie .leaflet-control-zoom,\\r\\n.leaflet-oldie .leaflet-control-layers,\\r\\n.leaflet-oldie .leaflet-popup-content-wrapper,\\r\\n.leaflet-oldie .leaflet-popup-tip {\\r\\n\\tborder: 1px solid #999;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* div icon */\\r\\n\\r\\n.leaflet-div-icon {\\r\\n\\tbackground: #fff;\\r\\n\\tborder: 1px solid #666;\\r\\n\\t}\\r\\n\\r\\n\\r\\n/* Tooltip */\\r\\n/* Base styles for the element that has a tooltip */\\r\\n.leaflet-tooltip {\\r\\n\\tposition: absolute;\\r\\n\\tpadding: 6px;\\r\\n\\tbackground-color: #fff;\\r\\n\\tborder: 1px solid #fff;\\r\\n\\tborder-radius: 3px;\\r\\n\\tcolor: #222;\\r\\n\\twhite-space: nowrap;\\r\\n\\t-webkit-user-select: none;\\r\\n\\t-moz-user-select: none;\\r\\n\\t-ms-user-select: none;\\r\\n\\tuser-select: none;\\r\\n\\tpointer-events: none;\\r\\n\\tbox-shadow: 0 1px 3px rgba(0,0,0,0.4);\\r\\n\\t}\\r\\n.leaflet-tooltip.leaflet-clickable {\\r\\n\\tcursor: pointer;\\r\\n\\tpointer-events: auto;\\r\\n\\t}\\r\\n.leaflet-tooltip-top:before,\\r\\n.leaflet-tooltip-bottom:before,\\r\\n.leaflet-tooltip-left:before,\\r\\n.leaflet-tooltip-right:before {\\r\\n\\tposition: absolute;\\r\\n\\tpointer-events: none;\\r\\n\\tborder: 6px solid transparent;\\r\\n\\tbackground: transparent;\\r\\n\\tcontent: \\"\\";\\r\\n\\t}\\r\\n\\r\\n/* Directions */\\r\\n\\r\\n.leaflet-tooltip-bottom {\\r\\n\\tmargin-top: 6px;\\r\\n}\\r\\n.leaflet-tooltip-top {\\r\\n\\tmargin-top: -6px;\\r\\n}\\r\\n.leaflet-tooltip-bottom:before,\\r\\n.leaflet-tooltip-top:before {\\r\\n\\tleft: 50%;\\r\\n\\tmargin-left: -6px;\\r\\n\\t}\\r\\n.leaflet-tooltip-top:before {\\r\\n\\tbottom: 0;\\r\\n\\tmargin-bottom: -12px;\\r\\n\\tborder-top-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-bottom:before {\\r\\n\\ttop: 0;\\r\\n\\tmargin-top: -12px;\\r\\n\\tmargin-left: -6px;\\r\\n\\tborder-bottom-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-left {\\r\\n\\tmargin-left: -6px;\\r\\n}\\r\\n.leaflet-tooltip-right {\\r\\n\\tmargin-left: 6px;\\r\\n}\\r\\n.leaflet-tooltip-left:before,\\r\\n.leaflet-tooltip-right:before {\\r\\n\\ttop: 50%;\\r\\n\\tmargin-top: -6px;\\r\\n\\t}\\r\\n.leaflet-tooltip-left:before {\\r\\n\\tright: 0;\\r\\n\\tmargin-right: -12px;\\r\\n\\tborder-left-color: #fff;\\r\\n\\t}\\r\\n.leaflet-tooltip-right:before {\\r\\n\\tleft: 0;\\r\\n\\tmargin-left: -12px;\\r\\n\\tborder-right-color: #fff;\\r\\n\\t}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzPzRmODMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxDQUFzQztBQUNoRixzQ0FBc0MsbUJBQU8sQ0FBQyxFQUF5QztBQUN2RixvQ0FBb0MsbUJBQU8sQ0FBQyxHQUFxQjtBQUNqRSxvQ0FBb0MsbUJBQU8sQ0FBQyxHQUF3QjtBQUNwRSxvQ0FBb0MsbUJBQU8sQ0FBQyxHQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFTLHNRQUFzUSx5QkFBeUIsY0FBYyxhQUFhLE9BQU8sd0JBQXdCLHVCQUF1QixPQUFPLHVFQUF1RSxnQ0FBZ0MsZ0NBQWdDLGdDQUFnQyxnQ0FBZ0MsT0FBTyxxRkFBcUYsOEJBQThCLEtBQUssMkhBQTJILGlEQUFpRCxPQUFPLHlIQUF5SCxvQkFBb0IscUJBQXFCLG9DQUFvQyxPQUFPLHFEQUFxRCxxQkFBcUIsT0FBTyxtZEFBbWQsaUNBQWlDLGtDQUFrQyxPQUFPLCtDQUErQyxvQ0FBb0MsZ0NBQWdDLE9BQU8sMkNBQTJDLG1DQUFtQyxxRkFBcUYsK0JBQStCLEtBQUssOERBQThELDZCQUE2Qix5QkFBeUIsS0FBSyx3QkFBd0IsK0NBQStDLEtBQUssMEJBQTBCLDJEQUEyRCxLQUFLLG1CQUFtQixzQkFBc0IseUJBQXlCLE9BQU8sMEJBQTBCLDBCQUEwQixPQUFPLHVCQUF1QixlQUFlLGdCQUFnQixrQ0FBa0Msa0NBQWtDLG1CQUFtQixPQUFPLDJHQUEyRyw2QkFBNkIsT0FBTywrQkFBK0IsY0FBYyxFQUFFLCtCQUErQixjQUFjLEVBQUUsMkJBQTJCLGNBQWMsRUFBRSwyQkFBMkIsY0FBYyxFQUFFLDJCQUEyQixjQUFjLEVBQUUsNkJBQTZCLGNBQWMsRUFBRSwyQkFBMkIsY0FBYyxFQUFFLGtDQUFrQyxjQUFjLEVBQUUsOEJBQThCLGNBQWMsRUFBRSw0QkFBNEIsaUJB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Z0NBQWdDLE9BQU8sMkJBQTJCLHdCQUF3QixLQUFLLDRCQUE0Qix1QkFBdUIsS0FBSyxvRUFBb0UsZUFBZSx1QkFBdUIsT0FBTyxrQ0FBa0MsZUFBZSwwQkFBMEIsOEJBQThCLE9BQU8sbUNBQW1DLGNBQWMseUJBQXlCLCtCQUErQixPQUFPO0FBQzVwZjtBQUNBIiwiZmlsZSI6IjE3NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fID0gcmVxdWlyZShcIi4vaW1hZ2VzL2xheWVycy5wbmdcIik7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzFfX18gPSByZXF1aXJlKFwiLi9pbWFnZXMvbGF5ZXJzLTJ4LnBuZ1wiKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMl9fXyA9IHJlcXVpcmUoXCIuL2ltYWdlcy9tYXJrZXItaWNvbi5wbmdcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8wX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMF9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMV9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzFfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzJfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8yX19fKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyogcmVxdWlyZWQgc3R5bGVzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtcGFuZSxcXHJcXG4ubGVhZmxldC10aWxlLFxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLFxcclxcbi5sZWFmbGV0LW1hcmtlci1zaGFkb3csXFxyXFxuLmxlYWZsZXQtdGlsZS1jb250YWluZXIsXFxyXFxuLmxlYWZsZXQtcGFuZSA+IHN2ZyxcXHJcXG4ubGVhZmxldC1wYW5lID4gY2FudmFzLFxcclxcbi5sZWFmbGV0LXpvb20tYm94LFxcclxcbi5sZWFmbGV0LWltYWdlLWxheWVyLFxcclxcbi5sZWFmbGV0LWxheWVyIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciB7XFxyXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdGlsZSxcXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93IHtcXHJcXG5cXHQtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdCAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0ICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQgIC13ZWJraXQtdXNlci1kcmFnOiBub25lO1xcclxcblxcdH1cXHJcXG4vKiBQcmV2ZW50cyBJRTExIGZyb20gaGlnaGxpZ2h0aW5nIHRpbGVzIGluIGJsdWUgKi9cXHJcXG4ubGVhZmxldC10aWxlOjpzZWxlY3Rpb24ge1xcclxcblxcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG4vKiBTYWZhcmkgcmVuZGVycyBub24tcmV0aW5hIHRpbGUgb24gcmV0aW5hIGJldHRlciB3aXRoIHRoaXMsIGJ1dCBDaHJvbWUgaXMgd29yc2UgKi9cXHJcXG4ubGVhZmxldC1zYWZhcmkgLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0aW1hZ2UtcmVuZGVyaW5nOiAtd2Via2l0LW9wdGltaXplLWNvbnRyYXN0O1xcclxcblxcdH1cXHJcXG4vKiBoYWNrIHRoYXQgcHJldmVudHMgaHcgbGF5ZXJzIFxcXCJzdHJldGNoaW5nXFxcIiB3aGVuIGxvYWRpbmcgbmV3IHRpbGVzICovXFxyXFxuLmxlYWZsZXQtc2FmYXJpIC5sZWFmbGV0LXRpbGUtY29udGFpbmVyIHtcXHJcXG5cXHR3aWR0aDogMTYwMHB4O1xcclxcblxcdGhlaWdodDogMTYwMHB4O1xcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93IHtcXHJcXG5cXHRkaXNwbGF5OiBibG9jaztcXHJcXG5cXHR9XFxyXFxuLyogLmxlYWZsZXQtY29udGFpbmVyIHN2ZzogcmVzZXQgc3ZnIG1heC13aWR0aCBkZWNsZXJhdGlvbiBzaGlwcGVkIGluIEpvb21sYSEgKGpvb21sYS5vcmcpIDMueCAqL1xcclxcbi8qIC5sZWFmbGV0LWNvbnRhaW5lciBpbWc6IG1hcCBpcyBicm9rZW4gaW4gRkYgaWYgeW91IGhhdmUgbWF4LXdpZHRoOiAxMDAlIG9uIHRpbGVzICovXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LW92ZXJsYXktcGFuZSBzdmcsXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LW1hcmtlci1wYW5lIGltZyxcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtc2hhZG93LXBhbmUgaW1nLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC10aWxlLXBhbmUgaW1nLFxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBpbWcubGVhZmxldC1pbWFnZS1sYXllcixcXHJcXG4ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0bWF4LXdpZHRoOiBub25lICFpbXBvcnRhbnQ7XFxyXFxuXFx0bWF4LWhlaWdodDogbm9uZSAhaW1wb3J0YW50O1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250YWluZXIubGVhZmxldC10b3VjaC16b29tIHtcXHJcXG5cXHQtbXMtdG91Y2gtYWN0aW9uOiBwYW4teCBwYW4teTtcXHJcXG5cXHR0b3VjaC1hY3Rpb246IHBhbi14IHBhbi15O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250YWluZXIubGVhZmxldC10b3VjaC1kcmFnIHtcXHJcXG5cXHQtbXMtdG91Y2gtYWN0aW9uOiBwaW5jaC16b29tO1xcclxcblxcdC8qIEZhbGxiYWNrIGZvciBGRiB3aGljaCBkb2Vzbid0IHN1cHBvcnQgcGluY2gtem9vbSAqL1xcclxcblxcdHRvdWNoLWFjdGlvbjogbm9uZTtcXHJcXG5cXHR0b3VjaC1hY3Rpb246IHBpbmNoLXpvb207XFxyXFxufVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLWRyYWcubGVhZmxldC10b3VjaC16b29tIHtcXHJcXG5cXHQtbXMtdG91Y2gtYWN0aW9uOiBub25lO1xcclxcblxcdHRvdWNoLWFjdGlvbjogbm9uZTtcXHJcXG59XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHQtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG4ubGVhZmxldC1jb250YWluZXIgYSB7XFxyXFxuXFx0LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDUxLCAxODEsIDIyOSwgMC40KTtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0ZmlsdGVyOiBpbmhlcml0O1xcclxcblxcdHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdGlsZS1sb2FkZWQge1xcclxcblxcdHZpc2liaWxpdHk6IGluaGVyaXQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYm94IHtcXHJcXG5cXHR3aWR0aDogMDtcXHJcXG5cXHRoZWlnaHQ6IDA7XFxyXFxuXFx0LW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcdCAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG5cXHR6LWluZGV4OiA4MDA7XFxyXFxuXFx0fVxcclxcbi8qIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4ODMxOSAqL1xcclxcbi5sZWFmbGV0LW92ZXJsYXktcGFuZSBzdmcge1xcclxcblxcdC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXBhbmUgICAgICAgICB7IHotaW5kZXg6IDQwMDsgfVxcclxcblxcclxcbi5sZWFmbGV0LXRpbGUtcGFuZSAgICB7IHotaW5kZXg6IDIwMDsgfVxcclxcbi5sZWFmbGV0LW92ZXJsYXktcGFuZSB7IHotaW5kZXg6IDQwMDsgfVxcclxcbi5sZWFmbGV0LXNoYWRvdy1wYW5lICB7IHotaW5kZXg6IDUwMDsgfVxcclxcbi5sZWFmbGV0LW1hcmtlci1wYW5lICB7IHotaW5kZXg6IDYwMDsgfVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtcGFuZSAgIHsgei1pbmRleDogNjUwOyB9XFxyXFxuLmxlYWZsZXQtcG9wdXAtcGFuZSAgIHsgei1pbmRleDogNzAwOyB9XFxyXFxuXFxyXFxuLmxlYWZsZXQtbWFwLXBhbmUgY2FudmFzIHsgei1pbmRleDogMTAwOyB9XFxyXFxuLmxlYWZsZXQtbWFwLXBhbmUgc3ZnICAgIHsgei1pbmRleDogMjAwOyB9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdm1sLXNoYXBlIHtcXHJcXG5cXHR3aWR0aDogMXB4O1xcclxcblxcdGhlaWdodDogMXB4O1xcclxcblxcdH1cXHJcXG4ubHZtbCB7XFxyXFxuXFx0YmVoYXZpb3I6IHVybCgjZGVmYXVsdCNWTUwpO1xcclxcblxcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGNvbnRyb2wgcG9zaXRpb25pbmcgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuXFx0ei1pbmRleDogODAwO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiB2aXNpYmxlUGFpbnRlZDsgLyogSUUgOS0xMCBkb2Vzbid0IGhhdmUgYXV0byAqL1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3AsXFxyXFxuLmxlYWZsZXQtYm90dG9tIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0ei1pbmRleDogMTAwMDtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9wIHtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJpZ2h0IHtcXHJcXG5cXHRyaWdodDogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYm90dG9tIHtcXHJcXG5cXHRib3R0b206IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWxlZnQge1xcclxcblxcdGxlZnQ6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wge1xcclxcblxcdGZsb2F0OiBsZWZ0O1xcclxcblxcdGNsZWFyOiBib3RoO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1yaWdodCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRmbG9hdDogcmlnaHQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvcCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiAxMHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1ib3R0b20gLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbTogMTBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtbGVmdCAubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRtYXJnaW4tbGVmdDogMTBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcmlnaHQgLmxlYWZsZXQtY29udHJvbCB7XFxyXFxuXFx0bWFyZ2luLXJpZ2h0OiAxMHB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiB6b29tIGFuZCBmYWRlIGFuaW1hdGlvbnMgKi9cXHJcXG5cXHJcXG4ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0d2lsbC1jaGFuZ2U6IG9wYWNpdHk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWZhZGUtYW5pbSAubGVhZmxldC1wb3B1cCB7XFxyXFxuXFx0b3BhY2l0eTogMDtcXHJcXG5cXHQtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBsaW5lYXI7XFxyXFxuXFx0ICAgLW1vei10cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgbGluZWFyO1xcclxcblxcdCAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGxpbmVhcjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtZmFkZS1hbmltIC5sZWFmbGV0LW1hcC1wYW5lIC5sZWFmbGV0LXBvcHVwIHtcXHJcXG5cXHRvcGFjaXR5OiAxO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC16b29tLWFuaW1hdGVkIHtcXHJcXG5cXHQtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHQgICAgLW1zLXRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHQgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDAgMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20tYW5pbWF0ZWQge1xcclxcblxcdHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYW5pbSAubGVhZmxldC16b29tLWFuaW1hdGVkIHtcXHJcXG5cXHQtd2Via2l0LXRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtIDAuMjVzIGN1YmljLWJlemllcigwLDAsMC4yNSwxKTtcXHJcXG5cXHQgICAtbW96LXRyYW5zaXRpb246ICAgIC1tb3otdHJhbnNmb3JtIDAuMjVzIGN1YmljLWJlemllcigwLDAsMC4yNSwxKTtcXHJcXG5cXHQgICAgICAgIHRyYW5zaXRpb246ICAgICAgICAgdHJhbnNmb3JtIDAuMjVzIGN1YmljLWJlemllcigwLDAsMC4yNSwxKTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXRpbGUsXFxyXFxuLmxlYWZsZXQtcGFuLWFuaW0gLmxlYWZsZXQtdGlsZSB7XFxyXFxuXFx0LXdlYmtpdC10cmFuc2l0aW9uOiBub25lO1xcclxcblxcdCAgIC1tb3otdHJhbnNpdGlvbjogbm9uZTtcXHJcXG5cXHQgICAgICAgIHRyYW5zaXRpb246IG5vbmU7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LXpvb20tYW5pbSAubGVhZmxldC16b29tLWhpZGUge1xcclxcblxcdHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogY3Vyc29ycyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWludGVyYWN0aXZlIHtcXHJcXG5cXHRjdXJzb3I6IHBvaW50ZXI7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWdyYWIge1xcclxcblxcdGN1cnNvcjogLXdlYmtpdC1ncmFiO1xcclxcblxcdGN1cnNvcjogICAgLW1vei1ncmFiO1xcclxcblxcdGN1cnNvcjogICAgICAgICBncmFiO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jcm9zc2hhaXIsXFxyXFxuLmxlYWZsZXQtY3Jvc3NoYWlyIC5sZWFmbGV0LWludGVyYWN0aXZlIHtcXHJcXG5cXHRjdXJzb3I6IGNyb3NzaGFpcjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtcGFuZSxcXHJcXG4ubGVhZmxldC1jb250cm9sIHtcXHJcXG5cXHRjdXJzb3I6IGF1dG87XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWRyYWdnaW5nIC5sZWFmbGV0LWdyYWIsXFxyXFxuLmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtZ3JhYiAubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG4ubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlIHtcXHJcXG5cXHRjdXJzb3I6IG1vdmU7XFxyXFxuXFx0Y3Vyc29yOiAtd2Via2l0LWdyYWJiaW5nO1xcclxcblxcdGN1cnNvcjogICAgLW1vei1ncmFiYmluZztcXHJcXG5cXHRjdXJzb3I6ICAgICAgICAgZ3JhYmJpbmc7XFxyXFxuXFx0fVxcclxcblxcclxcbi8qIG1hcmtlciAmIG92ZXJsYXlzIGludGVyYWN0aXZpdHkgKi9cXHJcXG4ubGVhZmxldC1tYXJrZXItaWNvbixcXHJcXG4ubGVhZmxldC1tYXJrZXItc2hhZG93LFxcclxcbi5sZWFmbGV0LWltYWdlLWxheWVyLFxcclxcbi5sZWFmbGV0LXBhbmUgPiBzdmcgcGF0aCxcXHJcXG4ubGVhZmxldC10aWxlLWNvbnRhaW5lciB7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LW1hcmtlci1pY29uLmxlYWZsZXQtaW50ZXJhY3RpdmUsXFxyXFxuLmxlYWZsZXQtaW1hZ2UtbGF5ZXIubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG4ubGVhZmxldC1wYW5lID4gc3ZnIHBhdGgubGVhZmxldC1pbnRlcmFjdGl2ZSxcXHJcXG5zdmcubGVhZmxldC1pbWFnZS1sYXllci5sZWFmbGV0LWludGVyYWN0aXZlIHBhdGgge1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiB2aXNpYmxlUGFpbnRlZDsgLyogSUUgOS0xMCBkb2Vzbid0IGhhdmUgYXV0byAqL1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiB2aXN1YWwgdHdlYWtzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZGRkO1xcclxcblxcdG91dGxpbmU6IDA7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhIHtcXHJcXG5cXHRjb2xvcjogIzAwNzhBODtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1hY3RpdmUge1xcclxcblxcdG91dGxpbmU6IDJweCBzb2xpZCBvcmFuZ2U7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXpvb20tYm94IHtcXHJcXG5cXHRib3JkZXI6IDJweCBkb3R0ZWQgIzM4ZjtcXHJcXG5cXHRiYWNrZ3JvdW5kOiByZ2JhKDI1NSwyNTUsMjU1LDAuNSk7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGdlbmVyYWwgdHlwb2dyYXBoeSAqL1xcclxcbi5sZWFmbGV0LWNvbnRhaW5lciB7XFxyXFxuXFx0Zm9udDogMTJweC8xLjUgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogZ2VuZXJhbCB0b29sYmFyIHN0eWxlcyAqL1xcclxcblxcclxcbi5sZWFmbGV0LWJhciB7XFxyXFxuXFx0Ym94LXNoYWRvdzogMCAxcHggNXB4IHJnYmEoMCwwLDAsMC42NSk7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogNHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYSxcXHJcXG4ubGVhZmxldC1iYXIgYTpob3ZlciB7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXHJcXG5cXHRib3JkZXItYm90dG9tOiAxcHggc29saWQgI2NjYztcXHJcXG5cXHR3aWR0aDogMjZweDtcXHJcXG5cXHRoZWlnaHQ6IDI2cHg7XFxyXFxuXFx0bGluZS1oZWlnaHQ6IDI2cHg7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG5cXHRjb2xvcjogYmxhY2s7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWJhciBhLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0YmFja2dyb3VuZC1wb3NpdGlvbjogNTAlIDUwJTtcXHJcXG5cXHRiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYTpob3ZlciB7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtYmFyIGE6Zmlyc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDRweDtcXHJcXG5cXHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogNHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYTpsYXN0LWNoaWxkIHtcXHJcXG5cXHRib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA0cHg7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDRweDtcXHJcXG5cXHRib3JkZXItYm90dG9tOiBub25lO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1iYXIgYS5sZWFmbGV0LWRpc2FibGVkIHtcXHJcXG5cXHRjdXJzb3I6IGRlZmF1bHQ7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcXHJcXG5cXHRjb2xvcjogI2JiYjtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIGEge1xcclxcblxcdHdpZHRoOiAzMHB4O1xcclxcblxcdGhlaWdodDogMzBweDtcXHJcXG5cXHRsaW5lLWhlaWdodDogMzBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyIGE6Zmlyc3QtY2hpbGQge1xcclxcblxcdGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDJweDtcXHJcXG5cXHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYTpsYXN0LWNoaWxkIHtcXHJcXG5cXHRib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAycHg7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDJweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogem9vbSBjb250cm9sICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udHJvbC16b29tLWluLFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXQge1xcclxcblxcdGZvbnQ6IGJvbGQgMThweCAnTHVjaWRhIENvbnNvbGUnLCBNb25hY28sIG1vbm9zcGFjZTtcXHJcXG5cXHR0ZXh0LWluZGVudDogMXB4O1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLXpvb20taW4sIC5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXQgIHtcXHJcXG5cXHRmb250LXNpemU6IDIycHg7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIGxheWVycyBjb250cm9sICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMge1xcclxcblxcdGJveC1zaGFkb3c6IDAgMXB4IDVweCByZ2JhKDAsMCwwLDAuNCk7XFxyXFxuXFx0YmFja2dyb3VuZDogI2ZmZjtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiA1cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fXyArIFwiKTtcXHJcXG5cXHR3aWR0aDogMzZweDtcXHJcXG5cXHRoZWlnaHQ6IDM2cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXJldGluYSAubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGUge1xcclxcblxcdGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzFfX18gKyBcIik7XFxyXFxuXFx0YmFja2dyb3VuZC1zaXplOiAyNnB4IDI2cHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0d2lkdGg6IDQ0cHg7XFxyXFxuXFx0aGVpZ2h0OiA0NHB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycyAubGVhZmxldC1jb250cm9sLWxheWVycy1saXN0LFxcclxcbi5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7XFxyXFxuXFx0ZGlzcGxheTogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtbGlzdCB7XFxyXFxuXFx0ZGlzcGxheTogYmxvY2s7XFxyXFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCB7XFxyXFxuXFx0cGFkZGluZzogNnB4IDEwcHggNnB4IDZweDtcXHJcXG5cXHRjb2xvcjogIzMzMztcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXIge1xcclxcblxcdG92ZXJmbG93LXk6IHNjcm9sbDtcXHJcXG5cXHRvdmVyZmxvdy14OiBoaWRkZW47XFxyXFxuXFx0cGFkZGluZy1yaWdodDogNXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvciB7XFxyXFxuXFx0bWFyZ2luLXRvcDogMnB4O1xcclxcblxcdHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG5cXHR0b3A6IDFweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1sYXllcnMgbGFiZWwge1xcclxcblxcdGRpc3BsYXk6IGJsb2NrO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWxheWVycy1zZXBhcmF0b3Ige1xcclxcblxcdGhlaWdodDogMDtcXHJcXG5cXHRib3JkZXItdG9wOiAxcHggc29saWQgI2RkZDtcXHJcXG5cXHRtYXJnaW46IDVweCAtMTBweCA1cHggLTZweDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLyogRGVmYXVsdCBpY29uIFVSTHMgKi9cXHJcXG4ubGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCB7XFxyXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMl9fXyArIFwiKTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFxyXFxuLyogYXR0cmlidXRpb24gYW5kIHNjYWxlIGNvbnRyb2xzICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24ge1xcclxcblxcdGJhY2tncm91bmQ6ICNmZmY7XFxyXFxuXFx0YmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xcclxcblxcdG1hcmdpbjogMDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbixcXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmUge1xcclxcblxcdHBhZGRpbmc6IDAgNXB4O1xcclxcblxcdGNvbG9yOiAjMzMzO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uIGEge1xcclxcblxcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiBhOmhvdmVyIHtcXHJcXG5cXHR0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sXFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtc2NhbGUge1xcclxcblxcdGZvbnQtc2l6ZTogMTFweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtbGVmdCAubGVhZmxldC1jb250cm9sLXNjYWxlIHtcXHJcXG5cXHRtYXJnaW4tbGVmdDogNXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1ib3R0b20gLmxlYWZsZXQtY29udHJvbC1zY2FsZSB7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbTogNXB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmUge1xcclxcblxcdGJvcmRlcjogMnB4IHNvbGlkICM3Nzc7XFxyXFxuXFx0Ym9yZGVyLXRvcDogbm9uZTtcXHJcXG5cXHRsaW5lLWhlaWdodDogMS4xO1xcclxcblxcdHBhZGRpbmc6IDJweCA1cHggMXB4O1xcclxcblxcdGZvbnQtc2l6ZTogMTFweDtcXHJcXG5cXHR3aGl0ZS1zcGFjZTogbm93cmFwO1xcclxcblxcdG92ZXJmbG93OiBoaWRkZW47XFxyXFxuXFx0LW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcdCAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG5cXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udHJvbC1zY2FsZS1saW5lOm5vdCg6Zmlyc3QtY2hpbGQpIHtcXHJcXG5cXHRib3JkZXItdG9wOiAycHggc29saWQgIzc3NztcXHJcXG5cXHRib3JkZXItYm90dG9tOiBub25lO1xcclxcblxcdG1hcmdpbi10b3A6IC0ycHg7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZTpub3QoOmZpcnN0LWNoaWxkKTpub3QoOmxhc3QtY2hpbGQpIHtcXHJcXG5cXHRib3JkZXItYm90dG9tOiAycHggc29saWQgIzc3NztcXHJcXG5cXHR9XFxyXFxuXFxyXFxuLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbixcXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLWxheWVycyxcXHJcXG4ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIge1xcclxcblxcdGJveC1zaGFkb3c6IG5vbmU7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLFxcclxcbi5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciB7XFxyXFxuXFx0Ym9yZGVyOiAycHggc29saWQgcmdiYSgwLDAsMCwwLjIpO1xcclxcblxcdGJhY2tncm91bmQtY2xpcDogcGFkZGluZy1ib3g7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIHBvcHVwICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtcG9wdXAge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbTogMjBweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyIHtcXHJcXG5cXHRwYWRkaW5nOiAxcHg7XFxyXFxuXFx0dGV4dC1hbGlnbjogbGVmdDtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiAxMnB4O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1jb250ZW50IHtcXHJcXG5cXHRtYXJnaW46IDEzcHggMTlweDtcXHJcXG5cXHRsaW5lLWhlaWdodDogMS40O1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1jb250ZW50IHAge1xcclxcblxcdG1hcmdpbjogMThweCAwO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC10aXAtY29udGFpbmVyIHtcXHJcXG5cXHR3aWR0aDogNDBweDtcXHJcXG5cXHRoZWlnaHQ6IDIwcHg7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdGxlZnQ6IDUwJTtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTIwcHg7XFxyXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtdGlwIHtcXHJcXG5cXHR3aWR0aDogMTdweDtcXHJcXG5cXHRoZWlnaHQ6IDE3cHg7XFxyXFxuXFx0cGFkZGluZzogMXB4O1xcclxcblxcclxcblxcdG1hcmdpbjogLTEwcHggYXV0byAwO1xcclxcblxcclxcblxcdC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcclxcblxcdCAgIC1tb3otdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcclxcblxcdCAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcclxcblxcdCAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXIsXFxyXFxuLmxlYWZsZXQtcG9wdXAtdGlwIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiB3aGl0ZTtcXHJcXG5cXHRjb2xvcjogIzMzMztcXHJcXG5cXHRib3gtc2hhZG93OiAwIDNweCAxNHB4IHJnYmEoMCwwLDAsMC40KTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b24ge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0cmlnaHQ6IDA7XFxyXFxuXFx0cGFkZGluZzogNHB4IDRweCAwIDA7XFxyXFxuXFx0Ym9yZGVyOiBub25lO1xcclxcblxcdHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG5cXHR3aWR0aDogMThweDtcXHJcXG5cXHRoZWlnaHQ6IDE0cHg7XFxyXFxuXFx0Zm9udDogMTZweC8xNHB4IFRhaG9tYSwgVmVyZGFuYSwgc2Fucy1zZXJpZjtcXHJcXG5cXHRjb2xvcjogI2MzYzNjMztcXHJcXG5cXHR0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuXFx0Zm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxuXFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9uOmhvdmVyIHtcXHJcXG5cXHRjb2xvcjogIzk5OTtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtcG9wdXAtc2Nyb2xsZWQge1xcclxcblxcdG92ZXJmbG93OiBhdXRvO1xcclxcblxcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZGRkO1xcclxcblxcdGJvcmRlci10b3A6IDFweCBzb2xpZCAjZGRkO1xcclxcblxcdH1cXHJcXG5cXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXIge1xcclxcblxcdHpvb206IDE7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLXRpcCB7XFxyXFxuXFx0d2lkdGg6IDI0cHg7XFxyXFxuXFx0bWFyZ2luOiAwIGF1dG87XFxyXFxuXFxyXFxuXFx0LW1zLWZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPTAuNzA3MTA2NzgsIE0xMj0wLjcwNzEwNjc4LCBNMjE9LTAuNzA3MTA2NzgsIE0yMj0wLjcwNzEwNjc4KVxcXCI7XFxyXFxuXFx0ZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0wLjcwNzEwNjc4LCBNMTI9MC43MDcxMDY3OCwgTTIxPS0wLjcwNzEwNjc4LCBNMjI9MC43MDcxMDY3OCk7XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXIge1xcclxcblxcdG1hcmdpbi10b3A6IC0xcHg7XFxyXFxuXFx0fVxcclxcblxcclxcbi5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LWNvbnRyb2wtem9vbSxcXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1jb250cm9sLWxheWVycyxcXHJcXG4ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXIsXFxyXFxuLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtdGlwIHtcXHJcXG5cXHRib3JkZXI6IDFweCBzb2xpZCAjOTk5O1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHJcXG4vKiBkaXYgaWNvbiAqL1xcclxcblxcclxcbi5sZWFmbGV0LWRpdi1pY29uIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICM2NjY7XFxyXFxuXFx0fVxcclxcblxcclxcblxcclxcbi8qIFRvb2x0aXAgKi9cXHJcXG4vKiBCYXNlIHN0eWxlcyBmb3IgdGhlIGVsZW1lbnQgdGhhdCBoYXMgYSB0b29sdGlwICovXFxyXFxuLmxlYWZsZXQtdG9vbHRpcCB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHBhZGRpbmc6IDZweDtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICNmZmY7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogM3B4O1xcclxcblxcdGNvbG9yOiAjMjIyO1xcclxcblxcdHdoaXRlLXNwYWNlOiBub3dyYXA7XFxyXFxuXFx0LXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHQtbW96LXVzZXItc2VsZWN0OiBub25lO1xcclxcblxcdC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHR1c2VyLXNlbGVjdDogbm9uZTtcXHJcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG5cXHRib3gtc2hhZG93OiAwIDFweCAzcHggcmdiYSgwLDAsMCwwLjQpO1xcclxcblxcdH1cXHJcXG4ubGVhZmxldC10b29sdGlwLmxlYWZsZXQtY2xpY2thYmxlIHtcXHJcXG5cXHRjdXJzb3I6IHBvaW50ZXI7XFxyXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxyXFxuXFx0fVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtdG9wOmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLWJvdHRvbTpiZWZvcmUsXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0OmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0OmJlZm9yZSB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcblxcdGJvcmRlcjogNnB4IHNvbGlkIHRyYW5zcGFyZW50O1xcclxcblxcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcblxcdGNvbnRlbnQ6IFxcXCJcXFwiO1xcclxcblxcdH1cXHJcXG5cXHJcXG4vKiBEaXJlY3Rpb25zICovXFxyXFxuXFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1ib3R0b20ge1xcclxcblxcdG1hcmdpbi10b3A6IDZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC10b3Age1xcclxcblxcdG1hcmdpbi10b3A6IC02cHg7XFxyXFxufVxcclxcbi5sZWFmbGV0LXRvb2x0aXAtYm90dG9tOmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLXRvcDpiZWZvcmUge1xcclxcblxcdGxlZnQ6IDUwJTtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3JlIHtcXHJcXG5cXHRib3R0b206IDA7XFxyXFxuXFx0bWFyZ2luLWJvdHRvbTogLTEycHg7XFxyXFxuXFx0Ym9yZGVyLXRvcC1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1ib3R0b206YmVmb3JlIHtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTEycHg7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC02cHg7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbS1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0IHtcXHJcXG5cXHRtYXJnaW4tbGVmdDogLTZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1yaWdodCB7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IDZweDtcXHJcXG59XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0OmJlZm9yZSxcXHJcXG4ubGVhZmxldC10b29sdGlwLXJpZ2h0OmJlZm9yZSB7XFxyXFxuXFx0dG9wOiA1MCU7XFxyXFxuXFx0bWFyZ2luLXRvcDogLTZweDtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1sZWZ0OmJlZm9yZSB7XFxyXFxuXFx0cmlnaHQ6IDA7XFxyXFxuXFx0bWFyZ2luLXJpZ2h0OiAtMTJweDtcXHJcXG5cXHRib3JkZXItbGVmdC1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmUge1xcclxcblxcdGxlZnQ6IDA7XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IC0xMnB4O1xcclxcblxcdGJvcmRlci1yaWdodC1jb2xvcjogI2ZmZjtcXHJcXG5cXHR9XFxyXFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///174\n')},175:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "layers.png?416d91365b44e4b4f4777663e6f009f3");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9sYXllcnMucG5nP2YwYzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBZSxvRkFBdUIsZ0RBQWdEIiwiZmlsZSI6IjE3NS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJsYXllcnMucG5nPzQxNmQ5MTM2NWI0NGU0YjRmNDc3NzY2M2U2ZjAwOWYzXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///175\n')},176:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "layers-2x.png?8f2c4d11474275fbc1614b9098334eae");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9sYXllcnMtMngucG5nP2UxMjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBZSxvRkFBdUIsbURBQW1EIiwiZmlsZSI6IjE3Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJsYXllcnMtMngucG5nPzhmMmM0ZDExNDc0Mjc1ZmJjMTYxNGI5MDk4MzM0ZWFlXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///176\n')},177:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "marker-icon.png?2b3e1faf89f94a4835397e7a43b4f77d");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi5wbmc/NWM4ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFlLG9GQUF1QixxREFBcUQiLCJmaWxlIjoiMTc3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIm1hcmtlci1pY29uLnBuZz8yYjNlMWZhZjg5Zjk0YTQ4MzUzOTdlN2E0M2I0Zjc3ZFwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///177\n')},199:function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(200);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(4).default\nvar update = add(\"52ac88d4\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9DaGFydC5taW4uY3NzPzdhYzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsR0FBZ0Q7QUFDdEU7QUFDQSw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLENBQWdEO0FBQ2xFLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6IjE5OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vQ2hhcnQubWluLmNzc1wiKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjUyYWM4OGQ0XCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vQ2hhcnQubWluLmNzc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vQ2hhcnQubWluLmNzc1wiKTtcbiAgICAgaWYobmV3Q29udGVudC5fX2VzTW9kdWxlKSBuZXdDb250ZW50ID0gbmV3Q29udGVudC5kZWZhdWx0O1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///199\n")},2:function(module,exports,__webpack_require__){eval("/* @preserve\n * Leaflet 1.6.0, a JS library for interactive maps. http://leafletjs.com\n * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */\n(function (global, factory) {\n   true ? factory(exports) : undefined;\n})(this, function (exports) {\n  'use strict';\n\n  var version = \"1.6.0\";\n  /*\r\n   * @namespace Util\r\n   *\r\n   * Various utility functions, used by Leaflet internally.\r\n   */\n\n  var freeze = Object.freeze;\n\n  Object.freeze = function (obj) {\n    return obj;\n  }; // @function extend(dest: Object, src?: Object): Object\n  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.\n\n\n  function extend(dest) {\n    var i, j, len, src;\n\n    for (j = 1, len = arguments.length; j < len; j++) {\n      src = arguments[j];\n\n      for (i in src) {\n        dest[i] = src[i];\n      }\n    }\n\n    return dest;\n  } // @function create(proto: Object, properties?: Object): Object\n  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n\n\n  var create = Object.create || function () {\n    function F() {}\n\n    return function (proto) {\n      F.prototype = proto;\n      return new F();\n    };\n  }(); // @function bind(fn: Function, …): Function\n  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n  // Has a `L.bind()` shortcut.\n\n\n  function bind(fn, obj) {\n    var slice = Array.prototype.slice;\n\n    if (fn.bind) {\n      return fn.bind.apply(fn, slice.call(arguments, 1));\n    }\n\n    var args = slice.call(arguments, 2);\n    return function () {\n      return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\n    };\n  } // @property lastId: Number\n  // Last unique ID used by [`stamp()`](#util-stamp)\n\n\n  var lastId = 0; // @function stamp(obj: Object): Number\n  // Returns the unique ID of an object, assigning it one if it doesn't have it.\n\n  function stamp(obj) {\n    /*eslint-disable */\n    obj._leaflet_id = obj._leaflet_id || ++lastId;\n    return obj._leaflet_id;\n    /* eslint-enable */\n  } // @function throttle(fn: Function, time: Number, context: Object): Function\n  // Returns a function which executes function `fn` with the given scope `context`\n  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function\n  // `fn` will be called no more than one time per given amount of `time`. The arguments\n  // received by the bound function will be any arguments passed when binding the\n  // function, followed by any arguments passed when invoking the bound function.\n  // Has an `L.throttle` shortcut.\n\n\n  function throttle(fn, time, context) {\n    var lock, args, wrapperFn, later;\n\n    later = function () {\n      // reset lock and call if queued\n      lock = false;\n\n      if (args) {\n        wrapperFn.apply(context, args);\n        args = false;\n      }\n    };\n\n    wrapperFn = function () {\n      if (lock) {\n        // called too soon, queue to call later\n        args = arguments;\n      } else {\n        // call and lock until later\n        fn.apply(context, arguments);\n        setTimeout(later, time);\n        lock = true;\n      }\n    };\n\n    return wrapperFn;\n  } // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number\n  // Returns the number `num` modulo `range` in such a way so it lies within\n  // `range[0]` and `range[1]`. The returned value will be always smaller than\n  // `range[1]` unless `includeMax` is set to `true`.\n\n\n  function wrapNum(x, range, includeMax) {\n    var max = range[1],\n        min = range[0],\n        d = max - min;\n    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;\n  } // @function falseFn(): Function\n  // Returns a function which always returns `false`.\n\n\n  function falseFn() {\n    return false;\n  } // @function formatNum(num: Number, digits?: Number): Number\n  // Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.\n\n\n  function formatNum(num, digits) {\n    var pow = Math.pow(10, digits === undefined ? 6 : digits);\n    return Math.round(num * pow) / pow;\n  } // @function trim(str: String): String\n  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)\n\n\n  function trim(str) {\n    return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n  } // @function splitWords(str: String): String[]\n  // Trims and splits the string on whitespace and returns the array of parts.\n\n\n  function splitWords(str) {\n    return trim(str).split(/\\s+/);\n  } // @function setOptions(obj: Object, options: Object): Object\n  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.\n\n\n  function setOptions(obj, options) {\n    if (!obj.hasOwnProperty('options')) {\n      obj.options = obj.options ? create(obj.options) : {};\n    }\n\n    for (var i in options) {\n      obj.options[i] = options[i];\n    }\n\n    return obj.options;\n  } // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String\n  // Converts an object into a parameter URL string, e.g. `{a: \"foo\", b: \"bar\"}`\n  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will\n  // be appended at the end. If `uppercase` is `true`, the parameter names will\n  // be uppercased (e.g. `'?A=foo&B=bar'`)\n\n\n  function getParamString(obj, existingUrl, uppercase) {\n    var params = [];\n\n    for (var i in obj) {\n      params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\n    }\n\n    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');\n  }\n\n  var templateRe = /\\{ *([\\w_-]+) *\\}/g; // @function template(str: String, data: Object): String\n  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\n  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\n  // `('Hello foo, bar')`. You can also specify functions instead of strings for\n  // data values — they will be evaluated passing `data` as an argument.\n\n  function template(str, data) {\n    return str.replace(templateRe, function (str, key) {\n      var value = data[key];\n\n      if (value === undefined) {\n        throw new Error('No value provided for variable ' + str);\n      } else if (typeof value === 'function') {\n        value = value(data);\n      }\n\n      return value;\n    });\n  } // @function isArray(obj): Boolean\n  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\n\n\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  }; // @function indexOf(array: Array, el: Object): Number\n  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\n\n\n  function indexOf(array, el) {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === el) {\n        return i;\n      }\n    }\n\n    return -1;\n  } // @property emptyImageUrl: String\n  // Data URI string containing a base64-encoded empty GIF image.\n  // Used as a hack to free memory from unused images on WebKit-powered\n  // mobile devices (by setting image `src` to this string).\n\n\n  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\n  function getPrefixed(name) {\n    return window['webkit' + name] || window['moz' + name] || window['ms' + name];\n  }\n\n  var lastTime = 0; // fallback for IE 7-8\n\n  function timeoutDefer(fn) {\n    var time = +new Date(),\n        timeToCall = Math.max(0, 16 - (time - lastTime));\n    lastTime = time + timeToCall;\n    return window.setTimeout(fn, timeToCall);\n  }\n\n  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;\n\n  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {\n    window.clearTimeout(id);\n  }; // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number\n  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to\n  // `context` if given. When `immediate` is set, `fn` is called immediately if\n  // the browser doesn't have native support for\n  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),\n  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.\n\n\n  function requestAnimFrame(fn, context, immediate) {\n    if (immediate && requestFn === timeoutDefer) {\n      fn.call(context);\n    } else {\n      return requestFn.call(window, bind(fn, context));\n    }\n  } // @function cancelAnimFrame(id: Number): undefined\n  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).\n\n\n  function cancelAnimFrame(id) {\n    if (id) {\n      cancelFn.call(window, id);\n    }\n  }\n\n  var Util = (Object.freeze || Object)({\n    freeze: freeze,\n    extend: extend,\n    create: create,\n    bind: bind,\n    lastId: lastId,\n    stamp: stamp,\n    throttle: throttle,\n    wrapNum: wrapNum,\n    falseFn: falseFn,\n    formatNum: formatNum,\n    trim: trim,\n    splitWords: splitWords,\n    setOptions: setOptions,\n    getParamString: getParamString,\n    template: template,\n    isArray: isArray,\n    indexOf: indexOf,\n    emptyImageUrl: emptyImageUrl,\n    requestFn: requestFn,\n    cancelFn: cancelFn,\n    requestAnimFrame: requestAnimFrame,\n    cancelAnimFrame: cancelAnimFrame\n  }); // @class Class\n  // @aka L.Class\n  // @section\n  // @uninheritable\n  // Thanks to John Resig and Dean Edwards for inspiration!\n\n  function Class() {}\n\n  Class.extend = function (props) {\n    // @function extend(props: Object): Function\n    // [Extends the current class](#class-inheritance) given the properties to be included.\n    // Returns a Javascript function that is a class constructor (to be called with `new`).\n    var NewClass = function () {\n      // call the constructor\n      if (this.initialize) {\n        this.initialize.apply(this, arguments);\n      } // call all constructor hooks\n\n\n      this.callInitHooks();\n    };\n\n    var parentProto = NewClass.__super__ = this.prototype;\n    var proto = create(parentProto);\n    proto.constructor = NewClass;\n    NewClass.prototype = proto; // inherit parent's statics\n\n    for (var i in this) {\n      if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {\n        NewClass[i] = this[i];\n      }\n    } // mix static properties into the class\n\n\n    if (props.statics) {\n      extend(NewClass, props.statics);\n      delete props.statics;\n    } // mix includes into the prototype\n\n\n    if (props.includes) {\n      checkDeprecatedMixinEvents(props.includes);\n      extend.apply(null, [proto].concat(props.includes));\n      delete props.includes;\n    } // merge options\n\n\n    if (proto.options) {\n      props.options = extend(create(proto.options), props.options);\n    } // mix given properties into the prototype\n\n\n    extend(proto, props);\n    proto._initHooks = []; // add method for calling all hooks\n\n    proto.callInitHooks = function () {\n      if (this._initHooksCalled) {\n        return;\n      }\n\n      if (parentProto.callInitHooks) {\n        parentProto.callInitHooks.call(this);\n      }\n\n      this._initHooksCalled = true;\n\n      for (var i = 0, len = proto._initHooks.length; i < len; i++) {\n        proto._initHooks[i].call(this);\n      }\n    };\n\n    return NewClass;\n  }; // @function include(properties: Object): this\n  // [Includes a mixin](#class-includes) into the current class.\n\n\n  Class.include = function (props) {\n    extend(this.prototype, props);\n    return this;\n  }; // @function mergeOptions(options: Object): this\n  // [Merges `options`](#class-options) into the defaults of the class.\n\n\n  Class.mergeOptions = function (options) {\n    extend(this.prototype.options, options);\n    return this;\n  }; // @function addInitHook(fn: Function): this\n  // Adds a [constructor hook](#class-constructor-hooks) to the class.\n\n\n  Class.addInitHook = function (fn) {\n    // (Function) || (String, args...)\n    var args = Array.prototype.slice.call(arguments, 1);\n    var init = typeof fn === 'function' ? fn : function () {\n      this[fn].apply(this, args);\n    };\n    this.prototype._initHooks = this.prototype._initHooks || [];\n\n    this.prototype._initHooks.push(init);\n\n    return this;\n  };\n\n  function checkDeprecatedMixinEvents(includes) {\n    if (typeof L === 'undefined' || !L || !L.Mixin) {\n      return;\n    }\n\n    includes = isArray(includes) ? includes : [includes];\n\n    for (var i = 0; i < includes.length; i++) {\n      if (includes[i] === L.Mixin.Events) {\n        console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);\n      }\n    }\n  }\n  /*\r\n   * @class Evented\r\n   * @aka L.Evented\r\n   * @inherits Class\r\n   *\r\n   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * map.on('click', function(e) {\r\n   * \talert(e.latlng);\r\n   * } );\r\n   * ```\r\n   *\r\n   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n   *\r\n   * ```js\r\n   * function onClick(e) { ... }\r\n   *\r\n   * map.on('click', onClick);\r\n   * map.off('click', onClick);\r\n   * ```\r\n   */\n\n\n  var Events = {\n    /* @method on(type: String, fn: Function, context?: Object): this\r\n     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n     *\r\n     * @alternative\r\n     * @method on(eventMap: Object): this\r\n     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n     */\n    on: function (types, fn, context) {\n      // types can be a map of types/handlers\n      if (typeof types === 'object') {\n        for (var type in types) {\n          // we don't process space-separated events here for performance;\n          // it's a hot path since Layer uses the on(obj) syntax\n          this._on(type, types[type], fn);\n        }\n      } else {\n        // types can be a string of space-separated words\n        types = splitWords(types);\n\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._on(types[i], fn, context);\n        }\n      }\n\n      return this;\n    },\n\n    /* @method off(type: String, fn?: Function, context?: Object): this\r\n     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n     *\r\n     * @alternative\r\n     * @method off(eventMap: Object): this\r\n     * Removes a set of type/listener pairs.\r\n     *\r\n     * @alternative\r\n     * @method off: this\r\n     * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n     */\n    off: function (types, fn, context) {\n      if (!types) {\n        // clear all listeners if called without arguments\n        delete this._events;\n      } else if (typeof types === 'object') {\n        for (var type in types) {\n          this._off(type, types[type], fn);\n        }\n      } else {\n        types = splitWords(types);\n\n        for (var i = 0, len = types.length; i < len; i++) {\n          this._off(types[i], fn, context);\n        }\n      }\n\n      return this;\n    },\n    // attach listener (without syntactic sugar now)\n    _on: function (type, fn, context) {\n      this._events = this._events || {};\n      /* get/init listeners for type */\n\n      var typeListeners = this._events[type];\n\n      if (!typeListeners) {\n        typeListeners = [];\n        this._events[type] = typeListeners;\n      }\n\n      if (context === this) {\n        // Less memory footprint.\n        context = undefined;\n      }\n\n      var newListener = {\n        fn: fn,\n        ctx: context\n      },\n          listeners = typeListeners; // check if fn already there\n\n      for (var i = 0, len = listeners.length; i < len; i++) {\n        if (listeners[i].fn === fn && listeners[i].ctx === context) {\n          return;\n        }\n      }\n\n      listeners.push(newListener);\n    },\n    _off: function (type, fn, context) {\n      var listeners, i, len;\n\n      if (!this._events) {\n        return;\n      }\n\n      listeners = this._events[type];\n\n      if (!listeners) {\n        return;\n      }\n\n      if (!fn) {\n        // Set all removed listeners to noop so they are not called if remove happens in fire\n        for (i = 0, len = listeners.length; i < len; i++) {\n          listeners[i].fn = falseFn;\n        } // clear all listeners for a type if function isn't specified\n\n\n        delete this._events[type];\n        return;\n      }\n\n      if (context === this) {\n        context = undefined;\n      }\n\n      if (listeners) {\n        // find fn and remove it\n        for (i = 0, len = listeners.length; i < len; i++) {\n          var l = listeners[i];\n\n          if (l.ctx !== context) {\n            continue;\n          }\n\n          if (l.fn === fn) {\n            // set the removed listener to noop so that's not called if remove happens in fire\n            l.fn = falseFn;\n\n            if (this._firingCount) {\n              /* copy array in case events are being fired */\n              this._events[type] = listeners = listeners.slice();\n            }\n\n            listeners.splice(i, 1);\n            return;\n          }\n        }\n      }\n    },\n    // @method fire(type: String, data?: Object, propagate?: Boolean): this\n    // Fires an event of the specified type. You can optionally provide an data\n    // object — the first argument of the listener function will contain its\n    // properties. The event can optionally be propagated to event parents.\n    fire: function (type, data, propagate) {\n      if (!this.listens(type, propagate)) {\n        return this;\n      }\n\n      var event = extend({}, data, {\n        type: type,\n        target: this,\n        sourceTarget: data && data.sourceTarget || this\n      });\n\n      if (this._events) {\n        var listeners = this._events[type];\n\n        if (listeners) {\n          this._firingCount = this._firingCount + 1 || 1;\n\n          for (var i = 0, len = listeners.length; i < len; i++) {\n            var l = listeners[i];\n            l.fn.call(l.ctx || this, event);\n          }\n\n          this._firingCount--;\n        }\n      }\n\n      if (propagate) {\n        // propagate the event to parents (set with addEventParent)\n        this._propagateEvent(event);\n      }\n\n      return this;\n    },\n    // @method listens(type: String): Boolean\n    // Returns `true` if a particular event type has any listeners attached to it.\n    listens: function (type, propagate) {\n      var listeners = this._events && this._events[type];\n\n      if (listeners && listeners.length) {\n        return true;\n      }\n\n      if (propagate) {\n        // also check parents for listeners if event propagates\n        for (var id in this._eventParents) {\n          if (this._eventParents[id].listens(type, propagate)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    // @method once(…): this\n    // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.\n    once: function (types, fn, context) {\n      if (typeof types === 'object') {\n        for (var type in types) {\n          this.once(type, types[type], fn);\n        }\n\n        return this;\n      }\n\n      var handler = bind(function () {\n        this.off(types, fn, context).off(types, handler, context);\n      }, this); // add a listener that's executed once and removed after that\n\n      return this.on(types, fn, context).on(types, handler, context);\n    },\n    // @method addEventParent(obj: Evented): this\n    // Adds an event parent - an `Evented` that will receive propagated events\n    addEventParent: function (obj) {\n      this._eventParents = this._eventParents || {};\n      this._eventParents[stamp(obj)] = obj;\n      return this;\n    },\n    // @method removeEventParent(obj: Evented): this\n    // Removes an event parent, so it will stop receiving propagated events\n    removeEventParent: function (obj) {\n      if (this._eventParents) {\n        delete this._eventParents[stamp(obj)];\n      }\n\n      return this;\n    },\n    _propagateEvent: function (e) {\n      for (var id in this._eventParents) {\n        this._eventParents[id].fire(e.type, extend({\n          layer: e.target,\n          propagatedFrom: e.target\n        }, e), true);\n      }\n    }\n  }; // aliases; we should ditch those eventually\n  // @method addEventListener(…): this\n  // Alias to [`on(…)`](#evented-on)\n\n  Events.addEventListener = Events.on; // @method removeEventListener(…): this\n  // Alias to [`off(…)`](#evented-off)\n  // @method clearAllEventListeners(…): this\n  // Alias to [`off()`](#evented-off)\n\n  Events.removeEventListener = Events.clearAllEventListeners = Events.off; // @method addOneTimeEventListener(…): this\n  // Alias to [`once(…)`](#evented-once)\n\n  Events.addOneTimeEventListener = Events.once; // @method fireEvent(…): this\n  // Alias to [`fire(…)`](#evented-fire)\n\n  Events.fireEvent = Events.fire; // @method hasEventListeners(…): Boolean\n  // Alias to [`listens(…)`](#evented-listens)\n\n  Events.hasEventListeners = Events.listens;\n  var Evented = Class.extend(Events);\n  /*\r\n   * @class Point\r\n   * @aka L.Point\r\n   *\r\n   * Represents a point with `x` and `y` coordinates in pixels.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var point = L.point(200, 300);\r\n   * ```\r\n   *\r\n   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```js\r\n   * map.panBy([200, 300]);\r\n   * map.panBy(L.point(200, 300));\r\n   * ```\r\n   *\r\n   * Note that `Point` does not inherit from Leafet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n  function Point(x, y, round) {\n    // @property x: Number; The `x` coordinate of the point\n    this.x = round ? Math.round(x) : x; // @property y: Number; The `y` coordinate of the point\n\n    this.y = round ? Math.round(y) : y;\n  }\n\n  var trunc = Math.trunc || function (v) {\n    return v > 0 ? Math.floor(v) : Math.ceil(v);\n  };\n\n  Point.prototype = {\n    // @method clone(): Point\n    // Returns a copy of the current point.\n    clone: function () {\n      return new Point(this.x, this.y);\n    },\n    // @method add(otherPoint: Point): Point\n    // Returns the result of addition of the current and the given points.\n    add: function (point) {\n      // non-destructive, returns a new point\n      return this.clone()._add(toPoint(point));\n    },\n    _add: function (point) {\n      // destructive, used directly for performance in situations where it's safe to modify existing point\n      this.x += point.x;\n      this.y += point.y;\n      return this;\n    },\n    // @method subtract(otherPoint: Point): Point\n    // Returns the result of subtraction of the given point from the current.\n    subtract: function (point) {\n      return this.clone()._subtract(toPoint(point));\n    },\n    _subtract: function (point) {\n      this.x -= point.x;\n      this.y -= point.y;\n      return this;\n    },\n    // @method divideBy(num: Number): Point\n    // Returns the result of division of the current point by the given number.\n    divideBy: function (num) {\n      return this.clone()._divideBy(num);\n    },\n    _divideBy: function (num) {\n      this.x /= num;\n      this.y /= num;\n      return this;\n    },\n    // @method multiplyBy(num: Number): Point\n    // Returns the result of multiplication of the current point by the given number.\n    multiplyBy: function (num) {\n      return this.clone()._multiplyBy(num);\n    },\n    _multiplyBy: function (num) {\n      this.x *= num;\n      this.y *= num;\n      return this;\n    },\n    // @method scaleBy(scale: Point): Point\n    // Multiply each coordinate of the current point by each coordinate of\n    // `scale`. In linear algebra terms, multiply the point by the\n    // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\n    // defined by `scale`.\n    scaleBy: function (point) {\n      return new Point(this.x * point.x, this.y * point.y);\n    },\n    // @method unscaleBy(scale: Point): Point\n    // Inverse of `scaleBy`. Divide each coordinate of the current point by\n    // each coordinate of `scale`.\n    unscaleBy: function (point) {\n      return new Point(this.x / point.x, this.y / point.y);\n    },\n    // @method round(): Point\n    // Returns a copy of the current point with rounded coordinates.\n    round: function () {\n      return this.clone()._round();\n    },\n    _round: function () {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    },\n    // @method floor(): Point\n    // Returns a copy of the current point with floored coordinates (rounded down).\n    floor: function () {\n      return this.clone()._floor();\n    },\n    _floor: function () {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    },\n    // @method ceil(): Point\n    // Returns a copy of the current point with ceiled coordinates (rounded up).\n    ceil: function () {\n      return this.clone()._ceil();\n    },\n    _ceil: function () {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    },\n    // @method trunc(): Point\n    // Returns a copy of the current point with truncated coordinates (rounded towards zero).\n    trunc: function () {\n      return this.clone()._trunc();\n    },\n    _trunc: function () {\n      this.x = trunc(this.x);\n      this.y = trunc(this.y);\n      return this;\n    },\n    // @method distanceTo(otherPoint: Point): Number\n    // Returns the cartesian distance between the current and the given points.\n    distanceTo: function (point) {\n      point = toPoint(point);\n      var x = point.x - this.x,\n          y = point.y - this.y;\n      return Math.sqrt(x * x + y * y);\n    },\n    // @method equals(otherPoint: Point): Boolean\n    // Returns `true` if the given point has the same coordinates.\n    equals: function (point) {\n      point = toPoint(point);\n      return point.x === this.x && point.y === this.y;\n    },\n    // @method contains(otherPoint: Point): Boolean\n    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\n    contains: function (point) {\n      point = toPoint(point);\n      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point for debugging purposes.\n    toString: function () {\n      return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';\n    }\n  }; // @factory L.point(x: Number, y: Number, round?: Boolean)\n  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\n  // @alternative\n  // @factory L.point(coords: Number[])\n  // Expects an array of the form `[x, y]` instead.\n  // @alternative\n  // @factory L.point(coords: Object)\n  // Expects a plain object of the form `{x: Number, y: Number}` instead.\n\n  function toPoint(x, y, round) {\n    if (x instanceof Point) {\n      return x;\n    }\n\n    if (isArray(x)) {\n      return new Point(x[0], x[1]);\n    }\n\n    if (x === undefined || x === null) {\n      return x;\n    }\n\n    if (typeof x === 'object' && 'x' in x && 'y' in x) {\n      return new Point(x.x, x.y);\n    }\n\n    return new Point(x, y, round);\n  }\n  /*\r\n   * @class Bounds\r\n   * @aka L.Bounds\r\n   *\r\n   * Represents a rectangular area in pixel coordinates.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var p1 = L.point(10, 10),\r\n   * p2 = L.point(40, 60),\r\n   * bounds = L.bounds(p1, p2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * otherBounds.intersects([[10, 10], [40, 60]]);\r\n   * ```\r\n   *\r\n   * Note that `Bounds` does not inherit from Leafet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n\n  function Bounds(a, b) {\n    if (!a) {\n      return;\n    }\n\n    var points = b ? [a, b] : a;\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      this.extend(points[i]);\n    }\n  }\n\n  Bounds.prototype = {\n    // @method extend(point: Point): this\n    // Extends the bounds to contain the given point.\n    extend: function (point) {\n      // (Point)\n      point = toPoint(point); // @property min: Point\n      // The top left corner of the rectangle.\n      // @property max: Point\n      // The bottom right corner of the rectangle.\n\n      if (!this.min && !this.max) {\n        this.min = point.clone();\n        this.max = point.clone();\n      } else {\n        this.min.x = Math.min(point.x, this.min.x);\n        this.max.x = Math.max(point.x, this.max.x);\n        this.min.y = Math.min(point.y, this.min.y);\n        this.max.y = Math.max(point.y, this.max.y);\n      }\n\n      return this;\n    },\n    // @method getCenter(round?: Boolean): Point\n    // Returns the center point of the bounds.\n    getCenter: function (round) {\n      return new Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);\n    },\n    // @method getBottomLeft(): Point\n    // Returns the bottom-left point of the bounds.\n    getBottomLeft: function () {\n      return new Point(this.min.x, this.max.y);\n    },\n    // @method getTopRight(): Point\n    // Returns the top-right point of the bounds.\n    getTopRight: function () {\n      // -> Point\n      return new Point(this.max.x, this.min.y);\n    },\n    // @method getTopLeft(): Point\n    // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).\n    getTopLeft: function () {\n      return this.min; // left, top\n    },\n    // @method getBottomRight(): Point\n    // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).\n    getBottomRight: function () {\n      return this.max; // right, bottom\n    },\n    // @method getSize(): Point\n    // Returns the size of the given bounds\n    getSize: function () {\n      return this.max.subtract(this.min);\n    },\n    // @method contains(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n    // @alternative\n    // @method contains(point: Point): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function (obj) {\n      var min, max;\n\n      if (typeof obj[0] === 'number' || obj instanceof Point) {\n        obj = toPoint(obj);\n      } else {\n        obj = toBounds(obj);\n      }\n\n      if (obj instanceof Bounds) {\n        min = obj.min;\n        max = obj.max;\n      } else {\n        min = max = obj;\n      }\n\n      return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;\n    },\n    // @method intersects(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds\n    // intersect if they have at least one point in common.\n    intersects: function (bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n          max = this.max,\n          min2 = bounds.min,\n          max2 = bounds.max,\n          xIntersects = max2.x >= min.x && min2.x <= max.x,\n          yIntersects = max2.y >= min.y && min2.y <= max.y;\n      return xIntersects && yIntersects;\n    },\n    // @method overlaps(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds\n    // overlap if their intersection is an area.\n    overlaps: function (bounds) {\n      // (Bounds) -> Boolean\n      bounds = toBounds(bounds);\n      var min = this.min,\n          max = this.max,\n          min2 = bounds.min,\n          max2 = bounds.max,\n          xOverlaps = max2.x > min.x && min2.x < max.x,\n          yOverlaps = max2.y > min.y && min2.y < max.y;\n      return xOverlaps && yOverlaps;\n    },\n    isValid: function () {\n      return !!(this.min && this.max);\n    }\n  }; // @factory L.bounds(corner1: Point, corner2: Point)\n  // Creates a Bounds object from two corners coordinate pairs.\n  // @alternative\n  // @factory L.bounds(points: Point[])\n  // Creates a Bounds object from the given array of points.\n\n  function toBounds(a, b) {\n    if (!a || a instanceof Bounds) {\n      return a;\n    }\n\n    return new Bounds(a, b);\n  }\n  /*\r\n   * @class LatLngBounds\r\n   * @aka L.LatLngBounds\r\n   *\r\n   * Represents a rectangular geographical area on a map.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var corner1 = L.latLng(40.712, -74.227),\r\n   * corner2 = L.latLng(40.774, -74.125),\r\n   * bounds = L.latLngBounds(corner1, corner2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * map.fitBounds([\r\n   * \t[40.712, -74.227],\r\n   * \t[40.774, -74.125]\r\n   * ]);\r\n   * ```\r\n   *\r\n   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.\r\n   *\r\n   * Note that `LatLngBounds` does not inherit from Leafet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n\n  function LatLngBounds(corner1, corner2) {\n    // (LatLng, LatLng) or (LatLng[])\n    if (!corner1) {\n      return;\n    }\n\n    var latlngs = corner2 ? [corner1, corner2] : corner1;\n\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      this.extend(latlngs[i]);\n    }\n  }\n\n  LatLngBounds.prototype = {\n    // @method extend(latlng: LatLng): this\n    // Extend the bounds to contain the given point\n    // @alternative\n    // @method extend(otherBounds: LatLngBounds): this\n    // Extend the bounds to contain the given bounds\n    extend: function (obj) {\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2,\n          ne2;\n\n      if (obj instanceof LatLng) {\n        sw2 = obj;\n        ne2 = obj;\n      } else if (obj instanceof LatLngBounds) {\n        sw2 = obj._southWest;\n        ne2 = obj._northEast;\n\n        if (!sw2 || !ne2) {\n          return this;\n        }\n      } else {\n        return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;\n      }\n\n      if (!sw && !ne) {\n        this._southWest = new LatLng(sw2.lat, sw2.lng);\n        this._northEast = new LatLng(ne2.lat, ne2.lng);\n      } else {\n        sw.lat = Math.min(sw2.lat, sw.lat);\n        sw.lng = Math.min(sw2.lng, sw.lng);\n        ne.lat = Math.max(ne2.lat, ne.lat);\n        ne.lng = Math.max(ne2.lng, ne.lng);\n      }\n\n      return this;\n    },\n    // @method pad(bufferRatio: Number): LatLngBounds\n    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n    // Negative values will retract the bounds.\n    pad: function (bufferRatio) {\n      var sw = this._southWest,\n          ne = this._northEast,\n          heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\n          widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\n      return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\n    },\n    // @method getCenter(): LatLng\n    // Returns the center point of the bounds.\n    getCenter: function () {\n      return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);\n    },\n    // @method getSouthWest(): LatLng\n    // Returns the south-west point of the bounds.\n    getSouthWest: function () {\n      return this._southWest;\n    },\n    // @method getNorthEast(): LatLng\n    // Returns the north-east point of the bounds.\n    getNorthEast: function () {\n      return this._northEast;\n    },\n    // @method getNorthWest(): LatLng\n    // Returns the north-west point of the bounds.\n    getNorthWest: function () {\n      return new LatLng(this.getNorth(), this.getWest());\n    },\n    // @method getSouthEast(): LatLng\n    // Returns the south-east point of the bounds.\n    getSouthEast: function () {\n      return new LatLng(this.getSouth(), this.getEast());\n    },\n    // @method getWest(): Number\n    // Returns the west longitude of the bounds\n    getWest: function () {\n      return this._southWest.lng;\n    },\n    // @method getSouth(): Number\n    // Returns the south latitude of the bounds\n    getSouth: function () {\n      return this._southWest.lat;\n    },\n    // @method getEast(): Number\n    // Returns the east longitude of the bounds\n    getEast: function () {\n      return this._northEast.lng;\n    },\n    // @method getNorth(): Number\n    // Returns the north latitude of the bounds\n    getNorth: function () {\n      return this._northEast.lat;\n    },\n    // @method contains(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle contains the given one.\n    // @alternative\n    // @method contains (latlng: LatLng): Boolean\n    // Returns `true` if the rectangle contains the given point.\n    contains: function (obj) {\n      // (LatLngBounds) or (LatLng) -> Boolean\n      if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {\n        obj = toLatLng(obj);\n      } else {\n        obj = toLatLngBounds(obj);\n      }\n\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2,\n          ne2;\n\n      if (obj instanceof LatLngBounds) {\n        sw2 = obj.getSouthWest();\n        ne2 = obj.getNorthEast();\n      } else {\n        sw2 = ne2 = obj;\n      }\n\n      return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;\n    },\n    // @method intersects(otherBounds: LatLngBounds): Boolean\n    // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.\n    intersects: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2 = bounds.getSouthWest(),\n          ne2 = bounds.getNorthEast(),\n          latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,\n          lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;\n      return latIntersects && lngIntersects;\n    },\n    // @method overlaps(otherBounds: Bounds): Boolean\n    // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.\n    overlaps: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n      var sw = this._southWest,\n          ne = this._northEast,\n          sw2 = bounds.getSouthWest(),\n          ne2 = bounds.getNorthEast(),\n          latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,\n          lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;\n      return latOverlaps && lngOverlaps;\n    },\n    // @method toBBoxString(): String\n    // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.\n    toBBoxString: function () {\n      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\n    },\n    // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean\n    // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function (bounds, maxMargin) {\n      if (!bounds) {\n        return false;\n      }\n\n      bounds = toLatLngBounds(bounds);\n      return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);\n    },\n    // @method isValid(): Boolean\n    // Returns `true` if the bounds are properly initialized.\n    isValid: function () {\n      return !!(this._southWest && this._northEast);\n    }\n  }; // TODO International date line?\n  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)\n  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.\n  // @alternative\n  // @factory L.latLngBounds(latlngs: LatLng[])\n  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).\n\n  function toLatLngBounds(a, b) {\n    if (a instanceof LatLngBounds) {\n      return a;\n    }\n\n    return new LatLngBounds(a, b);\n  }\n  /* @class LatLng\r\n   * @aka L.LatLng\r\n   *\r\n   * Represents a geographical point with a certain latitude and longitude.\r\n   *\r\n   * @example\r\n   *\r\n   * ```\r\n   * var latlng = L.latLng(50.5, 30.5);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```\r\n   * map.panTo([50, 30]);\r\n   * map.panTo({lon: 30, lat: 50});\r\n   * map.panTo({lat: 50, lng: 30});\r\n   * map.panTo(L.latLng(50, 30));\r\n   * ```\r\n   *\r\n   * Note that `LatLng` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\n\n\n  function LatLng(lat, lng, alt) {\n    if (isNaN(lat) || isNaN(lng)) {\n      throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\n    } // @property lat: Number\n    // Latitude in degrees\n\n\n    this.lat = +lat; // @property lng: Number\n    // Longitude in degrees\n\n    this.lng = +lng; // @property alt: Number\n    // Altitude in meters (optional)\n\n    if (alt !== undefined) {\n      this.alt = +alt;\n    }\n  }\n\n  LatLng.prototype = {\n    // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean\n    // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.\n    equals: function (obj, maxMargin) {\n      if (!obj) {\n        return false;\n      }\n\n      obj = toLatLng(obj);\n      var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));\n      return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\n    },\n    // @method toString(): String\n    // Returns a string representation of the point (for debugging purposes).\n    toString: function (precision) {\n      return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')';\n    },\n    // @method distanceTo(otherLatLng: LatLng): Number\n    // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).\n    distanceTo: function (other) {\n      return Earth.distance(this, toLatLng(other));\n    },\n    // @method wrap(): LatLng\n    // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.\n    wrap: function () {\n      return Earth.wrapLatLng(this);\n    },\n    // @method toBounds(sizeInMeters: Number): LatLngBounds\n    // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.\n    toBounds: function (sizeInMeters) {\n      var latAccuracy = 180 * sizeInMeters / 40075017,\n          lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);\n      return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);\n    },\n    clone: function () {\n      return new LatLng(this.lat, this.lng, this.alt);\n    }\n  }; // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng\n  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).\n  // @alternative\n  // @factory L.latLng(coords: Array): LatLng\n  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.\n  // @alternative\n  // @factory L.latLng(coords: Object): LatLng\n  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.\n\n  function toLatLng(a, b, c) {\n    if (a instanceof LatLng) {\n      return a;\n    }\n\n    if (isArray(a) && typeof a[0] !== 'object') {\n      if (a.length === 3) {\n        return new LatLng(a[0], a[1], a[2]);\n      }\n\n      if (a.length === 2) {\n        return new LatLng(a[0], a[1]);\n      }\n\n      return null;\n    }\n\n    if (a === undefined || a === null) {\n      return a;\n    }\n\n    if (typeof a === 'object' && 'lat' in a) {\n      return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);\n    }\n\n    if (b === undefined) {\n      return null;\n    }\n\n    return new LatLng(a, b, c);\n  }\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.Base\r\n   * Object that defines coordinate reference systems for projecting\r\n   * geographical points into pixel (screen) coordinates and back (and to\r\n   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n   * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).\r\n   *\r\n   * Leaflet defines the most usual CRSs by default. If you want to use a\r\n   * CRS not defined by default, take a look at the\r\n   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n   *\r\n   * Note that the CRS instances do not inherit from Leafet's `Class` object,\r\n   * and can't be instantiated. Also, new classes can't inherit from them,\r\n   * and methods can't be added to them with the `include` function.\r\n   */\n\n\n  var CRS = {\n    // @method latLngToPoint(latlng: LatLng, zoom: Number): Point\n    // Projects geographical coordinates into pixel coordinates for a given zoom.\n    latLngToPoint: function (latlng, zoom) {\n      var projectedPoint = this.projection.project(latlng),\n          scale = this.scale(zoom);\n      return this.transformation._transform(projectedPoint, scale);\n    },\n    // @method pointToLatLng(point: Point, zoom: Number): LatLng\n    // The inverse of `latLngToPoint`. Projects pixel coordinates on a given\n    // zoom into geographical coordinates.\n    pointToLatLng: function (point, zoom) {\n      var scale = this.scale(zoom),\n          untransformedPoint = this.transformation.untransform(point, scale);\n      return this.projection.unproject(untransformedPoint);\n    },\n    // @method project(latlng: LatLng): Point\n    // Projects geographical coordinates into coordinates in units accepted for\n    // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\n    project: function (latlng) {\n      return this.projection.project(latlng);\n    },\n    // @method unproject(point: Point): LatLng\n    // Given a projected coordinate returns the corresponding LatLng.\n    // The inverse of `project`.\n    unproject: function (point) {\n      return this.projection.unproject(point);\n    },\n    // @method scale(zoom: Number): Number\n    // Returns the scale used when transforming projected coordinates into\n    // pixel coordinates for a particular zoom. For example, it returns\n    // `256 * 2^zoom` for Mercator-based CRS.\n    scale: function (zoom) {\n      return 256 * Math.pow(2, zoom);\n    },\n    // @method zoom(scale: Number): Number\n    // Inverse of `scale()`, returns the zoom level corresponding to a scale\n    // factor of `scale`.\n    zoom: function (scale) {\n      return Math.log(scale / 256) / Math.LN2;\n    },\n    // @method getProjectedBounds(zoom: Number): Bounds\n    // Returns the projection's bounds scaled and transformed for the provided `zoom`.\n    getProjectedBounds: function (zoom) {\n      if (this.infinite) {\n        return null;\n      }\n\n      var b = this.projection.bounds,\n          s = this.scale(zoom),\n          min = this.transformation.transform(b.min, s),\n          max = this.transformation.transform(b.max, s);\n      return new Bounds(min, max);\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates.\n    // @property code: String\n    // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\n    //\n    // @property wrapLng: Number[]\n    // An array of two numbers defining whether the longitude (horizontal) coordinate\n    // axis wraps around a given range and how. Defaults to `[-180, 180]` in most\n    // geographical CRSs. If `undefined`, the longitude axis does not wrap around.\n    //\n    // @property wrapLat: Number[]\n    // Like `wrapLng`, but for the latitude (vertical) axis.\n    // wrapLng: [min, max],\n    // wrapLat: [min, max],\n    // @property infinite: Boolean\n    // If true, the coordinate space will be unbounded (infinite in both axes)\n    infinite: false,\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where lat and lng has been wrapped according to the\n    // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\n    wrapLatLng: function (latlng) {\n      var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\n          lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\n          alt = latlng.alt;\n      return new LatLng(lat, lng, alt);\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring\n    // that its center is within the CRS's bounds.\n    // Only accepts actual `L.LatLngBounds` instances, not arrays.\n    wrapLatLngBounds: function (bounds) {\n      var center = bounds.getCenter(),\n          newCenter = this.wrapLatLng(center),\n          latShift = center.lat - newCenter.lat,\n          lngShift = center.lng - newCenter.lng;\n\n      if (latShift === 0 && lngShift === 0) {\n        return bounds;\n      }\n\n      var sw = bounds.getSouthWest(),\n          ne = bounds.getNorthEast(),\n          newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),\n          newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\n      return new LatLngBounds(newSw, newNe);\n    }\n  };\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Earth\n   *\n   * Serves as the base for CRS that are global such that they cover the earth.\n   * Can only be used as the base for other CRS and cannot be used directly,\n   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns\n   * meters.\n   */\n\n  var Earth = extend({}, CRS, {\n    wrapLng: [-180, 180],\n    // Mean Earth Radius, as recommended for use by\n    // the International Union of Geodesy and Geophysics,\n    // see http://rosettacode.org/wiki/Haversine_formula\n    R: 6371000,\n    // distance between two geographical points using spherical law of cosines approximation\n    distance: function (latlng1, latlng2) {\n      var rad = Math.PI / 180,\n          lat1 = latlng1.lat * rad,\n          lat2 = latlng2.lat * rad,\n          sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),\n          sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),\n          a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n          c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      return this.R * c;\n    }\n  });\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.SphericalMercator\r\n   *\r\n   * Spherical Mercator projection — the most common projection for online maps,\r\n   * used by almost all free and commercial tile providers. Assumes that Earth is\r\n   * a sphere. Used by the `EPSG:3857` CRS.\r\n   */\n\n  var earthRadius = 6378137;\n  var SphericalMercator = {\n    R: earthRadius,\n    MAX_LATITUDE: 85.0511287798,\n    project: function (latlng) {\n      var d = Math.PI / 180,\n          max = this.MAX_LATITUDE,\n          lat = Math.max(Math.min(max, latlng.lat), -max),\n          sin = Math.sin(lat * d);\n      return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);\n    },\n    unproject: function (point) {\n      var d = 180 / Math.PI;\n      return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);\n    },\n    bounds: function () {\n      var d = earthRadius * Math.PI;\n      return new Bounds([-d, -d], [d, d]);\n    }()\n  };\n  /*\r\n   * @class Transformation\r\n   * @aka L.Transformation\r\n   *\r\n   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n   * the reverse. Used by Leaflet in its projections code.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var transformation = L.transformation(2, 5, -1, 10),\r\n   * \tp = L.point(1, 2),\r\n   * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n   * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n   * ```\r\n   */\n  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\n  // Creates a `Transformation` object with the given coefficients.\n\n  function Transformation(a, b, c, d) {\n    if (isArray(a)) {\n      // use array properties\n      this._a = a[0];\n      this._b = a[1];\n      this._c = a[2];\n      this._d = a[3];\n      return;\n    }\n\n    this._a = a;\n    this._b = b;\n    this._c = c;\n    this._d = d;\n  }\n\n  Transformation.prototype = {\n    // @method transform(point: Point, scale?: Number): Point\n    // Returns a transformed point, optionally multiplied by the given scale.\n    // Only accepts actual `L.Point` instances, not arrays.\n    transform: function (point, scale) {\n      // (Point, Number) -> Point\n      return this._transform(point.clone(), scale);\n    },\n    // destructive transform (faster)\n    _transform: function (point, scale) {\n      scale = scale || 1;\n      point.x = scale * (this._a * point.x + this._b);\n      point.y = scale * (this._c * point.y + this._d);\n      return point;\n    },\n    // @method untransform(point: Point, scale?: Number): Point\n    // Returns the reverse transformation of the given point, optionally divided\n    // by the given scale. Only accepts actual `L.Point` instances, not arrays.\n    untransform: function (point, scale) {\n      scale = scale || 1;\n      return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);\n    }\n  }; // factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n  // Instantiates a Transformation object with the given coefficients.\n  // @alternative\n  // @factory L.transformation(coefficients: Array): Transformation\n  // Expects an coefficients array of the form\n  // `[a: Number, b: Number, c: Number, d: Number]`.\n\n  function toTransformation(a, b, c, d) {\n    return new Transformation(a, b, c, d);\n  }\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3857\r\n   *\r\n   * The most common CRS for online maps, used by almost all free and commercial\r\n   * tile providers. Uses Spherical Mercator projection. Set in by default in\r\n   * Map's `crs` option.\r\n   */\n\n\n  var EPSG3857 = extend({}, Earth, {\n    code: 'EPSG:3857',\n    projection: SphericalMercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * SphericalMercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n  var EPSG900913 = extend({}, EPSG3857, {\n    code: 'EPSG:900913'\n  }); // @namespace SVG; @section\n  // There are several static functions which can be called without instantiating L.SVG:\n  // @function create(name: String): SVGElement\n  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),\n  // corresponding to the class name passed. For example, using 'line' will return\n  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).\n\n  function svgCreate(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  } // @function pointsToPath(rings: Point[], closed: Boolean): String\n  // Generates a SVG path string for multiple rings, with each ring turning\n  // into \"M..L..L..\" instructions\n\n\n  function pointsToPath(rings, closed) {\n    var str = '',\n        i,\n        j,\n        len,\n        len2,\n        points,\n        p;\n\n    for (i = 0, len = rings.length; i < len; i++) {\n      points = rings[i];\n\n      for (j = 0, len2 = points.length; j < len2; j++) {\n        p = points[j];\n        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n      } // closes the ring for polygons; \"x\" is VML syntax\n\n\n      str += closed ? svg ? 'z' : 'x' : '';\n    } // SVG complains about empty path strings\n\n\n    return str || 'M0 0';\n  }\n  /*\r\n   * @namespace Browser\r\n   * @aka L.Browser\r\n   *\r\n   * A namespace with static properties for browser/feature detection used by Leaflet internally.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * if (L.Browser.ielt9) {\r\n   *   alert('Upgrade your browser, dude!');\r\n   * }\r\n   * ```\r\n   */\n\n\n  var style$1 = document.documentElement.style; // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).\n\n  var ie = ('ActiveXObject' in window); // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.\n\n  var ielt9 = ie && !document.addEventListener; // @property edge: Boolean; `true` for the Edge web browser.\n\n  var edge = 'msLaunchUri' in navigator && !('documentMode' in document); // @property webkit: Boolean;\n  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).\n\n  var webkit = userAgentContains('webkit'); // @property android: Boolean\n  // `true` for any browser running on an Android platform.\n\n  var android = userAgentContains('android'); // @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.\n\n  var android23 = userAgentContains('android 2') || userAgentContains('android 3');\n  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */\n\n  var webkitVer = parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit\n  // @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)\n\n  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window); // @property opera: Boolean; `true` for the Opera browser\n\n  var opera = !!window.opera; // @property chrome: Boolean; `true` for the Chrome browser.\n\n  var chrome = userAgentContains('chrome'); // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.\n\n  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie; // @property safari: Boolean; `true` for the Safari browser.\n\n  var safari = !chrome && userAgentContains('safari');\n  var phantom = userAgentContains('phantom'); // @property opera12: Boolean\n  // `true` for the Opera browser supporting CSS transforms (version 12 or later).\n\n  var opera12 = ('OTransition' in style$1); // @property win: Boolean; `true` when the browser is running in a Windows platform\n\n  var win = navigator.platform.indexOf('Win') === 0; // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.\n\n  var ie3d = ie && 'transition' in style$1; // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.\n\n  var webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23; // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.\n\n  var gecko3d = ('MozPerspective' in style$1); // @property any3d: Boolean\n  // `true` for all browsers supporting CSS transforms.\n\n  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom; // @property mobile: Boolean; `true` for all browsers running in a mobile device.\n\n  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile'); // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.\n\n  var mobileWebkit = mobile && webkit; // @property mobileWebkit3d: Boolean\n  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.\n\n  var mobileWebkit3d = mobile && webkit3d; // @property msPointer: Boolean\n  // `true` for browsers implementing the Microsoft touch events model (notably IE10).\n\n  var msPointer = !window.PointerEvent && window.MSPointerEvent; // @property pointer: Boolean\n  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).\n\n  var pointer = !webkit && !!(window.PointerEvent || msPointer); // @property touch: Boolean\n  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).\n  // This does not necessarily mean that the browser is running in a computer with\n  // a touchscreen, it only means that the browser is capable of understanding\n  // touch events.\n\n  var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch); // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.\n\n  var mobileOpera = mobile && opera; // @property mobileGecko: Boolean\n  // `true` for gecko-based browsers running in a mobile device.\n\n  var mobileGecko = mobile && gecko; // @property retina: Boolean\n  // `true` for browsers on a high-resolution \"retina\" screen or on any screen when browser's display zoom is more than 100%.\n\n  var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1; // @property passiveEvents: Boolean\n  // `true` for browsers that support passive events.\n\n  var passiveEvents = function () {\n    var supportsPassiveOption = false;\n\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function () {\n          supportsPassiveOption = true;\n        }\n      });\n      window.addEventListener('testPassiveEventSupport', falseFn, opts);\n      window.removeEventListener('testPassiveEventSupport', falseFn, opts);\n    } catch (e) {// Errors can safely be ignored since this is only a browser support test.\n    }\n\n    return supportsPassiveOption;\n  }; // @property canvas: Boolean\n  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n\n\n  var canvas = function () {\n    return !!document.createElement('canvas').getContext;\n  }(); // @property svg: Boolean\n  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).\n\n\n  var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect); // @property vml: Boolean\n  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).\n\n  var vml = !svg && function () {\n    try {\n      var div = document.createElement('div');\n      div.innerHTML = '<v:shape adj=\"1\"/>';\n      var shape = div.firstChild;\n      shape.style.behavior = 'url(#default#VML)';\n      return shape && typeof shape.adj === 'object';\n    } catch (e) {\n      return false;\n    }\n  }();\n\n  function userAgentContains(str) {\n    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;\n  }\n\n  var Browser = (Object.freeze || Object)({\n    ie: ie,\n    ielt9: ielt9,\n    edge: edge,\n    webkit: webkit,\n    android: android,\n    android23: android23,\n    androidStock: androidStock,\n    opera: opera,\n    chrome: chrome,\n    gecko: gecko,\n    safari: safari,\n    phantom: phantom,\n    opera12: opera12,\n    win: win,\n    ie3d: ie3d,\n    webkit3d: webkit3d,\n    gecko3d: gecko3d,\n    any3d: any3d,\n    mobile: mobile,\n    mobileWebkit: mobileWebkit,\n    mobileWebkit3d: mobileWebkit3d,\n    msPointer: msPointer,\n    pointer: pointer,\n    touch: touch,\n    mobileOpera: mobileOpera,\n    mobileGecko: mobileGecko,\n    retina: retina,\n    passiveEvents: passiveEvents,\n    canvas: canvas,\n    svg: svg,\n    vml: vml\n  });\n  /*\n   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n   */\n\n  var POINTER_DOWN = msPointer ? 'MSPointerDown' : 'pointerdown';\n  var POINTER_MOVE = msPointer ? 'MSPointerMove' : 'pointermove';\n  var POINTER_UP = msPointer ? 'MSPointerUp' : 'pointerup';\n  var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';\n  var TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'];\n  var _pointers = {};\n  var _pointerDocListener = false; // DomEvent.DoubleTap needs to know about this\n\n  var _pointersCount = 0; // Provides a touch events wrapper for (ms)pointer events.\n  // ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n  function addPointerListener(obj, type, handler, id) {\n    if (type === 'touchstart') {\n      _addPointerStart(obj, handler, id);\n    } else if (type === 'touchmove') {\n      _addPointerMove(obj, handler, id);\n    } else if (type === 'touchend') {\n      _addPointerEnd(obj, handler, id);\n    }\n\n    return this;\n  }\n\n  function removePointerListener(obj, type, id) {\n    var handler = obj['_leaflet_' + type + id];\n\n    if (type === 'touchstart') {\n      obj.removeEventListener(POINTER_DOWN, handler, false);\n    } else if (type === 'touchmove') {\n      obj.removeEventListener(POINTER_MOVE, handler, false);\n    } else if (type === 'touchend') {\n      obj.removeEventListener(POINTER_UP, handler, false);\n      obj.removeEventListener(POINTER_CANCEL, handler, false);\n    }\n\n    return this;\n  }\n\n  function _addPointerStart(obj, handler, id) {\n    var onDown = bind(function (e) {\n      if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {\n        // In IE11, some touch events needs to fire for form controls, or\n        // the controls will stop working. We keep a whitelist of tag names that\n        // need these events. For other target tags, we prevent default on the event.\n        if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {\n          preventDefault(e);\n        } else {\n          return;\n        }\n      }\n\n      _handlePointer(e, handler);\n    });\n    obj['_leaflet_touchstart' + id] = onDown;\n    obj.addEventListener(POINTER_DOWN, onDown, false); // need to keep track of what pointers and how many are active to provide e.touches emulation\n\n    if (!_pointerDocListener) {\n      // we listen documentElement as any drags that end by moving the touch off the screen get fired there\n      document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);\n      document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);\n      document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);\n      document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);\n      _pointerDocListener = true;\n    }\n  }\n\n  function _globalPointerDown(e) {\n    _pointers[e.pointerId] = e;\n    _pointersCount++;\n  }\n\n  function _globalPointerMove(e) {\n    if (_pointers[e.pointerId]) {\n      _pointers[e.pointerId] = e;\n    }\n  }\n\n  function _globalPointerUp(e) {\n    delete _pointers[e.pointerId];\n    _pointersCount--;\n  }\n\n  function _handlePointer(e, handler) {\n    e.touches = [];\n\n    for (var i in _pointers) {\n      e.touches.push(_pointers[i]);\n    }\n\n    e.changedTouches = [e];\n    handler(e);\n  }\n\n  function _addPointerMove(obj, handler, id) {\n    var onMove = function (e) {\n      // don't fire touch moves when mouse isn't down\n      if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) {\n        return;\n      }\n\n      _handlePointer(e, handler);\n    };\n\n    obj['_leaflet_touchmove' + id] = onMove;\n    obj.addEventListener(POINTER_MOVE, onMove, false);\n  }\n\n  function _addPointerEnd(obj, handler, id) {\n    var onUp = function (e) {\n      _handlePointer(e, handler);\n    };\n\n    obj['_leaflet_touchend' + id] = onUp;\n    obj.addEventListener(POINTER_UP, onUp, false);\n    obj.addEventListener(POINTER_CANCEL, onUp, false);\n  }\n  /*\r\n   * Extends the event handling code with double tap support for mobile browsers.\r\n   */\n\n\n  var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';\n\n  var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';\n\n  var _pre = '_leaflet_'; // inspired by Zepto touch code by Thomas Fuchs\n\n  function addDoubleTapListener(obj, handler, id) {\n    var last,\n        touch$$1,\n        doubleTap = false,\n        delay = 250;\n\n    function onTouchStart(e) {\n      var count;\n\n      if (pointer) {\n        if (!edge || e.pointerType === 'mouse') {\n          return;\n        }\n\n        count = _pointersCount;\n      } else {\n        count = e.touches.length;\n      }\n\n      if (count > 1) {\n        return;\n      }\n\n      var now = Date.now(),\n          delta = now - (last || now);\n      touch$$1 = e.touches ? e.touches[0] : e;\n      doubleTap = delta > 0 && delta <= delay;\n      last = now;\n    }\n\n    function onTouchEnd(e) {\n      if (doubleTap && !touch$$1.cancelBubble) {\n        if (pointer) {\n          if (!edge || e.pointerType === 'mouse') {\n            return;\n          } // work around .type being readonly with MSPointer* events\n\n\n          var newTouch = {},\n              prop,\n              i;\n\n          for (i in touch$$1) {\n            prop = touch$$1[i];\n            newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;\n          }\n\n          touch$$1 = newTouch;\n        }\n\n        touch$$1.type = 'dblclick';\n        touch$$1.button = 0;\n        handler(touch$$1);\n        last = null;\n      }\n    }\n\n    obj[_pre + _touchstart + id] = onTouchStart;\n    obj[_pre + _touchend + id] = onTouchEnd;\n    obj[_pre + 'dblclick' + id] = handler;\n    obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? {\n      passive: false\n    } : false);\n    obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? {\n      passive: false\n    } : false); // On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),\n    // the browser doesn't fire touchend/pointerup events but does fire\n    // native dblclicks. See #4127.\n    // Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.\n\n    obj.addEventListener('dblclick', handler, false);\n    return this;\n  }\n\n  function removeDoubleTapListener(obj, id) {\n    var touchstart = obj[_pre + _touchstart + id],\n        touchend = obj[_pre + _touchend + id],\n        dblclick = obj[_pre + 'dblclick' + id];\n    obj.removeEventListener(_touchstart, touchstart, passiveEvents ? {\n      passive: false\n    } : false);\n    obj.removeEventListener(_touchend, touchend, passiveEvents ? {\n      passive: false\n    } : false);\n\n    if (!edge) {\n      obj.removeEventListener('dblclick', dblclick, false);\n    }\n\n    return this;\n  }\n  /*\r\n   * @namespace DomUtil\r\n   *\r\n   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)\r\n   * tree, used by Leaflet internally.\r\n   *\r\n   * Most functions expecting or returning a `HTMLElement` also work for\r\n   * SVG elements. The only difference is that classes refer to CSS classes\r\n   * in HTML and SVG classes in SVG.\r\n   */\n  // @property TRANSFORM: String\n  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).\n\n\n  var TRANSFORM = testProp(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']); // webkitTransition comes first because some browser versions that drop vendor prefix don't do\n  // the same for the transitionend event, in particular the Android 4.1 stock browser\n  // @property TRANSITION: String\n  // Vendor-prefixed transition style name.\n\n  var TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']); // @property TRANSITION_END: String\n  // Vendor-prefixed transitionend event name.\n\n  var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend'; // @function get(id: String|HTMLElement): HTMLElement\n  // Returns an element given its DOM id, or returns the element itself\n  // if it was passed directly.\n\n  function get(id) {\n    return typeof id === 'string' ? document.getElementById(id) : id;\n  } // @function getStyle(el: HTMLElement, styleAttrib: String): String\n  // Returns the value for a certain style attribute on an element,\n  // including computed values or values set through CSS.\n\n\n  function getStyle(el, style) {\n    var value = el.style[style] || el.currentStyle && el.currentStyle[style];\n\n    if ((!value || value === 'auto') && document.defaultView) {\n      var css = document.defaultView.getComputedStyle(el, null);\n      value = css ? css[style] : null;\n    }\n\n    return value === 'auto' ? null : value;\n  } // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement\n  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.\n\n\n  function create$1(tagName, className, container) {\n    var el = document.createElement(tagName);\n    el.className = className || '';\n\n    if (container) {\n      container.appendChild(el);\n    }\n\n    return el;\n  } // @function remove(el: HTMLElement)\n  // Removes `el` from its parent element\n\n\n  function remove(el) {\n    var parent = el.parentNode;\n\n    if (parent) {\n      parent.removeChild(el);\n    }\n  } // @function empty(el: HTMLElement)\n  // Removes all of `el`'s children elements from `el`\n\n\n  function empty(el) {\n    while (el.firstChild) {\n      el.removeChild(el.firstChild);\n    }\n  } // @function toFront(el: HTMLElement)\n  // Makes `el` the last child of its parent, so it renders in front of the other children.\n\n\n  function toFront(el) {\n    var parent = el.parentNode;\n\n    if (parent && parent.lastChild !== el) {\n      parent.appendChild(el);\n    }\n  } // @function toBack(el: HTMLElement)\n  // Makes `el` the first child of its parent, so it renders behind the other children.\n\n\n  function toBack(el) {\n    var parent = el.parentNode;\n\n    if (parent && parent.firstChild !== el) {\n      parent.insertBefore(el, parent.firstChild);\n    }\n  } // @function hasClass(el: HTMLElement, name: String): Boolean\n  // Returns `true` if the element's class attribute contains `name`.\n\n\n  function hasClass(el, name) {\n    if (el.classList !== undefined) {\n      return el.classList.contains(name);\n    }\n\n    var className = getClass(el);\n    return className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\n  } // @function addClass(el: HTMLElement, name: String)\n  // Adds `name` to the element's class attribute.\n\n\n  function addClass(el, name) {\n    if (el.classList !== undefined) {\n      var classes = splitWords(name);\n\n      for (var i = 0, len = classes.length; i < len; i++) {\n        el.classList.add(classes[i]);\n      }\n    } else if (!hasClass(el, name)) {\n      var className = getClass(el);\n      setClass(el, (className ? className + ' ' : '') + name);\n    }\n  } // @function removeClass(el: HTMLElement, name: String)\n  // Removes `name` from the element's class attribute.\n\n\n  function removeClass(el, name) {\n    if (el.classList !== undefined) {\n      el.classList.remove(name);\n    } else {\n      setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\n    }\n  } // @function setClass(el: HTMLElement, name: String)\n  // Sets the element's class.\n\n\n  function setClass(el, name) {\n    if (el.className.baseVal === undefined) {\n      el.className = name;\n    } else {\n      // in case of SVG element\n      el.className.baseVal = name;\n    }\n  } // @function getClass(el: HTMLElement): String\n  // Returns the element's class.\n\n\n  function getClass(el) {\n    // Check if the element is an SVGElementInstance and use the correspondingElement instead\n    // (Required for linked SVG elements in IE11.)\n    if (el.correspondingElement) {\n      el = el.correspondingElement;\n    }\n\n    return el.className.baseVal === undefined ? el.className : el.className.baseVal;\n  } // @function setOpacity(el: HTMLElement, opacity: Number)\n  // Set the opacity of an element (including old IE support).\n  // `opacity` must be a number from `0` to `1`.\n\n\n  function setOpacity(el, value) {\n    if ('opacity' in el.style) {\n      el.style.opacity = value;\n    } else if ('filter' in el.style) {\n      _setOpacityIE(el, value);\n    }\n  }\n\n  function _setOpacityIE(el, value) {\n    var filter = false,\n        filterName = 'DXImageTransform.Microsoft.Alpha'; // filters collection throws an error if we try to retrieve a filter that doesn't exist\n\n    try {\n      filter = el.filters.item(filterName);\n    } catch (e) {\n      // don't set opacity to 1 if we haven't already set an opacity,\n      // it isn't needed and breaks transparent pngs.\n      if (value === 1) {\n        return;\n      }\n    }\n\n    value = Math.round(value * 100);\n\n    if (filter) {\n      filter.Enabled = value !== 100;\n      filter.Opacity = value;\n    } else {\n      el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\n    }\n  } // @function testProp(props: String[]): String|false\n  // Goes through the array of style names and returns the first name\n  // that is a valid style name for an element. If no such name is found,\n  // it returns false. Useful for vendor-prefixed styles like `transform`.\n\n\n  function testProp(props) {\n    var style = document.documentElement.style;\n\n    for (var i = 0; i < props.length; i++) {\n      if (props[i] in style) {\n        return props[i];\n      }\n    }\n\n    return false;\n  } // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)\n  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\n  // and optionally scaled by `scale`. Does not have an effect if the\n  // browser doesn't support 3D CSS transforms.\n\n\n  function setTransform(el, offset, scale) {\n    var pos = offset || new Point(0, 0);\n    el.style[TRANSFORM] = (ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');\n  } // @function setPosition(el: HTMLElement, position: Point)\n  // Sets the position of `el` to coordinates specified by `position`,\n  // using CSS translate or top/left positioning depending on the browser\n  // (used by Leaflet internally to position its layers).\n\n\n  function setPosition(el, point) {\n    /*eslint-disable */\n    el._leaflet_pos = point;\n    /* eslint-enable */\n\n    if (any3d) {\n      setTransform(el, point);\n    } else {\n      el.style.left = point.x + 'px';\n      el.style.top = point.y + 'px';\n    }\n  } // @function getPosition(el: HTMLElement): Point\n  // Returns the coordinates of an element previously positioned with setPosition.\n\n\n  function getPosition(el) {\n    // this method is only used for elements previously positioned using setPosition,\n    // so it's safe to cache the position for performance\n    return el._leaflet_pos || new Point(0, 0);\n  } // @function disableTextSelection()\n  // Prevents the user from generating `selectstart` DOM events, usually generated\n  // when the user drags the mouse through a page with text. Used internally\n  // by Leaflet to override the behaviour of any click-and-drag interaction on\n  // the map. Affects drag interactions on the whole document.\n  // @function enableTextSelection()\n  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).\n\n\n  var disableTextSelection;\n  var enableTextSelection;\n\n  var _userSelect;\n\n  if ('onselectstart' in document) {\n    disableTextSelection = function () {\n      on(window, 'selectstart', preventDefault);\n    };\n\n    enableTextSelection = function () {\n      off(window, 'selectstart', preventDefault);\n    };\n  } else {\n    var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\n\n    disableTextSelection = function () {\n      if (userSelectProperty) {\n        var style = document.documentElement.style;\n        _userSelect = style[userSelectProperty];\n        style[userSelectProperty] = 'none';\n      }\n    };\n\n    enableTextSelection = function () {\n      if (userSelectProperty) {\n        document.documentElement.style[userSelectProperty] = _userSelect;\n        _userSelect = undefined;\n      }\n    };\n  } // @function disableImageDrag()\n  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but\n  // for `dragstart` DOM events, usually generated when the user drags an image.\n\n\n  function disableImageDrag() {\n    on(window, 'dragstart', preventDefault);\n  } // @function enableImageDrag()\n  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).\n\n\n  function enableImageDrag() {\n    off(window, 'dragstart', preventDefault);\n  }\n\n  var _outlineElement;\n\n  var _outlineStyle; // @function preventOutline(el: HTMLElement)\n  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)\n  // of the element `el` invisible. Used internally by Leaflet to prevent\n  // focusable elements from displaying an outline when the user performs a\n  // drag interaction on them.\n\n\n  function preventOutline(element) {\n    while (element.tabIndex === -1) {\n      element = element.parentNode;\n    }\n\n    if (!element.style) {\n      return;\n    }\n\n    restoreOutline();\n    _outlineElement = element;\n    _outlineStyle = element.style.outline;\n    element.style.outline = 'none';\n    on(window, 'keydown', restoreOutline);\n  } // @function restoreOutline()\n  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().\n\n\n  function restoreOutline() {\n    if (!_outlineElement) {\n      return;\n    }\n\n    _outlineElement.style.outline = _outlineStyle;\n    _outlineElement = undefined;\n    _outlineStyle = undefined;\n    off(window, 'keydown', restoreOutline);\n  } // @function getSizedParentNode(el: HTMLElement): HTMLElement\n  // Finds the closest parent node which size (width and height) is not null.\n\n\n  function getSizedParentNode(element) {\n    do {\n      element = element.parentNode;\n    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);\n\n    return element;\n  } // @function getScale(el: HTMLElement): Object\n  // Computes the CSS scale currently applied on the element.\n  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,\n  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\n\n\n  function getScale(element) {\n    var rect = element.getBoundingClientRect(); // Read-only in old browsers.\n\n    return {\n      x: rect.width / element.offsetWidth || 1,\n      y: rect.height / element.offsetHeight || 1,\n      boundingClientRect: rect\n    };\n  }\n\n  var DomUtil = (Object.freeze || Object)({\n    TRANSFORM: TRANSFORM,\n    TRANSITION: TRANSITION,\n    TRANSITION_END: TRANSITION_END,\n    get: get,\n    getStyle: getStyle,\n    create: create$1,\n    remove: remove,\n    empty: empty,\n    toFront: toFront,\n    toBack: toBack,\n    hasClass: hasClass,\n    addClass: addClass,\n    removeClass: removeClass,\n    setClass: setClass,\n    getClass: getClass,\n    setOpacity: setOpacity,\n    testProp: testProp,\n    setTransform: setTransform,\n    setPosition: setPosition,\n    getPosition: getPosition,\n    disableTextSelection: disableTextSelection,\n    enableTextSelection: enableTextSelection,\n    disableImageDrag: disableImageDrag,\n    enableImageDrag: enableImageDrag,\n    preventOutline: preventOutline,\n    restoreOutline: restoreOutline,\n    getSizedParentNode: getSizedParentNode,\n    getScale: getScale\n  });\n  /*\r\n   * @namespace DomEvent\r\n   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.\r\n   */\n  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\n  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Adds a listener function (`fn`) to a particular DOM event type of the\n  // element `el`. You can optionally specify the context of the listener\n  // (object the `this` keyword will point to). You can also pass several\n  // space-separated types (e.g. `'click dblclick'`).\n  // @alternative\n  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n\n  function on(obj, types, fn, context) {\n    if (typeof types === 'object') {\n      for (var type in types) {\n        addOne(obj, type, types[type], fn);\n      }\n    } else {\n      types = splitWords(types);\n\n      for (var i = 0, len = types.length; i < len; i++) {\n        addOne(obj, types[i], fn, context);\n      }\n    }\n\n    return this;\n  }\n\n  var eventsKey = '_leaflet_events'; // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this\n  // Removes a previously added listener function.\n  // Note that if you passed a custom context to on, you must pass the same\n  // context to `off` in order to remove the listener.\n  // @alternative\n  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this\n  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n\n  function off(obj, types, fn, context) {\n    if (typeof types === 'object') {\n      for (var type in types) {\n        removeOne(obj, type, types[type], fn);\n      }\n    } else if (types) {\n      types = splitWords(types);\n\n      for (var i = 0, len = types.length; i < len; i++) {\n        removeOne(obj, types[i], fn, context);\n      }\n    } else {\n      for (var j in obj[eventsKey]) {\n        removeOne(obj, j, obj[eventsKey][j]);\n      }\n\n      delete obj[eventsKey];\n    }\n\n    return this;\n  }\n\n  function addOne(obj, type, fn, context) {\n    var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');\n\n    if (obj[eventsKey] && obj[eventsKey][id]) {\n      return this;\n    }\n\n    var handler = function (e) {\n      return fn.call(context || obj, e || window.event);\n    };\n\n    var originalHandler = handler;\n\n    if (pointer && type.indexOf('touch') === 0) {\n      // Needs DomEvent.Pointer.js\n      addPointerListener(obj, type, handler, id);\n    } else if (touch && type === 'dblclick' && addDoubleTapListener && !(pointer && chrome)) {\n      // Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener\n      // See #5180\n      addDoubleTapListener(obj, handler, id);\n    } else if ('addEventListener' in obj) {\n      if (type === 'mousewheel') {\n        obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, passiveEvents ? {\n          passive: false\n        } : false);\n      } else if (type === 'mouseenter' || type === 'mouseleave') {\n        handler = function (e) {\n          e = e || window.event;\n\n          if (isExternalTarget(obj, e)) {\n            originalHandler(e);\n          }\n        };\n\n        obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);\n      } else {\n        if (type === 'click' && android) {\n          handler = function (e) {\n            filterClick(e, originalHandler);\n          };\n        }\n\n        obj.addEventListener(type, handler, false);\n      }\n    } else if ('attachEvent' in obj) {\n      obj.attachEvent('on' + type, handler);\n    }\n\n    obj[eventsKey] = obj[eventsKey] || {};\n    obj[eventsKey][id] = handler;\n  }\n\n  function removeOne(obj, type, fn, context) {\n    var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),\n        handler = obj[eventsKey] && obj[eventsKey][id];\n\n    if (!handler) {\n      return this;\n    }\n\n    if (pointer && type.indexOf('touch') === 0) {\n      removePointerListener(obj, type, id);\n    } else if (touch && type === 'dblclick' && removeDoubleTapListener && !(pointer && chrome)) {\n      removeDoubleTapListener(obj, id);\n    } else if ('removeEventListener' in obj) {\n      if (type === 'mousewheel') {\n        obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, passiveEvents ? {\n          passive: false\n        } : false);\n      } else {\n        obj.removeEventListener(type === 'mouseenter' ? 'mouseover' : type === 'mouseleave' ? 'mouseout' : type, handler, false);\n      }\n    } else if ('detachEvent' in obj) {\n      obj.detachEvent('on' + type, handler);\n    }\n\n    obj[eventsKey][id] = null;\n  } // @function stopPropagation(ev: DOMEvent): this\n  // Stop the given event from propagation to parent elements. Used inside the listener functions:\n  // ```js\n  // L.DomEvent.on(div, 'click', function (ev) {\n  // \tL.DomEvent.stopPropagation(ev);\n  // });\n  // ```\n\n\n  function stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else if (e.originalEvent) {\n      // In case of Leaflet event.\n      e.originalEvent._stopped = true;\n    } else {\n      e.cancelBubble = true;\n    }\n\n    skipped(e);\n    return this;\n  } // @function disableScrollPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).\n\n\n  function disableScrollPropagation(el) {\n    addOne(el, 'mousewheel', stopPropagation);\n    return this;\n  } // @function disableClickPropagation(el: HTMLElement): this\n  // Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,\n  // `'mousedown'` and `'touchstart'` events (plus browser variants).\n\n\n  function disableClickPropagation(el) {\n    on(el, 'mousedown touchstart dblclick', stopPropagation);\n    addOne(el, 'click', fakeStop);\n    return this;\n  } // @function preventDefault(ev: DOMEvent): this\n  // Prevents the default action of the DOM Event `ev` from happening (such as\n  // following a link in the href of the a element, or doing a POST request\n  // with page reload when a `<form>` is submitted).\n  // Use it inside listener functions.\n\n\n  function preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n    } else {\n      e.returnValue = false;\n    }\n\n    return this;\n  } // @function stop(ev: DOMEvent): this\n  // Does `stopPropagation` and `preventDefault` at the same time.\n\n\n  function stop(e) {\n    preventDefault(e);\n    stopPropagation(e);\n    return this;\n  } // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point\n  // Gets normalized mouse position from a DOM event relative to the\n  // `container` (border excluded) or to the whole page if not specified.\n\n\n  function getMousePosition(e, container) {\n    if (!container) {\n      return new Point(e.clientX, e.clientY);\n    }\n\n    var scale = getScale(container),\n        offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)\n\n    return new Point( // offset.left/top values are in page scale (like clientX/Y),\n    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).\n    (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);\n  } // Chrome on Win scrolls double the pixels as in other platforms (see #4538),\n  // and Firefox scrolls device pixels, not CSS pixels\n\n\n  var wheelPxFactor = win && chrome ? 2 * window.devicePixelRatio : gecko ? window.devicePixelRatio : 1; // @function getWheelDelta(ev: DOMEvent): Number\n  // Gets normalized wheel delta from a mousewheel DOM event, in vertical\n  // pixels scrolled (negative if scrolling down).\n  // Events from pointing devices without precise scrolling are mapped to\n  // a best guess of 60 pixels.\n\n  function getWheelDelta(e) {\n    return edge ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta\n    e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : // Pixels\n    e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : // Lines\n    e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : // Pages\n    e.deltaX || e.deltaZ ? 0 : // Skip horizontal/depth wheel events\n    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels\n    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : // Legacy Moz lines\n    e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages\n    0;\n  }\n\n  var skipEvents = {};\n\n  function fakeStop(e) {\n    // fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)\n    skipEvents[e.type] = true;\n  }\n\n  function skipped(e) {\n    var events = skipEvents[e.type]; // reset when checking, as it's only used in map container and propagates outside of the map\n\n    skipEvents[e.type] = false;\n    return events;\n  } // check if element really left/entered the event target (for mouseenter/mouseleave)\n\n\n  function isExternalTarget(el, e) {\n    var related = e.relatedTarget;\n\n    if (!related) {\n      return true;\n    }\n\n    try {\n      while (related && related !== el) {\n        related = related.parentNode;\n      }\n    } catch (err) {\n      return false;\n    }\n\n    return related !== el;\n  }\n\n  var lastClick; // this is a horrible workaround for a bug in Android where a single touch triggers two click events\n\n  function filterClick(e, handler) {\n    var timeStamp = e.timeStamp || e.originalEvent && e.originalEvent.timeStamp,\n        elapsed = lastClick && timeStamp - lastClick; // are they closer together than 500ms yet more than 100ms?\n    // Android typically triggers them ~300ms apart while multiple listeners\n    // on the same event should be triggered far faster;\n    // or check if click is simulated on the element, and if it is, reject any non-simulated events\n\n    if (elapsed && elapsed > 100 && elapsed < 500 || e.target._simulatedClick && !e._simulated) {\n      stop(e);\n      return;\n    }\n\n    lastClick = timeStamp;\n    handler(e);\n  }\n\n  var DomEvent = (Object.freeze || Object)({\n    on: on,\n    off: off,\n    stopPropagation: stopPropagation,\n    disableScrollPropagation: disableScrollPropagation,\n    disableClickPropagation: disableClickPropagation,\n    preventDefault: preventDefault,\n    stop: stop,\n    getMousePosition: getMousePosition,\n    getWheelDelta: getWheelDelta,\n    fakeStop: fakeStop,\n    skipped: skipped,\n    isExternalTarget: isExternalTarget,\n    addListener: on,\n    removeListener: off\n  });\n  /*\n   * @class PosAnimation\n   * @aka L.PosAnimation\n   * @inherits Evented\n   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.\n   *\n   * @example\n   * ```js\n   * var fx = new L.PosAnimation();\n   * fx.run(el, [300, 500], 0.5);\n   * ```\n   *\n   * @constructor L.PosAnimation()\n   * Creates a `PosAnimation` object.\n   *\n   */\n\n  var PosAnimation = Evented.extend({\n    // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)\n    // Run an animation of a given element to a new position, optionally setting\n    // duration in seconds (`0.25` by default) and easing linearity factor (3rd\n    // argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),\n    // `0.5` by default).\n    run: function (el, newPos, duration, easeLinearity) {\n      this.stop();\n      this._el = el;\n      this._inProgress = true;\n      this._duration = duration || 0.25;\n      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n      this._startPos = getPosition(el);\n      this._offset = newPos.subtract(this._startPos);\n      this._startTime = +new Date(); // @event start: Event\n      // Fired when the animation starts\n\n      this.fire('start');\n\n      this._animate();\n    },\n    // @method stop()\n    // Stops the animation (if currently running).\n    stop: function () {\n      if (!this._inProgress) {\n        return;\n      }\n\n      this._step(true);\n\n      this._complete();\n    },\n    _animate: function () {\n      // animation loop\n      this._animId = requestAnimFrame(this._animate, this);\n\n      this._step();\n    },\n    _step: function (round) {\n      var elapsed = +new Date() - this._startTime,\n          duration = this._duration * 1000;\n\n      if (elapsed < duration) {\n        this._runFrame(this._easeOut(elapsed / duration), round);\n      } else {\n        this._runFrame(1);\n\n        this._complete();\n      }\n    },\n    _runFrame: function (progress, round) {\n      var pos = this._startPos.add(this._offset.multiplyBy(progress));\n\n      if (round) {\n        pos._round();\n      }\n\n      setPosition(this._el, pos); // @event step: Event\n      // Fired continuously during the animation.\n\n      this.fire('step');\n    },\n    _complete: function () {\n      cancelAnimFrame(this._animId);\n      this._inProgress = false; // @event end: Event\n      // Fired when the animation ends.\n\n      this.fire('end');\n    },\n    _easeOut: function (t) {\n      return 1 - Math.pow(1 - t, this._easeOutPower);\n    }\n  });\n  /*\r\n   * @class Map\r\n   * @aka L.Map\r\n   * @inherits Evented\r\n   *\r\n   * The central class of the API — it is used to create a map on a page and manipulate it.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * // initialize the map on the \"map\" div with a given center and zoom\r\n   * var map = L.map('map', {\r\n   * \tcenter: [51.505, -0.09],\r\n   * \tzoom: 13\r\n   * });\r\n   * ```\r\n   *\r\n   */\n\n  var Map = Evented.extend({\n    options: {\n      // @section Map State Options\n      // @option crs: CRS = L.CRS.EPSG3857\n      // The [Coordinate Reference System](#crs) to use. Don't change this if you're not\n      // sure what it means.\n      crs: EPSG3857,\n      // @option center: LatLng = undefined\n      // Initial geographic center of the map\n      center: undefined,\n      // @option zoom: Number = undefined\n      // Initial map zoom level\n      zoom: undefined,\n      // @option minZoom: Number = *\n      // Minimum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the lowest of their `minZoom` options will be used instead.\n      minZoom: undefined,\n      // @option maxZoom: Number = *\n      // Maximum zoom level of the map.\n      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n      // the highest of their `maxZoom` options will be used instead.\n      maxZoom: undefined,\n      // @option layers: Layer[] = []\n      // Array of layers that will be added to the map initially\n      layers: [],\n      // @option maxBounds: LatLngBounds = null\n      // When this option is set, the map restricts the view to the given\n      // geographical bounds, bouncing the user back if the user tries to pan\n      // outside the view. To set the restriction dynamically, use\n      // [`setMaxBounds`](#map-setmaxbounds) method.\n      maxBounds: undefined,\n      // @option renderer: Renderer = *\n      // The default method for drawing vector layers on the map. `L.SVG`\n      // or `L.Canvas` by default depending on browser support.\n      renderer: undefined,\n      // @section Animation Options\n      // @option zoomAnimation: Boolean = true\n      // Whether the map zoom animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      zoomAnimation: true,\n      // @option zoomAnimationThreshold: Number = 4\n      // Won't animate zoom if the zoom difference exceeds this value.\n      zoomAnimationThreshold: 4,\n      // @option fadeAnimation: Boolean = true\n      // Whether the tile fade animation is enabled. By default it's enabled\n      // in all browsers that support CSS3 Transitions except Android.\n      fadeAnimation: true,\n      // @option markerZoomAnimation: Boolean = true\n      // Whether markers animate their zoom with the zoom animation, if disabled\n      // they will disappear for the length of the animation. By default it's\n      // enabled in all browsers that support CSS3 Transitions except Android.\n      markerZoomAnimation: true,\n      // @option transform3DLimit: Number = 2^23\n      // Defines the maximum size of a CSS translation transform. The default\n      // value should not be changed unless a web browser positions layers in\n      // the wrong place after doing a large `panBy`.\n      transform3DLimit: 8388608,\n      // Precision limit of a 32-bit float\n      // @section Interaction Options\n      // @option zoomSnap: Number = 1\n      // Forces the map's zoom level to always be a multiple of this, particularly\n      // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\n      // By default, the zoom level snaps to the nearest integer; lower values\n      // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\n      // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\n      zoomSnap: 1,\n      // @option zoomDelta: Number = 1\n      // Controls how much the map's zoom level will change after a\n      // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\n      // or `-` on the keyboard, or using the [zoom controls](#control-zoom).\n      // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\n      zoomDelta: 1,\n      // @option trackResize: Boolean = true\n      // Whether the map automatically handles browser window resize to update itself.\n      trackResize: true\n    },\n    initialize: function (id, options) {\n      // (HTMLElement or String, Object)\n      options = setOptions(this, options); // Make sure to assign internal flags at the beginning,\n      // to avoid inconsistent state in some edge cases.\n\n      this._handlers = [];\n      this._layers = {};\n      this._zoomBoundLayers = {};\n      this._sizeChanged = true;\n\n      this._initContainer(id);\n\n      this._initLayout(); // hack for https://github.com/Leaflet/Leaflet/issues/1980\n\n\n      this._onResize = bind(this._onResize, this);\n\n      this._initEvents();\n\n      if (options.maxBounds) {\n        this.setMaxBounds(options.maxBounds);\n      }\n\n      if (options.zoom !== undefined) {\n        this._zoom = this._limitZoom(options.zoom);\n      }\n\n      if (options.center && options.zoom !== undefined) {\n        this.setView(toLatLng(options.center), options.zoom, {\n          reset: true\n        });\n      }\n\n      this.callInitHooks(); // don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\n      this._zoomAnimated = TRANSITION && any3d && !mobileOpera && this.options.zoomAnimation; // zoom transitions run with the same duration for all layers, so if one of transitionend events\n      // happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\n      if (this._zoomAnimated) {\n        this._createAnimProxy();\n\n        on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);\n      }\n\n      this._addLayers(this.options.layers);\n    },\n    // @section Methods for modifying map state\n    // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) with the given\n    // animation options.\n    setView: function (center, zoom, options) {\n      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n      center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\n      options = options || {};\n\n      this._stop();\n\n      if (this._loaded && !options.reset && options !== true) {\n        if (options.animate !== undefined) {\n          options.zoom = extend({\n            animate: options.animate\n          }, options.zoom);\n          options.pan = extend({\n            animate: options.animate,\n            duration: options.duration\n          }, options.pan);\n        } // try animating pan or zoom\n\n\n        var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);\n\n        if (moved) {\n          // prevent resize handler call, the view will refresh after animation anyway\n          clearTimeout(this._sizeTimer);\n          return this;\n        }\n      } // animation didn't start, just reset the map view\n\n\n      this._resetView(center, zoom);\n\n      return this;\n    },\n    // @method setZoom(zoom: Number, options?: Zoom/pan options): this\n    // Sets the zoom of the map.\n    setZoom: function (zoom, options) {\n      if (!this._loaded) {\n        this._zoom = zoom;\n        return this;\n      }\n\n      return this.setView(this.getCenter(), zoom, {\n        zoom: options\n      });\n    },\n    // @method zoomIn(delta?: Number, options?: Zoom options): this\n    // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomIn: function (delta, options) {\n      delta = delta || (any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom + delta, options);\n    },\n    // @method zoomOut(delta?: Number, options?: Zoom options): this\n    // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n    zoomOut: function (delta, options) {\n      delta = delta || (any3d ? this.options.zoomDelta : 1);\n      return this.setZoom(this._zoom - delta, options);\n    },\n    // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified geographical point on the map\n    // stationary (e.g. used internally for scroll zoom and double-click zoom).\n    // @alternative\n    // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\n    // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\n    setZoomAround: function (latlng, zoom, options) {\n      var scale = this.getZoomScale(zoom),\n          viewHalf = this.getSize().divideBy(2),\n          containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),\n          centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\n          newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\n      return this.setView(newCenter, zoom, {\n        zoom: options\n      });\n    },\n    _getBoundsCenterZoom: function (bounds, options) {\n      options = options || {};\n      bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n          zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n      zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;\n\n      if (zoom === Infinity) {\n        return {\n          center: bounds.getCenter(),\n          zoom: zoom\n        };\n      }\n\n      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\n          swPoint = this.project(bounds.getSouthWest(), zoom),\n          nePoint = this.project(bounds.getNorthEast(), zoom),\n          center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\n      return {\n        center: center,\n        zoom: zoom\n      };\n    },\n    // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets a map view that contains the given geographical bounds with the\n    // maximum zoom level possible.\n    fitBounds: function (bounds, options) {\n      bounds = toLatLngBounds(bounds);\n\n      if (!bounds.isValid()) {\n        throw new Error('Bounds are not valid.');\n      }\n\n      var target = this._getBoundsCenterZoom(bounds, options);\n\n      return this.setView(target.center, target.zoom, options);\n    },\n    // @method fitWorld(options?: fitBounds options): this\n    // Sets a map view that mostly contains the whole world with the maximum\n    // zoom level possible.\n    fitWorld: function (options) {\n      return this.fitBounds([[-90, -180], [90, 180]], options);\n    },\n    // @method panTo(latlng: LatLng, options?: Pan options): this\n    // Pans the map to a given center.\n    panTo: function (center, options) {\n      // (LatLng)\n      return this.setView(center, this._zoom, {\n        pan: options\n      });\n    },\n    // @method panBy(offset: Point, options?: Pan options): this\n    // Pans the map by a given number of pixels (animated).\n    panBy: function (offset, options) {\n      offset = toPoint(offset).round();\n      options = options || {};\n\n      if (!offset.x && !offset.y) {\n        return this.fire('moveend');\n      } // If we pan too far, Chrome gets issues with tiles\n      // and makes them disappear or appear in the wrong place (slightly offset) #2602\n\n\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\n\n        return this;\n      }\n\n      if (!this._panAnim) {\n        this._panAnim = new PosAnimation();\n\n        this._panAnim.on({\n          'step': this._onPanTransitionStep,\n          'end': this._onPanTransitionEnd\n        }, this);\n      } // don't fire movestart if animating inertia\n\n\n      if (!options.noMoveStart) {\n        this.fire('movestart');\n      } // animate pan unless animate: false specified\n\n\n      if (options.animate !== false) {\n        addClass(this._mapPane, 'leaflet-pan-anim');\n\n        var newPos = this._getMapPanePos().subtract(offset).round();\n\n        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n      } else {\n        this._rawPanBy(offset);\n\n        this.fire('move').fire('moveend');\n      }\n\n      return this;\n    },\n    // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\n    // Sets the view of the map (geographical center and zoom) performing a smooth\n    // pan-zoom animation.\n    flyTo: function (targetCenter, targetZoom, options) {\n      options = options || {};\n\n      if (options.animate === false || !any3d) {\n        return this.setView(targetCenter, targetZoom, options);\n      }\n\n      this._stop();\n\n      var from = this.project(this.getCenter()),\n          to = this.project(targetCenter),\n          size = this.getSize(),\n          startZoom = this._zoom;\n      targetCenter = toLatLng(targetCenter);\n      targetZoom = targetZoom === undefined ? startZoom : targetZoom;\n      var w0 = Math.max(size.x, size.y),\n          w1 = w0 * this.getZoomScale(startZoom, targetZoom),\n          u1 = to.distanceTo(from) || 1,\n          rho = 1.42,\n          rho2 = rho * rho;\n\n      function r(i) {\n        var s1 = i ? -1 : 1,\n            s2 = i ? w1 : w0,\n            t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,\n            b1 = 2 * s2 * rho2 * u1,\n            b = t1 / b1,\n            sq = Math.sqrt(b * b + 1) - b; // workaround for floating point precision bug when sq = 0, log = -Infinite,\n        // thus triggering an infinite loop in flyTo\n\n        var log = sq < 0.000000001 ? -18 : Math.log(sq);\n        return log;\n      }\n\n      function sinh(n) {\n        return (Math.exp(n) - Math.exp(-n)) / 2;\n      }\n\n      function cosh(n) {\n        return (Math.exp(n) + Math.exp(-n)) / 2;\n      }\n\n      function tanh(n) {\n        return sinh(n) / cosh(n);\n      }\n\n      var r0 = r(0);\n\n      function w(s) {\n        return w0 * (cosh(r0) / cosh(r0 + rho * s));\n      }\n\n      function u(s) {\n        return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;\n      }\n\n      function easeOut(t) {\n        return 1 - Math.pow(1 - t, 1.5);\n      }\n\n      var start = Date.now(),\n          S = (r(1) - r0) / rho,\n          duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\n\n      function frame() {\n        var t = (Date.now() - start) / duration,\n            s = easeOut(t) * S;\n\n        if (t <= 1) {\n          this._flyToFrame = requestAnimFrame(frame, this);\n\n          this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {\n            flyTo: true\n          });\n        } else {\n          this._move(targetCenter, targetZoom)._moveEnd(true);\n        }\n      }\n\n      this._moveStart(true, options.noMoveStart);\n\n      frame.call(this);\n      return this;\n    },\n    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\n    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\n    flyToBounds: function (bounds, options) {\n      var target = this._getBoundsCenterZoom(bounds, options);\n\n      return this.flyTo(target.center, target.zoom, options);\n    },\n    // @method setMaxBounds(bounds: Bounds): this\n    // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\n    setMaxBounds: function (bounds) {\n      bounds = toLatLngBounds(bounds);\n\n      if (!bounds.isValid()) {\n        this.options.maxBounds = null;\n        return this.off('moveend', this._panInsideMaxBounds);\n      } else if (this.options.maxBounds) {\n        this.off('moveend', this._panInsideMaxBounds);\n      }\n\n      this.options.maxBounds = bounds;\n\n      if (this._loaded) {\n        this._panInsideMaxBounds();\n      }\n\n      return this.on('moveend', this._panInsideMaxBounds);\n    },\n    // @method setMinZoom(zoom: Number): this\n    // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\n    setMinZoom: function (zoom) {\n      var oldZoom = this.options.minZoom;\n      this.options.minZoom = zoom;\n\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n\n        if (this.getZoom() < this.options.minZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n\n      return this;\n    },\n    // @method setMaxZoom(zoom: Number): this\n    // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\n    setMaxZoom: function (zoom) {\n      var oldZoom = this.options.maxZoom;\n      this.options.maxZoom = zoom;\n\n      if (this._loaded && oldZoom !== zoom) {\n        this.fire('zoomlevelschange');\n\n        if (this.getZoom() > this.options.maxZoom) {\n          return this.setZoom(zoom);\n        }\n      }\n\n      return this;\n    },\n    // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\n    // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\n    panInsideBounds: function (bounds, options) {\n      this._enforcingBounds = true;\n\n      var center = this.getCenter(),\n          newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\n\n      if (!center.equals(newCenter)) {\n        this.panTo(newCenter, options);\n      }\n\n      this._enforcingBounds = false;\n      return this;\n    },\n    // @method panInside(latlng: LatLng, options?: options): this\n    // Pans the map the minimum amount to make the `latlng` visible. Use\n    // `padding`, `paddingTopLeft` and `paddingTopRight` options to fit\n    // the display to more restricted bounds, like [`fitBounds`](#map-fitbounds).\n    // If `latlng` is already within the (optionally padded) display bounds,\n    // the map will not be panned.\n    panInside: function (latlng, options) {\n      options = options || {};\n      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\n          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\n          center = this.getCenter(),\n          pixelCenter = this.project(center),\n          pixelPoint = this.project(latlng),\n          pixelBounds = this.getPixelBounds(),\n          halfPixelBounds = pixelBounds.getSize().divideBy(2),\n          paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);\n\n      if (!paddedBounds.contains(pixelPoint)) {\n        this._enforcingBounds = true;\n        var diff = pixelCenter.subtract(pixelPoint),\n            newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);\n\n        if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {\n          newCenter.x = pixelCenter.x - diff.x;\n\n          if (diff.x > 0) {\n            newCenter.x += halfPixelBounds.x - paddingTL.x;\n          } else {\n            newCenter.x -= halfPixelBounds.x - paddingBR.x;\n          }\n        }\n\n        if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {\n          newCenter.y = pixelCenter.y - diff.y;\n\n          if (diff.y > 0) {\n            newCenter.y += halfPixelBounds.y - paddingTL.y;\n          } else {\n            newCenter.y -= halfPixelBounds.y - paddingBR.y;\n          }\n        }\n\n        this.panTo(this.unproject(newCenter), options);\n        this._enforcingBounds = false;\n      }\n\n      return this;\n    },\n    // @method invalidateSize(options: Zoom/pan options): this\n    // Checks if the map container size changed and updates the map if so —\n    // call it after you've changed the map size dynamically, also animating\n    // pan by default. If `options.pan` is `false`, panning will not occur.\n    // If `options.debounceMoveend` is `true`, it will delay `moveend` event so\n    // that it doesn't happen often even if the method is called many\n    // times in a row.\n    // @alternative\n    // @method invalidateSize(animate: Boolean): this\n    // Checks if the map container size changed and updates the map if so —\n    // call it after you've changed the map size dynamically, also animating\n    // pan by default.\n    invalidateSize: function (options) {\n      if (!this._loaded) {\n        return this;\n      }\n\n      options = extend({\n        animate: false,\n        pan: true\n      }, options === true ? {\n        animate: true\n      } : options);\n      var oldSize = this.getSize();\n      this._sizeChanged = true;\n      this._lastCenter = null;\n      var newSize = this.getSize(),\n          oldCenter = oldSize.divideBy(2).round(),\n          newCenter = newSize.divideBy(2).round(),\n          offset = oldCenter.subtract(newCenter);\n\n      if (!offset.x && !offset.y) {\n        return this;\n      }\n\n      if (options.animate && options.pan) {\n        this.panBy(offset);\n      } else {\n        if (options.pan) {\n          this._rawPanBy(offset);\n        }\n\n        this.fire('move');\n\n        if (options.debounceMoveend) {\n          clearTimeout(this._sizeTimer);\n          this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);\n        } else {\n          this.fire('moveend');\n        }\n      } // @section Map state change events\n      // @event resize: ResizeEvent\n      // Fired when the map is resized.\n\n\n      return this.fire('resize', {\n        oldSize: oldSize,\n        newSize: newSize\n      });\n    },\n    // @section Methods for modifying map state\n    // @method stop(): this\n    // Stops the currently running `panTo` or `flyTo` animation, if any.\n    stop: function () {\n      this.setZoom(this._limitZoom(this._zoom));\n\n      if (!this.options.zoomSnap) {\n        this.fire('viewreset');\n      }\n\n      return this._stop();\n    },\n    // @section Geolocation methods\n    // @method locate(options?: Locate options): this\n    // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\n    // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\n    // and optionally sets the map view to the user's location with respect to\n    // detection accuracy (or to the world view if geolocation failed).\n    // Note that, if your page doesn't use HTTPS, this method will fail in\n    // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\n    // See `Locate options` for more details.\n    locate: function (options) {\n      options = this._locateOptions = extend({\n        timeout: 10000,\n        watch: false // setView: false\n        // maxZoom: <Number>\n        // maximumAge: 0\n        // enableHighAccuracy: false\n\n      }, options);\n\n      if (!('geolocation' in navigator)) {\n        this._handleGeolocationError({\n          code: 0,\n          message: 'Geolocation not supported.'\n        });\n\n        return this;\n      }\n\n      var onResponse = bind(this._handleGeolocationResponse, this),\n          onError = bind(this._handleGeolocationError, this);\n\n      if (options.watch) {\n        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);\n      } else {\n        navigator.geolocation.getCurrentPosition(onResponse, onError, options);\n      }\n\n      return this;\n    },\n    // @method stopLocate(): this\n    // Stops watching location previously initiated by `map.locate({watch: true})`\n    // and aborts resetting the map view if map.locate was called with\n    // `{setView: true}`.\n    stopLocate: function () {\n      if (navigator.geolocation && navigator.geolocation.clearWatch) {\n        navigator.geolocation.clearWatch(this._locationWatchId);\n      }\n\n      if (this._locateOptions) {\n        this._locateOptions.setView = false;\n      }\n\n      return this;\n    },\n    _handleGeolocationError: function (error) {\n      var c = error.code,\n          message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');\n\n      if (this._locateOptions.setView && !this._loaded) {\n        this.fitWorld();\n      } // @section Location events\n      // @event locationerror: ErrorEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method) failed.\n\n\n      this.fire('locationerror', {\n        code: c,\n        message: 'Geolocation error: ' + message + '.'\n      });\n    },\n    _handleGeolocationResponse: function (pos) {\n      var lat = pos.coords.latitude,\n          lng = pos.coords.longitude,\n          latlng = new LatLng(lat, lng),\n          bounds = latlng.toBounds(pos.coords.accuracy * 2),\n          options = this._locateOptions;\n\n      if (options.setView) {\n        var zoom = this.getBoundsZoom(bounds);\n        this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\n      }\n\n      var data = {\n        latlng: latlng,\n        bounds: bounds,\n        timestamp: pos.timestamp\n      };\n\n      for (var i in pos.coords) {\n        if (typeof pos.coords[i] === 'number') {\n          data[i] = pos.coords[i];\n        }\n      } // @event locationfound: LocationEvent\n      // Fired when geolocation (using the [`locate`](#map-locate) method)\n      // went successfully.\n\n\n      this.fire('locationfound', data);\n    },\n    // TODO Appropriate docs section?\n    // @section Other Methods\n    // @method addHandler(name: String, HandlerClass: Function): this\n    // Adds a new `Handler` to the map, given its name and constructor function.\n    addHandler: function (name, HandlerClass) {\n      if (!HandlerClass) {\n        return this;\n      }\n\n      var handler = this[name] = new HandlerClass(this);\n\n      this._handlers.push(handler);\n\n      if (this.options[name]) {\n        handler.enable();\n      }\n\n      return this;\n    },\n    // @method remove(): this\n    // Destroys the map and clears all related event listeners.\n    remove: function () {\n      this._initEvents(true);\n\n      if (this._containerId !== this._container._leaflet_id) {\n        throw new Error('Map container is being reused by another instance');\n      }\n\n      try {\n        // throws error in IE6-8\n        delete this._container._leaflet_id;\n        delete this._containerId;\n      } catch (e) {\n        /*eslint-disable */\n        this._container._leaflet_id = undefined;\n        /* eslint-enable */\n\n        this._containerId = undefined;\n      }\n\n      if (this._locationWatchId !== undefined) {\n        this.stopLocate();\n      }\n\n      this._stop();\n\n      remove(this._mapPane);\n\n      if (this._clearControlPos) {\n        this._clearControlPos();\n      }\n\n      if (this._resizeRequest) {\n        cancelAnimFrame(this._resizeRequest);\n        this._resizeRequest = null;\n      }\n\n      this._clearHandlers();\n\n      if (this._loaded) {\n        // @section Map state change events\n        // @event unload: Event\n        // Fired when the map is destroyed with [remove](#map-remove) method.\n        this.fire('unload');\n      }\n\n      var i;\n\n      for (i in this._layers) {\n        this._layers[i].remove();\n      }\n\n      for (i in this._panes) {\n        remove(this._panes[i]);\n      }\n\n      this._layers = [];\n      this._panes = [];\n      delete this._mapPane;\n      delete this._renderer;\n      return this;\n    },\n    // @section Other Methods\n    // @method createPane(name: String, container?: HTMLElement): HTMLElement\n    // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\n    // then returns it. The pane is created as a child of `container`, or\n    // as a child of the main map pane if not set.\n    createPane: function (name, container) {\n      var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\n          pane = create$1('div', className, container || this._mapPane);\n\n      if (name) {\n        this._panes[name] = pane;\n      }\n\n      return pane;\n    },\n    // @section Methods for Getting Map State\n    // @method getCenter(): LatLng\n    // Returns the geographical center of the map view\n    getCenter: function () {\n      this._checkIfLoaded();\n\n      if (this._lastCenter && !this._moved()) {\n        return this._lastCenter;\n      }\n\n      return this.layerPointToLatLng(this._getCenterLayerPoint());\n    },\n    // @method getZoom(): Number\n    // Returns the current zoom level of the map view\n    getZoom: function () {\n      return this._zoom;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the geographical bounds visible in the current map view\n    getBounds: function () {\n      var bounds = this.getPixelBounds(),\n          sw = this.unproject(bounds.getBottomLeft()),\n          ne = this.unproject(bounds.getTopRight());\n      return new LatLngBounds(sw, ne);\n    },\n    // @method getMinZoom(): Number\n    // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\n    getMinZoom: function () {\n      return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\n    },\n    // @method getMaxZoom(): Number\n    // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\n    getMaxZoom: function () {\n      return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;\n    },\n    // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\n    // Returns the maximum zoom level on which the given bounds fit to the map\n    // view in its entirety. If `inside` (optional) is set to `true`, the method\n    // instead returns the minimum zoom level on which the map view fits into\n    // the given bounds in its entirety.\n    getBoundsZoom: function (bounds, inside, padding) {\n      // (LatLngBounds[, Boolean, Point]) -> Number\n      bounds = toLatLngBounds(bounds);\n      padding = toPoint(padding || [0, 0]);\n      var zoom = this.getZoom() || 0,\n          min = this.getMinZoom(),\n          max = this.getMaxZoom(),\n          nw = bounds.getNorthWest(),\n          se = bounds.getSouthEast(),\n          size = this.getSize().subtract(padding),\n          boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\n          snap = any3d ? this.options.zoomSnap : 1,\n          scalex = size.x / boundsSize.x,\n          scaley = size.y / boundsSize.y,\n          scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\n      zoom = this.getScaleZoom(scale, zoom);\n\n      if (snap) {\n        zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\n\n        zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\n      }\n\n      return Math.max(min, Math.min(max, zoom));\n    },\n    // @method getSize(): Point\n    // Returns the current size of the map container (in pixels).\n    getSize: function () {\n      if (!this._size || this._sizeChanged) {\n        this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);\n        this._sizeChanged = false;\n      }\n\n      return this._size.clone();\n    },\n    // @method getPixelBounds(): Bounds\n    // Returns the bounds of the current map view in projected pixel\n    // coordinates (sometimes useful in layer and overlay implementations).\n    getPixelBounds: function (center, zoom) {\n      var topLeftPoint = this._getTopLeftPoint(center, zoom);\n\n      return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n    },\n    // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\n    // the map pane? \"left point of the map layer\" can be confusing, specially\n    // since there can be negative offsets.\n    // @method getPixelOrigin(): Point\n    // Returns the projected pixel coordinates of the top left point of\n    // the map layer (useful in custom layer and overlay implementations).\n    getPixelOrigin: function () {\n      this._checkIfLoaded();\n\n      return this._pixelOrigin;\n    },\n    // @method getPixelWorldBounds(zoom?: Number): Bounds\n    // Returns the world's bounds in pixel coordinates for zoom level `zoom`.\n    // If `zoom` is omitted, the map's current zoom level is used.\n    getPixelWorldBounds: function (zoom) {\n      return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\n    },\n    // @section Other Methods\n    // @method getPane(pane: String|HTMLElement): HTMLElement\n    // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\n    getPane: function (pane) {\n      return typeof pane === 'string' ? this._panes[pane] : pane;\n    },\n    // @method getPanes(): Object\n    // Returns a plain object containing the names of all [panes](#map-pane) as keys and\n    // the panes as values.\n    getPanes: function () {\n      return this._panes;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the map.\n    getContainer: function () {\n      return this._container;\n    },\n    // @section Conversion Methods\n    // @method getZoomScale(toZoom: Number, fromZoom: Number): Number\n    // Returns the scale factor to be applied to a map transition from zoom level\n    // `fromZoom` to `toZoom`. Used internally to help with zoom animations.\n    getZoomScale: function (toZoom, fromZoom) {\n      // TODO replace with universal implementation after refactoring projections\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      return crs.scale(toZoom) / crs.scale(fromZoom);\n    },\n    // @method getScaleZoom(scale: Number, fromZoom: Number): Number\n    // Returns the zoom level that the map would end up at, if it is at `fromZoom`\n    // level and everything is scaled by a factor of `scale`. Inverse of\n    // [`getZoomScale`](#map-getZoomScale).\n    getScaleZoom: function (scale, fromZoom) {\n      var crs = this.options.crs;\n      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n      var zoom = crs.zoom(scale * crs.scale(fromZoom));\n      return isNaN(zoom) ? Infinity : zoom;\n    },\n    // @method project(latlng: LatLng, zoom: Number): Point\n    // Projects a geographical coordinate `LatLng` according to the projection\n    // of the map's CRS, then scales it according to `zoom` and the CRS's\n    // `Transformation`. The result is pixel coordinate relative to\n    // the CRS origin.\n    project: function (latlng, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\n    },\n    // @method unproject(point: Point, zoom: Number): LatLng\n    // Inverse of [`project`](#map-project).\n    unproject: function (point, zoom) {\n      zoom = zoom === undefined ? this._zoom : zoom;\n      return this.options.crs.pointToLatLng(toPoint(point), zoom);\n    },\n    // @method layerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding geographical coordinate (for the current zoom level).\n    layerPointToLatLng: function (point) {\n      var projectedPoint = toPoint(point).add(this.getPixelOrigin());\n      return this.unproject(projectedPoint);\n    },\n    // @method latLngToLayerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the [origin pixel](#map-getpixelorigin).\n    latLngToLayerPoint: function (latlng) {\n      var projectedPoint = this.project(toLatLng(latlng))._round();\n\n      return projectedPoint._subtract(this.getPixelOrigin());\n    },\n    // @method wrapLatLng(latlng: LatLng): LatLng\n    // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\n    // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\n    // CRS's bounds.\n    // By default this means longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees.\n    wrapLatLng: function (latlng) {\n      return this.options.crs.wrapLatLng(toLatLng(latlng));\n    },\n    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n    // Returns a `LatLngBounds` with the same size as the given one, ensuring that\n    // its center is within the CRS's bounds.\n    // By default this means the center longitude is wrapped around the dateline so its\n    // value is between -180 and +180 degrees, and the majority of the bounds\n    // overlaps the CRS's bounds.\n    wrapLatLngBounds: function (latlng) {\n      return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\n    },\n    // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n    // Returns the distance between two geographical coordinates according to\n    // the map's CRS. By default this measures distance in meters.\n    distance: function (latlng1, latlng2) {\n      return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\n    },\n    // @method containerPointToLayerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the map container, returns the corresponding\n    // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\n    containerPointToLayerPoint: function (point) {\n      // (Point)\n      return toPoint(point).subtract(this._getMapPanePos());\n    },\n    // @method layerPointToContainerPoint(point: Point): Point\n    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n    // returns the corresponding pixel coordinate relative to the map container.\n    layerPointToContainerPoint: function (point) {\n      // (Point)\n      return toPoint(point).add(this._getMapPanePos());\n    },\n    // @method containerPointToLatLng(point: Point): LatLng\n    // Given a pixel coordinate relative to the map container, returns\n    // the corresponding geographical coordinate (for the current zoom level).\n    containerPointToLatLng: function (point) {\n      var layerPoint = this.containerPointToLayerPoint(toPoint(point));\n      return this.layerPointToLatLng(layerPoint);\n    },\n    // @method latLngToContainerPoint(latlng: LatLng): Point\n    // Given a geographical coordinate, returns the corresponding pixel coordinate\n    // relative to the map container.\n    latLngToContainerPoint: function (latlng) {\n      return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\n    },\n    // @method mouseEventToContainerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to the\n    // map container where the event took place.\n    mouseEventToContainerPoint: function (e) {\n      return getMousePosition(e, this._container);\n    },\n    // @method mouseEventToLayerPoint(ev: MouseEvent): Point\n    // Given a MouseEvent object, returns the pixel coordinate relative to\n    // the [origin pixel](#map-getpixelorigin) where the event took place.\n    mouseEventToLayerPoint: function (e) {\n      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\n    },\n    // @method mouseEventToLatLng(ev: MouseEvent): LatLng\n    // Given a MouseEvent object, returns geographical coordinate where the\n    // event took place.\n    mouseEventToLatLng: function (e) {\n      // (MouseEvent)\n      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\n    },\n    // map initialization methods\n    _initContainer: function (id) {\n      var container = this._container = get(id);\n\n      if (!container) {\n        throw new Error('Map container not found.');\n      } else if (container._leaflet_id) {\n        throw new Error('Map container is already initialized.');\n      }\n\n      on(container, 'scroll', this._onScroll, this);\n      this._containerId = stamp(container);\n    },\n    _initLayout: function () {\n      var container = this._container;\n      this._fadeAnimated = this.options.fadeAnimation && any3d;\n      addClass(container, 'leaflet-container' + (touch ? ' leaflet-touch' : '') + (retina ? ' leaflet-retina' : '') + (ielt9 ? ' leaflet-oldie' : '') + (safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));\n      var position = getStyle(container, 'position');\n\n      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\n        container.style.position = 'relative';\n      }\n\n      this._initPanes();\n\n      if (this._initControlPos) {\n        this._initControlPos();\n      }\n    },\n    _initPanes: function () {\n      var panes = this._panes = {};\n      this._paneRenderers = {}; // @section\n      //\n      // Panes are DOM elements used to control the ordering of layers on the map. You\n      // can access panes with [`map.getPane`](#map-getpane) or\n      // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\n      // [`map.createPane`](#map-createpane) method.\n      //\n      // Every map has the following default panes that differ only in zIndex.\n      //\n      // @pane mapPane: HTMLElement = 'auto'\n      // Pane that contains all other map panes\n\n      this._mapPane = this.createPane('mapPane', this._container);\n      setPosition(this._mapPane, new Point(0, 0)); // @pane tilePane: HTMLElement = 200\n      // Pane for `GridLayer`s and `TileLayer`s\n\n      this.createPane('tilePane'); // @pane overlayPane: HTMLElement = 400\n      // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\n\n      this.createPane('shadowPane'); // @pane shadowPane: HTMLElement = 500\n      // Pane for overlay shadows (e.g. `Marker` shadows)\n\n      this.createPane('overlayPane'); // @pane markerPane: HTMLElement = 600\n      // Pane for `Icon`s of `Marker`s\n\n      this.createPane('markerPane'); // @pane tooltipPane: HTMLElement = 650\n      // Pane for `Tooltip`s.\n\n      this.createPane('tooltipPane'); // @pane popupPane: HTMLElement = 700\n      // Pane for `Popup`s.\n\n      this.createPane('popupPane');\n\n      if (!this.options.markerZoomAnimation) {\n        addClass(panes.markerPane, 'leaflet-zoom-hide');\n        addClass(panes.shadowPane, 'leaflet-zoom-hide');\n      }\n    },\n    // private methods that modify map state\n    // @section Map state change events\n    _resetView: function (center, zoom) {\n      setPosition(this._mapPane, new Point(0, 0));\n      var loading = !this._loaded;\n      this._loaded = true;\n      zoom = this._limitZoom(zoom);\n      this.fire('viewprereset');\n      var zoomChanged = this._zoom !== zoom;\n\n      this._moveStart(zoomChanged, false)._move(center, zoom)._moveEnd(zoomChanged); // @event viewreset: Event\n      // Fired when the map needs to redraw its content (this usually happens\n      // on map zoom or load). Very useful for creating custom overlays.\n\n\n      this.fire('viewreset'); // @event load: Event\n      // Fired when the map is initialized (when its center and zoom are set\n      // for the first time).\n\n      if (loading) {\n        this.fire('load');\n      }\n    },\n    _moveStart: function (zoomChanged, noMoveStart) {\n      // @event zoomstart: Event\n      // Fired when the map zoom is about to change (e.g. before zoom animation).\n      // @event movestart: Event\n      // Fired when the view of the map starts changing (e.g. user starts dragging the map).\n      if (zoomChanged) {\n        this.fire('zoomstart');\n      }\n\n      if (!noMoveStart) {\n        this.fire('movestart');\n      }\n\n      return this;\n    },\n    _move: function (center, zoom, data) {\n      if (zoom === undefined) {\n        zoom = this._zoom;\n      }\n\n      var zoomChanged = this._zoom !== zoom;\n      this._zoom = zoom;\n      this._lastCenter = center;\n      this._pixelOrigin = this._getNewPixelOrigin(center); // @event zoom: Event\n      // Fired repeatedly during any change in zoom level, including zoom\n      // and fly animations.\n\n      if (zoomChanged || data && data.pinch) {\n        // Always fire 'zoom' if pinching because #3530\n        this.fire('zoom', data);\n      } // @event move: Event\n      // Fired repeatedly during any movement of the map, including pan and\n      // fly animations.\n\n\n      return this.fire('move', data);\n    },\n    _moveEnd: function (zoomChanged) {\n      // @event zoomend: Event\n      // Fired when the map has changed, after any animations.\n      if (zoomChanged) {\n        this.fire('zoomend');\n      } // @event moveend: Event\n      // Fired when the center of the map stops changing (e.g. user stopped\n      // dragging the map).\n\n\n      return this.fire('moveend');\n    },\n    _stop: function () {\n      cancelAnimFrame(this._flyToFrame);\n\n      if (this._panAnim) {\n        this._panAnim.stop();\n      }\n\n      return this;\n    },\n    _rawPanBy: function (offset) {\n      setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\n    },\n    _getZoomSpan: function () {\n      return this.getMaxZoom() - this.getMinZoom();\n    },\n    _panInsideMaxBounds: function () {\n      if (!this._enforcingBounds) {\n        this.panInsideBounds(this.options.maxBounds);\n      }\n    },\n    _checkIfLoaded: function () {\n      if (!this._loaded) {\n        throw new Error('Set map center and zoom first.');\n      }\n    },\n    // DOM event handling\n    // @section Interaction events\n    _initEvents: function (remove$$1) {\n      this._targets = {};\n      this._targets[stamp(this._container)] = this;\n      var onOff = remove$$1 ? off : on; // @event click: MouseEvent\n      // Fired when the user clicks (or taps) the map.\n      // @event dblclick: MouseEvent\n      // Fired when the user double-clicks (or double-taps) the map.\n      // @event mousedown: MouseEvent\n      // Fired when the user pushes the mouse button on the map.\n      // @event mouseup: MouseEvent\n      // Fired when the user releases the mouse button on the map.\n      // @event mouseover: MouseEvent\n      // Fired when the mouse enters the map.\n      // @event mouseout: MouseEvent\n      // Fired when the mouse leaves the map.\n      // @event mousemove: MouseEvent\n      // Fired while the mouse moves over the map.\n      // @event contextmenu: MouseEvent\n      // Fired when the user pushes the right mouse button on the map, prevents\n      // default browser context menu from showing if there are listeners on\n      // this event. Also fired on mobile when the user holds a single touch\n      // for a second (also called long press).\n      // @event keypress: KeyboardEvent\n      // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\n      // @event keydown: KeyboardEvent\n      // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\n      // the `keydown` event is fired for keys that produce a character value and for keys\n      // that do not produce a character value.\n      // @event keyup: KeyboardEvent\n      // Fired when the user releases a key from the keyboard while the map is focused.\n\n      onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);\n\n      if (this.options.trackResize) {\n        onOff(window, 'resize', this._onResize, this);\n      }\n\n      if (any3d && this.options.transform3DLimit) {\n        (remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);\n      }\n    },\n    _onResize: function () {\n      cancelAnimFrame(this._resizeRequest);\n      this._resizeRequest = requestAnimFrame(function () {\n        this.invalidateSize({\n          debounceMoveend: true\n        });\n      }, this);\n    },\n    _onScroll: function () {\n      this._container.scrollTop = 0;\n      this._container.scrollLeft = 0;\n    },\n    _onMoveEnd: function () {\n      var pos = this._getMapPanePos();\n\n      if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\n        // a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/\n        this._resetView(this.getCenter(), this.getZoom());\n      }\n    },\n    _findEventTargets: function (e, type) {\n      var targets = [],\n          target,\n          isHover = type === 'mouseout' || type === 'mouseover',\n          src = e.target || e.srcElement,\n          dragging = false;\n\n      while (src) {\n        target = this._targets[stamp(src)];\n\n        if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {\n          // Prevent firing click after you just dragged an object.\n          dragging = true;\n          break;\n        }\n\n        if (target && target.listens(type, true)) {\n          if (isHover && !isExternalTarget(src, e)) {\n            break;\n          }\n\n          targets.push(target);\n\n          if (isHover) {\n            break;\n          }\n        }\n\n        if (src === this._container) {\n          break;\n        }\n\n        src = src.parentNode;\n      }\n\n      if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {\n        targets = [this];\n      }\n\n      return targets;\n    },\n    _handleDOMEvent: function (e) {\n      if (!this._loaded || skipped(e)) {\n        return;\n      }\n\n      var type = e.type;\n\n      if (type === 'mousedown' || type === 'keypress' || type === 'keyup' || type === 'keydown') {\n        // prevents outline when clicking on keyboard-focusable element\n        preventOutline(e.target || e.srcElement);\n      }\n\n      this._fireDOMEvent(e, type);\n    },\n    _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\n    _fireDOMEvent: function (e, type, targets) {\n      if (e.type === 'click') {\n        // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\n        // @event preclick: MouseEvent\n        // Fired before mouse click on the map (sometimes useful when you\n        // want something to happen on click before any existing click\n        // handlers start running).\n        var synth = extend({}, e);\n        synth.type = 'preclick';\n\n        this._fireDOMEvent(synth, synth.type, targets);\n      }\n\n      if (e._stopped) {\n        return;\n      } // Find the layer the event is propagating from and its parents.\n\n\n      targets = (targets || []).concat(this._findEventTargets(e, type));\n\n      if (!targets.length) {\n        return;\n      }\n\n      var target = targets[0];\n\n      if (type === 'contextmenu' && target.listens(type, true)) {\n        preventDefault(e);\n      }\n\n      var data = {\n        originalEvent: e\n      };\n\n      if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {\n        var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\n        data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\n        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\n        data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\n      }\n\n      for (var i = 0; i < targets.length; i++) {\n        targets[i].fire(type, data, true);\n\n        if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {\n          return;\n        }\n      }\n    },\n    _draggableMoved: function (obj) {\n      obj = obj.dragging && obj.dragging.enabled() ? obj : this;\n      return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();\n    },\n    _clearHandlers: function () {\n      for (var i = 0, len = this._handlers.length; i < len; i++) {\n        this._handlers[i].disable();\n      }\n    },\n    // @section Other Methods\n    // @method whenReady(fn: Function, context?: Object): this\n    // Runs the given function `fn` when the map gets initialized with\n    // a view (center and zoom) and at least one layer, or immediately\n    // if it's already initialized, optionally passing a function context.\n    whenReady: function (callback, context) {\n      if (this._loaded) {\n        callback.call(context || this, {\n          target: this\n        });\n      } else {\n        this.on('load', callback, context);\n      }\n\n      return this;\n    },\n    // private methods for getting map state\n    _getMapPanePos: function () {\n      return getPosition(this._mapPane) || new Point(0, 0);\n    },\n    _moved: function () {\n      var pos = this._getMapPanePos();\n\n      return pos && !pos.equals([0, 0]);\n    },\n    _getTopLeftPoint: function (center, zoom) {\n      var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();\n      return pixelOrigin.subtract(this._getMapPanePos());\n    },\n    _getNewPixelOrigin: function (center, zoom) {\n      var viewHalf = this.getSize()._divideBy(2);\n\n      return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\n    },\n    _latLngToNewLayerPoint: function (latlng, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n\n      return this.project(latlng, zoom)._subtract(topLeft);\n    },\n    _latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {\n      var topLeft = this._getNewPixelOrigin(center, zoom);\n\n      return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);\n    },\n    // layer point of the current center\n    _getCenterLayerPoint: function () {\n      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n    },\n    // offset of the specified place to the current center in pixels\n    _getCenterOffset: function (latlng) {\n      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\n    },\n    // adjust center for view to get inside bounds\n    _limitCenter: function (center, zoom, bounds) {\n      if (!bounds) {\n        return center;\n      }\n\n      var centerPoint = this.project(center, zoom),\n          viewHalf = this.getSize().divideBy(2),\n          viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\n          offset = this._getBoundsOffset(viewBounds, bounds, zoom); // If offset is less than a pixel, ignore.\n      // This prevents unstable projections from getting into\n      // an infinite loop of tiny offsets.\n\n\n      if (offset.round().equals([0, 0])) {\n        return center;\n      }\n\n      return this.unproject(centerPoint.add(offset), zoom);\n    },\n    // adjust offset for view to get inside bounds\n    _limitOffset: function (offset, bounds) {\n      if (!bounds) {\n        return offset;\n      }\n\n      var viewBounds = this.getPixelBounds(),\n          newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\n      return offset.add(this._getBoundsOffset(newBounds, bounds));\n    },\n    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom\n    _getBoundsOffset: function (pxBounds, maxBounds, zoom) {\n      var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),\n          minOffset = projectedMaxBounds.min.subtract(pxBounds.min),\n          maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),\n          dx = this._rebound(minOffset.x, -maxOffset.x),\n          dy = this._rebound(minOffset.y, -maxOffset.y);\n\n      return new Point(dx, dy);\n    },\n    _rebound: function (left, right) {\n      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\n    },\n    _limitZoom: function (zoom) {\n      var min = this.getMinZoom(),\n          max = this.getMaxZoom(),\n          snap = any3d ? this.options.zoomSnap : 1;\n\n      if (snap) {\n        zoom = Math.round(zoom / snap) * snap;\n      }\n\n      return Math.max(min, Math.min(max, zoom));\n    },\n    _onPanTransitionStep: function () {\n      this.fire('move');\n    },\n    _onPanTransitionEnd: function () {\n      removeClass(this._mapPane, 'leaflet-pan-anim');\n      this.fire('moveend');\n    },\n    _tryAnimatedPan: function (center, options) {\n      // difference between the new and current centers in pixels\n      var offset = this._getCenterOffset(center)._trunc(); // don't animate too far unless animate: true specified in options\n\n\n      if ((options && options.animate) !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n\n      this.panBy(offset, options);\n      return true;\n    },\n    _createAnimProxy: function () {\n      var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');\n\n      this._panes.mapPane.appendChild(proxy);\n\n      this.on('zoomanim', function (e) {\n        var prop = TRANSFORM,\n            transform = this._proxy.style[prop];\n        setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1)); // workaround for case when transform is the same and so transitionend event is not fired\n\n        if (transform === this._proxy.style[prop] && this._animatingZoom) {\n          this._onZoomTransitionEnd();\n        }\n      }, this);\n      this.on('load moveend', this._animMoveEnd, this);\n\n      this._on('unload', this._destroyAnimProxy, this);\n    },\n    _destroyAnimProxy: function () {\n      remove(this._proxy);\n      this.off('load moveend', this._animMoveEnd, this);\n      delete this._proxy;\n    },\n    _animMoveEnd: function () {\n      var c = this.getCenter(),\n          z = this.getZoom();\n      setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\n    },\n    _catchTransitionEnd: function (e) {\n      if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n        this._onZoomTransitionEnd();\n      }\n    },\n    _nothingToAnimate: function () {\n      return !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n    },\n    _tryAnimatedZoom: function (center, zoom, options) {\n      if (this._animatingZoom) {\n        return true;\n      }\n\n      options = options || {}; // don't animate if disabled, not supported or zoom difference is too large\n\n      if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {\n        return false;\n      } // offset is the pixel coords of the zoom origin relative to the current center\n\n\n      var scale = this.getZoomScale(zoom),\n          offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale); // don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\n\n      if (options.animate !== true && !this.getSize().contains(offset)) {\n        return false;\n      }\n\n      requestAnimFrame(function () {\n        this._moveStart(true, false)._animateZoom(center, zoom, true);\n      }, this);\n      return true;\n    },\n    _animateZoom: function (center, zoom, startAnim, noUpdate) {\n      if (!this._mapPane) {\n        return;\n      }\n\n      if (startAnim) {\n        this._animatingZoom = true; // remember what center/zoom to set after animation\n\n        this._animateToCenter = center;\n        this._animateToZoom = zoom;\n        addClass(this._mapPane, 'leaflet-zoom-anim');\n      } // @section Other Events\n      // @event zoomanim: ZoomAnimEvent\n      // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\n\n\n      this.fire('zoomanim', {\n        center: center,\n        zoom: zoom,\n        noUpdate: noUpdate\n      }); // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\n\n      setTimeout(bind(this._onZoomTransitionEnd, this), 250);\n    },\n    _onZoomTransitionEnd: function () {\n      if (!this._animatingZoom) {\n        return;\n      }\n\n      if (this._mapPane) {\n        removeClass(this._mapPane, 'leaflet-zoom-anim');\n      }\n\n      this._animatingZoom = false;\n\n      this._move(this._animateToCenter, this._animateToZoom); // This anim frame should prevent an obscure iOS webkit tile loading race condition.\n\n\n      requestAnimFrame(function () {\n        this._moveEnd(true);\n      }, this);\n    }\n  }); // @section\n  // @factory L.map(id: String, options?: Map options)\n  // Instantiates a map object given the DOM ID of a `<div>` element\n  // and optionally an object literal with `Map options`.\n  //\n  // @alternative\n  // @factory L.map(el: HTMLElement, options?: Map options)\n  // Instantiates a map object given an instance of a `<div>` HTML element\n  // and optionally an object literal with `Map options`.\n\n  function createMap(id, options) {\n    return new Map(id, options);\n  }\n  /*\r\n   * @class Control\r\n   * @aka L.Control\r\n   * @inherits Class\r\n   *\r\n   * L.Control is a base class for implementing map controls. Handles positioning.\r\n   * All other controls extend from this class.\r\n   */\n\n\n  var Control = Class.extend({\n    // @section\n    // @aka Control options\n    options: {\n      // @option position: String = 'topright'\n      // The position of the control (one of the map corners). Possible values are `'topleft'`,\n      // `'topright'`, `'bottomleft'` or `'bottomright'`\n      position: 'topright'\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n\n    /* @section\r\n     * Classes extending L.Control will inherit the following methods:\r\n     *\r\n     * @method getPosition: string\r\n     * Returns the position of the control.\r\n     */\n    getPosition: function () {\n      return this.options.position;\n    },\n    // @method setPosition(position: string): this\n    // Sets the position of the control.\n    setPosition: function (position) {\n      var map = this._map;\n\n      if (map) {\n        map.removeControl(this);\n      }\n\n      this.options.position = position;\n\n      if (map) {\n        map.addControl(this);\n      }\n\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTMLElement that contains the control.\n    getContainer: function () {\n      return this._container;\n    },\n    // @method addTo(map: Map): this\n    // Adds the control to the given map.\n    addTo: function (map) {\n      this.remove();\n      this._map = map;\n      var container = this._container = this.onAdd(map),\n          pos = this.getPosition(),\n          corner = map._controlCorners[pos];\n      addClass(container, 'leaflet-control');\n\n      if (pos.indexOf('bottom') !== -1) {\n        corner.insertBefore(container, corner.firstChild);\n      } else {\n        corner.appendChild(container);\n      }\n\n      this._map.on('unload', this.remove, this);\n\n      return this;\n    },\n    // @method remove: this\n    // Removes the control from the map it is currently active on.\n    remove: function () {\n      if (!this._map) {\n        return this;\n      }\n\n      remove(this._container);\n\n      if (this.onRemove) {\n        this.onRemove(this._map);\n      }\n\n      this._map.off('unload', this.remove, this);\n\n      this._map = null;\n      return this;\n    },\n    _refocusOnMap: function (e) {\n      // if map exists and event is not a keyboard event\n      if (this._map && e && e.screenX > 0 && e.screenY > 0) {\n        this._map.getContainer().focus();\n      }\n    }\n  });\n\n  var control = function (options) {\n    return new Control(options);\n  };\n  /* @section Extension methods\r\n   * @uninheritable\r\n   *\r\n   * Every control should extend from `L.Control` and (re-)implement the following methods.\r\n   *\r\n   * @method onAdd(map: Map): HTMLElement\r\n   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).\r\n   *\r\n   * @method onRemove(map: Map)\r\n   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).\r\n   */\n\n  /* @namespace Map\r\n   * @section Methods for Layers and Controls\r\n   */\n\n\n  Map.include({\n    // @method addControl(control: Control): this\n    // Adds the given control to the map\n    addControl: function (control) {\n      control.addTo(this);\n      return this;\n    },\n    // @method removeControl(control: Control): this\n    // Removes the given control from the map\n    removeControl: function (control) {\n      control.remove();\n      return this;\n    },\n    _initControlPos: function () {\n      var corners = this._controlCorners = {},\n          l = 'leaflet-',\n          container = this._controlContainer = create$1('div', l + 'control-container', this._container);\n\n      function createCorner(vSide, hSide) {\n        var className = l + vSide + ' ' + l + hSide;\n        corners[vSide + hSide] = create$1('div', className, container);\n      }\n\n      createCorner('top', 'left');\n      createCorner('top', 'right');\n      createCorner('bottom', 'left');\n      createCorner('bottom', 'right');\n    },\n    _clearControlPos: function () {\n      for (var i in this._controlCorners) {\n        remove(this._controlCorners[i]);\n      }\n\n      remove(this._controlContainer);\n      delete this._controlCorners;\n      delete this._controlContainer;\n    }\n  });\n  /*\r\n   * @class Control.Layers\r\n   * @aka L.Control.Layers\r\n   * @inherits Control\r\n   *\r\n   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var baseLayers = {\r\n   * \t\"Mapbox\": mapbox,\r\n   * \t\"OpenStreetMap\": osm\r\n   * };\r\n   *\r\n   * var overlays = {\r\n   * \t\"Marker\": marker,\r\n   * \t\"Roads\": roadsLayer\r\n   * };\r\n   *\r\n   * L.control.layers(baseLayers, overlays).addTo(map);\r\n   * ```\r\n   *\r\n   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:\r\n   *\r\n   * ```js\r\n   * {\r\n   *     \"<someName1>\": layer1,\r\n   *     \"<someName2>\": layer2\r\n   * }\r\n   * ```\r\n   *\r\n   * The layer names can contain HTML, which allows you to add additional styling to the items:\r\n   *\r\n   * ```js\r\n   * {\"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>\": myLayer}\r\n   * ```\r\n   */\n\n  var Layers = Control.extend({\n    // @section\n    // @aka Control.Layers options\n    options: {\n      // @option collapsed: Boolean = true\n      // If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.\n      collapsed: true,\n      position: 'topright',\n      // @option autoZIndex: Boolean = true\n      // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.\n      autoZIndex: true,\n      // @option hideSingleBase: Boolean = false\n      // If `true`, the base layers in the control will be hidden when there is only one.\n      hideSingleBase: false,\n      // @option sortLayers: Boolean = false\n      // Whether to sort the layers. When `false`, layers will keep the order\n      // in which they were added to the control.\n      sortLayers: false,\n      // @option sortFunction: Function = *\n      // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n      // that will be used for sorting the layers, when `sortLayers` is `true`.\n      // The function receives both the `L.Layer` instances and their names, as in\n      // `sortFunction(layerA, layerB, nameA, nameB)`.\n      // By default, it sorts layers alphabetically by their name.\n      sortFunction: function (layerA, layerB, nameA, nameB) {\n        return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;\n      }\n    },\n    initialize: function (baseLayers, overlays, options) {\n      setOptions(this, options);\n      this._layerControlInputs = [];\n      this._layers = [];\n      this._lastZIndex = 0;\n      this._handlingClick = false;\n\n      for (var i in baseLayers) {\n        this._addLayer(baseLayers[i], i);\n      }\n\n      for (i in overlays) {\n        this._addLayer(overlays[i], i, true);\n      }\n    },\n    onAdd: function (map) {\n      this._initLayout();\n\n      this._update();\n\n      this._map = map;\n      map.on('zoomend', this._checkDisabledLayers, this);\n\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.on('add remove', this._onLayerChange, this);\n      }\n\n      return this._container;\n    },\n    addTo: function (map) {\n      Control.prototype.addTo.call(this, map); // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.\n\n      return this._expandIfNotCollapsed();\n    },\n    onRemove: function () {\n      this._map.off('zoomend', this._checkDisabledLayers, this);\n\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.off('add remove', this._onLayerChange, this);\n      }\n    },\n    // @method addBaseLayer(layer: Layer, name: String): this\n    // Adds a base layer (radio button entry) with the given name to the control.\n    addBaseLayer: function (layer, name) {\n      this._addLayer(layer, name);\n\n      return this._map ? this._update() : this;\n    },\n    // @method addOverlay(layer: Layer, name: String): this\n    // Adds an overlay (checkbox entry) with the given name to the control.\n    addOverlay: function (layer, name) {\n      this._addLayer(layer, name, true);\n\n      return this._map ? this._update() : this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Remove the given layer from the control.\n    removeLayer: function (layer) {\n      layer.off('add remove', this._onLayerChange, this);\n\n      var obj = this._getLayer(stamp(layer));\n\n      if (obj) {\n        this._layers.splice(this._layers.indexOf(obj), 1);\n      }\n\n      return this._map ? this._update() : this;\n    },\n    // @method expand(): this\n    // Expand the control container if collapsed.\n    expand: function () {\n      addClass(this._container, 'leaflet-control-layers-expanded');\n      this._section.style.height = null;\n      var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);\n\n      if (acceptableHeight < this._section.clientHeight) {\n        addClass(this._section, 'leaflet-control-layers-scrollbar');\n        this._section.style.height = acceptableHeight + 'px';\n      } else {\n        removeClass(this._section, 'leaflet-control-layers-scrollbar');\n      }\n\n      this._checkDisabledLayers();\n\n      return this;\n    },\n    // @method collapse(): this\n    // Collapse the control container if expanded.\n    collapse: function () {\n      removeClass(this._container, 'leaflet-control-layers-expanded');\n      return this;\n    },\n    _initLayout: function () {\n      var className = 'leaflet-control-layers',\n          container = this._container = create$1('div', className),\n          collapsed = this.options.collapsed; // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\n\n      container.setAttribute('aria-haspopup', true);\n      disableClickPropagation(container);\n      disableScrollPropagation(container);\n      var section = this._section = create$1('section', className + '-list');\n\n      if (collapsed) {\n        this._map.on('click', this.collapse, this);\n\n        if (!android) {\n          on(container, {\n            mouseenter: this.expand,\n            mouseleave: this.collapse\n          }, this);\n        }\n      }\n\n      var link = this._layersLink = create$1('a', className + '-toggle', container);\n      link.href = '#';\n      link.title = 'Layers';\n\n      if (touch) {\n        on(link, 'click', stop);\n        on(link, 'click', this.expand, this);\n      } else {\n        on(link, 'focus', this.expand, this);\n      }\n\n      if (!collapsed) {\n        this.expand();\n      }\n\n      this._baseLayersList = create$1('div', className + '-base', section);\n      this._separator = create$1('div', className + '-separator', section);\n      this._overlaysList = create$1('div', className + '-overlays', section);\n      container.appendChild(section);\n    },\n    _getLayer: function (id) {\n      for (var i = 0; i < this._layers.length; i++) {\n        if (this._layers[i] && stamp(this._layers[i].layer) === id) {\n          return this._layers[i];\n        }\n      }\n    },\n    _addLayer: function (layer, name, overlay) {\n      if (this._map) {\n        layer.on('add remove', this._onLayerChange, this);\n      }\n\n      this._layers.push({\n        layer: layer,\n        name: name,\n        overlay: overlay\n      });\n\n      if (this.options.sortLayers) {\n        this._layers.sort(bind(function (a, b) {\n          return this.options.sortFunction(a.layer, b.layer, a.name, b.name);\n        }, this));\n      }\n\n      if (this.options.autoZIndex && layer.setZIndex) {\n        this._lastZIndex++;\n        layer.setZIndex(this._lastZIndex);\n      }\n\n      this._expandIfNotCollapsed();\n    },\n    _update: function () {\n      if (!this._container) {\n        return this;\n      }\n\n      empty(this._baseLayersList);\n      empty(this._overlaysList);\n      this._layerControlInputs = [];\n      var baseLayersPresent,\n          overlaysPresent,\n          i,\n          obj,\n          baseLayersCount = 0;\n\n      for (i = 0; i < this._layers.length; i++) {\n        obj = this._layers[i];\n\n        this._addItem(obj);\n\n        overlaysPresent = overlaysPresent || obj.overlay;\n        baseLayersPresent = baseLayersPresent || !obj.overlay;\n        baseLayersCount += !obj.overlay ? 1 : 0;\n      } // Hide base layers section if there's only one layer.\n\n\n      if (this.options.hideSingleBase) {\n        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;\n        this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';\n      }\n\n      this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\n      return this;\n    },\n    _onLayerChange: function (e) {\n      if (!this._handlingClick) {\n        this._update();\n      }\n\n      var obj = this._getLayer(stamp(e.target)); // @namespace Map\n      // @section Layer events\n      // @event baselayerchange: LayersControlEvent\n      // Fired when the base layer is changed through the [layer control](#control-layers).\n      // @event overlayadd: LayersControlEvent\n      // Fired when an overlay is selected through the [layer control](#control-layers).\n      // @event overlayremove: LayersControlEvent\n      // Fired when an overlay is deselected through the [layer control](#control-layers).\n      // @namespace Control.Layers\n\n\n      var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;\n\n      if (type) {\n        this._map.fire(type, obj);\n      }\n    },\n    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\n    _createRadioElement: function (name, checked) {\n      var radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"' + (checked ? ' checked=\"checked\"' : '') + '/>';\n      var radioFragment = document.createElement('div');\n      radioFragment.innerHTML = radioHtml;\n      return radioFragment.firstChild;\n    },\n    _addItem: function (obj) {\n      var label = document.createElement('label'),\n          checked = this._map.hasLayer(obj.layer),\n          input;\n\n      if (obj.overlay) {\n        input = document.createElement('input');\n        input.type = 'checkbox';\n        input.className = 'leaflet-control-layers-selector';\n        input.defaultChecked = checked;\n      } else {\n        input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);\n      }\n\n      this._layerControlInputs.push(input);\n\n      input.layerId = stamp(obj.layer);\n      on(input, 'click', this._onInputClick, this);\n      var name = document.createElement('span');\n      name.innerHTML = ' ' + obj.name; // Helps from preventing layer control flicker when checkboxes are disabled\n      // https://github.com/Leaflet/Leaflet/issues/2771\n\n      var holder = document.createElement('div');\n      label.appendChild(holder);\n      holder.appendChild(input);\n      holder.appendChild(name);\n      var container = obj.overlay ? this._overlaysList : this._baseLayersList;\n      container.appendChild(label);\n\n      this._checkDisabledLayers();\n\n      return label;\n    },\n    _onInputClick: function () {\n      var inputs = this._layerControlInputs,\n          input,\n          layer;\n      var addedLayers = [],\n          removedLayers = [];\n      this._handlingClick = true;\n\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n\n        if (input.checked) {\n          addedLayers.push(layer);\n        } else if (!input.checked) {\n          removedLayers.push(layer);\n        }\n      } // Bugfix issue 2318: Should remove all old layers before readding new ones\n\n\n      for (i = 0; i < removedLayers.length; i++) {\n        if (this._map.hasLayer(removedLayers[i])) {\n          this._map.removeLayer(removedLayers[i]);\n        }\n      }\n\n      for (i = 0; i < addedLayers.length; i++) {\n        if (!this._map.hasLayer(addedLayers[i])) {\n          this._map.addLayer(addedLayers[i]);\n        }\n      }\n\n      this._handlingClick = false;\n\n      this._refocusOnMap();\n    },\n    _checkDisabledLayers: function () {\n      var inputs = this._layerControlInputs,\n          input,\n          layer,\n          zoom = this._map.getZoom();\n\n      for (var i = inputs.length - 1; i >= 0; i--) {\n        input = inputs[i];\n        layer = this._getLayer(input.layerId).layer;\n        input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;\n      }\n    },\n    _expandIfNotCollapsed: function () {\n      if (this._map && !this.options.collapsed) {\n        this.expand();\n      }\n\n      return this;\n    },\n    _expand: function () {\n      // Backward compatibility, remove me in 1.1.\n      return this.expand();\n    },\n    _collapse: function () {\n      // Backward compatibility, remove me in 1.1.\n      return this.collapse();\n    }\n  }); // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)\n  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.\n\n  var layers = function (baseLayers, overlays, options) {\n    return new Layers(baseLayers, overlays, options);\n  };\n  /*\r\n   * @class Control.Zoom\r\n   * @aka L.Control.Zoom\r\n   * @inherits Control\r\n   *\r\n   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.\r\n   */\n\n\n  var Zoom = Control.extend({\n    // @section\n    // @aka Control.Zoom options\n    options: {\n      position: 'topleft',\n      // @option zoomInText: String = '+'\n      // The text set on the 'zoom in' button.\n      zoomInText: '+',\n      // @option zoomInTitle: String = 'Zoom in'\n      // The title set on the 'zoom in' button.\n      zoomInTitle: 'Zoom in',\n      // @option zoomOutText: String = '&#x2212;'\n      // The text set on the 'zoom out' button.\n      zoomOutText: '&#x2212;',\n      // @option zoomOutTitle: String = 'Zoom out'\n      // The title set on the 'zoom out' button.\n      zoomOutTitle: 'Zoom out'\n    },\n    onAdd: function (map) {\n      var zoomName = 'leaflet-control-zoom',\n          container = create$1('div', zoomName + ' leaflet-bar'),\n          options = this.options;\n      this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);\n      this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);\n\n      this._updateDisabled();\n\n      map.on('zoomend zoomlevelschange', this._updateDisabled, this);\n      return container;\n    },\n    onRemove: function (map) {\n      map.off('zoomend zoomlevelschange', this._updateDisabled, this);\n    },\n    disable: function () {\n      this._disabled = true;\n\n      this._updateDisabled();\n\n      return this;\n    },\n    enable: function () {\n      this._disabled = false;\n\n      this._updateDisabled();\n\n      return this;\n    },\n    _zoomIn: function (e) {\n      if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {\n        this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _zoomOut: function (e) {\n      if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {\n        this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n      }\n    },\n    _createButton: function (html, title, className, container, fn) {\n      var link = create$1('a', className, container);\n      link.innerHTML = html;\n      link.href = '#';\n      link.title = title;\n      /*\r\n       * Will force screen readers like VoiceOver to read this as \"Zoom in - button\"\r\n       */\n\n      link.setAttribute('role', 'button');\n      link.setAttribute('aria-label', title);\n      disableClickPropagation(link);\n      on(link, 'click', stop);\n      on(link, 'click', fn, this);\n      on(link, 'click', this._refocusOnMap, this);\n      return link;\n    },\n    _updateDisabled: function () {\n      var map = this._map,\n          className = 'leaflet-disabled';\n      removeClass(this._zoomInButton, className);\n      removeClass(this._zoomOutButton, className);\n\n      if (this._disabled || map._zoom === map.getMinZoom()) {\n        addClass(this._zoomOutButton, className);\n      }\n\n      if (this._disabled || map._zoom === map.getMaxZoom()) {\n        addClass(this._zoomInButton, className);\n      }\n    }\n  }); // @namespace Map\n  // @section Control options\n  // @option zoomControl: Boolean = true\n  // Whether a [zoom control](#control-zoom) is added to the map by default.\n\n  Map.mergeOptions({\n    zoomControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.zoomControl) {\n      // @section Controls\n      // @property zoomControl: Control.Zoom\n      // The default zoom control (only available if the\n      // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).\n      this.zoomControl = new Zoom();\n      this.addControl(this.zoomControl);\n    }\n  }); // @namespace Control.Zoom\n  // @factory L.control.zoom(options: Control.Zoom options)\n  // Creates a zoom control\n\n  var zoom = function (options) {\n    return new Zoom(options);\n  };\n  /*\n   * @class Control.Scale\n   * @aka L.Control.Scale\n   * @inherits Control\n   *\n   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.\n   *\n   * @example\n   *\n   * ```js\n   * L.control.scale().addTo(map);\n   * ```\n   */\n\n\n  var Scale = Control.extend({\n    // @section\n    // @aka Control.Scale options\n    options: {\n      position: 'bottomleft',\n      // @option maxWidth: Number = 100\n      // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).\n      maxWidth: 100,\n      // @option metric: Boolean = True\n      // Whether to show the metric scale line (m/km).\n      metric: true,\n      // @option imperial: Boolean = True\n      // Whether to show the imperial scale line (mi/ft).\n      imperial: true // @option updateWhenIdle: Boolean = false\n      // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).\n\n    },\n    onAdd: function (map) {\n      var className = 'leaflet-control-scale',\n          container = create$1('div', className),\n          options = this.options;\n\n      this._addScales(options, className + '-line', container);\n\n      map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n      map.whenReady(this._update, this);\n      return container;\n    },\n    onRemove: function (map) {\n      map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n    },\n    _addScales: function (options, className, container) {\n      if (options.metric) {\n        this._mScale = create$1('div', className, container);\n      }\n\n      if (options.imperial) {\n        this._iScale = create$1('div', className, container);\n      }\n    },\n    _update: function () {\n      var map = this._map,\n          y = map.getSize().y / 2;\n      var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));\n\n      this._updateScales(maxMeters);\n    },\n    _updateScales: function (maxMeters) {\n      if (this.options.metric && maxMeters) {\n        this._updateMetric(maxMeters);\n      }\n\n      if (this.options.imperial && maxMeters) {\n        this._updateImperial(maxMeters);\n      }\n    },\n    _updateMetric: function (maxMeters) {\n      var meters = this._getRoundNum(maxMeters),\n          label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';\n\n      this._updateScale(this._mScale, label, meters / maxMeters);\n    },\n    _updateImperial: function (maxMeters) {\n      var maxFeet = maxMeters * 3.2808399,\n          maxMiles,\n          miles,\n          feet;\n\n      if (maxFeet > 5280) {\n        maxMiles = maxFeet / 5280;\n        miles = this._getRoundNum(maxMiles);\n\n        this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);\n      } else {\n        feet = this._getRoundNum(maxFeet);\n\n        this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);\n      }\n    },\n    _updateScale: function (scale, text, ratio) {\n      scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';\n      scale.innerHTML = text;\n    },\n    _getRoundNum: function (num) {\n      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n          d = num / pow10;\n      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n      return pow10 * d;\n    }\n  }); // @factory L.control.scale(options?: Control.Scale options)\n  // Creates an scale control with the given options.\n\n  var scale = function (options) {\n    return new Scale(options);\n  };\n  /*\r\n   * @class Control.Attribution\r\n   * @aka L.Control.Attribution\r\n   * @inherits Control\r\n   *\r\n   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.\r\n   */\n\n\n  var Attribution = Control.extend({\n    // @section\n    // @aka Control.Attribution options\n    options: {\n      position: 'bottomright',\n      // @option prefix: String = 'Leaflet'\n      // The HTML text shown before the attributions. Pass `false` to disable.\n      prefix: '<a href=\"https://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n      this._attributions = {};\n    },\n    onAdd: function (map) {\n      map.attributionControl = this;\n      this._container = create$1('div', 'leaflet-control-attribution');\n      disableClickPropagation(this._container); // TODO ugly, refactor\n\n      for (var i in map._layers) {\n        if (map._layers[i].getAttribution) {\n          this.addAttribution(map._layers[i].getAttribution());\n        }\n      }\n\n      this._update();\n\n      return this._container;\n    },\n    // @method setPrefix(prefix: String): this\n    // Sets the text before the attributions.\n    setPrefix: function (prefix) {\n      this.options.prefix = prefix;\n\n      this._update();\n\n      return this;\n    },\n    // @method addAttribution(text: String): this\n    // Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).\n    addAttribution: function (text) {\n      if (!text) {\n        return this;\n      }\n\n      if (!this._attributions[text]) {\n        this._attributions[text] = 0;\n      }\n\n      this._attributions[text]++;\n\n      this._update();\n\n      return this;\n    },\n    // @method removeAttribution(text: String): this\n    // Removes an attribution text.\n    removeAttribution: function (text) {\n      if (!text) {\n        return this;\n      }\n\n      if (this._attributions[text]) {\n        this._attributions[text]--;\n\n        this._update();\n      }\n\n      return this;\n    },\n    _update: function () {\n      if (!this._map) {\n        return;\n      }\n\n      var attribs = [];\n\n      for (var i in this._attributions) {\n        if (this._attributions[i]) {\n          attribs.push(i);\n        }\n      }\n\n      var prefixAndAttribs = [];\n\n      if (this.options.prefix) {\n        prefixAndAttribs.push(this.options.prefix);\n      }\n\n      if (attribs.length) {\n        prefixAndAttribs.push(attribs.join(', '));\n      }\n\n      this._container.innerHTML = prefixAndAttribs.join(' | ');\n    }\n  }); // @namespace Map\n  // @section Control options\n  // @option attributionControl: Boolean = true\n  // Whether a [attribution control](#control-attribution) is added to the map by default.\n\n  Map.mergeOptions({\n    attributionControl: true\n  });\n  Map.addInitHook(function () {\n    if (this.options.attributionControl) {\n      new Attribution().addTo(this);\n    }\n  }); // @namespace Control.Attribution\n  // @factory L.control.attribution(options: Control.Attribution options)\n  // Creates an attribution control.\n\n  var attribution = function (options) {\n    return new Attribution(options);\n  };\n\n  Control.Layers = Layers;\n  Control.Zoom = Zoom;\n  Control.Scale = Scale;\n  Control.Attribution = Attribution;\n  control.layers = layers;\n  control.zoom = zoom;\n  control.scale = scale;\n  control.attribution = attribution;\n  /*\n  \tL.Handler is a base class for handler classes that are used internally to inject\n  \tinteraction features like dragging to classes like Map and Marker.\n  */\n  // @class Handler\n  // @aka L.Handler\n  // Abstract class for map interaction handlers\n\n  var Handler = Class.extend({\n    initialize: function (map) {\n      this._map = map;\n    },\n    // @method enable(): this\n    // Enables the handler\n    enable: function () {\n      if (this._enabled) {\n        return this;\n      }\n\n      this._enabled = true;\n      this.addHooks();\n      return this;\n    },\n    // @method disable(): this\n    // Disables the handler\n    disable: function () {\n      if (!this._enabled) {\n        return this;\n      }\n\n      this._enabled = false;\n      this.removeHooks();\n      return this;\n    },\n    // @method enabled(): Boolean\n    // Returns `true` if the handler is enabled\n    enabled: function () {\n      return !!this._enabled;\n    } // @section Extension methods\n    // Classes inheriting from `Handler` must implement the two following methods:\n    // @method addHooks()\n    // Called when the handler is enabled, should add event hooks.\n    // @method removeHooks()\n    // Called when the handler is disabled, should remove the event hooks added previously.\n\n  }); // @section There is static function which can be called without instantiating L.Handler:\n  // @function addTo(map: Map, name: String): this\n  // Adds a new Handler to the given map with the given name.\n\n  Handler.addTo = function (map, name) {\n    map.addHandler(name, this);\n    return this;\n  };\n\n  var Mixin = {\n    Events: Events\n  };\n  /*\r\n   * @class Draggable\r\n   * @aka L.Draggable\r\n   * @inherits Evented\r\n   *\r\n   * A class for making DOM elements draggable (including touch support).\r\n   * Used internally for map and marker dragging. Only works for elements\r\n   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * var draggable = new L.Draggable(elementToDrag);\r\n   * draggable.enable();\r\n   * ```\r\n   */\n\n  var START = touch ? 'touchstart mousedown' : 'mousedown';\n  var END = {\n    mousedown: 'mouseup',\n    touchstart: 'touchend',\n    pointerdown: 'touchend',\n    MSPointerDown: 'touchend'\n  };\n  var MOVE = {\n    mousedown: 'mousemove',\n    touchstart: 'touchmove',\n    pointerdown: 'touchmove',\n    MSPointerDown: 'touchmove'\n  };\n  var Draggable = Evented.extend({\n    options: {\n      // @section\n      // @aka Draggable options\n      // @option clickTolerance: Number = 3\n      // The max number of pixels a user can shift the mouse pointer during a click\n      // for it to be considered a valid click (as opposed to a mouse drag).\n      clickTolerance: 3\n    },\n    // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)\n    // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).\n    initialize: function (element, dragStartTarget, preventOutline$$1, options) {\n      setOptions(this, options);\n      this._element = element;\n      this._dragStartTarget = dragStartTarget || element;\n      this._preventOutline = preventOutline$$1;\n    },\n    // @method enable()\n    // Enables the dragging ability\n    enable: function () {\n      if (this._enabled) {\n        return;\n      }\n\n      on(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = true;\n    },\n    // @method disable()\n    // Disables the dragging ability\n    disable: function () {\n      if (!this._enabled) {\n        return;\n      } // If we're currently dragging this draggable,\n      // disabling it counts as first ending the drag.\n\n\n      if (Draggable._dragging === this) {\n        this.finishDrag();\n      }\n\n      off(this._dragStartTarget, START, this._onDown, this);\n      this._enabled = false;\n      this._moved = false;\n    },\n    _onDown: function (e) {\n      // Ignore simulated events, since we handle both touch and\n      // mouse explicitly; otherwise we risk getting duplicates of\n      // touch events, see #4315.\n      // Also ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (e._simulated || !this._enabled) {\n        return;\n      }\n\n      this._moved = false;\n\n      if (hasClass(this._element, 'leaflet-zoom-anim')) {\n        return;\n      }\n\n      if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {\n        return;\n      }\n\n      Draggable._dragging = this; // Prevent dragging multiple objects at once.\n\n      if (this._preventOutline) {\n        preventOutline(this._element);\n      }\n\n      disableImageDrag();\n      disableTextSelection();\n\n      if (this._moving) {\n        return;\n      } // @event down: Event\n      // Fired when a drag is about to start.\n\n\n      this.fire('down');\n      var first = e.touches ? e.touches[0] : e,\n          sizedParent = getSizedParentNode(this._element);\n      this._startPoint = new Point(first.clientX, first.clientY); // Cache the scale, so that we can continuously compensate for it during drag (_onMove).\n\n      this._parentScale = getScale(sizedParent);\n      on(document, MOVE[e.type], this._onMove, this);\n      on(document, END[e.type], this._onUp, this);\n    },\n    _onMove: function (e) {\n      // Ignore simulated events, since we handle both touch and\n      // mouse explicitly; otherwise we risk getting duplicates of\n      // touch events, see #4315.\n      // Also ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (e._simulated || !this._enabled) {\n        return;\n      }\n\n      if (e.touches && e.touches.length > 1) {\n        this._moved = true;\n        return;\n      }\n\n      var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,\n          offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);\n\n      if (!offset.x && !offset.y) {\n        return;\n      }\n\n      if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {\n        return;\n      } // We assume that the parent container's position, border and scale do not change for the duration of the drag.\n      // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)\n      // and we can use the cached value for the scale.\n\n\n      offset.x /= this._parentScale.x;\n      offset.y /= this._parentScale.y;\n      preventDefault(e);\n\n      if (!this._moved) {\n        // @event dragstart: Event\n        // Fired when a drag starts\n        this.fire('dragstart');\n        this._moved = true;\n        this._startPos = getPosition(this._element).subtract(offset);\n        addClass(document.body, 'leaflet-dragging');\n        this._lastTarget = e.target || e.srcElement; // IE and Edge do not give the <use> element, so fetch it\n        // if necessary\n\n        if (window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance) {\n          this._lastTarget = this._lastTarget.correspondingUseElement;\n        }\n\n        addClass(this._lastTarget, 'leaflet-drag-target');\n      }\n\n      this._newPos = this._startPos.add(offset);\n      this._moving = true;\n      cancelAnimFrame(this._animRequest);\n      this._lastEvent = e;\n      this._animRequest = requestAnimFrame(this._updatePosition, this, true);\n    },\n    _updatePosition: function () {\n      var e = {\n        originalEvent: this._lastEvent\n      }; // @event predrag: Event\n      // Fired continuously during dragging *before* each corresponding\n      // update of the element's position.\n\n      this.fire('predrag', e);\n      setPosition(this._element, this._newPos); // @event drag: Event\n      // Fired continuously during dragging.\n\n      this.fire('drag', e);\n    },\n    _onUp: function (e) {\n      // Ignore simulated events, since we handle both touch and\n      // mouse explicitly; otherwise we risk getting duplicates of\n      // touch events, see #4315.\n      // Also ignore the event if disabled; this happens in IE11\n      // under some circumstances, see #3666.\n      if (e._simulated || !this._enabled) {\n        return;\n      }\n\n      this.finishDrag();\n    },\n    finishDrag: function () {\n      removeClass(document.body, 'leaflet-dragging');\n\n      if (this._lastTarget) {\n        removeClass(this._lastTarget, 'leaflet-drag-target');\n        this._lastTarget = null;\n      }\n\n      for (var i in MOVE) {\n        off(document, MOVE[i], this._onMove, this);\n        off(document, END[i], this._onUp, this);\n      }\n\n      enableImageDrag();\n      enableTextSelection();\n\n      if (this._moved && this._moving) {\n        // ensure drag is not fired after dragend\n        cancelAnimFrame(this._animRequest); // @event dragend: DragEndEvent\n        // Fired when the drag ends.\n\n        this.fire('dragend', {\n          distance: this._newPos.distanceTo(this._startPos)\n        });\n      }\n\n      this._moving = false;\n      Draggable._dragging = false;\n    }\n  });\n  /*\r\n   * @namespace LineUtil\r\n   *\r\n   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.\r\n   */\n  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.\n  // Improves rendering performance dramatically by lessening the number of points to draw.\n  // @function simplify(points: Point[], tolerance: Number): Point[]\n  // Dramatically reduces the number of points in a polyline while retaining\n  // its shape and returns a new array of simplified points, using the\n  // [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).\n  // Used for a huge performance boost when processing/displaying Leaflet polylines for\n  // each zoom level and also reducing visual noise. tolerance affects the amount of\n  // simplification (lesser value means higher quality but slower and with more points).\n  // Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).\n\n  function simplify(points, tolerance) {\n    if (!tolerance || !points.length) {\n      return points.slice();\n    }\n\n    var sqTolerance = tolerance * tolerance; // stage 1: vertex reduction\n\n    points = _reducePoints(points, sqTolerance); // stage 2: Douglas-Peucker simplification\n\n    points = _simplifyDP(points, sqTolerance);\n    return points;\n  } // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number\n  // Returns the distance between point `p` and segment `p1` to `p2`.\n\n\n  function pointToSegmentDistance(p, p1, p2) {\n    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));\n  } // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number\n  // Returns the closest point from a point `p` on a segment `p1` to `p2`.\n\n\n  function closestPointOnSegment(p, p1, p2) {\n    return _sqClosestPointOnSegment(p, p1, p2);\n  } // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\n\n\n  function _simplifyDP(points, sqTolerance) {\n    var len = points.length,\n        ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\n        markers = new ArrayConstructor(len);\n    markers[0] = markers[len - 1] = 1;\n\n    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\n\n    var i,\n        newPoints = [];\n\n    for (i = 0; i < len; i++) {\n      if (markers[i]) {\n        newPoints.push(points[i]);\n      }\n    }\n\n    return newPoints;\n  }\n\n  function _simplifyDPStep(points, markers, sqTolerance, first, last) {\n    var maxSqDist = 0,\n        index,\n        i,\n        sqDist;\n\n    for (i = first + 1; i <= last - 1; i++) {\n      sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);\n\n      if (sqDist > maxSqDist) {\n        index = i;\n        maxSqDist = sqDist;\n      }\n    }\n\n    if (maxSqDist > sqTolerance) {\n      markers[index] = 1;\n\n      _simplifyDPStep(points, markers, sqTolerance, first, index);\n\n      _simplifyDPStep(points, markers, sqTolerance, index, last);\n    }\n  } // reduce points that are too close to each other to a single point\n\n\n  function _reducePoints(points, sqTolerance) {\n    var reducedPoints = [points[0]];\n\n    for (var i = 1, prev = 0, len = points.length; i < len; i++) {\n      if (_sqDist(points[i], points[prev]) > sqTolerance) {\n        reducedPoints.push(points[i]);\n        prev = i;\n      }\n    }\n\n    if (prev < len - 1) {\n      reducedPoints.push(points[len - 1]);\n    }\n\n    return reducedPoints;\n  }\n\n  var _lastCode; // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean\n  // Clips the segment a to b by rectangular bounds with the\n  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)\n  // (modifying the segment points directly!). Used by Leaflet to only show polyline\n  // points that are on the screen or near, increasing performance.\n\n\n  function clipSegment(a, b, bounds, useLastCode, round) {\n    var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),\n        codeB = _getBitCode(b, bounds),\n        codeOut,\n        p,\n        newCode; // save 2nd code to avoid calculating it on the next segment\n\n\n    _lastCode = codeB;\n\n    while (true) {\n      // if a,b is inside the clip window (trivial accept)\n      if (!(codeA | codeB)) {\n        return [a, b];\n      } // if a,b is outside the clip window (trivial reject)\n\n\n      if (codeA & codeB) {\n        return false;\n      } // other cases\n\n\n      codeOut = codeA || codeB;\n      p = _getEdgeIntersection(a, b, codeOut, bounds, round);\n      newCode = _getBitCode(p, bounds);\n\n      if (codeOut === codeA) {\n        a = p;\n        codeA = newCode;\n      } else {\n        b = p;\n        codeB = newCode;\n      }\n    }\n  }\n\n  function _getEdgeIntersection(a, b, code, bounds, round) {\n    var dx = b.x - a.x,\n        dy = b.y - a.y,\n        min = bounds.min,\n        max = bounds.max,\n        x,\n        y;\n\n    if (code & 8) {\n      // top\n      x = a.x + dx * (max.y - a.y) / dy;\n      y = max.y;\n    } else if (code & 4) {\n      // bottom\n      x = a.x + dx * (min.y - a.y) / dy;\n      y = min.y;\n    } else if (code & 2) {\n      // right\n      x = max.x;\n      y = a.y + dy * (max.x - a.x) / dx;\n    } else if (code & 1) {\n      // left\n      x = min.x;\n      y = a.y + dy * (min.x - a.x) / dx;\n    }\n\n    return new Point(x, y, round);\n  }\n\n  function _getBitCode(p, bounds) {\n    var code = 0;\n\n    if (p.x < bounds.min.x) {\n      // left\n      code |= 1;\n    } else if (p.x > bounds.max.x) {\n      // right\n      code |= 2;\n    }\n\n    if (p.y < bounds.min.y) {\n      // bottom\n      code |= 4;\n    } else if (p.y > bounds.max.y) {\n      // top\n      code |= 8;\n    }\n\n    return code;\n  } // square distance (to avoid unnecessary Math.sqrt calls)\n\n\n  function _sqDist(p1, p2) {\n    var dx = p2.x - p1.x,\n        dy = p2.y - p1.y;\n    return dx * dx + dy * dy;\n  } // return closest point on segment or distance to that point\n\n\n  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\n    var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y,\n        dot = dx * dx + dy * dy,\n        t;\n\n    if (dot > 0) {\n      t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n\n      if (t > 1) {\n        x = p2.x;\n        y = p2.y;\n      } else if (t > 0) {\n        x += dx * t;\n        y += dy * t;\n      }\n    }\n\n    dx = p.x - x;\n    dy = p.y - y;\n    return sqDist ? dx * dx + dy * dy : new Point(x, y);\n  } // @function isFlat(latlngs: LatLng[]): Boolean\n  // Returns true if `latlngs` is a flat array, false is nested.\n\n\n  function isFlat(latlngs) {\n    return !isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';\n  }\n\n  function _flat(latlngs) {\n    console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');\n    return isFlat(latlngs);\n  }\n\n  var LineUtil = (Object.freeze || Object)({\n    simplify: simplify,\n    pointToSegmentDistance: pointToSegmentDistance,\n    closestPointOnSegment: closestPointOnSegment,\n    clipSegment: clipSegment,\n    _getEdgeIntersection: _getEdgeIntersection,\n    _getBitCode: _getBitCode,\n    _sqClosestPointOnSegment: _sqClosestPointOnSegment,\n    isFlat: isFlat,\n    _flat: _flat\n  });\n  /*\r\n   * @namespace PolyUtil\r\n   * Various utility functions for polygon geometries.\r\n   */\n\n  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]\r\n   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).\r\n   * Used by Leaflet to only show polygon points that are on the screen or near, increasing\r\n   * performance. Note that polygon points needs different algorithm for clipping\r\n   * than polyline, so there's a separate method for it.\r\n   */\n\n  function clipPolygon(points, bounds, round) {\n    var clippedPoints,\n        edges = [1, 4, 2, 8],\n        i,\n        j,\n        k,\n        a,\n        b,\n        len,\n        edge,\n        p;\n\n    for (i = 0, len = points.length; i < len; i++) {\n      points[i]._code = _getBitCode(points[i], bounds);\n    } // for each edge (left, bottom, right, top)\n\n\n    for (k = 0; k < 4; k++) {\n      edge = edges[k];\n      clippedPoints = [];\n\n      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        a = points[i];\n        b = points[j]; // if a is inside the clip window\n\n        if (!(a._code & edge)) {\n          // if b is outside the clip window (a->b goes out of screen)\n          if (b._code & edge) {\n            p = _getEdgeIntersection(b, a, edge, bounds, round);\n            p._code = _getBitCode(p, bounds);\n            clippedPoints.push(p);\n          }\n\n          clippedPoints.push(a); // else if b is inside the clip window (a->b enters the screen)\n        } else if (!(b._code & edge)) {\n          p = _getEdgeIntersection(b, a, edge, bounds, round);\n          p._code = _getBitCode(p, bounds);\n          clippedPoints.push(p);\n        }\n      }\n\n      points = clippedPoints;\n    }\n\n    return points;\n  }\n\n  var PolyUtil = (Object.freeze || Object)({\n    clipPolygon: clipPolygon\n  });\n  /*\r\n   * @namespace Projection\r\n   * @section\r\n   * Leaflet comes with a set of already defined Projections out of the box:\r\n   *\r\n   * @projection L.Projection.LonLat\r\n   *\r\n   * Equirectangular, or Plate Carree projection — the most simple projection,\r\n   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as\r\n   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the\r\n   * `EPSG:4326` and `Simple` CRS.\r\n   */\n\n  var LonLat = {\n    project: function (latlng) {\n      return new Point(latlng.lng, latlng.lat);\n    },\n    unproject: function (point) {\n      return new LatLng(point.y, point.x);\n    },\n    bounds: new Bounds([-180, -90], [180, 90])\n  };\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.Mercator\r\n   *\r\n   * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.\r\n   */\n\n  var Mercator = {\n    R: 6378137,\n    R_MINOR: 6356752.314245179,\n    bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),\n    project: function (latlng) {\n      var d = Math.PI / 180,\n          r = this.R,\n          y = latlng.lat * d,\n          tmp = this.R_MINOR / r,\n          e = Math.sqrt(1 - tmp * tmp),\n          con = e * Math.sin(y);\n      var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\n      y = -r * Math.log(Math.max(ts, 1E-10));\n      return new Point(latlng.lng * d * r, y);\n    },\n    unproject: function (point) {\n      var d = 180 / Math.PI,\n          r = this.R,\n          tmp = this.R_MINOR / r,\n          e = Math.sqrt(1 - tmp * tmp),\n          ts = Math.exp(-point.y / r),\n          phi = Math.PI / 2 - 2 * Math.atan(ts);\n\n      for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {\n        con = e * Math.sin(phi);\n        con = Math.pow((1 - con) / (1 + con), e / 2);\n        dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\n        phi += dphi;\n      }\n\n      return new LatLng(phi * d, point.x * d / r);\n    }\n  };\n  /*\n   * @class Projection\n  \n   * An object with methods for projecting geographical coordinates of the world onto\n   * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).\n  \n   * @property bounds: Bounds\n   * The bounds (specified in CRS units) where the projection is valid\n  \n   * @method project(latlng: LatLng): Point\n   * Projects geographical coordinates into a 2D point.\n   * Only accepts actual `L.LatLng` instances, not arrays.\n  \n   * @method unproject(point: Point): LatLng\n   * The inverse of `project`. Projects a 2D point into a geographical location.\n   * Only accepts actual `L.Point` instances, not arrays.\n  \n   * Note that the projection instances do not inherit from Leafet's `Class` object,\n   * and can't be instantiated. Also, new classes can't inherit from them,\n   * and methods can't be added to them with the `include` function.\n  \n   */\n\n  var index = (Object.freeze || Object)({\n    LonLat: LonLat,\n    Mercator: Mercator,\n    SphericalMercator: SphericalMercator\n  });\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3395\r\n   *\r\n   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.\r\n   */\n\n  var EPSG3395 = extend({}, Earth, {\n    code: 'EPSG:3395',\n    projection: Mercator,\n    transformation: function () {\n      var scale = 0.5 / (Math.PI * Mercator.R);\n      return toTransformation(scale, 0.5, -scale, 0.5);\n    }()\n  });\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG4326\r\n   *\r\n   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\r\n   *\r\n   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),\r\n   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`\r\n   * with this CRS, ensure that there are two 256x256 pixel tiles covering the\r\n   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),\r\n   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.\r\n   */\n\n  var EPSG4326 = extend({}, Earth, {\n    code: 'EPSG:4326',\n    projection: LonLat,\n    transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)\n  });\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Simple\n   *\n   * A simple CRS that maps longitude and latitude into `x` and `y` directly.\n   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`\n   * axis should still be inverted (going from bottom to top). `distance()` returns\n   * simple euclidean distance.\n   */\n\n  var Simple = extend({}, CRS, {\n    projection: LonLat,\n    transformation: toTransformation(1, 0, -1, 0),\n    scale: function (zoom) {\n      return Math.pow(2, zoom);\n    },\n    zoom: function (scale) {\n      return Math.log(scale) / Math.LN2;\n    },\n    distance: function (latlng1, latlng2) {\n      var dx = latlng2.lng - latlng1.lng,\n          dy = latlng2.lat - latlng1.lat;\n      return Math.sqrt(dx * dx + dy * dy);\n    },\n    infinite: true\n  });\n  CRS.Earth = Earth;\n  CRS.EPSG3395 = EPSG3395;\n  CRS.EPSG3857 = EPSG3857;\n  CRS.EPSG900913 = EPSG900913;\n  CRS.EPSG4326 = EPSG4326;\n  CRS.Simple = Simple;\n  /*\n   * @class Layer\n   * @inherits Evented\n   * @aka L.Layer\n   * @aka ILayer\n   *\n   * A set of methods from the Layer base class that all Leaflet layers use.\n   * Inherits all methods, options and events from `L.Evented`.\n   *\n   * @example\n   *\n   * ```js\n   * var layer = L.marker(latlng).addTo(map);\n   * layer.addTo(map);\n   * layer.remove();\n   * ```\n   *\n   * @event add: Event\n   * Fired after the layer is added to a map\n   *\n   * @event remove: Event\n   * Fired after the layer is removed from a map\n   */\n\n  var Layer = Evented.extend({\n    // Classes extending `L.Layer` will inherit the following options:\n    options: {\n      // @option pane: String = 'overlayPane'\n      // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.\n      pane: 'overlayPane',\n      // @option attribution: String = null\n      // String to be shown in the attribution control, e.g. \"© OpenStreetMap contributors\". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.\n      attribution: null,\n      bubblingMouseEvents: true\n    },\n\n    /* @section\n     * Classes extending `L.Layer` will inherit the following methods:\n     *\n     * @method addTo(map: Map|LayerGroup): this\n     * Adds the layer to the given map or layer group.\n     */\n    addTo: function (map) {\n      map.addLayer(this);\n      return this;\n    },\n    // @method remove: this\n    // Removes the layer from the map it is currently active on.\n    remove: function () {\n      return this.removeFrom(this._map || this._mapToAdd);\n    },\n    // @method removeFrom(map: Map): this\n    // Removes the layer from the given map\n    removeFrom: function (obj) {\n      if (obj) {\n        obj.removeLayer(this);\n      }\n\n      return this;\n    },\n    // @method getPane(name? : String): HTMLElement\n    // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.\n    getPane: function (name) {\n      return this._map.getPane(name ? this.options[name] || name : this.options.pane);\n    },\n    addInteractiveTarget: function (targetEl) {\n      this._map._targets[stamp(targetEl)] = this;\n      return this;\n    },\n    removeInteractiveTarget: function (targetEl) {\n      delete this._map._targets[stamp(targetEl)];\n      return this;\n    },\n    // @method getAttribution: String\n    // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).\n    getAttribution: function () {\n      return this.options.attribution;\n    },\n    _layerAdd: function (e) {\n      var map = e.target; // check in case layer gets added and then removed before the map is ready\n\n      if (!map.hasLayer(this)) {\n        return;\n      }\n\n      this._map = map;\n      this._zoomAnimated = map._zoomAnimated;\n\n      if (this.getEvents) {\n        var events = this.getEvents();\n        map.on(events, this);\n        this.once('remove', function () {\n          map.off(events, this);\n        }, this);\n      }\n\n      this.onAdd(map);\n\n      if (this.getAttribution && map.attributionControl) {\n        map.attributionControl.addAttribution(this.getAttribution());\n      }\n\n      this.fire('add');\n      map.fire('layeradd', {\n        layer: this\n      });\n    }\n  });\n  /* @section Extension methods\n   * @uninheritable\n   *\n   * Every layer should extend from `L.Layer` and (re-)implement the following methods.\n   *\n   * @method onAdd(map: Map): this\n   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).\n   *\n   * @method onRemove(map: Map): this\n   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).\n   *\n   * @method getEvents(): Object\n   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.\n   *\n   * @method getAttribution(): String\n   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.\n   *\n   * @method beforeAdd(map: Map): this\n   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.\n   */\n\n  /* @namespace Map\n   * @section Layer events\n   *\n   * @event layeradd: LayerEvent\n   * Fired when a new layer is added to the map.\n   *\n   * @event layerremove: LayerEvent\n   * Fired when some layer is removed from the map\n   *\n   * @section Methods for Layers and Controls\n   */\n\n  Map.include({\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the map\n    addLayer: function (layer) {\n      if (!layer._layerAdd) {\n        throw new Error('The provided object is not a Layer.');\n      }\n\n      var id = stamp(layer);\n\n      if (this._layers[id]) {\n        return this;\n      }\n\n      this._layers[id] = layer;\n      layer._mapToAdd = this;\n\n      if (layer.beforeAdd) {\n        layer.beforeAdd(this);\n      }\n\n      this.whenReady(layer._layerAdd, layer);\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the map.\n    removeLayer: function (layer) {\n      var id = stamp(layer);\n\n      if (!this._layers[id]) {\n        return this;\n      }\n\n      if (this._loaded) {\n        layer.onRemove(this);\n      }\n\n      if (layer.getAttribution && this.attributionControl) {\n        this.attributionControl.removeAttribution(layer.getAttribution());\n      }\n\n      delete this._layers[id];\n\n      if (this._loaded) {\n        this.fire('layerremove', {\n          layer: layer\n        });\n        layer.fire('remove');\n      }\n\n      layer._map = layer._mapToAdd = null;\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the map\n    hasLayer: function (layer) {\n      return !!layer && stamp(layer) in this._layers;\n    },\n\n    /* @method eachLayer(fn: Function, context?: Object): this\n     * Iterates over the layers of the map, optionally specifying context of the iterator function.\n     * ```\n     * map.eachLayer(function(layer){\n     *     layer.bindPopup('Hello');\n     * });\n     * ```\n     */\n    eachLayer: function (method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n\n      return this;\n    },\n    _addLayers: function (layers) {\n      layers = layers ? isArray(layers) ? layers : [layers] : [];\n\n      for (var i = 0, len = layers.length; i < len; i++) {\n        this.addLayer(layers[i]);\n      }\n    },\n    _addZoomLimit: function (layer) {\n      if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n        this._zoomBoundLayers[stamp(layer)] = layer;\n\n        this._updateZoomLevels();\n      }\n    },\n    _removeZoomLimit: function (layer) {\n      var id = stamp(layer);\n\n      if (this._zoomBoundLayers[id]) {\n        delete this._zoomBoundLayers[id];\n\n        this._updateZoomLevels();\n      }\n    },\n    _updateZoomLevels: function () {\n      var minZoom = Infinity,\n          maxZoom = -Infinity,\n          oldZoomSpan = this._getZoomSpan();\n\n      for (var i in this._zoomBoundLayers) {\n        var options = this._zoomBoundLayers[i].options;\n        minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n        maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n      }\n\n      this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n      this._layersMinZoom = minZoom === Infinity ? undefined : minZoom; // @section Map state change events\n      // @event zoomlevelschange: Event\n      // Fired when the number of zoomlevels on the map is changed due\n      // to adding or removing a layer.\n\n      if (oldZoomSpan !== this._getZoomSpan()) {\n        this.fire('zoomlevelschange');\n      }\n\n      if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {\n        this.setZoom(this._layersMaxZoom);\n      }\n\n      if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {\n        this.setZoom(this._layersMinZoom);\n      }\n    }\n  });\n  /*\r\n   * @class LayerGroup\r\n   * @aka L.LayerGroup\r\n   * @inherits Layer\r\n   *\r\n   * Used to group several layers and handle them as one. If you add it to the map,\r\n   * any layers added or removed from the group will be added/removed on the map as\r\n   * well. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.layerGroup([marker1, marker2])\r\n   * \t.addLayer(polyline)\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n  var LayerGroup = Layer.extend({\n    initialize: function (layers, options) {\n      setOptions(this, options);\n      this._layers = {};\n      var i, len;\n\n      if (layers) {\n        for (i = 0, len = layers.length; i < len; i++) {\n          this.addLayer(layers[i]);\n        }\n      }\n    },\n    // @method addLayer(layer: Layer): this\n    // Adds the given layer to the group.\n    addLayer: function (layer) {\n      var id = this.getLayerId(layer);\n      this._layers[id] = layer;\n\n      if (this._map) {\n        this._map.addLayer(layer);\n      }\n\n      return this;\n    },\n    // @method removeLayer(layer: Layer): this\n    // Removes the given layer from the group.\n    // @alternative\n    // @method removeLayer(id: Number): this\n    // Removes the layer with the given internal ID from the group.\n    removeLayer: function (layer) {\n      var id = layer in this._layers ? layer : this.getLayerId(layer);\n\n      if (this._map && this._layers[id]) {\n        this._map.removeLayer(this._layers[id]);\n      }\n\n      delete this._layers[id];\n      return this;\n    },\n    // @method hasLayer(layer: Layer): Boolean\n    // Returns `true` if the given layer is currently added to the group.\n    // @alternative\n    // @method hasLayer(id: Number): Boolean\n    // Returns `true` if the given internal ID is currently added to the group.\n    hasLayer: function (layer) {\n      return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);\n    },\n    // @method clearLayers(): this\n    // Removes all the layers from the group.\n    clearLayers: function () {\n      return this.eachLayer(this.removeLayer, this);\n    },\n    // @method invoke(methodName: String, …): this\n    // Calls `methodName` on every layer contained in this group, passing any\n    // additional parameters. Has no effect if the layers contained do not\n    // implement `methodName`.\n    invoke: function (methodName) {\n      var args = Array.prototype.slice.call(arguments, 1),\n          i,\n          layer;\n\n      for (i in this._layers) {\n        layer = this._layers[i];\n\n        if (layer[methodName]) {\n          layer[methodName].apply(layer, args);\n        }\n      }\n\n      return this;\n    },\n    onAdd: function (map) {\n      this.eachLayer(map.addLayer, map);\n    },\n    onRemove: function (map) {\n      this.eachLayer(map.removeLayer, map);\n    },\n    // @method eachLayer(fn: Function, context?: Object): this\n    // Iterates over the layers of the group, optionally specifying context of the iterator function.\n    // ```js\n    // group.eachLayer(function (layer) {\n    // \tlayer.bindPopup('Hello');\n    // });\n    // ```\n    eachLayer: function (method, context) {\n      for (var i in this._layers) {\n        method.call(context, this._layers[i]);\n      }\n\n      return this;\n    },\n    // @method getLayer(id: Number): Layer\n    // Returns the layer with the given internal ID.\n    getLayer: function (id) {\n      return this._layers[id];\n    },\n    // @method getLayers(): Layer[]\n    // Returns an array of all the layers added to the group.\n    getLayers: function () {\n      var layers = [];\n      this.eachLayer(layers.push, layers);\n      return layers;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Calls `setZIndex` on every layer contained in this group, passing the z-index.\n    setZIndex: function (zIndex) {\n      return this.invoke('setZIndex', zIndex);\n    },\n    // @method getLayerId(layer: Layer): Number\n    // Returns the internal ID for a layer\n    getLayerId: function (layer) {\n      return stamp(layer);\n    }\n  }); // @factory L.layerGroup(layers?: Layer[], options?: Object)\n  // Create a layer group, optionally given an initial set of layers and an `options` object.\n\n  var layerGroup = function (layers, options) {\n    return new LayerGroup(layers, options);\n  };\n  /*\r\n   * @class FeatureGroup\r\n   * @aka L.FeatureGroup\r\n   * @inherits LayerGroup\r\n   *\r\n   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:\r\n   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))\r\n   *  * Events are propagated to the `FeatureGroup`, so if the group has an event\r\n   * handler, it will handle events from any of the layers. This includes mouse events\r\n   * and custom events.\r\n   *  * Has `layeradd` and `layerremove` events\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.featureGroup([marker1, marker2, polyline])\r\n   * \t.bindPopup('Hello world!')\r\n   * \t.on('click', function() { alert('Clicked on a member of the group!'); })\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\n\n\n  var FeatureGroup = LayerGroup.extend({\n    addLayer: function (layer) {\n      if (this.hasLayer(layer)) {\n        return this;\n      }\n\n      layer.addEventParent(this);\n      LayerGroup.prototype.addLayer.call(this, layer); // @event layeradd: LayerEvent\n      // Fired when a layer is added to this `FeatureGroup`\n\n      return this.fire('layeradd', {\n        layer: layer\n      });\n    },\n    removeLayer: function (layer) {\n      if (!this.hasLayer(layer)) {\n        return this;\n      }\n\n      if (layer in this._layers) {\n        layer = this._layers[layer];\n      }\n\n      layer.removeEventParent(this);\n      LayerGroup.prototype.removeLayer.call(this, layer); // @event layerremove: LayerEvent\n      // Fired when a layer is removed from this `FeatureGroup`\n\n      return this.fire('layerremove', {\n        layer: layer\n      });\n    },\n    // @method setStyle(style: Path options): this\n    // Sets the given path options to each layer of the group that has a `setStyle` method.\n    setStyle: function (style) {\n      return this.invoke('setStyle', style);\n    },\n    // @method bringToFront(): this\n    // Brings the layer group to the top of all other layers\n    bringToFront: function () {\n      return this.invoke('bringToFront');\n    },\n    // @method bringToBack(): this\n    // Brings the layer group to the back of all other layers\n    bringToBack: function () {\n      return this.invoke('bringToBack');\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).\n    getBounds: function () {\n      var bounds = new LatLngBounds();\n\n      for (var id in this._layers) {\n        var layer = this._layers[id];\n        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\n      }\n\n      return bounds;\n    }\n  }); // @factory L.featureGroup(layers: Layer[])\n  // Create a feature group, optionally given an initial set of layers.\n\n  var featureGroup = function (layers) {\n    return new FeatureGroup(layers);\n  };\n  /*\r\n   * @class Icon\r\n   * @aka L.Icon\r\n   *\r\n   * Represents an icon to provide when creating a marker.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var myIcon = L.icon({\r\n   *     iconUrl: 'my-icon.png',\r\n   *     iconRetinaUrl: 'my-icon@2x.png',\r\n   *     iconSize: [38, 95],\r\n   *     iconAnchor: [22, 94],\r\n   *     popupAnchor: [-3, -76],\r\n   *     shadowUrl: 'my-icon-shadow.png',\r\n   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',\r\n   *     shadowSize: [68, 95],\r\n   *     shadowAnchor: [22, 94]\r\n   * });\r\n   *\r\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\r\n   * ```\r\n   *\r\n   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.\r\n   *\r\n   */\n\n\n  var Icon = Class.extend({\n    /* @section\r\n     * @aka Icon options\r\n     *\r\n     * @option iconUrl: String = null\r\n     * **(required)** The URL to the icon image (absolute or relative to your script path).\r\n     *\r\n     * @option iconRetinaUrl: String = null\r\n     * The URL to a retina sized version of the icon image (absolute or relative to your\r\n     * script path). Used for Retina screen devices.\r\n     *\r\n     * @option iconSize: Point = null\r\n     * Size of the icon image in pixels.\r\n     *\r\n     * @option iconAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the icon (relative to its top left corner). The icon\r\n     * will be aligned so that this point is at the marker's geographical location. Centered\r\n     * by default if size is specified, also can be set in CSS with negative margins.\r\n     *\r\n     * @option popupAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which popups will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option tooltipAnchor: Point = [0, 0]\r\n     * The coordinates of the point from which tooltips will \"open\", relative to the icon anchor.\r\n     *\r\n     * @option shadowUrl: String = null\r\n     * The URL to the icon shadow image. If not specified, no shadow image will be created.\r\n     *\r\n     * @option shadowRetinaUrl: String = null\r\n     *\r\n     * @option shadowSize: Point = null\r\n     * Size of the shadow image in pixels.\r\n     *\r\n     * @option shadowAnchor: Point = null\r\n     * The coordinates of the \"tip\" of the shadow (relative to its top left corner) (the same\r\n     * as iconAnchor if not specified).\r\n     *\r\n     * @option className: String = ''\r\n     * A custom class name to assign to both icon and shadow images. Empty by default.\r\n     */\n    options: {\n      popupAnchor: [0, 0],\n      tooltipAnchor: [0, 0]\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    // @method createIcon(oldIcon?: HTMLElement): HTMLElement\n    // Called internally when the icon has to be shown, returns a `<img>` HTML element\n    // styled according to the options.\n    createIcon: function (oldIcon) {\n      return this._createIcon('icon', oldIcon);\n    },\n    // @method createShadow(oldIcon?: HTMLElement): HTMLElement\n    // As `createIcon`, but for the shadow beneath it.\n    createShadow: function (oldIcon) {\n      return this._createIcon('shadow', oldIcon);\n    },\n    _createIcon: function (name, oldIcon) {\n      var src = this._getIconUrl(name);\n\n      if (!src) {\n        if (name === 'icon') {\n          throw new Error('iconUrl not set in Icon options (see the docs).');\n        }\n\n        return null;\n      }\n\n      var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);\n\n      this._setIconStyles(img, name);\n\n      return img;\n    },\n    _setIconStyles: function (img, name) {\n      var options = this.options;\n      var sizeOption = options[name + 'Size'];\n\n      if (typeof sizeOption === 'number') {\n        sizeOption = [sizeOption, sizeOption];\n      }\n\n      var size = toPoint(sizeOption),\n          anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));\n      img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\n\n      if (anchor) {\n        img.style.marginLeft = -anchor.x + 'px';\n        img.style.marginTop = -anchor.y + 'px';\n      }\n\n      if (size) {\n        img.style.width = size.x + 'px';\n        img.style.height = size.y + 'px';\n      }\n    },\n    _createImg: function (src, el) {\n      el = el || document.createElement('img');\n      el.src = src;\n      return el;\n    },\n    _getIconUrl: function (name) {\n      return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];\n    }\n  }); // @factory L.icon(options: Icon options)\n  // Creates an icon instance with the given options.\n\n  function icon(options) {\n    return new Icon(options);\n  }\n  /*\n   * @miniclass Icon.Default (Icon)\n   * @aka L.Icon.Default\n   * @section\n   *\n   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when\n   * no icon is specified. Points to the blue marker image distributed with Leaflet\n   * releases.\n   *\n   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`\n   * (which is a set of `Icon options`).\n   *\n   * If you want to _completely_ replace the default icon, override the\n   * `L.Marker.prototype.options.icon` with your own icon instead.\n   */\n\n\n  var IconDefault = Icon.extend({\n    options: {\n      iconUrl: 'marker-icon.png',\n      iconRetinaUrl: 'marker-icon-2x.png',\n      shadowUrl: 'marker-shadow.png',\n      iconSize: [25, 41],\n      iconAnchor: [12, 41],\n      popupAnchor: [1, -34],\n      tooltipAnchor: [16, -28],\n      shadowSize: [41, 41]\n    },\n    _getIconUrl: function (name) {\n      if (!IconDefault.imagePath) {\n        // Deprecated, backwards-compatibility only\n        IconDefault.imagePath = this._detectIconPath();\n      } // @option imagePath: String\n      // `Icon.Default` will try to auto-detect the location of the\n      // blue icon images. If you are placing these images in a non-standard\n      // way, set this option to point to the right path.\n\n\n      return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);\n    },\n    _detectIconPath: function () {\n      var el = create$1('div', 'leaflet-default-icon-path', document.body);\n      var path = getStyle(el, 'background-image') || getStyle(el, 'backgroundImage'); // IE8\n\n      document.body.removeChild(el);\n\n      if (path === null || path.indexOf('url') !== 0) {\n        path = '';\n      } else {\n        path = path.replace(/^url\\([\"']?/, '').replace(/marker-icon\\.png[\"']?\\)$/, '');\n      }\n\n      return path;\n    }\n  });\n  /*\n   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n   */\n\n  /* @namespace Marker\n   * @section Interaction handlers\n   *\n   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:\n   *\n   * ```js\n   * marker.dragging.disable();\n   * ```\n   *\n   * @property dragging: Handler\n   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).\n   */\n\n  var MarkerDrag = Handler.extend({\n    initialize: function (marker) {\n      this._marker = marker;\n    },\n    addHooks: function () {\n      var icon = this._marker._icon;\n\n      if (!this._draggable) {\n        this._draggable = new Draggable(icon, icon, true);\n      }\n\n      this._draggable.on({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).enable();\n\n      addClass(icon, 'leaflet-marker-draggable');\n    },\n    removeHooks: function () {\n      this._draggable.off({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).disable();\n\n      if (this._marker._icon) {\n        removeClass(this._marker._icon, 'leaflet-marker-draggable');\n      }\n    },\n    moved: function () {\n      return this._draggable && this._draggable._moved;\n    },\n    _adjustPan: function (e) {\n      var marker = this._marker,\n          map = marker._map,\n          speed = this._marker.options.autoPanSpeed,\n          padding = this._marker.options.autoPanPadding,\n          iconPos = getPosition(marker._icon),\n          bounds = map.getPixelBounds(),\n          origin = map.getPixelOrigin();\n      var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));\n\n      if (!panBounds.contains(iconPos)) {\n        // Compute incremental movement\n        var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);\n        map.panBy(movement, {\n          animate: false\n        });\n\n        this._draggable._newPos._add(movement);\n\n        this._draggable._startPos._add(movement);\n\n        setPosition(marker._icon, this._draggable._newPos);\n\n        this._onDrag(e);\n\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDragStart: function () {\n      // @section Dragging events\n      // @event dragstart: Event\n      // Fired when the user starts dragging the marker.\n      // @event movestart: Event\n      // Fired when the marker starts moving (because of dragging).\n      this._oldLatLng = this._marker.getLatLng();\n\n      this._marker.closePopup().fire('movestart').fire('dragstart');\n    },\n    _onPreDrag: function (e) {\n      if (this._marker.options.autoPan) {\n        cancelAnimFrame(this._panRequest);\n        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n      }\n    },\n    _onDrag: function (e) {\n      var marker = this._marker,\n          shadow = marker._shadow,\n          iconPos = getPosition(marker._icon),\n          latlng = marker._map.layerPointToLatLng(iconPos); // update shadow position\n\n\n      if (shadow) {\n        setPosition(shadow, iconPos);\n      }\n\n      marker._latlng = latlng;\n      e.latlng = latlng;\n      e.oldLatLng = this._oldLatLng; // @event drag: Event\n      // Fired repeatedly while the user drags the marker.\n\n      marker.fire('move', e).fire('drag', e);\n    },\n    _onDragEnd: function (e) {\n      // @event dragend: DragEndEvent\n      // Fired when the user stops dragging the marker.\n      cancelAnimFrame(this._panRequest); // @event moveend: Event\n      // Fired when the marker stops moving (because of dragging).\n\n      delete this._oldLatLng;\n\n      this._marker.fire('moveend').fire('dragend', e);\n    }\n  });\n  /*\r\n   * @class Marker\r\n   * @inherits Interactive layer\r\n   * @aka L.Marker\r\n   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.marker([50.5, 30.5]).addTo(map);\r\n   * ```\r\n   */\n\n  var Marker = Layer.extend({\n    // @section\n    // @aka Marker options\n    options: {\n      // @option icon: Icon = *\n      // Icon instance to use for rendering the marker.\n      // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.\n      // If not specified, a common instance of `L.Icon.Default` is used.\n      icon: new IconDefault(),\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option keyboard: Boolean = true\n      // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.\n      keyboard: true,\n      // @option title: String = ''\n      // Text for the browser tooltip that appear on marker hover (no tooltip by default).\n      title: '',\n      // @option alt: String = ''\n      // Text for the `alt` attribute of the icon image (useful for accessibility).\n      alt: '',\n      // @option zIndexOffset: Number = 0\n      // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).\n      zIndexOffset: 0,\n      // @option opacity: Number = 1.0\n      // The opacity of the marker.\n      opacity: 1,\n      // @option riseOnHover: Boolean = false\n      // If `true`, the marker will get on top of others when you hover the mouse over it.\n      riseOnHover: false,\n      // @option riseOffset: Number = 250\n      // The z-index offset used for the `riseOnHover` feature.\n      riseOffset: 250,\n      // @option pane: String = 'markerPane'\n      // `Map pane` where the markers icon will be added.\n      pane: 'markerPane',\n      // @option pane: String = 'shadowPane'\n      // `Map pane` where the markers shadow will be added.\n      shadowPane: 'shadowPane',\n      // @option bubblingMouseEvents: Boolean = false\n      // When `true`, a mouse event on this marker will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: false,\n      // @section Draggable marker options\n      // @option draggable: Boolean = false\n      // Whether the marker is draggable with mouse/touch or not.\n      draggable: false,\n      // @option autoPan: Boolean = false\n      // Whether to pan the map when dragging this marker near its edge or not.\n      autoPan: false,\n      // @option autoPanPadding: Point = Point(50, 50)\n      // Distance (in pixels to the left/right and to the top/bottom) of the\n      // map edge to start panning the map.\n      autoPanPadding: [50, 50],\n      // @option autoPanSpeed: Number = 10\n      // Number of pixels the map should pan by.\n      autoPanSpeed: 10\n    },\n\n    /* @section\r\n     *\r\n     * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:\r\n     */\n    initialize: function (latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n    },\n    onAdd: function (map) {\n      this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\n\n      if (this._zoomAnimated) {\n        map.on('zoomanim', this._animateZoom, this);\n      }\n\n      this._initIcon();\n\n      this.update();\n    },\n    onRemove: function (map) {\n      if (this.dragging && this.dragging.enabled()) {\n        this.options.draggable = true;\n        this.dragging.removeHooks();\n      }\n\n      delete this.dragging;\n\n      if (this._zoomAnimated) {\n        map.off('zoomanim', this._animateZoom, this);\n      }\n\n      this._removeIcon();\n\n      this._removeShadow();\n    },\n    getEvents: function () {\n      return {\n        zoom: this.update,\n        viewreset: this.update\n      };\n    },\n    // @method getLatLng: LatLng\n    // Returns the current geographical position of the marker.\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Changes the marker position to the given point.\n    setLatLng: function (latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.update(); // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method setZIndexOffset(offset: Number): this\n    // Changes the [zIndex offset](#marker-zindexoffset) of the marker.\n    setZIndexOffset: function (offset) {\n      this.options.zIndexOffset = offset;\n      return this.update();\n    },\n    // @method getIcon: Icon\n    // Returns the current icon used by the marker\n    getIcon: function () {\n      return this.options.icon;\n    },\n    // @method setIcon(icon: Icon): this\n    // Changes the marker icon.\n    setIcon: function (icon) {\n      this.options.icon = icon;\n\n      if (this._map) {\n        this._initIcon();\n\n        this.update();\n      }\n\n      if (this._popup) {\n        this.bindPopup(this._popup, this._popup.options);\n      }\n\n      return this;\n    },\n    getElement: function () {\n      return this._icon;\n    },\n    update: function () {\n      if (this._icon && this._map) {\n        var pos = this._map.latLngToLayerPoint(this._latlng).round();\n\n        this._setPos(pos);\n      }\n\n      return this;\n    },\n    _initIcon: function () {\n      var options = this.options,\n          classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      var icon = options.icon.createIcon(this._icon),\n          addIcon = false; // if we're not reusing the icon, remove the old one and init new one\n\n      if (icon !== this._icon) {\n        if (this._icon) {\n          this._removeIcon();\n        }\n\n        addIcon = true;\n\n        if (options.title) {\n          icon.title = options.title;\n        }\n\n        if (icon.tagName === 'IMG') {\n          icon.alt = options.alt || '';\n        }\n      }\n\n      addClass(icon, classToAdd);\n\n      if (options.keyboard) {\n        icon.tabIndex = '0';\n      }\n\n      this._icon = icon;\n\n      if (options.riseOnHover) {\n        this.on({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n\n      var newShadow = options.icon.createShadow(this._shadow),\n          addShadow = false;\n\n      if (newShadow !== this._shadow) {\n        this._removeShadow();\n\n        addShadow = true;\n      }\n\n      if (newShadow) {\n        addClass(newShadow, classToAdd);\n        newShadow.alt = '';\n      }\n\n      this._shadow = newShadow;\n\n      if (options.opacity < 1) {\n        this._updateOpacity();\n      }\n\n      if (addIcon) {\n        this.getPane().appendChild(this._icon);\n      }\n\n      this._initInteraction();\n\n      if (newShadow && addShadow) {\n        this.getPane(options.shadowPane).appendChild(this._shadow);\n      }\n    },\n    _removeIcon: function () {\n      if (this.options.riseOnHover) {\n        this.off({\n          mouseover: this._bringToFront,\n          mouseout: this._resetZIndex\n        });\n      }\n\n      remove(this._icon);\n      this.removeInteractiveTarget(this._icon);\n      this._icon = null;\n    },\n    _removeShadow: function () {\n      if (this._shadow) {\n        remove(this._shadow);\n      }\n\n      this._shadow = null;\n    },\n    _setPos: function (pos) {\n      if (this._icon) {\n        setPosition(this._icon, pos);\n      }\n\n      if (this._shadow) {\n        setPosition(this._shadow, pos);\n      }\n\n      this._zIndex = pos.y + this.options.zIndexOffset;\n\n      this._resetZIndex();\n    },\n    _updateZIndex: function (offset) {\n      if (this._icon) {\n        this._icon.style.zIndex = this._zIndex + offset;\n      }\n    },\n    _animateZoom: function (opt) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\n\n      this._setPos(pos);\n    },\n    _initInteraction: function () {\n      if (!this.options.interactive) {\n        return;\n      }\n\n      addClass(this._icon, 'leaflet-interactive');\n      this.addInteractiveTarget(this._icon);\n\n      if (MarkerDrag) {\n        var draggable = this.options.draggable;\n\n        if (this.dragging) {\n          draggable = this.dragging.enabled();\n          this.dragging.disable();\n        }\n\n        this.dragging = new MarkerDrag(this);\n\n        if (draggable) {\n          this.dragging.enable();\n        }\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the opacity of the marker.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      if (this._map) {\n        this._updateOpacity();\n      }\n\n      return this;\n    },\n    _updateOpacity: function () {\n      var opacity = this.options.opacity;\n\n      if (this._icon) {\n        setOpacity(this._icon, opacity);\n      }\n\n      if (this._shadow) {\n        setOpacity(this._shadow, opacity);\n      }\n    },\n    _bringToFront: function () {\n      this._updateZIndex(this.options.riseOffset);\n    },\n    _resetZIndex: function () {\n      this._updateZIndex(0);\n    },\n    _getPopupAnchor: function () {\n      return this.options.icon.options.popupAnchor;\n    },\n    _getTooltipAnchor: function () {\n      return this.options.icon.options.tooltipAnchor;\n    }\n  }); // factory L.marker(latlng: LatLng, options? : Marker options)\n  // @factory L.marker(latlng: LatLng, options? : Marker options)\n  // Instantiates a Marker object given a geographical point and optionally an options object.\n\n  function marker(latlng, options) {\n    return new Marker(latlng, options);\n  }\n  /*\n   * @class Path\n   * @aka L.Path\n   * @inherits Interactive layer\n   *\n   * An abstract class that contains options and constants shared between vector\n   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.\n   */\n\n\n  var Path = Layer.extend({\n    // @section\n    // @aka Path options\n    options: {\n      // @option stroke: Boolean = true\n      // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.\n      stroke: true,\n      // @option color: String = '#3388ff'\n      // Stroke color\n      color: '#3388ff',\n      // @option weight: Number = 3\n      // Stroke width in pixels\n      weight: 3,\n      // @option opacity: Number = 1.0\n      // Stroke opacity\n      opacity: 1,\n      // @option lineCap: String= 'round'\n      // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.\n      lineCap: 'round',\n      // @option lineJoin: String = 'round'\n      // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.\n      lineJoin: 'round',\n      // @option dashArray: String = null\n      // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashArray: null,\n      // @option dashOffset: String = null\n      // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n      dashOffset: null,\n      // @option fill: Boolean = depends\n      // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.\n      fill: false,\n      // @option fillColor: String = *\n      // Fill color. Defaults to the value of the [`color`](#path-color) option\n      fillColor: null,\n      // @option fillOpacity: Number = 0.2\n      // Fill opacity.\n      fillOpacity: 0.2,\n      // @option fillRule: String = 'evenodd'\n      // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.\n      fillRule: 'evenodd',\n      // className: '',\n      // Option inherited from \"Interactive layer\" abstract class\n      interactive: true,\n      // @option bubblingMouseEvents: Boolean = true\n      // When `true`, a mouse event on this path will trigger the same event on the map\n      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n      bubblingMouseEvents: true\n    },\n    beforeAdd: function (map) {\n      // Renderer is set here because we need to call renderer.getEvents\n      // before this.getEvents.\n      this._renderer = map.getRenderer(this);\n    },\n    onAdd: function () {\n      this._renderer._initPath(this);\n\n      this._reset();\n\n      this._renderer._addPath(this);\n    },\n    onRemove: function () {\n      this._renderer._removePath(this);\n    },\n    // @method redraw(): this\n    // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.\n    redraw: function () {\n      if (this._map) {\n        this._renderer._updatePath(this);\n      }\n\n      return this;\n    },\n    // @method setStyle(style: Path options): this\n    // Changes the appearance of a Path based on the options in the `Path options` object.\n    setStyle: function (style) {\n      setOptions(this, style);\n\n      if (this._renderer) {\n        this._renderer._updateStyle(this);\n\n        if (this.options.stroke && style && style.hasOwnProperty('weight')) {\n          this._updateBounds();\n        }\n      }\n\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all path layers.\n    bringToFront: function () {\n      if (this._renderer) {\n        this._renderer._bringToFront(this);\n      }\n\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all path layers.\n    bringToBack: function () {\n      if (this._renderer) {\n        this._renderer._bringToBack(this);\n      }\n\n      return this;\n    },\n    getElement: function () {\n      return this._path;\n    },\n    _reset: function () {\n      // defined in child classes\n      this._project();\n\n      this._update();\n    },\n    _clickTolerance: function () {\n      // used when doing hit detection for Canvas layers\n      return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;\n    }\n  });\n  /*\n   * @class CircleMarker\n   * @aka L.CircleMarker\n   * @inherits Path\n   *\n   * A circle of a fixed size with radius specified in pixels. Extends `Path`.\n   */\n\n  var CircleMarker = Path.extend({\n    // @section\n    // @aka CircleMarker options\n    options: {\n      fill: true,\n      // @option radius: Number = 10\n      // Radius of the circle marker, in pixels\n      radius: 10\n    },\n    initialize: function (latlng, options) {\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n      this._radius = this.options.radius;\n    },\n    // @method setLatLng(latLng: LatLng): this\n    // Sets the position of a circle marker to a new location.\n    setLatLng: function (latlng) {\n      var oldLatLng = this._latlng;\n      this._latlng = toLatLng(latlng);\n      this.redraw(); // @event move: Event\n      // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n\n      return this.fire('move', {\n        oldLatLng: oldLatLng,\n        latlng: this._latlng\n      });\n    },\n    // @method getLatLng(): LatLng\n    // Returns the current geographical position of the circle marker\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle marker. Units are in pixels.\n    setRadius: function (radius) {\n      this.options.radius = this._radius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of the circle\n    getRadius: function () {\n      return this._radius;\n    },\n    setStyle: function (options) {\n      var radius = options && options.radius || this._radius;\n      Path.prototype.setStyle.call(this, options);\n      this.setRadius(radius);\n      return this;\n    },\n    _project: function () {\n      this._point = this._map.latLngToLayerPoint(this._latlng);\n\n      this._updateBounds();\n    },\n    _updateBounds: function () {\n      var r = this._radius,\n          r2 = this._radiusY || r,\n          w = this._clickTolerance(),\n          p = [r + w, r2 + w];\n\n      this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));\n    },\n    _update: function () {\n      if (this._map) {\n        this._updatePath();\n      }\n    },\n    _updatePath: function () {\n      this._renderer._updateCircle(this);\n    },\n    _empty: function () {\n      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p) {\n      return p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n    }\n  }); // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)\n  // Instantiates a circle marker object given a geographical point, and an optional options object.\n\n  function circleMarker(latlng, options) {\n    return new CircleMarker(latlng, options);\n  }\n  /*\n   * @class Circle\n   * @aka L.Circle\n   * @inherits CircleMarker\n   *\n   * A class for drawing circle overlays on a map. Extends `CircleMarker`.\n   *\n   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).\n   *\n   * @example\n   *\n   * ```js\n   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);\n   * ```\n   */\n\n\n  var Circle = CircleMarker.extend({\n    initialize: function (latlng, options, legacyOptions) {\n      if (typeof options === 'number') {\n        // Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n        options = extend({}, legacyOptions, {\n          radius: options\n        });\n      }\n\n      setOptions(this, options);\n      this._latlng = toLatLng(latlng);\n\n      if (isNaN(this.options.radius)) {\n        throw new Error('Circle radius cannot be NaN');\n      } // @section\n      // @aka Circle options\n      // @option radius: Number; Radius of the circle, in meters.\n\n\n      this._mRadius = this.options.radius;\n    },\n    // @method setRadius(radius: Number): this\n    // Sets the radius of a circle. Units are in meters.\n    setRadius: function (radius) {\n      this._mRadius = radius;\n      return this.redraw();\n    },\n    // @method getRadius(): Number\n    // Returns the current radius of a circle. Units are in meters.\n    getRadius: function () {\n      return this._mRadius;\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function () {\n      var half = [this._radius, this._radiusY || this._radius];\n      return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));\n    },\n    setStyle: Path.prototype.setStyle,\n    _project: function () {\n      var lng = this._latlng.lng,\n          lat = this._latlng.lat,\n          map = this._map,\n          crs = map.options.crs;\n\n      if (crs.distance === Earth.distance) {\n        var d = Math.PI / 180,\n            latR = this._mRadius / Earth.R / d,\n            top = map.project([lat + latR, lng]),\n            bottom = map.project([lat - latR, lng]),\n            p = top.add(bottom).divideBy(2),\n            lat2 = map.unproject(p).lat,\n            lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n\n        if (isNaN(lngR) || lngR === 0) {\n          lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425\n        }\n\n        this._point = p.subtract(map.getPixelOrigin());\n        this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;\n        this._radiusY = p.y - top.y;\n      } else {\n        var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));\n        this._point = map.latLngToLayerPoint(this._latlng);\n        this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n      }\n\n      this._updateBounds();\n    }\n  }); // @factory L.circle(latlng: LatLng, options?: Circle options)\n  // Instantiates a circle object given a geographical point, and an options object\n  // which contains the circle radius.\n  // @alternative\n  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)\n  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.\n  // Do not use in new applications or plugins.\n\n  function circle(latlng, options, legacyOptions) {\n    return new Circle(latlng, options, legacyOptions);\n  }\n  /*\n   * @class Polyline\n   * @aka L.Polyline\n   * @inherits Path\n   *\n   * A class for drawing polyline overlays on a map. Extends `Path`.\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polyline from an array of LatLng points\n   * var latlngs = [\n   * \t[45.51, -122.68],\n   * \t[37.77, -122.43],\n   * \t[34.04, -118.2]\n   * ];\n   *\n   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polyline\n   * map.fitBounds(polyline.getBounds());\n   * ```\n   *\n   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\n   *\n   * ```js\n   * // create a red polyline from an array of arrays of LatLng points\n   * var latlngs = [\n   * \t[[45.51, -122.68],\n   * \t [37.77, -122.43],\n   * \t [34.04, -118.2]],\n   * \t[[40.78, -73.91],\n   * \t [41.83, -87.62],\n   * \t [32.76, -96.72]]\n   * ];\n   * ```\n   */\n\n\n  var Polyline = Path.extend({\n    // @section\n    // @aka Polyline options\n    options: {\n      // @option smoothFactor: Number = 1.0\n      // How much to simplify the polyline on each zoom level. More means\n      // better performance and smoother look, and less means more accurate representation.\n      smoothFactor: 1.0,\n      // @option noClip: Boolean = false\n      // Disable polyline clipping.\n      noClip: false\n    },\n    initialize: function (latlngs, options) {\n      setOptions(this, options);\n\n      this._setLatLngs(latlngs);\n    },\n    // @method getLatLngs(): LatLng[]\n    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\n    getLatLngs: function () {\n      return this._latlngs;\n    },\n    // @method setLatLngs(latlngs: LatLng[]): this\n    // Replaces all the points in the polyline with the given array of geographical points.\n    setLatLngs: function (latlngs) {\n      this._setLatLngs(latlngs);\n\n      return this.redraw();\n    },\n    // @method isEmpty(): Boolean\n    // Returns `true` if the Polyline has no LatLngs.\n    isEmpty: function () {\n      return !this._latlngs.length;\n    },\n    // @method closestLayerPoint(p: Point): Point\n    // Returns the point closest to `p` on the Polyline.\n    closestLayerPoint: function (p) {\n      var minDistance = Infinity,\n          minPoint = null,\n          closest = _sqClosestPointOnSegment,\n          p1,\n          p2;\n\n      for (var j = 0, jLen = this._parts.length; j < jLen; j++) {\n        var points = this._parts[j];\n\n        for (var i = 1, len = points.length; i < len; i++) {\n          p1 = points[i - 1];\n          p2 = points[i];\n          var sqDist = closest(p, p1, p2, true);\n\n          if (sqDist < minDistance) {\n            minDistance = sqDist;\n            minPoint = closest(p, p1, p2);\n          }\n        }\n      }\n\n      if (minPoint) {\n        minPoint.distance = Math.sqrt(minDistance);\n      }\n\n      return minPoint;\n    },\n    // @method getCenter(): LatLng\n    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.\n    getCenter: function () {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n\n      var i,\n          halfDist,\n          segDist,\n          dist,\n          p1,\n          p2,\n          ratio,\n          points = this._rings[0],\n          len = points.length;\n\n      if (!len) {\n        return null;\n      } // polyline centroid algorithm; only uses the first ring if there are multiple\n\n\n      for (i = 0, halfDist = 0; i < len - 1; i++) {\n        halfDist += points[i].distanceTo(points[i + 1]) / 2;\n      } // The line is so small in the current view that all points are on the same pixel.\n\n\n      if (halfDist === 0) {\n        return this._map.layerPointToLatLng(points[0]);\n      }\n\n      for (i = 0, dist = 0; i < len - 1; i++) {\n        p1 = points[i];\n        p2 = points[i + 1];\n        segDist = p1.distanceTo(p2);\n        dist += segDist;\n\n        if (dist > halfDist) {\n          ratio = (dist - halfDist) / segDist;\n          return this._map.layerPointToLatLng([p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)]);\n        }\n      }\n    },\n    // @method getBounds(): LatLngBounds\n    // Returns the `LatLngBounds` of the path.\n    getBounds: function () {\n      return this._bounds;\n    },\n    // @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this\n    // Adds a given point to the polyline. By default, adds to the first ring of\n    // the polyline in case of a multi-polyline, but can be overridden by passing\n    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\n    addLatLng: function (latlng, latlngs) {\n      latlngs = latlngs || this._defaultShape();\n      latlng = toLatLng(latlng);\n      latlngs.push(latlng);\n\n      this._bounds.extend(latlng);\n\n      return this.redraw();\n    },\n    _setLatLngs: function (latlngs) {\n      this._bounds = new LatLngBounds();\n      this._latlngs = this._convertLatLngs(latlngs);\n    },\n    _defaultShape: function () {\n      return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];\n    },\n    // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n    _convertLatLngs: function (latlngs) {\n      var result = [],\n          flat = isFlat(latlngs);\n\n      for (var i = 0, len = latlngs.length; i < len; i++) {\n        if (flat) {\n          result[i] = toLatLng(latlngs[i]);\n\n          this._bounds.extend(result[i]);\n        } else {\n          result[i] = this._convertLatLngs(latlngs[i]);\n        }\n      }\n\n      return result;\n    },\n    _project: function () {\n      var pxBounds = new Bounds();\n      this._rings = [];\n\n      this._projectLatlngs(this._latlngs, this._rings, pxBounds);\n\n      if (this._bounds.isValid() && pxBounds.isValid()) {\n        this._rawPxBounds = pxBounds;\n\n        this._updateBounds();\n      }\n    },\n    _updateBounds: function () {\n      var w = this._clickTolerance(),\n          p = new Point(w, w);\n\n      this._pxBounds = new Bounds([this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p)]);\n    },\n    // recursively turns latlngs into a set of rings with projected coordinates\n    _projectLatlngs: function (latlngs, result, projectedBounds) {\n      var flat = latlngs[0] instanceof LatLng,\n          len = latlngs.length,\n          i,\n          ring;\n\n      if (flat) {\n        ring = [];\n\n        for (i = 0; i < len; i++) {\n          ring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n          projectedBounds.extend(ring[i]);\n        }\n\n        result.push(ring);\n      } else {\n        for (i = 0; i < len; i++) {\n          this._projectLatlngs(latlngs[i], result, projectedBounds);\n        }\n      }\n    },\n    // clip polyline by renderer bounds so that we have less to render for performance\n    _clipPoints: function () {\n      var bounds = this._renderer._bounds;\n      this._parts = [];\n\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n\n      var parts = this._parts,\n          i,\n          j,\n          k,\n          len,\n          len2,\n          segment,\n          points;\n\n      for (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n        points = this._rings[i];\n\n        for (j = 0, len2 = points.length; j < len2 - 1; j++) {\n          segment = clipSegment(points[j], points[j + 1], bounds, j, true);\n\n          if (!segment) {\n            continue;\n          }\n\n          parts[k] = parts[k] || [];\n          parts[k].push(segment[0]); // if segment goes out of screen, or it's the last one, it's the end of the line part\n\n          if (segment[1] !== points[j + 1] || j === len2 - 2) {\n            parts[k].push(segment[1]);\n            k++;\n          }\n        }\n      }\n    },\n    // simplify each clipped part of the polyline for performance\n    _simplifyPoints: function () {\n      var parts = this._parts,\n          tolerance = this.options.smoothFactor;\n\n      for (var i = 0, len = parts.length; i < len; i++) {\n        parts[i] = simplify(parts[i], tolerance);\n      }\n    },\n    _update: function () {\n      if (!this._map) {\n        return;\n      }\n\n      this._clipPoints();\n\n      this._simplifyPoints();\n\n      this._updatePath();\n    },\n    _updatePath: function () {\n      this._renderer._updatePoly(this);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p, closed) {\n      var i,\n          j,\n          k,\n          len,\n          len2,\n          part,\n          w = this._clickTolerance();\n\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      } // hit detection for polylines\n\n\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          if (!closed && j === 0) {\n            continue;\n          }\n\n          if (pointToSegmentDistance(p, part[k], part[j]) <= w) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n  }); // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)\n  // Instantiates a polyline object given an array of geographical points and\n  // optionally an options object. You can create a `Polyline` object with\n  // multiple separate lines (`MultiPolyline`) by passing an array of arrays\n  // of geographic points.\n\n  function polyline(latlngs, options) {\n    return new Polyline(latlngs, options);\n  } // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.\n\n\n  Polyline._flat = _flat;\n  /*\n   * @class Polygon\n   * @aka L.Polygon\n   * @inherits Polyline\n   *\n   * A class for drawing polygon overlays on a map. Extends `Polyline`.\n   *\n   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.\n   *\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polygon from an array of LatLng points\n   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];\n   *\n   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polygon\n   * map.fitBounds(polygon.getBounds());\n   * ```\n   *\n   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:\n   *\n   * ```js\n   * var latlngs = [\n   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   * ];\n   * ```\n   *\n   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.\n   *\n   * ```js\n   * var latlngs = [\n   *   [ // first polygon\n   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   *   ],\n   *   [ // second polygon\n   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]\n   *   ]\n   * ];\n   * ```\n   */\n\n  var Polygon = Polyline.extend({\n    options: {\n      fill: true\n    },\n    isEmpty: function () {\n      return !this._latlngs.length || !this._latlngs[0].length;\n    },\n    getCenter: function () {\n      // throws error when not yet added to map as this center calculation requires projected coordinates\n      if (!this._map) {\n        throw new Error('Must add layer to map before using getCenter()');\n      }\n\n      var i,\n          j,\n          p1,\n          p2,\n          f,\n          area,\n          x,\n          y,\n          center,\n          points = this._rings[0],\n          len = points.length;\n\n      if (!len) {\n        return null;\n      } // polygon centroid algorithm; only uses the first ring if there are multiple\n\n\n      area = x = y = 0;\n\n      for (i = 0, j = len - 1; i < len; j = i++) {\n        p1 = points[i];\n        p2 = points[j];\n        f = p1.y * p2.x - p2.y * p1.x;\n        x += (p1.x + p2.x) * f;\n        y += (p1.y + p2.y) * f;\n        area += f * 3;\n      }\n\n      if (area === 0) {\n        // Polygon is so small that all points are on same pixel.\n        center = points[0];\n      } else {\n        center = [x / area, y / area];\n      }\n\n      return this._map.layerPointToLatLng(center);\n    },\n    _convertLatLngs: function (latlngs) {\n      var result = Polyline.prototype._convertLatLngs.call(this, latlngs),\n          len = result.length; // remove last point if it equals first one\n\n\n      if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {\n        result.pop();\n      }\n\n      return result;\n    },\n    _setLatLngs: function (latlngs) {\n      Polyline.prototype._setLatLngs.call(this, latlngs);\n\n      if (isFlat(this._latlngs)) {\n        this._latlngs = [this._latlngs];\n      }\n    },\n    _defaultShape: function () {\n      return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n    },\n    _clipPoints: function () {\n      // polygons need a different clipping algorithm so we redefine that\n      var bounds = this._renderer._bounds,\n          w = this.options.weight,\n          p = new Point(w, w); // increase clip padding by stroke width to avoid stroke on clip edges\n\n      bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));\n      this._parts = [];\n\n      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n        return;\n      }\n\n      if (this.options.noClip) {\n        this._parts = this._rings;\n        return;\n      }\n\n      for (var i = 0, len = this._rings.length, clipped; i < len; i++) {\n        clipped = clipPolygon(this._rings[i], bounds, true);\n\n        if (clipped.length) {\n          this._parts.push(clipped);\n        }\n      }\n    },\n    _updatePath: function () {\n      this._renderer._updatePoly(this, true);\n    },\n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (p) {\n      var inside = false,\n          part,\n          p1,\n          p2,\n          i,\n          j,\n          k,\n          len,\n          len2;\n\n      if (!this._pxBounds || !this._pxBounds.contains(p)) {\n        return false;\n      } // ray casting algorithm for detecting if point is in polygon\n\n\n      for (i = 0, len = this._parts.length; i < len; i++) {\n        part = this._parts[i];\n\n        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n          p1 = part[j];\n          p2 = part[k];\n\n          if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {\n            inside = !inside;\n          }\n        }\n      } // also check if it's on polygon stroke\n\n\n      return inside || Polyline.prototype._containsPoint.call(this, p, true);\n    }\n  }); // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)\n\n  function polygon(latlngs, options) {\n    return new Polygon(latlngs, options);\n  }\n  /*\r\n   * @class GeoJSON\r\n   * @aka L.GeoJSON\r\n   * @inherits FeatureGroup\r\n   *\r\n   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse\r\n   * GeoJSON data and display it on the map. Extends `FeatureGroup`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.geoJSON(data, {\r\n   * \tstyle: function (feature) {\r\n   * \t\treturn {color: feature.properties.color};\r\n   * \t}\r\n   * }).bindPopup(function (layer) {\r\n   * \treturn layer.feature.properties.description;\r\n   * }).addTo(map);\r\n   * ```\r\n   */\n\n\n  var GeoJSON = FeatureGroup.extend({\n    /* @section\r\n     * @aka GeoJSON options\r\n     *\r\n     * @option pointToLayer: Function = *\r\n     * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally\r\n     * called when data is added, passing the GeoJSON point feature and its `LatLng`.\r\n     * The default is to spawn a default `Marker`:\r\n     * ```js\r\n     * function(geoJsonPoint, latlng) {\r\n     * \treturn L.marker(latlng);\r\n     * }\r\n     * ```\r\n     *\r\n     * @option style: Function = *\r\n     * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,\r\n     * called internally when data is added.\r\n     * The default value is to not override any defaults:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn {}\r\n     * }\r\n     * ```\r\n     *\r\n     * @option onEachFeature: Function = *\r\n     * A `Function` that will be called once for each created `Feature`, after it has\r\n     * been created and styled. Useful for attaching events and popups to features.\r\n     * The default is to do nothing with the newly created layers:\r\n     * ```js\r\n     * function (feature, layer) {}\r\n     * ```\r\n     *\r\n     * @option filter: Function = *\r\n     * A `Function` that will be used to decide whether to include a feature or not.\r\n     * The default is to include all features:\r\n     * ```js\r\n     * function (geoJsonFeature) {\r\n     * \treturn true;\r\n     * }\r\n     * ```\r\n     * Note: dynamically changing the `filter` option will have effect only on newly\r\n     * added data. It will _not_ re-evaluate already included features.\r\n     *\r\n     * @option coordsToLatLng: Function = *\r\n     * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.\r\n     * The default is the `coordsToLatLng` static method.\r\n     *\r\n     * @option markersInheritOptions: Boolean = false\r\n     * Whether default Markers for \"Point\" type Features inherit from group options.\r\n     */\n    initialize: function (geojson, options) {\n      setOptions(this, options);\n      this._layers = {};\n\n      if (geojson) {\n        this.addData(geojson);\n      }\n    },\n    // @method addData( <GeoJSON> data ): this\n    // Adds a GeoJSON object to the layer.\n    addData: function (geojson) {\n      var features = isArray(geojson) ? geojson : geojson.features,\n          i,\n          len,\n          feature;\n\n      if (features) {\n        for (i = 0, len = features.length; i < len; i++) {\n          // only add this if geometry or geometries are set and not null\n          feature = features[i];\n\n          if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\n            this.addData(feature);\n          }\n        }\n\n        return this;\n      }\n\n      var options = this.options;\n\n      if (options.filter && !options.filter(geojson)) {\n        return this;\n      }\n\n      var layer = geometryToLayer(geojson, options);\n\n      if (!layer) {\n        return this;\n      }\n\n      layer.feature = asFeature(geojson);\n      layer.defaultOptions = layer.options;\n      this.resetStyle(layer);\n\n      if (options.onEachFeature) {\n        options.onEachFeature(geojson, layer);\n      }\n\n      return this.addLayer(layer);\n    },\n    // @method resetStyle( <Path> layer? ): this\n    // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.\n    // If `layer` is omitted, the style of all features in the current layer is reset.\n    resetStyle: function (layer) {\n      if (layer === undefined) {\n        return this.eachLayer(this.resetStyle, this);\n      } // reset any custom styles\n\n\n      layer.options = extend({}, layer.defaultOptions);\n\n      this._setLayerStyle(layer, this.options.style);\n\n      return this;\n    },\n    // @method setStyle( <Function> style ): this\n    // Changes styles of GeoJSON vector layers with the given style function.\n    setStyle: function (style) {\n      return this.eachLayer(function (layer) {\n        this._setLayerStyle(layer, style);\n      }, this);\n    },\n    _setLayerStyle: function (layer, style) {\n      if (layer.setStyle) {\n        if (typeof style === 'function') {\n          style = style(layer.feature);\n        }\n\n        layer.setStyle(style);\n      }\n    }\n  }); // @section\n  // There are several static functions which can be called without instantiating L.GeoJSON:\n  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer\n  // Creates a `Layer` from a given GeoJSON feature. Can use a custom\n  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)\n  // functions if provided as options.\n\n  function geometryToLayer(geojson, options) {\n    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\n        coords = geometry ? geometry.coordinates : null,\n        layers = [],\n        pointToLayer = options && options.pointToLayer,\n        _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,\n        latlng,\n        latlngs,\n        i,\n        len;\n\n    if (!coords && !geometry) {\n      return null;\n    }\n\n    switch (geometry.type) {\n      case 'Point':\n        latlng = _coordsToLatLng(coords);\n        return _pointToLayer(pointToLayer, geojson, latlng, options);\n\n      case 'MultiPoint':\n        for (i = 0, len = coords.length; i < len; i++) {\n          latlng = _coordsToLatLng(coords[i]);\n          layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));\n        }\n\n        return new FeatureGroup(layers);\n\n      case 'LineString':\n      case 'MultiLineString':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);\n        return new Polyline(latlngs, options);\n\n      case 'Polygon':\n      case 'MultiPolygon':\n        latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);\n        return new Polygon(latlngs, options);\n\n      case 'GeometryCollection':\n        for (i = 0, len = geometry.geometries.length; i < len; i++) {\n          var layer = geometryToLayer({\n            geometry: geometry.geometries[i],\n            type: 'Feature',\n            properties: geojson.properties\n          }, options);\n\n          if (layer) {\n            layers.push(layer);\n          }\n        }\n\n        return new FeatureGroup(layers);\n\n      default:\n        throw new Error('Invalid GeoJSON object.');\n    }\n  }\n\n  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {\n    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);\n  } // @function coordsToLatLng(coords: Array): LatLng\n  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)\n  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.\n\n\n  function coordsToLatLng(coords) {\n    return new LatLng(coords[1], coords[0], coords[2]);\n  } // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array\n  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.\n  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).\n  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.\n\n\n  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {\n    var latlngs = [];\n\n    for (var i = 0, len = coords.length, latlng; i < len; i++) {\n      latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);\n      latlngs.push(latlng);\n    }\n\n    return latlngs;\n  } // @function latLngToCoords(latlng: LatLng, precision?: Number): Array\n  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)\n\n\n  function latLngToCoords(latlng, precision) {\n    precision = typeof precision === 'number' ? precision : 6;\n    return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];\n  } // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array\n  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)\n  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.\n\n\n  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {\n    var coords = [];\n\n    for (var i = 0, len = latlngs.length; i < len; i++) {\n      coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));\n    }\n\n    if (!levelsDeep && closed) {\n      coords.push(coords[0]);\n    }\n\n    return coords;\n  }\n\n  function getFeature(layer, newGeometry) {\n    return layer.feature ? extend({}, layer.feature, {\n      geometry: newGeometry\n    }) : asFeature(newGeometry);\n  } // @function asFeature(geojson: Object): Object\n  // Normalize GeoJSON geometries/features into GeoJSON features.\n\n\n  function asFeature(geojson) {\n    if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {\n      return geojson;\n    }\n\n    return {\n      type: 'Feature',\n      properties: {},\n      geometry: geojson\n    };\n  }\n\n  var PointToGeoJSON = {\n    toGeoJSON: function (precision) {\n      return getFeature(this, {\n        type: 'Point',\n        coordinates: latLngToCoords(this.getLatLng(), precision)\n      });\n    }\n  }; // @namespace Marker\n  // @section Other methods\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).\n\n  Marker.include(PointToGeoJSON); // @namespace CircleMarker\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).\n\n  Circle.include(PointToGeoJSON);\n  CircleMarker.include(PointToGeoJSON); // @namespace Polyline\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).\n\n  Polyline.include({\n    toGeoJSON: function (precision) {\n      var multi = !isFlat(this._latlngs);\n      var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'LineString',\n        coordinates: coords\n      });\n    }\n  }); // @namespace Polygon\n  // @method toGeoJSON(precision?: Number): Object\n  // `precision` is the number of decimal places for coordinates.\n  // The default value is 6 places.\n  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).\n\n  Polygon.include({\n    toGeoJSON: function (precision) {\n      var holes = !isFlat(this._latlngs),\n          multi = holes && !isFlat(this._latlngs[0]);\n      var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);\n\n      if (!holes) {\n        coords = [coords];\n      }\n\n      return getFeature(this, {\n        type: (multi ? 'Multi' : '') + 'Polygon',\n        coordinates: coords\n      });\n    }\n  }); // @namespace LayerGroup\n\n  LayerGroup.include({\n    toMultiPoint: function (precision) {\n      var coords = [];\n      this.eachLayer(function (layer) {\n        coords.push(layer.toGeoJSON(precision).geometry.coordinates);\n      });\n      return getFeature(this, {\n        type: 'MultiPoint',\n        coordinates: coords\n      });\n    },\n    // @method toGeoJSON(precision?: Number): Object\n    // `precision` is the number of decimal places for coordinates.\n    // The default value is 6 places.\n    // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).\n    toGeoJSON: function (precision) {\n      var type = this.feature && this.feature.geometry && this.feature.geometry.type;\n\n      if (type === 'MultiPoint') {\n        return this.toMultiPoint(precision);\n      }\n\n      var isGeometryCollection = type === 'GeometryCollection',\n          jsons = [];\n      this.eachLayer(function (layer) {\n        if (layer.toGeoJSON) {\n          var json = layer.toGeoJSON(precision);\n\n          if (isGeometryCollection) {\n            jsons.push(json.geometry);\n          } else {\n            var feature = asFeature(json); // Squash nested feature collections\n\n            if (feature.type === 'FeatureCollection') {\n              jsons.push.apply(jsons, feature.features);\n            } else {\n              jsons.push(feature);\n            }\n          }\n        }\n      });\n\n      if (isGeometryCollection) {\n        return getFeature(this, {\n          geometries: jsons,\n          type: 'GeometryCollection'\n        });\n      }\n\n      return {\n        type: 'FeatureCollection',\n        features: jsons\n      };\n    }\n  }); // @namespace GeoJSON\n  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)\n  // Creates a GeoJSON layer. Optionally accepts an object in\n  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map\n  // (you can alternatively add it later with `addData` method) and an `options` object.\n\n  function geoJSON(geojson, options) {\n    return new GeoJSON(geojson, options);\n  } // Backward compatibility.\n\n\n  var geoJson = geoJSON;\n  /*\r\n   * @class ImageOverlay\r\n   * @aka L.ImageOverlay\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',\r\n   * \timageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];\r\n   * L.imageOverlay(imageUrl, imageBounds).addTo(map);\r\n   * ```\r\n   */\n\n  var ImageOverlay = Layer.extend({\n    // @section\n    // @aka ImageOverlay options\n    options: {\n      // @option opacity: Number = 1.0\n      // The opacity of the image overlay.\n      opacity: 1,\n      // @option alt: String = ''\n      // Text for the `alt` attribute of the image (useful for accessibility).\n      alt: '',\n      // @option interactive: Boolean = false\n      // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.\n      interactive: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the image.\n      // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false,\n      // @option errorOverlayUrl: String = ''\n      // URL to the overlay image to show in place of the overlay that failed to load.\n      errorOverlayUrl: '',\n      // @option zIndex: Number = 1\n      // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.\n      zIndex: 1,\n      // @option className: String = ''\n      // A custom class name to assign to the image. Empty by default.\n      className: ''\n    },\n    initialize: function (url, bounds, options) {\n      // (String, LatLngBounds, Object)\n      this._url = url;\n      this._bounds = toLatLngBounds(bounds);\n      setOptions(this, options);\n    },\n    onAdd: function () {\n      if (!this._image) {\n        this._initImage();\n\n        if (this.options.opacity < 1) {\n          this._updateOpacity();\n        }\n      }\n\n      if (this.options.interactive) {\n        addClass(this._image, 'leaflet-interactive');\n        this.addInteractiveTarget(this._image);\n      }\n\n      this.getPane().appendChild(this._image);\n\n      this._reset();\n    },\n    onRemove: function () {\n      remove(this._image);\n\n      if (this.options.interactive) {\n        this.removeInteractiveTarget(this._image);\n      }\n    },\n    // @method setOpacity(opacity: Number): this\n    // Sets the opacity of the overlay.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      if (this._image) {\n        this._updateOpacity();\n      }\n\n      return this;\n    },\n    setStyle: function (styleOpts) {\n      if (styleOpts.opacity) {\n        this.setOpacity(styleOpts.opacity);\n      }\n\n      return this;\n    },\n    // @method bringToFront(): this\n    // Brings the layer to the top of all overlays.\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._image);\n      }\n\n      return this;\n    },\n    // @method bringToBack(): this\n    // Brings the layer to the bottom of all overlays.\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._image);\n      }\n\n      return this;\n    },\n    // @method setUrl(url: String): this\n    // Changes the URL of the image.\n    setUrl: function (url) {\n      this._url = url;\n\n      if (this._image) {\n        this._image.src = url;\n      }\n\n      return this;\n    },\n    // @method setBounds(bounds: LatLngBounds): this\n    // Update the bounds that this ImageOverlay covers\n    setBounds: function (bounds) {\n      this._bounds = toLatLngBounds(bounds);\n\n      if (this._map) {\n        this._reset();\n      }\n\n      return this;\n    },\n    getEvents: function () {\n      var events = {\n        zoom: this._reset,\n        viewreset: this._reset\n      };\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n\n      return events;\n    },\n    // @method setZIndex(value: Number): this\n    // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.\n    setZIndex: function (value) {\n      this.options.zIndex = value;\n\n      this._updateZIndex();\n\n      return this;\n    },\n    // @method getBounds(): LatLngBounds\n    // Get the bounds that this ImageOverlay covers\n    getBounds: function () {\n      return this._bounds;\n    },\n    // @method getElement(): HTMLElement\n    // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)\n    // used by this overlay.\n    getElement: function () {\n      return this._image;\n    },\n    _initImage: function () {\n      var wasElementSupplied = this._url.tagName === 'IMG';\n      var img = this._image = wasElementSupplied ? this._url : create$1('img');\n      addClass(img, 'leaflet-image-layer');\n\n      if (this._zoomAnimated) {\n        addClass(img, 'leaflet-zoom-animated');\n      }\n\n      if (this.options.className) {\n        addClass(img, this.options.className);\n      }\n\n      img.onselectstart = falseFn;\n      img.onmousemove = falseFn; // @event load: Event\n      // Fired when the ImageOverlay layer has loaded its image\n\n      img.onload = bind(this.fire, this, 'load');\n      img.onerror = bind(this._overlayOnError, this, 'error');\n\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n\n      if (this.options.zIndex) {\n        this._updateZIndex();\n      }\n\n      if (wasElementSupplied) {\n        this._url = img.src;\n        return;\n      }\n\n      img.src = this._url;\n      img.alt = this.options.alt;\n    },\n    _animateZoom: function (e) {\n      var scale = this._map.getZoomScale(e.zoom),\n          offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;\n\n      setTransform(this._image, offset, scale);\n    },\n    _reset: function () {\n      var image = this._image,\n          bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),\n          size = bounds.getSize();\n      setPosition(image, bounds.min);\n      image.style.width = size.x + 'px';\n      image.style.height = size.y + 'px';\n    },\n    _updateOpacity: function () {\n      setOpacity(this._image, this.options.opacity);\n    },\n    _updateZIndex: function () {\n      if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._image.style.zIndex = this.options.zIndex;\n      }\n    },\n    _overlayOnError: function () {\n      // @event error: Event\n      // Fired when the ImageOverlay layer fails to load its image\n      this.fire('error');\n      var errorUrl = this.options.errorOverlayUrl;\n\n      if (errorUrl && this._url !== errorUrl) {\n        this._url = errorUrl;\n        this._image.src = errorUrl;\n      }\n    }\n  }); // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)\n  // Instantiates an image overlay object given the URL of the image and the\n  // geographical bounds it is tied to.\n\n  var imageOverlay = function (url, bounds, options) {\n    return new ImageOverlay(url, bounds, options);\n  };\n  /*\r\n   * @class VideoOverlay\r\n   * @aka L.VideoOverlay\r\n   * @inherits ImageOverlay\r\n   *\r\n   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.\r\n   *\r\n   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)\r\n   * HTML5 element.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',\r\n   * \tvideoBounds = [[ 32, -130], [ 13, -100]];\r\n   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);\r\n   * ```\r\n   */\n\n\n  var VideoOverlay = ImageOverlay.extend({\n    // @section\n    // @aka VideoOverlay options\n    options: {\n      // @option autoplay: Boolean = true\n      // Whether the video starts playing automatically when loaded.\n      autoplay: true,\n      // @option loop: Boolean = true\n      // Whether the video will loop back to the beginning when played.\n      loop: true,\n      // @option keepAspectRatio: Boolean = true\n      // Whether the video will save aspect ratio after the projection.\n      // Relevant for supported browsers. Browser compatibility- https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit\n      keepAspectRatio: true\n    },\n    _initImage: function () {\n      var wasElementSupplied = this._url.tagName === 'VIDEO';\n      var vid = this._image = wasElementSupplied ? this._url : create$1('video');\n      addClass(vid, 'leaflet-image-layer');\n\n      if (this._zoomAnimated) {\n        addClass(vid, 'leaflet-zoom-animated');\n      }\n\n      if (this.options.className) {\n        addClass(vid, this.options.className);\n      }\n\n      vid.onselectstart = falseFn;\n      vid.onmousemove = falseFn; // @event load: Event\n      // Fired when the video has finished loading the first frame\n\n      vid.onloadeddata = bind(this.fire, this, 'load');\n\n      if (wasElementSupplied) {\n        var sourceElements = vid.getElementsByTagName('source');\n        var sources = [];\n\n        for (var j = 0; j < sourceElements.length; j++) {\n          sources.push(sourceElements[j].src);\n        }\n\n        this._url = sourceElements.length > 0 ? sources : [vid.src];\n        return;\n      }\n\n      if (!isArray(this._url)) {\n        this._url = [this._url];\n      }\n\n      if (!this.options.keepAspectRatio && vid.style.hasOwnProperty('objectFit')) {\n        vid.style['objectFit'] = 'fill';\n      }\n\n      vid.autoplay = !!this.options.autoplay;\n      vid.loop = !!this.options.loop;\n\n      for (var i = 0; i < this._url.length; i++) {\n        var source = create$1('source');\n        source.src = this._url[i];\n        vid.appendChild(source);\n      }\n    } // @method getElement(): HTMLVideoElement\n    // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)\n    // used by this overlay.\n\n  }); // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)\n  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the\n  // geographical bounds it is tied to.\n\n  function videoOverlay(video, bounds, options) {\n    return new VideoOverlay(video, bounds, options);\n  }\n  /*\n   * @class SVGOverlay\n   * @aka L.SVGOverlay\n   * @inherits ImageOverlay\n   *\n   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.\n   *\n   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.\n   *\n   * @example\n   *\n   * ```js\n   * var svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n   * svgElement.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n   * svgElement.setAttribute('viewBox', \"0 0 200 200\");\n   * svgElement.innerHTML = '<rect width=\"200\" height=\"200\"/><rect x=\"75\" y=\"23\" width=\"50\" height=\"50\" style=\"fill:red\"/><rect x=\"75\" y=\"123\" width=\"50\" height=\"50\" style=\"fill:#0013ff\"/>';\n   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];\n   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);\n   * ```\n   */\n\n\n  var SVGOverlay = ImageOverlay.extend({\n    _initImage: function () {\n      var el = this._image = this._url;\n      addClass(el, 'leaflet-image-layer');\n\n      if (this._zoomAnimated) {\n        addClass(el, 'leaflet-zoom-animated');\n      }\n\n      if (this.options.className) {\n        addClass(el, this.options.className);\n      }\n\n      el.onselectstart = falseFn;\n      el.onmousemove = falseFn;\n    } // @method getElement(): SVGElement\n    // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)\n    // used by this overlay.\n\n  }); // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)\n  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.\n  // A viewBox attribute is required on the SVG element to zoom in and out properly.\n\n  function svgOverlay(el, bounds, options) {\n    return new SVGOverlay(el, bounds, options);\n  }\n  /*\r\n   * @class DivOverlay\r\n   * @inherits Layer\r\n   * @aka L.DivOverlay\r\n   * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.\r\n   */\n  // @namespace DivOverlay\n\n\n  var DivOverlay = Layer.extend({\n    // @section\n    // @aka DivOverlay options\n    options: {\n      // @option offset: Point = Point(0, 7)\n      // The offset of the popup position. Useful to control the anchor\n      // of the popup when opening it on some overlays.\n      offset: [0, 7],\n      // @option className: String = ''\n      // A custom CSS class name to assign to the popup.\n      className: '',\n      // @option pane: String = 'popupPane'\n      // `Map pane` where the popup will be added.\n      pane: 'popupPane'\n    },\n    initialize: function (options, source) {\n      setOptions(this, options);\n      this._source = source;\n    },\n    onAdd: function (map) {\n      this._zoomAnimated = map._zoomAnimated;\n\n      if (!this._container) {\n        this._initLayout();\n      }\n\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 0);\n      }\n\n      clearTimeout(this._removeTimeout);\n      this.getPane().appendChild(this._container);\n      this.update();\n\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 1);\n      }\n\n      this.bringToFront();\n    },\n    onRemove: function (map) {\n      if (map._fadeAnimated) {\n        setOpacity(this._container, 0);\n        this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);\n      } else {\n        remove(this._container);\n      }\n    },\n    // @namespace Popup\n    // @method getLatLng: LatLng\n    // Returns the geographical point of popup.\n    getLatLng: function () {\n      return this._latlng;\n    },\n    // @method setLatLng(latlng: LatLng): this\n    // Sets the geographical point where the popup will open.\n    setLatLng: function (latlng) {\n      this._latlng = toLatLng(latlng);\n\n      if (this._map) {\n        this._updatePosition();\n\n        this._adjustPan();\n      }\n\n      return this;\n    },\n    // @method getContent: String|HTMLElement\n    // Returns the content of the popup.\n    getContent: function () {\n      return this._content;\n    },\n    // @method setContent(htmlContent: String|HTMLElement|Function): this\n    // Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.\n    setContent: function (content) {\n      this._content = content;\n      this.update();\n      return this;\n    },\n    // @method getElement: String|HTMLElement\n    // Alias for [getContent()](#popup-getcontent)\n    getElement: function () {\n      return this._container;\n    },\n    // @method update: null\n    // Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.\n    update: function () {\n      if (!this._map) {\n        return;\n      }\n\n      this._container.style.visibility = 'hidden';\n\n      this._updateContent();\n\n      this._updateLayout();\n\n      this._updatePosition();\n\n      this._container.style.visibility = '';\n\n      this._adjustPan();\n    },\n    getEvents: function () {\n      var events = {\n        zoom: this._updatePosition,\n        viewreset: this._updatePosition\n      };\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n\n      return events;\n    },\n    // @method isOpen: Boolean\n    // Returns `true` when the popup is visible on the map.\n    isOpen: function () {\n      return !!this._map && this._map.hasLayer(this);\n    },\n    // @method bringToFront: this\n    // Brings this popup in front of other popups (in the same map pane).\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._container);\n      }\n\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings this popup to the back of other popups (in the same map pane).\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._container);\n      }\n\n      return this;\n    },\n    _prepareOpen: function (parent, layer, latlng) {\n      if (!(layer instanceof Layer)) {\n        latlng = layer;\n        layer = parent;\n      }\n\n      if (layer instanceof FeatureGroup) {\n        for (var id in parent._layers) {\n          layer = parent._layers[id];\n          break;\n        }\n      }\n\n      if (!latlng) {\n        if (layer.getCenter) {\n          latlng = layer.getCenter();\n        } else if (layer.getLatLng) {\n          latlng = layer.getLatLng();\n        } else {\n          throw new Error('Unable to get source layer LatLng.');\n        }\n      } // set overlay source to this layer\n\n\n      this._source = layer; // update the overlay (content, layout, ect...)\n\n      this.update();\n      return latlng;\n    },\n    _updateContent: function () {\n      if (!this._content) {\n        return;\n      }\n\n      var node = this._contentNode;\n      var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;\n\n      if (typeof content === 'string') {\n        node.innerHTML = content;\n      } else {\n        while (node.hasChildNodes()) {\n          node.removeChild(node.firstChild);\n        }\n\n        node.appendChild(content);\n      }\n\n      this.fire('contentupdate');\n    },\n    _updatePosition: function () {\n      if (!this._map) {\n        return;\n      }\n\n      var pos = this._map.latLngToLayerPoint(this._latlng),\n          offset = toPoint(this.options.offset),\n          anchor = this._getAnchor();\n\n      if (this._zoomAnimated) {\n        setPosition(this._container, pos.add(anchor));\n      } else {\n        offset = offset.add(pos).add(anchor);\n      }\n\n      var bottom = this._containerBottom = -offset.y,\n          left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x; // bottom position the popup in case the height of the popup changes (images loading etc)\n\n      this._container.style.bottom = bottom + 'px';\n      this._container.style.left = left + 'px';\n    },\n    _getAnchor: function () {\n      return [0, 0];\n    }\n  });\n  /*\r\n   * @class Popup\r\n   * @inherits DivOverlay\r\n   * @aka L.Popup\r\n   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to\r\n   * open popups while making sure that only one popup is open at one time\r\n   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.\r\n   *\r\n   * @example\r\n   *\r\n   * If you want to just bind a popup to marker click and then open it, it's really easy:\r\n   *\r\n   * ```js\r\n   * marker.bindPopup(popupContent).openPopup();\r\n   * ```\r\n   * Path overlays like polylines also have a `bindPopup` method.\r\n   * Here's a more complicated way to open a popup on a map:\r\n   *\r\n   * ```js\r\n   * var popup = L.popup()\r\n   * \t.setLatLng(latlng)\r\n   * \t.setContent('<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   */\n  // @namespace Popup\n\n  var Popup = DivOverlay.extend({\n    // @section\n    // @aka Popup options\n    options: {\n      // @option maxWidth: Number = 300\n      // Max width of the popup, in pixels.\n      maxWidth: 300,\n      // @option minWidth: Number = 50\n      // Min width of the popup, in pixels.\n      minWidth: 50,\n      // @option maxHeight: Number = null\n      // If set, creates a scrollable container of the given height\n      // inside a popup if its content exceeds it.\n      maxHeight: null,\n      // @option autoPan: Boolean = true\n      // Set it to `false` if you don't want the map to do panning animation\n      // to fit the opened popup.\n      autoPan: true,\n      // @option autoPanPaddingTopLeft: Point = null\n      // The margin between the popup and the top left corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingTopLeft: null,\n      // @option autoPanPaddingBottomRight: Point = null\n      // The margin between the popup and the bottom right corner of the map\n      // view after autopanning was performed.\n      autoPanPaddingBottomRight: null,\n      // @option autoPanPadding: Point = Point(5, 5)\n      // Equivalent of setting both top left and bottom right autopan padding to the same value.\n      autoPanPadding: [5, 5],\n      // @option keepInView: Boolean = false\n      // Set it to `true` if you want to prevent users from panning the popup\n      // off of the screen while it is open.\n      keepInView: false,\n      // @option closeButton: Boolean = true\n      // Controls the presence of a close button in the popup.\n      closeButton: true,\n      // @option autoClose: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the popup closing when another popup is opened.\n      autoClose: true,\n      // @option closeOnEscapeKey: Boolean = true\n      // Set it to `false` if you want to override the default behavior of\n      // the ESC key for closing of the popup.\n      closeOnEscapeKey: true,\n      // @option closeOnClick: Boolean = *\n      // Set it if you want to override the default behavior of the popup closing when user clicks\n      // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.\n      // @option className: String = ''\n      // A custom CSS class name to assign to the popup.\n      className: ''\n    },\n    // @namespace Popup\n    // @method openOn(map: Map): this\n    // Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.\n    openOn: function (map) {\n      map.openPopup(this);\n      return this;\n    },\n    onAdd: function (map) {\n      DivOverlay.prototype.onAdd.call(this, map); // @namespace Map\n      // @section Popup events\n      // @event popupopen: PopupEvent\n      // Fired when a popup is opened in the map\n\n      map.fire('popupopen', {\n        popup: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupopen: PopupEvent\n        // Fired when a popup bound to this layer is opened\n        this._source.fire('popupopen', {\n          popup: this\n        }, true); // For non-path layers, we toggle the popup when clicking\n        // again the layer, so prevent the map to reopen it.\n\n\n        if (!(this._source instanceof Path)) {\n          this._source.on('preclick', stopPropagation);\n        }\n      }\n    },\n    onRemove: function (map) {\n      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map\n      // @section Popup events\n      // @event popupclose: PopupEvent\n      // Fired when a popup in the map is closed\n\n      map.fire('popupclose', {\n        popup: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Popup events\n        // @event popupclose: PopupEvent\n        // Fired when a popup bound to this layer is closed\n        this._source.fire('popupclose', {\n          popup: this\n        }, true);\n\n        if (!(this._source instanceof Path)) {\n          this._source.off('preclick', stopPropagation);\n        }\n      }\n    },\n    getEvents: function () {\n      var events = DivOverlay.prototype.getEvents.call(this);\n\n      if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\n        events.preclick = this._close;\n      }\n\n      if (this.options.keepInView) {\n        events.moveend = this._adjustPan;\n      }\n\n      return events;\n    },\n    _close: function () {\n      if (this._map) {\n        this._map.closePopup(this);\n      }\n    },\n    _initLayout: function () {\n      var prefix = 'leaflet-popup',\n          container = this._container = create$1('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');\n      var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);\n      this._contentNode = create$1('div', prefix + '-content', wrapper);\n      disableClickPropagation(wrapper);\n      disableScrollPropagation(this._contentNode);\n      on(wrapper, 'contextmenu', stopPropagation);\n      this._tipContainer = create$1('div', prefix + '-tip-container', container);\n      this._tip = create$1('div', prefix + '-tip', this._tipContainer);\n\n      if (this.options.closeButton) {\n        var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);\n        closeButton.href = '#close';\n        closeButton.innerHTML = '&#215;';\n        on(closeButton, 'click', this._onCloseButtonClick, this);\n      }\n    },\n    _updateLayout: function () {\n      var container = this._contentNode,\n          style = container.style;\n      style.width = '';\n      style.whiteSpace = 'nowrap';\n      var width = container.offsetWidth;\n      width = Math.min(width, this.options.maxWidth);\n      width = Math.max(width, this.options.minWidth);\n      style.width = width + 1 + 'px';\n      style.whiteSpace = '';\n      style.height = '';\n      var height = container.offsetHeight,\n          maxHeight = this.options.maxHeight,\n          scrolledClass = 'leaflet-popup-scrolled';\n\n      if (maxHeight && height > maxHeight) {\n        style.height = maxHeight + 'px';\n        addClass(container, scrolledClass);\n      } else {\n        removeClass(container, scrolledClass);\n      }\n\n      this._containerWidth = this._container.offsetWidth;\n    },\n    _animateZoom: function (e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),\n          anchor = this._getAnchor();\n\n      setPosition(this._container, pos.add(anchor));\n    },\n    _adjustPan: function () {\n      if (!this.options.autoPan) {\n        return;\n      }\n\n      if (this._map._panAnim) {\n        this._map._panAnim.stop();\n      }\n\n      var map = this._map,\n          marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,\n          containerHeight = this._container.offsetHeight + marginBottom,\n          containerWidth = this._containerWidth,\n          layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);\n\n      layerPos._add(getPosition(this._container));\n\n      var containerPos = map.layerPointToContainerPoint(layerPos),\n          padding = toPoint(this.options.autoPanPadding),\n          paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),\n          paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),\n          size = map.getSize(),\n          dx = 0,\n          dy = 0;\n\n      if (containerPos.x + containerWidth + paddingBR.x > size.x) {\n        // right\n        dx = containerPos.x + containerWidth - size.x + paddingBR.x;\n      }\n\n      if (containerPos.x - dx - paddingTL.x < 0) {\n        // left\n        dx = containerPos.x - paddingTL.x;\n      }\n\n      if (containerPos.y + containerHeight + paddingBR.y > size.y) {\n        // bottom\n        dy = containerPos.y + containerHeight - size.y + paddingBR.y;\n      }\n\n      if (containerPos.y - dy - paddingTL.y < 0) {\n        // top\n        dy = containerPos.y - paddingTL.y;\n      } // @namespace Map\n      // @section Popup events\n      // @event autopanstart: Event\n      // Fired when the map starts autopanning when opening a popup.\n\n\n      if (dx || dy) {\n        map.fire('autopanstart').panBy([dx, dy]);\n      }\n    },\n    _onCloseButtonClick: function (e) {\n      this._close();\n\n      stop(e);\n    },\n    _getAnchor: function () {\n      // Where should we anchor the popup on the source layer?\n      return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);\n    }\n  }); // @namespace Popup\n  // @factory L.popup(options?: Popup options, source?: Layer)\n  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.\n\n  var popup = function (options, source) {\n    return new Popup(options, source);\n  };\n  /* @namespace Map\r\n   * @section Interaction Options\r\n   * @option closePopupOnClick: Boolean = true\r\n   * Set it to `false` if you don't want popups to close when user clicks the map.\r\n   */\n\n\n  Map.mergeOptions({\n    closePopupOnClick: true\n  }); // @namespace Map\n  // @section Methods for Layers and Controls\n\n  Map.include({\n    // @method openPopup(popup: Popup): this\n    // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).\n    // @alternative\n    // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this\n    // Creates a popup with the specified content and options and opens it in the given point on a map.\n    openPopup: function (popup, latlng, options) {\n      if (!(popup instanceof Popup)) {\n        popup = new Popup(options).setContent(popup);\n      }\n\n      if (latlng) {\n        popup.setLatLng(latlng);\n      }\n\n      if (this.hasLayer(popup)) {\n        return this;\n      }\n\n      if (this._popup && this._popup.options.autoClose) {\n        this.closePopup();\n      }\n\n      this._popup = popup;\n      return this.addLayer(popup);\n    },\n    // @method closePopup(popup?: Popup): this\n    // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).\n    closePopup: function (popup) {\n      if (!popup || popup === this._popup) {\n        popup = this._popup;\n        this._popup = null;\n      }\n\n      if (popup) {\n        this.removeLayer(popup);\n      }\n\n      return this;\n    }\n  });\n  /*\r\n   * @namespace Layer\r\n   * @section Popup methods example\r\n   *\r\n   * All layers share a set of methods convenient for binding popups to it.\r\n   *\r\n   * ```js\r\n   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);\r\n   * layer.openPopup();\r\n   * layer.closePopup();\r\n   * ```\r\n   *\r\n   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.\r\n   */\n  // @section Popup methods\n\n  Layer.include({\n    // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this\n    // Binds a popup to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindPopup: function (content, options) {\n      if (content instanceof Popup) {\n        setOptions(content, options);\n        this._popup = content;\n        content._source = this;\n      } else {\n        if (!this._popup || options) {\n          this._popup = new Popup(options, this);\n        }\n\n        this._popup.setContent(content);\n      }\n\n      if (!this._popupHandlersAdded) {\n        this.on({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = true;\n      }\n\n      return this;\n    },\n    // @method unbindPopup(): this\n    // Removes the popup previously bound with `bindPopup`.\n    unbindPopup: function () {\n      if (this._popup) {\n        this.off({\n          click: this._openPopup,\n          keypress: this._onKeyPress,\n          remove: this.closePopup,\n          move: this._movePopup\n        });\n        this._popupHandlersAdded = false;\n        this._popup = null;\n      }\n\n      return this;\n    },\n    // @method openPopup(latlng?: LatLng): this\n    // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.\n    openPopup: function (layer, latlng) {\n      if (this._popup && this._map) {\n        latlng = this._popup._prepareOpen(this, layer, latlng); // open the popup on the map\n\n        this._map.openPopup(this._popup, latlng);\n      }\n\n      return this;\n    },\n    // @method closePopup(): this\n    // Closes the popup bound to this layer if it is open.\n    closePopup: function () {\n      if (this._popup) {\n        this._popup._close();\n      }\n\n      return this;\n    },\n    // @method togglePopup(): this\n    // Opens or closes the popup bound to this layer depending on its current state.\n    togglePopup: function (target) {\n      if (this._popup) {\n        if (this._popup._map) {\n          this.closePopup();\n        } else {\n          this.openPopup(target);\n        }\n      }\n\n      return this;\n    },\n    // @method isPopupOpen(): boolean\n    // Returns `true` if the popup bound to this layer is currently open.\n    isPopupOpen: function () {\n      return this._popup ? this._popup.isOpen() : false;\n    },\n    // @method setPopupContent(content: String|HTMLElement|Popup): this\n    // Sets the content of the popup bound to this layer.\n    setPopupContent: function (content) {\n      if (this._popup) {\n        this._popup.setContent(content);\n      }\n\n      return this;\n    },\n    // @method getPopup(): Popup\n    // Returns the popup bound to this layer.\n    getPopup: function () {\n      return this._popup;\n    },\n    _openPopup: function (e) {\n      var layer = e.layer || e.target;\n\n      if (!this._popup) {\n        return;\n      }\n\n      if (!this._map) {\n        return;\n      } // prevent map click\n\n\n      stop(e); // if this inherits from Path its a vector and we can just\n      // open the popup at the new location\n\n      if (layer instanceof Path) {\n        this.openPopup(e.layer || e.target, e.latlng);\n        return;\n      } // otherwise treat it like a marker and figure out\n      // if we should toggle it open/closed\n\n\n      if (this._map.hasLayer(this._popup) && this._popup._source === layer) {\n        this.closePopup();\n      } else {\n        this.openPopup(layer, e.latlng);\n      }\n    },\n    _movePopup: function (e) {\n      this._popup.setLatLng(e.latlng);\n    },\n    _onKeyPress: function (e) {\n      if (e.originalEvent.keyCode === 13) {\n        this._openPopup(e);\n      }\n    }\n  });\n  /*\n   * @class Tooltip\n   * @inherits DivOverlay\n   * @aka L.Tooltip\n   * Used to display small texts on top of map layers.\n   *\n   * @example\n   *\n   * ```js\n   * marker.bindTooltip(\"my tooltip text\").openTooltip();\n   * ```\n   * Note about tooltip offset. Leaflet takes two options in consideration\n   * for computing tooltip offsetting:\n   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.\n   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to\n   *   move it to the bottom. Negatives will move to the left and top.\n   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You\n   *   should adapt this value if you use a custom icon.\n   */\n  // @namespace Tooltip\n\n  var Tooltip = DivOverlay.extend({\n    // @section\n    // @aka Tooltip options\n    options: {\n      // @option pane: String = 'tooltipPane'\n      // `Map pane` where the tooltip will be added.\n      pane: 'tooltipPane',\n      // @option offset: Point = Point(0, 0)\n      // Optional offset of the tooltip position.\n      offset: [0, 0],\n      // @option direction: String = 'auto'\n      // Direction where to open the tooltip. Possible values are: `right`, `left`,\n      // `top`, `bottom`, `center`, `auto`.\n      // `auto` will dynamically switch between `right` and `left` according to the tooltip\n      // position on the map.\n      direction: 'auto',\n      // @option permanent: Boolean = false\n      // Whether to open the tooltip permanently or only on mouseover.\n      permanent: false,\n      // @option sticky: Boolean = false\n      // If true, the tooltip will follow the mouse instead of being fixed at the feature center.\n      sticky: false,\n      // @option interactive: Boolean = false\n      // If true, the tooltip will listen to the feature events.\n      interactive: false,\n      // @option opacity: Number = 0.9\n      // Tooltip container opacity.\n      opacity: 0.9\n    },\n    onAdd: function (map) {\n      DivOverlay.prototype.onAdd.call(this, map);\n      this.setOpacity(this.options.opacity); // @namespace Map\n      // @section Tooltip events\n      // @event tooltipopen: TooltipEvent\n      // Fired when a tooltip is opened in the map.\n\n      map.fire('tooltipopen', {\n        tooltip: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipopen: TooltipEvent\n        // Fired when a tooltip bound to this layer is opened.\n        this._source.fire('tooltipopen', {\n          tooltip: this\n        }, true);\n      }\n    },\n    onRemove: function (map) {\n      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map\n      // @section Tooltip events\n      // @event tooltipclose: TooltipEvent\n      // Fired when a tooltip in the map is closed.\n\n      map.fire('tooltipclose', {\n        tooltip: this\n      });\n\n      if (this._source) {\n        // @namespace Layer\n        // @section Tooltip events\n        // @event tooltipclose: TooltipEvent\n        // Fired when a tooltip bound to this layer is closed.\n        this._source.fire('tooltipclose', {\n          tooltip: this\n        }, true);\n      }\n    },\n    getEvents: function () {\n      var events = DivOverlay.prototype.getEvents.call(this);\n\n      if (touch && !this.options.permanent) {\n        events.preclick = this._close;\n      }\n\n      return events;\n    },\n    _close: function () {\n      if (this._map) {\n        this._map.closeTooltip(this);\n      }\n    },\n    _initLayout: function () {\n      var prefix = 'leaflet-tooltip',\n          className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n      this._contentNode = this._container = create$1('div', className);\n    },\n    _updateLayout: function () {},\n    _adjustPan: function () {},\n    _setPosition: function (pos) {\n      var map = this._map,\n          container = this._container,\n          centerPoint = map.latLngToContainerPoint(map.getCenter()),\n          tooltipPoint = map.layerPointToContainerPoint(pos),\n          direction = this.options.direction,\n          tooltipWidth = container.offsetWidth,\n          tooltipHeight = container.offsetHeight,\n          offset = toPoint(this.options.offset),\n          anchor = this._getAnchor();\n\n      if (direction === 'top') {\n        pos = pos.add(toPoint(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));\n      } else if (direction === 'bottom') {\n        pos = pos.subtract(toPoint(tooltipWidth / 2 - offset.x, -offset.y, true));\n      } else if (direction === 'center') {\n        pos = pos.subtract(toPoint(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));\n      } else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {\n        direction = 'right';\n        pos = pos.add(toPoint(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));\n      } else {\n        direction = 'left';\n        pos = pos.subtract(toPoint(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));\n      }\n\n      removeClass(container, 'leaflet-tooltip-right');\n      removeClass(container, 'leaflet-tooltip-left');\n      removeClass(container, 'leaflet-tooltip-top');\n      removeClass(container, 'leaflet-tooltip-bottom');\n      addClass(container, 'leaflet-tooltip-' + direction);\n      setPosition(container, pos);\n    },\n    _updatePosition: function () {\n      var pos = this._map.latLngToLayerPoint(this._latlng);\n\n      this._setPosition(pos);\n    },\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      if (this._container) {\n        setOpacity(this._container, opacity);\n      }\n    },\n    _animateZoom: function (e) {\n      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n\n      this._setPosition(pos);\n    },\n    _getAnchor: function () {\n      // Where should we anchor the tooltip on the source layer?\n      return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);\n    }\n  }); // @namespace Tooltip\n  // @factory L.tooltip(options?: Tooltip options, source?: Layer)\n  // Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.\n\n  var tooltip = function (options, source) {\n    return new Tooltip(options, source);\n  }; // @namespace Map\n  // @section Methods for Layers and Controls\n\n\n  Map.include({\n    // @method openTooltip(tooltip: Tooltip): this\n    // Opens the specified tooltip.\n    // @alternative\n    // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this\n    // Creates a tooltip with the specified content and options and open it.\n    openTooltip: function (tooltip, latlng, options) {\n      if (!(tooltip instanceof Tooltip)) {\n        tooltip = new Tooltip(options).setContent(tooltip);\n      }\n\n      if (latlng) {\n        tooltip.setLatLng(latlng);\n      }\n\n      if (this.hasLayer(tooltip)) {\n        return this;\n      }\n\n      return this.addLayer(tooltip);\n    },\n    // @method closeTooltip(tooltip?: Tooltip): this\n    // Closes the tooltip given as parameter.\n    closeTooltip: function (tooltip) {\n      if (tooltip) {\n        this.removeLayer(tooltip);\n      }\n\n      return this;\n    }\n  });\n  /*\n   * @namespace Layer\n   * @section Tooltip methods example\n   *\n   * All layers share a set of methods convenient for binding tooltips to it.\n   *\n   * ```js\n   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);\n   * layer.openTooltip();\n   * layer.closeTooltip();\n   * ```\n   */\n  // @section Tooltip methods\n\n  Layer.include({\n    // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this\n    // Binds a tooltip to the layer with the passed `content` and sets up the\n    // necessary event listeners. If a `Function` is passed it will receive\n    // the layer as the first argument and should return a `String` or `HTMLElement`.\n    bindTooltip: function (content, options) {\n      if (content instanceof Tooltip) {\n        setOptions(content, options);\n        this._tooltip = content;\n        content._source = this;\n      } else {\n        if (!this._tooltip || options) {\n          this._tooltip = new Tooltip(options, this);\n        }\n\n        this._tooltip.setContent(content);\n      }\n\n      this._initTooltipInteractions();\n\n      if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {\n        this.openTooltip();\n      }\n\n      return this;\n    },\n    // @method unbindTooltip(): this\n    // Removes the tooltip previously bound with `bindTooltip`.\n    unbindTooltip: function () {\n      if (this._tooltip) {\n        this._initTooltipInteractions(true);\n\n        this.closeTooltip();\n        this._tooltip = null;\n      }\n\n      return this;\n    },\n    _initTooltipInteractions: function (remove$$1) {\n      if (!remove$$1 && this._tooltipHandlersAdded) {\n        return;\n      }\n\n      var onOff = remove$$1 ? 'off' : 'on',\n          events = {\n        remove: this.closeTooltip,\n        move: this._moveTooltip\n      };\n\n      if (!this._tooltip.options.permanent) {\n        events.mouseover = this._openTooltip;\n        events.mouseout = this.closeTooltip;\n\n        if (this._tooltip.options.sticky) {\n          events.mousemove = this._moveTooltip;\n        }\n\n        if (touch) {\n          events.click = this._openTooltip;\n        }\n      } else {\n        events.add = this._openTooltip;\n      }\n\n      this[onOff](events);\n      this._tooltipHandlersAdded = !remove$$1;\n    },\n    // @method openTooltip(latlng?: LatLng): this\n    // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.\n    openTooltip: function (layer, latlng) {\n      if (this._tooltip && this._map) {\n        latlng = this._tooltip._prepareOpen(this, layer, latlng); // open the tooltip on the map\n\n        this._map.openTooltip(this._tooltip, latlng); // Tooltip container may not be defined if not permanent and never\n        // opened.\n\n\n        if (this._tooltip.options.interactive && this._tooltip._container) {\n          addClass(this._tooltip._container, 'leaflet-clickable');\n          this.addInteractiveTarget(this._tooltip._container);\n        }\n      }\n\n      return this;\n    },\n    // @method closeTooltip(): this\n    // Closes the tooltip bound to this layer if it is open.\n    closeTooltip: function () {\n      if (this._tooltip) {\n        this._tooltip._close();\n\n        if (this._tooltip.options.interactive && this._tooltip._container) {\n          removeClass(this._tooltip._container, 'leaflet-clickable');\n          this.removeInteractiveTarget(this._tooltip._container);\n        }\n      }\n\n      return this;\n    },\n    // @method toggleTooltip(): this\n    // Opens or closes the tooltip bound to this layer depending on its current state.\n    toggleTooltip: function (target) {\n      if (this._tooltip) {\n        if (this._tooltip._map) {\n          this.closeTooltip();\n        } else {\n          this.openTooltip(target);\n        }\n      }\n\n      return this;\n    },\n    // @method isTooltipOpen(): boolean\n    // Returns `true` if the tooltip bound to this layer is currently open.\n    isTooltipOpen: function () {\n      return this._tooltip.isOpen();\n    },\n    // @method setTooltipContent(content: String|HTMLElement|Tooltip): this\n    // Sets the content of the tooltip bound to this layer.\n    setTooltipContent: function (content) {\n      if (this._tooltip) {\n        this._tooltip.setContent(content);\n      }\n\n      return this;\n    },\n    // @method getTooltip(): Tooltip\n    // Returns the tooltip bound to this layer.\n    getTooltip: function () {\n      return this._tooltip;\n    },\n    _openTooltip: function (e) {\n      var layer = e.layer || e.target;\n\n      if (!this._tooltip || !this._map) {\n        return;\n      }\n\n      this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);\n    },\n    _moveTooltip: function (e) {\n      var latlng = e.latlng,\n          containerPoint,\n          layerPoint;\n\n      if (this._tooltip.options.sticky && e.originalEvent) {\n        containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);\n        layerPoint = this._map.containerPointToLayerPoint(containerPoint);\n        latlng = this._map.layerPointToLatLng(layerPoint);\n      }\n\n      this._tooltip.setLatLng(latlng);\n    }\n  });\n  /*\n   * @class DivIcon\n   * @aka L.DivIcon\n   * @inherits Icon\n   *\n   * Represents a lightweight icon for markers that uses a simple `<div>`\n   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.\n   *\n   * @example\n   * ```js\n   * var myIcon = L.divIcon({className: 'my-div-icon'});\n   * // you can set .my-div-icon styles in CSS\n   *\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\n   * ```\n   *\n   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.\n   */\n\n  var DivIcon = Icon.extend({\n    options: {\n      // @section\n      // @aka DivIcon options\n      iconSize: [12, 12],\n      // also can be set through CSS\n      // iconAnchor: (Point),\n      // popupAnchor: (Point),\n      // @option html: String|HTMLElement = ''\n      // Custom HTML code to put inside the div element, empty by default. Alternatively,\n      // an instance of `HTMLElement`.\n      html: false,\n      // @option bgPos: Point = [0, 0]\n      // Optional relative position of the background, in pixels\n      bgPos: null,\n      className: 'leaflet-div-icon'\n    },\n    createIcon: function (oldIcon) {\n      var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),\n          options = this.options;\n\n      if (options.html instanceof Element) {\n        empty(div);\n        div.appendChild(options.html);\n      } else {\n        div.innerHTML = options.html !== false ? options.html : '';\n      }\n\n      if (options.bgPos) {\n        var bgPos = toPoint(options.bgPos);\n        div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';\n      }\n\n      this._setIconStyles(div, 'icon');\n\n      return div;\n    },\n    createShadow: function () {\n      return null;\n    }\n  }); // @factory L.divIcon(options: DivIcon options)\n  // Creates a `DivIcon` instance with the given options.\n\n  function divIcon(options) {\n    return new DivIcon(options);\n  }\n\n  Icon.Default = IconDefault;\n  /*\n   * @class GridLayer\n   * @inherits Layer\n   * @aka L.GridLayer\n   *\n   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.\n   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.\n   *\n   *\n   * @section Synchronous usage\n   * @example\n   *\n   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords){\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z\n   *         var ctx = tile.getContext('2d');\n   *\n   *         // return the tile so it can be rendered on screen\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section Asynchronous usage\n   * @example\n   *\n   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords, done){\n   *         var error;\n   *\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // draw something asynchronously and pass the tile to the done() callback\n   *         setTimeout(function() {\n   *             done(error, tile);\n   *         }, 1000);\n   *\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section\n   */\n\n  var GridLayer = Layer.extend({\n    // @section\n    // @aka GridLayer options\n    options: {\n      // @option tileSize: Number|Point = 256\n      // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n      tileSize: 256,\n      // @option opacity: Number = 1.0\n      // Opacity of the tiles. Can be used in the `createTile()` function.\n      opacity: 1,\n      // @option updateWhenIdle: Boolean = (depends)\n      // Load new tiles only when panning ends.\n      // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n      // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the\n      // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n      updateWhenIdle: mobile,\n      // @option updateWhenZooming: Boolean = true\n      // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.\n      updateWhenZooming: true,\n      // @option updateInterval: Number = 200\n      // Tiles will not update more than once every `updateInterval` milliseconds when panning.\n      updateInterval: 200,\n      // @option zIndex: Number = 1\n      // The explicit zIndex of the tile layer.\n      zIndex: 1,\n      // @option bounds: LatLngBounds = undefined\n      // If set, tiles will only be loaded inside the set `LatLngBounds`.\n      bounds: null,\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = undefined\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: undefined,\n      // @option maxNativeZoom: Number = undefined\n      // Maximum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded\n      // from `maxNativeZoom` level and auto-scaled.\n      maxNativeZoom: undefined,\n      // @option minNativeZoom: Number = undefined\n      // Minimum zoom number the tile source has available. If it is specified,\n      // the tiles on all zoom levels lower than `minNativeZoom` will be loaded\n      // from `minNativeZoom` level and auto-scaled.\n      minNativeZoom: undefined,\n      // @option noWrap: Boolean = false\n      // Whether the layer is wrapped around the antimeridian. If `true`, the\n      // GridLayer will only be displayed once at low zoom levels. Has no\n      // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n      // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n      // tiles outside the CRS limits.\n      noWrap: false,\n      // @option pane: String = 'tilePane'\n      // `Map pane` where the grid layer will be added.\n      pane: 'tilePane',\n      // @option className: String = ''\n      // A custom class name to assign to the tile layer. Empty by default.\n      className: '',\n      // @option keepBuffer: Number = 2\n      // When panning the map, keep this many rows and columns of tiles before unloading them.\n      keepBuffer: 2\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n    },\n    onAdd: function () {\n      this._initContainer();\n\n      this._levels = {};\n      this._tiles = {};\n\n      this._resetView();\n\n      this._update();\n    },\n    beforeAdd: function (map) {\n      map._addZoomLimit(this);\n    },\n    onRemove: function (map) {\n      this._removeAllTiles();\n\n      remove(this._container);\n\n      map._removeZoomLimit(this);\n\n      this._container = null;\n      this._tileZoom = undefined;\n    },\n    // @method bringToFront: this\n    // Brings the tile layer to the top of all tile layers.\n    bringToFront: function () {\n      if (this._map) {\n        toFront(this._container);\n\n        this._setAutoZIndex(Math.max);\n      }\n\n      return this;\n    },\n    // @method bringToBack: this\n    // Brings the tile layer to the bottom of all tile layers.\n    bringToBack: function () {\n      if (this._map) {\n        toBack(this._container);\n\n        this._setAutoZIndex(Math.min);\n      }\n\n      return this;\n    },\n    // @method getContainer: HTMLElement\n    // Returns the HTML element that contains the tiles for this layer.\n    getContainer: function () {\n      return this._container;\n    },\n    // @method setOpacity(opacity: Number): this\n    // Changes the [opacity](#gridlayer-opacity) of the grid layer.\n    setOpacity: function (opacity) {\n      this.options.opacity = opacity;\n\n      this._updateOpacity();\n\n      return this;\n    },\n    // @method setZIndex(zIndex: Number): this\n    // Changes the [zIndex](#gridlayer-zindex) of the grid layer.\n    setZIndex: function (zIndex) {\n      this.options.zIndex = zIndex;\n\n      this._updateZIndex();\n\n      return this;\n    },\n    // @method isLoading: Boolean\n    // Returns `true` if any tile in the grid layer has not finished loading.\n    isLoading: function () {\n      return this._loading;\n    },\n    // @method redraw: this\n    // Causes the layer to clear all the tiles and request them again.\n    redraw: function () {\n      if (this._map) {\n        this._removeAllTiles();\n\n        this._update();\n      }\n\n      return this;\n    },\n    getEvents: function () {\n      var events = {\n        viewprereset: this._invalidateAll,\n        viewreset: this._resetView,\n        zoom: this._resetView,\n        moveend: this._onMoveEnd\n      };\n\n      if (!this.options.updateWhenIdle) {\n        // update tiles on move, but not more often than once per given interval\n        if (!this._onMove) {\n          this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);\n        }\n\n        events.move = this._onMove;\n      }\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._animateZoom;\n      }\n\n      return events;\n    },\n    // @section Extension methods\n    // Layers extending `GridLayer` shall reimplement the following method.\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, must be overridden by classes extending `GridLayer`.\n    // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n    // is specified, it must be called when the tile has finished loading and drawing.\n    createTile: function () {\n      return document.createElement('div');\n    },\n    // @section\n    // @method getTileSize: Point\n    // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.\n    getTileSize: function () {\n      var s = this.options.tileSize;\n      return s instanceof Point ? s : new Point(s, s);\n    },\n    _updateZIndex: function () {\n      if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n        this._container.style.zIndex = this.options.zIndex;\n      }\n    },\n    _setAutoZIndex: function (compare) {\n      // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n      var layers = this.getPane().children,\n          edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n\n      for (var i = 0, len = layers.length, zIndex; i < len; i++) {\n        zIndex = layers[i].style.zIndex;\n\n        if (layers[i] !== this._container && zIndex) {\n          edgeZIndex = compare(edgeZIndex, +zIndex);\n        }\n      }\n\n      if (isFinite(edgeZIndex)) {\n        this.options.zIndex = edgeZIndex + compare(-1, 1);\n\n        this._updateZIndex();\n      }\n    },\n    _updateOpacity: function () {\n      if (!this._map) {\n        return;\n      } // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n\n\n      if (ielt9) {\n        return;\n      }\n\n      setOpacity(this._container, this.options.opacity);\n      var now = +new Date(),\n          nextFrame = false,\n          willPrune = false;\n\n      for (var key in this._tiles) {\n        var tile = this._tiles[key];\n\n        if (!tile.current || !tile.loaded) {\n          continue;\n        }\n\n        var fade = Math.min(1, (now - tile.loaded) / 200);\n        setOpacity(tile.el, fade);\n\n        if (fade < 1) {\n          nextFrame = true;\n        } else {\n          if (tile.active) {\n            willPrune = true;\n          } else {\n            this._onOpaqueTile(tile);\n          }\n\n          tile.active = true;\n        }\n      }\n\n      if (willPrune && !this._noPrune) {\n        this._pruneTiles();\n      }\n\n      if (nextFrame) {\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      }\n    },\n    _onOpaqueTile: falseFn,\n    _initContainer: function () {\n      if (this._container) {\n        return;\n      }\n\n      this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));\n\n      this._updateZIndex();\n\n      if (this.options.opacity < 1) {\n        this._updateOpacity();\n      }\n\n      this.getPane().appendChild(this._container);\n    },\n    _updateLevels: function () {\n      var zoom = this._tileZoom,\n          maxZoom = this.options.maxZoom;\n\n      if (zoom === undefined) {\n        return undefined;\n      }\n\n      for (var z in this._levels) {\n        if (this._levels[z].el.children.length || z === zoom) {\n          this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n\n          this._onUpdateLevel(z);\n        } else {\n          remove(this._levels[z].el);\n\n          this._removeTilesAtZoom(z);\n\n          this._onRemoveLevel(z);\n\n          delete this._levels[z];\n        }\n      }\n\n      var level = this._levels[zoom],\n          map = this._map;\n\n      if (!level) {\n        level = this._levels[zoom] = {};\n        level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);\n        level.el.style.zIndex = maxZoom;\n        level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n        level.zoom = zoom;\n\n        this._setZoomTransform(level, map.getCenter(), map.getZoom()); // force the browser to consider the newly added element for transition\n\n\n        falseFn(level.el.offsetWidth);\n\n        this._onCreateLevel(level);\n      }\n\n      this._level = level;\n      return level;\n    },\n    _onUpdateLevel: falseFn,\n    _onRemoveLevel: falseFn,\n    _onCreateLevel: falseFn,\n    _pruneTiles: function () {\n      if (!this._map) {\n        return;\n      }\n\n      var key, tile;\n\n      var zoom = this._map.getZoom();\n\n      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n        this._removeAllTiles();\n\n        return;\n      }\n\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n        tile.retain = tile.current;\n      }\n\n      for (key in this._tiles) {\n        tile = this._tiles[key];\n\n        if (tile.current && !tile.active) {\n          var coords = tile.coords;\n\n          if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n            this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n          }\n        }\n      }\n\n      for (key in this._tiles) {\n        if (!this._tiles[key].retain) {\n          this._removeTile(key);\n        }\n      }\n    },\n    _removeTilesAtZoom: function (zoom) {\n      for (var key in this._tiles) {\n        if (this._tiles[key].coords.z !== zoom) {\n          continue;\n        }\n\n        this._removeTile(key);\n      }\n    },\n    _removeAllTiles: function () {\n      for (var key in this._tiles) {\n        this._removeTile(key);\n      }\n    },\n    _invalidateAll: function () {\n      for (var z in this._levels) {\n        remove(this._levels[z].el);\n\n        this._onRemoveLevel(z);\n\n        delete this._levels[z];\n      }\n\n      this._removeAllTiles();\n\n      this._tileZoom = undefined;\n    },\n    _retainParent: function (x, y, z, minZoom) {\n      var x2 = Math.floor(x / 2),\n          y2 = Math.floor(y / 2),\n          z2 = z - 1,\n          coords2 = new Point(+x2, +y2);\n      coords2.z = +z2;\n\n      var key = this._tileCoordsToKey(coords2),\n          tile = this._tiles[key];\n\n      if (tile && tile.active) {\n        tile.retain = true;\n        return true;\n      } else if (tile && tile.loaded) {\n        tile.retain = true;\n      }\n\n      if (z2 > minZoom) {\n        return this._retainParent(x2, y2, z2, minZoom);\n      }\n\n      return false;\n    },\n    _retainChildren: function (x, y, z, maxZoom) {\n      for (var i = 2 * x; i < 2 * x + 2; i++) {\n        for (var j = 2 * y; j < 2 * y + 2; j++) {\n          var coords = new Point(i, j);\n          coords.z = z + 1;\n\n          var key = this._tileCoordsToKey(coords),\n              tile = this._tiles[key];\n\n          if (tile && tile.active) {\n            tile.retain = true;\n            continue;\n          } else if (tile && tile.loaded) {\n            tile.retain = true;\n          }\n\n          if (z + 1 < maxZoom) {\n            this._retainChildren(i, j, z + 1, maxZoom);\n          }\n        }\n      }\n    },\n    _resetView: function (e) {\n      var animating = e && (e.pinch || e.flyTo);\n\n      this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n    },\n    _animateZoom: function (e) {\n      this._setView(e.center, e.zoom, true, e.noUpdate);\n    },\n    _clampZoom: function (zoom) {\n      var options = this.options;\n\n      if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {\n        return options.minNativeZoom;\n      }\n\n      if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {\n        return options.maxNativeZoom;\n      }\n\n      return zoom;\n    },\n    _setView: function (center, zoom, noPrune, noUpdate) {\n      var tileZoom = this._clampZoom(Math.round(zoom));\n\n      if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {\n        tileZoom = undefined;\n      }\n\n      var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;\n\n      if (!noUpdate || tileZoomChanged) {\n        this._tileZoom = tileZoom;\n\n        if (this._abortLoading) {\n          this._abortLoading();\n        }\n\n        this._updateLevels();\n\n        this._resetGrid();\n\n        if (tileZoom !== undefined) {\n          this._update(center);\n        }\n\n        if (!noPrune) {\n          this._pruneTiles();\n        } // Flag to prevent _updateOpacity from pruning tiles during\n        // a zoom anim or a pinch gesture\n\n\n        this._noPrune = !!noPrune;\n      }\n\n      this._setZoomTransforms(center, zoom);\n    },\n    _setZoomTransforms: function (center, zoom) {\n      for (var i in this._levels) {\n        this._setZoomTransform(this._levels[i], center, zoom);\n      }\n    },\n    _setZoomTransform: function (level, center, zoom) {\n      var scale = this._map.getZoomScale(zoom, level.zoom),\n          translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n\n      if (any3d) {\n        setTransform(level.el, translate, scale);\n      } else {\n        setPosition(level.el, translate);\n      }\n    },\n    _resetGrid: function () {\n      var map = this._map,\n          crs = map.options.crs,\n          tileSize = this._tileSize = this.getTileSize(),\n          tileZoom = this._tileZoom;\n\n      var bounds = this._map.getPixelWorldBounds(this._tileZoom);\n\n      if (bounds) {\n        this._globalTileRange = this._pxBoundsToTileRange(bounds);\n      }\n\n      this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];\n      this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];\n    },\n    _onMoveEnd: function () {\n      if (!this._map || this._map._animatingZoom) {\n        return;\n      }\n\n      this._update();\n    },\n    _getTiledPixelBounds: function (center) {\n      var map = this._map,\n          mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),\n          scale = map.getZoomScale(mapZoom, this._tileZoom),\n          pixelCenter = map.project(center, this._tileZoom).floor(),\n          halfSize = map.getSize().divideBy(scale * 2);\n      return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n    },\n    // Private method to load tiles in the grid's active zoom level according to map bounds\n    _update: function (center) {\n      var map = this._map;\n\n      if (!map) {\n        return;\n      }\n\n      var zoom = this._clampZoom(map.getZoom());\n\n      if (center === undefined) {\n        center = map.getCenter();\n      }\n\n      if (this._tileZoom === undefined) {\n        return;\n      } // if out of minzoom/maxzoom\n\n\n      var pixelBounds = this._getTiledPixelBounds(center),\n          tileRange = this._pxBoundsToTileRange(pixelBounds),\n          tileCenter = tileRange.getCenter(),\n          queue = [],\n          margin = this.options.keepBuffer,\n          noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin])); // Sanity check: panic if the tile range contains Infinity somewhere.\n\n\n      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {\n        throw new Error('Attempted to load an infinite number of tiles');\n      }\n\n      for (var key in this._tiles) {\n        var c = this._tiles[key].coords;\n\n        if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n          this._tiles[key].current = false;\n        }\n      } // _update just loads more tiles. If the tile zoom level differs too much\n      // from the map's, let _setView reset levels and prune old tiles.\n\n\n      if (Math.abs(zoom - this._tileZoom) > 1) {\n        this._setView(center, zoom);\n\n        return;\n      } // create a queue of coordinates to load tiles from\n\n\n      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n          var coords = new Point(i, j);\n          coords.z = this._tileZoom;\n\n          if (!this._isValidTile(coords)) {\n            continue;\n          }\n\n          var tile = this._tiles[this._tileCoordsToKey(coords)];\n\n          if (tile) {\n            tile.current = true;\n          } else {\n            queue.push(coords);\n          }\n        }\n      } // sort tile queue to load tiles in order of their distance to center\n\n\n      queue.sort(function (a, b) {\n        return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n      });\n\n      if (queue.length !== 0) {\n        // if it's the first batch of tiles to load\n        if (!this._loading) {\n          this._loading = true; // @event loading: Event\n          // Fired when the grid layer starts loading tiles.\n\n          this.fire('loading');\n        } // create DOM fragment to append tiles in one batch\n\n\n        var fragment = document.createDocumentFragment();\n\n        for (i = 0; i < queue.length; i++) {\n          this._addTile(queue[i], fragment);\n        }\n\n        this._level.el.appendChild(fragment);\n      }\n    },\n    _isValidTile: function (coords) {\n      var crs = this._map.options.crs;\n\n      if (!crs.infinite) {\n        // don't load tile if it's out of bounds and not wrapped\n        var bounds = this._globalTileRange;\n\n        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n          return false;\n        }\n      }\n\n      if (!this.options.bounds) {\n        return true;\n      } // don't load tile if it doesn't intersect the bounds in options\n\n\n      var tileBounds = this._tileCoordsToBounds(coords);\n\n      return toLatLngBounds(this.options.bounds).overlaps(tileBounds);\n    },\n    _keyToBounds: function (key) {\n      return this._tileCoordsToBounds(this._keyToTileCoords(key));\n    },\n    _tileCoordsToNwSe: function (coords) {\n      var map = this._map,\n          tileSize = this.getTileSize(),\n          nwPoint = coords.scaleBy(tileSize),\n          sePoint = nwPoint.add(tileSize),\n          nw = map.unproject(nwPoint, coords.z),\n          se = map.unproject(sePoint, coords.z);\n      return [nw, se];\n    },\n    // converts tile coordinates to its geographical bounds\n    _tileCoordsToBounds: function (coords) {\n      var bp = this._tileCoordsToNwSe(coords),\n          bounds = new LatLngBounds(bp[0], bp[1]);\n\n      if (!this.options.noWrap) {\n        bounds = this._map.wrapLatLngBounds(bounds);\n      }\n\n      return bounds;\n    },\n    // converts tile coordinates to key for the tile cache\n    _tileCoordsToKey: function (coords) {\n      return coords.x + ':' + coords.y + ':' + coords.z;\n    },\n    // converts tile cache key to coordinates\n    _keyToTileCoords: function (key) {\n      var k = key.split(':'),\n          coords = new Point(+k[0], +k[1]);\n      coords.z = +k[2];\n      return coords;\n    },\n    _removeTile: function (key) {\n      var tile = this._tiles[key];\n\n      if (!tile) {\n        return;\n      }\n\n      remove(tile.el);\n      delete this._tiles[key]; // @event tileunload: TileEvent\n      // Fired when a tile is removed (e.g. when a tile goes off the screen).\n\n      this.fire('tileunload', {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key)\n      });\n    },\n    _initTile: function (tile) {\n      addClass(tile, 'leaflet-tile');\n      var tileSize = this.getTileSize();\n      tile.style.width = tileSize.x + 'px';\n      tile.style.height = tileSize.y + 'px';\n      tile.onselectstart = falseFn;\n      tile.onmousemove = falseFn; // update opacity on tiles in IE7-8 because of filter inheritance problems\n\n      if (ielt9 && this.options.opacity < 1) {\n        setOpacity(tile, this.options.opacity);\n      } // without this hack, tiles disappear after zoom on Chrome for Android\n      // https://github.com/Leaflet/Leaflet/issues/2078\n\n\n      if (android && !android23) {\n        tile.style.WebkitBackfaceVisibility = 'hidden';\n      }\n    },\n    _addTile: function (coords, container) {\n      var tilePos = this._getTilePos(coords),\n          key = this._tileCoordsToKey(coords);\n\n      var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));\n\n      this._initTile(tile); // if createTile is defined with a second argument (\"done\" callback),\n      // we know that tile is async and will be ready later; otherwise\n\n\n      if (this.createTile.length < 2) {\n        // mark tile as ready, but delay one frame for opacity animation to happen\n        requestAnimFrame(bind(this._tileReady, this, coords, null, tile));\n      }\n\n      setPosition(tile, tilePos); // save tile in cache\n\n      this._tiles[key] = {\n        el: tile,\n        coords: coords,\n        current: true\n      };\n      container.appendChild(tile); // @event tileloadstart: TileEvent\n      // Fired when a tile is requested and starts loading.\n\n      this.fire('tileloadstart', {\n        tile: tile,\n        coords: coords\n      });\n    },\n    _tileReady: function (coords, err, tile) {\n      if (err) {\n        // @event tileerror: TileErrorEvent\n        // Fired when there is an error loading a tile.\n        this.fire('tileerror', {\n          error: err,\n          tile: tile,\n          coords: coords\n        });\n      }\n\n      var key = this._tileCoordsToKey(coords);\n\n      tile = this._tiles[key];\n\n      if (!tile) {\n        return;\n      }\n\n      tile.loaded = +new Date();\n\n      if (this._map._fadeAnimated) {\n        setOpacity(tile.el, 0);\n        cancelAnimFrame(this._fadeFrame);\n        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n      } else {\n        tile.active = true;\n\n        this._pruneTiles();\n      }\n\n      if (!err) {\n        addClass(tile.el, 'leaflet-tile-loaded'); // @event tileload: TileEvent\n        // Fired when a tile loads.\n\n        this.fire('tileload', {\n          tile: tile.el,\n          coords: coords\n        });\n      }\n\n      if (this._noTilesToLoad()) {\n        this._loading = false; // @event load: Event\n        // Fired when the grid layer loaded all visible tiles.\n\n        this.fire('load');\n\n        if (ielt9 || !this._map._fadeAnimated) {\n          requestAnimFrame(this._pruneTiles, this);\n        } else {\n          // Wait a bit more than 0.2 secs (the duration of the tile fade-in)\n          // to trigger a pruning.\n          setTimeout(bind(this._pruneTiles, this), 250);\n        }\n      }\n    },\n    _getTilePos: function (coords) {\n      return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n    },\n    _wrapCoords: function (coords) {\n      var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);\n      newCoords.z = coords.z;\n      return newCoords;\n    },\n    _pxBoundsToTileRange: function (bounds) {\n      var tileSize = this.getTileSize();\n      return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));\n    },\n    _noTilesToLoad: function () {\n      for (var key in this._tiles) {\n        if (!this._tiles[key].loaded) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }); // @factory L.gridLayer(options?: GridLayer options)\n  // Creates a new instance of GridLayer with the supplied options.\n\n  function gridLayer(options) {\n    return new GridLayer(options);\n  }\n  /*\r\n   * @class TileLayer\r\n   * @inherits GridLayer\r\n   * @aka L.TileLayer\r\n   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: 'Map data &copy; <a href=\"https://www.openstreetmap.org/\">OpenStreetMap</a> contributors, <a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>'}).addTo(map);\r\n   * ```\r\n   *\r\n   * @section URL template\r\n   * @example\r\n   *\r\n   * A string of the following form:\r\n   *\r\n   * ```\r\n   * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'\r\n   * ```\r\n   *\r\n   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add \"&commat;2x\" to the URL to load retina tiles.\r\n   *\r\n   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:\r\n   *\r\n   * ```\r\n   * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});\r\n   * ```\r\n   */\n\n\n  var TileLayer = GridLayer.extend({\n    // @section\n    // @aka TileLayer options\n    options: {\n      // @option minZoom: Number = 0\n      // The minimum zoom level down to which this layer will be displayed (inclusive).\n      minZoom: 0,\n      // @option maxZoom: Number = 18\n      // The maximum zoom level up to which this layer will be displayed (inclusive).\n      maxZoom: 18,\n      // @option subdomains: String|String[] = 'abc'\n      // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.\n      subdomains: 'abc',\n      // @option errorTileUrl: String = ''\n      // URL to the tile image to show in place of the tile that failed to load.\n      errorTileUrl: '',\n      // @option zoomOffset: Number = 0\n      // The zoom number used in tile URLs will be offset with this value.\n      zoomOffset: 0,\n      // @option tms: Boolean = false\n      // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).\n      tms: false,\n      // @option zoomReverse: Boolean = false\n      // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)\n      zoomReverse: false,\n      // @option detectRetina: Boolean = false\n      // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.\n      detectRetina: false,\n      // @option crossOrigin: Boolean|String = false\n      // Whether the crossOrigin attribute will be added to the tiles.\n      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n      crossOrigin: false\n    },\n    initialize: function (url, options) {\n      this._url = url;\n      options = setOptions(this, options); // detecting retina displays, adjusting tileSize and zoom levels\n\n      if (options.detectRetina && retina && options.maxZoom > 0) {\n        options.tileSize = Math.floor(options.tileSize / 2);\n\n        if (!options.zoomReverse) {\n          options.zoomOffset++;\n          options.maxZoom--;\n        } else {\n          options.zoomOffset--;\n          options.minZoom++;\n        }\n\n        options.minZoom = Math.max(0, options.minZoom);\n      }\n\n      if (typeof options.subdomains === 'string') {\n        options.subdomains = options.subdomains.split('');\n      } // for https://github.com/Leaflet/Leaflet/issues/137\n\n\n      if (!android) {\n        this.on('tileunload', this._onTileRemove);\n      }\n    },\n    // @method setUrl(url: String, noRedraw?: Boolean): this\n    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).\n    // If the URL does not change, the layer will not be redrawn unless\n    // the noRedraw parameter is set to false.\n    setUrl: function (url, noRedraw) {\n      if (this._url === url && noRedraw === undefined) {\n        noRedraw = true;\n      }\n\n      this._url = url;\n\n      if (!noRedraw) {\n        this.redraw();\n      }\n\n      return this;\n    },\n    // @method createTile(coords: Object, done?: Function): HTMLElement\n    // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)\n    // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`\n    // callback is called when the tile has been loaded.\n    createTile: function (coords, done) {\n      var tile = document.createElement('img');\n      on(tile, 'load', bind(this._tileOnLoad, this, done, tile));\n      on(tile, 'error', bind(this._tileOnError, this, done, tile));\n\n      if (this.options.crossOrigin || this.options.crossOrigin === '') {\n        tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\n      }\n      /*\r\n       Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons\r\n       http://www.w3.org/TR/WCAG20-TECHS/H67\r\n      */\n\n\n      tile.alt = '';\n      /*\r\n       Set role=\"presentation\" to force screen readers to ignore this\r\n       https://www.w3.org/TR/wai-aria/roles#textalternativecomputation\r\n      */\n\n      tile.setAttribute('role', 'presentation');\n      tile.src = this.getTileUrl(coords);\n      return tile;\n    },\n    // @section Extension methods\n    // @uninheritable\n    // Layers extending `TileLayer` might reimplement the following method.\n    // @method getTileUrl(coords: Object): String\n    // Called only internally, returns the URL for a tile given its coordinates.\n    // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.\n    getTileUrl: function (coords) {\n      var data = {\n        r: retina ? '@2x' : '',\n        s: this._getSubdomain(coords),\n        x: coords.x,\n        y: coords.y,\n        z: this._getZoomForUrl()\n      };\n\n      if (this._map && !this._map.options.crs.infinite) {\n        var invertedY = this._globalTileRange.max.y - coords.y;\n\n        if (this.options.tms) {\n          data['y'] = invertedY;\n        }\n\n        data['-y'] = invertedY;\n      }\n\n      return template(this._url, extend(data, this.options));\n    },\n    _tileOnLoad: function (done, tile) {\n      // For https://github.com/Leaflet/Leaflet/issues/3332\n      if (ielt9) {\n        setTimeout(bind(done, this, null, tile), 0);\n      } else {\n        done(null, tile);\n      }\n    },\n    _tileOnError: function (done, tile, e) {\n      var errorUrl = this.options.errorTileUrl;\n\n      if (errorUrl && tile.getAttribute('src') !== errorUrl) {\n        tile.src = errorUrl;\n      }\n\n      done(e, tile);\n    },\n    _onTileRemove: function (e) {\n      e.tile.onload = null;\n    },\n    _getZoomForUrl: function () {\n      var zoom = this._tileZoom,\n          maxZoom = this.options.maxZoom,\n          zoomReverse = this.options.zoomReverse,\n          zoomOffset = this.options.zoomOffset;\n\n      if (zoomReverse) {\n        zoom = maxZoom - zoom;\n      }\n\n      return zoom + zoomOffset;\n    },\n    _getSubdomain: function (tilePoint) {\n      var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n      return this.options.subdomains[index];\n    },\n    // stops loading all tiles in the background layer\n    _abortLoading: function () {\n      var i, tile;\n\n      for (i in this._tiles) {\n        if (this._tiles[i].coords.z !== this._tileZoom) {\n          tile = this._tiles[i].el;\n          tile.onload = falseFn;\n          tile.onerror = falseFn;\n\n          if (!tile.complete) {\n            tile.src = emptyImageUrl;\n            remove(tile);\n            delete this._tiles[i];\n          }\n        }\n      }\n    },\n    _removeTile: function (key) {\n      var tile = this._tiles[key];\n\n      if (!tile) {\n        return;\n      } // Cancels any pending http requests associated with the tile\n      // unless we're on Android's stock browser,\n      // see https://github.com/Leaflet/Leaflet/issues/137\n\n\n      if (!androidStock) {\n        tile.el.setAttribute('src', emptyImageUrl);\n      }\n\n      return GridLayer.prototype._removeTile.call(this, key);\n    },\n    _tileReady: function (coords, err, tile) {\n      if (!this._map || tile && tile.getAttribute('src') === emptyImageUrl) {\n        return;\n      }\n\n      return GridLayer.prototype._tileReady.call(this, coords, err, tile);\n    }\n  }); // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)\n  // Instantiates a tile layer object given a `URL template` and optionally an options object.\n\n  function tileLayer(url, options) {\n    return new TileLayer(url, options);\n  }\n  /*\r\n   * @class TileLayer.WMS\r\n   * @inherits TileLayer\r\n   * @aka L.TileLayer.WMS\r\n   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var nexrad = L.tileLayer.wms(\"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\", {\r\n   * \tlayers: 'nexrad-n0r-900913',\r\n   * \tformat: 'image/png',\r\n   * \ttransparent: true,\r\n   * \tattribution: \"Weather data © 2012 IEM Nexrad\"\r\n   * });\r\n   * ```\r\n   */\n\n\n  var TileLayerWMS = TileLayer.extend({\n    // @section\n    // @aka TileLayer.WMS options\n    // If any custom options not documented here are used, they will be sent to the\n    // WMS server as extra parameters in each request URL. This can be useful for\n    // [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).\n    defaultWmsParams: {\n      service: 'WMS',\n      request: 'GetMap',\n      // @option layers: String = ''\n      // **(required)** Comma-separated list of WMS layers to show.\n      layers: '',\n      // @option styles: String = ''\n      // Comma-separated list of WMS styles.\n      styles: '',\n      // @option format: String = 'image/jpeg'\n      // WMS image format (use `'image/png'` for layers with transparency).\n      format: 'image/jpeg',\n      // @option transparent: Boolean = false\n      // If `true`, the WMS service will return images with transparency.\n      transparent: false,\n      // @option version: String = '1.1.1'\n      // Version of the WMS service to use\n      version: '1.1.1'\n    },\n    options: {\n      // @option crs: CRS = null\n      // Coordinate Reference System to use for the WMS requests, defaults to\n      // map CRS. Don't change this if you're not sure what it means.\n      crs: null,\n      // @option uppercase: Boolean = false\n      // If `true`, WMS request parameter keys will be uppercase.\n      uppercase: false\n    },\n    initialize: function (url, options) {\n      this._url = url;\n      var wmsParams = extend({}, this.defaultWmsParams); // all keys that are not TileLayer options go to WMS params\n\n      for (var i in options) {\n        if (!(i in this.options)) {\n          wmsParams[i] = options[i];\n        }\n      }\n\n      options = setOptions(this, options);\n      var realRetina = options.detectRetina && retina ? 2 : 1;\n      var tileSize = this.getTileSize();\n      wmsParams.width = tileSize.x * realRetina;\n      wmsParams.height = tileSize.y * realRetina;\n      this.wmsParams = wmsParams;\n    },\n    onAdd: function (map) {\n      this._crs = this.options.crs || map.options.crs;\n      this._wmsVersion = parseFloat(this.wmsParams.version);\n      var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\n      this.wmsParams[projectionKey] = this._crs.code;\n      TileLayer.prototype.onAdd.call(this, map);\n    },\n    getTileUrl: function (coords) {\n      var tileBounds = this._tileCoordsToNwSe(coords),\n          crs = this._crs,\n          bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),\n          min = bounds.min,\n          max = bounds.max,\n          bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(','),\n          url = TileLayer.prototype.getTileUrl.call(this, coords);\n\n      return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;\n    },\n    // @method setParams(params: Object, noRedraw?: Boolean): this\n    // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).\n    setParams: function (params, noRedraw) {\n      extend(this.wmsParams, params);\n\n      if (!noRedraw) {\n        this.redraw();\n      }\n\n      return this;\n    }\n  }); // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)\n  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.\n\n  function tileLayerWMS(url, options) {\n    return new TileLayerWMS(url, options);\n  }\n\n  TileLayer.WMS = TileLayerWMS;\n  tileLayer.wms = tileLayerWMS;\n  /*\n   * @class Renderer\n   * @inherits Layer\n   * @aka L.Renderer\n   *\n   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the\n   * DOM container of the renderer, its bounds, and its zoom animation.\n   *\n   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer\n   * itself can be added or removed to the map. All paths use a renderer, which can\n   * be implicit (the map will decide the type of renderer and use it automatically)\n   * or explicit (using the [`renderer`](#path-renderer) option of the path).\n   *\n   * Do not use this class directly, use `SVG` and `Canvas` instead.\n   *\n   * @event update: Event\n   * Fired when the renderer updates its bounds, center and zoom, for example when\n   * its map has moved\n   */\n\n  var Renderer = Layer.extend({\n    // @section\n    // @aka Renderer options\n    options: {\n      // @option padding: Number = 0.1\n      // How much to extend the clip area around the map view (relative to its size)\n      // e.g. 0.1 would be 10% of map view in each direction\n      padding: 0.1,\n      // @option tolerance: Number = 0\n      // How much to extend click tolerance round a path/object on the map\n      tolerance: 0\n    },\n    initialize: function (options) {\n      setOptions(this, options);\n      stamp(this);\n      this._layers = this._layers || {};\n    },\n    onAdd: function () {\n      if (!this._container) {\n        this._initContainer(); // defined by renderer implementations\n\n\n        if (this._zoomAnimated) {\n          addClass(this._container, 'leaflet-zoom-animated');\n        }\n      }\n\n      this.getPane().appendChild(this._container);\n\n      this._update();\n\n      this.on('update', this._updatePaths, this);\n    },\n    onRemove: function () {\n      this.off('update', this._updatePaths, this);\n\n      this._destroyContainer();\n    },\n    getEvents: function () {\n      var events = {\n        viewreset: this._reset,\n        zoom: this._onZoom,\n        moveend: this._update,\n        zoomend: this._onZoomEnd\n      };\n\n      if (this._zoomAnimated) {\n        events.zoomanim = this._onAnimZoom;\n      }\n\n      return events;\n    },\n    _onAnimZoom: function (ev) {\n      this._updateTransform(ev.center, ev.zoom);\n    },\n    _onZoom: function () {\n      this._updateTransform(this._map.getCenter(), this._map.getZoom());\n    },\n    _updateTransform: function (center, zoom) {\n      var scale = this._map.getZoomScale(zoom, this._zoom),\n          position = getPosition(this._container),\n          viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),\n          currentCenterPoint = this._map.project(this._center, zoom),\n          destCenterPoint = this._map.project(center, zoom),\n          centerOffset = destCenterPoint.subtract(currentCenterPoint),\n          topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);\n\n      if (any3d) {\n        setTransform(this._container, topLeftOffset, scale);\n      } else {\n        setPosition(this._container, topLeftOffset);\n      }\n    },\n    _reset: function () {\n      this._update();\n\n      this._updateTransform(this._center, this._zoom);\n\n      for (var id in this._layers) {\n        this._layers[id]._reset();\n      }\n    },\n    _onZoomEnd: function () {\n      for (var id in this._layers) {\n        this._layers[id]._project();\n      }\n    },\n    _updatePaths: function () {\n      for (var id in this._layers) {\n        this._layers[id]._update();\n      }\n    },\n    _update: function () {\n      // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n      // Subclasses are responsible of firing the 'update' event.\n      var p = this.options.padding,\n          size = this._map.getSize(),\n          min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n\n      this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n      this._center = this._map.getCenter();\n      this._zoom = this._map.getZoom();\n    }\n  });\n  /*\n   * @class Canvas\n   * @inherits Renderer\n   * @aka L.Canvas\n   *\n   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not\n   * available in all web browsers, notably IE8, and overlapping geometries might\n   * not display properly in some edge cases.\n   *\n   * @example\n   *\n   * Use Canvas by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.canvas()\n   * });\n   * ```\n   *\n   * Use a Canvas renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.canvas({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var Canvas = Renderer.extend({\n    getEvents: function () {\n      var events = Renderer.prototype.getEvents.call(this);\n      events.viewprereset = this._onViewPreReset;\n      return events;\n    },\n    _onViewPreReset: function () {\n      // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once\n      this._postponeUpdatePaths = true;\n    },\n    onAdd: function () {\n      Renderer.prototype.onAdd.call(this); // Redraw vectors since canvas is cleared upon removal,\n      // in case of removing the renderer itself from the map.\n\n      this._draw();\n    },\n    _initContainer: function () {\n      var container = this._container = document.createElement('canvas');\n      on(container, 'mousemove', this._onMouseMove, this);\n      on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);\n      on(container, 'mouseout', this._handleMouseOut, this);\n      this._ctx = container.getContext('2d');\n    },\n    _destroyContainer: function () {\n      cancelAnimFrame(this._redrawRequest);\n      delete this._ctx;\n      remove(this._container);\n      off(this._container);\n      delete this._container;\n    },\n    _updatePaths: function () {\n      if (this._postponeUpdatePaths) {\n        return;\n      }\n\n      var layer;\n      this._redrawBounds = null;\n\n      for (var id in this._layers) {\n        layer = this._layers[id];\n\n        layer._update();\n      }\n\n      this._redraw();\n    },\n    _update: function () {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n\n      Renderer.prototype._update.call(this);\n\n      var b = this._bounds,\n          container = this._container,\n          size = b.getSize(),\n          m = retina ? 2 : 1;\n      setPosition(container, b.min); // set canvas size (also clearing it); use double size on retina\n\n      container.width = m * size.x;\n      container.height = m * size.y;\n      container.style.width = size.x + 'px';\n      container.style.height = size.y + 'px';\n\n      if (retina) {\n        this._ctx.scale(2, 2);\n      } // translate so we use the same path coordinates after canvas element moves\n\n\n      this._ctx.translate(-b.min.x, -b.min.y); // Tell paths to redraw themselves\n\n\n      this.fire('update');\n    },\n    _reset: function () {\n      Renderer.prototype._reset.call(this);\n\n      if (this._postponeUpdatePaths) {\n        this._postponeUpdatePaths = false;\n\n        this._updatePaths();\n      }\n    },\n    _initPath: function (layer) {\n      this._updateDashArray(layer);\n\n      this._layers[stamp(layer)] = layer;\n      var order = layer._order = {\n        layer: layer,\n        prev: this._drawLast,\n        next: null\n      };\n\n      if (this._drawLast) {\n        this._drawLast.next = order;\n      }\n\n      this._drawLast = order;\n      this._drawFirst = this._drawFirst || this._drawLast;\n    },\n    _addPath: function (layer) {\n      this._requestRedraw(layer);\n    },\n    _removePath: function (layer) {\n      var order = layer._order;\n      var next = order.next;\n      var prev = order.prev;\n\n      if (next) {\n        next.prev = prev;\n      } else {\n        this._drawLast = prev;\n      }\n\n      if (prev) {\n        prev.next = next;\n      } else {\n        this._drawFirst = next;\n      }\n\n      delete layer._order;\n      delete this._layers[stamp(layer)];\n\n      this._requestRedraw(layer);\n    },\n    _updatePath: function (layer) {\n      // Redraw the union of the layer's old pixel\n      // bounds and the new pixel bounds.\n      this._extendRedrawBounds(layer);\n\n      layer._project();\n\n      layer._update(); // The redraw will extend the redraw bounds\n      // with the new pixel bounds.\n\n\n      this._requestRedraw(layer);\n    },\n    _updateStyle: function (layer) {\n      this._updateDashArray(layer);\n\n      this._requestRedraw(layer);\n    },\n    _updateDashArray: function (layer) {\n      if (typeof layer.options.dashArray === 'string') {\n        var parts = layer.options.dashArray.split(/[, ]+/),\n            dashArray = [],\n            dashValue,\n            i;\n\n        for (i = 0; i < parts.length; i++) {\n          dashValue = Number(parts[i]); // Ignore dash array containing invalid lengths\n\n          if (isNaN(dashValue)) {\n            return;\n          }\n\n          dashArray.push(dashValue);\n        }\n\n        layer.options._dashArray = dashArray;\n      } else {\n        layer.options._dashArray = layer.options.dashArray;\n      }\n    },\n    _requestRedraw: function (layer) {\n      if (!this._map) {\n        return;\n      }\n\n      this._extendRedrawBounds(layer);\n\n      this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);\n    },\n    _extendRedrawBounds: function (layer) {\n      if (layer._pxBounds) {\n        var padding = (layer.options.weight || 0) + 1;\n        this._redrawBounds = this._redrawBounds || new Bounds();\n\n        this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));\n\n        this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));\n      }\n    },\n    _redraw: function () {\n      this._redrawRequest = null;\n\n      if (this._redrawBounds) {\n        this._redrawBounds.min._floor();\n\n        this._redrawBounds.max._ceil();\n      }\n\n      this._clear(); // clear layers in redraw bounds\n\n\n      this._draw(); // draw layers\n\n\n      this._redrawBounds = null;\n    },\n    _clear: function () {\n      var bounds = this._redrawBounds;\n\n      if (bounds) {\n        var size = bounds.getSize();\n\n        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\n      } else {\n        this._ctx.clearRect(0, 0, this._container.width, this._container.height);\n      }\n    },\n    _draw: function () {\n      var layer,\n          bounds = this._redrawBounds;\n\n      this._ctx.save();\n\n      if (bounds) {\n        var size = bounds.getSize();\n\n        this._ctx.beginPath();\n\n        this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\n\n        this._ctx.clip();\n      }\n\n      this._drawing = true;\n\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n\n        if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {\n          layer._updatePath();\n        }\n      }\n\n      this._drawing = false;\n\n      this._ctx.restore(); // Restore state before clipping.\n\n    },\n    _updatePoly: function (layer, closed) {\n      if (!this._drawing) {\n        return;\n      }\n\n      var i,\n          j,\n          len2,\n          p,\n          parts = layer._parts,\n          len = parts.length,\n          ctx = this._ctx;\n\n      if (!len) {\n        return;\n      }\n\n      ctx.beginPath();\n\n      for (i = 0; i < len; i++) {\n        for (j = 0, len2 = parts[i].length; j < len2; j++) {\n          p = parts[i][j];\n          ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);\n        }\n\n        if (closed) {\n          ctx.closePath();\n        }\n      }\n\n      this._fillStroke(ctx, layer); // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n\n    },\n    _updateCircle: function (layer) {\n      if (!this._drawing || layer._empty()) {\n        return;\n      }\n\n      var p = layer._point,\n          ctx = this._ctx,\n          r = Math.max(Math.round(layer._radius), 1),\n          s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;\n\n      if (s !== 1) {\n        ctx.save();\n        ctx.scale(1, s);\n      }\n\n      ctx.beginPath();\n      ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n\n      if (s !== 1) {\n        ctx.restore();\n      }\n\n      this._fillStroke(ctx, layer);\n    },\n    _fillStroke: function (ctx, layer) {\n      var options = layer.options;\n\n      if (options.fill) {\n        ctx.globalAlpha = options.fillOpacity;\n        ctx.fillStyle = options.fillColor || options.color;\n        ctx.fill(options.fillRule || 'evenodd');\n      }\n\n      if (options.stroke && options.weight !== 0) {\n        if (ctx.setLineDash) {\n          ctx.setLineDash(layer.options && layer.options._dashArray || []);\n        }\n\n        ctx.globalAlpha = options.opacity;\n        ctx.lineWidth = options.weight;\n        ctx.strokeStyle = options.color;\n        ctx.lineCap = options.lineCap;\n        ctx.lineJoin = options.lineJoin;\n        ctx.stroke();\n      }\n    },\n    // Canvas obviously doesn't have mouse events for individual drawn objects,\n    // so we emulate that by calculating what's under the mouse on mousemove/click manually\n    _onClick: function (e) {\n      var point = this._map.mouseEventToLayerPoint(e),\n          layer,\n          clickedLayer;\n\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n\n        if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {\n          clickedLayer = layer;\n        }\n      }\n\n      if (clickedLayer) {\n        fakeStop(e);\n\n        this._fireEvent([clickedLayer], e);\n      }\n    },\n    _onMouseMove: function (e) {\n      if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {\n        return;\n      }\n\n      var point = this._map.mouseEventToLayerPoint(e);\n\n      this._handleMouseHover(e, point);\n    },\n    _handleMouseOut: function (e) {\n      var layer = this._hoveredLayer;\n\n      if (layer) {\n        // if we're leaving the layer, fire mouseout\n        removeClass(this._container, 'leaflet-interactive');\n\n        this._fireEvent([layer], e, 'mouseout');\n\n        this._hoveredLayer = null;\n        this._mouseHoverThrottled = false;\n      }\n    },\n    _handleMouseHover: function (e, point) {\n      if (this._mouseHoverThrottled) {\n        return;\n      }\n\n      var layer, candidateHoveredLayer;\n\n      for (var order = this._drawFirst; order; order = order.next) {\n        layer = order.layer;\n\n        if (layer.options.interactive && layer._containsPoint(point)) {\n          candidateHoveredLayer = layer;\n        }\n      }\n\n      if (candidateHoveredLayer !== this._hoveredLayer) {\n        this._handleMouseOut(e);\n\n        if (candidateHoveredLayer) {\n          addClass(this._container, 'leaflet-interactive'); // change cursor\n\n          this._fireEvent([candidateHoveredLayer], e, 'mouseover');\n\n          this._hoveredLayer = candidateHoveredLayer;\n        }\n      }\n\n      if (this._hoveredLayer) {\n        this._fireEvent([this._hoveredLayer], e);\n      }\n\n      this._mouseHoverThrottled = true;\n      setTimeout(L.bind(function () {\n        this._mouseHoverThrottled = false;\n      }, this), 32);\n    },\n    _fireEvent: function (layers, e, type) {\n      this._map._fireDOMEvent(e, type || e.type, layers);\n    },\n    _bringToFront: function (layer) {\n      var order = layer._order;\n\n      if (!order) {\n        return;\n      }\n\n      var next = order.next;\n      var prev = order.prev;\n\n      if (next) {\n        next.prev = prev;\n      } else {\n        // Already last\n        return;\n      }\n\n      if (prev) {\n        prev.next = next;\n      } else if (next) {\n        // Update first entry unless this is the\n        // single entry\n        this._drawFirst = next;\n      }\n\n      order.prev = this._drawLast;\n      this._drawLast.next = order;\n      order.next = null;\n      this._drawLast = order;\n\n      this._requestRedraw(layer);\n    },\n    _bringToBack: function (layer) {\n      var order = layer._order;\n\n      if (!order) {\n        return;\n      }\n\n      var next = order.next;\n      var prev = order.prev;\n\n      if (prev) {\n        prev.next = next;\n      } else {\n        // Already first\n        return;\n      }\n\n      if (next) {\n        next.prev = prev;\n      } else if (prev) {\n        // Update last entry unless this is the\n        // single entry\n        this._drawLast = prev;\n      }\n\n      order.prev = null;\n      order.next = this._drawFirst;\n      this._drawFirst.prev = order;\n      this._drawFirst = order;\n\n      this._requestRedraw(layer);\n    }\n  }); // @factory L.canvas(options?: Renderer options)\n  // Creates a Canvas renderer with the given options.\n\n  function canvas$1(options) {\n    return canvas ? new Canvas(options) : null;\n  }\n  /*\n   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n   */\n\n\n  var vmlCreate = function () {\n    try {\n      document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n      return function (name) {\n        return document.createElement('<lvml:' + name + ' class=\"lvml\">');\n      };\n    } catch (e) {\n      return function (name) {\n        return document.createElement('<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n      };\n    }\n  }();\n  /*\n   * @class SVG\n   *\n   *\n   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility\n   * with old versions of Internet Explorer.\n   */\n  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences\n\n\n  var vmlMixin = {\n    _initContainer: function () {\n      this._container = create$1('div', 'leaflet-vml-container');\n    },\n    _update: function () {\n      if (this._map._animatingZoom) {\n        return;\n      }\n\n      Renderer.prototype._update.call(this);\n\n      this.fire('update');\n    },\n    _initPath: function (layer) {\n      var container = layer._container = vmlCreate('shape');\n      addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));\n      container.coordsize = '1 1';\n      layer._path = vmlCreate('path');\n      container.appendChild(layer._path);\n\n      this._updateStyle(layer);\n\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function (layer) {\n      var container = layer._container;\n\n      this._container.appendChild(container);\n\n      if (layer.options.interactive) {\n        layer.addInteractiveTarget(container);\n      }\n    },\n    _removePath: function (layer) {\n      var container = layer._container;\n      remove(container);\n      layer.removeInteractiveTarget(container);\n      delete this._layers[stamp(layer)];\n    },\n    _updateStyle: function (layer) {\n      var stroke = layer._stroke,\n          fill = layer._fill,\n          options = layer.options,\n          container = layer._container;\n      container.stroked = !!options.stroke;\n      container.filled = !!options.fill;\n\n      if (options.stroke) {\n        if (!stroke) {\n          stroke = layer._stroke = vmlCreate('stroke');\n        }\n\n        container.appendChild(stroke);\n        stroke.weight = options.weight + 'px';\n        stroke.color = options.color;\n        stroke.opacity = options.opacity;\n\n        if (options.dashArray) {\n          stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');\n        } else {\n          stroke.dashStyle = '';\n        }\n\n        stroke.endcap = options.lineCap.replace('butt', 'flat');\n        stroke.joinstyle = options.lineJoin;\n      } else if (stroke) {\n        container.removeChild(stroke);\n        layer._stroke = null;\n      }\n\n      if (options.fill) {\n        if (!fill) {\n          fill = layer._fill = vmlCreate('fill');\n        }\n\n        container.appendChild(fill);\n        fill.color = options.fillColor || options.color;\n        fill.opacity = options.fillOpacity;\n      } else if (fill) {\n        container.removeChild(fill);\n        layer._fill = null;\n      }\n    },\n    _updateCircle: function (layer) {\n      var p = layer._point.round(),\n          r = Math.round(layer._radius),\n          r2 = Math.round(layer._radiusY || r);\n\n      this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);\n    },\n    _setPath: function (layer, path) {\n      layer._path.v = path;\n    },\n    _bringToFront: function (layer) {\n      toFront(layer._container);\n    },\n    _bringToBack: function (layer) {\n      toBack(layer._container);\n    }\n  };\n  var create$2 = vml ? vmlCreate : svgCreate;\n  /*\n   * @class SVG\n   * @inherits Renderer\n   * @aka L.SVG\n   *\n   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not\n   * available in all web browsers, notably Android 2.x and 3.x.\n   *\n   * Although SVG is not available on IE7 and IE8, these browsers support\n   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)\n   * (a now deprecated technology), and the SVG renderer will fall back to VML in\n   * this case.\n   *\n   * @example\n   *\n   * Use SVG by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.svg()\n   * });\n   * ```\n   *\n   * Use a SVG renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.svg({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var SVG = Renderer.extend({\n    getEvents: function () {\n      var events = Renderer.prototype.getEvents.call(this);\n      events.zoomstart = this._onZoomStart;\n      return events;\n    },\n    _initContainer: function () {\n      this._container = create$2('svg'); // makes it possible to click through svg root; we'll reset it back in individual paths\n\n      this._container.setAttribute('pointer-events', 'none');\n\n      this._rootGroup = create$2('g');\n\n      this._container.appendChild(this._rootGroup);\n    },\n    _destroyContainer: function () {\n      remove(this._container);\n      off(this._container);\n      delete this._container;\n      delete this._rootGroup;\n      delete this._svgSize;\n    },\n    _onZoomStart: function () {\n      // Drag-then-pinch interactions might mess up the center and zoom.\n      // In this case, the easiest way to prevent this is re-do the renderer\n      //   bounds and padding when the zooming starts.\n      this._update();\n    },\n    _update: function () {\n      if (this._map._animatingZoom && this._bounds) {\n        return;\n      }\n\n      Renderer.prototype._update.call(this);\n\n      var b = this._bounds,\n          size = b.getSize(),\n          container = this._container; // set size of svg-container if changed\n\n      if (!this._svgSize || !this._svgSize.equals(size)) {\n        this._svgSize = size;\n        container.setAttribute('width', size.x);\n        container.setAttribute('height', size.y);\n      } // movement: update container viewBox so that we don't have to change coordinates of individual layers\n\n\n      setPosition(container, b.min);\n      container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));\n      this.fire('update');\n    },\n    // methods below are called by vector layers implementations\n    _initPath: function (layer) {\n      var path = layer._path = create$2('path'); // @namespace Path\n      // @option className: String = null\n      // Custom class name set on an element. Only for SVG renderer.\n\n      if (layer.options.className) {\n        addClass(path, layer.options.className);\n      }\n\n      if (layer.options.interactive) {\n        addClass(path, 'leaflet-interactive');\n      }\n\n      this._updateStyle(layer);\n\n      this._layers[stamp(layer)] = layer;\n    },\n    _addPath: function (layer) {\n      if (!this._rootGroup) {\n        this._initContainer();\n      }\n\n      this._rootGroup.appendChild(layer._path);\n\n      layer.addInteractiveTarget(layer._path);\n    },\n    _removePath: function (layer) {\n      remove(layer._path);\n      layer.removeInteractiveTarget(layer._path);\n      delete this._layers[stamp(layer)];\n    },\n    _updatePath: function (layer) {\n      layer._project();\n\n      layer._update();\n    },\n    _updateStyle: function (layer) {\n      var path = layer._path,\n          options = layer.options;\n\n      if (!path) {\n        return;\n      }\n\n      if (options.stroke) {\n        path.setAttribute('stroke', options.color);\n        path.setAttribute('stroke-opacity', options.opacity);\n        path.setAttribute('stroke-width', options.weight);\n        path.setAttribute('stroke-linecap', options.lineCap);\n        path.setAttribute('stroke-linejoin', options.lineJoin);\n\n        if (options.dashArray) {\n          path.setAttribute('stroke-dasharray', options.dashArray);\n        } else {\n          path.removeAttribute('stroke-dasharray');\n        }\n\n        if (options.dashOffset) {\n          path.setAttribute('stroke-dashoffset', options.dashOffset);\n        } else {\n          path.removeAttribute('stroke-dashoffset');\n        }\n      } else {\n        path.setAttribute('stroke', 'none');\n      }\n\n      if (options.fill) {\n        path.setAttribute('fill', options.fillColor || options.color);\n        path.setAttribute('fill-opacity', options.fillOpacity);\n        path.setAttribute('fill-rule', options.fillRule || 'evenodd');\n      } else {\n        path.setAttribute('fill', 'none');\n      }\n    },\n    _updatePoly: function (layer, closed) {\n      this._setPath(layer, pointsToPath(layer._parts, closed));\n    },\n    _updateCircle: function (layer) {\n      var p = layer._point,\n          r = Math.max(Math.round(layer._radius), 1),\n          r2 = Math.max(Math.round(layer._radiusY), 1) || r,\n          arc = 'a' + r + ',' + r2 + ' 0 1,0 '; // drawing a circle with two half-arcs\n\n      var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';\n\n      this._setPath(layer, d);\n    },\n    _setPath: function (layer, path) {\n      layer._path.setAttribute('d', path);\n    },\n    // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n    _bringToFront: function (layer) {\n      toFront(layer._path);\n    },\n    _bringToBack: function (layer) {\n      toBack(layer._path);\n    }\n  });\n\n  if (vml) {\n    SVG.include(vmlMixin);\n  } // @namespace SVG\n  // @factory L.svg(options?: Renderer options)\n  // Creates a SVG renderer with the given options.\n\n\n  function svg$1(options) {\n    return svg || vml ? new SVG(options) : null;\n  }\n\n  Map.include({\n    // @namespace Map; @method getRenderer(layer: Path): Renderer\n    // Returns the instance of `Renderer` that should be used to render the given\n    // `Path`. It will ensure that the `renderer` options of the map and paths\n    // are respected, and that the renderers do exist on the map.\n    getRenderer: function (layer) {\n      // @namespace Path; @option renderer: Renderer\n      // Use this specific instance of `Renderer` for this path. Takes\n      // precedence over the map's [default renderer](#map-renderer).\n      var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n\n      if (!renderer) {\n        renderer = this._renderer = this._createRenderer();\n      }\n\n      if (!this.hasLayer(renderer)) {\n        this.addLayer(renderer);\n      }\n\n      return renderer;\n    },\n    _getPaneRenderer: function (name) {\n      if (name === 'overlayPane' || name === undefined) {\n        return false;\n      }\n\n      var renderer = this._paneRenderers[name];\n\n      if (renderer === undefined) {\n        renderer = this._createRenderer({\n          pane: name\n        });\n        this._paneRenderers[name] = renderer;\n      }\n\n      return renderer;\n    },\n    _createRenderer: function (options) {\n      // @namespace Map; @option preferCanvas: Boolean = false\n      // Whether `Path`s should be rendered on a `Canvas` renderer.\n      // By default, all `Path`s are rendered in a `SVG` renderer.\n      return this.options.preferCanvas && canvas$1(options) || svg$1(options);\n    }\n  });\n  /*\n   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n   */\n\n  /*\n   * @class Rectangle\n   * @aka L.Rectangle\n   * @inherits Polygon\n   *\n   * A class for drawing rectangle overlays on a map. Extends `Polygon`.\n   *\n   * @example\n   *\n   * ```js\n   * // define rectangle geographical bounds\n   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];\n   *\n   * // create an orange rectangle\n   * L.rectangle(bounds, {color: \"#ff7800\", weight: 1}).addTo(map);\n   *\n   * // zoom the map to the rectangle bounds\n   * map.fitBounds(bounds);\n   * ```\n   *\n   */\n\n  var Rectangle = Polygon.extend({\n    initialize: function (latLngBounds, options) {\n      Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n    },\n    // @method setBounds(latLngBounds: LatLngBounds): this\n    // Redraws the rectangle with the passed bounds.\n    setBounds: function (latLngBounds) {\n      return this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n    },\n    _boundsToLatLngs: function (latLngBounds) {\n      latLngBounds = toLatLngBounds(latLngBounds);\n      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];\n    }\n  }); // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)\n\n  function rectangle(latLngBounds, options) {\n    return new Rectangle(latLngBounds, options);\n  }\n\n  SVG.create = create$2;\n  SVG.pointsToPath = pointsToPath;\n  GeoJSON.geometryToLayer = geometryToLayer;\n  GeoJSON.coordsToLatLng = coordsToLatLng;\n  GeoJSON.coordsToLatLngs = coordsToLatLngs;\n  GeoJSON.latLngToCoords = latLngToCoords;\n  GeoJSON.latLngsToCoords = latLngsToCoords;\n  GeoJSON.getFeature = getFeature;\n  GeoJSON.asFeature = asFeature;\n  /*\n   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map\n   * (zoom to a selected bounding box), enabled by default.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option boxZoom: Boolean = true\n    // Whether the map can be zoomed to a rectangular area specified by\n    // dragging the mouse while pressing the shift key.\n    boxZoom: true\n  });\n  var BoxZoom = Handler.extend({\n    initialize: function (map) {\n      this._map = map;\n      this._container = map._container;\n      this._pane = map._panes.overlayPane;\n      this._resetStateTimeout = 0;\n      map.on('unload', this._destroy, this);\n    },\n    addHooks: function () {\n      on(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    removeHooks: function () {\n      off(this._container, 'mousedown', this._onMouseDown, this);\n    },\n    moved: function () {\n      return this._moved;\n    },\n    _destroy: function () {\n      remove(this._pane);\n      delete this._pane;\n    },\n    _resetState: function () {\n      this._resetStateTimeout = 0;\n      this._moved = false;\n    },\n    _clearDeferredResetState: function () {\n      if (this._resetStateTimeout !== 0) {\n        clearTimeout(this._resetStateTimeout);\n        this._resetStateTimeout = 0;\n      }\n    },\n    _onMouseDown: function (e) {\n      if (!e.shiftKey || e.which !== 1 && e.button !== 1) {\n        return false;\n      } // Clear the deferred resetState if it hasn't executed yet, otherwise it\n      // will interrupt the interaction and orphan a box element in the container.\n\n\n      this._clearDeferredResetState();\n\n      this._resetState();\n\n      disableTextSelection();\n      disableImageDrag();\n      this._startPoint = this._map.mouseEventToContainerPoint(e);\n      on(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseMove: function (e) {\n      if (!this._moved) {\n        this._moved = true;\n        this._box = create$1('div', 'leaflet-zoom-box', this._container);\n        addClass(this._container, 'leaflet-crosshair');\n\n        this._map.fire('boxzoomstart');\n      }\n\n      this._point = this._map.mouseEventToContainerPoint(e);\n      var bounds = new Bounds(this._point, this._startPoint),\n          size = bounds.getSize();\n      setPosition(this._box, bounds.min);\n      this._box.style.width = size.x + 'px';\n      this._box.style.height = size.y + 'px';\n    },\n    _finish: function () {\n      if (this._moved) {\n        remove(this._box);\n        removeClass(this._container, 'leaflet-crosshair');\n      }\n\n      enableTextSelection();\n      enableImageDrag();\n      off(document, {\n        contextmenu: stop,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseUp: function (e) {\n      if (e.which !== 1 && e.button !== 1) {\n        return;\n      }\n\n      this._finish();\n\n      if (!this._moved) {\n        return;\n      } // Postpone to next JS tick so internal click event handling\n      // still see it as \"moved\".\n\n\n      this._clearDeferredResetState();\n\n      this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);\n      var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));\n\n      this._map.fitBounds(bounds).fire('boxzoomend', {\n        boxZoomBounds: bounds\n      });\n    },\n    _onKeyDown: function (e) {\n      if (e.keyCode === 27) {\n        this._finish();\n      }\n    }\n  }); // @section Handlers\n  // @property boxZoom: Handler\n  // Box (shift-drag with mouse) zoom handler.\n\n  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);\n  /*\n   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option doubleClickZoom: Boolean|String = true\n    // Whether the map can be zoomed in by double clicking on it and\n    // zoomed out by double clicking while holding shift. If passed\n    // `'center'`, double-click zoom will zoom to the center of the\n    //  view regardless of where the mouse was.\n    doubleClickZoom: true\n  });\n  var DoubleClickZoom = Handler.extend({\n    addHooks: function () {\n      this._map.on('dblclick', this._onDoubleClick, this);\n    },\n    removeHooks: function () {\n      this._map.off('dblclick', this._onDoubleClick, this);\n    },\n    _onDoubleClick: function (e) {\n      var map = this._map,\n          oldZoom = map.getZoom(),\n          delta = map.options.zoomDelta,\n          zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;\n\n      if (map.options.doubleClickZoom === 'center') {\n        map.setZoom(zoom);\n      } else {\n        map.setZoomAround(e.containerPoint, zoom);\n      }\n    }\n  }); // @section Handlers\n  //\n  // Map properties include interaction handlers that allow you to control\n  // interaction behavior in runtime, enabling or disabling certain features such\n  // as dragging or touch zoom (see `Handler` methods). For example:\n  //\n  // ```js\n  // map.doubleClickZoom.disable();\n  // ```\n  //\n  // @property doubleClickZoom: Handler\n  // Double click zoom handler.\n\n  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);\n  /*\n   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @option dragging: Boolean = true\n    // Whether the map be draggable with mouse/touch or not.\n    dragging: true,\n    // @section Panning Inertia Options\n    // @option inertia: Boolean = *\n    // If enabled, panning of the map will have an inertia effect where\n    // the map builds momentum while dragging and continues moving in\n    // the same direction for some time. Feels especially nice on touch\n    // devices. Enabled by default unless running on old Android devices.\n    inertia: !android23,\n    // @option inertiaDeceleration: Number = 3000\n    // The rate with which the inertial movement slows down, in pixels/second².\n    inertiaDeceleration: 3400,\n    // px/s^2\n    // @option inertiaMaxSpeed: Number = Infinity\n    // Max speed of the inertial movement, in pixels/second.\n    inertiaMaxSpeed: Infinity,\n    // px/s\n    // @option easeLinearity: Number = 0.2\n    easeLinearity: 0.2,\n    // TODO refactor, move to CRS\n    // @option worldCopyJump: Boolean = false\n    // With this option enabled, the map tracks when you pan to another \"copy\"\n    // of the world and seamlessly jumps to the original one so that all overlays\n    // like markers and vector layers are still visible.\n    worldCopyJump: false,\n    // @option maxBoundsViscosity: Number = 0.0\n    // If `maxBounds` is set, this option will control how solid the bounds\n    // are when dragging the map around. The default value of `0.0` allows the\n    // user to drag outside the bounds at normal speed, higher values will\n    // slow down map dragging outside bounds, and `1.0` makes the bounds fully\n    // solid, preventing the user from dragging outside the bounds.\n    maxBoundsViscosity: 0.0\n  });\n  var Drag = Handler.extend({\n    addHooks: function () {\n      if (!this._draggable) {\n        var map = this._map;\n        this._draggable = new Draggable(map._mapPane, map._container);\n\n        this._draggable.on({\n          dragstart: this._onDragStart,\n          drag: this._onDrag,\n          dragend: this._onDragEnd\n        }, this);\n\n        this._draggable.on('predrag', this._onPreDragLimit, this);\n\n        if (map.options.worldCopyJump) {\n          this._draggable.on('predrag', this._onPreDragWrap, this);\n\n          map.on('zoomend', this._onZoomEnd, this);\n          map.whenReady(this._onZoomEnd, this);\n        }\n      }\n\n      addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');\n\n      this._draggable.enable();\n\n      this._positions = [];\n      this._times = [];\n    },\n    removeHooks: function () {\n      removeClass(this._map._container, 'leaflet-grab');\n      removeClass(this._map._container, 'leaflet-touch-drag');\n\n      this._draggable.disable();\n    },\n    moved: function () {\n      return this._draggable && this._draggable._moved;\n    },\n    moving: function () {\n      return this._draggable && this._draggable._moving;\n    },\n    _onDragStart: function () {\n      var map = this._map;\n\n      map._stop();\n\n      if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n        var bounds = toLatLngBounds(this._map.options.maxBounds);\n        this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));\n        this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n      } else {\n        this._offsetLimit = null;\n      }\n\n      map.fire('movestart').fire('dragstart');\n\n      if (map.options.inertia) {\n        this._positions = [];\n        this._times = [];\n      }\n    },\n    _onDrag: function (e) {\n      if (this._map.options.inertia) {\n        var time = this._lastTime = +new Date(),\n            pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n\n        this._positions.push(pos);\n\n        this._times.push(time);\n\n        this._prunePositions(time);\n      }\n\n      this._map.fire('move', e).fire('drag', e);\n    },\n    _prunePositions: function (time) {\n      while (this._positions.length > 1 && time - this._times[0] > 50) {\n        this._positions.shift();\n\n        this._times.shift();\n      }\n    },\n    _onZoomEnd: function () {\n      var pxCenter = this._map.getSize().divideBy(2),\n          pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n      this._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n    },\n    _viscousLimit: function (value, threshold) {\n      return value - (value - threshold) * this._viscosity;\n    },\n    _onPreDragLimit: function () {\n      if (!this._viscosity || !this._offsetLimit) {\n        return;\n      }\n\n      var offset = this._draggable._newPos.subtract(this._draggable._startPos);\n\n      var limit = this._offsetLimit;\n\n      if (offset.x < limit.min.x) {\n        offset.x = this._viscousLimit(offset.x, limit.min.x);\n      }\n\n      if (offset.y < limit.min.y) {\n        offset.y = this._viscousLimit(offset.y, limit.min.y);\n      }\n\n      if (offset.x > limit.max.x) {\n        offset.x = this._viscousLimit(offset.x, limit.max.x);\n      }\n\n      if (offset.y > limit.max.y) {\n        offset.y = this._viscousLimit(offset.y, limit.max.y);\n      }\n\n      this._draggable._newPos = this._draggable._startPos.add(offset);\n    },\n    _onPreDragWrap: function () {\n      // TODO refactor to be able to adjust map pane position after zoom\n      var worldWidth = this._worldWidth,\n          halfWidth = Math.round(worldWidth / 2),\n          dx = this._initialWorldOffset,\n          x = this._draggable._newPos.x,\n          newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n          newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n          newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n      this._draggable._absPos = this._draggable._newPos.clone();\n      this._draggable._newPos.x = newX;\n    },\n    _onDragEnd: function (e) {\n      var map = this._map,\n          options = map.options,\n          noInertia = !options.inertia || this._times.length < 2;\n      map.fire('dragend', e);\n\n      if (noInertia) {\n        map.fire('moveend');\n      } else {\n        this._prunePositions(+new Date());\n\n        var direction = this._lastPos.subtract(this._positions[0]),\n            duration = (this._lastTime - this._times[0]) / 1000,\n            ease = options.easeLinearity,\n            speedVector = direction.multiplyBy(ease / duration),\n            speed = speedVector.distanceTo([0, 0]),\n            limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n            limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n            decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n            offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n        if (!offset.x && !offset.y) {\n          map.fire('moveend');\n        } else {\n          offset = map._limitOffset(offset, map.options.maxBounds);\n          requestAnimFrame(function () {\n            map.panBy(offset, {\n              duration: decelerationDuration,\n              easeLinearity: ease,\n              noMoveStart: true,\n              animate: true\n            });\n          });\n        }\n      }\n    }\n  }); // @section Handlers\n  // @property dragging: Handler\n  // Map dragging handler (by both mouse and touch).\n\n  Map.addInitHook('addHandler', 'dragging', Drag);\n  /*\n   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n   */\n  // @namespace Map\n  // @section Keyboard Navigation Options\n\n  Map.mergeOptions({\n    // @option keyboard: Boolean = true\n    // Makes the map focusable and allows users to navigate the map with keyboard\n    // arrows and `+`/`-` keys.\n    keyboard: true,\n    // @option keyboardPanDelta: Number = 80\n    // Amount of pixels to pan when pressing an arrow key.\n    keyboardPanDelta: 80\n  });\n  var Keyboard = Handler.extend({\n    keyCodes: {\n      left: [37],\n      right: [39],\n      down: [40],\n      up: [38],\n      zoomIn: [187, 107, 61, 171],\n      zoomOut: [189, 109, 54, 173]\n    },\n    initialize: function (map) {\n      this._map = map;\n\n      this._setPanDelta(map.options.keyboardPanDelta);\n\n      this._setZoomDelta(map.options.zoomDelta);\n    },\n    addHooks: function () {\n      var container = this._map._container; // make the container focusable by tabbing\n\n      if (container.tabIndex <= 0) {\n        container.tabIndex = '0';\n      }\n\n      on(container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n\n      this._map.on({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    removeHooks: function () {\n      this._removeHooks();\n\n      off(this._map._container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this);\n\n      this._map.off({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    _onMouseDown: function () {\n      if (this._focused) {\n        return;\n      }\n\n      var body = document.body,\n          docEl = document.documentElement,\n          top = body.scrollTop || docEl.scrollTop,\n          left = body.scrollLeft || docEl.scrollLeft;\n\n      this._map._container.focus();\n\n      window.scrollTo(left, top);\n    },\n    _onFocus: function () {\n      this._focused = true;\n\n      this._map.fire('focus');\n    },\n    _onBlur: function () {\n      this._focused = false;\n\n      this._map.fire('blur');\n    },\n    _setPanDelta: function (panDelta) {\n      var keys = this._panKeys = {},\n          codes = this.keyCodes,\n          i,\n          len;\n\n      for (i = 0, len = codes.left.length; i < len; i++) {\n        keys[codes.left[i]] = [-1 * panDelta, 0];\n      }\n\n      for (i = 0, len = codes.right.length; i < len; i++) {\n        keys[codes.right[i]] = [panDelta, 0];\n      }\n\n      for (i = 0, len = codes.down.length; i < len; i++) {\n        keys[codes.down[i]] = [0, panDelta];\n      }\n\n      for (i = 0, len = codes.up.length; i < len; i++) {\n        keys[codes.up[i]] = [0, -1 * panDelta];\n      }\n    },\n    _setZoomDelta: function (zoomDelta) {\n      var keys = this._zoomKeys = {},\n          codes = this.keyCodes,\n          i,\n          len;\n\n      for (i = 0, len = codes.zoomIn.length; i < len; i++) {\n        keys[codes.zoomIn[i]] = zoomDelta;\n      }\n\n      for (i = 0, len = codes.zoomOut.length; i < len; i++) {\n        keys[codes.zoomOut[i]] = -zoomDelta;\n      }\n    },\n    _addHooks: function () {\n      on(document, 'keydown', this._onKeyDown, this);\n    },\n    _removeHooks: function () {\n      off(document, 'keydown', this._onKeyDown, this);\n    },\n    _onKeyDown: function (e) {\n      if (e.altKey || e.ctrlKey || e.metaKey) {\n        return;\n      }\n\n      var key = e.keyCode,\n          map = this._map,\n          offset;\n\n      if (key in this._panKeys) {\n        if (!map._panAnim || !map._panAnim._inProgress) {\n          offset = this._panKeys[key];\n\n          if (e.shiftKey) {\n            offset = toPoint(offset).multiplyBy(3);\n          }\n\n          map.panBy(offset);\n\n          if (map.options.maxBounds) {\n            map.panInsideBounds(map.options.maxBounds);\n          }\n        }\n      } else if (key in this._zoomKeys) {\n        map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n      } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {\n        map.closePopup();\n      } else {\n        return;\n      }\n\n      stop(e);\n    }\n  }); // @section Handlers\n  // @section Handlers\n  // @property keyboard: Handler\n  // Keyboard navigation handler.\n\n  Map.addInitHook('addHandler', 'keyboard', Keyboard);\n  /*\n   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @section Mousewheel options\n    // @option scrollWheelZoom: Boolean|String = true\n    // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\n    // it will zoom to the center of the view regardless of where the mouse was.\n    scrollWheelZoom: true,\n    // @option wheelDebounceTime: Number = 40\n    // Limits the rate at which a wheel can fire (in milliseconds). By default\n    // user can't zoom via wheel more often than once per 40 ms.\n    wheelDebounceTime: 40,\n    // @option wheelPxPerZoomLevel: Number = 60\n    // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\n    // mean a change of one full zoom level. Smaller values will make wheel-zooming\n    // faster (and vice versa).\n    wheelPxPerZoomLevel: 60\n  });\n  var ScrollWheelZoom = Handler.extend({\n    addHooks: function () {\n      on(this._map._container, 'mousewheel', this._onWheelScroll, this);\n      this._delta = 0;\n    },\n    removeHooks: function () {\n      off(this._map._container, 'mousewheel', this._onWheelScroll, this);\n    },\n    _onWheelScroll: function (e) {\n      var delta = getWheelDelta(e);\n      var debounce = this._map.options.wheelDebounceTime;\n      this._delta += delta;\n      this._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n      if (!this._startTime) {\n        this._startTime = +new Date();\n      }\n\n      var left = Math.max(debounce - (+new Date() - this._startTime), 0);\n      clearTimeout(this._timer);\n      this._timer = setTimeout(bind(this._performZoom, this), left);\n      stop(e);\n    },\n    _performZoom: function () {\n      var map = this._map,\n          zoom = map.getZoom(),\n          snap = this._map.options.zoomSnap || 0;\n\n      map._stop(); // stop panning and fly animations if any\n      // map the delta with a sigmoid function to -4..4 range leaning on -1..1\n\n\n      var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),\n          d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,\n          d4 = snap ? Math.ceil(d3 / snap) * snap : d3,\n          delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;\n      this._delta = 0;\n      this._startTime = null;\n\n      if (!delta) {\n        return;\n      }\n\n      if (map.options.scrollWheelZoom === 'center') {\n        map.setZoom(zoom + delta);\n      } else {\n        map.setZoomAround(this._lastMousePos, zoom + delta);\n      }\n    }\n  }); // @section Handlers\n  // @property scrollWheelZoom: Handler\n  // Scroll wheel zoom handler.\n\n  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);\n  /*\n   * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option tap: Boolean = true\n    // Enables mobile hacks for supporting instant taps (fixing 200ms click\n    // delay on iOS/Android) and touch holds (fired as `contextmenu` events).\n    tap: true,\n    // @option tapTolerance: Number = 15\n    // The max number of pixels a user can shift his finger during touch\n    // for it to be considered a valid tap.\n    tapTolerance: 15\n  });\n  var Tap = Handler.extend({\n    addHooks: function () {\n      on(this._map._container, 'touchstart', this._onDown, this);\n    },\n    removeHooks: function () {\n      off(this._map._container, 'touchstart', this._onDown, this);\n    },\n    _onDown: function (e) {\n      if (!e.touches) {\n        return;\n      }\n\n      preventDefault(e);\n      this._fireClick = true; // don't simulate click or track longpress if more than 1 touch\n\n      if (e.touches.length > 1) {\n        this._fireClick = false;\n        clearTimeout(this._holdTimeout);\n        return;\n      }\n\n      var first = e.touches[0],\n          el = first.target;\n      this._startPos = this._newPos = new Point(first.clientX, first.clientY); // if touching a link, highlight it\n\n      if (el.tagName && el.tagName.toLowerCase() === 'a') {\n        addClass(el, 'leaflet-active');\n      } // simulate long hold but setting a timeout\n\n\n      this._holdTimeout = setTimeout(bind(function () {\n        if (this._isTapValid()) {\n          this._fireClick = false;\n\n          this._onUp();\n\n          this._simulateEvent('contextmenu', first);\n        }\n      }, this), 1000);\n\n      this._simulateEvent('mousedown', first);\n\n      on(document, {\n        touchmove: this._onMove,\n        touchend: this._onUp\n      }, this);\n    },\n    _onUp: function (e) {\n      clearTimeout(this._holdTimeout);\n      off(document, {\n        touchmove: this._onMove,\n        touchend: this._onUp\n      }, this);\n\n      if (this._fireClick && e && e.changedTouches) {\n        var first = e.changedTouches[0],\n            el = first.target;\n\n        if (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n          removeClass(el, 'leaflet-active');\n        }\n\n        this._simulateEvent('mouseup', first); // simulate click if the touch didn't move too much\n\n\n        if (this._isTapValid()) {\n          this._simulateEvent('click', first);\n        }\n      }\n    },\n    _isTapValid: function () {\n      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n    },\n    _onMove: function (e) {\n      var first = e.touches[0];\n      this._newPos = new Point(first.clientX, first.clientY);\n\n      this._simulateEvent('mousemove', first);\n    },\n    _simulateEvent: function (type, e) {\n      var simulatedEvent = document.createEvent('MouseEvents');\n      simulatedEvent._simulated = true;\n      e.target._simulatedClick = true;\n      simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);\n      e.target.dispatchEvent(simulatedEvent);\n    }\n  }); // @section Handlers\n  // @property tap: Handler\n  // Mobile touch hacks (quick tap and touch hold) handler.\n\n  if (touch && !pointer) {\n    Map.addInitHook('addHandler', 'tap', Tap);\n  }\n  /*\n   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n   */\n  // @namespace Map\n  // @section Interaction Options\n\n\n  Map.mergeOptions({\n    // @section Touch interaction options\n    // @option touchZoom: Boolean|String = *\n    // Whether the map can be zoomed by touch-dragging with two fingers. If\n    // passed `'center'`, it will zoom to the center of the view regardless of\n    // where the touch events (fingers) were. Enabled for touch-capable web\n    // browsers except for old Androids.\n    touchZoom: touch && !android23,\n    // @option bounceAtZoomLimits: Boolean = true\n    // Set it to false if you don't want the map to zoom beyond min/max zoom\n    // and then bounce back when pinch-zooming.\n    bounceAtZoomLimits: true\n  });\n  var TouchZoom = Handler.extend({\n    addHooks: function () {\n      addClass(this._map._container, 'leaflet-touch-zoom');\n      on(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    removeHooks: function () {\n      removeClass(this._map._container, 'leaflet-touch-zoom');\n      off(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n    _onTouchStart: function (e) {\n      var map = this._map;\n\n      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {\n        return;\n      }\n\n      var p1 = map.mouseEventToContainerPoint(e.touches[0]),\n          p2 = map.mouseEventToContainerPoint(e.touches[1]);\n      this._centerPoint = map.getSize()._divideBy(2);\n      this._startLatLng = map.containerPointToLatLng(this._centerPoint);\n\n      if (map.options.touchZoom !== 'center') {\n        this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n      }\n\n      this._startDist = p1.distanceTo(p2);\n      this._startZoom = map.getZoom();\n      this._moved = false;\n      this._zooming = true;\n\n      map._stop();\n\n      on(document, 'touchmove', this._onTouchMove, this);\n      on(document, 'touchend', this._onTouchEnd, this);\n      preventDefault(e);\n    },\n    _onTouchMove: function (e) {\n      if (!e.touches || e.touches.length !== 2 || !this._zooming) {\n        return;\n      }\n\n      var map = this._map,\n          p1 = map.mouseEventToContainerPoint(e.touches[0]),\n          p2 = map.mouseEventToContainerPoint(e.touches[1]),\n          scale = p1.distanceTo(p2) / this._startDist;\n\n      this._zoom = map.getScaleZoom(scale, this._startZoom);\n\n      if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {\n        this._zoom = map._limitZoom(this._zoom);\n      }\n\n      if (map.options.touchZoom === 'center') {\n        this._center = this._startLatLng;\n\n        if (scale === 1) {\n          return;\n        }\n      } else {\n        // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n        var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n\n        if (scale === 1 && delta.x === 0 && delta.y === 0) {\n          return;\n        }\n\n        this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);\n      }\n\n      if (!this._moved) {\n        map._moveStart(true, false);\n\n        this._moved = true;\n      }\n\n      cancelAnimFrame(this._animRequest);\n      var moveFn = bind(map._move, map, this._center, this._zoom, {\n        pinch: true,\n        round: false\n      });\n      this._animRequest = requestAnimFrame(moveFn, this, true);\n      preventDefault(e);\n    },\n    _onTouchEnd: function () {\n      if (!this._moved || !this._zooming) {\n        this._zooming = false;\n        return;\n      }\n\n      this._zooming = false;\n      cancelAnimFrame(this._animRequest);\n      off(document, 'touchmove', this._onTouchMove);\n      off(document, 'touchend', this._onTouchEnd); // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\n\n      if (this._map.options.zoomAnimation) {\n        this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\n      } else {\n        this._map._resetView(this._center, this._map._limitZoom(this._zoom));\n      }\n    }\n  }); // @section Handlers\n  // @property touchZoom: Handler\n  // Touch zoom handler.\n\n  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);\n  Map.BoxZoom = BoxZoom;\n  Map.DoubleClickZoom = DoubleClickZoom;\n  Map.Drag = Drag;\n  Map.Keyboard = Keyboard;\n  Map.ScrollWheelZoom = ScrollWheelZoom;\n  Map.Tap = Tap;\n  Map.TouchZoom = TouchZoom;\n  Object.freeze = freeze;\n  exports.version = version;\n  exports.Control = Control;\n  exports.control = control;\n  exports.Browser = Browser;\n  exports.Evented = Evented;\n  exports.Mixin = Mixin;\n  exports.Util = Util;\n  exports.Class = Class;\n  exports.Handler = Handler;\n  exports.extend = extend;\n  exports.bind = bind;\n  exports.stamp = stamp;\n  exports.setOptions = setOptions;\n  exports.DomEvent = DomEvent;\n  exports.DomUtil = DomUtil;\n  exports.PosAnimation = PosAnimation;\n  exports.Draggable = Draggable;\n  exports.LineUtil = LineUtil;\n  exports.PolyUtil = PolyUtil;\n  exports.Point = Point;\n  exports.point = toPoint;\n  exports.Bounds = Bounds;\n  exports.bounds = toBounds;\n  exports.Transformation = Transformation;\n  exports.transformation = toTransformation;\n  exports.Projection = index;\n  exports.LatLng = LatLng;\n  exports.latLng = toLatLng;\n  exports.LatLngBounds = LatLngBounds;\n  exports.latLngBounds = toLatLngBounds;\n  exports.CRS = CRS;\n  exports.GeoJSON = GeoJSON;\n  exports.geoJSON = geoJSON;\n  exports.geoJson = geoJson;\n  exports.Layer = Layer;\n  exports.LayerGroup = LayerGroup;\n  exports.layerGroup = layerGroup;\n  exports.FeatureGroup = FeatureGroup;\n  exports.featureGroup = featureGroup;\n  exports.ImageOverlay = ImageOverlay;\n  exports.imageOverlay = imageOverlay;\n  exports.VideoOverlay = VideoOverlay;\n  exports.videoOverlay = videoOverlay;\n  exports.SVGOverlay = SVGOverlay;\n  exports.svgOverlay = svgOverlay;\n  exports.DivOverlay = DivOverlay;\n  exports.Popup = Popup;\n  exports.popup = popup;\n  exports.Tooltip = Tooltip;\n  exports.tooltip = tooltip;\n  exports.Icon = Icon;\n  exports.icon = icon;\n  exports.DivIcon = DivIcon;\n  exports.divIcon = divIcon;\n  exports.Marker = Marker;\n  exports.marker = marker;\n  exports.TileLayer = TileLayer;\n  exports.tileLayer = tileLayer;\n  exports.GridLayer = GridLayer;\n  exports.gridLayer = gridLayer;\n  exports.SVG = SVG;\n  exports.svg = svg$1;\n  exports.Renderer = Renderer;\n  exports.Canvas = Canvas;\n  exports.canvas = canvas$1;\n  exports.Path = Path;\n  exports.CircleMarker = CircleMarker;\n  exports.circleMarker = circleMarker;\n  exports.Circle = Circle;\n  exports.circle = circle;\n  exports.Polyline = Polyline;\n  exports.polyline = polyline;\n  exports.Polygon = Polygon;\n  exports.polygon = polygon;\n  exports.Rectangle = Rectangle;\n  exports.rectangle = rectangle;\n  exports.Map = Map;\n  exports.map = createMap;\n  var oldL = window.L;\n\n  exports.noConflict = function () {\n    window.L = oldL;\n    return this;\n  }; // Always export us to window global (see #2364)\n\n\n  window.L = exports;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvVXRpbC5qcz8yZTY0Iiwid2VicGFjazovLy8uLi9zcmMvY29yZS9DbGFzcy5qcz8wMWFjIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9FdmVudHMuanM/MTM2ZiIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlb21ldHJ5L1BvaW50LmpzPzE1NDAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW9tZXRyeS9Cb3VuZHMuanM/MWM3OSIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9MYXRMbmdCb3VuZHMuanM/YjU3YyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9MYXRMbmcuanM/NWI2NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9jcnMvQ1JTLmpzP2IyY2QiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW8vY3JzL0NSUy5FYXJ0aC5qcz8xMDE5Iiwid2VicGFjazovLy8uLi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5qcz8xZTVlIiwid2VicGFjazovLy8uLi9zcmMvZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24uanM/YzI1MyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9jcnMvQ1JTLkVQU0czODU3LmpzP2YyMmUiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci92ZWN0b3IvU1ZHLlV0aWwuanM/OTBjMSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvQnJvd3Nlci5qcz83ZGUzIiwid2VicGFjazovLy8uLi9zcmMvZG9tL0RvbUV2ZW50LlBvaW50ZXIuanM/ODY0NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9Eb21FdmVudC5Eb3VibGVUYXAuanM/ZTc2ZCIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9Eb21VdGlsLmpzPzdjOTMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9kb20vRG9tRXZlbnQuanM/MWVhYyIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9Qb3NBbmltYXRpb24uanM/YjZiMSIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9NYXAuanM/NzNlYSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5qcz81MjkxIiwid2VicGFjazovLy8uLi9zcmMvY29udHJvbC9Db250cm9sLkxheWVycy5qcz82NGQ0Iiwid2VicGFjazovLy8uLi9zcmMvY29udHJvbC9Db250cm9sLlpvb20uanM/MTU1MCIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbnRyb2wvQ29udHJvbC5TY2FsZS5qcz84YzY0Iiwid2VicGFjazovLy8uLi9zcmMvY29udHJvbC9Db250cm9sLkF0dHJpYnV0aW9uLmpzPzJjZDciLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb250cm9sL2luZGV4LmpzPzBjYTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL0hhbmRsZXIuanM/NGU1ZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvaW5kZXguanM/ZTBlMCIsIndlYnBhY2s6Ly8vLi4vc3JjL2RvbS9EcmFnZ2FibGUuanM/Y2NlYyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlb21ldHJ5L0xpbmVVdGlsLmpzPzE4N2EiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW9tZXRyeS9Qb2x5VXRpbC5qcz9kNTdlIiwid2VicGFjazovLy8uLi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQuanM/OWQ4NSIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3IuanM/YjJiYyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9wcm9qZWN0aW9uL2luZGV4LmpzP2ZkYTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZW8vY3JzL0NSUy5FUFNHMzM5NS5qcz8wYzNiIiwid2VicGFjazovLy8uLi9zcmMvZ2VvL2Nycy9DUlMuRVBTRzQzMjYuanM/ZDk4MyIsIndlYnBhY2s6Ly8vLi4vc3JjL2dlby9jcnMvQ1JTLlNpbXBsZS5qcz85YmU4Iiwid2VicGFjazovLy8uLi9zcmMvZ2VvL2Nycy9pbmRleC5qcz82NmQ5Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvTGF5ZXIuanM/NjcwMyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0xheWVyR3JvdXAuanM/N2Y2NCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0ZlYXR1cmVHcm91cC5qcz8yNDRhIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvbWFya2VyL0ljb24uanM/MDU4OCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL21hcmtlci9JY29uLkRlZmF1bHQuanM/MjdlNyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL21hcmtlci9NYXJrZXIuRHJhZy5qcz8yZmI1Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvbWFya2VyL01hcmtlci5qcz8zZGQyIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1BhdGguanM/ZjY2YSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGVNYXJrZXIuanM/MjQ4ZiIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGUuanM/OWQxYSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9Qb2x5bGluZS5qcz85YzM3Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1BvbHlnb24uanM/MjcyNyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0dlb0pTT04uanM/YWFlYSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL0ltYWdlT3ZlcmxheS5qcz8wMTg5Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvVmlkZW9PdmVybGF5LmpzPzAzZTgiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9TVkdPdmVybGF5LmpzPzNjZjMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9EaXZPdmVybGF5LmpzPzAwMjMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9Qb3B1cC5qcz84ZTExIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvVG9vbHRpcC5qcz8wZGIyIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvbWFya2VyL0Rpdkljb24uanM/ZTBkZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL21hcmtlci9pbmRleC5qcz84ZjM4Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdGlsZS9HcmlkTGF5ZXIuanM/Mzg4ZSIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzPzI2MjAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci90aWxlL1RpbGVMYXllci5XTVMuanM/ZjllNiIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3RpbGUvaW5kZXguanM/NDI4YyIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5qcz8xMGVlIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL0NhbnZhcy5qcz9iOWViIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1NWRy5WTUwuanM/YzkzNCIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9TVkcuanM/Zjg0YiIsIndlYnBhY2s6Ly8vLi4vc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5nZXRSZW5kZXJlci5qcz81ZmE3Iiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL1JlY3RhbmdsZS5qcz8wZDdhIiwid2VicGFjazovLy8uLi9zcmMvbGF5ZXIvdmVjdG9yL2luZGV4LmpzPzFlMTMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9sYXllci9pbmRleC5qcz8xMjIyIiwid2VicGFjazovLy8uLi9zcmMvbWFwL2hhbmRsZXIvTWFwLkJveFpvb20uanM/ZTljYyIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20uanM/MDJkNSIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5EcmFnLmpzP2JjZDAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9tYXAvaGFuZGxlci9NYXAuS2V5Ym9hcmQuanM/M2YzYiIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20uanM/MWYxNCIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5UYXAuanM/OTFiZCIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9oYW5kbGVyL01hcC5Ub3VjaFpvb20uanM/ZjY2YSIsIndlYnBhY2s6Ly8vLi4vc3JjL21hcC9pbmRleC5qcz8yMDUyIiwid2VicGFjazovLy8uLi9zcmMvTGVhZmxldC5qcz82YzExIl0sIm5hbWVzIjpbIlV0aWwuY3JlYXRlIiwiVXRpbC5leHRlbmQiLCJVdGlsLmlzQXJyYXkiLCJVdGlsLnNwbGl0V29yZHMiLCJVdGlsLmZhbHNlRm4iLCJVdGlsLmJpbmQiLCJVdGlsLnN0YW1wIiwiVXRpbC5mb3JtYXROdW0iLCJVdGlsLndyYXBOdW0iLCJCcm93c2VyLnN2ZyIsInN0eWxlIiwiQnJvd3Nlci5tc1BvaW50ZXIiLCJEb21FdmVudC5wcmV2ZW50RGVmYXVsdCIsIkJyb3dzZXIucG9pbnRlciIsInRvdWNoIiwiQnJvd3Nlci5lZGdlIiwiQnJvd3Nlci5wYXNzaXZlRXZlbnRzIiwiY3JlYXRlIiwiVXRpbC50cmltIiwiQnJvd3Nlci5pZTNkIiwiQnJvd3Nlci5hbnkzZCIsIkRvbUV2ZW50Lm9uIiwiRG9tRXZlbnQub2ZmIiwiQnJvd3Nlci50b3VjaCIsIkJyb3dzZXIuY2hyb21lIiwiQnJvd3Nlci5hbmRyb2lkIiwiQnJvd3Nlci53aW4iLCJCcm93c2VyLmdlY2tvIiwiRG9tVXRpbC5nZXRQb3NpdGlvbiIsIlV0aWwucmVxdWVzdEFuaW1GcmFtZSIsIkRvbVV0aWwuc2V0UG9zaXRpb24iLCJVdGlsLmNhbmNlbEFuaW1GcmFtZSIsIlV0aWwuc2V0T3B0aW9ucyIsIkRvbVV0aWwuVFJBTlNJVElPTiIsIkJyb3dzZXIubW9iaWxlT3BlcmEiLCJEb21VdGlsLlRSQU5TSVRJT05fRU5EIiwiRG9tVXRpbC5hZGRDbGFzcyIsIkRvbVV0aWwucmVtb3ZlIiwiRG9tVXRpbC5jcmVhdGUiLCJEb21FdmVudC5nZXRNb3VzZVBvc2l0aW9uIiwiRG9tVXRpbC5nZXQiLCJCcm93c2VyLnJldGluYSIsIkJyb3dzZXIuaWVsdDkiLCJCcm93c2VyLnNhZmFyaSIsIkRvbVV0aWwuZ2V0U3R5bGUiLCJyZW1vdmUiLCJEb21FdmVudC5pc0V4dGVybmFsVGFyZ2V0IiwiRG9tRXZlbnQuc2tpcHBlZCIsIkRvbVV0aWwucHJldmVudE91dGxpbmUiLCJVdGlsLmluZGV4T2YiLCJEb21VdGlsLnJlbW92ZUNsYXNzIiwiRG9tVXRpbC5UUkFOU0ZPUk0iLCJEb21VdGlsLnNldFRyYW5zZm9ybSIsIkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uIiwiRG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uIiwiRG9tRXZlbnQuc3RvcCIsIkRvbVV0aWwuZW1wdHkiLCJwcmV2ZW50T3V0bGluZSIsIkRvbVV0aWwuaGFzQ2xhc3MiLCJEb21VdGlsLmRpc2FibGVJbWFnZURyYWciLCJEb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uIiwiRG9tVXRpbC5nZXRTaXplZFBhcmVudE5vZGUiLCJEb21VdGlsLmdldFNjYWxlIiwiRG9tVXRpbC5lbmFibGVJbWFnZURyYWciLCJEb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24iLCJMaW5lVXRpbC5fZ2V0Qml0Q29kZSIsIkxpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uIiwicG9pbnQiLCJsYXRMbmciLCJEb21VdGlsLnNldE9wYWNpdHkiLCJMaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJMaW5lVXRpbC5pc0ZsYXQiLCJMaW5lVXRpbC5jbGlwU2VnbWVudCIsIkxpbmVVdGlsLnNpbXBsaWZ5IiwiTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZSIsIkxpbmVVdGlsLl9mbGF0IiwiUG9seVV0aWwuY2xpcFBvbHlnb24iLCJEb21VdGlsLnRvRnJvbnQiLCJEb21VdGlsLnRvQmFjayIsIkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbiIsIkJyb3dzZXIubW9iaWxlIiwiVXRpbC50aHJvdHRsZSIsImxhdExuZ0JvdW5kcyIsIkJyb3dzZXIuYW5kcm9pZDIzIiwiVXRpbC50ZW1wbGF0ZSIsIlV0aWwuZW1wdHlJbWFnZVVybCIsIkJyb3dzZXIuYW5kcm9pZFN0b2NrIiwiRG9tRXZlbnQuZmFrZVN0b3AiLCJjYW52YXMiLCJCcm93c2VyLmNhbnZhcyIsIkJyb3dzZXIudm1sIiwic3ZnIiwiRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7QUFNTyxNQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBcEI7O0FBQ1AsUUFBTSxDQUFDLE1BQVAsR0FBZ0IsVUFBVSxHQUFWLEVBQWU7QUFBRSxXQUFPLEdBQVA7QUFBYSxHQUE5QyxDOzs7O0FBSU8sV0FBUyxNQUFULENBQWdCLElBQWhCLEVBQXNCO0FBQzVCLFFBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxHQUFWLEVBQWUsR0FBZjs7QUFFQSxTQUFLLENBQUMsR0FBRyxDQUFKLEVBQU8sR0FBRyxHQUFHLFNBQVMsQ0FBQyxNQUE1QixFQUFvQyxDQUFDLEdBQUcsR0FBeEMsRUFBNkMsQ0FBQyxFQUE5QyxFQUFrRDtBQUNqRCxTQUFHLEdBQUcsU0FBUyxDQUFDLENBQUQsQ0FBZjs7QUFDQSxXQUFLLENBQUwsSUFBVSxHQUFWLEVBQWU7QUFDZCxZQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVUsR0FBRyxDQUFDLENBQUQsQ0FBYjtBQUNBO0FBQ0Q7O0FBQ0QsV0FBTyxJQUFQO0FBQ0EsRzs7OztBQUlNLE1BQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFQLElBQWtCLFlBQVk7QUFDakQsYUFBUyxDQUFULEdBQWEsQ0FBRTs7QUFDZixXQUFPLFVBQVUsS0FBVixFQUFpQjtBQUN2QixPQUFDLENBQUMsU0FBRixHQUFjLEtBQWQ7QUFDQSxhQUFPLElBQUksQ0FBSixFQUFQO0FBQ0EsS0FIRDtBQUlBLEdBTm9DLEVBQTlCLEM7Ozs7O0FBV0EsV0FBUyxJQUFULENBQWMsRUFBZCxFQUFrQixHQUFsQixF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QTtBQUVBVCxTQUFZLENBQUMsUUFBRCxFQUFXLFdBQVgsRUFBd0IsS0FBSyxZQUE3QixDQUFaQTtBQUNBQSxTQUFZLENBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUIsS0FBSyxXQUE1QixDQUFaQSxDQVZ3QixDOztBQWF4QixVQUFJLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBa0IsYUFBdEIsRUFBcUM7QUFDcEMsYUFBSyxJQUFMLENBQVUsWUFBVixDQUF1QixLQUFLLE9BQTVCLEVBQXFDLEtBQUssSUFBTCxDQUFVLFVBQVYsQ0FBcUIsS0FBSyxLQUExQixDQUFyQyxFQUF1RSxJQUF2RSxFQUE2RSxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWtCLFFBQS9GO0FBQ0EsT0FGRCxNQUVPO0FBQ04sYUFBSyxJQUFMLENBQVUsVUFBVixDQUFxQixLQUFLLE9BQTFCLEVBQW1DLEtBQUssSUFBTCxDQUFVLFVBQVYsQ0FBcUIsS0FBSyxLQUExQixDQUFuQztBQUNBO0FBQ0Q7QUEvRm9DLEdBQWYsQ0FBaEIsQzs7OztBQXFHUCxLQUFHLENBQUMsV0FBSixDQUFnQixZQUFoQixFQUE4QixXQUE5QixFQUEyQyxTQUEzQztBQy9IQSxLQUFHLENBQUMsT0FBSixHQUFjLE9BQWQ7QUFFQSxLQUFHLENBQUMsZUFBSixHQUFzQixlQUF0QjtBQUVBLEtBQUcsQ0FBQyxJQUFKLEdBQVcsSUFBWDtBQUVBLEtBQUcsQ0FBQyxRQUFKLEdBQWUsUUFBZjtBQUVBLEtBQUcsQ0FBQyxlQUFKLEdBQXNCLGVBQXRCO0FBRUEsS0FBRyxDQUFDLEdBQUosR0FBVSxHQUFWO0FBRUEsS0FBRyxDQUFDLFNBQUosR0FBZ0IsU0FBaEI7QUNZQSxRQUFNLENBQUMsTUFBUCxHQUFnQixNQUFoQiIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQG5hbWVzcGFjZSBVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgZnJlZXplID0gT2JqZWN0LmZyZWV6ZTtcclxuT2JqZWN0LmZyZWV6ZSA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iajsgfTtcclxuXHJcbi8vIEBmdW5jdGlvbiBleHRlbmQoZGVzdDogT2JqZWN0LCBzcmM/OiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgc3JjYCBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGludG8gYGRlc3RgIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgbGF0dGVyLiBIYXMgYW4gYEwuZXh0ZW5kYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChkZXN0KSB7XHJcblx0dmFyIGksIGosIGxlbiwgc3JjO1xyXG5cclxuXHRmb3IgKGogPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuXHRcdHNyYyA9IGFyZ3VtZW50c1tqXTtcclxuXHRcdGZvciAoaSBpbiBzcmMpIHtcclxuXHRcdFx0ZGVzdFtpXSA9IHNyY1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGRlc3Q7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUocHJvdG86IE9iamVjdCwgcHJvcGVydGllcz86IE9iamVjdCk6IE9iamVjdFxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbT2JqZWN0LmNyZWF0ZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZSlcclxuZXhwb3J0IHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XHJcblx0ZnVuY3Rpb24gRigpIHt9XHJcblx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bykge1xyXG5cdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcclxuXHRcdHJldHVybiBuZXcgRigpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG4vLyBAZnVuY3Rpb24gYmluZChmbjogRnVuY3Rpb24sIOKApik6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQsIGxpa2UgW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cclxuLy8gSGFzIGEgYEwuYmluZCgpYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGJpbmQoZm4sIG9iaikge1xyXG5cdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcblx0aWYgKGZuLmJpbmQpIHtcclxuXHRcdHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG5cdH1cclxuXHJcblx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xyXG5cdH07XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBsYXN0SWQ6IE51bWJlclxyXG4vLyBMYXN0IHVuaXF1ZSBJRCB1c2VkIGJ5IFtgc3RhbXAoKWBdKCN1dGlsLXN0YW1wKVxyXG5leHBvcnQgdmFyIGxhc3RJZCA9IDA7XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RhbXAob2JqOiBPYmplY3QpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWduaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFtcChvYmopIHtcclxuXHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0b2JqLl9sZWFmbGV0X2lkID0gb2JqLl9sZWFmbGV0X2lkIHx8ICsrbGFzdElkO1xyXG5cdHJldHVybiBvYmouX2xlYWZsZXRfaWQ7XHJcblx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGhyb3R0bGUoZm46IEZ1bmN0aW9uLCB0aW1lOiBOdW1iZXIsIGNvbnRleHQ6IE9iamVjdCk6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG4vLyAoc28gdGhhdCB0aGUgYHRoaXNgIGtleXdvcmQgcmVmZXJzIHRvIGBjb250ZXh0YCBpbnNpZGUgYGZuYCdzIGNvZGUpLiBUaGUgZnVuY3Rpb25cclxuLy8gYGZuYCB3aWxsIGJlIGNhbGxlZCBubyBtb3JlIHRoYW4gb25lIHRpbWUgcGVyIGdpdmVuIGFtb3VudCBvZiBgdGltZWAuIFRoZSBhcmd1bWVudHNcclxuLy8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG4vLyBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBpbnZva2luZyB0aGUgYm91bmQgZnVuY3Rpb24uXHJcbi8vIEhhcyBhbiBgTC50aHJvdHRsZWAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZShmbiwgdGltZSwgY29udGV4dCkge1xyXG5cdHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xyXG5cclxuXHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXHJcblx0XHRsb2NrID0gZmFsc2U7XHJcblx0XHRpZiAoYXJncykge1xyXG5cdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHRcdGFyZ3MgPSBmYWxzZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHR3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAobG9jaykge1xyXG5cdFx0XHQvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuXHRcdFx0YXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXHJcblx0XHRcdGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG5cdFx0XHRsb2NrID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gd3JhcHBlckZuO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgbW9kdWxvIGByYW5nZWAgaW4gc3VjaCBhIHdheSBzbyBpdCBsaWVzIHdpdGhpblxyXG4vLyBgcmFuZ2VbMF1gIGFuZCBgcmFuZ2VbMV1gLiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBhbHdheXMgc21hbGxlciB0aGFuXHJcbi8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG5leHBvcnQgZnVuY3Rpb24gd3JhcE51bSh4LCByYW5nZSwgaW5jbHVkZU1heCkge1xyXG5cdHZhciBtYXggPSByYW5nZVsxXSxcclxuXHQgICAgbWluID0gcmFuZ2VbMF0sXHJcblx0ICAgIGQgPSBtYXggLSBtaW47XHJcblx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZmFsc2VGbigpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGZhbHNlRm4oKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuLy8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgZGlnaXRzPzogTnVtYmVyKTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCByb3VuZGVkIHRvIGBkaWdpdHNgIGRlY2ltYWxzLCBvciB0byA2IGRlY2ltYWxzIGJ5IGRlZmF1bHQuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROdW0obnVtLCBkaWdpdHMpIHtcclxuXHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIChkaWdpdHMgPT09IHVuZGVmaW5lZCA/IDYgOiBkaWdpdHMpKTtcclxuXHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdHJpbShzdHI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbU3RyaW5nLnByb3RvdHlwZS50cmltXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbSlcclxuZXhwb3J0IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XHJcblx0cmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cjogU3RyaW5nKTogU3RyaW5nW11cclxuLy8gVHJpbXMgYW5kIHNwbGl0cyB0aGUgc3RyaW5nIG9uIHdoaXRlc3BhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHBhcnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHIpIHtcclxuXHRyZXR1cm4gdHJpbShzdHIpLnNwbGl0KC9cXHMrLyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRPcHRpb25zKG9iajogT2JqZWN0LCBvcHRpb25zOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBnaXZlbiBwcm9wZXJ0aWVzIHRvIHRoZSBgb3B0aW9uc2Agb2YgdGhlIGBvYmpgIG9iamVjdCwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgb3B0aW9ucy4gU2VlIGBDbGFzcyBvcHRpb25zYC4gSGFzIGFuIGBMLnNldE9wdGlvbnNgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmosIG9wdGlvbnMpIHtcclxuXHRpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eSgnb3B0aW9ucycpKSB7XHJcblx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gY3JlYXRlKG9iai5vcHRpb25zKSA6IHt9O1xyXG5cdH1cclxuXHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuXHR9XHJcblx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqOiBPYmplY3QsIGV4aXN0aW5nVXJsPzogU3RyaW5nLCB1cHBlcmNhc2U/OiBCb29sZWFuKTogU3RyaW5nXHJcbi8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuLy8gdHJhbnNsYXRlcyB0byBgJz9hPWZvbyZiPWJhcidgLiBJZiBgZXhpc3RpbmdVcmxgIGlzIHNldCwgdGhlIHBhcmFtZXRlcnMgd2lsbFxyXG4vLyBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kLiBJZiBgdXBwZXJjYXNlYCBpcyBgdHJ1ZWAsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbFxyXG4vLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuXHR2YXIgcGFyYW1zID0gW107XHJcblx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuXHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuXHR9XHJcblx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcbn1cclxuXHJcbnZhciB0ZW1wbGF0ZVJlID0gL1xceyAqKFtcXHdfLV0rKSAqXFx9L2c7XHJcblxyXG4vLyBAZnVuY3Rpb24gdGVtcGxhdGUoc3RyOiBTdHJpbmcsIGRhdGE6IE9iamVjdCk6IFN0cmluZ1xyXG4vLyBTaW1wbGUgdGVtcGxhdGluZyBmYWNpbGl0eSwgYWNjZXB0cyBhIHRlbXBsYXRlIHN0cmluZyBvZiB0aGUgZm9ybSBgJ0hlbGxvIHthfSwge2J9J2BcclxuLy8gYW5kIGEgZGF0YSBvYmplY3QgbGlrZSBge2E6ICdmb28nLCBiOiAnYmFyJ31gLCByZXR1cm5zIGV2YWx1YXRlZCBzdHJpbmdcclxuLy8gYCgnSGVsbG8gZm9vLCBiYXInKWAuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHN0cmluZ3MgZm9yXHJcbi8vIGRhdGEgdmFsdWVzIOKAlCB0aGV5IHdpbGwgYmUgZXZhbHVhdGVkIHBhc3NpbmcgYGRhdGFgIGFzIGFuIGFyZ3VtZW50LlxyXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGUoc3RyLCBkYXRhKSB7XHJcblx0cmV0dXJuIHN0ci5yZXBsYWNlKHRlbXBsYXRlUmUsIGZ1bmN0aW9uIChzdHIsIGtleSkge1xyXG5cdFx0dmFyIHZhbHVlID0gZGF0YVtrZXldO1xyXG5cclxuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgcHJvdmlkZWQgZm9yIHZhcmlhYmxlICcgKyBzdHIpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBpc0FycmF5KG9iaik6IEJvb2xlYW5cclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LmlzQXJyYXldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXkpXHJcbmV4cG9ydCB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xyXG5cdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGluZGV4T2YoYXJyYXk6IEFycmF5LCBlbDogT2JqZWN0KTogTnVtYmVyXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5wcm90b3R5cGUuaW5kZXhPZl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZilcclxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIGVsKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKGFycmF5W2ldID09PSBlbCkgeyByZXR1cm4gaTsgfVxyXG5cdH1cclxuXHRyZXR1cm4gLTE7XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBlbXB0eUltYWdlVXJsOiBTdHJpbmdcclxuLy8gRGF0YSBVUkkgc3RyaW5nIGNvbnRhaW5pbmcgYSBiYXNlNjQtZW5jb2RlZCBlbXB0eSBHSUYgaW1hZ2UuXHJcbi8vIFVzZWQgYXMgYSBoYWNrIHRvIGZyZWUgbWVtb3J5IGZyb20gdW51c2VkIGltYWdlcyBvbiBXZWJLaXQtcG93ZXJlZFxyXG4vLyBtb2JpbGUgZGV2aWNlcyAoYnkgc2V0dGluZyBpbWFnZSBgc3JjYCB0byB0aGlzIHN0cmluZykuXHJcbmV4cG9ydCB2YXIgZW1wdHlJbWFnZVVybCA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9JztcclxuXHJcbi8vIGluc3BpcmVkIGJ5IGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcblxyXG5mdW5jdGlvbiBnZXRQcmVmaXhlZChuYW1lKSB7XHJcblx0cmV0dXJuIHdpbmRvd1snd2Via2l0JyArIG5hbWVdIHx8IHdpbmRvd1snbW96JyArIG5hbWVdIHx8IHdpbmRvd1snbXMnICsgbmFtZV07XHJcbn1cclxuXHJcbnZhciBsYXN0VGltZSA9IDA7XHJcblxyXG4vLyBmYWxsYmFjayBmb3IgSUUgNy04XHJcbmZ1bmN0aW9uIHRpbWVvdXREZWZlcihmbikge1xyXG5cdHZhciB0aW1lID0gK25ldyBEYXRlKCksXHJcblx0ICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lIC0gbGFzdFRpbWUpKTtcclxuXHJcblx0bGFzdFRpbWUgPSB0aW1lICsgdGltZVRvQ2FsbDtcclxuXHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVUb0NhbGwpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIHJlcXVlc3RGbiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ1JlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IHRpbWVvdXREZWZlcjtcclxuZXhwb3J0IHZhciBjYW5jZWxGbiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnKSB8fFxyXG5cdFx0Z2V0UHJlZml4ZWQoJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IGZ1bmN0aW9uIChpZCkgeyB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTsgfTtcclxuXHJcbi8vIEBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgaW1tZWRpYXRlPzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBTY2hlZHVsZXMgYGZuYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBicm93c2VyIHJlcGFpbnRzLiBgZm5gIGlzIGJvdW5kIHRvXHJcbi8vIGBjb250ZXh0YCBpZiBnaXZlbi4gV2hlbiBgaW1tZWRpYXRlYCBpcyBzZXQsIGBmbmAgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGlmXHJcbi8vIHRoZSBicm93c2VyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgc3VwcG9ydCBmb3JcclxuLy8gW2B3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLFxyXG4vLyBvdGhlcndpc2UgaXQncyBkZWxheWVkLiBSZXR1cm5zIGEgcmVxdWVzdCBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm4sIGNvbnRleHQsIGltbWVkaWF0ZSkge1xyXG5cdGlmIChpbW1lZGlhdGUgJiYgcmVxdWVzdEZuID09PSB0aW1lb3V0RGVmZXIpIHtcclxuXHRcdGZuLmNhbGwoY29udGV4dCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiByZXF1ZXN0Rm4uY2FsbCh3aW5kb3csIGJpbmQoZm4sIGNvbnRleHQpKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQ6IE51bWJlcik6IHVuZGVmaW5lZFxyXG4vLyBDYW5jZWxzIGEgcHJldmlvdXMgYHJlcXVlc3RBbmltRnJhbWVgLiBTZWUgYWxzbyBbd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZCkge1xyXG5cdGlmIChpZCkge1xyXG5cdFx0Y2FuY2VsRm4uY2FsbCh3aW5kb3csIGlkKTtcclxuXHR9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xyXG5cclxuLy8gQGNsYXNzIENsYXNzXHJcbi8vIEBha2EgTC5DbGFzc1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gQHVuaW5oZXJpdGFibGVcclxuXHJcbi8vIFRoYW5rcyB0byBKb2huIFJlc2lnIGFuZCBEZWFuIEVkd2FyZHMgZm9yIGluc3BpcmF0aW9uIVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENsYXNzKCkge31cclxuXHJcbkNsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gZXh0ZW5kKHByb3BzOiBPYmplY3QpOiBGdW5jdGlvblxyXG5cdC8vIFtFeHRlbmRzIHRoZSBjdXJyZW50IGNsYXNzXSgjY2xhc3MtaW5oZXJpdGFuY2UpIGdpdmVuIHRoZSBwcm9wZXJ0aWVzIHRvIGJlIGluY2x1ZGVkLlxyXG5cdC8vIFJldHVybnMgYSBKYXZhc2NyaXB0IGZ1bmN0aW9uIHRoYXQgaXMgYSBjbGFzcyBjb25zdHJ1Y3RvciAodG8gYmUgY2FsbGVkIHdpdGggYG5ld2ApLlxyXG5cdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG5cdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG5cdFx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblx0fTtcclxuXHJcblx0dmFyIHBhcmVudFByb3RvID0gTmV3Q2xhc3MuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG5cdHZhciBwcm90byA9IFV0aWwuY3JlYXRlKHBhcmVudFByb3RvKTtcclxuXHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xyXG5cclxuXHROZXdDbGFzcy5wcm90b3R5cGUgPSBwcm90bztcclxuXHJcblx0Ly8gaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXHJcblx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcblx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSAncHJvdG90eXBlJyAmJiBpICE9PSAnX19zdXBlcl9fJykge1xyXG5cdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuXHRpZiAocHJvcHMuc3RhdGljcykge1xyXG5cdFx0VXRpbC5leHRlbmQoTmV3Q2xhc3MsIHByb3BzLnN0YXRpY3MpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLnN0YXRpY3M7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggaW5jbHVkZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcblx0XHRjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhwcm9wcy5pbmNsdWRlcyk7XHJcblx0XHRVdGlsLmV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLmluY2x1ZGVzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWVyZ2Ugb3B0aW9uc1xyXG5cdGlmIChwcm90by5vcHRpb25zKSB7XHJcblx0XHRwcm9wcy5vcHRpb25zID0gVXRpbC5leHRlbmQoVXRpbC5jcmVhdGUocHJvdG8ub3B0aW9ucyksIHByb3BzLm9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0VXRpbC5leHRlbmQocHJvdG8sIHByb3BzKTtcclxuXHJcblx0cHJvdG8uX2luaXRIb29rcyA9IFtdO1xyXG5cclxuXHQvLyBhZGQgbWV0aG9kIGZvciBjYWxsaW5nIGFsbCBob29rc1xyXG5cdHByb3RvLmNhbGxJbml0SG9va3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRIb29rc0NhbGxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAocGFyZW50UHJvdG8uY2FsbEluaXRIb29rcykge1xyXG5cdFx0XHRwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEhvb2tzQ2FsbGVkID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvdG8uX2luaXRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRwcm90by5faW5pdEhvb2tzW2ldLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIE5ld0NsYXNzO1xyXG59O1xyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBpbmNsdWRlKHByb3BlcnRpZXM6IE9iamVjdCk6IHRoaXNcclxuLy8gW0luY2x1ZGVzIGEgbWl4aW5dKCNjbGFzcy1pbmNsdWRlcykgaW50byB0aGUgY3VycmVudCBjbGFzcy5cclxuQ2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnM6IE9iamVjdCk6IHRoaXNcclxuLy8gW01lcmdlcyBgb3B0aW9uc2BdKCNjbGFzcy1vcHRpb25zKSBpbnRvIHRoZSBkZWZhdWx0cyBvZiB0aGUgY2xhc3MuXHJcbkNsYXNzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0VXRpbC5leHRlbmQodGhpcy5wcm90b3R5cGUub3B0aW9ucywgb3B0aW9ucyk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkSW5pdEhvb2soZm46IEZ1bmN0aW9uKTogdGhpc1xyXG4vLyBBZGRzIGEgW2NvbnN0cnVjdG9yIGhvb2tdKCNjbGFzcy1jb25zdHJ1Y3Rvci1ob29rcykgdG8gdGhlIGNsYXNzLlxyXG5DbGFzcy5hZGRJbml0SG9vayA9IGZ1bmN0aW9uIChmbikgeyAvLyAoRnVuY3Rpb24pIHx8IChTdHJpbmcsIGFyZ3MuLi4pXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuXHR2YXIgaW5pdCA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpc1tmbl0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0fTtcclxuXHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyA9IHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgfHwgW107XHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcy5wdXNoKGluaXQpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gY2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMoaW5jbHVkZXMpIHtcclxuXHRpZiAodHlwZW9mIEwgPT09ICd1bmRlZmluZWQnIHx8ICFMIHx8ICFMLk1peGluKSB7IHJldHVybjsgfVxyXG5cclxuXHRpbmNsdWRlcyA9IFV0aWwuaXNBcnJheShpbmNsdWRlcykgPyBpbmNsdWRlcyA6IFtpbmNsdWRlc107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgaW5jbHVkZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChpbmNsdWRlc1tpXSA9PT0gTC5NaXhpbi5FdmVudHMpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIGluY2x1ZGUgb2YgTC5NaXhpbi5FdmVudHM6ICcgK1xyXG5cdFx0XHRcdCd0aGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMsICcgK1xyXG5cdFx0XHRcdCdwbGVhc2UgaW5oZXJpdCBmcm9tIEwuRXZlbnRlZCBpbnN0ZWFkLicsIG5ldyBFcnJvcigpLnN0YWNrKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwiaW1wb3J0IHtDbGFzc30gZnJvbSAnLi9DbGFzcyc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBFdmVudGVkXHJcbiAqIEBha2EgTC5FdmVudGVkXHJcbiAqIEBpbmhlcml0cyBDbGFzc1xyXG4gKlxyXG4gKiBBIHNldCBvZiBtZXRob2RzIHNoYXJlZCBiZXR3ZWVuIGV2ZW50LXBvd2VyZWQgY2xhc3NlcyAobGlrZSBgTWFwYCBhbmQgYE1hcmtlcmApLiBHZW5lcmFsbHksIGV2ZW50cyBhbGxvdyB5b3UgdG8gZXhlY3V0ZSBzb21lIGZ1bmN0aW9uIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgd2l0aCBhbiBvYmplY3QgKGUuZy4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAsIGNhdXNpbmcgdGhlIG1hcCB0byBmaXJlIGAnY2xpY2snYCBldmVudCkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAqIFx0YWxlcnQoZS5sYXRsbmcpO1xyXG4gKiB9ICk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlYWxzIHdpdGggZXZlbnQgbGlzdGVuZXJzIGJ5IHJlZmVyZW5jZSwgc28gaWYgeW91IHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIgYW5kIHRoZW4gcmVtb3ZlIGl0LCBkZWZpbmUgaXQgYXMgYSBmdW5jdGlvbjpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gb25DbGljayhlKSB7IC4uLiB9XHJcbiAqXHJcbiAqIG1hcC5vbignY2xpY2snLCBvbkNsaWNrKTtcclxuICogbWFwLm9mZignY2xpY2snLCBvbkNsaWNrKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFdmVudHMgPSB7XHJcblx0LyogQG1ldGhvZCBvbih0eXBlOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBldmVudCB0eXBlIG9mIHRoZSBvYmplY3QuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lciAob2JqZWN0IHRoZSB0aGlzIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9uKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cdCAqL1xyXG5cdG9uOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG5cdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvKiBAbWV0aG9kIG9mZih0eXBlOiBTdHJpbmcsIGZuPzogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgb2YgdGhhdCBwYXJ0aWN1bGFyIGV2ZW50IGZyb20gdGhlIG9iamVjdC4gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBgb25gLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmY6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyBvbiB0aGUgb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGltcGxpY2l0bHkgYXR0YWNoZWQgZXZlbnRzLlxyXG5cdCAqL1xyXG5cdG9mZjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICghdHlwZXMpIHtcclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHNcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50cztcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBhdHRhY2ggbGlzdGVuZXIgKHdpdGhvdXQgc3ludGFjdGljIHN1Z2FyIG5vdylcclxuXHRfb246IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xyXG5cclxuXHRcdC8qIGdldC9pbml0IGxpc3RlbmVycyBmb3IgdHlwZSAqL1xyXG5cdFx0dmFyIHR5cGVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAoIXR5cGVMaXN0ZW5lcnMpIHtcclxuXHRcdFx0dHlwZUxpc3RlbmVycyA9IFtdO1xyXG5cdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSB0eXBlTGlzdGVuZXJzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcblx0XHRcdC8vIExlc3MgbWVtb3J5IGZvb3RwcmludC5cclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHRcdHZhciBuZXdMaXN0ZW5lciA9IHtmbjogZm4sIGN0eDogY29udGV4dH0sXHJcblx0XHQgICAgbGlzdGVuZXJzID0gdHlwZUxpc3RlbmVycztcclxuXHJcblx0XHQvLyBjaGVjayBpZiBmbiBhbHJlYWR5IHRoZXJlXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuICYmIGxpc3RlbmVyc1tpXS5jdHggPT09IGNvbnRleHQpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsaXN0ZW5lcnMucHVzaChuZXdMaXN0ZW5lcik7XHJcblx0fSxcclxuXHJcblx0X29mZjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzLFxyXG5cdFx0ICAgIGksXHJcblx0XHQgICAgbGVuO1xyXG5cclxuXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcblx0XHRpZiAoIWxpc3RlbmVycykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFmbikge1xyXG5cdFx0XHQvLyBTZXQgYWxsIHJlbW92ZWQgbGlzdGVuZXJzIHRvIG5vb3Agc28gdGhleSBhcmUgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGxpc3RlbmVyc1tpXS5mbiA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGZvciBhIHR5cGUgaWYgZnVuY3Rpb24gaXNuJ3Qgc3BlY2lmaWVkXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHJcblx0XHRcdC8vIGZpbmQgZm4gYW5kIHJlbW92ZSBpdFxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRpZiAobC5jdHggIT09IGNvbnRleHQpIHsgY29udGludWU7IH1cclxuXHRcdFx0XHRpZiAobC5mbiA9PT0gZm4pIHtcclxuXHJcblx0XHRcdFx0XHQvLyBzZXQgdGhlIHJlbW92ZWQgbGlzdGVuZXIgdG8gbm9vcCBzbyB0aGF0J3Mgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdFx0XHRsLmZuID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHRcdGlmICh0aGlzLl9maXJpbmdDb3VudCkge1xyXG5cdFx0XHRcdFx0XHQvKiBjb3B5IGFycmF5IGluIGNhc2UgZXZlbnRzIGFyZSBiZWluZyBmaXJlZCAqL1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmlyZSh0eXBlOiBTdHJpbmcsIGRhdGE/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gRmlyZXMgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhbiBkYXRhXHJcblx0Ly8gb2JqZWN0IOKAlCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgY29udGFpbiBpdHNcclxuXHQvLyBwcm9wZXJ0aWVzLiBUaGUgZXZlbnQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCB0byBldmVudCBwYXJlbnRzLlxyXG5cdGZpcmU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBwcm9wYWdhdGUpIHtcclxuXHRcdGlmICghdGhpcy5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgZXZlbnQgPSBVdGlsLmV4dGVuZCh7fSwgZGF0YSwge1xyXG5cdFx0XHR0eXBlOiB0eXBlLFxyXG5cdFx0XHR0YXJnZXQ6IHRoaXMsXHJcblx0XHRcdHNvdXJjZVRhcmdldDogZGF0YSAmJiBkYXRhLnNvdXJjZVRhcmdldCB8fCB0aGlzXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fZXZlbnRzKSB7XHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG5cdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQgPSAodGhpcy5fZmlyaW5nQ291bnQgKyAxKSB8fCAxO1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xyXG5cdFx0XHRcdFx0bC5mbi5jYWxsKGwuY3R4IHx8IHRoaXMsIGV2ZW50KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50LS07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAocHJvcGFnYXRlKSB7XHJcblx0XHRcdC8vIHByb3BhZ2F0ZSB0aGUgZXZlbnQgdG8gcGFyZW50cyAoc2V0IHdpdGggYWRkRXZlbnRQYXJlbnQpXHJcblx0XHRcdHRoaXMuX3Byb3BhZ2F0ZUV2ZW50KGV2ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxpc3RlbnModHlwZTogU3RyaW5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGEgcGFydGljdWxhciBldmVudCB0eXBlIGhhcyBhbnkgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIGl0LlxyXG5cdGxpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBwcm9wYWdhdGUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMubGVuZ3RoKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBhbHNvIGNoZWNrIHBhcmVudHMgZm9yIGxpc3RlbmVycyBpZiBldmVudCBwcm9wYWdhdGVzXHJcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHNbaWRdLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvbmNlKOKApik6IHRoaXNcclxuXHQvLyBCZWhhdmVzIGFzIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKSwgZXhjZXB0IHRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgZ2V0IGZpcmVkIG9uY2UgYW5kIHRoZW4gcmVtb3ZlZC5cclxuXHRvbmNlOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMub25jZSh0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHRcdCAgICAub2ZmKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdC8vIGFkZCBhIGxpc3RlbmVyIHRoYXQncyBleGVjdXRlZCBvbmNlIGFuZCByZW1vdmVkIGFmdGVyIHRoYXRcclxuXHRcdHJldHVybiB0aGlzXHJcblx0XHQgICAgLm9uKHR5cGVzLCBmbiwgY29udGV4dClcclxuXHRcdCAgICAub24odHlwZXMsIGhhbmRsZXIsIGNvbnRleHQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gZXZlbnQgcGFyZW50IC0gYW4gYEV2ZW50ZWRgIHRoYXQgd2lsbCByZWNlaXZlIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0YWRkRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50cyA9IHRoaXMuX2V2ZW50UGFyZW50cyB8fCB7fTtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50c1tVdGlsLnN0YW1wKG9iaildID0gb2JqO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBldmVudCBwYXJlbnQsIHNvIGl0IHdpbGwgc3RvcCByZWNlaXZpbmcgcHJvcGFnYXRlZCBldmVudHNcclxuXHRyZW1vdmVFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRQYXJlbnRzW1V0aWwuc3RhbXAob2JqKV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcHJvcGFnYXRlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0dGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5maXJlKGUudHlwZSwgVXRpbC5leHRlbmQoe1xyXG5cdFx0XHRcdGxheWVyOiBlLnRhcmdldCxcclxuXHRcdFx0XHRwcm9wYWdhdGVkRnJvbTogZS50YXJnZXRcclxuXHRcdFx0fSwgZSksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbi8vIGFsaWFzZXM7IHdlIHNob3VsZCBkaXRjaCB0aG9zZSBldmVudHVhbGx5XHJcblxyXG4vLyBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uKOKApilgXSgjZXZlbnRlZC1vbilcclxuRXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBFdmVudHMub247XHJcblxyXG4vLyBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZijigKYpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5cclxuLy8gQG1ldGhvZCBjbGVhckFsbEV2ZW50TGlzdGVuZXJzKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYoKWBdKCNldmVudGVkLW9mZilcclxuRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMuY2xlYXJBbGxFdmVudExpc3RlbmVycyA9IEV2ZW50cy5vZmY7XHJcblxyXG4vLyBAbWV0aG9kIGFkZE9uZVRpbWVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbmNlKOKApilgXSgjZXZlbnRlZC1vbmNlKVxyXG5FdmVudHMuYWRkT25lVGltZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMub25jZTtcclxuXHJcbi8vIEBtZXRob2QgZmlyZUV2ZW50KOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BmaXJlKOKApilgXSgjZXZlbnRlZC1maXJlKVxyXG5FdmVudHMuZmlyZUV2ZW50ID0gRXZlbnRzLmZpcmU7XHJcblxyXG4vLyBAbWV0aG9kIGhhc0V2ZW50TGlzdGVuZXJzKOKApik6IEJvb2xlYW5cclxuLy8gQWxpYXMgdG8gW2BsaXN0ZW5zKOKApilgXSgjZXZlbnRlZC1saXN0ZW5zKVxyXG5FdmVudHMuaGFzRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMubGlzdGVucztcclxuXHJcbmV4cG9ydCB2YXIgRXZlbnRlZCA9IENsYXNzLmV4dGVuZChFdmVudHMpO1xyXG4iLCJpbXBvcnQge2lzQXJyYXksIGZvcm1hdE51bX0gZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBQb2ludFxyXG4gKiBAYWthIEwuUG9pbnRcclxuICpcclxuICogUmVwcmVzZW50cyBhIHBvaW50IHdpdGggYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgaW4gcGl4ZWxzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9pbnQgPSBMLnBvaW50KDIwMCwgMzAwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgYW5kIG9wdGlvbnMgdGhhdCBhY2NlcHQgYFBvaW50YCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAucGFuQnkoWzIwMCwgMzAwXSk7XHJcbiAqIG1hcC5wYW5CeShMLnBvaW50KDIwMCwgMzAwKSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYFBvaW50YCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuXHQvLyBAcHJvcGVydHkgeDogTnVtYmVyOyBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG5cdC8vIEBwcm9wZXJ0eSB5OiBOdW1iZXI7IFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuXHR0aGlzLnkgPSAocm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XHJcbn1cclxuXHJcbnZhciB0cnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcclxuXHRyZXR1cm4gdiA+IDAgPyBNYXRoLmZsb29yKHYpIDogTWF0aC5jZWlsKHYpO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGNsb25lKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkKG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYWRkaXRpb24gb2YgdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0YWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIG5vbi1kZXN0cnVjdGl2ZSwgcmV0dXJucyBhIG5ldyBwb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHRvUG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIGRlc3RydWN0aXZlLCB1c2VkIGRpcmVjdGx5IGZvciBwZXJmb3JtYW5jZSBpbiBzaXR1YXRpb25zIHdoZXJlIGl0J3Mgc2FmZSB0byBtb2RpZnkgZXhpc3RpbmcgcG9pbnRcclxuXHRcdHRoaXMueCArPSBwb2ludC54O1xyXG5cdFx0dGhpcy55ICs9IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN1YnRyYWN0KG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3Rpb24gb2YgdGhlIGdpdmVuIHBvaW50IGZyb20gdGhlIGN1cnJlbnQuXHJcblx0c3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QodG9Qb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9zdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR0aGlzLnggLT0gcG9pbnQueDtcclxuXHRcdHRoaXMueSAtPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXZpZGVCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0ZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2RpdmlkZUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X2RpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggLz0gbnVtO1xyXG5cdFx0dGhpcy55IC89IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbXVsdGlwbHlCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0bXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdGlwbHlCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9tdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggKj0gbnVtO1xyXG5cdFx0dGhpcy55ICo9IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIE11bHRpcGx5IGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieSBlYWNoIGNvb3JkaW5hdGUgb2ZcclxuXHQvLyBgc2NhbGVgLiBJbiBsaW5lYXIgYWxnZWJyYSB0ZXJtcywgbXVsdGlwbHkgdGhlIHBvaW50IGJ5IHRoZVxyXG5cdC8vIFtzY2FsaW5nIG1hdHJpeF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NhbGluZ18lMjhnZW9tZXRyeSUyOSNNYXRyaXhfcmVwcmVzZW50YXRpb24pXHJcblx0Ly8gZGVmaW5lZCBieSBgc2NhbGVgLlxyXG5cdHNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEludmVyc2Ugb2YgYHNjYWxlQnlgLiBEaXZpZGUgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5XHJcblx0Ly8gZWFjaCBjb29yZGluYXRlIG9mIGBzY2FsZWAuXHJcblx0dW5zY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByb3VuZCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggcm91bmRlZCBjb29yZGluYXRlcy5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmxvb3IoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGZsb29yZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgZG93bikuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XHJcblx0fSxcclxuXHJcblx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNlaWwoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGNlaWxlZCBjb29yZGluYXRlcyAocm91bmRlZCB1cCkuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0cnVuYygpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggdHJ1bmNhdGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHRvd2FyZHMgemVybykuXHJcblx0dHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3RydW5jKCk7XHJcblx0fSxcclxuXHJcblx0X3RydW5jOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSB0cnVuYyh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gdHJ1bmModGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlclBvaW50OiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGNhcnRlc2lhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLngsXHJcblx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaGFzIHRoZSBzYW1lIGNvb3JkaW5hdGVzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludC54ID09PSB0aGlzLnggJiZcclxuXHRcdCAgICAgICBwb2ludC55ID09PSB0aGlzLnk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGNvb3JkaW5hdGVzIG9mIHRoZSBnaXZlbiBwb2ludCBhcmUgbGVzcyB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGN1cnJlbnQgcG9pbnQgY29vcmRpbmF0ZXMgKGluIGFic29sdXRlIHZhbHVlcykuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMocG9pbnQueCkgPD0gTWF0aC5hYnModGhpcy54KSAmJlxyXG5cdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gJ1BvaW50KCcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy55KSArICcpJztcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KHg6IE51bWJlciwgeTogTnVtYmVyLCByb3VuZD86IEJvb2xlYW4pXHJcbi8vIENyZWF0ZXMgYSBQb2ludCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMuIElmIG9wdGlvbmFsIGByb3VuZGAgaXMgc2V0IHRvIHRydWUsIHJvdW5kcyB0aGUgYHhgIGFuZCBgeWAgdmFsdWVzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBOdW1iZXJbXSlcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW3gsIHldYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBPYmplY3QpXHJcbi8vIEV4cGVjdHMgYSBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHt4OiBOdW1iZXIsIHk6IE51bWJlcn1gIGluc3RlYWQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1BvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0aWYgKHggaW5zdGFuY2VvZiBQb2ludCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmIChpc0FycmF5KHgpKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHhbMF0sIHhbMV0pO1xyXG5cdH1cclxuXHRpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGwpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmICd4JyBpbiB4ICYmICd5JyBpbiB4KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHgueCwgeC55KTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbn1cclxuIiwiaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQm91bmRzXHJcbiAqIEBha2EgTC5Cb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgaW4gcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwMSA9IEwucG9pbnQoMTAsIDEwKSxcclxuICogcDIgPSBMLnBvaW50KDQwLCA2MCksXHJcbiAqIGJvdW5kcyA9IEwuYm91bmRzKHAxLCBwMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IGBCb3VuZHNgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBvdGhlckJvdW5kcy5pbnRlcnNlY3RzKFtbMTAsIDEwXSwgWzQwLCA2MF1dKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoIWEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBwb2ludHMgPSBiID8gW2EsIGJdIDogYTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQocG9pbnRzW2ldKTtcclxuXHR9XHJcbn1cclxuXHJcbkJvdW5kcy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBleHRlbmQocG9pbnQ6IFBvaW50KTogdGhpc1xyXG5cdC8vIEV4dGVuZHMgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludC5cclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtaW46IFBvaW50XHJcblx0XHQvLyBUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHQvLyBAcHJvcGVydHkgbWF4OiBQb2ludFxyXG5cdFx0Ly8gVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHRcdGlmICghdGhpcy5taW4gJiYgIXRoaXMubWF4KSB7XHJcblx0XHRcdHRoaXMubWluID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdFx0dGhpcy5tYXggPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5taW4ueCA9IE1hdGgubWluKHBvaW50LngsIHRoaXMubWluLngpO1xyXG5cdFx0XHR0aGlzLm1heC54ID0gTWF0aC5tYXgocG9pbnQueCwgdGhpcy5tYXgueCk7XHJcblx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihwb2ludC55LCB0aGlzLm1pbi55KTtcclxuXHRcdFx0dGhpcy5tYXgueSA9IE1hdGgubWF4KHBvaW50LnksIHRoaXMubWF4LnkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIocm91bmQ/OiBCb29sZWFuKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uIChyb3VuZCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnggKyB0aGlzLm1heC54KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi55ICsgdGhpcy5tYXgueSkgLyAyLCByb3VuZCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21MZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRCb3R0b21MZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMubWluLngsIHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0VG9wUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRUb3BSaWdodDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLm1heC54LCB0aGlzLm1pbi55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFRvcExlZnQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5taW5gXSgjYm91bmRzLW1pbikpLlxyXG5cdGdldFRvcExlZnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1pbjsgLy8gbGVmdCwgdG9wXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21SaWdodCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGJvdHRvbS1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5tYXhgXSgjYm91bmRzLW1heCkpLlxyXG5cdGdldEJvdHRvbVJpZ2h0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXg7IC8vIHJpZ2h0LCBib3R0b21cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBib3VuZHNcclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXguc3VidHJhY3QodGhpcy5taW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhwb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBtaW4sIG1heDtcclxuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgUG9pbnQpIHtcclxuXHRcdFx0b2JqID0gdG9Qb2ludChvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gdG9Cb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcblx0XHRcdG1pbiA9IG9iai5taW47XHJcblx0XHRcdG1heCA9IG9iai5tYXg7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtaW4gPSBtYXggPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChtaW4ueCA+PSB0aGlzLm1pbi54KSAmJlxyXG5cdFx0ICAgICAgIChtYXgueCA8PSB0aGlzLm1heC54KSAmJlxyXG5cdFx0ICAgICAgIChtaW4ueSA+PSB0aGlzLm1pbi55KSAmJlxyXG5cdFx0ICAgICAgIChtYXgueSA8PSB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG5cdC8vIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhJbnRlcnNlY3RzID0gKG1heDIueCA+PSBtaW4ueCkgJiYgKG1pbjIueCA8PSBtYXgueCksXHJcblx0XHQgICAgeUludGVyc2VjdHMgPSAobWF4Mi55ID49IG1pbi55KSAmJiAobWluMi55IDw9IG1heC55KTtcclxuXHJcblx0XHRyZXR1cm4geEludGVyc2VjdHMgJiYgeUludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG5cdC8vIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcblx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeE92ZXJsYXBzID0gKG1heDIueCA+IG1pbi54KSAmJiAobWluMi54IDwgbWF4LngpLFxyXG5cdFx0ICAgIHlPdmVybGFwcyA9IChtYXgyLnkgPiBtaW4ueSkgJiYgKG1pbjIueSA8IG1heC55KTtcclxuXHJcblx0XHRyZXR1cm4geE92ZXJsYXBzICYmIHlPdmVybGFwcztcclxuXHR9LFxyXG5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5taW4gJiYgdGhpcy5tYXgpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhjb3JuZXIxOiBQb2ludCwgY29ybmVyMjogUG9pbnQpXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdHdvIGNvcm5lcnMgY29vcmRpbmF0ZSBwYWlycy5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKHBvaW50czogUG9pbnRbXSlcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgcG9pbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Cb3VuZHMoYSwgYikge1xyXG5cdGlmICghYSB8fCBhIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBCb3VuZHMoYSwgYik7XHJcbn1cclxuIiwiaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuL0xhdExuZyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF0TG5nQm91bmRzXHJcbiAqIEBha2EgTC5MYXRMbmdCb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGdlb2dyYXBoaWNhbCBhcmVhIG9uIGEgbWFwLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgY29ybmVyMSA9IEwubGF0TG5nKDQwLjcxMiwgLTc0LjIyNyksXHJcbiAqIGNvcm5lcjIgPSBMLmxhdExuZyg0MC43NzQsIC03NC4xMjUpLFxyXG4gKiBib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nQm91bmRzIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAuZml0Qm91bmRzKFtcclxuICogXHRbNDAuNzEyLCAtNzQuMjI3XSxcclxuICogXHRbNDAuNzc0LCAtNzQuMTI1XVxyXG4gKiBdKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIENhdXRpb246IGlmIHRoZSBhcmVhIGNyb3NzZXMgdGhlIGFudGltZXJpZGlhbiAob2Z0ZW4gY29uZnVzZWQgd2l0aCB0aGUgSW50ZXJuYXRpb25hbCBEYXRlIExpbmUpLCB5b3UgbXVzdCBzcGVjaWZ5IGNvcm5lcnMgX291dHNpZGVfIHRoZSBbLTE4MCwgMTgwXSBkZWdyZWVzIGxvbmdpdHVkZSByYW5nZS5cclxuICpcclxuICogTm90ZSB0aGF0IGBMYXRMbmdCb3VuZHNgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBMYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMikgeyAvLyAoTGF0TG5nLCBMYXRMbmcpIG9yIChMYXRMbmdbXSlcclxuXHRpZiAoIWNvcm5lcjEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBsYXRsbmdzID0gY29ybmVyMiA/IFtjb3JuZXIxLCBjb3JuZXIyXSA6IGNvcm5lcjE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChsYXRsbmdzW2ldKTtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZ0JvdW5kcy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50XHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0XHRzdzIgPSBvYmo7XHJcblx0XHRcdG5lMiA9IG9iajtcclxuXHJcblx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouX3NvdXRoV2VzdDtcclxuXHRcdFx0bmUyID0gb2JqLl9ub3J0aEVhc3Q7XHJcblxyXG5cdFx0XHRpZiAoIXN3MiB8fCAhbmUyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKHRvTGF0TG5nKG9iaikgfHwgdG9MYXRMbmdCb3VuZHMob2JqKSkgOiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghc3cgJiYgIW5lKSB7XHJcblx0XHRcdHRoaXMuX3NvdXRoV2VzdCA9IG5ldyBMYXRMbmcoc3cyLmxhdCwgc3cyLmxuZyk7XHJcblx0XHRcdHRoaXMuX25vcnRoRWFzdCA9IG5ldyBMYXRMbmcobmUyLmxhdCwgbmUyLmxuZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdy5sYXQgPSBNYXRoLm1pbihzdzIubGF0LCBzdy5sYXQpO1xyXG5cdFx0XHRzdy5sbmcgPSBNYXRoLm1pbihzdzIubG5nLCBzdy5sbmcpO1xyXG5cdFx0XHRuZS5sYXQgPSBNYXRoLm1heChuZTIubGF0LCBuZS5sYXQpO1xyXG5cdFx0XHRuZS5sbmcgPSBNYXRoLm1heChuZTIubG5nLCBuZS5sbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFkKGJ1ZmZlclJhdGlvOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGJvdW5kcyBjcmVhdGVkIGJ5IGV4dGVuZGluZyBvciByZXRyYWN0aW5nIHRoZSBjdXJyZW50IGJvdW5kcyBieSBhIGdpdmVuIHJhdGlvIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdC8vIEZvciBleGFtcGxlLCBhIHJhdGlvIG9mIDAuNSBleHRlbmRzIHRoZSBib3VuZHMgYnkgNTAlIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdC8vIE5lZ2F0aXZlIHZhbHVlcyB3aWxsIHJldHJhY3QgdGhlIGJvdW5kcy5cclxuXHRwYWQ6IGZ1bmN0aW9uIChidWZmZXJSYXRpbykge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIGhlaWdodEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxhdCAtIG5lLmxhdCkgKiBidWZmZXJSYXRpbyxcclxuXHRcdCAgICB3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxuZyAtIG5lLmxuZykgKiBidWZmZXJSYXRpbztcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgbmV3IExhdExuZyhzdy5sYXQgLSBoZWlnaHRCdWZmZXIsIHN3LmxuZyAtIHdpZHRoQnVmZmVyKSxcclxuXHRcdCAgICAgICAgbmV3IExhdExuZyhuZS5sYXQgKyBoZWlnaHRCdWZmZXIsIG5lLmxuZyArIHdpZHRoQnVmZmVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sYXQgKyB0aGlzLl9ub3J0aEVhc3QubGF0KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubG5nICsgdGhpcy5fbm9ydGhFYXN0LmxuZykgLyAyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXROb3J0aCgpLCB0aGlzLmdldFdlc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aEVhc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRXZXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHdlc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRTb3V0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFYXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGVhc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXROb3J0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyAobGF0bG5nOiBMYXRMbmcpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZ0JvdW5kcykgb3IgKExhdExuZykgLT4gQm9vbGVhblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIExhdExuZyB8fCAnbGF0JyBpbiBvYmopIHtcclxuXHRcdFx0b2JqID0gdG9MYXRMbmcob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvTGF0TG5nQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLmdldFNvdXRoV2VzdCgpO1xyXG5cdFx0XHRuZTIgPSBvYmouZ2V0Tm9ydGhFYXN0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdzIgPSBuZTIgPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChzdzIubGF0ID49IHN3LmxhdCkgJiYgKG5lMi5sYXQgPD0gbmUubGF0KSAmJlxyXG5cdFx0ICAgICAgIChzdzIubG5nID49IHN3LmxuZykgJiYgKG5lMi5sbmcgPD0gbmUubG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0SW50ZXJzZWN0cyA9IChuZTIubGF0ID49IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPD0gbmUubGF0KSxcclxuXHRcdCAgICBsbmdJbnRlcnNlY3RzID0gKG5lMi5sbmcgPj0gc3cubG5nKSAmJiAoc3cyLmxuZyA8PSBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRJbnRlcnNlY3RzICYmIGxuZ0ludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRPdmVybGFwcyA9IChuZTIubGF0ID4gc3cubGF0KSAmJiAoc3cyLmxhdCA8IG5lLmxhdCksXHJcblx0XHQgICAgbG5nT3ZlcmxhcHMgPSAobmUyLmxuZyA+IHN3LmxuZykgJiYgKHN3Mi5sbmcgPCBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRPdmVybGFwcyAmJiBsbmdPdmVybGFwcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQkJveFN0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYm91bmRpbmcgYm94IGNvb3JkaW5hdGVzIGluIGEgJ3NvdXRod2VzdF9sbmcsc291dGh3ZXN0X2xhdCxub3J0aGVhc3RfbG5nLG5vcnRoZWFzdF9sYXQnIGZvcm1hdC4gVXNlZnVsIGZvciBzZW5kaW5nIHJlcXVlc3RzIHRvIHdlYiBzZXJ2aWNlcyB0aGF0IHJldHVybiBnZW8gZGF0YS5cclxuXHR0b0JCb3hTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbdGhpcy5nZXRXZXN0KCksIHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0Tm9ydGgoKV0uam9pbignLCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVxdWl2YWxlbnQgKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikgdG8gdGhlIGdpdmVuIGJvdW5kcy4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcywgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QuZXF1YWxzKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgbWF4TWFyZ2luKSAmJlxyXG5cdFx0ICAgICAgIHRoaXMuX25vcnRoRWFzdC5lcXVhbHMoYm91bmRzLmdldE5vcnRoRWFzdCgpLCBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMuX3NvdXRoV2VzdCAmJiB0aGlzLl9ub3J0aEVhc3QpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIFRPRE8gSW50ZXJuYXRpb25hbCBkYXRlIGxpbmU/XHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxOiBMYXRMbmcsIGNvcm5lcjI6IExhdExuZylcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBieSBkZWZpbmluZyB0d28gZGlhZ29uYWxseSBvcHBvc2l0ZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMobGF0bG5nczogTGF0TG5nW10pXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgZGVmaW5lZCBieSB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50cyBpdCBjb250YWlucy4gVmVyeSB1c2VmdWwgZm9yIHpvb21pbmcgdGhlIG1hcCB0byBmaXQgYSBwYXJ0aWN1bGFyIHNldCBvZiBsb2NhdGlvbnMgd2l0aCBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTGF0TG5nQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKGEsIGIpO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9jcnMvQ1JTLkVhcnRoJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi9MYXRMbmdCb3VuZHMnO1xyXG5cclxuLyogQGNsYXNzIExhdExuZ1xyXG4gKiBAYWthIEwuTGF0TG5nXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCBhIGNlcnRhaW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIHZhciBsYXRsbmcgPSBMLmxhdExuZyg1MC41LCAzMC41KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtIGFuZCBzaW1wbGUgb2JqZWN0IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBgXHJcbiAqIG1hcC5wYW5UbyhbNTAsIDMwXSk7XHJcbiAqIG1hcC5wYW5Ubyh7bG9uOiAzMCwgbGF0OiA1MH0pO1xyXG4gKiBtYXAucGFuVG8oe2xhdDogNTAsIGxuZzogMzB9KTtcclxuICogbWFwLnBhblRvKEwubGF0TG5nKDUwLCAzMCkpO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBMYXRMbmdgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTGF0TG5nKGxhdCwgbG5nLCBhbHQpIHtcclxuXHRpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcclxuXHR9XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsYXQ6IE51bWJlclxyXG5cdC8vIExhdGl0dWRlIGluIGRlZ3JlZXNcclxuXHR0aGlzLmxhdCA9ICtsYXQ7XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsbmc6IE51bWJlclxyXG5cdC8vIExvbmdpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sbmcgPSArbG5nO1xyXG5cclxuXHQvLyBAcHJvcGVydHkgYWx0OiBOdW1iZXJcclxuXHQvLyBBbHRpdHVkZSBpbiBtZXRlcnMgKG9wdGlvbmFsKVxyXG5cdGlmIChhbHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhpcy5hbHQgPSArYWx0O1xyXG5cdH1cclxufVxyXG5cclxuTGF0TG5nLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckxhdExuZzogTGF0TG5nLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGBMYXRMbmdgIHBvaW50IGlzIGF0IHRoZSBzYW1lIHBvc2l0aW9uICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAob2JqLCBtYXhNYXJnaW4pIHtcclxuXHRcdGlmICghb2JqKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblxyXG5cdFx0dmFyIG1hcmdpbiA9IE1hdGgubWF4KFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxhdCAtIG9iai5sYXQpLFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxuZyAtIG9iai5sbmcpKTtcclxuXHJcblx0XHRyZXR1cm4gbWFyZ2luIDw9IChtYXhNYXJnaW4gPT09IHVuZGVmaW5lZCA/IDEuMEUtOSA6IG1heE1hcmdpbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlcykuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHJldHVybiAnTGF0TG5nKCcgK1xyXG5cdFx0ICAgICAgICBVdGlsLmZvcm1hdE51bSh0aGlzLmxhdCwgcHJlY2lzaW9uKSArICcsICcgK1xyXG5cdFx0ICAgICAgICBVdGlsLmZvcm1hdE51bSh0aGlzLmxuZywgcHJlY2lzaW9uKSArICcpJztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJMYXRMbmc6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIChpbiBtZXRlcnMpIHRvIHRoZSBnaXZlbiBgTGF0TG5nYCBjYWxjdWxhdGVkIHVzaW5nIHRoZSBbU3BoZXJpY2FsIExhdyBvZiBDb3NpbmVzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGhlcmljYWxfbGF3X29mX2Nvc2luZXMpLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChvdGhlcikge1xyXG5cdFx0cmV0dXJuIEVhcnRoLmRpc3RhbmNlKHRoaXMsIHRvTGF0TG5nKG90aGVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ2Agb2JqZWN0IHdpdGggdGhlIGxvbmdpdHVkZSB3cmFwcGVkIHNvIGl0J3MgYWx3YXlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBFYXJ0aC53cmFwTGF0TG5nKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9Cb3VuZHMoc2l6ZUluTWV0ZXJzOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnMvMmAgbWV0ZXJzIGFwYXJ0IGZyb20gdGhlIGBMYXRMbmdgLlxyXG5cdHRvQm91bmRzOiBmdW5jdGlvbiAoc2l6ZUluTWV0ZXJzKSB7XHJcblx0XHR2YXIgbGF0QWNjdXJhY3kgPSAxODAgKiBzaXplSW5NZXRlcnMgLyA0MDA3NTAxNyxcclxuXHRcdCAgICBsbmdBY2N1cmFjeSA9IGxhdEFjY3VyYWN5IC8gTWF0aC5jb3MoKE1hdGguUEkgLyAxODApICogdGhpcy5sYXQpO1xyXG5cclxuXHRcdHJldHVybiB0b0xhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgW3RoaXMubGF0IC0gbGF0QWNjdXJhY3ksIHRoaXMubG5nIC0gbG5nQWNjdXJhY3ldLFxyXG5cdFx0ICAgICAgICBbdGhpcy5sYXQgKyBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgKyBsbmdBY2N1cmFjeV0pO1xyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmxhdCwgdGhpcy5sbmcsIHRoaXMuYWx0KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGxhdGl0dWRlOiBOdW1iZXIsIGxvbmdpdHVkZTogTnVtYmVyLCBhbHRpdHVkZT86IE51bWJlcik6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAoYW5kIG9wdGlvbmFsbHkgYWx0aXR1ZGUpLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW051bWJlciwgTnVtYmVyXWAgb3IgYFtOdW1iZXIsIE51bWJlciwgTnVtYmVyXWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlcn1gIG9yIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyLCBhbHQ6IE51bWJlcn1gIGluc3RlYWQuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9MYXRMbmcoYSwgYiwgYykge1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKFV0aWwuaXNBcnJheShhKSAmJiB0eXBlb2YgYVswXSAhPT0gJ29iamVjdCcpIHtcclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMykge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdLCBhWzJdKTtcclxuXHRcdH1cclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKGEubGF0LCAnbG5nJyBpbiBhID8gYS5sbmcgOiBhLmxvbiwgYS5hbHQpO1xyXG5cdH1cclxuXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoYSwgYiwgYyk7XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuQmFzZVxyXG4gKiBPYmplY3QgdGhhdCBkZWZpbmVzIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbXMgZm9yIHByb2plY3RpbmdcclxuICogZ2VvZ3JhcGhpY2FsIHBvaW50cyBpbnRvIHBpeGVsIChzY3JlZW4pIGNvb3JkaW5hdGVzIGFuZCBiYWNrIChhbmQgdG9cclxuICogY29vcmRpbmF0ZXMgaW4gb3RoZXIgdW5pdHMgZm9yIFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMpLiBTZWVcclxuICogW3NwYXRpYWwgcmVmZXJlbmNlIHN5c3RlbV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db29yZGluYXRlX3JlZmVyZW5jZV9zeXN0ZW0pLlxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlZmluZXMgdGhlIG1vc3QgdXN1YWwgQ1JTcyBieSBkZWZhdWx0LiBJZiB5b3Ugd2FudCB0byB1c2UgYVxyXG4gKiBDUlMgbm90IGRlZmluZWQgYnkgZGVmYXVsdCwgdGFrZSBhIGxvb2sgYXQgdGhlXHJcbiAqIFtQcm9qNExlYWZsZXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJ0ZW5hL1Byb2o0TGVhZmxldCkgcGx1Z2luLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhlIENSUyBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogYW5kIGNhbid0IGJlIGluc3RhbnRpYXRlZC4gQWxzbywgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIHRoZW0sXHJcbiAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQ1JTID0ge1xyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Qb2ludChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBnaXZlbiB6b29tLlxyXG5cdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuXHQvLyB6b29tIGludG8gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cdHBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICB1bnRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGNvb3JkaW5hdGVzIGluIHVuaXRzIGFjY2VwdGVkIGZvclxyXG5cdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcHJvamVjdGVkIGNvb3JkaW5hdGUgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBMYXRMbmcuXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChwb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZSh6b29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSB1c2VkIHdoZW4gdHJhbnNmb3JtaW5nIHByb2plY3RlZCBjb29yZGluYXRlcyBpbnRvXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG5cdC8vIGAyNTYgKiAyXnpvb21gIGZvciBNZXJjYXRvci1iYXNlZCBDUlMuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tKHNjYWxlOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5nIHRvIGEgc2NhbGVcclxuXHQvLyBmYWN0b3Igb2YgYHNjYWxlYC5cclxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFByb2plY3RlZEJvdW5kcyh6b29tOiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcblx0Z2V0UHJvamVjdGVkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0aWYgKHRoaXMuaW5maW5pdGUpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcblx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcblx0XHQgICAgcyA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgbWluID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5taW4sIHMpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhtaW4sIG1heCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHJcblx0Ly8gQHByb3BlcnR5IGNvZGU6IFN0cmluZ1xyXG5cdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxyXG5cdC8vXHJcblx0Ly8gQHByb3BlcnR5IHdyYXBMbmc6IE51bWJlcltdXHJcblx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXHJcblx0Ly8gYXhpcyB3cmFwcyBhcm91bmQgYSBnaXZlbiByYW5nZSBhbmQgaG93LiBEZWZhdWx0cyB0byBgWy0xODAsIDE4MF1gIGluIG1vc3RcclxuXHQvLyBnZW9ncmFwaGljYWwgQ1JTcy4gSWYgYHVuZGVmaW5lZGAsIHRoZSBsb25naXR1ZGUgYXhpcyBkb2VzIG5vdCB3cmFwIGFyb3VuZC5cclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTGF0OiBOdW1iZXJbXVxyXG5cdC8vIExpa2UgYHdyYXBMbmdgLCBidXQgZm9yIHRoZSBsYXRpdHVkZSAodmVydGljYWwpIGF4aXMuXHJcblxyXG5cdC8vIHdyYXBMbmc6IFttaW4sIG1heF0sXHJcblx0Ly8gd3JhcExhdDogW21pbiwgbWF4XSxcclxuXHJcblx0Ly8gQHByb3BlcnR5IGluZmluaXRlOiBCb29sZWFuXHJcblx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuXHRpbmZpbml0ZTogZmFsc2UsXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IFV0aWwud3JhcE51bShsYXRsbmcubG5nLCB0aGlzLndyYXBMbmcsIHRydWUpIDogbGF0bG5nLmxuZyxcclxuXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyBVdGlsLndyYXBOdW0obGF0bG5nLmxhdCwgdGhpcy53cmFwTGF0LCB0cnVlKSA6IGxhdGxuZy5sYXQsXHJcblx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhsYXQsIGxuZywgYWx0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nXHJcblx0Ly8gdGhhdCBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dmFyIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLndyYXBMYXRMbmcoY2VudGVyKSxcclxuXHRcdCAgICBsYXRTaGlmdCA9IGNlbnRlci5sYXQgLSBuZXdDZW50ZXIubGF0LFxyXG5cdFx0ICAgIGxuZ1NoaWZ0ID0gY2VudGVyLmxuZyAtIG5ld0NlbnRlci5sbmc7XHJcblxyXG5cdFx0aWYgKGxhdFNoaWZ0ID09PSAwICYmIGxuZ1NoaWZ0ID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBib3VuZHM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cdFx0ICAgIG5ld1N3ID0gbmV3IExhdExuZyhzdy5sYXQgLSBsYXRTaGlmdCwgc3cubG5nIC0gbG5nU2hpZnQpLFxyXG5cdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKG5ld1N3LCBuZXdOZSk7XHJcblx0fVxyXG59O1xyXG4iLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuRWFydGhcbiAqXG4gKiBTZXJ2ZXMgYXMgdGhlIGJhc2UgZm9yIENSUyB0aGF0IGFyZSBnbG9iYWwgc3VjaCB0aGF0IHRoZXkgY292ZXIgdGhlIGVhcnRoLlxuICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAqIHNpbmNlIGl0IGRvZXMgbm90IGhhdmUgYSBgY29kZWAsIGBwcm9qZWN0aW9uYCBvciBgdHJhbnNmb3JtYXRpb25gLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogbWV0ZXJzLlxuICovXG5cbmV4cG9ydCB2YXIgRWFydGggPSBVdGlsLmV4dGVuZCh7fSwgQ1JTLCB7XG5cdHdyYXBMbmc6IFstMTgwLCAxODBdLFxuXG5cdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG5cdC8vIHRoZSBJbnRlcm5hdGlvbmFsIFVuaW9uIG9mIEdlb2Rlc3kgYW5kIEdlb3BoeXNpY3MsXG5cdC8vIHNlZSBodHRwOi8vcm9zZXR0YWNvZGUub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcblx0UjogNjM3MTAwMCxcblxuXHQvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgcG9pbnRzIHVzaW5nIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdCAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG5cdFx0ICAgIGxhdDIgPSBsYXRsbmcyLmxhdCAqIHJhZCxcblx0XHQgICAgc2luRExhdCA9IE1hdGguc2luKChsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0KSAqIHJhZCAvIDIpLFxuXHRcdCAgICBzaW5ETG9uID0gTWF0aC5zaW4oKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpICogcmFkIC8gMiksXG5cdFx0ICAgIGEgPSBzaW5ETGF0ICogc2luRExhdCArIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBzaW5ETG9uICogc2luRExvbixcblx0XHQgICAgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG5cdFx0cmV0dXJuIHRoaXMuUiAqIGM7XG5cdH1cbn0pO1xuIiwiaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yXHJcbiAqXHJcbiAqIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBjb21tb24gcHJvamVjdGlvbiBmb3Igb25saW5lIG1hcHMsXHJcbiAqIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBBc3N1bWVzIHRoYXQgRWFydGggaXNcclxuICogYSBzcGhlcmUuIFVzZWQgYnkgdGhlIGBFUFNHOjM4NTdgIENSUy5cclxuICovXHJcblxyXG52YXIgZWFydGhSYWRpdXMgPSA2Mzc4MTM3O1xyXG5cclxuZXhwb3J0IHZhciBTcGhlcmljYWxNZXJjYXRvciA9IHtcclxuXHJcblx0UjogZWFydGhSYWRpdXMsXHJcblx0TUFYX0xBVElUVURFOiA4NS4wNTExMjg3Nzk4LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgbWF4ID0gdGhpcy5NQVhfTEFUSVRVREUsXHJcblx0XHQgICAgbGF0ID0gTWF0aC5tYXgoTWF0aC5taW4obWF4LCBsYXRsbmcubGF0KSwgLW1heCksXHJcblx0XHQgICAgc2luID0gTWF0aC5zaW4obGF0ICogZCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdFx0dGhpcy5SICogbGF0bG5nLmxuZyAqIGQsXHJcblx0XHRcdHRoaXMuUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyKTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG5cdFx0XHQoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55IC8gdGhpcy5SKSkgLSAoTWF0aC5QSSAvIDIpKSAqIGQsXHJcblx0XHRcdHBvaW50LnggKiBkIC8gdGhpcy5SKTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZCA9IGVhcnRoUmFkaXVzICogTWF0aC5QSTtcclxuXHRcdHJldHVybiBuZXcgQm91bmRzKFstZCwgLWRdLCBbZCwgZF0pO1xyXG5cdH0pKClcclxufTtcclxuIiwiaW1wb3J0IHtQb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblxyXG4gKiBAYWthIEwuVHJhbnNmb3JtYXRpb25cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb246IGEgc2V0IG9mIGNvZWZmaWNpZW50cyBgYWAsIGBiYCwgYGNgLCBgZGBcclxuICogZm9yIHRyYW5zZm9ybWluZyBhIHBvaW50IG9mIGEgZm9ybSBgKHgsIHkpYCBpbnRvIGAoYSp4ICsgYiwgYyp5ICsgZClgIGFuZCBkb2luZ1xyXG4gKiB0aGUgcmV2ZXJzZS4gVXNlZCBieSBMZWFmbGV0IGluIGl0cyBwcm9qZWN0aW9ucyBjb2RlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdHJhbnNmb3JtYXRpb24gPSBMLnRyYW5zZm9ybWF0aW9uKDIsIDUsIC0xLCAxMCksXHJcbiAqIFx0cCA9IEwucG9pbnQoMSwgMiksXHJcbiAqIFx0cDIgPSB0cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0ocCksIC8vICBMLnBvaW50KDcsIDgpXHJcbiAqIFx0cDMgPSB0cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwMik7IC8vICBMLnBvaW50KDEsIDIpXHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG4vLyBmYWN0b3J5IG5ldyBMLlRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuLy8gQ3JlYXRlcyBhIGBUcmFuc2Zvcm1hdGlvbmAgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuXHRpZiAoVXRpbC5pc0FycmF5KGEpKSB7XHJcblx0XHQvLyB1c2UgYXJyYXkgcHJvcGVydGllc1xyXG5cdFx0dGhpcy5fYSA9IGFbMF07XHJcblx0XHR0aGlzLl9iID0gYVsxXTtcclxuXHRcdHRoaXMuX2MgPSBhWzJdO1xyXG5cdFx0dGhpcy5fZCA9IGFbM107XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cdHRoaXMuX2EgPSBhO1xyXG5cdHRoaXMuX2IgPSBiO1xyXG5cdHRoaXMuX2MgPSBjO1xyXG5cdHRoaXMuX2QgPSBkO1xyXG59XHJcblxyXG5UcmFuc2Zvcm1hdGlvbi5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCB0cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIHRyYW5zZm9ybWVkIHBvaW50LCBvcHRpb25hbGx5IG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIHNjYWxlLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHsgLy8gKFBvaW50LCBOdW1iZXIpIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHBvaW50LmNsb25lKCksIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXN0cnVjdGl2ZSB0cmFuc2Zvcm0gKGZhc3RlcilcclxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRwb2ludC54ID0gc2NhbGUgKiAodGhpcy5fYSAqIHBvaW50LnggKyB0aGlzLl9iKTtcclxuXHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW50cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmV2ZXJzZSB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQsIG9wdGlvbmFsbHkgZGl2aWRlZFxyXG5cdC8vIGJ5IHRoZSBnaXZlbiBzY2FsZS4gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHVudHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0ICAgICAgICAocG9pbnQueCAvIHNjYWxlIC0gdGhpcy5fYikgLyB0aGlzLl9hLFxyXG5cdFx0ICAgICAgICAocG9pbnQueSAvIHNjYWxlIC0gdGhpcy5fZCkgLyB0aGlzLl9jKTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG5cclxuLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIEluc3RhbnRpYXRlcyBhIFRyYW5zZm9ybWF0aW9uIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihjb2VmZmljaWVudHM6IEFycmF5KTogVHJhbnNmb3JtYXRpb25cclxuLy8gRXhwZWN0cyBhbiBjb2VmZmljaWVudHMgYXJyYXkgb2YgdGhlIGZvcm1cclxuLy8gYFthOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXJdYC5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1RyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuXHRyZXR1cm4gbmV3IFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpO1xyXG59XHJcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtTcGhlcmljYWxNZXJjYXRvcn0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yJztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzM4NTdcclxuICpcclxuICogVGhlIG1vc3QgY29tbW9uIENSUyBmb3Igb25saW5lIG1hcHMsIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsXHJcbiAqIHRpbGUgcHJvdmlkZXJzLiBVc2VzIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLiBTZXQgaW4gYnkgZGVmYXVsdCBpblxyXG4gKiBNYXAncyBgY3JzYCBvcHRpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFUFNHMzg1NyA9IFV0aWwuZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG5cdHByb2plY3Rpb246IFNwaGVyaWNhbE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogU3BoZXJpY2FsTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXHJcbmV4cG9ydCB2YXIgRVBTRzkwMDkxMyA9IFV0aWwuZXh0ZW5kKHt9LCBFUFNHMzg1Nywge1xyXG5cdGNvZGU6ICdFUFNHOjkwMDkxMydcclxufSk7XHJcbiIsImltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuLy8gQG5hbWVzcGFjZSBTVkc7IEBzZWN0aW9uXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuU1ZHOlxuXG4vLyBAZnVuY3Rpb24gY3JlYXRlKG5hbWU6IFN0cmluZyk6IFNWR0VsZW1lbnRcbi8vIFJldHVybnMgYSBpbnN0YW5jZSBvZiBbU1ZHRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpLFxuLy8gY29ycmVzcG9uZGluZyB0byB0aGUgY2xhc3MgbmFtZSBwYXNzZWQuIEZvciBleGFtcGxlLCB1c2luZyAnbGluZScgd2lsbCByZXR1cm5cbi8vIGFuIGluc3RhbmNlIG9mIFtTVkdMaW5lRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0xpbmVFbGVtZW50KS5cbmV4cG9ydCBmdW5jdGlvbiBzdmdDcmVhdGUobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuXG4vLyBAZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzOiBQb2ludFtdLCBjbG9zZWQ6IEJvb2xlYW4pOiBTdHJpbmdcbi8vIEdlbmVyYXRlcyBhIFNWRyBwYXRoIHN0cmluZyBmb3IgbXVsdGlwbGUgcmluZ3MsIHdpdGggZWFjaCByaW5nIHR1cm5pbmdcbi8vIGludG8gXCJNLi5MLi5MLi5cIiBpbnN0cnVjdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3MsIGNsb3NlZCkge1xuXHR2YXIgc3RyID0gJycsXG5cdGksIGosIGxlbiwgbGVuMiwgcG9pbnRzLCBwO1xuXG5cdGZvciAoaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0cG9pbnRzID0gcmluZ3NbaV07XG5cblx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0cCA9IHBvaW50c1tqXTtcblx0XHRcdHN0ciArPSAoaiA/ICdMJyA6ICdNJykgKyBwLnggKyAnICcgKyBwLnk7XG5cdFx0fVxuXG5cdFx0Ly8gY2xvc2VzIHRoZSByaW5nIGZvciBwb2x5Z29uczsgXCJ4XCIgaXMgVk1MIHN5bnRheFxuXHRcdHN0ciArPSBjbG9zZWQgPyAoQnJvd3Nlci5zdmcgPyAneicgOiAneCcpIDogJyc7XG5cdH1cblxuXHQvLyBTVkcgY29tcGxhaW5zIGFib3V0IGVtcHR5IHBhdGggc3RyaW5nc1xuXHRyZXR1cm4gc3RyIHx8ICdNMCAwJztcbn1cblxuXG5cblxuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xyXG5pbXBvcnQge3N2Z0NyZWF0ZX0gZnJvbSAnLi4vbGF5ZXIvdmVjdG9yL1NWRy5VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQnJvd3NlclxyXG4gKiBAYWthIEwuQnJvd3NlclxyXG4gKlxyXG4gKiBBIG5hbWVzcGFjZSB3aXRoIHN0YXRpYyBwcm9wZXJ0aWVzIGZvciBicm93c2VyL2ZlYXR1cmUgZGV0ZWN0aW9uIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcbiAqICAgYWxlcnQoJ1VwZ3JhZGUgeW91ciBicm93c2VyLCBkdWRlIScpO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBpZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgKG5vdCBFZGdlKS5cclxuZXhwb3J0IHZhciBpZSA9ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3c7XHJcblxyXG4vLyBAcHJvcGVydHkgaWVsdDk6IEJvb2xlYW47IGB0cnVlYCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgbGVzcyB0aGFuIDkuXHJcbmV4cG9ydCB2YXIgaWVsdDkgPSBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHJcbi8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG5leHBvcnQgdmFyIGVkZ2UgPSAnbXNMYXVuY2hVcmknIGluIG5hdmlnYXRvciAmJiAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3ZWJraXQ6IEJvb2xlYW47XHJcbi8vIGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIGxpa2UgQ2hyb21lIGFuZCBTYWZhcmkgKGluY2x1ZGluZyBtb2JpbGUgdmVyc2lvbnMpLlxyXG5leHBvcnQgdmFyIHdlYmtpdCA9IHVzZXJBZ2VudENvbnRhaW5zKCd3ZWJraXQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYW55IGJyb3dzZXIgcnVubmluZyBvbiBhbiBBbmRyb2lkIHBsYXRmb3JtLlxyXG5leHBvcnQgdmFyIGFuZHJvaWQgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCcpO1xyXG5cclxuLy8gQHByb3BlcnR5IGFuZHJvaWQyMzogQm9vbGVhbjsgYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXHJcbmV4cG9ydCB2YXIgYW5kcm9pZDIzID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQgMicpIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDMnKTtcclxuXHJcbi8qIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTc5NjEyNjYgZm9yIGRldGFpbHMgb24gZGV0ZWN0aW5nIHN0b2NrIEFuZHJvaWQgKi9cclxudmFyIHdlYmtpdFZlciA9IHBhcnNlSW50KC9XZWJLaXRcXC8oWzAtOV0rKXwkLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpWzFdLCAxMCk7IC8vIGFsc28gbWF0Y2hlcyBBcHBsZVdlYktpdFxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZFN0b2NrOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBBbmRyb2lkIHN0b2NrIGJyb3dzZXIgKGkuZS4gbm90IENocm9tZSlcclxuZXhwb3J0IHZhciBhbmRyb2lkU3RvY2sgPSBhbmRyb2lkICYmIHVzZXJBZ2VudENvbnRhaW5zKCdHb29nbGUnKSAmJiB3ZWJraXRWZXIgPCA1MzcgJiYgISgnQXVkaW9Ob2RlJyBpbiB3aW5kb3cpO1xyXG5cclxuLy8gQHByb3BlcnR5IG9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyXHJcbmV4cG9ydCB2YXIgb3BlcmEgPSAhIXdpbmRvdy5vcGVyYTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBjaHJvbWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIENocm9tZSBicm93c2VyLlxyXG5leHBvcnQgdmFyIGNocm9tZSA9IHVzZXJBZ2VudENvbnRhaW5zKCdjaHJvbWUnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBnZWNrbzogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBsaWtlIEZpcmVmb3guXHJcbmV4cG9ydCB2YXIgZ2Vja28gPSB1c2VyQWdlbnRDb250YWlucygnZ2Vja28nKSAmJiAhd2Via2l0ICYmICFvcGVyYSAmJiAhaWU7XHJcblxyXG4vLyBAcHJvcGVydHkgc2FmYXJpOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBTYWZhcmkgYnJvd3Nlci5cclxuZXhwb3J0IHZhciBzYWZhcmkgPSAhY2hyb21lICYmIHVzZXJBZ2VudENvbnRhaW5zKCdzYWZhcmknKTtcclxuXHJcbmV4cG9ydCB2YXIgcGhhbnRvbSA9IHVzZXJBZ2VudENvbnRhaW5zKCdwaGFudG9tJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgb3BlcmExMjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMgKHZlcnNpb24gMTIgb3IgbGF0ZXIpLlxyXG5leHBvcnQgdmFyIG9wZXJhMTIgPSAnT1RyYW5zaXRpb24nIGluIHN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IHdpbjogQm9vbGVhbjsgYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIFdpbmRvd3MgcGxhdGZvcm1cclxuZXhwb3J0IHZhciB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDA7XHJcblxyXG4vLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBzdHlsZSk7XHJcblxyXG4vLyBAcHJvcGVydHkgd2Via2l0M2Q6IEJvb2xlYW47IGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMztcclxuXHJcbi8vIEBwcm9wZXJ0eSBnZWNrbzNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgYW55M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciBhbnkzZCA9ICF3aW5kb3cuTF9ESVNBQkxFXzNEICYmIChpZTNkIHx8IHdlYmtpdDNkIHx8IGdlY2tvM2QpICYmICFvcGVyYTEyICYmICFwaGFudG9tO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbmV4cG9ydCB2YXIgbW9iaWxlID0gdHlwZW9mIG9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJyB8fCB1c2VyQWdlbnRDb250YWlucygnbW9iaWxlJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZVdlYmtpdCA9IG1vYmlsZSAmJiB3ZWJraXQ7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgdmFyIG1vYmlsZVdlYmtpdDNkID0gbW9iaWxlICYmIHdlYmtpdDNkO1xyXG5cclxuLy8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIGltcGxlbWVudGluZyB0aGUgTWljcm9zb2Z0IHRvdWNoIGV2ZW50cyBtb2RlbCAobm90YWJseSBJRTEwKS5cclxuZXhwb3J0IHZhciBtc1BvaW50ZXIgPSAhd2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cuTVNQb2ludGVyRXZlbnQ7XHJcblxyXG4vLyBAcHJvcGVydHkgcG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFtwb2ludGVyIGV2ZW50c10oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0NCUyOHY9dnMuODUlMjkuYXNweCkuXHJcbmV4cG9ydCB2YXIgcG9pbnRlciA9ICF3ZWJraXQgJiYgISEod2luZG93LlBvaW50ZXJFdmVudCB8fCBtc1BvaW50ZXIpO1xyXG5cclxuLy8gQHByb3BlcnR5IHRvdWNoOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3RvdWNoIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1RvdWNoX2V2ZW50cykuXHJcbi8vIFRoaXMgZG9lcyBub3QgbmVjZXNzYXJpbHkgbWVhbiB0aGF0IHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBjb21wdXRlciB3aXRoXHJcbi8vIGEgdG91Y2hzY3JlZW4sIGl0IG9ubHkgbWVhbnMgdGhhdCB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mIHVuZGVyc3RhbmRpbmdcclxuLy8gdG91Y2ggZXZlbnRzLlxyXG5leHBvcnQgdmFyIHRvdWNoID0gIXdpbmRvdy5MX05PX1RPVUNIICYmIChwb2ludGVyIHx8ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fFxyXG5cdFx0KHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVPcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbmV4cG9ydCB2YXIgbW9iaWxlT3BlcmEgPSBtb2JpbGUgJiYgb3BlcmE7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlR2Vja286IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxuZXhwb3J0IHZhciBtb2JpbGVHZWNrbyA9IG1vYmlsZSAmJiBnZWNrbztcclxuXHJcbi8vIEBwcm9wZXJ0eSByZXRpbmE6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyBvbiBhIGhpZ2gtcmVzb2x1dGlvbiBcInJldGluYVwiIHNjcmVlbiBvciBvbiBhbnkgc2NyZWVuIHdoZW4gYnJvd3NlcidzIGRpc3BsYXkgem9vbSBpcyBtb3JlIHRoYW4gMTAwJS5cclxuZXhwb3J0IHZhciByZXRpbmEgPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgKHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSAvIHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkpKSA+IDE7XHJcblxyXG4vLyBAcHJvcGVydHkgcGFzc2l2ZUV2ZW50czogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBwYXNzaXZlIGV2ZW50cy5cclxuZXhwb3J0IHZhciBwYXNzaXZlRXZlbnRzID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgc3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gZmFsc2U7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0c3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBVdGlsLmZhbHNlRm4sIG9wdHMpO1xyXG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlRXZlbnRTdXBwb3J0JywgVXRpbC5mYWxzZUZuLCBvcHRzKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvLyBFcnJvcnMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIHNpbmNlIHRoaXMgaXMgb25seSBhIGJyb3dzZXIgc3VwcG9ydCB0ZXN0LlxyXG5cdH1cclxuXHRyZXR1cm4gc3VwcG9ydHNQYXNzaXZlT3B0aW9uO1xyXG59KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBjYW52YXM6IEJvb2xlYW5cclxuLy8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cclxuZXhwb3J0IHZhciBjYW52YXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXHJcbmV4cG9ydCB2YXIgc3ZnID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIHN2Z0NyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XHJcblxyXG4vLyBAcHJvcGVydHkgdm1sOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKS5cclxuZXhwb3J0IHZhciB2bWwgPSAhc3ZnICYmIChmdW5jdGlvbiAoKSB7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xyXG5cclxuXHRcdHZhciBzaGFwZSA9IGRpdi5maXJzdENoaWxkO1xyXG5cdFx0c2hhcGUuc3R5bGUuYmVoYXZpb3IgPSAndXJsKCNkZWZhdWx0I1ZNTCknO1xyXG5cclxuXHRcdHJldHVybiBzaGFwZSAmJiAodHlwZW9mIHNoYXBlLmFkaiA9PT0gJ29iamVjdCcpO1xyXG5cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59KCkpO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZXJBZ2VudENvbnRhaW5zKHN0cikge1xyXG5cdHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdHIpID49IDA7XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8qXG4gKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxuICovXG5cblxudmFyIFBPSU5URVJfRE9XTiA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgICA6ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9NT1ZFID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJNb3ZlJyAgIDogJ3BvaW50ZXJtb3ZlJztcbnZhciBQT0lOVEVSX1VQID0gICAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyAgICAgOiAncG9pbnRlcnVwJztcbnZhciBQT0lOVEVSX0NBTkNFTCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckNhbmNlbCcgOiAncG9pbnRlcmNhbmNlbCc7XG52YXIgVEFHX1dISVRFX0xJU1QgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdPUFRJT04nXTtcblxudmFyIF9wb2ludGVycyA9IHt9O1xudmFyIF9wb2ludGVyRG9jTGlzdGVuZXIgPSBmYWxzZTtcblxuLy8gRG9tRXZlbnQuRG91YmxlVGFwIG5lZWRzIHRvIGtub3cgYWJvdXQgdGhpc1xuZXhwb3J0IHZhciBfcG9pbnRlcnNDb3VudCA9IDA7XG5cbi8vIFByb3ZpZGVzIGEgdG91Y2ggZXZlbnRzIHdyYXBwZXIgZm9yIChtcylwb2ludGVyIGV2ZW50cy5cbi8vIHJlZiBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCkge1xuXHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0X2FkZFBvaW50ZXJTdGFydChvYmosIGhhbmRsZXIsIGlkKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG5cdFx0X2FkZFBvaW50ZXJNb3ZlKG9iaiwgaGFuZGxlciwgaWQpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuXHRcdF9hZGRQb2ludGVyRW5kKG9iaiwgaGFuZGxlciwgaWQpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCkge1xuXHR2YXIgaGFuZGxlciA9IG9ialsnX2xlYWZsZXRfJyArIHR5cGUgKyBpZF07XG5cblx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIGhhbmRsZXIsIGZhbHNlKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIGhhbmRsZXIsIGZhbHNlKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlclN0YXJ0KG9iaiwgaGFuZGxlciwgaWQpIHtcblx0dmFyIG9uRG93biA9IFV0aWwuYmluZChmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLnBvaW50ZXJUeXBlICE9PSAnbW91c2UnICYmIGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgJiYgZS5wb2ludGVyVHlwZSAhPT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSkge1xuXHRcdFx0Ly8gSW4gSUUxMSwgc29tZSB0b3VjaCBldmVudHMgbmVlZHMgdG8gZmlyZSBmb3IgZm9ybSBjb250cm9scywgb3Jcblx0XHRcdC8vIHRoZSBjb250cm9scyB3aWxsIHN0b3Agd29ya2luZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBvZiB0YWcgbmFtZXMgdGhhdFxuXHRcdFx0Ly8gbmVlZCB0aGVzZSBldmVudHMuIEZvciBvdGhlciB0YXJnZXQgdGFncywgd2UgcHJldmVudCBkZWZhdWx0IG9uIHRoZSBldmVudC5cblx0XHRcdGlmIChUQUdfV0hJVEVfTElTVC5pbmRleE9mKGUudGFyZ2V0LnRhZ05hbWUpIDwgMCkge1xuXHRcdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0fSk7XG5cblx0b2JqWydfbGVhZmxldF90b3VjaHN0YXJ0JyArIGlkXSA9IG9uRG93bjtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBvbkRvd24sIGZhbHNlKTtcblxuXHQvLyBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCBwb2ludGVycyBhbmQgaG93IG1hbnkgYXJlIGFjdGl2ZSB0byBwcm92aWRlIGUudG91Y2hlcyBlbXVsYXRpb25cblx0aWYgKCFfcG9pbnRlckRvY0xpc3RlbmVyKSB7XG5cdFx0Ly8gd2UgbGlzdGVuIGRvY3VtZW50RWxlbWVudCBhcyBhbnkgZHJhZ3MgdGhhdCBlbmQgYnkgbW92aW5nIHRoZSB0b3VjaCBvZmYgdGhlIHNjcmVlbiBnZXQgZmlyZWQgdGhlcmVcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIF9nbG9iYWxQb2ludGVyRG93biwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBfZ2xvYmFsUG9pbnRlck1vdmUsIHRydWUpO1xuXHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblxuXHRcdF9wb2ludGVyRG9jTGlzdGVuZXIgPSB0cnVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyRG93bihlKSB7XG5cdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHRfcG9pbnRlcnNDb3VudCsrO1xufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlck1vdmUoZSkge1xuXHRpZiAoX3BvaW50ZXJzW2UucG9pbnRlcklkXSkge1xuXHRcdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyVXAoZSkge1xuXHRkZWxldGUgX3BvaW50ZXJzW2UucG9pbnRlcklkXTtcblx0X3BvaW50ZXJzQ291bnQtLTtcbn1cblxuZnVuY3Rpb24gX2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcikge1xuXHRlLnRvdWNoZXMgPSBbXTtcblx0Zm9yICh2YXIgaSBpbiBfcG9pbnRlcnMpIHtcblx0XHRlLnRvdWNoZXMucHVzaChfcG9pbnRlcnNbaV0pO1xuXHR9XG5cdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cblx0aGFuZGxlcihlKTtcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJNb3ZlKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0dmFyIG9uTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gZG9uJ3QgZmlyZSB0b3VjaCBtb3ZlcyB3aGVuIG1vdXNlIGlzbid0IGRvd25cblx0XHRpZiAoKGUucG9pbnRlclR5cGUgPT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgJiYgZS5idXR0b25zID09PSAwKSB7IHJldHVybjsgfVxuXG5cdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdH07XG5cblx0b2JqWydfbGVhZmxldF90b3VjaG1vdmUnICsgaWRdID0gb25Nb3ZlO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIG9uTW92ZSwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlckVuZChvYmosIGhhbmRsZXIsIGlkKSB7XG5cdHZhciBvblVwID0gZnVuY3Rpb24gKGUpIHtcblx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0fTtcblxuXHRvYmpbJ19sZWFmbGV0X3RvdWNoZW5kJyArIGlkXSA9IG9uVXA7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIG9uVXAsIGZhbHNlKTtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIG9uVXAsIGZhbHNlKTtcbn1cblxuIiwiaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQge19wb2ludGVyc0NvdW50fSBmcm9tICcuL0RvbUV2ZW50LlBvaW50ZXInO1xyXG5cclxuLypcclxuICogRXh0ZW5kcyB0aGUgZXZlbnQgaGFuZGxpbmcgY29kZSB3aXRoIGRvdWJsZSB0YXAgc3VwcG9ydCBmb3IgbW9iaWxlIGJyb3dzZXJzLlxyXG4gKi9cclxuXHJcbnZhciBfdG91Y2hzdGFydCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nIDogQnJvd3Nlci5wb2ludGVyID8gJ3BvaW50ZXJkb3duJyA6ICd0b3VjaHN0YXJ0JztcclxudmFyIF90b3VjaGVuZCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyA6IEJyb3dzZXIucG9pbnRlciA/ICdwb2ludGVydXAnIDogJ3RvdWNoZW5kJztcclxudmFyIF9wcmUgPSAnX2xlYWZsZXRfJztcclxuXHJcbi8vIGluc3BpcmVkIGJ5IFplcHRvIHRvdWNoIGNvZGUgYnkgVGhvbWFzIEZ1Y2hzXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKSB7XHJcblx0dmFyIGxhc3QsIHRvdWNoLFxyXG5cdCAgICBkb3VibGVUYXAgPSBmYWxzZSxcclxuXHQgICAgZGVsYXkgPSAyNTA7XHJcblxyXG5cdGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XHJcblx0XHR2YXIgY291bnQ7XHJcblxyXG5cdFx0aWYgKEJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRpZiAoKCFCcm93c2VyLmVkZ2UpIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHsgcmV0dXJuOyB9XHJcblx0XHRcdGNvdW50ID0gX3BvaW50ZXJzQ291bnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb3VudCA9IGUudG91Y2hlcy5sZW5ndGg7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvdW50ID4gMSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSxcclxuXHRcdCAgICBkZWx0YSA9IG5vdyAtIChsYXN0IHx8IG5vdyk7XHJcblxyXG5cdFx0dG91Y2ggPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xyXG5cdFx0ZG91YmxlVGFwID0gKGRlbHRhID4gMCAmJiBkZWx0YSA8PSBkZWxheSk7XHJcblx0XHRsYXN0ID0gbm93O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XHJcblx0XHRpZiAoZG91YmxlVGFwICYmICF0b3VjaC5jYW5jZWxCdWJibGUpIHtcclxuXHRcdFx0aWYgKEJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdGlmICgoIUJyb3dzZXIuZWRnZSkgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgeyByZXR1cm47IH1cclxuXHRcdFx0XHQvLyB3b3JrIGFyb3VuZCAudHlwZSBiZWluZyByZWFkb25seSB3aXRoIE1TUG9pbnRlciogZXZlbnRzXHJcblx0XHRcdFx0dmFyIG5ld1RvdWNoID0ge30sXHJcblx0XHRcdFx0ICAgIHByb3AsIGk7XHJcblxyXG5cdFx0XHRcdGZvciAoaSBpbiB0b3VjaCkge1xyXG5cdFx0XHRcdFx0cHJvcCA9IHRvdWNoW2ldO1xyXG5cdFx0XHRcdFx0bmV3VG91Y2hbaV0gPSBwcm9wICYmIHByb3AuYmluZCA/IHByb3AuYmluZCh0b3VjaCkgOiBwcm9wO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0b3VjaCA9IG5ld1RvdWNoO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRvdWNoLnR5cGUgPSAnZGJsY2xpY2snO1xyXG5cdFx0XHR0b3VjaC5idXR0b24gPSAwO1xyXG5cdFx0XHRoYW5kbGVyKHRvdWNoKTtcclxuXHRcdFx0bGFzdCA9IG51bGw7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRvYmpbX3ByZSArIF90b3VjaHN0YXJ0ICsgaWRdID0gb25Ub3VjaFN0YXJ0O1xyXG5cdG9ialtfcHJlICsgX3RvdWNoZW5kICsgaWRdID0gb25Ub3VjaEVuZDtcclxuXHRvYmpbX3ByZSArICdkYmxjbGljaycgKyBpZF0gPSBoYW5kbGVyO1xyXG5cclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihfdG91Y2hzdGFydCwgb25Ub3VjaFN0YXJ0LCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKF90b3VjaGVuZCwgb25Ub3VjaEVuZCwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHJcblx0Ly8gT24gc29tZSBwbGF0Zm9ybXMgKG5vdGFibHksIGNocm9tZTw1NSBvbiB3aW4xMCArIHRvdWNoc2NyZWVuICsgbW91c2UpLFxyXG5cdC8vIHRoZSBicm93c2VyIGRvZXNuJ3QgZmlyZSB0b3VjaGVuZC9wb2ludGVydXAgZXZlbnRzIGJ1dCBkb2VzIGZpcmVcclxuXHQvLyBuYXRpdmUgZGJsY2xpY2tzLiBTZWUgIzQxMjcuXHJcblx0Ly8gRWRnZSAxNCBhbHNvIGZpcmVzIG5hdGl2ZSBkYmxjbGlja3MsIGJ1dCBvbmx5IGZvciBwb2ludGVyVHlwZSBtb3VzZSwgc2VlICM1MTgwLlxyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKSB7XHJcblx0dmFyIHRvdWNoc3RhcnQgPSBvYmpbX3ByZSArIF90b3VjaHN0YXJ0ICsgaWRdLFxyXG5cdCAgICB0b3VjaGVuZCA9IG9ialtfcHJlICsgX3RvdWNoZW5kICsgaWRdLFxyXG5cdCAgICBkYmxjbGljayA9IG9ialtfcHJlICsgJ2RibGNsaWNrJyArIGlkXTtcclxuXHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3RvdWNoc3RhcnQsIHRvdWNoc3RhcnQsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3RvdWNoZW5kLCB0b3VjaGVuZCwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHRpZiAoIUJyb3dzZXIuZWRnZSkge1xyXG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZGJsY2xpY2ssIGZhbHNlKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBEb21VdGlsXHJcbiAqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0RvY3VtZW50X09iamVjdF9Nb2RlbClcclxuICogdHJlZSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIE1vc3QgZnVuY3Rpb25zIGV4cGVjdGluZyBvciByZXR1cm5pbmcgYSBgSFRNTEVsZW1lbnRgIGFsc28gd29yayBmb3JcclxuICogU1ZHIGVsZW1lbnRzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgY2xhc3NlcyByZWZlciB0byBDU1MgY2xhc3Nlc1xyXG4gKiBpbiBIVE1MIGFuZCBTVkcgY2xhc3NlcyBpbiBTVkcuXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0ZPUk06IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNmb3JtIHN0eWxlIG5hbWUgKGUuZy4gYCd3ZWJraXRUcmFuc2Zvcm0nYCBmb3IgV2ViS2l0KS5cclxuZXhwb3J0IHZhciBUUkFOU0ZPUk0gPSB0ZXN0UHJvcChcclxuXHRbJ3RyYW5zZm9ybScsICd3ZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXSk7XHJcblxyXG4vLyB3ZWJraXRUcmFuc2l0aW9uIGNvbWVzIGZpcnN0IGJlY2F1c2Ugc29tZSBicm93c2VyIHZlcnNpb25zIHRoYXQgZHJvcCB2ZW5kb3IgcHJlZml4IGRvbid0IGRvXHJcbi8vIHRoZSBzYW1lIGZvciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgaW4gcGFydGljdWxhciB0aGUgQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT046IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbiBzdHlsZSBuYW1lLlxyXG5leHBvcnQgdmFyIFRSQU5TSVRJT04gPSB0ZXN0UHJvcChcclxuXHRbJ3dlYmtpdFRyYW5zaXRpb24nLCAndHJhbnNpdGlvbicsICdPVHJhbnNpdGlvbicsICdNb3pUcmFuc2l0aW9uJywgJ21zVHJhbnNpdGlvbiddKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OX0VORDogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uZW5kIGV2ZW50IG5hbWUuXHJcbmV4cG9ydCB2YXIgVFJBTlNJVElPTl9FTkQgPVxyXG5cdFRSQU5TSVRJT04gPT09ICd3ZWJraXRUcmFuc2l0aW9uJyB8fCBUUkFOU0lUSU9OID09PSAnT1RyYW5zaXRpb24nID8gVFJBTlNJVElPTiArICdFbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXQoaWQ6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIFJldHVybnMgYW4gZWxlbWVudCBnaXZlbiBpdHMgRE9NIGlkLCBvciByZXR1cm5zIHRoZSBlbGVtZW50IGl0c2VsZlxyXG4vLyBpZiBpdCB3YXMgcGFzc2VkIGRpcmVjdGx5LlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGlkKSB7XHJcblx0cmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgc3R5bGVBdHRyaWI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgYSBjZXJ0YWluIHN0eWxlIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxyXG4vLyBpbmNsdWRpbmcgY29tcHV0ZWQgdmFsdWVzIG9yIHZhbHVlcyBzZXQgdGhyb3VnaCBDU1MuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHlsZShlbCwgc3R5bGUpIHtcclxuXHR2YXIgdmFsdWUgPSBlbC5zdHlsZVtzdHlsZV0gfHwgKGVsLmN1cnJlbnRTdHlsZSAmJiBlbC5jdXJyZW50U3R5bGVbc3R5bGVdKTtcclxuXHJcblx0aWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICdhdXRvJykgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcclxuXHRcdHZhciBjc3MgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcclxuXHRcdHZhbHVlID0gY3NzID8gY3NzW3N0eWxlXSA6IG51bGw7XHJcblx0fVxyXG5cdHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gbnVsbCA6IHZhbHVlO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWU6IFN0cmluZywgY2xhc3NOYW1lPzogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIENyZWF0ZXMgYW4gSFRNTCBlbGVtZW50IHdpdGggYHRhZ05hbWVgLCBzZXRzIGl0cyBjbGFzcyB0byBgY2xhc3NOYW1lYCwgYW5kIG9wdGlvbmFsbHkgYXBwZW5kcyBpdCB0byBgY29udGFpbmVyYCBlbGVtZW50LlxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuXHRlbC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XHJcblxyXG5cdGlmIChjb250YWluZXIpIHtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcblx0fVxyXG5cdHJldHVybiBlbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIFJlbW92ZXMgYGVsYCBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCkge1xyXG5cdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBlbXB0eShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIFJlbW92ZXMgYWxsIG9mIGBlbGAncyBjaGlsZHJlbiBlbGVtZW50cyBmcm9tIGBlbGBcclxuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5KGVsKSB7XHJcblx0d2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcclxuXHRcdGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRvRnJvbnQoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyBgZWxgIHRoZSBsYXN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgaW4gZnJvbnQgb2YgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Gcm9udChlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQgJiYgcGFyZW50Lmxhc3RDaGlsZCAhPT0gZWwpIHtcclxuXHRcdHBhcmVudC5hcHBlbmRDaGlsZChlbCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdG9CYWNrKGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgYGVsYCB0aGUgZmlyc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBiZWhpbmQgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9CYWNrKGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCAmJiBwYXJlbnQuZmlyc3RDaGlsZCAhPT0gZWwpIHtcclxuXHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoZWwsIHBhcmVudC5maXJzdENoaWxkKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBoYXNDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZyk6IEJvb2xlYW5cclxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUgY29udGFpbnMgYG5hbWVgLlxyXG5leHBvcnQgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XHJcblx0fVxyXG5cdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcblx0cmV0dXJuIGNsYXNzTmFtZS5sZW5ndGggPiAwICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBBZGRzIGBuYW1lYCB0byB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR2YXIgY2xhc3NlcyA9IFV0aWwuc3BsaXRXb3JkcyhuYW1lKTtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICghaGFzQ2xhc3MoZWwsIG5hbWUpKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0c2V0Q2xhc3MoZWwsIChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuYW1lKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gUmVtb3ZlcyBgbmFtZWAgZnJvbSB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzZXRDbGFzcyhlbCwgVXRpbC50cmltKCgnICcgKyBnZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKSkpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBTZXRzIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRlbC5jbGFzc05hbWUgPSBuYW1lO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBpbiBjYXNlIG9mIFNWRyBlbGVtZW50XHJcblx0XHRlbC5jbGFzc05hbWUuYmFzZVZhbCA9IG5hbWU7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50KTogU3RyaW5nXHJcbi8vIFJldHVybnMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENsYXNzKGVsKSB7XHJcblx0Ly8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgYW4gU1ZHRWxlbWVudEluc3RhbmNlIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmdFbGVtZW50IGluc3RlYWRcclxuXHQvLyAoUmVxdWlyZWQgZm9yIGxpbmtlZCBTVkcgZWxlbWVudHMgaW4gSUUxMS4pXHJcblx0aWYgKGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50KSB7XHJcblx0XHRlbCA9IGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50O1xyXG5cdH1cclxuXHRyZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0T3BhY2l0eShlbDogSFRNTEVsZW1lbnQsIG9wYWNpdHk6IE51bWJlcilcclxuLy8gU2V0IHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgKGluY2x1ZGluZyBvbGQgSUUgc3VwcG9ydCkuXHJcbi8vIGBvcGFjaXR5YCBtdXN0IGJlIGEgbnVtYmVyIGZyb20gYDBgIHRvIGAxYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldE9wYWNpdHkoZWwsIHZhbHVlKSB7XHJcblx0aWYgKCdvcGFjaXR5JyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0ZWwuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xyXG5cdH0gZWxzZSBpZiAoJ2ZpbHRlcicgaW4gZWwuc3R5bGUpIHtcclxuXHRcdF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKSB7XHJcblx0dmFyIGZpbHRlciA9IGZhbHNlLFxyXG5cdCAgICBmaWx0ZXJOYW1lID0gJ0RYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhJztcclxuXHJcblx0Ly8gZmlsdGVycyBjb2xsZWN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB3ZSB0cnkgdG8gcmV0cmlldmUgYSBmaWx0ZXIgdGhhdCBkb2Vzbid0IGV4aXN0XHJcblx0dHJ5IHtcclxuXHRcdGZpbHRlciA9IGVsLmZpbHRlcnMuaXRlbShmaWx0ZXJOYW1lKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvLyBkb24ndCBzZXQgb3BhY2l0eSB0byAxIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBzZXQgYW4gb3BhY2l0eSxcclxuXHRcdC8vIGl0IGlzbid0IG5lZWRlZCBhbmQgYnJlYWtzIHRyYW5zcGFyZW50IHBuZ3MuXHJcblx0XHRpZiAodmFsdWUgPT09IDEpIHsgcmV0dXJuOyB9XHJcblx0fVxyXG5cclxuXHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDApO1xyXG5cclxuXHRpZiAoZmlsdGVyKSB7XHJcblx0XHRmaWx0ZXIuRW5hYmxlZCA9ICh2YWx1ZSAhPT0gMTAwKTtcclxuXHRcdGZpbHRlci5PcGFjaXR5ID0gdmFsdWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsLnN0eWxlLmZpbHRlciArPSAnIHByb2dpZDonICsgZmlsdGVyTmFtZSArICcob3BhY2l0eT0nICsgdmFsdWUgKyAnKSc7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGVzdFByb3AocHJvcHM6IFN0cmluZ1tdKTogU3RyaW5nfGZhbHNlXHJcbi8vIEdvZXMgdGhyb3VnaCB0aGUgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IG5hbWVcclxuLy8gdGhhdCBpcyBhIHZhbGlkIHN0eWxlIG5hbWUgZm9yIGFuIGVsZW1lbnQuIElmIG5vIHN1Y2ggbmFtZSBpcyBmb3VuZCxcclxuLy8gaXQgcmV0dXJucyBmYWxzZS4gVXNlZnVsIGZvciB2ZW5kb3ItcHJlZml4ZWQgc3R5bGVzIGxpa2UgYHRyYW5zZm9ybWAuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wcykge1xyXG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKHByb3BzW2ldIGluIHN0eWxlKSB7XHJcblx0XHRcdHJldHVybiBwcm9wc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsOiBIVE1MRWxlbWVudCwgb2Zmc2V0OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpXHJcbi8vIFJlc2V0cyB0aGUgM0QgQ1NTIHRyYW5zZm9ybSBvZiBgZWxgIHNvIGl0IGlzIHRyYW5zbGF0ZWQgYnkgYG9mZnNldGAgcGl4ZWxzXHJcbi8vIGFuZCBvcHRpb25hbGx5IHNjYWxlZCBieSBgc2NhbGVgLiBEb2VzIG5vdCBoYXZlIGFuIGVmZmVjdCBpZiB0aGVcclxuLy8gYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgM0QgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWwsIG9mZnNldCwgc2NhbGUpIHtcclxuXHR2YXIgcG9zID0gb2Zmc2V0IHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHJcblx0ZWwuc3R5bGVbVFJBTlNGT1JNXSA9XHJcblx0XHQoQnJvd3Nlci5pZTNkID9cclxuXHRcdFx0J3RyYW5zbGF0ZSgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4KScgOlxyXG5cdFx0XHQndHJhbnNsYXRlM2QoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCwwKScpICtcclxuXHRcdChzY2FsZSA/ICcgc2NhbGUoJyArIHNjYWxlICsgJyknIDogJycpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50LCBwb3NpdGlvbjogUG9pbnQpXHJcbi8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGBlbGAgdG8gY29vcmRpbmF0ZXMgc3BlY2lmaWVkIGJ5IGBwb3NpdGlvbmAsXHJcbi8vIHVzaW5nIENTUyB0cmFuc2xhdGUgb3IgdG9wL2xlZnQgcG9zaXRpb25pbmcgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyXHJcbi8vICh1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBwb3NpdGlvbiBpdHMgbGF5ZXJzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsLCBwb2ludCkge1xyXG5cclxuXHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0ZWwuX2xlYWZsZXRfcG9zID0gcG9pbnQ7XHJcblx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG5cclxuXHRpZiAoQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0c2V0VHJhbnNmb3JtKGVsLCBwb2ludCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuXHRcdGVsLnN0eWxlLnRvcCA9IHBvaW50LnkgKyAncHgnO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIGFuIGVsZW1lbnQgcHJldmlvdXNseSBwb3NpdGlvbmVkIHdpdGggc2V0UG9zaXRpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbCkge1xyXG5cdC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBmb3IgZWxlbWVudHMgcHJldmlvdXNseSBwb3NpdGlvbmVkIHVzaW5nIHNldFBvc2l0aW9uLFxyXG5cdC8vIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSB0aGUgcG9zaXRpb24gZm9yIHBlcmZvcm1hbmNlXHJcblxyXG5cdHJldHVybiBlbC5fbGVhZmxldF9wb3MgfHwgbmV3IFBvaW50KDAsIDApO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBQcmV2ZW50cyB0aGUgdXNlciBmcm9tIGdlbmVyYXRpbmcgYHNlbGVjdHN0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZFxyXG4vLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB0aHJvdWdoIGEgcGFnZSB3aXRoIHRleHQuIFVzZWQgaW50ZXJuYWxseVxyXG4vLyBieSBMZWFmbGV0IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvdXIgb2YgYW55IGNsaWNrLWFuZC1kcmFnIGludGVyYWN0aW9uIG9uXHJcbi8vIHRoZSBtYXAuIEFmZmVjdHMgZHJhZyBpbnRlcmFjdGlvbnMgb24gdGhlIHdob2xlIGRvY3VtZW50LlxyXG5cclxuLy8gQGZ1bmN0aW9uIGVuYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbmV4cG9ydCB2YXIgZGlzYWJsZVRleHRTZWxlY3Rpb247XHJcbmV4cG9ydCB2YXIgZW5hYmxlVGV4dFNlbGVjdGlvbjtcclxudmFyIF91c2VyU2VsZWN0O1xyXG5pZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB7XHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21FdmVudC5vbih3aW5kb3csICdzZWxlY3RzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG5cdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21FdmVudC5vZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxufSBlbHNlIHtcclxuXHR2YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gdGVzdFByb3AoXHJcblx0XHRbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcclxuXHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldO1xyXG5cdFx0XHRzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSBfdXNlclNlbGVjdDtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKVxyXG4vLyBBcyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKSwgYnV0XHJcbi8vIGZvciBgZHJhZ3N0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGFuIGltYWdlLlxyXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpIHtcclxuXHREb21FdmVudC5vbih3aW5kb3csICdkcmFnc3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZ2BdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpIHtcclxuXHREb21FdmVudC5vZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG59XHJcblxyXG52YXIgX291dGxpbmVFbGVtZW50LCBfb3V0bGluZVN0eWxlO1xyXG4vLyBAZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyB0aGUgW291dGxpbmVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9vdXRsaW5lKVxyXG4vLyBvZiB0aGUgZWxlbWVudCBgZWxgIGludmlzaWJsZS4gVXNlZCBpbnRlcm5hbGx5IGJ5IExlYWZsZXQgdG8gcHJldmVudFxyXG4vLyBmb2N1c2FibGUgZWxlbWVudHMgZnJvbSBkaXNwbGF5aW5nIGFuIG91dGxpbmUgd2hlbiB0aGUgdXNlciBwZXJmb3JtcyBhXHJcbi8vIGRyYWcgaW50ZXJhY3Rpb24gb24gdGhlbS5cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsZW1lbnQpIHtcclxuXHR3aGlsZSAoZWxlbWVudC50YWJJbmRleCA9PT0gLTEpIHtcclxuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblx0fVxyXG5cdGlmICghZWxlbWVudC5zdHlsZSkgeyByZXR1cm47IH1cclxuXHRyZXN0b3JlT3V0bGluZSgpO1xyXG5cdF9vdXRsaW5lRWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0X291dGxpbmVTdHlsZSA9IGVsZW1lbnQuc3R5bGUub3V0bGluZTtcclxuXHRlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XHJcblx0RG9tRXZlbnQub24od2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKCkge1xyXG5cdGlmICghX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG5cdF9vdXRsaW5lRWxlbWVudC5zdHlsZS5vdXRsaW5lID0gX291dGxpbmVTdHlsZTtcclxuXHRfb3V0bGluZUVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcblx0X291dGxpbmVTdHlsZSA9IHVuZGVmaW5lZDtcclxuXHREb21FdmVudC5vZmYod2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbDogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBGaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB3aGljaCBzaXplICh3aWR0aCBhbmQgaGVpZ2h0KSBpcyBub3QgbnVsbC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbGVtZW50KSB7XHJcblx0ZG8ge1xyXG5cdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHR9IHdoaWxlICgoIWVsZW1lbnQub2Zmc2V0V2lkdGggfHwgIWVsZW1lbnQub2Zmc2V0SGVpZ2h0KSAmJiBlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KTtcclxuXHRyZXR1cm4gZWxlbWVudDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFNjYWxlKGVsOiBIVE1MRWxlbWVudCk6IE9iamVjdFxyXG4vLyBDb21wdXRlcyB0aGUgQ1NTIHNjYWxlIGN1cnJlbnRseSBhcHBsaWVkIG9uIHRoZSBlbGVtZW50LlxyXG4vLyBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGB4YCBhbmQgYHlgIG1lbWJlcnMgYXMgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc2NhbGVzIHJlc3BlY3RpdmVseSxcclxuLy8gYW5kIGBib3VuZGluZ0NsaWVudFJlY3RgIGFzIHRoZSByZXN1bHQgb2YgW2BnZXRCb3VuZGluZ0NsaWVudFJlY3QoKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEJvdW5kaW5nQ2xpZW50UmVjdCkuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XHJcblx0dmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBSZWFkLW9ubHkgaW4gb2xkIGJyb3dzZXJzLlxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogcmVjdC53aWR0aCAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSxcclxuXHRcdHk6IHJlY3QuaGVpZ2h0IC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSxcclxuXHRcdGJvdW5kaW5nQ2xpZW50UmVjdDogcmVjdFxyXG5cdH07XHJcbn1cclxuIiwiaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHthZGRQb2ludGVyTGlzdGVuZXIsIHJlbW92ZVBvaW50ZXJMaXN0ZW5lcn0gZnJvbSAnLi9Eb21FdmVudC5Qb2ludGVyJztcclxuaW1wb3J0IHthZGREb3VibGVUYXBMaXN0ZW5lciwgcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXJ9IGZyb20gJy4vRG9tRXZlbnQuRG91YmxlVGFwJztcclxuaW1wb3J0IHtnZXRTY2FsZX0gZnJvbSAnLi9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tRXZlbnRcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50KSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqL1xyXG5cclxuLy8gSW5zcGlyZWQgYnkgSm9obiBSZXNpZywgRGVhbiBFZHdhcmRzIGFuZCBZVUkgYWRkRXZlbnQgaW1wbGVtZW50YXRpb25zLlxyXG5cclxuLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBET00gZXZlbnQgdHlwZSBvZiB0aGVcclxuLy8gZWxlbWVudCBgZWxgLiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXJcclxuLy8gKG9iamVjdCB0aGUgYHRoaXNgIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWxcclxuLy8gc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5leHBvcnQgZnVuY3Rpb24gb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRhZGRPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbnZhciBldmVudHNLZXkgPSAnX2xlYWZsZXRfZXZlbnRzJztcclxuXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLlxyXG4vLyBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIG9uLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lXHJcbi8vIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5leHBvcnQgZnVuY3Rpb24gb2ZmKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICh0eXBlcykge1xyXG5cdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHRmb3IgKHZhciBqIGluIG9ialtldmVudHNLZXldKSB7XHJcblx0XHRcdHJlbW92ZU9uZShvYmosIGosIG9ialtldmVudHNLZXldW2pdKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSBvYmpbZXZlbnRzS2V5XTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRPbmUob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdHZhciBpZCA9IHR5cGUgKyBVdGlsLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgVXRpbC5zdGFtcChjb250ZXh0KSA6ICcnKTtcclxuXHJcblx0aWYgKG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gZm4uY2FsbChjb250ZXh0IHx8IG9iaiwgZSB8fCB3aW5kb3cuZXZlbnQpO1xyXG5cdH07XHJcblxyXG5cdHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuXHRpZiAoQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG5cdFx0Ly8gTmVlZHMgRG9tRXZlbnQuUG9pbnRlci5qc1xyXG5cdFx0YWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpO1xyXG5cclxuXHR9IGVsc2UgaWYgKEJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpICYmIGFkZERvdWJsZVRhcExpc3RlbmVyICYmXHJcblx0ICAgICAgICAgICAhKEJyb3dzZXIucG9pbnRlciAmJiBCcm93c2VyLmNocm9tZSkpIHtcclxuXHRcdC8vIENocm9tZSA+NTUgZG9lcyBub3QgbmVlZCB0aGUgc3ludGhldGljIGRibGNsaWNrcyBmcm9tIGFkZERvdWJsZVRhcExpc3RlbmVyXHJcblx0XHQvLyBTZWUgIzUxODBcclxuXHRcdGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlciwgaWQpO1xyXG5cclxuXHR9IGVsc2UgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKCdvbndoZWVsJyBpbiBvYmogPyAnd2hlZWwnIDogJ21vdXNld2hlZWwnLCBoYW5kbGVyLCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoKHR5cGUgPT09ICdtb3VzZWVudGVyJykgfHwgKHR5cGUgPT09ICdtb3VzZWxlYXZlJykpIHtcclxuXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0XHRcdGlmIChpc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcclxuXHRcdFx0XHRcdG9yaWdpbmFsSGFuZGxlcihlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDogJ21vdXNlb3V0JywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICh0eXBlID09PSAnY2xpY2snICYmIEJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0ZmlsdGVyQ2xpY2soZSwgb3JpZ2luYWxIYW5kbGVyKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIGlmICgnYXR0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHR9XHJcblxyXG5cdG9ialtldmVudHNLZXldID0gb2JqW2V2ZW50c0tleV0gfHwge307XHJcblx0b2JqW2V2ZW50c0tleV1baWRdID0gaGFuZGxlcjtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0dmFyIGlkID0gdHlwZSArIFV0aWwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBVdGlsLnN0YW1wKGNvbnRleHQpIDogJycpLFxyXG5cdCAgICBoYW5kbGVyID0gb2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdO1xyXG5cclxuXHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0aWYgKEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lciAmJlxyXG5cdCAgICAgICAgICAgIShCcm93c2VyLnBvaW50ZXIgJiYgQnJvd3Nlci5jaHJvbWUpKSB7XHJcblx0XHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuXHRcdFx0XHR0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6XHJcblx0XHRcdFx0dHlwZSA9PT0gJ21vdXNlbGVhdmUnID8gJ21vdXNlb3V0JyA6IHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIGlmICgnZGV0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0b2JqLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHR9XHJcblxyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IG51bGw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBTdG9wIHRoZSBnaXZlbiBldmVudCBmcm9tIHByb3BhZ2F0aW9uIHRvIHBhcmVudCBlbGVtZW50cy4gVXNlZCBpbnNpZGUgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uczpcclxuLy8gYGBganNcclxuLy8gTC5Eb21FdmVudC5vbihkaXYsICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG4vLyBcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGV2KTtcclxuLy8gfSk7XHJcbi8vIGBgYFxyXG5leHBvcnQgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGUpIHtcclxuXHJcblx0aWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XHJcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50KSB7ICAvLyBJbiBjYXNlIG9mIExlYWZsZXQgZXZlbnQuXHJcblx0XHRlLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgPSB0cnVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcblx0fVxyXG5cdHNraXBwZWQoZSk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnbW91c2V3aGVlbCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbCkge1xyXG5cdGFkZE9uZShlbCwgJ21vdXNld2hlZWwnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdjbGljaydgLCBgJ2RvdWJsZWNsaWNrJ2AsXHJcbi8vIGAnbW91c2Vkb3duJ2AgYW5kIGAndG91Y2hzdGFydCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsKSB7XHJcblx0b24oZWwsICdtb3VzZWRvd24gdG91Y2hzdGFydCBkYmxjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XHJcblx0YWRkT25lKGVsLCAnY2xpY2snLCBmYWtlU3RvcCk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgRE9NIEV2ZW50IGBldmAgZnJvbSBoYXBwZW5pbmcgKHN1Y2ggYXNcclxuLy8gZm9sbG93aW5nIGEgbGluayBpbiB0aGUgaHJlZiBvZiB0aGUgYSBlbGVtZW50LCBvciBkb2luZyBhIFBPU1QgcmVxdWVzdFxyXG4vLyB3aXRoIHBhZ2UgcmVsb2FkIHdoZW4gYSBgPGZvcm0+YCBpcyBzdWJtaXR0ZWQpLlxyXG4vLyBVc2UgaXQgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcclxuXHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcChldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIERvZXMgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgYXQgdGhlIHNhbWUgdGltZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3AoZSkge1xyXG5cdHByZXZlbnREZWZhdWx0KGUpO1xyXG5cdHN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZXY6IERPTUV2ZW50LCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIEdldHMgbm9ybWFsaXplZCBtb3VzZSBwb3NpdGlvbiBmcm9tIGEgRE9NIGV2ZW50IHJlbGF0aXZlIHRvIHRoZVxyXG4vLyBgY29udGFpbmVyYCAoYm9yZGVyIGV4Y2x1ZGVkKSBvciB0byB0aGUgd2hvbGUgcGFnZSBpZiBub3Qgc3BlY2lmaWVkLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihlLCBjb250YWluZXIpIHtcclxuXHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcblx0fVxyXG5cclxuXHR2YXIgc2NhbGUgPSBnZXRTY2FsZShjb250YWluZXIpLFxyXG5cdCAgICBvZmZzZXQgPSBzY2FsZS5ib3VuZGluZ0NsaWVudFJlY3Q7IC8vIGxlZnQgYW5kIHRvcCAgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIHRoZSBldmVudCBjbGllbnRYL1kpXHJcblxyXG5cdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHQvLyBvZmZzZXQubGVmdC90b3AgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIGNsaWVudFgvWSksXHJcblx0XHQvLyB3aGVyZWFzIGNsaWVudExlZnQvVG9wIChib3JkZXIgd2lkdGgpIHZhbHVlcyBhcmUgdGhlIG9yaWdpbmFsIHZhbHVlcyAoYmVmb3JlIENTUyBzY2FsZSBhcHBsaWVzKS5cclxuXHRcdChlLmNsaWVudFggLSBvZmZzZXQubGVmdCkgLyBzY2FsZS54IC0gY29udGFpbmVyLmNsaWVudExlZnQsXHJcblx0XHQoZS5jbGllbnRZIC0gb2Zmc2V0LnRvcCkgLyBzY2FsZS55IC0gY29udGFpbmVyLmNsaWVudFRvcFxyXG5cdCk7XHJcbn1cclxuXHJcbi8vIENocm9tZSBvbiBXaW4gc2Nyb2xscyBkb3VibGUgdGhlIHBpeGVscyBhcyBpbiBvdGhlciBwbGF0Zm9ybXMgKHNlZSAjNDUzOCksXHJcbi8vIGFuZCBGaXJlZm94IHNjcm9sbHMgZGV2aWNlIHBpeGVscywgbm90IENTUyBwaXhlbHNcclxudmFyIHdoZWVsUHhGYWN0b3IgPVxyXG5cdChCcm93c2VyLndpbiAmJiBCcm93c2VyLmNocm9tZSkgPyAyICogd2luZG93LmRldmljZVBpeGVsUmF0aW8gOlxyXG5cdEJyb3dzZXIuZ2Vja28gPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShldjogRE9NRXZlbnQpOiBOdW1iZXJcclxuLy8gR2V0cyBub3JtYWxpemVkIHdoZWVsIGRlbHRhIGZyb20gYSBtb3VzZXdoZWVsIERPTSBldmVudCwgaW4gdmVydGljYWxcclxuLy8gcGl4ZWxzIHNjcm9sbGVkIChuZWdhdGl2ZSBpZiBzY3JvbGxpbmcgZG93bikuXHJcbi8vIEV2ZW50cyBmcm9tIHBvaW50aW5nIGRldmljZXMgd2l0aG91dCBwcmVjaXNlIHNjcm9sbGluZyBhcmUgbWFwcGVkIHRvXHJcbi8vIGEgYmVzdCBndWVzcyBvZiA2MCBwaXhlbHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGUpIHtcclxuXHRyZXR1cm4gKEJyb3dzZXIuZWRnZSkgPyBlLndoZWVsRGVsdGFZIC8gMiA6IC8vIERvbid0IHRydXN0IHdpbmRvdy1nZW9tZXRyeS1iYXNlZCBkZWx0YVxyXG5cdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDApID8gLWUuZGVsdGFZIC8gd2hlZWxQeEZhY3RvciA6IC8vIFBpeGVsc1xyXG5cdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDEpID8gLWUuZGVsdGFZICogMjAgOiAvLyBMaW5lc1xyXG5cdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDIpID8gLWUuZGVsdGFZICogNjAgOiAvLyBQYWdlc1xyXG5cdCAgICAgICAoZS5kZWx0YVggfHwgZS5kZWx0YVopID8gMCA6XHQvLyBTa2lwIGhvcml6b250YWwvZGVwdGggd2hlZWwgZXZlbnRzXHJcblx0ICAgICAgIGUud2hlZWxEZWx0YSA/IChlLndoZWVsRGVsdGFZIHx8IGUud2hlZWxEZWx0YSkgLyAyIDogLy8gTGVnYWN5IElFIHBpeGVsc1xyXG5cdCAgICAgICAoZS5kZXRhaWwgJiYgTWF0aC5hYnMoZS5kZXRhaWwpIDwgMzI3NjUpID8gLWUuZGV0YWlsICogMjAgOiAvLyBMZWdhY3kgTW96IGxpbmVzXHJcblx0ICAgICAgIGUuZGV0YWlsID8gZS5kZXRhaWwgLyAtMzI3NjUgKiA2MCA6IC8vIExlZ2FjeSBNb3ogcGFnZXNcclxuXHQgICAgICAgMDtcclxufVxyXG5cclxudmFyIHNraXBFdmVudHMgPSB7fTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWtlU3RvcChlKSB7XHJcblx0Ly8gZmFrZXMgc3RvcFByb3BhZ2F0aW9uIGJ5IHNldHRpbmcgYSBzcGVjaWFsIGV2ZW50IGZsYWcsIGNoZWNrZWQvcmVzZXQgd2l0aCBza2lwcGVkKGUpXHJcblx0c2tpcEV2ZW50c1tlLnR5cGVdID0gdHJ1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNraXBwZWQoZSkge1xyXG5cdHZhciBldmVudHMgPSBza2lwRXZlbnRzW2UudHlwZV07XHJcblx0Ly8gcmVzZXQgd2hlbiBjaGVja2luZywgYXMgaXQncyBvbmx5IHVzZWQgaW4gbWFwIGNvbnRhaW5lciBhbmQgcHJvcGFnYXRlcyBvdXRzaWRlIG9mIHRoZSBtYXBcclxuXHRza2lwRXZlbnRzW2UudHlwZV0gPSBmYWxzZTtcclxuXHRyZXR1cm4gZXZlbnRzO1xyXG59XHJcblxyXG4vLyBjaGVjayBpZiBlbGVtZW50IHJlYWxseSBsZWZ0L2VudGVyZWQgdGhlIGV2ZW50IHRhcmdldCAoZm9yIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSlcclxuZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZXJuYWxUYXJnZXQoZWwsIGUpIHtcclxuXHJcblx0dmFyIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XHJcblxyXG5cdGlmICghcmVsYXRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHR0cnkge1xyXG5cdFx0d2hpbGUgKHJlbGF0ZWQgJiYgKHJlbGF0ZWQgIT09IGVsKSkge1xyXG5cdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gKHJlbGF0ZWQgIT09IGVsKTtcclxufVxyXG5cclxudmFyIGxhc3RDbGljaztcclxuXHJcbi8vIHRoaXMgaXMgYSBob3JyaWJsZSB3b3JrYXJvdW5kIGZvciBhIGJ1ZyBpbiBBbmRyb2lkIHdoZXJlIGEgc2luZ2xlIHRvdWNoIHRyaWdnZXJzIHR3byBjbGljayBldmVudHNcclxuZnVuY3Rpb24gZmlsdGVyQ2xpY2soZSwgaGFuZGxlcikge1xyXG5cdHZhciB0aW1lU3RhbXAgPSAoZS50aW1lU3RhbXAgfHwgKGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQudGltZVN0YW1wKSksXHJcblx0ICAgIGVsYXBzZWQgPSBsYXN0Q2xpY2sgJiYgKHRpbWVTdGFtcCAtIGxhc3RDbGljayk7XHJcblxyXG5cdC8vIGFyZSB0aGV5IGNsb3NlciB0b2dldGhlciB0aGFuIDUwMG1zIHlldCBtb3JlIHRoYW4gMTAwbXM/XHJcblx0Ly8gQW5kcm9pZCB0eXBpY2FsbHkgdHJpZ2dlcnMgdGhlbSB+MzAwbXMgYXBhcnQgd2hpbGUgbXVsdGlwbGUgbGlzdGVuZXJzXHJcblx0Ly8gb24gdGhlIHNhbWUgZXZlbnQgc2hvdWxkIGJlIHRyaWdnZXJlZCBmYXIgZmFzdGVyO1xyXG5cdC8vIG9yIGNoZWNrIGlmIGNsaWNrIGlzIHNpbXVsYXRlZCBvbiB0aGUgZWxlbWVudCwgYW5kIGlmIGl0IGlzLCByZWplY3QgYW55IG5vbi1zaW11bGF0ZWQgZXZlbnRzXHJcblxyXG5cdGlmICgoZWxhcHNlZCAmJiBlbGFwc2VkID4gMTAwICYmIGVsYXBzZWQgPCA1MDApIHx8IChlLnRhcmdldC5fc2ltdWxhdGVkQ2xpY2sgJiYgIWUuX3NpbXVsYXRlZCkpIHtcclxuXHRcdHN0b3AoZSk7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cdGxhc3RDbGljayA9IHRpbWVTdGFtcDtcclxuXHJcblx0aGFuZGxlcihlKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BMLkRvbUV2ZW50Lm9uYF0oI2RvbWV2ZW50LW9uKVxyXG5leHBvcnQge29uIGFzIGFkZExpc3RlbmVyfTtcclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vZmZgXSgjZG9tZXZlbnQtb2ZmKVxyXG5leHBvcnQge29mZiBhcyByZW1vdmVMaXN0ZW5lcn07XHJcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cblxuLypcbiAqIEBjbGFzcyBQb3NBbmltYXRpb25cbiAqIEBha2EgTC5Qb3NBbmltYXRpb25cbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIHBhbm5pbmcgYW5pbWF0aW9ucywgdXRpbGl6aW5nIENTUzMgVHJhbnNpdGlvbnMgZm9yIG1vZGVybiBicm93c2VycyBhbmQgYSB0aW1lciBmYWxsYmFjayBmb3IgSUU2LTkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgZnggPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcbiAqIGZ4LnJ1bihlbCwgWzMwMCwgNTAwXSwgMC41KTtcbiAqIGBgYFxuICpcbiAqIEBjb25zdHJ1Y3RvciBMLlBvc0FuaW1hdGlvbigpXG4gKiBDcmVhdGVzIGEgYFBvc0FuaW1hdGlvbmAgb2JqZWN0LlxuICpcbiAqL1xuXG5leHBvcnQgdmFyIFBvc0FuaW1hdGlvbiA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBAbWV0aG9kIHJ1bihlbDogSFRNTEVsZW1lbnQsIG5ld1BvczogUG9pbnQsIGR1cmF0aW9uPzogTnVtYmVyLCBlYXNlTGluZWFyaXR5PzogTnVtYmVyKVxuXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG5cdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuXHQvLyBhcmd1bWVudCBvZiB0aGUgW2N1YmljIGJlemllciBjdXJ2ZV0oaHR0cDovL2N1YmljLWJlemllci5jb20vIzAsMCwuNSwxKSxcblx0Ly8gYDAuNWAgYnkgZGVmYXVsdCkuXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG5cdFx0dGhpcy5zdG9wKCk7XG5cblx0XHR0aGlzLl9lbCA9IGVsO1xuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcblx0XHR0aGlzLl9lYXNlT3V0UG93ZXIgPSAxIC8gTWF0aC5tYXgoZWFzZUxpbmVhcml0eSB8fCAwLjUsIDAuMik7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24oZWwpO1xuXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cblx0XHQvLyBAZXZlbnQgc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuXHRcdHRoaXMuX2FuaW1hdGUoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHN0b3AoKVxuXHQvLyBTdG9wcyB0aGUgYW5pbWF0aW9uIChpZiBjdXJyZW50bHkgcnVubmluZykuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9zdGVwKHRydWUpO1xuXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhbmltYXRpb24gbG9vcFxuXHRcdHRoaXMuX2FuaW1JZCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcblx0XHR0aGlzLl9zdGVwKCk7XG5cdH0sXG5cblx0X3N0ZXA6IGZ1bmN0aW9uIChyb3VuZCkge1xuXHRcdHZhciBlbGFwc2VkID0gKCtuZXcgRGF0ZSgpKSAtIHRoaXMuX3N0YXJ0VGltZSxcblx0XHQgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbiAqIDEwMDA7XG5cblx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSh0aGlzLl9lYXNlT3V0KGVsYXBzZWQgLyBkdXJhdGlvbiksIHJvdW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG5cdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfcnVuRnJhbWU6IGZ1bmN0aW9uIChwcm9ncmVzcywgcm91bmQpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKHRoaXMuX29mZnNldC5tdWx0aXBseUJ5KHByb2dyZXNzKSk7XG5cdFx0aWYgKHJvdW5kKSB7XG5cdFx0XHRwb3MuX3JvdW5kKCk7XG5cdFx0fVxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XG5cblx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIHRoZSBhbmltYXRpb24uXG5cdFx0dGhpcy5maXJlKCdzdGVwJyk7XG5cdH0sXG5cblx0X2NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbUlkKTtcblxuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHRoaXMuZmlyZSgnZW5kJyk7XG5cdH0sXG5cblx0X2Vhc2VPdXQ6IGZ1bmN0aW9uICh0KSB7XG5cdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgdGhpcy5fZWFzZU91dFBvd2VyKTtcblx0fVxufSk7XG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xyXG5pbXBvcnQge0VQU0czODU3fSBmcm9tICcuLi9nZW8vY3JzL0NSUy5FUFNHMzg1Nyc7XHJcbmltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IHtCb3VuZHMsIHRvQm91bmRzfSBmcm9tICcuLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge0xhdExuZywgdG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge0xhdExuZ0JvdW5kcywgdG9MYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQge1Bvc0FuaW1hdGlvbn0gZnJvbSAnLi4vZG9tL1Bvc0FuaW1hdGlvbic7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTWFwXHJcbiAqIEBha2EgTC5NYXBcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogVGhlIGNlbnRyYWwgY2xhc3Mgb2YgdGhlIEFQSSDigJQgaXQgaXMgdXNlZCB0byBjcmVhdGUgYSBtYXAgb24gYSBwYWdlIGFuZCBtYW5pcHVsYXRlIGl0LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiAvLyBpbml0aWFsaXplIHRoZSBtYXAgb24gdGhlIFwibWFwXCIgZGl2IHdpdGggYSBnaXZlbiBjZW50ZXIgYW5kIHpvb21cclxuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XHJcbiAqIFx0Y2VudGVyOiBbNTEuNTA1LCAtMC4wOV0sXHJcbiAqIFx0em9vbTogMTNcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWFwID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvbiBNYXAgU3RhdGUgT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IEwuQ1JTLkVQU0czODU3XHJcblx0XHQvLyBUaGUgW0Nvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbV0oI2NycykgdG8gdXNlLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90XHJcblx0XHQvLyBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IEVQU0czODU3LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2VudGVyOiBMYXRMbmcgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgZ2VvZ3JhcGhpYyBjZW50ZXIgb2YgdGhlIG1hcFxyXG5cdFx0Y2VudGVyOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tOiBOdW1iZXIgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgbWFwIHpvb20gbGV2ZWxcclxuXHRcdHpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9ICpcclxuXHRcdC8vIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcblx0XHQvLyB0aGUgbG93ZXN0IG9mIHRoZWlyIGBtaW5ab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdFx0bWluWm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gKlxyXG5cdFx0Ly8gTWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuXHRcdC8vIHRoZSBoaWdoZXN0IG9mIHRoZWlyIGBtYXhab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBMYXllcltdID0gW11cclxuXHRcdC8vIEFycmF5IG9mIGxheWVycyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCBpbml0aWFsbHlcclxuXHRcdGxheWVyczogW10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHM6IExhdExuZ0JvdW5kcyA9IG51bGxcclxuXHRcdC8vIFdoZW4gdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgbWFwIHJlc3RyaWN0cyB0aGUgdmlldyB0byB0aGUgZ2l2ZW5cclxuXHRcdC8vIGdlb2dyYXBoaWNhbCBib3VuZHMsIGJvdW5jaW5nIHRoZSB1c2VyIGJhY2sgaWYgdGhlIHVzZXIgdHJpZXMgdG8gcGFuXHJcblx0XHQvLyBvdXRzaWRlIHRoZSB2aWV3LiBUbyBzZXQgdGhlIHJlc3RyaWN0aW9uIGR5bmFtaWNhbGx5LCB1c2VcclxuXHRcdC8vIFtgc2V0TWF4Qm91bmRzYF0oI21hcC1zZXRtYXhib3VuZHMpIG1ldGhvZC5cclxuXHRcdG1heEJvdW5kczogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyID0gKlxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgbWV0aG9kIGZvciBkcmF3aW5nIHZlY3RvciBsYXllcnMgb24gdGhlIG1hcC4gYEwuU1ZHYFxyXG5cdFx0Ly8gb3IgYEwuQ2FudmFzYCBieSBkZWZhdWx0IGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnQuXHJcblx0XHRyZW5kZXJlcjogdW5kZWZpbmVkLFxyXG5cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBBbmltYXRpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHR6b29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvblRocmVzaG9sZDogTnVtYmVyID0gNFxyXG5cdFx0Ly8gV29uJ3QgYW5pbWF0ZSB6b29tIGlmIHRoZSB6b29tIGRpZmZlcmVuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbUFuaW1hdGlvblRocmVzaG9sZDogNCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZhZGVBbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB0aWxlIGZhZGUgYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRmYWRlQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWFya2VyWm9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgbWFya2VycyBhbmltYXRlIHRoZWlyIHpvb20gd2l0aCB0aGUgem9vbSBhbmltYXRpb24sIGlmIGRpc2FibGVkXHJcblx0XHQvLyB0aGV5IHdpbGwgZGlzYXBwZWFyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQnc1xyXG5cdFx0Ly8gZW5hYmxlZCBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRtYXJrZXJab29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNmb3JtM0RMaW1pdDogTnVtYmVyID0gMl4yM1xyXG5cdFx0Ly8gRGVmaW5lcyB0aGUgbWF4aW11bSBzaXplIG9mIGEgQ1NTIHRyYW5zbGF0aW9uIHRyYW5zZm9ybS4gVGhlIGRlZmF1bHRcclxuXHRcdC8vIHZhbHVlIHNob3VsZCBub3QgYmUgY2hhbmdlZCB1bmxlc3MgYSB3ZWIgYnJvd3NlciBwb3NpdGlvbnMgbGF5ZXJzIGluXHJcblx0XHQvLyB0aGUgd3JvbmcgcGxhY2UgYWZ0ZXIgZG9pbmcgYSBsYXJnZSBgcGFuQnlgLlxyXG5cdFx0dHJhbnNmb3JtM0RMaW1pdDogODM4ODYwOCwgLy8gUHJlY2lzaW9uIGxpbWl0IG9mIGEgMzItYml0IGZsb2F0XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tU25hcDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gRm9yY2VzIHRoZSBtYXAncyB6b29tIGxldmVsIHRvIGFsd2F5cyBiZSBhIG11bHRpcGxlIG9mIHRoaXMsIHBhcnRpY3VsYXJseVxyXG5cdFx0Ly8gcmlnaHQgYWZ0ZXIgYSBbYGZpdEJvdW5kcygpYF0oI21hcC1maXRib3VuZHMpIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIHRoZSB6b29tIGxldmVsIHNuYXBzIHRvIHRoZSBuZWFyZXN0IGludGVnZXI7IGxvd2VyIHZhbHVlc1xyXG5cdFx0Ly8gKGUuZy4gYDAuNWAgb3IgYDAuMWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LiBBIHZhbHVlIG9mIGAwYFxyXG5cdFx0Ly8gbWVhbnMgdGhlIHpvb20gbGV2ZWwgd2lsbCBub3QgYmUgc25hcHBlZCBhZnRlciBgZml0Qm91bmRzYCBvciBhIHBpbmNoLXpvb20uXHJcblx0XHR6b29tU25hcDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21EZWx0YTogTnVtYmVyID0gMVxyXG5cdFx0Ly8gQ29udHJvbHMgaG93IG11Y2ggdGhlIG1hcCdzIHpvb20gbGV2ZWwgd2lsbCBjaGFuZ2UgYWZ0ZXIgYVxyXG5cdFx0Ly8gW2B6b29tSW4oKWBdKCNtYXAtem9vbWluKSwgW2B6b29tT3V0KClgXSgjbWFwLXpvb21vdXQpLCBwcmVzc2luZyBgK2BcclxuXHRcdC8vIG9yIGAtYCBvbiB0aGUga2V5Ym9hcmQsIG9yIHVzaW5nIHRoZSBbem9vbSBjb250cm9sc10oI2NvbnRyb2wtem9vbSkuXHJcblx0XHQvLyBWYWx1ZXMgc21hbGxlciB0aGFuIGAxYCAoZS5nLiBgMC41YCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuXHJcblx0XHR6b29tRGVsdGE6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFja1Jlc2l6ZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgYnJvd3NlciB3aW5kb3cgcmVzaXplIHRvIHVwZGF0ZSBpdHNlbGYuXHJcblx0XHR0cmFja1Jlc2l6ZTogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykgeyAvLyAoSFRNTEVsZW1lbnQgb3IgU3RyaW5nLCBPYmplY3QpXHJcblx0XHRvcHRpb25zID0gVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIE1ha2Ugc3VyZSB0byBhc3NpZ24gaW50ZXJuYWwgZmxhZ3MgYXQgdGhlIGJlZ2lubmluZyxcclxuXHRcdC8vIHRvIGF2b2lkIGluY29uc2lzdGVudCBzdGF0ZSBpbiBzb21lIGVkZ2UgY2FzZXMuXHJcblx0XHR0aGlzLl9oYW5kbGVycyA9IFtdO1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl96b29tQm91bmRMYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKGlkKTtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHJcblx0XHQvLyBoYWNrIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xOTgwXHJcblx0XHR0aGlzLl9vblJlc2l6ZSA9IFV0aWwuYmluZCh0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cygpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm1heEJvdW5kcykge1xyXG5cdFx0XHR0aGlzLnNldE1heEJvdW5kcyhvcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB0aGlzLl9saW1pdFpvb20ob3B0aW9ucy56b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5jZW50ZXIgJiYgb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KHRvTGF0TG5nKG9wdGlvbnMuY2VudGVyKSwgb3B0aW9ucy56b29tLCB7cmVzZXQ6IHRydWV9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIG9uIGJyb3dzZXJzIHdpdGhvdXQgaGFyZHdhcmUtYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnMgb3Igb2xkIEFuZHJvaWQvT3BlcmFcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IERvbVV0aWwuVFJBTlNJVElPTiAmJiBCcm93c2VyLmFueTNkICYmICFCcm93c2VyLm1vYmlsZU9wZXJhICYmXHJcblx0XHRcdFx0dGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XHJcblxyXG5cdFx0Ly8gem9vbSB0cmFuc2l0aW9ucyBydW4gd2l0aCB0aGUgc2FtZSBkdXJhdGlvbiBmb3IgYWxsIGxheWVycywgc28gaWYgb25lIG9mIHRyYW5zaXRpb25lbmQgZXZlbnRzXHJcblx0XHQvLyBoYXBwZW5zIGFmdGVyIHN0YXJ0aW5nIHpvb20gYW5pbWF0aW9uIChwcm9wYWdhdGluZyB0byB0aGUgbWFwIHBhbmUpLCB3ZSBrbm93IHRoYXQgaXQgZW5kZWQgZ2xvYmFsbHlcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0dGhpcy5fY3JlYXRlQW5pbVByb3h5KCk7XHJcblx0XHRcdERvbUV2ZW50Lm9uKHRoaXMuX3Byb3h5LCBEb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9jYXRjaFRyYW5zaXRpb25FbmQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FkZExheWVycyh0aGlzLm9wdGlvbnMubGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFZpZXcoY2VudGVyOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSB3aXRoIHRoZSBnaXZlblxyXG5cdC8vIGFuaW1hdGlvbiBvcHRpb25zLlxyXG5cdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHRcdGNlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKHRvTGF0TG5nKGNlbnRlciksIHpvb20sIHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgIW9wdGlvbnMucmVzZXQgJiYgb3B0aW9ucyAhPT0gdHJ1ZSkge1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tID0gVXRpbC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMuem9vbSk7XHJcblx0XHRcdFx0b3B0aW9ucy5wYW4gPSBVdGlsLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLCBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbn0sIG9wdGlvbnMucGFuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxyXG5cdFx0XHR2YXIgbW92ZWQgPSAodGhpcy5fem9vbSAhPT0gem9vbSkgP1xyXG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkWm9vbSAmJiB0aGlzLl90cnlBbmltYXRlZFpvb20oY2VudGVyLCB6b29tLCBvcHRpb25zLnpvb20pIDpcclxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMucGFuKTtcclxuXHJcblx0XHRcdGlmIChtb3ZlZCkge1xyXG5cdFx0XHRcdC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XHJcblx0XHR0aGlzLl9yZXNldFZpZXcoY2VudGVyLCB6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb20oem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB6b29tIG9mIHRoZSBtYXAuXHJcblx0c2V0Wm9vbTogZnVuY3Rpb24gKHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21JbihkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBJbmNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tSW46IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSArIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21PdXQoZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gRGVjcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbU91dDogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRkZWx0YSA9IGRlbHRhIHx8IChCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tIC0gZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIGdlb2dyYXBoaWNhbCBwb2ludCBvbiB0aGUgbWFwXHJcblx0Ly8gc3RhdGlvbmFyeSAoZS5nLiB1c2VkIGludGVybmFsbHkgZm9yIHNjcm9sbCB6b29tIGFuZCBkb3VibGUtY2xpY2sgem9vbSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKG9mZnNldDogUG9pbnQsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBwaXhlbCBvbiB0aGUgbWFwIChyZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyKSBzdGF0aW9uYXJ5LlxyXG5cdHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBsYXRsbmcgaW5zdGFuY2VvZiBQb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRCb3VuZHNDZW50ZXJab29tOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRib3VuZHMgPSBib3VuZHMuZ2V0Qm91bmRzID8gYm91bmRzLmdldEJvdW5kcygpIDogdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzLCBmYWxzZSwgcGFkZGluZ1RMLmFkZChwYWRkaW5nQlIpKTtcclxuXHJcblx0XHR6b29tID0gKHR5cGVvZiBvcHRpb25zLm1heFpvb20gPT09ICdudW1iZXInKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuXHRcdGlmICh6b29tID09PSBJbmZpbml0eSkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNlbnRlcjogYm91bmRzLmdldENlbnRlcigpLFxyXG5cdFx0XHRcdHpvb206IHpvb21cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuXHRcdCAgICBzd1BvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSksXHJcblx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb21cclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZ2VvZ3JhcGhpY2FsIGJvdW5kcyB3aXRoIHRoZVxyXG5cdC8vIG1heGltdW0gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBhcmUgbm90IHZhbGlkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdFdvcmxkKG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBtb3N0bHkgY29udGFpbnMgdGhlIHdob2xlIHdvcmxkIHdpdGggdGhlIG1heGltdW1cclxuXHQvLyB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5UbyhsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byBhIGdpdmVuIGNlbnRlci5cclxuXHRwYW5UbzogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkJ5KG9mZnNldDogUG9pbnQsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgYnkgYSBnaXZlbiBudW1iZXIgb2YgcGl4ZWxzIChhbmltYXRlZCkuXHJcblx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQsIG9wdGlvbnMpIHtcclxuXHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gSWYgd2UgcGFuIHRvbyBmYXIsIENocm9tZSBnZXRzIGlzc3VlcyB3aXRoIHRpbGVzXHJcblx0XHQvLyBhbmQgbWFrZXMgdGhlbSBkaXNhcHBlYXIgb3IgYXBwZWFyIGluIHRoZSB3cm9uZyBwbGFjZSAoc2xpZ2h0bHkgb2Zmc2V0KSAjMjYwMlxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkge1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy51bnByb2plY3QodGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBQb3NBbmltYXRpb24oKTtcclxuXHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ub24oe1xyXG5cdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcclxuXHRcdFx0XHQnZW5kJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uRW5kXHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRvbid0IGZpcmUgbW92ZXN0YXJ0IGlmIGFuaW1hdGluZyBpbmVydGlhXHJcblx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSBmYWxzZSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblxyXG5cdFx0XHR2YXIgbmV3UG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5ydW4odGhpcy5fbWFwUGFuZSwgbmV3UG9zLCBvcHRpb25zLmR1cmF0aW9uIHx8IDAuMjUsIG9wdGlvbnMuZWFzZUxpbmVhcml0eSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKS5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUbyhsYXRsbmc6IExhdExuZywgem9vbT86IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSBwZXJmb3JtaW5nIGEgc21vb3RoXHJcblx0Ly8gcGFuLXpvb20gYW5pbWF0aW9uLlxyXG5cdGZseVRvOiBmdW5jdGlvbiAodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCAhQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuXHRcdHZhciBmcm9tID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG5cdFx0ICAgIHRvID0gdGhpcy5wcm9qZWN0KHRhcmdldENlbnRlciksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIHN0YXJ0Wm9vbSA9IHRoaXMuX3pvb207XHJcblxyXG5cdFx0dGFyZ2V0Q2VudGVyID0gdG9MYXRMbmcodGFyZ2V0Q2VudGVyKTtcclxuXHRcdHRhcmdldFpvb20gPSB0YXJnZXRab29tID09PSB1bmRlZmluZWQgPyBzdGFydFpvb20gOiB0YXJnZXRab29tO1xyXG5cclxuXHRcdHZhciB3MCA9IE1hdGgubWF4KHNpemUueCwgc2l6ZS55KSxcclxuXHRcdCAgICB3MSA9IHcwICogdGhpcy5nZXRab29tU2NhbGUoc3RhcnRab29tLCB0YXJnZXRab29tKSxcclxuXHRcdCAgICB1MSA9ICh0by5kaXN0YW5jZVRvKGZyb20pKSB8fCAxLFxyXG5cdFx0ICAgIHJobyA9IDEuNDIsXHJcblx0XHQgICAgcmhvMiA9IHJobyAqIHJobztcclxuXHJcblx0XHRmdW5jdGlvbiByKGkpIHtcclxuXHRcdFx0dmFyIHMxID0gaSA/IC0xIDogMSxcclxuXHRcdFx0ICAgIHMyID0gaSA/IHcxIDogdzAsXHJcblx0XHRcdCAgICB0MSA9IHcxICogdzEgLSB3MCAqIHcwICsgczEgKiByaG8yICogcmhvMiAqIHUxICogdTEsXHJcblx0XHRcdCAgICBiMSA9IDIgKiBzMiAqIHJobzIgKiB1MSxcclxuXHRcdFx0ICAgIGIgPSB0MSAvIGIxLFxyXG5cdFx0XHQgICAgc3EgPSBNYXRoLnNxcnQoYiAqIGIgKyAxKSAtIGI7XHJcblxyXG5cdFx0XHQgICAgLy8gd29ya2Fyb3VuZCBmb3IgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIGJ1ZyB3aGVuIHNxID0gMCwgbG9nID0gLUluZmluaXRlLFxyXG5cdFx0XHQgICAgLy8gdGh1cyB0cmlnZ2VyaW5nIGFuIGluZmluaXRlIGxvb3AgaW4gZmx5VG9cclxuXHRcdFx0ICAgIHZhciBsb2cgPSBzcSA8IDAuMDAwMDAwMDAxID8gLTE4IDogTWF0aC5sb2coc3EpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGxvZztcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcblx0XHRmdW5jdGlvbiBjb3NoKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSArIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcblx0XHRmdW5jdGlvbiB0YW5oKG4pIHsgcmV0dXJuIHNpbmgobikgLyBjb3NoKG4pOyB9XHJcblxyXG5cdFx0dmFyIHIwID0gcigwKTtcclxuXHJcblx0XHRmdW5jdGlvbiB3KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfVxyXG5cdFx0ZnVuY3Rpb24gdShzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzI7IH1cclxuXHJcblx0XHRmdW5jdGlvbiBlYXNlT3V0KHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgMS41KTsgfVxyXG5cclxuXHRcdHZhciBzdGFydCA9IERhdGUubm93KCksXHJcblx0XHQgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvLFxyXG5cdFx0ICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiA/IDEwMDAgKiBvcHRpb25zLmR1cmF0aW9uIDogMTAwMCAqIFMgKiAwLjg7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZnJhbWUoKSB7XHJcblx0XHRcdHZhciB0ID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbixcclxuXHRcdFx0ICAgIHMgPSBlYXNlT3V0KHQpICogUztcclxuXHJcblx0XHRcdGlmICh0IDw9IDEpIHtcclxuXHRcdFx0XHR0aGlzLl9mbHlUb0ZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZyYW1lLCB0aGlzKTtcclxuXHJcblx0XHRcdFx0dGhpcy5fbW92ZShcclxuXHRcdFx0XHRcdHRoaXMudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1YnRyYWN0KGZyb20pLm11bHRpcGx5QnkodShzKSAvIHUxKSksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR0aGlzLmdldFNjYWxlWm9vbSh3MCAvIHcocyksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR7Zmx5VG86IHRydWV9KTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpc1xyXG5cdFx0XHRcdFx0Ll9tb3ZlKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSlcclxuXHRcdFx0XHRcdC5fbW92ZUVuZCh0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0KTtcclxuXHJcblx0XHRmcmFtZS5jYWxsKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUb0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCB3aXRoIGEgc21vb3RoIGFuaW1hdGlvbiBsaWtlIFtgZmx5VG9gXSgjbWFwLWZseXRvKSxcclxuXHQvLyBidXQgdGFrZXMgYSBib3VuZHMgcGFyYW1ldGVyIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcblx0Zmx5VG9Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5mbHlUbyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhCb3VuZHMoYm91bmRzOiBCb3VuZHMpOiB0aGlzXHJcblx0Ly8gUmVzdHJpY3RzIHRoZSBtYXAgdmlldyB0byB0aGUgZ2l2ZW4gYm91bmRzIChzZWUgdGhlIFttYXhCb3VuZHNdKCNtYXAtbWF4Ym91bmRzKSBvcHRpb24pLlxyXG5cdHNldE1heEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IG51bGw7XHJcblx0XHRcdHJldHVybiB0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBib3VuZHM7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNaW5ab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBsb3dlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWluWm9vbV0oI21hcC1taW56b29tKSBvcHRpb24pLlxyXG5cdHNldE1pblpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdFx0dGhpcy5vcHRpb25zLm1pblpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmdldFpvb20oKSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Wm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdXBwZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21heFpvb21dKCNtYXAtbWF4em9vbSkgb3B0aW9uKS5cclxuXHRzZXRNYXhab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuXHRcdHRoaXMub3B0aW9ucy5tYXhab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkluc2lkZUJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byB0aGUgY2xvc2VzdCB2aWV3IHRoYXQgd291bGQgbGllIGluc2lkZSB0aGUgZ2l2ZW4gYm91bmRzIChpZiBpdCdzIG5vdCBhbHJlYWR5KSwgY29udHJvbGxpbmcgdGhlIGFuaW1hdGlvbiB1c2luZyB0aGUgb3B0aW9ucyBzcGVjaWZpYywgaWYgYW55LlxyXG5cdHBhbkluc2lkZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKGNlbnRlciwgdGhpcy5fem9vbSwgdG9MYXRMbmdCb3VuZHMoYm91bmRzKSk7XHJcblxyXG5cdFx0aWYgKCFjZW50ZXIuZXF1YWxzKG5ld0NlbnRlcikpIHtcclxuXHRcdFx0dGhpcy5wYW5UbyhuZXdDZW50ZXIsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0aGUgbWluaW11bSBhbW91bnQgdG8gbWFrZSB0aGUgYGxhdGxuZ2AgdmlzaWJsZS4gVXNlXHJcblx0Ly8gYHBhZGRpbmdgLCBgcGFkZGluZ1RvcExlZnRgIGFuZCBgcGFkZGluZ1RvcFJpZ2h0YCBvcHRpb25zIHRvIGZpdFxyXG5cdC8vIHRoZSBkaXNwbGF5IHRvIG1vcmUgcmVzdHJpY3RlZCBib3VuZHMsIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcblx0Ly8gSWYgYGxhdGxuZ2AgaXMgYWxyZWFkeSB3aXRoaW4gdGhlIChvcHRpb25hbGx5IHBhZGRlZCkgZGlzcGxheSBib3VuZHMsXHJcblx0Ly8gdGhlIG1hcCB3aWxsIG5vdCBiZSBwYW5uZWQuXHJcblx0cGFuSW5zaWRlOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBwaXhlbENlbnRlciA9IHRoaXMucHJvamVjdChjZW50ZXIpLFxyXG5cdFx0ICAgIHBpeGVsUG9pbnQgPSB0aGlzLnByb2plY3QobGF0bG5nKSxcclxuXHRcdCAgICBwaXhlbEJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBoYWxmUGl4ZWxCb3VuZHMgPSBwaXhlbEJvdW5kcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgcGFkZGVkQm91bmRzID0gdG9Cb3VuZHMoW3BpeGVsQm91bmRzLm1pbi5hZGQocGFkZGluZ1RMKSwgcGl4ZWxCb3VuZHMubWF4LnN1YnRyYWN0KHBhZGRpbmdCUildKTtcclxuXHJcblx0XHRpZiAoIXBhZGRlZEJvdW5kcy5jb250YWlucyhwaXhlbFBvaW50KSkge1xyXG5cdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG5cdFx0XHR2YXIgZGlmZiA9IHBpeGVsQ2VudGVyLnN1YnRyYWN0KHBpeGVsUG9pbnQpLFxyXG5cdFx0XHQgICAgbmV3Q2VudGVyID0gdG9Qb2ludChwaXhlbFBvaW50LnggKyBkaWZmLngsIHBpeGVsUG9pbnQueSArIGRpZmYueSk7XHJcblxyXG5cdFx0XHRpZiAocGl4ZWxQb2ludC54IDwgcGFkZGVkQm91bmRzLm1pbi54IHx8IHBpeGVsUG9pbnQueCA+IHBhZGRlZEJvdW5kcy5tYXgueCkge1xyXG5cdFx0XHRcdG5ld0NlbnRlci54ID0gcGl4ZWxDZW50ZXIueCAtIGRpZmYueDtcclxuXHRcdFx0XHRpZiAoZGlmZi54ID4gMCkge1xyXG5cdFx0XHRcdFx0bmV3Q2VudGVyLnggKz0gaGFsZlBpeGVsQm91bmRzLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bmV3Q2VudGVyLnggLT0gaGFsZlBpeGVsQm91bmRzLnggLSBwYWRkaW5nQlIueDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHBpeGVsUG9pbnQueSA8IHBhZGRlZEJvdW5kcy5taW4ueSB8fCBwaXhlbFBvaW50LnkgPiBwYWRkZWRCb3VuZHMubWF4LnkpIHtcclxuXHRcdFx0XHRuZXdDZW50ZXIueSA9IHBpeGVsQ2VudGVyLnkgLSBkaWZmLnk7XHJcblx0XHRcdFx0aWYgKGRpZmYueSA+IDApIHtcclxuXHRcdFx0XHRcdG5ld0NlbnRlci55ICs9IGhhbGZQaXhlbEJvdW5kcy55IC0gcGFkZGluZ1RMLnk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG5ld0NlbnRlci55IC09IGhhbGZQaXhlbEJvdW5kcy55IC0gcGFkZGluZ0JSLnk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMucGFuVG8odGhpcy51bnByb2plY3QobmV3Q2VudGVyKSwgb3B0aW9ucyk7XHJcblx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShvcHRpb25zOiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuXHQvLyBwYW4gYnkgZGVmYXVsdC4gSWYgYG9wdGlvbnMucGFuYCBpcyBgZmFsc2VgLCBwYW5uaW5nIHdpbGwgbm90IG9jY3VyLlxyXG5cdC8vIElmIGBvcHRpb25zLmRlYm91bmNlTW92ZWVuZGAgaXMgYHRydWVgLCBpdCB3aWxsIGRlbGF5IGBtb3ZlZW5kYCBldmVudCBzb1xyXG5cdC8vIHRoYXQgaXQgZG9lc24ndCBoYXBwZW4gb2Z0ZW4gZXZlbiBpZiB0aGUgbWV0aG9kIGlzIGNhbGxlZCBtYW55XHJcblx0Ly8gdGltZXMgaW4gYSByb3cuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUoYW5pbWF0ZTogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuXHJcblx0aW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7XHJcblx0XHRcdGFuaW1hdGU6IGZhbHNlLFxyXG5cdFx0XHRwYW46IHRydWVcclxuXHRcdH0sIG9wdGlvbnMgPT09IHRydWUgPyB7YW5pbWF0ZTogdHJ1ZX0gOiBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgb2xkU2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5fbGFzdENlbnRlciA9IG51bGw7XHJcblxyXG5cdFx0dmFyIG5ld1NpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBvbGRDZW50ZXIgPSBvbGRTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gbmV3U2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG9sZENlbnRlci5zdWJ0cmFjdChuZXdDZW50ZXIpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAmJiBvcHRpb25zLnBhbikge1xyXG5cdFx0XHR0aGlzLnBhbkJ5KG9mZnNldCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5kZWJvdW5jZU1vdmVlbmQpIHtcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHR0aGlzLl9zaXplVGltZXIgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdtb3ZlZW5kJyksIDIwMCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHJlc2l6ZTogUmVzaXplRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyByZXNpemVkLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgncmVzaXplJywge1xyXG5cdFx0XHRvbGRTaXplOiBvbGRTaXplLFxyXG5cdFx0XHRuZXdTaXplOiBuZXdTaXplXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblx0Ly8gQG1ldGhvZCBzdG9wKCk6IHRoaXNcclxuXHQvLyBTdG9wcyB0aGUgY3VycmVudGx5IHJ1bm5pbmcgYHBhblRvYCBvciBgZmx5VG9gIGFuaW1hdGlvbiwgaWYgYW55LlxyXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuem9vbVNuYXApIHtcclxuXHRcdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zdG9wKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gR2VvbG9jYXRpb24gbWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgbG9jYXRlKG9wdGlvbnM/OiBMb2NhdGUgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBUcmllcyB0byBsb2NhdGUgdGhlIHVzZXIgdXNpbmcgdGhlIEdlb2xvY2F0aW9uIEFQSSwgZmlyaW5nIGEgW2Bsb2NhdGlvbmZvdW5kYF0oI21hcC1sb2NhdGlvbmZvdW5kKVxyXG5cdC8vIGV2ZW50IHdpdGggbG9jYXRpb24gZGF0YSBvbiBzdWNjZXNzIG9yIGEgW2Bsb2NhdGlvbmVycm9yYF0oI21hcC1sb2NhdGlvbmVycm9yKSBldmVudCBvbiBmYWlsdXJlLFxyXG5cdC8vIGFuZCBvcHRpb25hbGx5IHNldHMgdGhlIG1hcCB2aWV3IHRvIHRoZSB1c2VyJ3MgbG9jYXRpb24gd2l0aCByZXNwZWN0IHRvXHJcblx0Ly8gZGV0ZWN0aW9uIGFjY3VyYWN5IChvciB0byB0aGUgd29ybGQgdmlldyBpZiBnZW9sb2NhdGlvbiBmYWlsZWQpLlxyXG5cdC8vIE5vdGUgdGhhdCwgaWYgeW91ciBwYWdlIGRvZXNuJ3QgdXNlIEhUVFBTLCB0aGlzIG1ldGhvZCB3aWxsIGZhaWwgaW5cclxuXHQvLyBtb2Rlcm4gYnJvd3NlcnMgKFtDaHJvbWUgNTAgYW5kIG5ld2VyXShodHRwczovL3NpdGVzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZGV2L0hvbWUvY2hyb21pdW0tc2VjdXJpdHkvZGVwcmVjYXRpbmctcG93ZXJmdWwtZmVhdHVyZXMtb24taW5zZWN1cmUtb3JpZ2lucykpXHJcblx0Ly8gU2VlIGBMb2NhdGUgb3B0aW9uc2AgZm9yIG1vcmUgZGV0YWlscy5cclxuXHRsb2NhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7XHJcblx0XHRcdHRpbWVvdXQ6IDEwMDAwLFxyXG5cdFx0XHR3YXRjaDogZmFsc2VcclxuXHRcdFx0Ly8gc2V0VmlldzogZmFsc2VcclxuXHRcdFx0Ly8gbWF4Wm9vbTogPE51bWJlcj5cclxuXHRcdFx0Ly8gbWF4aW11bUFnZTogMFxyXG5cdFx0XHQvLyBlbmFibGVIaWdoQWNjdXJhY3k6IGZhbHNlXHJcblx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRpZiAoISgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikpIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvcih7XHJcblx0XHRcdFx0Y29kZTogMCxcclxuXHRcdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gbm90IHN1cHBvcnRlZC4nXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb25SZXNwb25zZSA9IFV0aWwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlLCB0aGlzKSxcclxuXHRcdCAgICBvbkVycm9yID0gVXRpbC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3IsIHRoaXMpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLndhdGNoKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCA9XHJcblx0XHRcdCAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzdG9wTG9jYXRlKCk6IHRoaXNcclxuXHQvLyBTdG9wcyB3YXRjaGluZyBsb2NhdGlvbiBwcmV2aW91c2x5IGluaXRpYXRlZCBieSBgbWFwLmxvY2F0ZSh7d2F0Y2g6IHRydWV9KWBcclxuXHQvLyBhbmQgYWJvcnRzIHJlc2V0dGluZyB0aGUgbWFwIHZpZXcgaWYgbWFwLmxvY2F0ZSB3YXMgY2FsbGVkIHdpdGhcclxuXHQvLyBge3NldFZpZXc6IHRydWV9YC5cclxuXHRzdG9wTG9jYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAobmF2aWdhdG9yLmdlb2xvY2F0aW9uICYmIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKSB7XHJcblx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucykge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVHZW9sb2NhdGlvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuXHRcdHZhciBjID0gZXJyb3IuY29kZSxcclxuXHRcdCAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fFxyXG5cdFx0ICAgICAgICAgICAgKGMgPT09IDEgPyAncGVybWlzc2lvbiBkZW5pZWQnIDpcclxuXHRcdCAgICAgICAgICAgIChjID09PSAyID8gJ3Bvc2l0aW9uIHVuYXZhaWxhYmxlJyA6ICd0aW1lb3V0JykpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgJiYgIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLmZpdFdvcmxkKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTG9jYXRpb24gZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25lcnJvcjogRXJyb3JFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZCkgZmFpbGVkLlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmVycm9yJywge1xyXG5cdFx0XHRjb2RlOiBjLFxyXG5cdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gZXJyb3I6ICcgKyBtZXNzYWdlICsgJy4nXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZTogZnVuY3Rpb24gKHBvcykge1xyXG5cdFx0dmFyIGxhdCA9IHBvcy5jb29yZHMubGF0aXR1ZGUsXHJcblx0XHQgICAgbG5nID0gcG9zLmNvb3Jkcy5sb25naXR1ZGUsXHJcblx0XHQgICAgbGF0bG5nID0gbmV3IExhdExuZyhsYXQsIGxuZyksXHJcblx0XHQgICAgYm91bmRzID0gbGF0bG5nLnRvQm91bmRzKHBvcy5jb29yZHMuYWNjdXJhY3kgKiAyKSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5zZXRWaWV3KSB7XHJcblx0XHRcdHZhciB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcyk7XHJcblx0XHRcdHRoaXMuc2V0VmlldyhsYXRsbmcsIG9wdGlvbnMubWF4Wm9vbSA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4Wm9vbSkgOiB6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bGF0bG5nOiBsYXRsbmcsXHJcblx0XHRcdGJvdW5kczogYm91bmRzLFxyXG5cdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuXHRcdH07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBwb3MuY29vcmRzKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0XHRkYXRhW2ldID0gcG9zLmNvb3Jkc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmZvdW5kOiBMb2NhdGlvbkV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKVxyXG5cdFx0Ly8gd2VudCBzdWNjZXNzZnVsbHkuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZm91bmQnLCBkYXRhKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPIEFwcHJvcHJpYXRlIGRvY3Mgc2VjdGlvbj9cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBhZGRIYW5kbGVyKG5hbWU6IFN0cmluZywgSGFuZGxlckNsYXNzOiBGdW5jdGlvbik6IHRoaXNcclxuXHQvLyBBZGRzIGEgbmV3IGBIYW5kbGVyYCB0byB0aGUgbWFwLCBnaXZlbiBpdHMgbmFtZSBhbmQgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcblx0YWRkSGFuZGxlcjogZnVuY3Rpb24gKG5hbWUsIEhhbmRsZXJDbGFzcykge1xyXG5cdFx0aWYgKCFIYW5kbGVyQ2xhc3MpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG5cdFx0XHRoYW5kbGVyLmVuYWJsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlKCk6IHRoaXNcclxuXHQvLyBEZXN0cm95cyB0aGUgbWFwIGFuZCBjbGVhcnMgYWxsIHJlbGF0ZWQgZXZlbnQgbGlzdGVuZXJzLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHModHJ1ZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcklkICE9PSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGluc3RhbmNlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gdGhyb3dzIGVycm9yIGluIElFNi04XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXJJZDtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdC8qIGVzbGludC1lbmFibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVySWQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc3RvcExvY2F0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY2xlYXJDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2NsZWFyQ29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpIHtcclxuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCB1bmxvYWQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ucmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fcGFuZXMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcGFuZXNbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fcGFuZXMgPSBbXTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9tYXBQYW5lO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVBhbmUobmFtZTogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXHJcblx0Ly8gdGhlbiByZXR1cm5zIGl0LiBUaGUgcGFuZSBpcyBjcmVhdGVkIGFzIGEgY2hpbGQgb2YgYGNvbnRhaW5lcmAsIG9yXHJcblx0Ly8gYXMgYSBjaGlsZCBvZiB0aGUgbWFpbiBtYXAgcGFuZSBpZiBub3Qgc2V0LlxyXG5cdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxyXG5cdFx0ICAgIHBhbmUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKG5hbWUpIHtcclxuXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgR2V0dGluZyBNYXAgU3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fbGFzdENlbnRlcjtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyB2aXNpYmxlIGluIHRoZSBjdXJyZW50IG1hcCB2aWV3XHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcblx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoc3csIG5lKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1pblpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1pblpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLCBvciBgMGAgYnkgZGVmYXVsdC5cclxuXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2xheWVyc01pblpvb20gfHwgMCA6IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWF4Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWF4Wm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycykuXHJcblx0Z2V0TWF4Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgP1xyXG5cdFx0XHQodGhpcy5fbGF5ZXJzTWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aGlzLl9sYXllcnNNYXhab29tKSA6XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzWm9vbShib3VuZHM6IExhdExuZ0JvdW5kcywgaW5zaWRlPzogQm9vbGVhbiwgcGFkZGluZz86IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBnaXZlbiBib3VuZHMgZml0IHRvIHRoZSBtYXBcclxuXHQvLyB2aWV3IGluIGl0cyBlbnRpcmV0eS4gSWYgYGluc2lkZWAgKG9wdGlvbmFsKSBpcyBzZXQgdG8gYHRydWVgLCB0aGUgbWV0aG9kXHJcblx0Ly8gaW5zdGVhZCByZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIG1hcCB2aWV3IGZpdHMgaW50b1xyXG5cdC8vIHRoZSBnaXZlbiBib3VuZHMgaW4gaXRzIGVudGlyZXR5LlxyXG5cdGdldEJvdW5kc1pvb206IGZ1bmN0aW9uIChib3VuZHMsIGluc2lkZSwgcGFkZGluZykgeyAvLyAoTGF0TG5nQm91bmRzWywgQm9vbGVhbiwgUG9pbnRdKSAtPiBOdW1iZXJcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblx0XHRwYWRkaW5nID0gdG9Qb2ludChwYWRkaW5nIHx8IFswLCAwXSk7XHJcblxyXG5cdFx0dmFyIHpvb20gPSB0aGlzLmdldFpvb20oKSB8fCAwLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIG53ID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLFxyXG5cdFx0ICAgIHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKS5zdWJ0cmFjdChwYWRkaW5nKSxcclxuXHRcdCAgICBib3VuZHNTaXplID0gdG9Cb3VuZHModGhpcy5wcm9qZWN0KHNlLCB6b29tKSwgdGhpcy5wcm9qZWN0KG53LCB6b29tKSkuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMSxcclxuXHRcdCAgICBzY2FsZXggPSBzaXplLnggLyBib3VuZHNTaXplLngsXHJcblx0XHQgICAgc2NhbGV5ID0gc2l6ZS55IC8gYm91bmRzU2l6ZS55LFxyXG5cdFx0ICAgIHNjYWxlID0gaW5zaWRlID8gTWF0aC5tYXgoc2NhbGV4LCBzY2FsZXkpIDogTWF0aC5taW4oc2NhbGV4LCBzY2FsZXkpO1xyXG5cclxuXHRcdHpvb20gPSB0aGlzLmdldFNjYWxlWm9vbShzY2FsZSwgem9vbSk7XHJcblxyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIChzbmFwIC8gMTAwKSkgKiAoc25hcCAvIDEwMCk7IC8vIGRvbid0IGp1bXAgaWYgd2l0aGluIDElIG9mIGEgc25hcCBsZXZlbFxyXG5cdFx0XHR6b29tID0gaW5zaWRlID8gTWF0aC5jZWlsKHpvb20gLyBzbmFwKSAqIHNuYXAgOiBNYXRoLmZsb29yKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBtYXAgY29udGFpbmVyIChpbiBwaXhlbHMpLlxyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IFBvaW50KFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAwLFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgMCk7XHJcblxyXG5cdFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3NpemUuY2xvbmUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsQm91bmRzKCk6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBtYXAgdmlldyBpbiBwcm9qZWN0ZWQgcGl4ZWxcclxuXHQvLyBjb29yZGluYXRlcyAoc29tZXRpbWVzIHVzZWZ1bCBpbiBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0VG9wTGVmdFBvaW50KGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyh0b3BMZWZ0UG9pbnQsIHRvcExlZnRQb2ludC5hZGQodGhpcy5nZXRTaXplKCkpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPOiBDaGVjayBzZW1hbnRpY3MgLSBpc24ndCB0aGUgcGl4ZWwgb3JpZ2luIHRoZSAwLDAgY29vcmQgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgbWFwIHBhbmU/IFwibGVmdCBwb2ludCBvZiB0aGUgbWFwIGxheWVyXCIgY2FuIGJlIGNvbmZ1c2luZywgc3BlY2lhbGx5XHJcblx0Ly8gc2luY2UgdGhlcmUgY2FuIGJlIG5lZ2F0aXZlIG9mZnNldHMuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbE9yaWdpbigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHByb2plY3RlZCBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgdG9wIGxlZnQgcG9pbnQgb2ZcclxuXHQvLyB0aGUgbWFwIGxheWVyICh1c2VmdWwgaW4gY3VzdG9tIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHRcdHJldHVybiB0aGlzLl9waXhlbE9yaWdpbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsV29ybGRCb3VuZHMoem9vbT86IE51bWJlcik6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIHdvcmxkJ3MgYm91bmRzIGluIHBpeGVsIGNvb3JkaW5hdGVzIGZvciB6b29tIGxldmVsIGB6b29tYC5cclxuXHQvLyBJZiBgem9vbWAgaXMgb21pdHRlZCwgdGhlIG1hcCdzIGN1cnJlbnQgem9vbSBsZXZlbCBpcyB1c2VkLlxyXG5cdGdldFBpeGVsV29ybGRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5nZXRQcm9qZWN0ZWRCb3VuZHMoem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRab29tKCkgOiB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShwYW5lOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgYSBbbWFwIHBhbmVdKCNtYXAtcGFuZSksIGdpdmVuIGl0cyBuYW1lIG9yIGl0cyBIVE1MIGVsZW1lbnQgKGl0cyBpZGVudGl0eSkuXHJcblx0Z2V0UGFuZTogZnVuY3Rpb24gKHBhbmUpIHtcclxuXHRcdHJldHVybiB0eXBlb2YgcGFuZSA9PT0gJ3N0cmluZycgPyB0aGlzLl9wYW5lc1twYW5lXSA6IHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lcygpOiBPYmplY3RcclxuXHQvLyBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCBbcGFuZXNdKCNtYXAtcGFuZSkgYXMga2V5cyBhbmRcclxuXHQvLyB0aGUgcGFuZXMgYXMgdmFsdWVzLlxyXG5cdGdldFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGFuZXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIG1hcC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIENvbnZlcnNpb24gTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb21TY2FsZSh0b1pvb206IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNjYWxlIGZhY3RvciB0byBiZSBhcHBsaWVkIHRvIGEgbWFwIHRyYW5zaXRpb24gZnJvbSB6b29tIGxldmVsXHJcblx0Ly8gYGZyb21ab29tYCB0byBgdG9ab29tYC4gVXNlZCBpbnRlcm5hbGx5IHRvIGhlbHAgd2l0aCB6b29tIGFuaW1hdGlvbnMuXHJcblx0Z2V0Wm9vbVNjYWxlOiBmdW5jdGlvbiAodG9ab29tLCBmcm9tWm9vbSkge1xyXG5cdFx0Ly8gVE9ETyByZXBsYWNlIHdpdGggdW5pdmVyc2FsIGltcGxlbWVudGF0aW9uIGFmdGVyIHJlZmFjdG9yaW5nIHByb2plY3Rpb25zXHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHJldHVybiBjcnMuc2NhbGUodG9ab29tKSAvIGNycy5zY2FsZShmcm9tWm9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTY2FsZVpvb20oc2NhbGU6IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHpvb20gbGV2ZWwgdGhhdCB0aGUgbWFwIHdvdWxkIGVuZCB1cCBhdCwgaWYgaXQgaXMgYXQgYGZyb21ab29tYFxyXG5cdC8vIGxldmVsIGFuZCBldmVyeXRoaW5nIGlzIHNjYWxlZCBieSBhIGZhY3RvciBvZiBgc2NhbGVgLiBJbnZlcnNlIG9mXHJcblx0Ly8gW2BnZXRab29tU2NhbGVgXSgjbWFwLWdldFpvb21TY2FsZSkuXHJcblx0Z2V0U2NhbGVab29tOiBmdW5jdGlvbiAoc2NhbGUsIGZyb21ab29tKSB7XHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHZhciB6b29tID0gY3JzLnpvb20oc2NhbGUgKiBjcnMuc2NhbGUoZnJvbVpvb20pKTtcclxuXHRcdHJldHVybiBpc05hTih6b29tKSA/IEluZmluaXR5IDogem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSBgTGF0TG5nYCBhY2NvcmRpbmcgdG8gdGhlIHByb2plY3Rpb25cclxuXHQvLyBvZiB0aGUgbWFwJ3MgQ1JTLCB0aGVuIHNjYWxlcyBpdCBhY2NvcmRpbmcgdG8gYHpvb21gIGFuZCB0aGUgQ1JTJ3NcclxuXHQvLyBgVHJhbnNmb3JtYXRpb25gLiBUaGUgcmVzdWx0IGlzIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgQ1JTIG9yaWdpbi5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KHRvTGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gSW52ZXJzZSBvZiBbYHByb2plY3RgXSgjbWFwLXByb2plY3QpLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKHRvUG9pbnQocG9pbnQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRsYXllclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QocHJvamVjdGVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3QodG9MYXRMbmcobGF0bG5nKSkuX3JvdW5kKCk7XHJcblx0XHRyZXR1cm4gcHJvamVjdGVkUG9pbnQuX3N1YnRyYWN0KHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGBsYXRgIGFuZCBgbG5nYCBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBtYXAncyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZVxyXG5cdC8vIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nKHRvTGF0TG5nKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZ0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmcgdGhhdFxyXG5cdC8vIGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXHJcblx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIHRoZSBjZW50ZXIgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcywgYW5kIHRoZSBtYWpvcml0eSBvZiB0aGUgYm91bmRzXHJcblx0Ly8gb3ZlcmxhcHMgdGhlIENSUydzIGJvdW5kcy5cclxuXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nQm91bmRzKHRvTGF0TG5nQm91bmRzKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvXHJcblx0Ly8gdGhlIG1hcCdzIENSUy4gQnkgZGVmYXVsdCB0aGlzIG1lYXN1cmVzIGRpc3RhbmNlIGluIG1ldGVycy5cclxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmRpc3RhbmNlKHRvTGF0TG5nKGxhdGxuZzEpLCB0b0xhdExuZyhsYXRsbmcyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9Db250YWluZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnNcclxuXHQvLyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRvUG9pbnQocG9pbnQpKTtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KHRvTGF0TG5nKGxhdGxuZykpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZVxyXG5cdC8vIG1hcCBjb250YWluZXIgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gRG9tRXZlbnQuZ2V0TW91c2VQb3NpdGlvbihlLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF5ZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXRMbmcoZXY6IE1vdXNlRXZlbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIHdoZXJlIHRoZVxyXG5cdC8vIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF0TG5nOiBmdW5jdGlvbiAoZSkgeyAvLyAoTW91c2VFdmVudClcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBtYXAgaW5pdGlhbGl6YXRpb24gbWV0aG9kc1xyXG5cclxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5nZXQoaWQpO1xyXG5cclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBub3QgZm91bmQuJyk7XHJcblx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgdGhpcyk7XHJcblx0XHR0aGlzLl9jb250YWluZXJJZCA9IFV0aWwuc3RhbXAoY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcblx0XHR0aGlzLl9mYWRlQW5pbWF0ZWQgPSB0aGlzLm9wdGlvbnMuZmFkZUFuaW1hdGlvbiAmJiBCcm93c2VyLmFueTNkO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250YWluZXInICtcclxuXHRcdFx0KEJyb3dzZXIudG91Y2ggPyAnIGxlYWZsZXQtdG91Y2gnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIucmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5pZWx0OSA/ICcgbGVhZmxldC1vbGRpZScgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5zYWZhcmkgPyAnIGxlYWZsZXQtc2FmYXJpJyA6ICcnKSArXHJcblx0XHRcdCh0aGlzLl9mYWRlQW5pbWF0ZWQgPyAnIGxlYWZsZXQtZmFkZS1hbmltJyA6ICcnKSk7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gRG9tVXRpbC5nZXRTdHlsZShjb250YWluZXIsICdwb3NpdGlvbicpO1xyXG5cclxuXHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xyXG5cdFx0XHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRQYW5lcygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0Q29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9pbml0Q29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XHJcblx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzID0ge307XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vXHJcblx0XHQvLyBQYW5lcyBhcmUgRE9NIGVsZW1lbnRzIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXJpbmcgb2YgbGF5ZXJzIG9uIHRoZSBtYXAuIFlvdVxyXG5cdFx0Ly8gY2FuIGFjY2VzcyBwYW5lcyB3aXRoIFtgbWFwLmdldFBhbmVgXSgjbWFwLWdldHBhbmUpIG9yXHJcblx0XHQvLyBbYG1hcC5nZXRQYW5lc2BdKCNtYXAtZ2V0cGFuZXMpIG1ldGhvZHMuIE5ldyBwYW5lcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxyXG5cdFx0Ly8gW2BtYXAuY3JlYXRlUGFuZWBdKCNtYXAtY3JlYXRlcGFuZSkgbWV0aG9kLlxyXG5cdFx0Ly9cclxuXHRcdC8vIEV2ZXJ5IG1hcCBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBhbmVzIHRoYXQgZGlmZmVyIG9ubHkgaW4gekluZGV4LlxyXG5cdFx0Ly9cclxuXHRcdC8vIEBwYW5lIG1hcFBhbmU6IEhUTUxFbGVtZW50ID0gJ2F1dG8nXHJcblx0XHQvLyBQYW5lIHRoYXQgY29udGFpbnMgYWxsIG90aGVyIG1hcCBwYW5lc1xyXG5cclxuXHRcdHRoaXMuX21hcFBhbmUgPSB0aGlzLmNyZWF0ZVBhbmUoJ21hcFBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdC8vIEBwYW5lIHRpbGVQYW5lOiBIVE1MRWxlbWVudCA9IDIwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEdyaWRMYXllcmBzIGFuZCBgVGlsZUxheWVyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndGlsZVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG92ZXJsYXlQYW5lOiBIVE1MRWxlbWVudCA9IDQwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgdmVjdG9ycyAoYFBhdGhgcywgbGlrZSBgUG9seWxpbmVgcyBhbmQgYFBvbHlnb25gcyksIGBJbWFnZU92ZXJsYXlgcyBhbmQgYFZpZGVvT3ZlcmxheWBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3NoYWRvd1BhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHNoYWRvd1BhbmU6IEhUTUxFbGVtZW50ID0gNTAwXHJcblx0XHQvLyBQYW5lIGZvciBvdmVybGF5IHNoYWRvd3MgKGUuZy4gYE1hcmtlcmAgc2hhZG93cylcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnb3ZlcmxheVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG1hcmtlclBhbmU6IEhUTUxFbGVtZW50ID0gNjAwXHJcblx0XHQvLyBQYW5lIGZvciBgSWNvbmBzIG9mIGBNYXJrZXJgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdtYXJrZXJQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSB0b29sdGlwUGFuZTogSFRNTEVsZW1lbnQgPSA2NTBcclxuXHRcdC8vIFBhbmUgZm9yIGBUb29sdGlwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3Rvb2x0aXBQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBwb3B1cFBhbmU6IEhUTUxFbGVtZW50ID0gNzAwXHJcblx0XHQvLyBQYW5lIGZvciBgUG9wdXBgcy5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgncG9wdXBQYW5lJyk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhbmVzLm1hcmtlclBhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdHZhciBsb2FkaW5nID0gIXRoaXMuX2xvYWRlZDtcclxuXHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XHJcblx0XHR6b29tID0gdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgndmlld3ByZXJlc2V0Jyk7XHJcblxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuXHRcdHRoaXNcclxuXHRcdFx0Ll9tb3ZlU3RhcnQoem9vbUNoYW5nZWQsIGZhbHNlKVxyXG5cdFx0XHQuX21vdmUoY2VudGVyLCB6b29tKVxyXG5cdFx0XHQuX21vdmVFbmQoem9vbUNoYW5nZWQpO1xyXG5cclxuXHRcdC8vIEBldmVudCB2aWV3cmVzZXQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgbmVlZHMgdG8gcmVkcmF3IGl0cyBjb250ZW50ICh0aGlzIHVzdWFsbHkgaGFwcGVuc1xyXG5cdFx0Ly8gb24gbWFwIHpvb20gb3IgbG9hZCkuIFZlcnkgdXNlZnVsIGZvciBjcmVhdGluZyBjdXN0b20gb3ZlcmxheXMuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGluaXRpYWxpemVkICh3aGVuIGl0cyBjZW50ZXIgYW5kIHpvb20gYXJlIHNldFxyXG5cdFx0Ly8gZm9yIHRoZSBmaXJzdCB0aW1lKS5cclxuXHRcdGlmIChsb2FkaW5nKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9tb3ZlU3RhcnQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCwgbm9Nb3ZlU3RhcnQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgem9vbSBpcyBhYm91dCB0byBjaGFuZ2UgKGUuZy4gYmVmb3JlIHpvb20gYW5pbWF0aW9uKS5cclxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWV3IG9mIHRoZSBtYXAgc3RhcnRzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXApLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbXN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0XHRpZiAoIW5vTW92ZVN0YXJ0KSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfbW92ZTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgZGF0YSkge1xyXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuXHRcdH1cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblxyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gY2VudGVyO1xyXG5cdFx0dGhpcy5fcGl4ZWxPcmlnaW4gPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCB6b29tOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IGNoYW5nZSBpbiB6b29tIGxldmVsLCBpbmNsdWRpbmcgem9vbVxyXG5cdFx0Ly8gYW5kIGZseSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkIHx8IChkYXRhICYmIGRhdGEucGluY2gpKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBtb3ZlbWVudCBvZiB0aGUgbWFwLCBpbmNsdWRpbmcgcGFuIGFuZFxyXG5cdFx0Ly8gZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0X21vdmVFbmQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21lbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaGFzIGNoYW5nZWQsIGFmdGVyIGFueSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY2VudGVyIG9mIHRoZSBtYXAgc3RvcHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdG9wcGVkXHJcblx0XHQvLyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfc3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmx5VG9GcmFtZSk7XHJcblx0XHRpZiAodGhpcy5fcGFuQW5pbSkge1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltLnN0b3AoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9yYXdQYW5CeTogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KSk7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNYXhab29tKCkgLSB0aGlzLmdldE1pblpvb20oKTtcclxuXHR9LFxyXG5cclxuXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuZm9yY2luZ0JvdW5kcykge1xyXG5cdFx0XHR0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTZXQgbWFwIGNlbnRlciBhbmQgem9vbSBmaXJzdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBET00gZXZlbnQgaGFuZGxpbmdcclxuXHJcblx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gZXZlbnRzXHJcblx0X2luaXRFdmVudHM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuXHRcdHRoaXMuX3RhcmdldHMgPSB7fTtcclxuXHRcdHRoaXMuX3RhcmdldHNbVXRpbC5zdGFtcCh0aGlzLl9jb250YWluZXIpXSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gRG9tRXZlbnQub2ZmIDogRG9tRXZlbnQub247XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAob3IgdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBkYmxjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIChvciBkb3VibGUtdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZWRvd246IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZXVwOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW92ZXI6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3V0OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW1vdmU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoaWxlIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgY29udGV4dG1lbnU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSByaWdodCBtb3VzZSBidXR0b24gb24gdGhlIG1hcCwgcHJldmVudHNcclxuXHRcdC8vIGRlZmF1bHQgYnJvd3NlciBjb250ZXh0IG1lbnUgZnJvbSBzaG93aW5nIGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMgb25cclxuXHRcdC8vIHRoaXMgZXZlbnQuIEFsc28gZmlyZWQgb24gbW9iaWxlIHdoZW4gdGhlIHVzZXIgaG9sZHMgYSBzaW5nbGUgdG91Y2hcclxuXHRcdC8vIGZvciBhIHNlY29uZCAoYWxzbyBjYWxsZWQgbG9uZyBwcmVzcykuXHJcblx0XHQvLyBAZXZlbnQga2V5cHJlc3M6IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB0aGF0IHByb2R1Y2VzIGEgY2hhcmFjdGVyIHZhbHVlIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuXHRcdC8vIEBldmVudCBrZXlkb3duOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLiBVbmxpa2UgdGhlIGBrZXlwcmVzc2AgZXZlbnQsXHJcblx0XHQvLyB0aGUgYGtleWRvd25gIGV2ZW50IGlzIGZpcmVkIGZvciBrZXlzIHRoYXQgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZSBhbmQgZm9yIGtleXNcclxuXHRcdC8vIHRoYXQgZG8gbm90IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUuXHJcblx0XHQvLyBAZXZlbnQga2V5dXA6IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG5cdFx0b25PZmYodGhpcy5fY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgJyArXHJcblx0XHRcdCdtb3VzZW92ZXIgbW91c2VvdXQgbW91c2Vtb3ZlIGNvbnRleHRtZW51IGtleXByZXNzIGtleWRvd24ga2V5dXAnLCB0aGlzLl9oYW5kbGVET01FdmVudCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSkge1xyXG5cdFx0XHRvbk9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QgJiYgdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0KHJlbW92ZSA/IHRoaXMub2ZmIDogdGhpcy5vbikuY2FsbCh0aGlzLCAnbW92ZWVuZCcsIHRoaXMuX29uTW92ZUVuZCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuXHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUoXHJcblx0XHQgICAgICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5pbnZhbGlkYXRlU2l6ZSh7ZGVib3VuY2VNb3ZlZW5kOiB0cnVlfSk7IH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vblNjcm9sbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbFRvcCAgPSAwO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbExlZnQgPSAwO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyMDM4NzMgYnV0IFdlYmtpdCBhbHNvIGhhdmVcclxuXHRcdFx0Ly8gYSBwaXhlbCBvZmZzZXQgb24gdmVyeSBoaWdoIHZhbHVlcywgc2VlOiBodHRwOi8vanNmaWRkbGUubmV0L2RnNnI1aGhiL1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9maW5kRXZlbnRUYXJnZXRzOiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG5cdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuXHRcdCAgICB0YXJnZXQsXHJcblx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXHJcblx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG5cdFx0ICAgIGRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0d2hpbGUgKHNyYykge1xyXG5cdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW1V0aWwuc3RhbXAoc3JjKV07XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ3ByZWNsaWNrJykgJiYgIWUuX3NpbXVsYXRlZCAmJiB0aGlzLl9kcmFnZ2FibGVNb3ZlZCh0YXJnZXQpKSB7XHJcblx0XHRcdFx0Ly8gUHJldmVudCBmaXJpbmcgY2xpY2sgYWZ0ZXIgeW91IGp1c3QgZHJhZ2dlZCBhbiBvYmplY3QuXHJcblx0XHRcdFx0ZHJhZ2dpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0XHRpZiAoaXNIb3ZlciAmJiAhRG9tRXZlbnQuaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7IGJyZWFrOyB9XHJcblx0XHRcdFx0dGFyZ2V0cy5wdXNoKHRhcmdldCk7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIpIHsgYnJlYWs7IH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoc3JjID09PSB0aGlzLl9jb250YWluZXIpIHsgYnJlYWs7IH1cclxuXHRcdFx0c3JjID0gc3JjLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0XHRpZiAoIXRhcmdldHMubGVuZ3RoICYmICFkcmFnZ2luZyAmJiAhaXNIb3ZlciAmJiBEb21FdmVudC5pc0V4dGVybmFsVGFyZ2V0KHNyYywgZSkpIHtcclxuXHRcdFx0dGFyZ2V0cyA9IFt0aGlzXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0YXJnZXRzO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVET01FdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8IERvbUV2ZW50LnNraXBwZWQoZSkpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHR5cGUgPSBlLnR5cGU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZWRvd24nIHx8IHR5cGUgPT09ICdrZXlwcmVzcycgfHwgdHlwZSA9PT0gJ2tleXVwJyB8fCB0eXBlID09PSAna2V5ZG93bicpIHtcclxuXHRcdFx0Ly8gcHJldmVudHMgb3V0bGluZSB3aGVuIGNsaWNraW5nIG9uIGtleWJvYXJkLWZvY3VzYWJsZSBlbGVtZW50XHJcblx0XHRcdERvbVV0aWwucHJldmVudE91dGxpbmUoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9maXJlRE9NRXZlbnQoZSwgdHlwZSk7XHJcblx0fSxcclxuXHJcblx0X21vdXNlRXZlbnRzOiBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdjb250ZXh0bWVudSddLFxyXG5cclxuXHRfZmlyZURPTUV2ZW50OiBmdW5jdGlvbiAoZSwgdHlwZSwgdGFyZ2V0cykge1xyXG5cclxuXHRcdGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcclxuXHRcdFx0Ly8gRmlyZSBhIHN5bnRoZXRpYyAncHJlY2xpY2snIGV2ZW50IHdoaWNoIHByb3BhZ2F0ZXMgdXAgKG1haW5seSBmb3IgY2xvc2luZyBwb3B1cHMpLlxyXG5cdFx0XHQvLyBAZXZlbnQgcHJlY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgYmVmb3JlIG1vdXNlIGNsaWNrIG9uIHRoZSBtYXAgKHNvbWV0aW1lcyB1c2VmdWwgd2hlbiB5b3VcclxuXHRcdFx0Ly8gd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9uIGNsaWNrIGJlZm9yZSBhbnkgZXhpc3RpbmcgY2xpY2tcclxuXHRcdFx0Ly8gaGFuZGxlcnMgc3RhcnQgcnVubmluZykuXHJcblx0XHRcdHZhciBzeW50aCA9IFV0aWwuZXh0ZW5kKHt9LCBlKTtcclxuXHRcdFx0c3ludGgudHlwZSA9ICdwcmVjbGljayc7XHJcblx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChzeW50aCwgc3ludGgudHlwZSwgdGFyZ2V0cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGUuX3N0b3BwZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gRmluZCB0aGUgbGF5ZXIgdGhlIGV2ZW50IGlzIHByb3BhZ2F0aW5nIGZyb20gYW5kIGl0cyBwYXJlbnRzLlxyXG5cdFx0dGFyZ2V0cyA9ICh0YXJnZXRzIHx8IFtdKS5jb25jYXQodGhpcy5fZmluZEV2ZW50VGFyZ2V0cyhlLCB0eXBlKSk7XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcclxuXHRcdGlmICh0eXBlID09PSAnY29udGV4dG1lbnUnICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChlLnR5cGUgIT09ICdrZXlwcmVzcycgJiYgZS50eXBlICE9PSAna2V5ZG93bicgJiYgZS50eXBlICE9PSAna2V5dXAnKSB7XHJcblx0XHRcdHZhciBpc01hcmtlciA9IHRhcmdldC5nZXRMYXRMbmcgJiYgKCF0YXJnZXQuX3JhZGl1cyB8fCB0YXJnZXQuX3JhZGl1cyA8PSAxMCk7XHJcblx0XHRcdGRhdGEuY29udGFpbmVyUG9pbnQgPSBpc01hcmtlciA/XHJcblx0XHRcdFx0dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRhcmdldC5nZXRMYXRMbmcoKSkgOiB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xyXG5cdFx0XHRkYXRhLmxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGRhdGEuY29udGFpbmVyUG9pbnQpO1xyXG5cdFx0XHRkYXRhLmxhdGxuZyA9IGlzTWFya2VyID8gdGFyZ2V0LmdldExhdExuZygpIDogdGhpcy5sYXllclBvaW50VG9MYXRMbmcoZGF0YS5sYXllclBvaW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGFyZ2V0c1tpXS5maXJlKHR5cGUsIGRhdGEsIHRydWUpO1xyXG5cdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkIHx8XHJcblx0XHRcdFx0KHRhcmdldHNbaV0ub3B0aW9ucy5idWJibGluZ01vdXNlRXZlbnRzID09PSBmYWxzZSAmJiBVdGlsLmluZGV4T2YodGhpcy5fbW91c2VFdmVudHMsIHR5cGUpICE9PSAtMSkpIHsgcmV0dXJuOyB9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2RyYWdnYWJsZU1vdmVkOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRvYmogPSBvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLmVuYWJsZWQoKSA/IG9iaiA6IHRoaXM7XHJcblx0XHRyZXR1cm4gKG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcubW92ZWQoKSkgfHwgKHRoaXMuYm94Wm9vbSAmJiB0aGlzLmJveFpvb20ubW92ZWQoKSk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFySGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIHdoZW5SZWFkeShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYGZuYCB3aGVuIHRoZSBtYXAgZ2V0cyBpbml0aWFsaXplZCB3aXRoXHJcblx0Ly8gYSB2aWV3IChjZW50ZXIgYW5kIHpvb20pIGFuZCBhdCBsZWFzdCBvbmUgbGF5ZXIsIG9yIGltbWVkaWF0ZWx5XHJcblx0Ly8gaWYgaXQncyBhbHJlYWR5IGluaXRpYWxpemVkLCBvcHRpb25hbGx5IHBhc3NpbmcgYSBmdW5jdGlvbiBjb250ZXh0LlxyXG5cdHdoZW5SZWFkeTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdGNhbGxiYWNrLmNhbGwoY29udGV4dCB8fCB0aGlzLCB7dGFyZ2V0OiB0aGlzfSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm9uKCdsb2FkJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyBmb3IgZ2V0dGluZyBtYXAgc3RhdGVcclxuXHJcblx0X2dldE1hcFBhbmVQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBEb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUpIHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRyZXR1cm4gcG9zICYmICFwb3MuZXF1YWxzKFswLCAwXSk7XHJcblx0fSxcclxuXHJcblx0X2dldFRvcExlZnRQb2ludDogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHBpeGVsT3JpZ2luID0gY2VudGVyICYmIHpvb20gIT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkgOlxyXG5cdFx0XHR0aGlzLmdldFBpeGVsT3JpZ2luKCk7XHJcblx0XHRyZXR1cm4gcGl4ZWxPcmlnaW4uc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TmV3UGl4ZWxPcmlnaW46IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKS5fc3VidHJhY3Qodmlld0hhbGYpLl9hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBjZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QobGF0bG5nLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRvQm91bmRzKFtcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpXHJcblx0XHRdKTtcclxuXHR9LFxyXG5cclxuXHQvLyBsYXllciBwb2ludCBvZiB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRfZ2V0Q2VudGVyTGF5ZXJQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBvZmZzZXQgb2YgdGhlIHNwZWNpZmllZCBwbGFjZSB0byB0aGUgY3VycmVudCBjZW50ZXIgaW4gcGl4ZWxzXHJcblx0X2dldENlbnRlck9mZnNldDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZykuc3VidHJhY3QodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3QgY2VudGVyIGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0Q2VudGVyOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBib3VuZHMpIHtcclxuXHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gY2VudGVyOyB9XHJcblxyXG5cdFx0dmFyIGNlbnRlclBvaW50ID0gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICB2aWV3Qm91bmRzID0gbmV3IEJvdW5kcyhjZW50ZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZiksIGNlbnRlclBvaW50LmFkZCh2aWV3SGFsZikpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xyXG5cclxuXHRcdC8vIElmIG9mZnNldCBpcyBsZXNzIHRoYW4gYSBwaXhlbCwgaWdub3JlLlxyXG5cdFx0Ly8gVGhpcyBwcmV2ZW50cyB1bnN0YWJsZSBwcm9qZWN0aW9ucyBmcm9tIGdldHRpbmcgaW50b1xyXG5cdFx0Ly8gYW4gaW5maW5pdGUgbG9vcCBvZiB0aW55IG9mZnNldHMuXHJcblx0XHRpZiAob2Zmc2V0LnJvdW5kKCkuZXF1YWxzKFswLCAwXSkpIHtcclxuXHRcdFx0cmV0dXJuIGNlbnRlcjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QoY2VudGVyUG9pbnQuYWRkKG9mZnNldCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQsIGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIG9mZnNldDsgfVxyXG5cclxuXHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIG5ld0JvdW5kcyA9IG5ldyBCb3VuZHModmlld0JvdW5kcy5taW4uYWRkKG9mZnNldCksIHZpZXdCb3VuZHMubWF4LmFkZChvZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0LmFkZCh0aGlzLl9nZXRCb3VuZHNPZmZzZXQobmV3Qm91bmRzLCBib3VuZHMpKTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm5zIG9mZnNldCBuZWVkZWQgZm9yIHB4Qm91bmRzIHRvIGdldCBpbnNpZGUgbWF4Qm91bmRzIGF0IGEgc3BlY2lmaWVkIHpvb21cclxuXHRfZ2V0Qm91bmRzT2Zmc2V0OiBmdW5jdGlvbiAocHhCb3VuZHMsIG1heEJvdW5kcywgem9vbSkge1xyXG5cdFx0dmFyIHByb2plY3RlZE1heEJvdW5kcyA9IHRvQm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSlcclxuXHRcdCAgICApLFxyXG5cdFx0ICAgIG1pbk9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5taW4uc3VidHJhY3QocHhCb3VuZHMubWluKSxcclxuXHRcdCAgICBtYXhPZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWF4LnN1YnRyYWN0KHB4Qm91bmRzLm1heCksXHJcblxyXG5cdFx0ICAgIGR4ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueCwgLW1heE9mZnNldC54KSxcclxuXHRcdCAgICBkeSA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LnksIC1tYXhPZmZzZXQueSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChkeCwgZHkpO1xyXG5cdH0sXHJcblxyXG5cdF9yZWJvdW5kOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuXHRcdHJldHVybiBsZWZ0ICsgcmlnaHQgPiAwID9cclxuXHRcdFx0TWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6XHJcblx0XHRcdE1hdGgubWF4KDAsIE1hdGguY2VpbChsZWZ0KSkgLSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHJpZ2h0KSk7XHJcblx0fSxcclxuXHJcblx0X2xpbWl0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0X29uUGFuVHJhbnNpdGlvblN0ZXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cdH0sXHJcblxyXG5cdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuXHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF90cnlBbmltYXRlZFBhbjogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykge1xyXG5cdFx0Ly8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBuZXcgYW5kIGN1cnJlbnQgY2VudGVycyBpbiBwaXhlbHNcclxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fdHJ1bmMoKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIHRvbyBmYXIgdW5sZXNzIGFuaW1hdGU6IHRydWUgc3BlY2lmaWVkIGluIG9wdGlvbnNcclxuXHRcdGlmICgob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUpICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdHRoaXMucGFuQnkob2Zmc2V0LCBvcHRpb25zKTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlQW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHByb3h5ID0gdGhpcy5fcHJveHkgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblx0XHR0aGlzLl9wYW5lcy5tYXBQYW5lLmFwcGVuZENoaWxkKHByb3h5KTtcclxuXHJcblx0XHR0aGlzLm9uKCd6b29tYW5pbScsIGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdHZhciBwcm9wID0gRG9tVXRpbC5UUkFOU0ZPUk0sXHJcblx0XHRcdCAgICB0cmFuc2Zvcm0gPSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXTtcclxuXHJcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoZS5jZW50ZXIsIGUuem9vbSksIHRoaXMuZ2V0Wm9vbVNjYWxlKGUuem9vbSwgMSkpO1xyXG5cclxuXHRcdFx0Ly8gd29ya2Fyb3VuZCBmb3IgY2FzZSB3aGVuIHRyYW5zZm9ybSBpcyB0aGUgc2FtZSBhbmQgc28gdHJhbnNpdGlvbmVuZCBldmVudCBpcyBub3QgZmlyZWRcclxuXHRcdFx0aWYgKHRyYW5zZm9ybSA9PT0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF0gJiYgdGhpcy5fYW5pbWF0aW5nWm9vbSkge1xyXG5cdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5vbignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX29uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95QW5pbVByb3h5LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfZGVzdHJveUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcHJveHkpO1xyXG5cdFx0dGhpcy5vZmYoJ2xvYWQgbW92ZWVuZCcsIHRoaXMuX2FuaW1Nb3ZlRW5kLCB0aGlzKTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9wcm94eTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbU1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICB6ID0gdGhpcy5nZXRab29tKCk7XHJcblx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGMsIHopLCB0aGlzLmdldFpvb21TY2FsZSh6LCAxKSk7XHJcblx0fSxcclxuXHJcblx0X2NhdGNoVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcclxuXHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9ub3RoaW5nVG9BbmltYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKS5sZW5ndGg7XHJcblx0fSxcclxuXHJcblx0X3RyeUFuaW1hdGVkWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiBkaXNhYmxlZCwgbm90IHN1cHBvcnRlZCBvciB6b29tIGRpZmZlcmVuY2UgaXMgdG9vIGxhcmdlXHJcblx0XHRpZiAoIXRoaXMuX3pvb21BbmltYXRlZCB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8IHRoaXMuX25vdGhpbmdUb0FuaW1hdGUoKSB8fFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHQvLyBvZmZzZXQgaXMgdGhlIHBpeGVsIGNvb3JkcyBvZiB0aGUgem9vbSBvcmlnaW4gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiB0aGUgem9vbSBvcmlnaW4gaXNuJ3Qgd2l0aGluIG9uZSBzY3JlZW4gZnJvbSB0aGUgY3VycmVudCBjZW50ZXIsIHVubGVzcyBmb3JjZWRcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpXHJcblx0XHRcdCAgICAuX2FuaW1hdGVab29tKGNlbnRlciwgem9vbSwgdHJ1ZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHN0YXJ0QW5pbSwgbm9VcGRhdGUpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwUGFuZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoc3RhcnRBbmltKSB7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSB0cnVlO1xyXG5cclxuXHRcdFx0Ly8gcmVtZW1iZXIgd2hhdCBjZW50ZXIvem9vbSB0byBzZXQgYWZ0ZXIgYW5pbWF0aW9uXHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb0NlbnRlciA9IGNlbnRlcjtcclxuXHRcdFx0dGhpcy5fYW5pbWF0ZVRvWm9vbSA9IHpvb207XHJcblxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIE90aGVyIEV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21hbmltOiBab29tQW5pbUV2ZW50XHJcblx0XHQvLyBGaXJlZCBhdCBsZWFzdCBvbmNlIHBlciB6b29tIGFuaW1hdGlvbi4gRm9yIGNvbnRpbnVvdXMgem9vbSwgbGlrZSBwaW5jaCB6b29taW5nLCBmaXJlZCBvbmNlIHBlciBmcmFtZSBkdXJpbmcgem9vbS5cclxuXHRcdHRoaXMuZmlyZSgnem9vbWFuaW0nLCB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tLFxyXG5cdFx0XHRub1VwZGF0ZTogbm9VcGRhdGVcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFdvcmsgYXJvdW5kIHdlYmtpdCBub3QgZmlyaW5nICd0cmFuc2l0aW9uZW5kJywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzM2ODksIDI2OTNcclxuXHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQsIHRoaXMpLCAyNTApO1xyXG5cdH0sXHJcblxyXG5cdF9vblpvb21UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcFBhbmUpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20pO1xyXG5cclxuXHRcdC8vIFRoaXMgYW5pbSBmcmFtZSBzaG91bGQgcHJldmVudCBhbiBvYnNjdXJlIGlPUyB3ZWJraXQgdGlsZSBsb2FkaW5nIHJhY2UgY29uZGl0aW9uLlxyXG5cdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5fbW92ZUVuZCh0cnVlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXAoaWQ6IFN0cmluZywgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4vL1xyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5tYXAoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gYW4gaW5zdGFuY2Ugb2YgYSBgPGRpdj5gIEhUTUwgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXAoaWQsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcChpZCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7Q2xhc3N9IGZyb20gJy4uL2NvcmUvQ2xhc3MnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbFxyXG4gKiBAYWthIEwuQ29udHJvbFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBDb250cm9sID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbCBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBwb3NpdGlvbjogU3RyaW5nID0gJ3RvcHJpZ2h0J1xyXG5cdFx0Ly8gVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIChvbmUgb2YgdGhlIG1hcCBjb3JuZXJzKS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RvcGxlZnQnYCxcclxuXHRcdC8vIGAndG9wcmlnaHQnYCwgYCdib3R0b21sZWZ0J2Agb3IgYCdib3R0b21yaWdodCdgXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBMLkNvbnRyb2wgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgZ2V0UG9zaXRpb246IHN0cmluZ1xyXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdCAqL1xyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MRWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGNvbnRyb2wgdG8gdGhlIGdpdmVuIG1hcC5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5yZW1vdmUoKTtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG5cdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wnKTtcclxuXHJcblx0XHRpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xyXG5cdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29ybmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9uKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBjb250cm9sIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG5cdFx0XHR0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9mZigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmVmb2N1c09uTWFwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gaWYgbWFwIGV4aXN0cyBhbmQgZXZlbnQgaXMgbm90IGEga2V5Ym9hcmQgZXZlbnRcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgZSAmJiBlLnNjcmVlblggPiAwICYmIGUuc2NyZWVuWSA+IDApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCB2YXIgY29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBDb250cm9sKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICogQHVuaW5oZXJpdGFibGVcclxuICpcclxuICogRXZlcnkgY29udHJvbCBzaG91bGQgZXh0ZW5kIGZyb20gYEwuQ29udHJvbGAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cclxuICpcclxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50XHJcbiAqIFNob3VsZCByZXR1cm4gdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgYW5kIGFkZCBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgY29udHJvbC5hZGRUbyhtYXApYF0oI2NvbnRyb2wtYWRkVG8pLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKVxyXG4gKiBPcHRpb25hbCBtZXRob2QuIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNjb250cm9sLW9uYWRkKS4gQ2FsbGVkIG9uIFtgY29udHJvbC5yZW1vdmUoKWBdKCNjb250cm9sLXJlbW92ZSkuXHJcbiAqL1xyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gKi9cclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2QgYWRkQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcFxyXG5cdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLmFkZFRvKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXBcclxuXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5yZW1vdmUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0Q29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9LFxyXG5cdFx0ICAgIGwgPSAnbGVhZmxldC0nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRyb2xDb250YWluZXIgPVxyXG5cdFx0ICAgICAgICAgICAgRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcblx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ3JpZ2h0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fY29udHJvbENvcm5lcnMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvcm5lcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvcm5lcnM7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvbnRhaW5lcjtcclxuXHR9XHJcbn0pO1xyXG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5MYXllcnNcclxuICogQGFrYSBMLkNvbnRyb2wuTGF5ZXJzXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBsYXllcnMgY29udHJvbCBnaXZlcyB1c2VycyB0aGUgYWJpbGl0eSB0byBzd2l0Y2ggYmV0d2VlbiBkaWZmZXJlbnQgYmFzZSBsYXllcnMgYW5kIHN3aXRjaCBvdmVybGF5cyBvbi9vZmYgKGNoZWNrIG91dCB0aGUgW2RldGFpbGVkIGV4YW1wbGVdKGh0dHA6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2xheWVycy1jb250cm9sLykpLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGJhc2VMYXllcnMgPSB7XHJcbiAqIFx0XCJNYXBib3hcIjogbWFwYm94LFxyXG4gKiBcdFwiT3BlblN0cmVldE1hcFwiOiBvc21cclxuICogfTtcclxuICpcclxuICogdmFyIG92ZXJsYXlzID0ge1xyXG4gKiBcdFwiTWFya2VyXCI6IG1hcmtlcixcclxuICogXHRcIlJvYWRzXCI6IHJvYWRzTGF5ZXJcclxuICogfTtcclxuICpcclxuICogTC5jb250cm9sLmxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBgYmFzZUxheWVyc2AgYW5kIGBvdmVybGF5c2AgcGFyYW1ldGVycyBhcmUgb2JqZWN0IGxpdGVyYWxzIHdpdGggbGF5ZXIgbmFtZXMgYXMga2V5cyBhbmQgYExheWVyYCBvYmplY3RzIGFzIHZhbHVlczpcclxuICpcclxuICogYGBganNcclxuICoge1xyXG4gKiAgICAgXCI8c29tZU5hbWUxPlwiOiBsYXllcjEsXHJcbiAqICAgICBcIjxzb21lTmFtZTI+XCI6IGxheWVyMlxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXIgbmFtZXMgY2FuIGNvbnRhaW4gSFRNTCwgd2hpY2ggYWxsb3dzIHlvdSB0byBhZGQgYWRkaXRpb25hbCBzdHlsaW5nIHRvIHRoZSBpdGVtczpcclxuICpcclxuICogYGBganNcclxuICoge1wiPGltZyBzcmM9J215LWxheWVyLWljb24nIC8+IDxzcGFuIGNsYXNzPSdteS1sYXllci1pdGVtJz5NeSBMYXllcjwvc3Bhbj5cIjogbXlMYXllcn1cclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMYXllcnMgPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuTGF5ZXJzIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNvbGxhcHNlZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBiZSBjb2xsYXBzZWQgaW50byBhbiBpY29uIGFuZCBleHBhbmRlZCBvbiBtb3VzZSBob3ZlciBvciB0b3VjaC5cclxuXHRcdGNvbGxhcHNlZDogdHJ1ZSxcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1pJbmRleDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBhc3NpZ24gekluZGV4ZXMgaW4gaW5jcmVhc2luZyBvcmRlciB0byBhbGwgb2YgaXRzIGxheWVycyBzbyB0aGF0IHRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQgd2hlbiBzd2l0Y2hpbmcgdGhlbSBvbi9vZmYuXHJcblx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaGlkZVNpbmdsZUJhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgYmFzZSBsYXllcnMgaW4gdGhlIGNvbnRyb2wgd2lsbCBiZSBoaWRkZW4gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZS5cclxuXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRMYXllcnM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0byBzb3J0IHRoZSBsYXllcnMuIFdoZW4gYGZhbHNlYCwgbGF5ZXJzIHdpbGwga2VlcCB0aGUgb3JkZXJcclxuXHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cclxuXHRcdHNvcnRMYXllcnM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc29ydEZ1bmN0aW9uOiBGdW5jdGlvbiA9ICpcclxuXHRcdC8vIEEgW2NvbXBhcmUgZnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpXHJcblx0XHQvLyB0aGF0IHdpbGwgYmUgdXNlZCBmb3Igc29ydGluZyB0aGUgbGF5ZXJzLCB3aGVuIGBzb3J0TGF5ZXJzYCBpcyBgdHJ1ZWAuXHJcblx0XHQvLyBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYm90aCB0aGUgYEwuTGF5ZXJgIGluc3RhbmNlcyBhbmQgdGhlaXIgbmFtZXMsIGFzIGluXHJcblx0XHQvLyBgc29ydEZ1bmN0aW9uKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpYC5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIGl0IHNvcnRzIGxheWVycyBhbHBoYWJldGljYWxseSBieSB0aGVpciBuYW1lLlxyXG5cdFx0c29ydEZ1bmN0aW9uOiBmdW5jdGlvbiAobGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQikge1xyXG5cdFx0XHRyZXR1cm4gbmFtZUEgPCBuYW1lQiA/IC0xIDogKG5hbWVCIDwgbmFtZUEgPyAxIDogMCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gYmFzZUxheWVycykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgaW4gb3ZlcmxheXMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIob3ZlcmxheXNbaV0sIGksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRDb250cm9sLnByb3RvdHlwZS5hZGRUby5jYWxsKHRoaXMsIG1hcCk7XHJcblx0XHQvLyBUcmlnZ2VyIGV4cGFuZCBhZnRlciBMYXllcnMgQ29udHJvbCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIERPTSBzbyB0aGF0IGlzIG5vdyBoYXMgYW4gYWN0dWFsIGhlaWdodC5cclxuXHRcdHJldHVybiB0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkQmFzZUxheWVyKGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBiYXNlIGxheWVyIChyYWRpbyBidXR0b24gZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkQmFzZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZE92ZXJsYXkobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBvdmVybGF5IChjaGVja2JveCBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRPdmVybGF5OiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lLCB0cnVlKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmUgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGNvbnRyb2wuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0bGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG9iaiA9IHRoaXMuX2dldExheWVyKFV0aWwuc3RhbXAobGF5ZXIpKTtcclxuXHRcdGlmIChvYmopIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNwbGljZSh0aGlzLl9sYXllcnMuaW5kZXhPZihvYmopLCAxKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGV4cGFuZCgpOiB0aGlzXHJcblx0Ly8gRXhwYW5kIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBjb2xsYXBzZWQuXHJcblx0ZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gbnVsbDtcclxuXHRcdHZhciBhY2NlcHRhYmxlSGVpZ2h0ID0gdGhpcy5fbWFwLmdldFNpemUoKS55IC0gKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRUb3AgKyA1MCk7XHJcblx0XHRpZiAoYWNjZXB0YWJsZUhlaWdodCA8IHRoaXMuX3NlY3Rpb24uY2xpZW50SGVpZ2h0KSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gYWNjZXB0YWJsZUhlaWdodCArICdweCc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb2xsYXBzZSgpOiB0aGlzXHJcblx0Ly8gQ29sbGFwc2UgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGV4cGFuZGVkLlxyXG5cdGNvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxyXG5cdFx0ICAgIGNvbGxhcHNlZCA9IHRoaXMub3B0aW9ucy5jb2xsYXBzZWQ7XHJcblxyXG5cdFx0Ly8gbWFrZXMgdGhpcyB3b3JrIG9uIElFIHRvdWNoIGRldmljZXMgYnkgc3RvcHBpbmcgaXQgZnJvbSBmaXJpbmcgYSBtb3VzZW91dCBldmVudCB3aGVuIHRoZSB0b3VjaCBpcyByZWxlYXNlZFxyXG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsIHRydWUpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHREb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHJcblx0XHR2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb24gPSBEb21VdGlsLmNyZWF0ZSgnc2VjdGlvbicsIGNsYXNzTmFtZSArICctbGlzdCcpO1xyXG5cclxuXHRcdGlmIChjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuY29sbGFwc2UsIHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKCFCcm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHREb21FdmVudC5vbihjb250YWluZXIsIHtcclxuXHRcdFx0XHRcdG1vdXNlZW50ZXI6IHRoaXMuZXhwYW5kLFxyXG5cdFx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxyXG5cdFx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxpbmsgPSB0aGlzLl9sYXllcnNMaW5rID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gJ0xheWVycyc7XHJcblxyXG5cdFx0aWYgKEJyb3dzZXIudG91Y2gpIHtcclxuXHRcdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgRG9tRXZlbnQuc3RvcCk7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGxpbmssICdmb2N1cycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIHNlY3Rpb24pO1xyXG5cdFx0dGhpcy5fc2VwYXJhdG9yID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctc2VwYXJhdG9yJywgc2VjdGlvbik7XHJcblx0XHR0aGlzLl9vdmVybGF5c0xpc3QgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1vdmVybGF5cycsIHNlY3Rpb24pO1xyXG5cclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWN0aW9uKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcblx0XHRcdGlmICh0aGlzLl9sYXllcnNbaV0gJiYgVXRpbC5zdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSwgb3ZlcmxheSkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHRsYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycy5wdXNoKHtcclxuXHRcdFx0bGF5ZXI6IGxheWVyLFxyXG5cdFx0XHRuYW1lOiBuYW1lLFxyXG5cdFx0XHRvdmVybGF5OiBvdmVybGF5XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnNvcnRMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNvcnQoVXRpbC5iaW5kKGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zb3J0RnVuY3Rpb24oYS5sYXllciwgYi5sYXllciwgYS5uYW1lLCBiLm5hbWUpO1xyXG5cdFx0XHR9LCB0aGlzKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl9sYXN0WkluZGV4Kys7XHJcblx0XHRcdGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0RG9tVXRpbC5lbXB0eSh0aGlzLl9iYXNlTGF5ZXJzTGlzdCk7XHJcblx0XHREb21VdGlsLmVtcHR5KHRoaXMuX292ZXJsYXlzTGlzdCk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0b2JqID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcblx0XHRcdG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCB8fCAhb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIaWRlIGJhc2UgbGF5ZXJzIHNlY3Rpb24gaWYgdGhlcmUncyBvbmx5IG9uZSBsYXllci5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCAmJiBiYXNlTGF5ZXJzQ291bnQgPiAxO1xyXG5cdFx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdC5zdHlsZS5kaXNwbGF5ID0gYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9oYW5kbGluZ0NsaWNrKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihVdGlsLnN0YW1wKGUudGFyZ2V0KSk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGJhc2VsYXllcmNoYW5nZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBiYXNlIGxheWVyIGlzIGNoYW5nZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheWFkZDogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgZGVzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXIgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBuYW1lc3BhY2UgQ29udHJvbC5MYXllcnNcclxuXHRcdHZhciB0eXBlID0gb2JqLm92ZXJsYXkgP1xyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdiYXNlbGF5ZXJjaGFuZ2UnIDogbnVsbCk7XHJcblxyXG5cdFx0aWYgKHR5cGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHA6Ly9iaXQubHkvUHFZTEJlKVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG5cdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcblx0XHR2YXIgcmFkaW9GcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG5cdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHR9LFxyXG5cclxuXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuXHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXHJcblx0XHQgICAgaW5wdXQ7XHJcblxyXG5cdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcblx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuXHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnNfJyArIFV0aWwuc3RhbXAodGhpcyksIGNoZWNrZWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cy5wdXNoKGlucHV0KTtcclxuXHRcdGlucHV0LmxheWVySWQgPSBVdGlsLnN0YW1wKG9iai5sYXllcik7XHJcblxyXG5cdFx0RG9tRXZlbnQub24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblx0XHRuYW1lLmlubmVySFRNTCA9ICcgJyArIG9iai5uYW1lO1xyXG5cclxuXHRcdC8vIEhlbHBzIGZyb20gcHJldmVudGluZyBsYXllciBjb250cm9sIGZsaWNrZXIgd2hlbiBjaGVja2JveGVzIGFyZSBkaXNhYmxlZFxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjc3MVxyXG5cdFx0dmFyIGhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuXHRcdGxhYmVsLmFwcGVuZENoaWxkKGhvbGRlcik7XHJcblx0XHRob2xkZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKG5hbWUpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSBvYmoub3ZlcmxheSA/IHRoaXMuX292ZXJsYXlzTGlzdCA6IHRoaXMuX2Jhc2VMYXllcnNMaXN0O1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gbGFiZWw7XHJcblx0fSxcclxuXHJcblx0X29uSW5wdXRDbGljazogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCwgbGF5ZXI7XHJcblx0XHR2YXIgYWRkZWRMYXllcnMgPSBbXSxcclxuXHRcdCAgICByZW1vdmVkTGF5ZXJzID0gW107XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHJcblx0XHRcdGlmIChpbnB1dC5jaGVja2VkKSB7XHJcblx0XHRcdFx0YWRkZWRMYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQpIHtcclxuXHRcdFx0XHRyZW1vdmVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVnZml4IGlzc3VlIDIzMTg6IFNob3VsZCByZW1vdmUgYWxsIG9sZCBsYXllcnMgYmVmb3JlIHJlYWRkaW5nIG5ldyBvbmVzXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHJlbW92ZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHJlbW92ZWRMYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgYWRkZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9tYXAuaGFzTGF5ZXIoYWRkZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGFkZGVkTGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9yZWZvY3VzT25NYXAoKTtcclxuXHR9LFxyXG5cclxuXHRfY2hlY2tEaXNhYmxlZExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCxcclxuXHRcdCAgICBsYXllcixcclxuXHRcdCAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cdFx0XHRpbnB1dC5kaXNhYmxlZCA9IChsYXllci5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tIDwgbGF5ZXIub3B0aW9ucy5taW5ab29tKSB8fFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgIChsYXllci5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tID4gbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZElmTm90Q29sbGFwc2VkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxyXG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2NvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxyXG5cdFx0cmV0dXJuIHRoaXMuY29sbGFwc2UoKTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wubGF5ZXJzKGJhc2VsYXllcnM/OiBPYmplY3QsIG92ZXJsYXlzPzogT2JqZWN0LCBvcHRpb25zPzogQ29udHJvbC5MYXllcnMgb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIGxheWVycyBjb250cm9sIHdpdGggdGhlIGdpdmVuIGxheWVycy4gQmFzZSBsYXllcnMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIHJhZGlvIGJ1dHRvbnMsIHdoaWxlIG92ZXJsYXlzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCBjaGVja2JveGVzLiBOb3RlIHRoYXQgYWxsIGJhc2UgbGF5ZXJzIHNob3VsZCBiZSBwYXNzZWQgaW4gdGhlIGJhc2UgbGF5ZXJzIG9iamVjdCwgYnV0IG9ubHkgb25lIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgbWFwIGR1cmluZyBtYXAgaW5zdGFudGlhdGlvbi5cclxuZXhwb3J0IHZhciBsYXllcnMgPSBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IExheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucyk7XHJcbn07XHJcbiIsIlxyXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5ab29tXHJcbiAqIEBha2EgTC5Db250cm9sLlpvb21cclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogQSBiYXNpYyB6b29tIGNvbnRyb2wgd2l0aCB0d28gYnV0dG9ucyAoem9vbSBpbiBhbmQgem9vbSBvdXQpLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHRvIGBmYWxzZWAuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgWm9vbSA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5ab29tIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ3RvcGxlZnQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGV4dDogU3RyaW5nID0gJysnXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UZXh0OiAnKycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UaXRsZTogU3RyaW5nID0gJ1pvb20gaW4nXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGl0bGU6ICdab29tIGluJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PdXRUZXh0OiBTdHJpbmcgPSAnJiN4MjIxMjsnXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRleHQ6ICcmI3gyMjEyOycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGl0bGU6IFN0cmluZyA9ICdab29tIG91dCdcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRpdGxlOiAnWm9vbSBvdXQnXHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHZhciB6b29tTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtem9vbScsXHJcblx0XHQgICAgY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHpvb21OYW1lICsgJyBsZWFmbGV0LWJhcicpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0dGhpcy5fem9vbUluQnV0dG9uICA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21JblRleHQsIG9wdGlvbnMuem9vbUluVGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1pbicsICBjb250YWluZXIsIHRoaXMuX3pvb21Jbik7XHJcblx0XHR0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbU91dFRleHQsIG9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctb3V0JywgY29udGFpbmVyLCB0aGlzLl96b29tT3V0KTtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3pvb21JbjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tIDwgdGhpcy5fbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tID4gdGhpcy5fbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbU91dCh0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4pIHtcclxuXHRcdHZhciBsaW5rID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmlubmVySFRNTCA9IGh0bWw7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG5cdFx0LypcclxuXHRcdCAqIFdpbGwgZm9yY2Ugc2NyZWVuIHJlYWRlcnMgbGlrZSBWb2ljZU92ZXIgdG8gcmVhZCB0aGlzIGFzIFwiWm9vbSBpbiAtIGJ1dHRvblwiXHJcblx0XHQgKi9cclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cdFx0bGluay5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24obGluayk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBEb21FdmVudC5zdG9wKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIGZuLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbms7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWRpc2FibGVkJztcclxuXHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWluWm9vbSgpKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4vLyBAb3B0aW9uIHpvb21Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW3pvb20gY29udHJvbF0oI2NvbnRyb2wtem9vbSkgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHR6b29tQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy56b29tQ29udHJvbCkge1xyXG5cdFx0Ly8gQHNlY3Rpb24gQ29udHJvbHNcclxuXHRcdC8vIEBwcm9wZXJ0eSB6b29tQ29udHJvbDogQ29udHJvbC5ab29tXHJcblx0XHQvLyBUaGUgZGVmYXVsdCB6b29tIGNvbnRyb2wgKG9ubHkgYXZhaWxhYmxlIGlmIHRoZVxyXG5cdFx0Ly8gW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB3YXMgYHRydWVgIHdoZW4gY3JlYXRpbmcgdGhlIG1hcCkuXHJcblx0XHR0aGlzLnpvb21Db250cm9sID0gbmV3IFpvb20oKTtcclxuXHRcdHRoaXMuYWRkQ29udHJvbCh0aGlzLnpvb21Db250cm9sKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDb250cm9sLlpvb21cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnpvb20ob3B0aW9uczogQ29udHJvbC5ab29tIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSB6b29tIGNvbnRyb2xcclxuZXhwb3J0IHZhciB6b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFpvb20ob3B0aW9ucyk7XHJcbn07XHJcbiIsIlxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgQ29udHJvbC5TY2FsZVxuICogQGFrYSBMLkNvbnRyb2wuU2NhbGVcbiAqIEBpbmhlcml0cyBDb250cm9sXG4gKlxuICogQSBzaW1wbGUgc2NhbGUgY29udHJvbCB0aGF0IHNob3dzIHRoZSBzY2FsZSBvZiB0aGUgY3VycmVudCBjZW50ZXIgb2Ygc2NyZWVuIGluIG1ldHJpYyAobS9rbSkgYW5kIGltcGVyaWFsIChtaS9mdCkgc3lzdGVtcy4gRXh0ZW5kcyBgQ29udHJvbGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jb250cm9sLnNjYWxlKCkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgU2NhbGUgPSBDb250cm9sLmV4dGVuZCh7XG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ29udHJvbC5TY2FsZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMTAwXG5cdFx0Ly8gTWF4aW11bSB3aWR0aCBvZiB0aGUgY29udHJvbCBpbiBwaXhlbHMuIFRoZSB3aWR0aCBpcyBzZXQgZHluYW1pY2FsbHkgdG8gc2hvdyByb3VuZCB2YWx1ZXMgKGUuZy4gMTAwLCAyMDAsIDUwMCkuXG5cdFx0bWF4V2lkdGg6IDEwMCxcblxuXHRcdC8vIEBvcHRpb24gbWV0cmljOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgbWV0cmljIHNjYWxlIGxpbmUgKG0va20pLlxuXHRcdG1ldHJpYzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gaW1wZXJpYWw6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBpbXBlcmlhbCBzY2FsZSBsaW5lIChtaS9mdCkuXG5cdFx0aW1wZXJpYWw6IHRydWVcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgaXMgdXBkYXRlZCBvbiBbYG1vdmVlbmRgXSgjbWFwLW1vdmVlbmQpLCBvdGhlcndpc2UgaXQncyBhbHdheXMgdXAtdG8tZGF0ZSAodXBkYXRlZCBvbiBbYG1vdmVgXSgjbWFwLW1vdmUpKS5cblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLXNjYWxlJyxcblx0XHQgICAgY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLl9hZGRTY2FsZXMob3B0aW9ucywgY2xhc3NOYW1lICsgJy1saW5lJywgY29udGFpbmVyKTtcblxuXHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHRcdG1hcC53aGVuUmVhZHkodGhpcy5fdXBkYXRlLCB0aGlzKTtcblxuXHRcdHJldHVybiBjb250YWluZXI7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAub2ZmKHRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0fSxcblxuXHRfYWRkU2NhbGVzOiBmdW5jdGlvbiAob3B0aW9ucywgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcblx0XHRpZiAob3B0aW9ucy5tZXRyaWMpIHtcblx0XHRcdHRoaXMuX21TY2FsZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmltcGVyaWFsKSB7XG5cdFx0XHR0aGlzLl9pU2NhbGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgeSA9IG1hcC5nZXRTaXplKCkueSAvIDI7XG5cblx0XHR2YXIgbWF4TWV0ZXJzID0gbWFwLmRpc3RhbmNlKFxuXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoWzAsIHldKSxcblx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFt0aGlzLm9wdGlvbnMubWF4V2lkdGgsIHldKSk7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZXMobWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlU2NhbGVzOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVNZXRyaWMobWF4TWV0ZXJzKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVNZXRyaWM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWV0ZXJzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWV0ZXJzKSxcblx0XHQgICAgbGFiZWwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5fbVNjYWxlLCBsYWJlbCwgbWV0ZXJzIC8gbWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlSW1wZXJpYWw6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWF4RmVldCA9IG1heE1ldGVycyAqIDMuMjgwODM5OSxcblx0XHQgICAgbWF4TWlsZXMsIG1pbGVzLCBmZWV0O1xuXG5cdFx0aWYgKG1heEZlZXQgPiA1MjgwKSB7XG5cdFx0XHRtYXhNaWxlcyA9IG1heEZlZXQgLyA1MjgwO1xuXHRcdFx0bWlsZXMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNaWxlcyk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIG1pbGVzICsgJyBtaScsIG1pbGVzIC8gbWF4TWlsZXMpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZlZXQgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhGZWV0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgZmVldCArICcgZnQnLCBmZWV0IC8gbWF4RmVldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVTY2FsZTogZnVuY3Rpb24gKHNjYWxlLCB0ZXh0LCByYXRpbykge1xuXHRcdHNjYWxlLnN0eWxlLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGggKiByYXRpbykgKyAncHgnO1xuXHRcdHNjYWxlLmlubmVySFRNTCA9IHRleHQ7XG5cdH0sXG5cblx0X2dldFJvdW5kTnVtOiBmdW5jdGlvbiAobnVtKSB7XG5cdFx0dmFyIHBvdzEwID0gTWF0aC5wb3coMTAsIChNYXRoLmZsb29yKG51bSkgKyAnJykubGVuZ3RoIC0gMSksXG5cdFx0ICAgIGQgPSBudW0gLyBwb3cxMDtcblxuXHRcdGQgPSBkID49IDEwID8gMTAgOlxuXHRcdCAgICBkID49IDUgPyA1IDpcblx0XHQgICAgZCA+PSAzID8gMyA6XG5cdFx0ICAgIGQgPj0gMiA/IDIgOiAxO1xuXG5cdFx0cmV0dXJuIHBvdzEwICogZDtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnNjYWxlKG9wdGlvbnM/OiBDb250cm9sLlNjYWxlIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGFuIHNjYWxlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCB2YXIgc2NhbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFNjYWxlKG9wdGlvbnMpO1xufTtcbiIsIlxyXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBha2EgTC5Db250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBhdHRyaWJ1dGlvbiBjb250cm9sIGFsbG93cyB5b3UgdG8gZGlzcGxheSBhdHRyaWJ1dGlvbiBkYXRhIGluIGEgc21hbGwgdGV4dCBib3ggb24gYSBtYXAuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgYXR0cmlidXRpb25Db250cm9sYCBvcHRpb25dKCNtYXAtYXR0cmlidXRpb25jb250cm9sKSB0byBgZmFsc2VgLCBhbmQgaXQgZmV0Y2hlcyBhdHRyaWJ1dGlvbiB0ZXh0cyBmcm9tIGxheWVycyB3aXRoIHRoZSBbYGdldEF0dHJpYnV0aW9uYCBtZXRob2RdKCNsYXllci1nZXRhdHRyaWJ1dGlvbikgYXV0b21hdGljYWxseS4gRXh0ZW5kcyBDb250cm9sLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQXR0cmlidXRpb24gPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcHJlZml4OiBTdHJpbmcgPSAnTGVhZmxldCdcclxuXHRcdC8vIFRoZSBIVE1MIHRleHQgc2hvd24gYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuIFBhc3MgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG5cdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHBzOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+TGVhZmxldDwvYT4nXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbCA9IHRoaXM7XHJcblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHQvLyBUT0RPIHVnbHksIHJlZmFjdG9yXHJcblx0XHRmb3IgKHZhciBpIGluIG1hcC5fbGF5ZXJzKSB7XHJcblx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UHJlZml4KHByZWZpeDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHRleHQgYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuXHJcblx0c2V0UHJlZml4OiBmdW5jdGlvbiAocHJlZml4KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMucHJlZml4ID0gcHJlZml4O1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGF0dHJpYnV0aW9uIHRleHQgKGUuZy4gYCdWZWN0b3IgZGF0YSAmY29weTsgTWFwYm94J2ApLlxyXG5cdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gYXR0cmlidXRpb24gdGV4dC5cclxuXHRyZW1vdmVBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5wcmVmaXgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0dHJpYnMubGVuZ3RoKSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyB8ICcpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiBhdHRyaWJ1dGlvbkNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbYXR0cmlidXRpb24gY29udHJvbF0oI2NvbnRyb2wtYXR0cmlidXRpb24pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0YXR0cmlidXRpb25Db250cm9sOiB0cnVlXHJcbn0pO1xyXG5cclxuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG5cdFx0bmV3IEF0dHJpYnV0aW9uKCkuYWRkVG8odGhpcyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuYXR0cmlidXRpb24ob3B0aW9uczogQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wuXHJcbmV4cG9ydCB2YXIgYXR0cmlidXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgQXR0cmlidXRpb24ob3B0aW9ucyk7XHJcbn07XHJcbiIsImltcG9ydCB7Q29udHJvbCwgY29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcbmltcG9ydCB7TGF5ZXJzLCBsYXllcnN9IGZyb20gJy4vQ29udHJvbC5MYXllcnMnO1xuaW1wb3J0IHtab29tLCB6b29tfSBmcm9tICcuL0NvbnRyb2wuWm9vbSc7XG5pbXBvcnQge1NjYWxlLCBzY2FsZX0gZnJvbSAnLi9Db250cm9sLlNjYWxlJztcbmltcG9ydCB7QXR0cmlidXRpb24sIGF0dHJpYnV0aW9ufSBmcm9tICcuL0NvbnRyb2wuQXR0cmlidXRpb24nO1xuXG5Db250cm9sLkxheWVycyA9IExheWVycztcbkNvbnRyb2wuWm9vbSA9IFpvb207XG5Db250cm9sLlNjYWxlID0gU2NhbGU7XG5Db250cm9sLkF0dHJpYnV0aW9uID0gQXR0cmlidXRpb247XG5cbmNvbnRyb2wubGF5ZXJzID0gbGF5ZXJzO1xuY29udHJvbC56b29tID0gem9vbTtcbmNvbnRyb2wuc2NhbGUgPSBzY2FsZTtcbmNvbnRyb2wuYXR0cmlidXRpb24gPSBhdHRyaWJ1dGlvbjtcblxuZXhwb3J0IHtDb250cm9sLCBjb250cm9sfTtcbiIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xuXG4vKlxuXHRMLkhhbmRsZXIgaXMgYSBiYXNlIGNsYXNzIGZvciBoYW5kbGVyIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5IHRvIGluamVjdFxuXHRpbnRlcmFjdGlvbiBmZWF0dXJlcyBsaWtlIGRyYWdnaW5nIHRvIGNsYXNzZXMgbGlrZSBNYXAgYW5kIE1hcmtlci5cbiovXG5cbi8vIEBjbGFzcyBIYW5kbGVyXG4vLyBAYWthIEwuSGFuZGxlclxuLy8gQWJzdHJhY3QgY2xhc3MgZm9yIG1hcCBpbnRlcmFjdGlvbiBoYW5kbGVyc1xuXG5leHBvcnQgdmFyIEhhbmRsZXIgPSBDbGFzcy5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlKCk6IHRoaXNcblx0Ly8gRW5hYmxlcyB0aGUgaGFuZGxlclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5hZGRIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpOiB0aGlzXG5cdC8vIERpc2FibGVzIHRoZSBoYW5kbGVyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblx0XHR0aGlzLnJlbW92ZUhvb2tzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGVkKCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZFxuXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZW5hYmxlZDtcblx0fVxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIENsYXNzZXMgaW5oZXJpdGluZyBmcm9tIGBIYW5kbGVyYCBtdXN0IGltcGxlbWVudCB0aGUgdHdvIGZvbGxvd2luZyBtZXRob2RzOlxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKClcblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCwgc2hvdWxkIGFkZCBldmVudCBob29rcy5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGRpc2FibGVkLCBzaG91bGQgcmVtb3ZlIHRoZSBldmVudCBob29rcyBhZGRlZCBwcmV2aW91c2x5LlxufSk7XG5cbi8vIEBzZWN0aW9uIFRoZXJlIGlzIHN0YXRpYyBmdW5jdGlvbiB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkhhbmRsZXI6XG4vLyBAZnVuY3Rpb24gYWRkVG8obWFwOiBNYXAsIG5hbWU6IFN0cmluZyk6IHRoaXNcbi8vIEFkZHMgYSBuZXcgSGFuZGxlciB0byB0aGUgZ2l2ZW4gbWFwIHdpdGggdGhlIGdpdmVuIG5hbWUuXG5IYW5kbGVyLmFkZFRvID0gZnVuY3Rpb24gKG1hcCwgbmFtZSkge1xuXHRtYXAuYWRkSGFuZGxlcihuYW1lLCB0aGlzKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuIiwiaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuL0Jyb3dzZXInO1xuZXhwb3J0IHtCcm93c2VyfTtcblxuZXhwb3J0IHtDbGFzc30gZnJvbSAnLi9DbGFzcyc7XG5cbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi9FdmVudHMnO1xuaW1wb3J0IHtFdmVudHN9IGZyb20gJy4vRXZlbnRzJztcbmV4cG9ydCB7RXZlbnRlZH07XG5leHBvcnQgdmFyIE1peGluID0ge0V2ZW50czogRXZlbnRzfTtcblxuZXhwb3J0IHtIYW5kbGVyfSBmcm9tICcuL0hhbmRsZXInO1xuXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XG5leHBvcnQge1V0aWx9O1xuZXhwb3J0IHtleHRlbmQsIGJpbmQsIHN0YW1wLCBzZXRPcHRpb25zfSBmcm9tICcuL1V0aWwnO1xuIiwiaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRHJhZ2dhYmxlXHJcbiAqIEBha2EgTC5EcmFnZ2FibGVcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogQSBjbGFzcyBmb3IgbWFraW5nIERPTSBlbGVtZW50cyBkcmFnZ2FibGUgKGluY2x1ZGluZyB0b3VjaCBzdXBwb3J0KS5cclxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBtYXAgYW5kIG1hcmtlciBkcmFnZ2luZy4gT25seSB3b3JrcyBmb3IgZWxlbWVudHNcclxuICogdGhhdCB3ZXJlIHBvc2l0aW9uZWQgd2l0aCBbYEwuRG9tVXRpbC5zZXRQb3NpdGlvbmBdKCNkb211dGlsLXNldHBvc2l0aW9uKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogdmFyIGRyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShlbGVtZW50VG9EcmFnKTtcclxuICogZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgU1RBUlQgPSBCcm93c2VyLnRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nO1xyXG52YXIgRU5EID0ge1xyXG5cdG1vdXNlZG93bjogJ21vdXNldXAnLFxyXG5cdHRvdWNoc3RhcnQ6ICd0b3VjaGVuZCcsXHJcblx0cG9pbnRlcmRvd246ICd0b3VjaGVuZCcsXHJcblx0TVNQb2ludGVyRG93bjogJ3RvdWNoZW5kJ1xyXG59O1xyXG52YXIgTU9WRSA9IHtcclxuXHRtb3VzZWRvd246ICdtb3VzZW1vdmUnLFxyXG5cdHRvdWNoc3RhcnQ6ICd0b3VjaG1vdmUnLFxyXG5cdHBvaW50ZXJkb3duOiAndG91Y2htb3ZlJyxcclxuXHRNU1BvaW50ZXJEb3duOiAndG91Y2htb3ZlJ1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydCB2YXIgRHJhZ2dhYmxlID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvblxyXG5cdFx0Ly8gQGFrYSBEcmFnZ2FibGUgb3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjbGlja1RvbGVyYW5jZTogTnVtYmVyID0gM1xyXG5cdFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgY2xpY2tcclxuXHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cclxuXHRcdGNsaWNrVG9sZXJhbmNlOiAzXHJcblx0fSxcclxuXHJcblx0Ly8gQGNvbnN0cnVjdG9yIEwuRHJhZ2dhYmxlKGVsOiBIVE1MRWxlbWVudCwgZHJhZ0hhbmRsZT86IEhUTUxFbGVtZW50LCBwcmV2ZW50T3V0bGluZT86IEJvb2xlYW4sIG9wdGlvbnM/OiBEcmFnZ2FibGUgb3B0aW9ucylcclxuXHQvLyBDcmVhdGVzIGEgYERyYWdnYWJsZWAgb2JqZWN0IGZvciBtb3ZpbmcgYGVsYCB3aGVuIHlvdSBzdGFydCBkcmFnZ2luZyB0aGUgYGRyYWdIYW5kbGVgIGVsZW1lbnQgKGVxdWFscyBgZWxgIGl0c2VsZiBieSBkZWZhdWx0KS5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZWxlbWVudCwgZHJhZ1N0YXJ0VGFyZ2V0LCBwcmV2ZW50T3V0bGluZSwgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG5cdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9wcmV2ZW50T3V0bGluZSA9IHByZXZlbnRPdXRsaW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZW5hYmxlKClcclxuXHQvLyBFbmFibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21FdmVudC5vbih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpXHJcblx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gSWYgd2UncmUgY3VycmVudGx5IGRyYWdnaW5nIHRoaXMgZHJhZ2dhYmxlLFxyXG5cdFx0Ly8gZGlzYWJsaW5nIGl0IGNvdW50cyBhcyBmaXJzdCBlbmRpbmcgdGhlIGRyYWcuXHJcblx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyA9PT0gdGhpcykge1xyXG5cdFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKERvbVV0aWwuaGFzQ2xhc3ModGhpcy5fZWxlbWVudCwgJ2xlYWZsZXQtem9vbS1hbmltJykpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgfHwgZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkgJiYgIWUudG91Y2hlcykpIHsgcmV0dXJuOyB9XHJcblx0XHREcmFnZ2FibGUuX2RyYWdnaW5nID0gdGhpczsgIC8vIFByZXZlbnQgZHJhZ2dpbmcgbXVsdGlwbGUgb2JqZWN0cyBhdCBvbmNlLlxyXG5cclxuXHRcdGlmICh0aGlzLl9wcmV2ZW50T3V0bGluZSkge1xyXG5cdFx0XHREb21VdGlsLnByZXZlbnRPdXRsaW5lKHRoaXMuX2VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0RG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZpbmcpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRvd246IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBpcyBhYm91dCB0byBzdGFydC5cclxuXHRcdHRoaXMuZmlyZSgnZG93bicpO1xyXG5cclxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXHJcblx0XHQgICAgc2l6ZWRQYXJlbnQgPSBEb21VdGlsLmdldFNpemVkUGFyZW50Tm9kZSh0aGlzLl9lbGVtZW50KTtcclxuXHJcblx0XHR0aGlzLl9zdGFydFBvaW50ID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xyXG5cclxuXHRcdC8vIENhY2hlIHRoZSBzY2FsZSwgc28gdGhhdCB3ZSBjYW4gY29udGludW91c2x5IGNvbXBlbnNhdGUgZm9yIGl0IGR1cmluZyBkcmFnIChfb25Nb3ZlKS5cclxuXHRcdHRoaXMuX3BhcmVudFNjYWxlID0gRG9tVXRpbC5nZXRTY2FsZShzaXplZFBhcmVudCk7XHJcblxyXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIE1PVkVbZS50eXBlXSwgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCBFTkRbZS50eXBlXSwgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmlyc3QgPSAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDEgPyBlLnRvdWNoZXNbMF0gOiBlKSxcclxuXHRcdCAgICBvZmZzZXQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSkuX3N1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybjsgfVxyXG5cdFx0aWYgKE1hdGguYWJzKG9mZnNldC54KSArIE1hdGguYWJzKG9mZnNldC55KSA8IHRoaXMub3B0aW9ucy5jbGlja1RvbGVyYW5jZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBXZSBhc3N1bWUgdGhhdCB0aGUgcGFyZW50IGNvbnRhaW5lcidzIHBvc2l0aW9uLCBib3JkZXIgYW5kIHNjYWxlIGRvIG5vdCBjaGFuZ2UgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZHJhZy5cclxuXHRcdC8vIFRoZXJlZm9yZSB0aGVyZSBpcyBubyBuZWVkIHRvIGFjY291bnQgZm9yIHRoZSBwb3NpdGlvbiBhbmQgYm9yZGVyICh0aGV5IGFyZSBlbGltaW5hdGVkIGJ5IHRoZSBzdWJ0cmFjdGlvbilcclxuXHRcdC8vIGFuZCB3ZSBjYW4gdXNlIHRoZSBjYWNoZWQgdmFsdWUgZm9yIHRoZSBzY2FsZS5cclxuXHRcdG9mZnNldC54IC89IHRoaXMuX3BhcmVudFNjYWxlLng7XHJcblx0XHRvZmZzZXQueSAvPSB0aGlzLl9wYXJlbnRTY2FsZS55O1xyXG5cclxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgc3RhcnRzXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblxyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHRoaXMuX3N0YXJ0UG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KS5zdWJ0cmFjdChvZmZzZXQpO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcclxuXHRcdFx0Ly8gSUUgYW5kIEVkZ2UgZG8gbm90IGdpdmUgdGhlIDx1c2U+IGVsZW1lbnQsIHNvIGZldGNoIGl0XHJcblx0XHRcdC8vIGlmIG5lY2Vzc2FyeVxyXG5cdFx0XHRpZiAoKHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UpICYmICh0aGlzLl9sYXN0VGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudEluc3RhbmNlKSkge1xyXG5cdFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSB0aGlzLl9sYXN0VGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xyXG5cdFx0XHR9XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9uZXdQb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcclxuXHRcdHRoaXMuX21vdmluZyA9IHRydWU7XHJcblxyXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fbGFzdEV2ZW50ID0gZTtcclxuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZVBvc2l0aW9uLCB0aGlzLCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBlID0ge29yaWdpbmFsRXZlbnQ6IHRoaXMuX2xhc3RFdmVudH07XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHByZWRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nICpiZWZvcmUqIGVhY2ggY29ycmVzcG9uZGluZ1xyXG5cdFx0Ly8gdXBkYXRlIG9mIHRoZSBlbGVtZW50J3MgcG9zaXRpb24uXHJcblx0XHR0aGlzLmZpcmUoJ3ByZWRyYWcnLCBlKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCwgdGhpcy5fbmV3UG9zKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcuXHJcblx0XHR0aGlzLmZpcmUoJ2RyYWcnLCBlKTtcclxuXHR9LFxyXG5cclxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHR9LFxyXG5cclxuXHRmaW5pc2hEcmFnOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpIGluIE1PVkUpIHtcclxuXHRcdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCBNT1ZFW2ldLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xyXG5cdFx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsIEVORFtpXSwgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcclxuXHRcdERvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZlZCAmJiB0aGlzLl9tb3ZpbmcpIHtcclxuXHRcdFx0Ly8gZW5zdXJlIGRyYWcgaXMgbm90IGZpcmVkIGFmdGVyIGRyYWdlbmRcclxuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBkcmFnIGVuZHMuXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ2VuZCcsIHtcclxuXHRcdFx0XHRkaXN0YW5jZTogdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmluZyA9IGZhbHNlO1xyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IGZhbHNlO1xyXG5cdH1cclxuXHJcbn0pO1xyXG4iLCJpbXBvcnQge1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGluZVV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWxpbmUgcG9pbnRzIHByb2Nlc3NpbmcsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIG1ha2UgcG9seWxpbmVzIGxpZ2h0bmluZy1mYXN0LlxyXG4gKi9cclxuXHJcbi8vIFNpbXBsaWZ5IHBvbHlsaW5lIHdpdGggdmVydGV4IHJlZHVjdGlvbiBhbmQgRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLlxyXG4vLyBJbXByb3ZlcyByZW5kZXJpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IGJ5IGxlc3NlbmluZyB0aGUgbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3LlxyXG5cclxuLy8gQGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50czogUG9pbnRbXSwgdG9sZXJhbmNlOiBOdW1iZXIpOiBQb2ludFtdXHJcbi8vIERyYW1hdGljYWxseSByZWR1Y2VzIHRoZSBudW1iZXIgb2YgcG9pbnRzIGluIGEgcG9seWxpbmUgd2hpbGUgcmV0YWluaW5nXHJcbi8vIGl0cyBzaGFwZSBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBzaW1wbGlmaWVkIHBvaW50cywgdXNpbmcgdGhlXHJcbi8vIFtEb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0pLlxyXG4vLyBVc2VkIGZvciBhIGh1Z2UgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiBwcm9jZXNzaW5nL2Rpc3BsYXlpbmcgTGVhZmxldCBwb2x5bGluZXMgZm9yXHJcbi8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuLy8gc2ltcGxpZmljYXRpb24gKGxlc3NlciB2YWx1ZSBtZWFucyBoaWdoZXIgcXVhbGl0eSBidXQgc2xvd2VyIGFuZCB3aXRoIG1vcmUgcG9pbnRzKS5cclxuLy8gQWxzbyByZWxlYXNlZCBhcyBhIHNlcGFyYXRlZCBtaWNyby1saWJyYXJ5IFtTaW1wbGlmeS5qc10oaHR0cDovL21vdXJuZXIuZ2l0aHViLmNvbS9zaW1wbGlmeS1qcy8pLlxyXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcclxuXHRpZiAoIXRvbGVyYW5jZSB8fCAhcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG5cdH1cclxuXHJcblx0dmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xyXG5cclxuXHQgICAgLy8gc3RhZ2UgMTogdmVydGV4IHJlZHVjdGlvblxyXG5cdCAgICBwb2ludHMgPSBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHQgICAgLy8gc3RhZ2UgMjogRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uXHJcblx0ICAgIHBvaW50cyA9IF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludCBgcGAgYW5kIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwMSwgcDIpIHtcclxuXHRyZXR1cm4gTWF0aC5zcXJ0KF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHRydWUpKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgY2xvc2VzdCBwb2ludCBmcm9tIGEgcG9pbnQgYHBgIG9uIGEgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG59XHJcblxyXG4vLyBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG1cclxuZnVuY3Rpb24gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuXHR2YXIgbGVuID0gcG9pbnRzLmxlbmd0aCxcclxuXHQgICAgQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSB1bmRlZmluZWQgKyAnJyA/IFVpbnQ4QXJyYXkgOiBBcnJheSxcclxuXHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG5cdCAgICBtYXJrZXJzWzBdID0gbWFya2Vyc1tsZW4gLSAxXSA9IDE7XHJcblxyXG5cdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCAwLCBsZW4gLSAxKTtcclxuXHJcblx0dmFyIGksXHJcblx0ICAgIG5ld1BvaW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGlmIChtYXJrZXJzW2ldKSB7XHJcblx0XHRcdG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3UG9pbnRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcclxuXHJcblx0dmFyIG1heFNxRGlzdCA9IDAsXHJcblx0aW5kZXgsIGksIHNxRGlzdDtcclxuXHJcblx0Zm9yIChpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3QgLSAxOyBpKyspIHtcclxuXHRcdHNxRGlzdCA9IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSwgdHJ1ZSk7XHJcblxyXG5cdFx0aWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xyXG5cdFx0XHRpbmRleCA9IGk7XHJcblx0XHRcdG1heFNxRGlzdCA9IHNxRGlzdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0bWFya2Vyc1tpbmRleF0gPSAxO1xyXG5cclxuXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG5cdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGluZGV4LCBsYXN0KTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIHJlZHVjZSBwb2ludHMgdGhhdCBhcmUgdG9vIGNsb3NlIHRvIGVhY2ggb3RoZXIgdG8gYSBzaW5nbGUgcG9pbnRcclxuZnVuY3Rpb24gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblx0dmFyIHJlZHVjZWRQb2ludHMgPSBbcG9pbnRzWzBdXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDEsIHByZXYgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGlmIChfc3FEaXN0KHBvaW50c1tpXSwgcG9pbnRzW3ByZXZdKSA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0XHRwcmV2ID0gaTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHByZXYgPCBsZW4gLSAxKSB7XHJcblx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2xlbiAtIDFdKTtcclxuXHR9XHJcblx0cmV0dXJuIHJlZHVjZWRQb2ludHM7XHJcbn1cclxuXHJcbnZhciBfbGFzdENvZGU7XHJcblxyXG4vLyBAZnVuY3Rpb24gY2xpcFNlZ21lbnQoYTogUG9pbnQsIGI6IFBvaW50LCBib3VuZHM6IEJvdW5kcywgdXNlTGFzdENvZGU/OiBCb29sZWFuLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdfEJvb2xlYW5cclxuLy8gQ2xpcHMgdGhlIHNlZ21lbnQgYSB0byBiIGJ5IHJlY3Rhbmd1bGFyIGJvdW5kcyB3aXRoIHRoZVxyXG4vLyBbQ29oZW4tU3V0aGVybGFuZCBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuJUUyJTgwJTkzU3V0aGVybGFuZF9hbGdvcml0aG0pXHJcbi8vIChtb2RpZnlpbmcgdGhlIHNlZ21lbnQgcG9pbnRzIGRpcmVjdGx5ISkuIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWxpbmVcclxuLy8gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZyBwZXJmb3JtYW5jZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBTZWdtZW50KGEsIGIsIGJvdW5kcywgdXNlTGFzdENvZGUsIHJvdW5kKSB7XHJcblx0dmFyIGNvZGVBID0gdXNlTGFzdENvZGUgPyBfbGFzdENvZGUgOiBfZ2V0Qml0Q29kZShhLCBib3VuZHMpLFxyXG5cdCAgICBjb2RlQiA9IF9nZXRCaXRDb2RlKGIsIGJvdW5kcyksXHJcblxyXG5cdCAgICBjb2RlT3V0LCBwLCBuZXdDb2RlO1xyXG5cclxuXHQgICAgLy8gc2F2ZSAybmQgY29kZSB0byBhdm9pZCBjYWxjdWxhdGluZyBpdCBvbiB0aGUgbmV4dCBzZWdtZW50XHJcblx0ICAgIF9sYXN0Q29kZSA9IGNvZGVCO1xyXG5cclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0Ly8gaWYgYSxiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgYWNjZXB0KVxyXG5cdFx0aWYgKCEoY29kZUEgfCBjb2RlQikpIHtcclxuXHRcdFx0cmV0dXJuIFthLCBiXTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBpZiBhLGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgcmVqZWN0KVxyXG5cdFx0aWYgKGNvZGVBICYgY29kZUIpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG90aGVyIGNhc2VzXHJcblx0XHRjb2RlT3V0ID0gY29kZUEgfHwgY29kZUI7XHJcblx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZU91dCwgYm91bmRzLCByb3VuZCk7XHJcblx0XHRuZXdDb2RlID0gX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHJcblx0XHRpZiAoY29kZU91dCA9PT0gY29kZUEpIHtcclxuXHRcdFx0YSA9IHA7XHJcblx0XHRcdGNvZGVBID0gbmV3Q29kZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGIgPSBwO1xyXG5cdFx0XHRjb2RlQiA9IG5ld0NvZGU7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZSwgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBkeCA9IGIueCAtIGEueCxcclxuXHQgICAgZHkgPSBiLnkgLSBhLnksXHJcblx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcblx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0ICAgIHgsIHk7XHJcblxyXG5cdGlmIChjb2RlICYgOCkgeyAvLyB0b3BcclxuXHRcdHggPSBhLnggKyBkeCAqIChtYXgueSAtIGEueSkgLyBkeTtcclxuXHRcdHkgPSBtYXgueTtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgNCkgeyAvLyBib3R0b21cclxuXHRcdHggPSBhLnggKyBkeCAqIChtaW4ueSAtIGEueSkgLyBkeTtcclxuXHRcdHkgPSBtaW4ueTtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMikgeyAvLyByaWdodFxyXG5cdFx0eCA9IG1heC54O1xyXG5cdFx0eSA9IGEueSArIGR5ICogKG1heC54IC0gYS54KSAvIGR4O1xyXG5cclxuXHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7IC8vIGxlZnRcclxuXHRcdHggPSBtaW4ueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtaW4ueCAtIGEueCkgLyBkeDtcclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2dldEJpdENvZGUocCwgYm91bmRzKSB7XHJcblx0dmFyIGNvZGUgPSAwO1xyXG5cclxuXHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuXHRcdGNvZGUgfD0gMTtcclxuXHR9IGVsc2UgaWYgKHAueCA+IGJvdW5kcy5tYXgueCkgeyAvLyByaWdodFxyXG5cdFx0Y29kZSB8PSAyO1xyXG5cdH1cclxuXHJcblx0aWYgKHAueSA8IGJvdW5kcy5taW4ueSkgeyAvLyBib3R0b21cclxuXHRcdGNvZGUgfD0gNDtcclxuXHR9IGVsc2UgaWYgKHAueSA+IGJvdW5kcy5tYXgueSkgeyAvLyB0b3BcclxuXHRcdGNvZGUgfD0gODtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb2RlO1xyXG59XHJcblxyXG4vLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuZnVuY3Rpb24gX3NxRGlzdChwMSwgcDIpIHtcclxuXHR2YXIgZHggPSBwMi54IC0gcDEueCxcclxuXHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuXHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG5leHBvcnQgZnVuY3Rpb24gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgc3FEaXN0KSB7XHJcblx0dmFyIHggPSBwMS54LFxyXG5cdCAgICB5ID0gcDEueSxcclxuXHQgICAgZHggPSBwMi54IC0geCxcclxuXHQgICAgZHkgPSBwMi55IC0geSxcclxuXHQgICAgZG90ID0gZHggKiBkeCArIGR5ICogZHksXHJcblx0ICAgIHQ7XHJcblxyXG5cdGlmIChkb3QgPiAwKSB7XHJcblx0XHR0ID0gKChwLnggLSB4KSAqIGR4ICsgKHAueSAtIHkpICogZHkpIC8gZG90O1xyXG5cclxuXHRcdGlmICh0ID4gMSkge1xyXG5cdFx0XHR4ID0gcDIueDtcclxuXHRcdFx0eSA9IHAyLnk7XHJcblx0XHR9IGVsc2UgaWYgKHQgPiAwKSB7XHJcblx0XHRcdHggKz0gZHggKiB0O1xyXG5cdFx0XHR5ICs9IGR5ICogdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGR4ID0gcC54IC0geDtcclxuXHRkeSA9IHAueSAtIHk7XHJcblxyXG5cdHJldHVybiBzcURpc3QgPyBkeCAqIGR4ICsgZHkgKiBkeSA6IG5ldyBQb2ludCh4LCB5KTtcclxufVxyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBpc0ZsYXQobGF0bG5nczogTGF0TG5nW10pOiBCb29sZWFuXHJcbi8vIFJldHVybnMgdHJ1ZSBpZiBgbGF0bG5nc2AgaXMgYSBmbGF0IGFycmF5LCBmYWxzZSBpcyBuZXN0ZWQuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ZsYXQobGF0bG5ncykge1xyXG5cdHJldHVybiAhVXRpbC5pc0FycmF5KGxhdGxuZ3NbMF0pIHx8ICh0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICd1bmRlZmluZWQnKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9mbGF0KGxhdGxuZ3MpIHtcclxuXHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgdXNlIG9mIF9mbGF0LCBwbGVhc2UgdXNlIEwuTGluZVV0aWwuaXNGbGF0IGluc3RlYWQuJyk7XHJcblx0cmV0dXJuIGlzRmxhdChsYXRsbmdzKTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuL0xpbmVVdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUG9seVV0aWxcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gKi9cclxuXHJcbi8qIEBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHM6IFBvaW50W10sIGJvdW5kczogQm91bmRzLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdXHJcbiAqIENsaXBzIHRoZSBwb2x5Z29uIGdlb21ldHJ5IGRlZmluZWQgYnkgdGhlIGdpdmVuIGBwb2ludHNgIGJ5IHRoZSBnaXZlbiBib3VuZHMgKHVzaW5nIHRoZSBbU3V0aGVybGFuZC1Ib2RnbWFuIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtKSkuXHJcbiAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAqIHBlcmZvcm1hbmNlLiBOb3RlIHRoYXQgcG9seWdvbiBwb2ludHMgbmVlZHMgZGlmZmVyZW50IGFsZ29yaXRobSBmb3IgY2xpcHBpbmdcclxuICogdGhhbiBwb2x5bGluZSwgc28gdGhlcmUncyBhIHNlcGFyYXRlIG1ldGhvZCBmb3IgaXQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzLCBib3VuZHMsIHJvdW5kKSB7XHJcblx0dmFyIGNsaXBwZWRQb2ludHMsXHJcblx0ICAgIGVkZ2VzID0gWzEsIDQsIDIsIDhdLFxyXG5cdCAgICBpLCBqLCBrLFxyXG5cdCAgICBhLCBiLFxyXG5cdCAgICBsZW4sIGVkZ2UsIHA7XHJcblxyXG5cdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0cG9pbnRzW2ldLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocG9pbnRzW2ldLCBib3VuZHMpO1xyXG5cdH1cclxuXHJcblx0Ly8gZm9yIGVhY2ggZWRnZSAobGVmdCwgYm90dG9tLCByaWdodCwgdG9wKVxyXG5cdGZvciAoayA9IDA7IGsgPCA0OyBrKyspIHtcclxuXHRcdGVkZ2UgPSBlZGdlc1trXTtcclxuXHRcdGNsaXBwZWRQb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG5cdFx0XHRhID0gcG9pbnRzW2ldO1xyXG5cdFx0XHRiID0gcG9pbnRzW2pdO1xyXG5cclxuXHRcdFx0Ly8gaWYgYSBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93XHJcblx0XHRcdGlmICghKGEuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdC8vIGlmIGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZ29lcyBvdXQgb2Ygc2NyZWVuKVxyXG5cdFx0XHRcdGlmIChiLl9jb2RlICYgZWRnZSkge1xyXG5cdFx0XHRcdFx0cCA9IExpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdFx0cC5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblx0XHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChhKTtcclxuXHJcblx0XHRcdC8vIGVsc2UgaWYgYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGVudGVycyB0aGUgc2NyZWVuKVxyXG5cdFx0XHR9IGVsc2UgaWYgKCEoYi5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0cCA9IExpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdHAuX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cG9pbnRzID0gY2xpcHBlZFBvaW50cztcclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn1cclxuIiwiaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHNlY3Rpb25cclxuICogTGVhZmxldCBjb21lcyB3aXRoIGEgc2V0IG9mIGFscmVhZHkgZGVmaW5lZCBQcm9qZWN0aW9ucyBvdXQgb2YgdGhlIGJveDpcclxuICpcclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLkxvbkxhdFxyXG4gKlxyXG4gKiBFcXVpcmVjdGFuZ3VsYXIsIG9yIFBsYXRlIENhcnJlZSBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBzaW1wbGUgcHJvamVjdGlvbixcclxuICogbW9zdGx5IHVzZWQgYnkgR0lTIGVudGh1c2lhc3RzLiBEaXJlY3RseSBtYXBzIGB4YCBhcyBsb25naXR1ZGUsIGFuZCBgeWAgYXNcclxuICogbGF0aXR1ZGUuIEFsc28gc3VpdGFibGUgZm9yIGZsYXQgd29ybGRzLCBlLmcuIGdhbWUgbWFwcy4gVXNlZCBieSB0aGVcclxuICogYEVQU0c6NDMyNmAgYW5kIGBTaW1wbGVgIENSUy5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIExvbkxhdCA9IHtcclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGxhdGxuZy5sbmcsIGxhdGxuZy5sYXQpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhwb2ludC55LCBwb2ludC54KTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IG5ldyBCb3VuZHMoWy0xODAsIC05MF0sIFsxODAsIDkwXSlcclxufTtcclxuIiwiaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLk1lcmNhdG9yXHJcbiAqXHJcbiAqIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgbW9yZSBjb21wbGV4IHRoYW4gU3BoZXJpY2FsIE1lcmNhdG9yLiBBc3N1bWVzIHRoYXQgRWFydGggaXMgYW4gZWxsaXBzb2lkLiBVc2VkIGJ5IHRoZSBFUFNHOjMzOTUgQ1JTLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWVyY2F0b3IgPSB7XHJcblx0UjogNjM3ODEzNyxcclxuXHRSX01JTk9SOiA2MzU2NzUyLjMxNDI0NTE3OSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMjAwMzc1MDguMzQyNzksIC0xNTQ5NjU3MC43Mzk3Ml0sIFsyMDAzNzUwOC4zNDI3OSwgMTg3NjQ2NTYuMjMxMzhdKSxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgeSA9IGxhdGxuZy5sYXQgKiBkLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICBjb24gPSBlICogTWF0aC5zaW4oeSk7XHJcblxyXG5cdFx0dmFyIHRzID0gTWF0aC50YW4oTWF0aC5QSSAvIDQgLSB5IC8gMikgLyBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdHkgPSAtciAqIE1hdGgubG9nKE1hdGgubWF4KHRzLCAxRS0xMCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZyAqIGQgKiByLCB5KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIHRzID0gTWF0aC5leHAoLXBvaW50LnkgLyByKSxcclxuXHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBkcGhpID0gMC4xLCBjb247IGkgPCAxNSAmJiBNYXRoLmFicyhkcGhpKSA+IDFlLTc7IGkrKykge1xyXG5cdFx0XHRjb24gPSBlICogTWF0aC5zaW4ocGhpKTtcclxuXHRcdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHRcdGRwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMgKiBjb24pIC0gcGhpO1xyXG5cdFx0XHRwaGkgKz0gZHBoaTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhwaGkgKiBkLCBwb2ludC54ICogZCAvIHIpO1xyXG5cdH1cclxufTtcclxuIiwiLypcbiAqIEBjbGFzcyBQcm9qZWN0aW9uXG5cbiAqIEFuIG9iamVjdCB3aXRoIG1ldGhvZHMgZm9yIHByb2plY3RpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBvbnRvXG4gKiBhIGZsYXQgc3VyZmFjZSAoYW5kIGJhY2spLiBTZWUgW01hcCBwcm9qZWN0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcF9wcm9qZWN0aW9uKS5cblxuICogQHByb3BlcnR5IGJvdW5kczogQm91bmRzXG4gKiBUaGUgYm91bmRzIChzcGVjaWZpZWQgaW4gQ1JTIHVuaXRzKSB3aGVyZSB0aGUgcHJvamVjdGlvbiBpcyB2YWxpZFxuXG4gKiBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxuICogUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gYSAyRCBwb2ludC5cbiAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAqIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xuICogVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLiBQcm9qZWN0cyBhIDJEIHBvaW50IGludG8gYSBnZW9ncmFwaGljYWwgbG9jYXRpb24uXG4gKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAqIE5vdGUgdGhhdCB0aGUgcHJvamVjdGlvbiBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmZXQncyBgQ2xhc3NgIG9iamVjdCxcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxuICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXG5cbiAqL1xuXG5leHBvcnQge0xvbkxhdH0gZnJvbSAnLi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5leHBvcnQge01lcmNhdG9yfSBmcm9tICcuL1Byb2plY3Rpb24uTWVyY2F0b3InO1xuZXhwb3J0IHtTcGhlcmljYWxNZXJjYXRvcn0gZnJvbSAnLi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yJztcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtNZXJjYXRvcn0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLk1lcmNhdG9yJztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzMzOTVcclxuICpcclxuICogUmFyZWx5IHVzZWQgYnkgc29tZSBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBVc2VzIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICovXHJcbmV4cG9ydCB2YXIgRVBTRzMzOTUgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuXHRwcm9qZWN0aW9uOiBNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtMb25MYXR9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQnO1xyXG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHNDMyNlxyXG4gKlxyXG4gKiBBIGNvbW1vbiBDUlMgYW1vbmcgR0lTIGVudGh1c2lhc3RzLiBVc2VzIHNpbXBsZSBFcXVpcmVjdGFuZ3VsYXIgcHJvamVjdGlvbi5cclxuICpcclxuICogTGVhZmxldCAxLjAueCBjb21wbGllcyB3aXRoIHRoZSBbVE1TIGNvb3JkaW5hdGUgc2NoZW1lIGZvciBFUFNHOjQzMjZdKGh0dHBzOi8vd2lraS5vc2dlby5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlX1NwZWNpZmljYXRpb24jZ2xvYmFsLWdlb2RldGljKSxcclxuICogd2hpY2ggaXMgYSBicmVha2luZyBjaGFuZ2UgZnJvbSAwLjcueCBiZWhhdmlvdXIuICBJZiB5b3UgYXJlIHVzaW5nIGEgYFRpbGVMYXllcmBcclxuICogd2l0aCB0aGlzIENSUywgZW5zdXJlIHRoYXQgdGhlcmUgYXJlIHR3byAyNTZ4MjU2IHBpeGVsIHRpbGVzIGNvdmVyaW5nIHRoZVxyXG4gKiB3aG9sZSBlYXJ0aCBhdCB6b29tIGxldmVsIHplcm8sIGFuZCB0aGF0IHRoZSB0aWxlIGNvb3JkaW5hdGUgb3JpZ2luIGlzICgtMTgwLCs5MCksXHJcbiAqIG9yICgtMTgwLC05MCkgZm9yIGBUaWxlTGF5ZXJgcyB3aXRoIFt0aGUgYHRtc2Agb3B0aW9uXSgjdGlsZWxheWVyLXRtcykgc2V0LlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRVBTRzQzMjYgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzo0MzI2JyxcclxuXHRwcm9qZWN0aW9uOiBMb25MYXQsXHJcblx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSAvIDE4MCwgMSwgLTEgLyAxODAsIDAuNSlcclxufSk7XHJcbiIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0xvbkxhdH0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICpcbiAqIEEgc2ltcGxlIENSUyB0aGF0IG1hcHMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBpbnRvIGB4YCBhbmQgYHlgIGRpcmVjdGx5LlxuICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICogYXhpcyBzaG91bGQgc3RpbGwgYmUgaW52ZXJ0ZWQgKGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCkuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBzaW1wbGUgZXVjbGlkZWFuIGRpc3RhbmNlLlxuICovXG5cbmV4cG9ydCB2YXIgU2ltcGxlID0gVXRpbC5leHRlbmQoe30sIENSUywge1xuXHRwcm9qZWN0aW9uOiBMb25MYXQsXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG5cdH0sXG5cblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yO1xuXHR9LFxuXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciBkeCA9IGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcsXG5cdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHR9LFxuXG5cdGluZmluaXRlOiB0cnVlXG59KTtcbiIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XG5pbXBvcnQge0VQU0czMzk1fSBmcm9tICcuL0NSUy5FUFNHMzM5NSc7XG5pbXBvcnQge0VQU0czODU3LCBFUFNHOTAwOTEzfSBmcm9tICcuL0NSUy5FUFNHMzg1Nyc7XG5pbXBvcnQge0VQU0c0MzI2fSBmcm9tICcuL0NSUy5FUFNHNDMyNic7XG5pbXBvcnQge1NpbXBsZX0gZnJvbSAnLi9DUlMuU2ltcGxlJztcblxuQ1JTLkVhcnRoID0gRWFydGg7XG5DUlMuRVBTRzMzOTUgPSBFUFNHMzM5NTtcbkNSUy5FUFNHMzg1NyA9IEVQU0czODU3O1xuQ1JTLkVQU0c5MDA5MTMgPSBFUFNHOTAwOTEzO1xuQ1JTLkVQU0c0MzI2ID0gRVBTRzQzMjY7XG5DUlMuU2ltcGxlID0gU2ltcGxlO1xuXG5leHBvcnQge0NSU307XG4iLCJpbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBMYXllclxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIEBha2EgTC5MYXllclxuICogQGFrYSBJTGF5ZXJcbiAqXG4gKiBBIHNldCBvZiBtZXRob2RzIGZyb20gdGhlIExheWVyIGJhc2UgY2xhc3MgdGhhdCBhbGwgTGVhZmxldCBsYXllcnMgdXNlLlxuICogSW5oZXJpdHMgYWxsIG1ldGhvZHMsIG9wdGlvbnMgYW5kIGV2ZW50cyBmcm9tIGBMLkV2ZW50ZWRgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwubWFya2VyKGxhdGxuZykuYWRkVG8obWFwKTtcbiAqIGxheWVyLmFkZFRvKG1hcCk7XG4gKiBsYXllci5yZW1vdmUoKTtcbiAqIGBgYFxuICpcbiAqIEBldmVudCBhZGQ6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gYSBtYXBcbiAqXG4gKiBAZXZlbnQgcmVtb3ZlOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIG1hcFxuICovXG5cblxuZXhwb3J0IHZhciBMYXllciA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ292ZXJsYXlQYW5lJ1xuXHRcdC8vIEJ5IGRlZmF1bHQgdGhlIGxheWVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCdzIFtvdmVybGF5IHBhbmVdKCNtYXAtb3ZlcmxheXBhbmUpLiBPdmVycmlkaW5nIHRoaXMgb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGxheWVyIHRvIGJlIHBsYWNlZCBvbiBhbm90aGVyIHBhbmUgYnkgZGVmYXVsdC5cblx0XHRwYW5lOiAnb3ZlcmxheVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxuXHRcdC8vIFN0cmluZyB0byBiZSBzaG93biBpbiB0aGUgYXR0cmlidXRpb24gY29udHJvbCwgZS5nLiBcIsKpIE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzXCIuIEl0IGRlc2NyaWJlcyB0aGUgbGF5ZXIgZGF0YSBhbmQgaXMgb2Z0ZW4gYSBsZWdhbCBvYmxpZ2F0aW9uIHRvd2FyZHMgY29weXJpZ2h0IGhvbGRlcnMgYW5kIHRpbGUgcHJvdmlkZXJzLlxuXHRcdGF0dHJpYnV0aW9uOiBudWxsLFxuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdC8qIEBzZWN0aW9uXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZFRvKG1hcDogTWFwfExheWVyR3JvdXApOiB0aGlzXG5cdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXAgb3IgbGF5ZXIgZ3JvdXAuXG5cdCAqL1xuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShtYXA6IE1hcCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG5cdHJlbW92ZUZyb206IGZ1bmN0aW9uIChvYmopIHtcblx0XHRpZiAob2JqKSB7XG5cdFx0XHRvYmoucmVtb3ZlTGF5ZXIodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShuYW1lPyA6IFN0cmluZyk6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgcmVwcmVzZW50aW5nIHRoZSBuYW1lZCBwYW5lIG9uIHRoZSBtYXAuIElmIGBuYW1lYCBpcyBvbWl0dGVkLCByZXR1cm5zIHRoZSBwYW5lIGZvciB0aGlzIGxheWVyLlxuXHRnZXRQYW5lOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZShuYW1lID8gKHRoaXMub3B0aW9uc1tuYW1lXSB8fCBuYW1lKSA6IHRoaXMub3B0aW9ucy5wYW5lKTtcblx0fSxcblxuXHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0dGhpcy5fbWFwLl90YXJnZXRzW1V0aWwuc3RhbXAodGFyZ2V0RWwpXSA9IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdGRlbGV0ZSB0aGlzLl9tYXAuX3RhcmdldHNbVXRpbC5zdGFtcCh0YXJnZXRFbCldO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0QXR0cmlidXRpb246IFN0cmluZ1xuXHQvLyBVc2VkIGJ5IHRoZSBgYXR0cmlidXRpb24gY29udHJvbGAsIHJldHVybnMgdGhlIFthdHRyaWJ1dGlvbiBvcHRpb25dKCNncmlkbGF5ZXItYXR0cmlidXRpb24pLlxuXHRnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG5cdH0sXG5cblx0X2xheWVyQWRkOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSBlLnRhcmdldDtcblxuXHRcdC8vIGNoZWNrIGluIGNhc2UgbGF5ZXIgZ2V0cyBhZGRlZCBhbmQgdGhlbiByZW1vdmVkIGJlZm9yZSB0aGUgbWFwIGlzIHJlYWR5XG5cdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XG5cblx0XHRpZiAodGhpcy5nZXRFdmVudHMpIHtcblx0XHRcdHZhciBldmVudHMgPSB0aGlzLmdldEV2ZW50cygpO1xuXHRcdFx0bWFwLm9uKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR0aGlzLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bWFwLm9mZihldmVudHMsIHRoaXMpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbkFkZChtYXApO1xuXG5cdFx0aWYgKHRoaXMuZ2V0QXR0cmlidXRpb24gJiYgbWFwLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuXHRcdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbC5hZGRBdHRyaWJ1dGlvbih0aGlzLmdldEF0dHJpYnV0aW9uKCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuZmlyZSgnYWRkJyk7XG5cdFx0bWFwLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiB0aGlzfSk7XG5cdH1cbn0pO1xuXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICogQHVuaW5oZXJpdGFibGVcbiAqXG4gKiBFdmVyeSBsYXllciBzaG91bGQgZXh0ZW5kIGZyb20gYEwuTGF5ZXJgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXG4gKlxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGNvZGUgdGhhdCBjcmVhdGVzIERPTSBlbGVtZW50cyBmb3IgdGhlIGxheWVyLCBhZGRzIHRoZW0gdG8gYG1hcCBwYW5lc2Agd2hlcmUgdGhleSBzaG91bGQgYmVsb25nIGFuZCBwdXRzIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllcikuXG4gKlxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGF5ZXIncyBlbGVtZW50cyBmcm9tIHRoZSBET00gYW5kIHJlbW92ZXMgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNsYXllci1vbmFkZCkuIENhbGxlZCBvbiBbYG1hcC5yZW1vdmVMYXllcihsYXllcilgXSgjbWFwLXJlbW92ZWxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIGdldEV2ZW50cygpOiBPYmplY3RcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGxpa2UgYHsgdmlld3Jlc2V0OiB0aGlzLl9yZXNldCB9YCBmb3IgW2BhZGRFdmVudExpc3RlbmVyYF0oI2V2ZW50ZWQtYWRkZXZlbnRsaXN0ZW5lcikuIFRoZSBldmVudCBoYW5kbGVycyBpbiB0aGlzIG9iamVjdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgbWFwIHdpdGggeW91ciBsYXllci5cbiAqXG4gKiBAbWV0aG9kIGdldEF0dHJpYnV0aW9uKCk6IFN0cmluZ1xuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYCB3aGVuZXZlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGJlZm9yZUFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIE9wdGlvbmFsIG1ldGhvZC4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLCBiZWZvcmUgdGhlIGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAsIGJlZm9yZSBldmVudHMgYXJlIGluaXRpYWxpemVkLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlIG1hcCBpcyBpbiBhIHVzYWJsZSBzdGF0ZS4gVXNlIGZvciBlYXJseSBpbml0aWFsaXphdGlvbiBvbmx5LlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXBcbiAqIEBzZWN0aW9uIExheWVyIGV2ZW50c1xuICpcbiAqIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBhIG5ldyBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLlxuICpcbiAqIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBzb21lIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gKlxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuICovXG5NYXAuaW5jbHVkZSh7XG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgbWFwXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIWxheWVyLl9sYXllckFkZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIExheWVyLicpO1xuXHRcdH1cblxuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG5cdFx0bGF5ZXIuX21hcFRvQWRkID0gdGhpcztcblxuXHRcdGlmIChsYXllci5iZWZvcmVBZGQpIHtcblx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLndoZW5SZWFkeShsYXllci5fbGF5ZXJBZGQsIGxheWVyKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICghdGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLmdldEF0dHJpYnV0aW9uICYmIHRoaXMuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHR0aGlzLmF0dHJpYnV0aW9uQ29udHJvbC5yZW1vdmVBdHRyaWJ1dGlvbihsYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcblx0XHR9XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XG5cdFx0XHRsYXllci5maXJlKCdyZW1vdmUnKTtcblx0XHR9XG5cblx0XHRsYXllci5fbWFwID0gbGF5ZXIuX21hcFRvQWRkID0gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBtYXBcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHJldHVybiAhIWxheWVyICYmIChVdGlsLnN0YW1wKGxheWVyKSBpbiB0aGlzLl9sYXllcnMpO1xuXHR9LFxuXG5cdC8qIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcblx0ICogSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBtYXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cblx0ICogYGBgXG5cdCAqIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpe1xuXHQgKiAgICAgbGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xuXHQgKiB9KTtcblx0ICogYGBgXG5cdCAqL1xuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2FkZExheWVyczogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdGxheWVycyA9IGxheWVycyA/IChVdGlsLmlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVpvb21MZXZlbHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWluWm9vbSA9IEluZmluaXR5LFxuXHRcdCAgICBtYXhab29tID0gLUluZmluaXR5LFxuXHRcdCAgICBvbGRab29tU3BhbiA9IHRoaXMuX2dldFpvb21TcGFuKCk7XG5cblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3pvb21Cb3VuZExheWVycykge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl96b29tQm91bmRMYXllcnNbaV0ub3B0aW9ucztcblxuXHRcdFx0bWluWm9vbSA9IG9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gbWluWm9vbSA6IE1hdGgubWluKG1pblpvb20sIG9wdGlvbnMubWluWm9vbSk7XG5cdFx0XHRtYXhab29tID0gb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgPyBtYXhab29tIDogTWF0aC5tYXgobWF4Wm9vbSwgb3B0aW9ucy5tYXhab29tKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sYXllcnNNYXhab29tID0gbWF4Wm9vbSA9PT0gLUluZmluaXR5ID8gdW5kZWZpbmVkIDogbWF4Wm9vbTtcblx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbSA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtaW5ab29tO1xuXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcblx0XHQvLyBAZXZlbnQgem9vbWxldmVsc2NoYW5nZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBudW1iZXIgb2Ygem9vbWxldmVscyBvbiB0aGUgbWFwIGlzIGNoYW5nZWQgZHVlXG5cdFx0Ly8gdG8gYWRkaW5nIG9yIHJlbW92aW5nIGEgbGF5ZXIuXG5cdFx0aWYgKG9sZFpvb21TcGFuICE9PSB0aGlzLl9nZXRab29tU3BhbigpKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNYXhab29tICYmIHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5fbGF5ZXJzTWF4Wm9vbSkge1xuXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01heFpvb20pO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNaW5ab29tICYmIHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5fbGF5ZXJzTWluWm9vbSkge1xuXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01pblpvb20pO1xuXHRcdH1cblx0fVxufSk7XG4iLCJcclxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBMYXllckdyb3VwXHJcbiAqIEBha2EgTC5MYXllckdyb3VwXHJcbiAqIEBpbmhlcml0cyBMYXllclxyXG4gKlxyXG4gKiBVc2VkIHRvIGdyb3VwIHNldmVyYWwgbGF5ZXJzIGFuZCBoYW5kbGUgdGhlbSBhcyBvbmUuIElmIHlvdSBhZGQgaXQgdG8gdGhlIG1hcCxcclxuICogYW55IGxheWVycyBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGdyb3VwIHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBvbiB0aGUgbWFwIGFzXHJcbiAqIHdlbGwuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5sYXllckdyb3VwKFttYXJrZXIxLCBtYXJrZXIyXSlcclxuICogXHQuYWRkTGF5ZXIocG9seWxpbmUpXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTGF5ZXJHcm91cCA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHR2YXIgaSwgbGVuO1xyXG5cclxuXHRcdGlmIChsYXllcnMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIGdyb3VwLlxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBncm91cC5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGlkOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgZnJvbSB0aGUgZ3JvdXAuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gbGF5ZXIgaW4gdGhpcy5fbGF5ZXJzID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fbGF5ZXJzW2lkXSkge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2lkXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBoYXNMYXllcihpZDogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHJldHVybiAhIWxheWVyICYmIChsYXllciBpbiB0aGlzLl9sYXllcnMgfHwgdGhpcy5nZXRMYXllcklkKGxheWVyKSBpbiB0aGlzLl9sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xlYXJMYXllcnMoKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYWxsIHRoZSBsYXllcnMgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlbW92ZUxheWVyLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludm9rZShtZXRob2ROYW1lOiBTdHJpbmcsIOKApik6IHRoaXNcclxuXHQvLyBDYWxscyBgbWV0aG9kTmFtZWAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgYW55XHJcblx0Ly8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBsYXllcnMgY29udGFpbmVkIGRvIG5vdFxyXG5cdC8vIGltcGxlbWVudCBgbWV0aG9kTmFtZWAuXHJcblx0aW52b2tlOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG5cdFx0ICAgIGksIGxheWVyO1xyXG5cclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaV07XHJcblxyXG5cdFx0XHRpZiAobGF5ZXJbbWV0aG9kTmFtZV0pIHtcclxuXHRcdFx0XHRsYXllclttZXRob2ROYW1lXS5hcHBseShsYXllciwgYXJncyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobWFwLmFkZExheWVyLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcihtYXAucmVtb3ZlTGF5ZXIsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgZ3JvdXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cclxuXHQvLyBgYGBqc1xyXG5cdC8vIGdyb3VwLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHQvLyBcdGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcclxuXHQvLyB9KTtcclxuXHQvLyBgYGBcclxuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVyKGlkOiBOdW1iZXIpOiBMYXllclxyXG5cdC8vIFJldHVybnMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElELlxyXG5cdGdldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJzKCk6IExheWVyW11cclxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbGF5ZXJzIGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuZWFjaExheWVyKGxheWVycy5wdXNoLCBsYXllcnMpO1xyXG5cdFx0cmV0dXJuIGxheWVycztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDYWxscyBgc2V0WkluZGV4YCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyB0aGUgei1pbmRleC5cclxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0WkluZGV4JywgekluZGV4KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVySWQobGF5ZXI6IExheWVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgaW50ZXJuYWwgSUQgZm9yIGEgbGF5ZXJcclxuXHRnZXRMYXllcklkOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHJldHVybiBVdGlsLnN0YW1wKGxheWVyKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF5ZXJHcm91cChsYXllcnM/OiBMYXllcltdLCBvcHRpb25zPzogT2JqZWN0KVxyXG4vLyBDcmVhdGUgYSBsYXllciBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbmV4cG9ydCB2YXIgbGF5ZXJHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IExheWVyR3JvdXAobGF5ZXJzLCBvcHRpb25zKTtcclxufTtcclxuIiwiaW1wb3J0IHtMYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xyXG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRmVhdHVyZUdyb3VwXHJcbiAqIEBha2EgTC5GZWF0dXJlR3JvdXBcclxuICogQGluaGVyaXRzIExheWVyR3JvdXBcclxuICpcclxuICogRXh0ZW5kZWQgYExheWVyR3JvdXBgIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIGRvIHRoZSBzYW1lIHRoaW5nIHRvIGFsbCBpdHMgbWVtYmVyIGxheWVyczpcclxuICogICogW2BiaW5kUG9wdXBgXSgjbGF5ZXItYmluZHBvcHVwKSBiaW5kcyBhIHBvcHVwIHRvIGFsbCBvZiB0aGUgbGF5ZXJzIGF0IG9uY2UgKGxpa2V3aXNlIHdpdGggW2BiaW5kVG9vbHRpcGBdKCNsYXllci1iaW5kdG9vbHRpcCkpXHJcbiAqICAqIEV2ZW50cyBhcmUgcHJvcGFnYXRlZCB0byB0aGUgYEZlYXR1cmVHcm91cGAsIHNvIGlmIHRoZSBncm91cCBoYXMgYW4gZXZlbnRcclxuICogaGFuZGxlciwgaXQgd2lsbCBoYW5kbGUgZXZlbnRzIGZyb20gYW55IG9mIHRoZSBsYXllcnMuIFRoaXMgaW5jbHVkZXMgbW91c2UgZXZlbnRzXHJcbiAqIGFuZCBjdXN0b20gZXZlbnRzLlxyXG4gKiAgKiBIYXMgYGxheWVyYWRkYCBhbmQgYGxheWVycmVtb3ZlYCBldmVudHNcclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5mZWF0dXJlR3JvdXAoW21hcmtlcjEsIG1hcmtlcjIsIHBvbHlsaW5lXSlcclxuICogXHQuYmluZFBvcHVwKCdIZWxsbyB3b3JsZCEnKVxyXG4gKiBcdC5vbignY2xpY2snLCBmdW5jdGlvbigpIHsgYWxlcnQoJ0NsaWNrZWQgb24gYSBtZW1iZXIgb2YgdGhlIGdyb3VwIScpOyB9KVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEZlYXR1cmVHcm91cCA9IExheWVyR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdExheWVyR3JvdXAucHJvdG90eXBlLmFkZExheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIGFkZGVkIHRvIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICghdGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2xheWVyXTtcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5yZW1vdmVFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMYXllckdyb3VwLnByb3RvdHlwZS5yZW1vdmVMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGdpdmVuIHBhdGggb3B0aW9ucyB0byBlYWNoIGxheWVyIG9mIHRoZSBncm91cCB0aGF0IGhhcyBhIGBzZXRTdHlsZWAgbWV0aG9kLlxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0U3R5bGUnLCBzdHlsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIHRvcCBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9Gcm9udCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIGJhY2sgb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9CYWNrJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgTGF0TG5nQm91bmRzIG9mIHRoZSBGZWF0dXJlIEdyb3VwIChjcmVhdGVkIGZyb20gYm91bmRzIGFuZCBjb29yZGluYXRlcyBvZiBpdHMgY2hpbGRyZW4pLlxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcclxuXHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHRcdFx0Ym91bmRzLmV4dGVuZChsYXllci5nZXRCb3VuZHMgPyBsYXllci5nZXRCb3VuZHMoKSA6IGxheWVyLmdldExhdExuZygpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBib3VuZHM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBmYWN0b3J5IEwuZmVhdHVyZUdyb3VwKGxheWVyczogTGF5ZXJbXSlcclxuLy8gQ3JlYXRlIGEgZmVhdHVyZSBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMuXHJcbmV4cG9ydCB2YXIgZmVhdHVyZUdyb3VwID0gZnVuY3Rpb24gKGxheWVycykge1xyXG5cdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcbn07XHJcbiIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4uLy4uL2NvcmUvQ2xhc3MnO1xyXG5pbXBvcnQge3NldE9wdGlvbnN9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9Qb2ludCBhcyBwb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQge3JldGluYX0gZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBJY29uXHJcbiAqIEBha2EgTC5JY29uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gaWNvbiB0byBwcm92aWRlIHdoZW4gY3JlYXRpbmcgYSBtYXJrZXIuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBteUljb24gPSBMLmljb24oe1xyXG4gKiAgICAgaWNvblVybDogJ215LWljb24ucG5nJyxcclxuICogICAgIGljb25SZXRpbmFVcmw6ICdteS1pY29uQDJ4LnBuZycsXHJcbiAqICAgICBpY29uU2l6ZTogWzM4LCA5NV0sXHJcbiAqICAgICBpY29uQW5jaG9yOiBbMjIsIDk0XSxcclxuICogICAgIHBvcHVwQW5jaG9yOiBbLTMsIC03Nl0sXHJcbiAqICAgICBzaGFkb3dVcmw6ICdteS1pY29uLXNoYWRvdy5wbmcnLFxyXG4gKiAgICAgc2hhZG93UmV0aW5hVXJsOiAnbXktaWNvbi1zaGFkb3dAMngucG5nJyxcclxuICogICAgIHNoYWRvd1NpemU6IFs2OCwgOTVdLFxyXG4gKiAgICAgc2hhZG93QW5jaG9yOiBbMjIsIDk0XVxyXG4gKiB9KTtcclxuICpcclxuICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIGBMLkljb24uRGVmYXVsdGAgZXh0ZW5kcyBgTC5JY29uYCBhbmQgaXMgdGhlIGJsdWUgaWNvbiBMZWFmbGV0IHVzZXMgZm9yIG1hcmtlcnMgYnkgZGVmYXVsdC5cclxuICpcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEljb24gPSBDbGFzcy5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgSWNvbiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25Vcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiAqKihyZXF1aXJlZCkqKiBUaGUgVVJMIHRvIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyIHNjcmlwdCBwYXRoKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblJldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gYSByZXRpbmEgc2l6ZWQgdmVyc2lvbiBvZiB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91clxyXG5cdCAqIHNjcmlwdCBwYXRoKS4gVXNlZCBmb3IgUmV0aW5hIHNjcmVlbiBkZXZpY2VzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uU2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgaWNvbiBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25BbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgaWNvbiAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikuIFRoZSBpY29uXHJcblx0ICogd2lsbCBiZSBhbGlnbmVkIHNvIHRoYXQgdGhpcyBwb2ludCBpcyBhdCB0aGUgbWFya2VyJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLiBDZW50ZXJlZFxyXG5cdCAqIGJ5IGRlZmF1bHQgaWYgc2l6ZSBpcyBzcGVjaWZpZWQsIGFsc28gY2FuIGJlIHNldCBpbiBDU1Mgd2l0aCBuZWdhdGl2ZSBtYXJnaW5zLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb3B1cEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggcG9wdXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gdG9vbHRpcEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggdG9vbHRpcHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIHRoZSBpY29uIHNoYWRvdyBpbWFnZS4gSWYgbm90IHNwZWNpZmllZCwgbm8gc2hhZG93IGltYWdlIHdpbGwgYmUgY3JlYXRlZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93UmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1NpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIHNoYWRvdyBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd0FuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBzaGFkb3cgKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpICh0aGUgc2FtZVxyXG5cdCAqIGFzIGljb25BbmNob3IgaWYgbm90IHNwZWNpZmllZCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHQgKiBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byBib3RoIGljb24gYW5kIHNoYWRvdyBpbWFnZXMuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcblx0ICovXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvcHVwQW5jaG9yOiBbMCwgMF0sXHJcblx0XHR0b29sdGlwQW5jaG9yOiBbMCwgMF1cclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZUljb24ob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBpY29uIGhhcyB0byBiZSBzaG93biwgcmV0dXJucyBhIGA8aW1nPmAgSFRNTCBlbGVtZW50XHJcblx0Ly8gc3R5bGVkIGFjY29yZGluZyB0byB0aGUgb3B0aW9ucy5cclxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVNoYWRvdyhvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIEFzIGBjcmVhdGVJY29uYCwgYnV0IGZvciB0aGUgc2hhZG93IGJlbmVhdGggaXQuXHJcblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ3NoYWRvdycsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJY29uOiBmdW5jdGlvbiAobmFtZSwgb2xkSWNvbikge1xyXG5cdFx0dmFyIHNyYyA9IHRoaXMuX2dldEljb25VcmwobmFtZSk7XHJcblxyXG5cdFx0aWYgKCFzcmMpIHtcclxuXHRcdFx0aWYgKG5hbWUgPT09ICdpY29uJykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignaWNvblVybCBub3Qgc2V0IGluIEljb24gb3B0aW9ucyAoc2VlIHRoZSBkb2NzKS4nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdJTUcnID8gb2xkSWNvbiA6IG51bGwpO1xyXG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpO1xyXG5cclxuXHRcdHJldHVybiBpbWc7XHJcblx0fSxcclxuXHJcblx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdFx0dmFyIHNpemVPcHRpb24gPSBvcHRpb25zW25hbWUgKyAnU2l6ZSddO1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygc2l6ZU9wdGlvbiA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0c2l6ZU9wdGlvbiA9IFtzaXplT3B0aW9uLCBzaXplT3B0aW9uXTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2l6ZSA9IHBvaW50KHNpemVPcHRpb24pLFxyXG5cdFx0ICAgIGFuY2hvciA9IHBvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG5cdFx0ICAgICAgICAgICAgc2l6ZSAmJiBzaXplLmRpdmlkZUJ5KDIsIHRydWUpKTtcclxuXHJcblx0XHRpbWcuY2xhc3NOYW1lID0gJ2xlYWZsZXQtbWFya2VyLScgKyBuYW1lICsgJyAnICsgKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKTtcclxuXHJcblx0XHRpZiAoYW5jaG9yKSB7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1hbmNob3IueCkgKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luVG9wICA9ICgtYW5jaG9yLnkpICsgJ3B4JztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2l6ZSkge1xyXG5cdFx0XHRpbWcuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuXHRcdGVsID0gZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblx0XHRlbC5zcmMgPSBzcmM7XHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRyZXR1cm4gcmV0aW5hICYmIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddIHx8IHRoaXMub3B0aW9uc1tuYW1lICsgJ1VybCddO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5pY29uKG9wdGlvbnM6IEljb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBpY29uIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBpY29uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEljb24ob3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5cbi8qXG4gKiBAbWluaWNsYXNzIEljb24uRGVmYXVsdCAoSWNvbilcbiAqIEBha2EgTC5JY29uLkRlZmF1bHRcbiAqIEBzZWN0aW9uXG4gKlxuICogQSB0cml2aWFsIHN1YmNsYXNzIG9mIGBJY29uYCwgcmVwcmVzZW50cyB0aGUgaWNvbiB0byB1c2UgaW4gYE1hcmtlcmBzIHdoZW5cbiAqIG5vIGljb24gaXMgc3BlY2lmaWVkLiBQb2ludHMgdG8gdGhlIGJsdWUgbWFya2VyIGltYWdlIGRpc3RyaWJ1dGVkIHdpdGggTGVhZmxldFxuICogcmVsZWFzZXMuXG4gKlxuICogSW4gb3JkZXIgdG8gY3VzdG9taXplIHRoZSBkZWZhdWx0IGljb24sIGp1c3QgY2hhbmdlIHRoZSBwcm9wZXJ0aWVzIG9mIGBMLkljb24uRGVmYXVsdC5wcm90b3R5cGUub3B0aW9uc2BcbiAqICh3aGljaCBpcyBhIHNldCBvZiBgSWNvbiBvcHRpb25zYCkuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gX2NvbXBsZXRlbHlfIHJlcGxhY2UgdGhlIGRlZmF1bHQgaWNvbiwgb3ZlcnJpZGUgdGhlXG4gKiBgTC5NYXJrZXIucHJvdG90eXBlLm9wdGlvbnMuaWNvbmAgd2l0aCB5b3VyIG93biBpY29uIGluc3RlYWQuXG4gKi9cblxuZXhwb3J0IHZhciBJY29uRGVmYXVsdCA9IEljb24uZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0aWNvblVybDogICAgICAgJ21hcmtlci1pY29uLnBuZycsXG5cdFx0aWNvblJldGluYVVybDogJ21hcmtlci1pY29uLTJ4LnBuZycsXG5cdFx0c2hhZG93VXJsOiAgICAgJ21hcmtlci1zaGFkb3cucG5nJyxcblx0XHRpY29uU2l6ZTogICAgWzI1LCA0MV0sXG5cdFx0aWNvbkFuY2hvcjogIFsxMiwgNDFdLFxuXHRcdHBvcHVwQW5jaG9yOiBbMSwgLTM0XSxcblx0XHR0b29sdGlwQW5jaG9yOiBbMTYsIC0yOF0sXG5cdFx0c2hhZG93U2l6ZTogIFs0MSwgNDFdXG5cdH0sXG5cblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKCFJY29uRGVmYXVsdC5pbWFnZVBhdGgpIHtcdC8vIERlcHJlY2F0ZWQsIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IG9ubHlcblx0XHRcdEljb25EZWZhdWx0LmltYWdlUGF0aCA9IHRoaXMuX2RldGVjdEljb25QYXRoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gQG9wdGlvbiBpbWFnZVBhdGg6IFN0cmluZ1xuXHRcdC8vIGBJY29uLkRlZmF1bHRgIHdpbGwgdHJ5IHRvIGF1dG8tZGV0ZWN0IHRoZSBsb2NhdGlvbiBvZiB0aGVcblx0XHQvLyBibHVlIGljb24gaW1hZ2VzLiBJZiB5b3UgYXJlIHBsYWNpbmcgdGhlc2UgaW1hZ2VzIGluIGEgbm9uLXN0YW5kYXJkXG5cdFx0Ly8gd2F5LCBzZXQgdGhpcyBvcHRpb24gdG8gcG9pbnQgdG8gdGhlIHJpZ2h0IHBhdGguXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuaW1hZ2VQYXRoIHx8IEljb25EZWZhdWx0LmltYWdlUGF0aCkgKyBJY29uLnByb3RvdHlwZS5fZ2V0SWNvblVybC5jYWxsKHRoaXMsIG5hbWUpO1xuXHR9LFxuXG5cdF9kZXRlY3RJY29uUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlbCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAgJ2xlYWZsZXQtZGVmYXVsdC1pY29uLXBhdGgnLCBkb2N1bWVudC5ib2R5KTtcblx0XHR2YXIgcGF0aCA9IERvbVV0aWwuZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kLWltYWdlJykgfHxcblx0XHQgICAgICAgICAgIERvbVV0aWwuZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kSW1hZ2UnKTtcdC8vIElFOFxuXG5cdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG5cblx0XHRpZiAocGF0aCA9PT0gbnVsbCB8fCBwYXRoLmluZGV4T2YoJ3VybCcpICE9PSAwKSB7XG5cdFx0XHRwYXRoID0gJyc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoL151cmxcXChbXCInXT8vLCAnJykucmVwbGFjZSgvbWFya2VyLWljb25cXC5wbmdbXCInXT9cXCkkLywgJycpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYXRoO1xuXHR9XG59KTtcbiIsImltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHtEcmFnZ2FibGV9IGZyb20gJy4uLy4uL2RvbS9EcmFnZ2FibGUnO1xuaW1wb3J0IHt0b0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtyZXF1ZXN0QW5pbUZyYW1lLCBjYW5jZWxBbmltRnJhbWV9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFya2VyRHJhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgTC5NYXJrZXIgdG8gbWFrZSB0aGUgbWFya2VycyBkcmFnZ2FibGUuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcmtlclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gaGFuZGxlcnNcbiAqXG4gKiBJbnRlcmFjdGlvbiBoYW5kbGVycyBhcmUgcHJvcGVydGllcyBvZiBhIG1hcmtlciBpbnN0YW5jZSB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2ggYXMgZHJhZ2dpbmcgKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIG1hcmtlci5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gKiBgYGBcbiAqXG4gKiBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbiAqIE1hcmtlciBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuIE9ubHkgdmFsaWQgd2hlbiB0aGUgbWFya2VyIGlzIG9uIHRoZSBtYXAgKE90aGVyd2lzZSBzZXQgW2BtYXJrZXIub3B0aW9ucy5kcmFnZ2FibGVgXSgjbWFya2VyLWRyYWdnYWJsZSkpLlxuICovXG5cbmV4cG9ydCB2YXIgTWFya2VyRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdHRoaXMuX21hcmtlciA9IG1hcmtlcjtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpY29uID0gdGhpcy5fbWFya2VyLl9pY29uO1xuXG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoaWNvbiwgaWNvbiwgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRwcmVkcmFnOiB0aGlzLl9vblByZURyYWcsXG5cdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHR9LCB0aGlzKS5lbmFibGUoKTtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9mZih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZGlzYWJsZSgpO1xuXG5cdFx0aWYgKHRoaXMuX21hcmtlci5faWNvbikge1xuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXJrZXIuX2ljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0XHR9XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG5cdH0sXG5cblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuXHRcdCAgICBtYXAgPSBtYXJrZXIuX21hcCxcblx0XHQgICAgc3BlZWQgPSB0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuU3BlZWQsXG5cdFx0ICAgIHBhZGRpbmcgPSB0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuUGFkZGluZyxcblx0XHQgICAgaWNvblBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcblx0XHQgICAgYm91bmRzID0gbWFwLmdldFBpeGVsQm91bmRzKCksXG5cdFx0ICAgIG9yaWdpbiA9IG1hcC5nZXRQaXhlbE9yaWdpbigpO1xuXG5cdFx0dmFyIHBhbkJvdW5kcyA9IHRvQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi5fc3VidHJhY3Qob3JpZ2luKS5hZGQocGFkZGluZyksXG5cdFx0XHRib3VuZHMubWF4Ll9zdWJ0cmFjdChvcmlnaW4pLnN1YnRyYWN0KHBhZGRpbmcpXG5cdFx0KTtcblxuXHRcdGlmICghcGFuQm91bmRzLmNvbnRhaW5zKGljb25Qb3MpKSB7XG5cdFx0XHQvLyBDb21wdXRlIGluY3JlbWVudGFsIG1vdmVtZW50XG5cdFx0XHR2YXIgbW92ZW1lbnQgPSB0b1BvaW50KFxuXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1heC54KSAvIChib3VuZHMubWF4LnggLSBwYW5Cb3VuZHMubWF4LngpIC1cblx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5taW4ueCkgLyAoYm91bmRzLm1pbi54IC0gcGFuQm91bmRzLm1pbi54KSxcblxuXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC55LCBpY29uUG9zLnkpIC0gcGFuQm91bmRzLm1heC55KSAvIChib3VuZHMubWF4LnkgLSBwYW5Cb3VuZHMubWF4LnkpIC1cblx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5taW4ueSkgLyAoYm91bmRzLm1pbi55IC0gcGFuQm91bmRzLm1pbi55KVxuXHRcdFx0KS5tdWx0aXBseUJ5KHNwZWVkKTtcblxuXHRcdFx0bWFwLnBhbkJ5KG1vdmVtZW50LCB7YW5pbWF0ZTogZmFsc2V9KTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuX2FkZChtb3ZlbWVudCk7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLl9hZGQobW92ZW1lbnQpO1xuXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKG1hcmtlci5faWNvbiwgdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MpO1xuXHRcdFx0dGhpcy5fb25EcmFnKGUpO1xuXG5cdFx0XHR0aGlzLl9wYW5SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLCBlKSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIEBzZWN0aW9uIERyYWdnaW5nIGV2ZW50c1xuXHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIHN0YXJ0cyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXG5cdFx0dGhpcy5fb2xkTGF0TG5nID0gdGhpcy5fbWFya2VyLmdldExhdExuZygpO1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuY2xvc2VQb3B1cCgpXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cdH0sXG5cblx0X29uUHJlRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1Bhbikge1xuXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3BhblJlcXVlc3QpO1xuXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuXHRcdCAgICBpY29uUG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuXHRcdCAgICBsYXRsbmcgPSBtYXJrZXIuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG5cblx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG5cdFx0aWYgKHNoYWRvdykge1xuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihzaGFkb3csIGljb25Qb3MpO1xuXHRcdH1cblxuXHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuXHRcdGUubGF0bG5nID0gbGF0bG5nO1xuXHRcdGUub2xkTGF0TG5nID0gdGhpcy5fb2xkTGF0TG5nO1xuXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgbWFya2VyLlxuXHRcdG1hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0IGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdG9wcyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXHRcdGRlbGV0ZSB0aGlzLl9vbGRMYXRMbmc7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlZW5kJylcblx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XHJcbmltcG9ydCB7SWNvbkRlZmF1bHR9IGZyb20gJy4vSWNvbi5EZWZhdWx0JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nIGFzIGxhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQge01hcmtlckRyYWd9IGZyb20gJy4vTWFya2VyLkRyYWcnO1xyXG5cclxuLypcclxuICogQGNsYXNzIE1hcmtlclxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICogQGFrYSBMLk1hcmtlclxyXG4gKiBMLk1hcmtlciBpcyB1c2VkIHRvIGRpc3BsYXkgY2xpY2thYmxlL2RyYWdnYWJsZSBpY29ucyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubWFya2VyKFs1MC41LCAzMC41XSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNYXJrZXIgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgTWFya2VyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGljb246IEljb24gPSAqXHJcblx0XHQvLyBJY29uIGluc3RhbmNlIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBtYXJrZXIuXHJcblx0XHQvLyBTZWUgW0ljb24gZG9jdW1lbnRhdGlvbl0oI0wuSWNvbikgZm9yIGRldGFpbHMgb24gaG93IHRvIGN1c3RvbWl6ZSB0aGUgbWFya2VyIGljb24uXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkLCBhIGNvbW1vbiBpbnN0YW5jZSBvZiBgTC5JY29uLkRlZmF1bHRgIGlzIHVzZWQuXHJcblx0XHRpY29uOiBuZXcgSWNvbkRlZmF1bHQoKSxcclxuXHJcblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXHJcblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGNhbiBiZSB0YWJiZWQgdG8gd2l0aCBhIGtleWJvYXJkIGFuZCBjbGlja2VkIGJ5IHByZXNzaW5nIGVudGVyLlxyXG5cdFx0a2V5Ym9hcmQ6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0aXRsZTogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBicm93c2VyIHRvb2x0aXAgdGhhdCBhcHBlYXIgb24gbWFya2VyIGhvdmVyIChubyB0b29sdGlwIGJ5IGRlZmF1bHQpLlxyXG5cdFx0dGl0bGU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaWNvbiBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXhPZmZzZXQ6IE51bWJlciA9IDBcclxuXHRcdC8vIEJ5IGRlZmF1bHQsIG1hcmtlciBpbWFnZXMgekluZGV4IGlzIHNldCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIGl0cyBsYXRpdHVkZS4gVXNlIHRoaXMgb3B0aW9uIGlmIHlvdSB3YW50IHRvIHB1dCB0aGUgbWFya2VyIG9uIHRvcCBvZiBhbGwgb3RoZXJzIChvciBiZWxvdyksIHNwZWNpZnlpbmcgYSBoaWdoIHZhbHVlIGxpa2UgYDEwMDBgIChvciBoaWdoIG5lZ2F0aXZlIHZhbHVlLCByZXNwZWN0aXZlbHkpLlxyXG5cdFx0ekluZGV4T2Zmc2V0OiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG5cdFx0b3BhY2l0eTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPbkhvdmVyOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIG1hcmtlciB3aWxsIGdldCBvbiB0b3Agb2Ygb3RoZXJzIHdoZW4geW91IGhvdmVyIHRoZSBtb3VzZSBvdmVyIGl0LlxyXG5cdFx0cmlzZU9uSG92ZXI6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmlzZU9mZnNldDogTnVtYmVyID0gMjUwXHJcblx0XHQvLyBUaGUgei1pbmRleCBvZmZzZXQgdXNlZCBmb3IgdGhlIGByaXNlT25Ib3ZlcmAgZmVhdHVyZS5cclxuXHRcdHJpc2VPZmZzZXQ6IDI1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdtYXJrZXJQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBpY29uIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAnbWFya2VyUGFuZScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnc2hhZG93UGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgc2hhZG93IHdpbGwgYmUgYWRkZWQuXHJcblx0XHRzaGFkb3dQYW5lOiAnc2hhZG93UGFuZScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgbWFya2VyIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXHJcblx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cclxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIERyYWdnYWJsZSBtYXJrZXIgb3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBkcmFnZ2FibGU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cclxuXHRcdGRyYWdnYWJsZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdG8gcGFuIHRoZSBtYXAgd2hlbiBkcmFnZ2luZyB0aGlzIG1hcmtlciBuZWFyIGl0cyBlZGdlIG9yIG5vdC5cclxuXHRcdGF1dG9QYW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNTAsIDUwKVxyXG5cdFx0Ly8gRGlzdGFuY2UgKGluIHBpeGVscyB0byB0aGUgbGVmdC9yaWdodCBhbmQgdG8gdGhlIHRvcC9ib3R0b20pIG9mIHRoZVxyXG5cdFx0Ly8gbWFwIGVkZ2UgdG8gc3RhcnQgcGFubmluZyB0aGUgbWFwLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1MCwgNTBdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblNwZWVkOiBOdW1iZXIgPSAxMFxyXG5cdFx0Ly8gTnVtYmVyIG9mIHBpeGVscyB0aGUgbWFwIHNob3VsZCBwYW4gYnkuXHJcblx0XHRhdXRvUGFuU3BlZWQ6IDEwXHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKlxyXG5cdCAqIEluIGFkZGl0aW9uIHRvIFtzaGFyZWQgbGF5ZXIgbWV0aG9kc10oI0xheWVyKSBsaWtlIGBhZGRUbygpYCBhbmQgYHJlbW92ZSgpYCBhbmQgW3BvcHVwIG1ldGhvZHNdKCNQb3B1cCkgbGlrZSBiaW5kUG9wdXAoKSB5b3UgY2FuIGFsc28gdXNlIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gbGF0TG5nKGxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IHRoaXMuX3pvb21BbmltYXRlZCAmJiBtYXAub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5kcmFnZ2luZy5lbmFibGVkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLmRyYWdnYWJsZSA9IHRydWU7XHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSB0aGlzLmRyYWdnaW5nO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR6b29tOiB0aGlzLnVwZGF0ZSxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLnVwZGF0ZVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBwb2ludC5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBsYXRMbmcobGF0bG5nKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI21hcmtlci1zZXRsYXRsbmcpIG9yIGJ5IFtkcmFnZ2luZ10oI21hcmtlci1kcmFnZ2luZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleE9mZnNldChvZmZzZXQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4IG9mZnNldF0oI21hcmtlci16aW5kZXhvZmZzZXQpIG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0ID0gb2Zmc2V0O1xyXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRJY29uOiBJY29uXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBpY29uIHVzZWQgYnkgdGhlIG1hcmtlclxyXG5cdGdldEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldEljb24oaWNvbjogSWNvbik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgaWNvbi5cclxuXHRzZXRJY29uOiBmdW5jdGlvbiAoaWNvbikge1xyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLCB0aGlzLl9wb3B1cC5vcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faWNvbjtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbiAmJiB0aGlzLl9tYXApIHtcclxuXHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpO1xyXG5cdFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIGNsYXNzVG9BZGQgPSAnbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XHJcblxyXG5cdFx0dmFyIGljb24gPSBvcHRpb25zLmljb24uY3JlYXRlSWNvbih0aGlzLl9pY29uKSxcclxuXHRcdCAgICBhZGRJY29uID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gaWYgd2UncmUgbm90IHJldXNpbmcgdGhlIGljb24sIHJlbW92ZSB0aGUgb2xkIG9uZSBhbmQgaW5pdCBuZXcgb25lXHJcblx0XHRpZiAoaWNvbiAhPT0gdGhpcy5faWNvbikge1xyXG5cdFx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRhZGRJY29uID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLnRpdGxlKSB7XHJcblx0XHRcdFx0aWNvbi50aXRsZSA9IG9wdGlvbnMudGl0bGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChpY29uLnRhZ05hbWUgPT09ICdJTUcnKSB7XHJcblx0XHRcdFx0aWNvbi5hbHQgPSBvcHRpb25zLmFsdCB8fCAnJztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcclxuXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5ld1NoYWRvdyA9IG9wdGlvbnMuaWNvbi5jcmVhdGVTaGFkb3codGhpcy5fc2hhZG93KSxcclxuXHRcdCAgICBhZGRTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKG5ld1NoYWRvdywgY2xhc3NUb0FkZCk7XHJcblx0XHRcdG5ld1NoYWRvdy5hbHQgPSAnJztcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG5ld1NoYWRvdztcclxuXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRpZiAoYWRkSWNvbikge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2luaXRJbnRlcmFjdGlvbigpO1xyXG5cdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKG9wdGlvbnMuc2hhZG93UGFuZSkuYXBwZW5kQ2hpbGQodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlSWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2ljb24pO1xyXG5cdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHR0aGlzLl9pY29uID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRQb3M6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2ljb24sIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2ljb24sICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblxyXG5cdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHRpZiAoTWFya2VyRHJhZykge1xyXG5cdFx0XHR2YXIgZHJhZ2dhYmxlID0gdGhpcy5vcHRpb25zLmRyYWdnYWJsZTtcclxuXHRcdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuXHRcdFx0XHRkcmFnZ2FibGUgPSB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKTtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmRpc2FibGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5kcmFnZ2luZyA9IG5ldyBNYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKGRyYWdnYWJsZSkge1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ljb24sIG9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0UG9wdXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb29sdGlwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuXHJcbi8vIEBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBNYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gbWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQGNsYXNzIFBhdGhcbiAqIEBha2EgTC5QYXRoXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcbiAqXG4gKiBBbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGNvbnRhaW5zIG9wdGlvbnMgYW5kIGNvbnN0YW50cyBzaGFyZWQgYmV0d2VlbiB2ZWN0b3JcbiAqIG92ZXJsYXlzIChQb2x5Z29uLCBQb2x5bGluZSwgQ2lyY2xlKS4gRG8gbm90IHVzZSBpdCBkaXJlY3RseS4gRXh0ZW5kcyBgTGF5ZXJgLlxuICovXG5cbmV4cG9ydCB2YXIgUGF0aCA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBQYXRoIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gc3Ryb2tlOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gZHJhdyBzdHJva2UgYWxvbmcgdGhlIHBhdGguIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgYm9yZGVycyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuXHRcdHN0cm9rZTogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gY29sb3I6IFN0cmluZyA9ICcjMzM4OGZmJ1xuXHRcdC8vIFN0cm9rZSBjb2xvclxuXHRcdGNvbG9yOiAnIzMzODhmZicsXG5cblx0XHQvLyBAb3B0aW9uIHdlaWdodDogTnVtYmVyID0gM1xuXHRcdC8vIFN0cm9rZSB3aWR0aCBpbiBwaXhlbHNcblx0XHR3ZWlnaHQ6IDMsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuXHRcdC8vIFN0cm9rZSBvcGFjaXR5XG5cdFx0b3BhY2l0eTogMSxcblxuXHRcdC8vIEBvcHRpb24gbGluZUNhcDogU3RyaW5nPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBlbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVjYXApIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUNhcDogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gbGluZUpvaW46IFN0cmluZyA9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGNvcm5lcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVqb2luKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVKb2luOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBkYXNoQXJyYXk6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIHN0cm9rZSBbZGFzaCBwYXR0ZXJuXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNoYXJyYXkpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaEFycmF5OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBkYXNoT2Zmc2V0OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBbZGlzdGFuY2UgaW50byB0aGUgZGFzaCBwYXR0ZXJuIHRvIHN0YXJ0IHRoZSBkYXNoXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNob2Zmc2V0KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hPZmZzZXQ6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGw6IEJvb2xlYW4gPSBkZXBlbmRzXG5cdFx0Ly8gV2hldGhlciB0byBmaWxsIHRoZSBwYXRoIHdpdGggY29sb3IuIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgZmlsbGluZyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuXHRcdGZpbGw6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsQ29sb3I6IFN0cmluZyA9ICpcblx0XHQvLyBGaWxsIGNvbG9yLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgb2YgdGhlIFtgY29sb3JgXSgjcGF0aC1jb2xvcikgb3B0aW9uXG5cdFx0ZmlsbENvbG9yOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsT3BhY2l0eTogTnVtYmVyID0gMC4yXG5cdFx0Ly8gRmlsbCBvcGFjaXR5LlxuXHRcdGZpbGxPcGFjaXR5OiAwLjIsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxSdWxlOiBTdHJpbmcgPSAnZXZlbm9kZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW2hvdyB0aGUgaW5zaWRlIG9mIGEgc2hhcGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvZmlsbC1ydWxlKSBpcyBkZXRlcm1pbmVkLlxuXHRcdGZpbGxSdWxlOiAnZXZlbm9kZCcsXG5cblx0XHQvLyBjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xuXHRcdGludGVyYWN0aXZlOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgcGF0aCB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxuXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcblx0fSxcblxuXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHQvLyBSZW5kZXJlciBpcyBzZXQgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gY2FsbCByZW5kZXJlci5nZXRFdmVudHNcblx0XHQvLyBiZWZvcmUgdGhpcy5nZXRFdmVudHMuXG5cdFx0dGhpcy5fcmVuZGVyZXIgPSBtYXAuZ2V0UmVuZGVyZXIodGhpcyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5faW5pdFBhdGgodGhpcyk7XG5cdFx0dGhpcy5fcmVzZXQoKTtcblx0XHR0aGlzLl9yZW5kZXJlci5fYWRkUGF0aCh0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9yZW1vdmVQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVkcmF3KCk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgbGF5ZXIuIFNvbWV0aW1lcyB1c2VmdWwgYWZ0ZXIgeW91IGNoYW5nZWQgdGhlIGNvb3JkaW5hdGVzIHRoYXQgdGhlIHBhdGggdXNlcy5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBhdGgodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgYXBwZWFyYW5jZSBvZiBhIFBhdGggYmFzZWQgb24gdGhlIG9wdGlvbnMgaW4gdGhlIGBQYXRoIG9wdGlvbnNgIG9iamVjdC5cblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBzdHlsZSk7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlU3R5bGUodGhpcyk7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnN0cm9rZSAmJiBzdHlsZSAmJiBzdHlsZS5oYXNPd25Qcm9wZXJ0eSgnd2VpZ2h0JykpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0Zyb250KHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvQmFjayh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGRlZmluZWQgaW4gY2hpbGQgY2xhc3Nlc1xuXHRcdHRoaXMuX3Byb2plY3QoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfY2xpY2tUb2xlcmFuY2U6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB1c2VkIHdoZW4gZG9pbmcgaGl0IGRldGVjdGlvbiBmb3IgQ2FudmFzIGxheWVyc1xuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnN0cm9rZSA/IHRoaXMub3B0aW9ucy53ZWlnaHQgLyAyIDogMCkgKyB0aGlzLl9yZW5kZXJlci5vcHRpb25zLnRvbGVyYW5jZTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlTWFya2VyXG4gKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAqL1xuXG5leHBvcnQgdmFyIENpcmNsZU1hcmtlciA9IFBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENpcmNsZU1hcmtlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlciA9IDEwXG5cdFx0Ly8gUmFkaXVzIG9mIHRoZSBjaXJjbGUgbWFya2VyLCBpbiBwaXhlbHNcblx0XHRyYWRpdXM6IDEwXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0TG5nOiBMYXRMbmcpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgY2lyY2xlIG1hcmtlciB0byBhIG5ldyBsb2NhdGlvbi5cblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMucmVkcmF3KCk7XG5cblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI2NpcmNsZW1hcmtlci1zZXRsYXRsbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUgbWFya2VyLiBVbml0cyBhcmUgaW4gcGl4ZWxzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLm9wdGlvbnMucmFkaXVzID0gdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiB0aGUgY2lyY2xlXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XG5cdH0sXG5cblx0c2V0U3R5bGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHZhciByYWRpdXMgPSBvcHRpb25zICYmIG9wdGlvbnMucmFkaXVzIHx8IHRoaXMuX3JhZGl1cztcblx0XHRQYXRoLnByb3RvdHlwZS5zZXRTdHlsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHIgPSB0aGlzLl9yYWRpdXMsXG5cdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IFtyICsgdywgcjIgKyB3XTtcblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ2lyY2xlKHRoaXMpO1xuXHR9LFxuXG5cdF9lbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXMgJiYgIXRoaXMuX3JlbmRlcmVyLl9ib3VuZHMuaW50ZXJzZWN0cyh0aGlzLl9weEJvdW5kcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0NpcmNsZU1hcmtlcn0gZnJvbSAnLi9DaXJjbGVNYXJrZXInO1xuaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0VhcnRofSBmcm9tICcuLi8uLi9nZW8vY3JzL0NSUy5FYXJ0aCc7XG5cblxuLypcbiAqIEBjbGFzcyBDaXJjbGVcbiAqIEBha2EgTC5DaXJjbGVcbiAqIEBpbmhlcml0cyBDaXJjbGVNYXJrZXJcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIGNpcmNsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgQ2lyY2xlTWFya2VyYC5cbiAqXG4gKiBJdCdzIGFuIGFwcHJveGltYXRpb24gYW5kIHN0YXJ0cyB0byBkaXZlcmdlIGZyb20gYSByZWFsIGNpcmNsZSBjbG9zZXIgdG8gcG9sZXMgKGR1ZSB0byBwcm9qZWN0aW9uIGRpc3RvcnRpb24pLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY2lyY2xlKFs1MC41LCAzMC41XSwge3JhZGl1czogMjAwfSkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgQ2lyY2xlID0gQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcblx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggZmFjdG9yeSAobGF0bG5nLCByYWRpdXMsIG9wdGlvbnM/KVxuXHRcdFx0b3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBsZWdhY3lPcHRpb25zLCB7cmFkaXVzOiBvcHRpb25zfSk7XG5cdFx0fVxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXG5cdFx0aWYgKGlzTmFOKHRoaXMub3B0aW9ucy5yYWRpdXMpKSB7IHRocm93IG5ldyBFcnJvcignQ2lyY2xlIHJhZGl1cyBjYW5ub3QgYmUgTmFOJyk7IH1cblxuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBDaXJjbGUgb3B0aW9uc1xuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXI7IFJhZGl1cyBvZiB0aGUgY2lyY2xlLCBpbiBtZXRlcnMuXG5cdFx0dGhpcy5fbVJhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGhhbGYgPSBbdGhpcy5fcmFkaXVzLCB0aGlzLl9yYWRpdXNZIHx8IHRoaXMuX3JhZGl1c107XG5cblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuc3VidHJhY3QoaGFsZikpLFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5hZGQoaGFsZikpKTtcblx0fSxcblxuXHRzZXRTdHlsZTogUGF0aC5wcm90b3R5cGUuc2V0U3R5bGUsXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBsbmcgPSB0aGlzLl9sYXRsbmcubG5nLFxuXHRcdCAgICBsYXQgPSB0aGlzLl9sYXRsbmcubGF0LFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuXHRcdGlmIChjcnMuZGlzdGFuY2UgPT09IEVhcnRoLmRpc3RhbmNlKSB7XG5cdFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHQgICAgbGF0UiA9ICh0aGlzLl9tUmFkaXVzIC8gRWFydGguUikgLyBkLFxuXHRcdFx0ICAgIHRvcCA9IG1hcC5wcm9qZWN0KFtsYXQgKyBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBib3R0b20gPSBtYXAucHJvamVjdChbbGF0IC0gbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgcCA9IHRvcC5hZGQoYm90dG9tKS5kaXZpZGVCeSgyKSxcblx0XHRcdCAgICBsYXQyID0gbWFwLnVucHJvamVjdChwKS5sYXQsXG5cdFx0XHQgICAgbG5nUiA9IE1hdGguYWNvcygoTWF0aC5jb3MobGF0UiAqIGQpIC0gTWF0aC5zaW4obGF0ICogZCkgKiBNYXRoLnNpbihsYXQyICogZCkpIC9cblx0XHRcdCAgICAgICAgICAgIChNYXRoLmNvcyhsYXQgKiBkKSAqIE1hdGguY29zKGxhdDIgKiBkKSkpIC8gZDtcblxuXHRcdFx0aWYgKGlzTmFOKGxuZ1IpIHx8IGxuZ1IgPT09IDApIHtcblx0XHRcdFx0bG5nUiA9IGxhdFIgLyBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogbGF0KTsgLy8gRmFsbGJhY2sgZm9yIGVkZ2UgY2FzZSwgIzI0MjVcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBwLnN1YnRyYWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IGlzTmFOKGxuZ1IpID8gMCA6IHAueCAtIG1hcC5wcm9qZWN0KFtsYXQyLCBsbmcgLSBsbmdSXSkueDtcblx0XHRcdHRoaXMuX3JhZGl1c1kgPSBwLnkgLSB0b3AueTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGF0bG5nMiA9IGNycy51bnByb2plY3QoY3JzLnByb2plY3QodGhpcy5fbGF0bG5nKS5zdWJ0cmFjdChbdGhpcy5fbVJhZGl1cywgMF0pKTtcblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLl9wb2ludC54IC0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcyKS54O1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25zIG9iamVjdFxuLy8gd2hpY2ggY29udGFpbnMgdGhlIGNpcmNsZSByYWRpdXMuXG4vLyBAYWx0ZXJuYXRpdmVcbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCByYWRpdXM6IE51bWJlciwgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gT2Jzb2xldGUgd2F5IG9mIGluc3RhbnRpYXRpbmcgYSBjaXJjbGUsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggY29kZS5cbi8vIERvIG5vdCB1c2UgaW4gbmV3IGFwcGxpY2F0aW9ucyBvciBwbHVnaW5zLlxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBDaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKTtcbn1cbiIsImltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcbmltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcblxuLypcbiAqIEBjbGFzcyBQb2x5bGluZVxuICogQGFrYSBMLlBvbHlsaW5lXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWxpbmUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBhdGhgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbNDUuNTEsIC0xMjIuNjhdLFxuICogXHRbMzcuNzcsIC0xMjIuNDNdLFxuICogXHRbMzQuMDQsIC0xMTguMl1cbiAqIF07XG4gKlxuICogdmFyIHBvbHlsaW5lID0gTC5wb2x5bGluZShsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlsaW5lXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlsaW5lLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgYE11bHRpUG9seWxpbmVgIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBhcnJheXMgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFtbNDUuNTEsIC0xMjIuNjhdLFxuICogXHQgWzM3Ljc3LCAtMTIyLjQzXSxcbiAqIFx0IFszNC4wNCwgLTExOC4yXV0sXG4gKiBcdFtbNDAuNzgsIC03My45MV0sXG4gKiBcdCBbNDEuODMsIC04Ny42Ml0sXG4gKiBcdCBbMzIuNzYsIC05Ni43Ml1dXG4gKiBdO1xuICogYGBgXG4gKi9cblxuXG5leHBvcnQgdmFyIFBvbHlsaW5lID0gUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUG9seWxpbmUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzbW9vdGhGYWN0b3I6IE51bWJlciA9IDEuMFxuXHRcdC8vIEhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWwuIE1vcmUgbWVhbnNcblx0XHQvLyBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHNtb290aGVyIGxvb2ssIGFuZCBsZXNzIG1lYW5zIG1vcmUgYWNjdXJhdGUgcmVwcmVzZW50YXRpb24uXG5cdFx0c21vb3RoRmFjdG9yOiAxLjAsXG5cblx0XHQvLyBAb3B0aW9uIG5vQ2xpcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gRGlzYWJsZSBwb2x5bGluZSBjbGlwcGluZy5cblx0XHRub0NsaXA6IGZhbHNlXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZ3MoKTogTGF0TG5nW11cblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcG9pbnRzIGluIHRoZSBwYXRoLCBvciBuZXN0ZWQgYXJyYXlzIG9mIHBvaW50cyBpbiBjYXNlIG9mIG11bHRpLXBvbHlsaW5lLlxuXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZ3M7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmdzKGxhdGxuZ3M6IExhdExuZ1tdKTogdGhpc1xuXHQvLyBSZXBsYWNlcyBhbGwgdGhlIHBvaW50cyBpbiB0aGUgcG9seWxpbmUgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cy5cblx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNFbXB0eSgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBQb2x5bGluZSBoYXMgbm8gTGF0TG5ncy5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGg7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZXN0TGF5ZXJQb2ludChwOiBQb2ludCk6IFBvaW50XG5cdC8vIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYHBgIG9uIHRoZSBQb2x5bGluZS5cblx0Y2xvc2VzdExheWVyUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksXG5cdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcblx0XHQgICAgY2xvc2VzdCA9IExpbmVVdGlsLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcblx0XHQgICAgcDEsIHAyO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcblx0XHRcdHZhciBwb2ludHMgPSB0aGlzLl9wYXJ0c1tqXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG5cdFx0XHRcdHAyID0gcG9pbnRzW2ldO1xuXG5cdFx0XHRcdHZhciBzcURpc3QgPSBjbG9zZXN0KHAsIHAxLCBwMiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBzcURpc3Q7XG5cdFx0XHRcdFx0bWluUG9pbnQgPSBjbG9zZXN0KHAsIHAxLCBwMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG1pblBvaW50KSB7XG5cdFx0XHRtaW5Qb2ludC5kaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZSk7XG5cdFx0fVxuXHRcdHJldHVybiBtaW5Qb2ludDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcG9seWxpbmUuXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cblx0XHR2YXIgaSwgaGFsZkRpc3QsIHNlZ0Rpc3QsIGRpc3QsIHAxLCBwMiwgcmF0aW8sXG5cdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuIG51bGw7IH1cblxuXHRcdC8vIHBvbHlsaW5lIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0Zm9yIChpID0gMCwgaGFsZkRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG5cdFx0XHRoYWxmRGlzdCArPSBwb2ludHNbaV0uZGlzdGFuY2VUbyhwb2ludHNbaSArIDFdKSAvIDI7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGxpbmUgaXMgc28gc21hbGwgaW4gdGhlIGN1cnJlbnQgdmlldyB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHRoZSBzYW1lIHBpeGVsLlxuXHRcdGlmIChoYWxmRGlzdCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcocG9pbnRzWzBdKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBkaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tpICsgMV07XG5cdFx0XHRzZWdEaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XG5cblx0XHRcdGlmIChkaXN0ID4gaGFsZkRpc3QpIHtcblx0XHRcdFx0cmF0aW8gPSAoZGlzdCAtIGhhbGZEaXN0KSAvIHNlZ0Rpc3Q7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKFtcblx0XHRcdFx0XHRwMi54IC0gcmF0aW8gKiAocDIueCAtIHAxLngpLFxuXHRcdFx0XHRcdHAyLnkgLSByYXRpbyAqIChwMi55IC0gcDEueSlcblx0XHRcdFx0XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZExhdExuZyhsYXRsbmc6IExhdExuZywgbGF0bG5ncz8gTGF0TG5nW10pOiB0aGlzXG5cdC8vIEFkZHMgYSBnaXZlbiBwb2ludCB0byB0aGUgcG9seWxpbmUuIEJ5IGRlZmF1bHQsIGFkZHMgdG8gdGhlIGZpcnN0IHJpbmcgb2Zcblx0Ly8gdGhlIHBvbHlsaW5lIGluIGNhc2Ugb2YgYSBtdWx0aS1wb2x5bGluZSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3Npbmdcblx0Ly8gYSBzcGVjaWZpYyByaW5nIGFzIGEgTGF0TG5nIGFycmF5ICh0aGF0IHlvdSBjYW4gZWFybGllciBhY2Nlc3Mgd2l0aCBbYGdldExhdExuZ3NgXSgjcG9seWxpbmUtZ2V0bGF0bG5ncykpLlxuXHRhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcblx0XHRsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9kZWZhdWx0U2hhcGUoKTtcblx0XHRsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xuXHRcdHRoaXMuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XG5cdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpID8gdGhpcy5fbGF0bG5ncyA6IHRoaXMuX2xhdGxuZ3NbMF07XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgY29udmVydCBsYXRsbmdzIGlucHV0IGludG8gYWN0dWFsIExhdExuZyBpbnN0YW5jZXM7IGNhbGN1bGF0ZSBib3VuZHMgYWxvbmcgdGhlIHdheVxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdCAgICBmbGF0ID0gTGluZVV0aWwuaXNGbGF0KGxhdGxuZ3MpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChmbGF0KSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKHJlc3VsdFtpXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Qm91bmRzID0gbmV3IEJvdW5kcygpO1xuXHRcdHRoaXMuX3JpbmdzID0gW107XG5cdFx0dGhpcy5fcHJvamVjdExhdGxuZ3ModGhpcy5fbGF0bG5ncywgdGhpcy5fcmluZ3MsIHB4Qm91bmRzKTtcblxuXHRcdGlmICh0aGlzLl9ib3VuZHMuaXNWYWxpZCgpICYmIHB4Qm91bmRzLmlzVmFsaWQoKSkge1xuXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMgPSBweEJvdW5kcztcblx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEJvdW5kcyhbXG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcy5taW4uc3VidHJhY3QocCksXG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcy5tYXguYWRkKHApXG5cdFx0XSk7XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgdHVybnMgbGF0bG5ncyBpbnRvIGEgc2V0IG9mIHJpbmdzIHdpdGggcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdF9wcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKSB7XG5cdFx0dmFyIGZsYXQgPSBsYXRsbmdzWzBdIGluc3RhbmNlb2YgTGF0TG5nLFxuXHRcdCAgICBsZW4gPSBsYXRsbmdzLmxlbmd0aCxcblx0XHQgICAgaSwgcmluZztcblxuXHRcdGlmIChmbGF0KSB7XG5cdFx0XHRyaW5nID0gW107XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmluZ1tpXSA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHByb2plY3RlZEJvdW5kcy5leHRlbmQocmluZ1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQucHVzaChyaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKGxhdGxuZ3NbaV0sIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gY2xpcCBwb2x5bGluZSBieSByZW5kZXJlciBib3VuZHMgc28gdGhhdCB3ZSBoYXZlIGxlc3MgdG8gcmVuZGVyIGZvciBwZXJmb3JtYW5jZVxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgaSwgaiwgaywgbGVuLCBsZW4yLCBzZWdtZW50LCBwb2ludHM7XG5cblx0XHRmb3IgKGkgPSAwLCBrID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBvaW50cyA9IHRoaXMuX3JpbmdzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjIgLSAxOyBqKyspIHtcblx0XHRcdFx0c2VnbWVudCA9IExpbmVVdGlsLmNsaXBTZWdtZW50KHBvaW50c1tqXSwgcG9pbnRzW2ogKyAxXSwgYm91bmRzLCBqLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoIXNlZ21lbnQpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRwYXJ0c1trXSA9IHBhcnRzW2tdIHx8IFtdO1xuXHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMF0pO1xuXG5cdFx0XHRcdC8vIGlmIHNlZ21lbnQgZ29lcyBvdXQgb2Ygc2NyZWVuLCBvciBpdCdzIHRoZSBsYXN0IG9uZSwgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lIHBhcnRcblx0XHRcdFx0aWYgKChzZWdtZW50WzFdICE9PSBwb2ludHNbaiArIDFdKSB8fCAoaiA9PT0gbGVuMiAtIDIpKSB7XG5cdFx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzFdKTtcblx0XHRcdFx0XHRrKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gc2ltcGxpZnkgZWFjaCBjbGlwcGVkIHBhcnQgb2YgdGhlIHBvbHlsaW5lIGZvciBwZXJmb3JtYW5jZVxuXHRfc2ltcGxpZnlQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgdG9sZXJhbmNlID0gdGhpcy5vcHRpb25zLnNtb290aEZhY3RvcjtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydHNbaV0gPSBMaW5lVXRpbC5zaW1wbGlmeShwYXJ0c1tpXSwgdG9sZXJhbmNlKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY2xpcFBvaW50cygpO1xuXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XG5cdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHAsIGNsb3NlZCkge1xuXHRcdHZhciBpLCBqLCBrLCBsZW4sIGxlbjIsIHBhcnQsXG5cdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyBoaXQgZGV0ZWN0aW9uIGZvciBwb2x5bGluZXNcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0aWYgKExpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSkgPD0gdykge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwucG9seWxpbmUobGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgcG9seWxpbmUgb2JqZWN0IGdpdmVuIGFuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMgYW5kXG4vLyBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LiBZb3UgY2FuIGNyZWF0ZSBhIGBQb2x5bGluZWAgb2JqZWN0IHdpdGhcbi8vIG11bHRpcGxlIHNlcGFyYXRlIGxpbmVzIChgTXVsdGlQb2x5bGluZWApIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgYXJyYXlzXG4vLyBvZiBnZW9ncmFwaGljIHBvaW50cy5cbmV4cG9ydCBmdW5jdGlvbiBwb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XG59XG5cbi8vIFJldHJvY29tcGF0LiBBbGxvdyBwbHVnaW5zIHRvIHN1cHBvcnQgTGVhZmxldCB2ZXJzaW9ucyBiZWZvcmUgYW5kIGFmdGVyIDEuMS5cblBvbHlsaW5lLl9mbGF0ID0gTGluZVV0aWwuX2ZsYXQ7XG4iLCJpbXBvcnQge1BvbHlsaW5lfSBmcm9tICcuL1BvbHlsaW5lJztcbmltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0ICogYXMgUG9seVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9seVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIFBvbHlnb25cbiAqIEBha2EgTC5Qb2x5Z29uXG4gKiBAaW5oZXJpdHMgUG9seWxpbmVcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlnb24gb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlsaW5lYC5cbiAqXG4gKiBOb3RlIHRoYXQgcG9pbnRzIHlvdSBwYXNzIHdoZW4gY3JlYXRpbmcgYSBwb2x5Z29uIHNob3VsZG4ndCBoYXZlIGFuIGFkZGl0aW9uYWwgbGFzdCBwb2ludCBlcXVhbCB0byB0aGUgZmlyc3Qgb25lIOKAlCBpdCdzIGJldHRlciB0byBmaWx0ZXIgb3V0IHN1Y2ggcG9pbnRzLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWdvbiBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dO1xuICpcbiAqIHZhciBwb2x5Z29uID0gTC5wb2x5Z29uKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWdvblxuICogbWFwLmZpdEJvdW5kcyhwb2x5Z29uLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB3aXRoIHRoZSBmaXJzdCBhcnJheSByZXByZXNlbnRpbmcgdGhlIG91dGVyIHNoYXBlIGFuZCB0aGUgb3RoZXIgYXJyYXlzIHJlcHJlc2VudGluZyBob2xlcyBpbiB0aGUgb3V0ZXIgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAqICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAqIF07XG4gKiBgYGBcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIE11bHRpUG9seWdvbiBzaGFwZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFsgLy8gZmlyc3QgcG9seWdvblxuICogICAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICogICAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gKiAgIF0sXG4gKiAgIFsgLy8gc2Vjb25kIHBvbHlnb25cbiAqICAgICBbWzQxLCAtMTExLjAzXSxbNDUsIC0xMTEuMDRdLFs0NSwgLTEwNC4wNV0sWzQxLCAtMTA0LjA1XV1cbiAqICAgXVxuICogXTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgUG9seWdvbiA9IFBvbHlsaW5lLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWVcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aCB8fCAhdGhpcy5fbGF0bG5nc1swXS5sZW5ndGg7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblxuXHRcdHZhciBpLCBqLCBwMSwgcDIsIGYsIGFyZWEsIHgsIHksIGNlbnRlcixcblx0XHQgICAgcG9pbnRzID0gdGhpcy5fcmluZ3NbMF0sXG5cdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm4gbnVsbDsgfVxuXG5cdFx0Ly8gcG9seWdvbiBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGFyZWEgPSB4ID0geSA9IDA7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tqXTtcblxuXHRcdFx0ZiA9IHAxLnkgKiBwMi54IC0gcDIueSAqIHAxLng7XG5cdFx0XHR4ICs9IChwMS54ICsgcDIueCkgKiBmO1xuXHRcdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcblx0XHRcdGFyZWEgKz0gZiAqIDM7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZWEgPT09IDApIHtcblx0XHRcdC8vIFBvbHlnb24gaXMgc28gc21hbGwgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiBzYW1lIHBpeGVsLlxuXHRcdFx0Y2VudGVyID0gcG9pbnRzWzBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjZW50ZXIgPSBbeCAvIGFyZWEsIHkgLyBhcmVhXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoY2VudGVyKTtcblx0fSxcblxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcblx0XHQgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblxuXHRcdC8vIHJlbW92ZSBsYXN0IHBvaW50IGlmIGl0IGVxdWFscyBmaXJzdCBvbmVcblx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuXHRcdFx0cmVzdWx0LnBvcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdFBvbHlsaW5lLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xuXHRcdGlmIChMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncykpIHtcblx0XHRcdHRoaXMuX2xhdGxuZ3MgPSBbdGhpcy5fbGF0bG5nc107XG5cdFx0fVxuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG5cdH0sXG5cblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwb2x5Z29ucyBuZWVkIGEgZGlmZmVyZW50IGNsaXBwaW5nIGFsZ29yaXRobSBzbyB3ZSByZWRlZmluZSB0aGF0XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcblx0XHQgICAgdyA9IHRoaXMub3B0aW9ucy53ZWlnaHQsXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cblx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG5cdFx0Ym91bmRzID0gbmV3IEJvdW5kcyhib3VuZHMubWluLnN1YnRyYWN0KHApLCBib3VuZHMubWF4LmFkZChwKSk7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGgsIGNsaXBwZWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y2xpcHBlZCA9IFBvbHlVdGlsLmNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMsIHRydWUpO1xuXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX3BhcnRzLnB1c2goY2xpcHBlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgaW5zaWRlID0gZmFsc2UsXG5cdFx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyByYXkgY2FzdGluZyBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBpZiBwb2ludCBpcyBpbiBwb2x5Z29uXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRcdHAxID0gcGFydFtqXTtcblx0XHRcdFx0cDIgPSBwYXJ0W2tdO1xuXG5cdFx0XHRcdGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG5cdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFsc28gY2hlY2sgaWYgaXQncyBvbiBwb2x5Z29uIHN0cm9rZVxuXHRcdHJldHVybiBpbnNpZGUgfHwgUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSk7XG5cdH1cblxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5wb2x5Z29uKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtMYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7TWFya2VyfSBmcm9tICcuL21hcmtlci9NYXJrZXInO1xyXG5pbXBvcnQge0NpcmNsZX0gZnJvbSAnLi92ZWN0b3IvQ2lyY2xlJztcclxuaW1wb3J0IHtDaXJjbGVNYXJrZXJ9IGZyb20gJy4vdmVjdG9yL0NpcmNsZU1hcmtlcic7XHJcbmltcG9ydCB7UG9seWxpbmV9IGZyb20gJy4vdmVjdG9yL1BvbHlsaW5lJztcclxuaW1wb3J0IHtQb2x5Z29ufSBmcm9tICcuL3ZlY3Rvci9Qb2x5Z29uJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi9nZW9tZXRyeS9MaW5lVXRpbCc7XHJcblxyXG5cclxuLypcclxuICogQGNsYXNzIEdlb0pTT05cclxuICogQGFrYSBMLkdlb0pTT05cclxuICogQGluaGVyaXRzIEZlYXR1cmVHcm91cFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgR2VvSlNPTiBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgR2VvSlNPTiBvYmplY3RzLiBBbGxvd3MgeW91IHRvIHBhcnNlXHJcbiAqIEdlb0pTT04gZGF0YSBhbmQgZGlzcGxheSBpdCBvbiB0aGUgbWFwLiBFeHRlbmRzIGBGZWF0dXJlR3JvdXBgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmdlb0pTT04oZGF0YSwge1xyXG4gKiBcdHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gKiBcdFx0cmV0dXJuIHtjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzLmNvbG9yfTtcclxuICogXHR9XHJcbiAqIH0pLmJpbmRQb3B1cChmdW5jdGlvbiAobGF5ZXIpIHtcclxuICogXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xyXG4gKiB9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEdlb0pTT04gPSBGZWF0dXJlR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEdlb0pTT04gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb2ludFRvTGF5ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyBob3cgR2VvSlNPTiBwb2ludHMgc3Bhd24gTGVhZmxldCBsYXllcnMuIEl0IGlzIGludGVybmFsbHlcclxuXHQgKiBjYWxsZWQgd2hlbiBkYXRhIGlzIGFkZGVkLCBwYXNzaW5nIHRoZSBHZW9KU09OIHBvaW50IGZlYXR1cmUgYW5kIGl0cyBgTGF0TG5nYC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBzcGF3biBhIGRlZmF1bHQgYE1hcmtlcmA6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbihnZW9Kc29uUG9pbnQsIGxhdGxuZykge1xyXG5cdCAqIFx0cmV0dXJuIEwubWFya2VyKGxhdGxuZyk7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzdHlsZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIHRoZSBgUGF0aCBvcHRpb25zYCBmb3Igc3R5bGluZyBHZW9KU09OIGxpbmVzIGFuZCBwb2x5Z29ucyxcclxuXHQgKiBjYWxsZWQgaW50ZXJuYWxseSB3aGVuIGRhdGEgaXMgYWRkZWQuXHJcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdG8gbm90IG92ZXJyaWRlIGFueSBkZWZhdWx0czpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHt9XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBvbkVhY2hGZWF0dXJlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGNyZWF0ZWQgYEZlYXR1cmVgLCBhZnRlciBpdCBoYXNcclxuXHQgKiBiZWVuIGNyZWF0ZWQgYW5kIHN0eWxlZC4gVXNlZnVsIGZvciBhdHRhY2hpbmcgZXZlbnRzIGFuZCBwb3B1cHMgdG8gZmVhdHVyZXMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gZG8gbm90aGluZyB3aXRoIHRoZSBuZXdseSBjcmVhdGVkIGxheWVyczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChmZWF0dXJlLCBsYXllcikge31cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gZmlsdGVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG8gaW5jbHVkZSBhIGZlYXR1cmUgb3Igbm90LlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGluY2x1ZGUgYWxsIGZlYXR1cmVzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4gdHJ1ZTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICogTm90ZTogZHluYW1pY2FsbHkgY2hhbmdpbmcgdGhlIGBmaWx0ZXJgIG9wdGlvbiB3aWxsIGhhdmUgZWZmZWN0IG9ubHkgb24gbmV3bHlcclxuXHQgKiBhZGRlZCBkYXRhLiBJdCB3aWxsIF9ub3RfIHJlLWV2YWx1YXRlIGFscmVhZHkgaW5jbHVkZWQgZmVhdHVyZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNvb3Jkc1RvTGF0TG5nOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgR2VvSlNPTiBjb29yZGluYXRlcyB0byBgTGF0TG5nYHMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdGhlIGBjb29yZHNUb0xhdExuZ2Agc3RhdGljIG1ldGhvZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gbWFya2Vyc0luaGVyaXRPcHRpb25zOiBCb29sZWFuID0gZmFsc2VcclxuXHQgKiBXaGV0aGVyIGRlZmF1bHQgTWFya2VycyBmb3IgXCJQb2ludFwiIHR5cGUgRmVhdHVyZXMgaW5oZXJpdCBmcm9tIGdyb3VwIG9wdGlvbnMuXHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0aWYgKGdlb2pzb24pIHtcclxuXHRcdFx0dGhpcy5hZGREYXRhKGdlb2pzb24pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRGF0YSggPEdlb0pTT04+IGRhdGEgKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBHZW9KU09OIG9iamVjdCB0byB0aGUgbGF5ZXIuXHJcblx0YWRkRGF0YTogZnVuY3Rpb24gKGdlb2pzb24pIHtcclxuXHRcdHZhciBmZWF0dXJlcyA9IFV0aWwuaXNBcnJheShnZW9qc29uKSA/IGdlb2pzb24gOiBnZW9qc29uLmZlYXR1cmVzLFxyXG5cdFx0ICAgIGksIGxlbiwgZmVhdHVyZTtcclxuXHJcblx0XHRpZiAoZmVhdHVyZXMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHQvLyBvbmx5IGFkZCB0aGlzIGlmIGdlb21ldHJ5IG9yIGdlb21ldHJpZXMgYXJlIHNldCBhbmQgbm90IG51bGxcclxuXHRcdFx0XHRmZWF0dXJlID0gZmVhdHVyZXNbaV07XHJcblx0XHRcdFx0aWYgKGZlYXR1cmUuZ2VvbWV0cmllcyB8fCBmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZmVhdHVyZXMgfHwgZmVhdHVyZS5jb29yZGluYXRlcykge1xyXG5cdFx0XHRcdFx0dGhpcy5hZGREYXRhKGZlYXR1cmUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5maWx0ZXIgJiYgIW9wdGlvbnMuZmlsdGVyKGdlb2pzb24pKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGxheWVyID0gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpO1xyXG5cdFx0aWYgKCFsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGxheWVyLmZlYXR1cmUgPSBhc0ZlYXR1cmUoZ2VvanNvbik7XHJcblxyXG5cdFx0bGF5ZXIuZGVmYXVsdE9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xyXG5cdFx0dGhpcy5yZXNldFN0eWxlKGxheWVyKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5vbkVhY2hGZWF0dXJlKSB7XHJcblx0XHRcdG9wdGlvbnMub25FYWNoRmVhdHVyZShnZW9qc29uLCBsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVzZXRTdHlsZSggPFBhdGg+IGxheWVyPyApOiB0aGlzXHJcblx0Ly8gUmVzZXRzIHRoZSBnaXZlbiB2ZWN0b3IgbGF5ZXIncyBzdHlsZSB0byB0aGUgb3JpZ2luYWwgR2VvSlNPTiBzdHlsZSwgdXNlZnVsIGZvciByZXNldHRpbmcgc3R5bGUgYWZ0ZXIgaG92ZXIgZXZlbnRzLlxyXG5cdC8vIElmIGBsYXllcmAgaXMgb21pdHRlZCwgdGhlIHN0eWxlIG9mIGFsbCBmZWF0dXJlcyBpbiB0aGUgY3VycmVudCBsYXllciBpcyByZXNldC5cclxuXHRyZXNldFN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlc2V0U3R5bGUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gcmVzZXQgYW55IGN1c3RvbSBzdHlsZXNcclxuXHRcdGxheWVyLm9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgbGF5ZXIuZGVmYXVsdE9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgdGhpcy5vcHRpb25zLnN0eWxlKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoIDxGdW5jdGlvbj4gc3R5bGUgKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgc3R5bGVzIG9mIEdlb0pTT04gdmVjdG9yIGxheWVycyB3aXRoIHRoZSBnaXZlbiBzdHlsZSBmdW5jdGlvbi5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRMYXllclN0eWxlOiBmdW5jdGlvbiAobGF5ZXIsIHN0eWxlKSB7XHJcblx0XHRpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuR2VvSlNPTjpcclxuXHJcbi8vIEBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZmVhdHVyZURhdGE6IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucyk6IExheWVyXHJcbi8vIENyZWF0ZXMgYSBgTGF5ZXJgIGZyb20gYSBnaXZlbiBHZW9KU09OIGZlYXR1cmUuIENhbiB1c2UgYSBjdXN0b21cclxuLy8gW2Bwb2ludFRvTGF5ZXJgXSgjZ2VvanNvbi1wb2ludHRvbGF5ZXIpIGFuZC9vciBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbi8vIGZ1bmN0aW9ucyBpZiBwcm92aWRlZCBhcyBvcHRpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbixcclxuXHQgICAgY29vcmRzID0gZ2VvbWV0cnkgPyBnZW9tZXRyeS5jb29yZGluYXRlcyA6IG51bGwsXHJcblx0ICAgIGxheWVycyA9IFtdLFxyXG5cdCAgICBwb2ludFRvTGF5ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMucG9pbnRUb0xheWVyLFxyXG5cdCAgICBfY29vcmRzVG9MYXRMbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcsXHJcblx0ICAgIGxhdGxuZywgbGF0bG5ncywgaSwgbGVuO1xyXG5cclxuXHRpZiAoIWNvb3JkcyAmJiAhZ2VvbWV0cnkpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0c3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XHJcblx0Y2FzZSAnUG9pbnQnOlxyXG5cdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkcyk7XHJcblx0XHRyZXR1cm4gX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ011bHRpUG9pbnQnOlxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHNbaV0pO1xyXG5cdFx0XHRsYXllcnMucHVzaChfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllciwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRjYXNlICdMaW5lU3RyaW5nJzpcclxuXHRjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxyXG5cdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyA/IDAgOiAxLCBfY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnUG9seWdvbic6XHJcblx0Y2FzZSAnTXVsdGlQb2x5Z29uJzpcclxuXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgPyAxIDogMiwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dmFyIGxheWVyID0gZ2VvbWV0cnlUb0xheWVyKHtcclxuXHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnkuZ2VvbWV0cmllc1tpXSxcclxuXHRcdFx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRcdFx0cHJvcGVydGllczogZ2VvanNvbi5wcm9wZXJ0aWVzXHJcblx0XHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyKSB7XHJcblx0XHRcdFx0bGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRkZWZhdWx0OlxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEdlb0pTT04gb2JqZWN0LicpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXJGbiwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIHBvaW50VG9MYXllckZuID9cclxuXHRcdHBvaW50VG9MYXllckZuKGdlb2pzb24sIGxhdGxuZykgOlxyXG5cdFx0bmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMgJiYgb3B0aW9ucy5tYXJrZXJzSW5oZXJpdE9wdGlvbnMgJiYgb3B0aW9ucyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nYCBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiAyIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUpXHJcbi8vIG9yIDMgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSwgYWx0aXR1ZGUpIHVzZWQgaW4gR2VvSlNPTiBmb3IgcG9pbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzKSB7XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY29vcmRzVG9MYXRMbmc/OiBGdW5jdGlvbik6IEFycmF5XHJcbi8vIENyZWF0ZXMgYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IG9mIGBMYXRMbmdgcyBmcm9tIGEgR2VvSlNPTiBjb29yZGluYXRlcyBhcnJheS5cclxuLy8gYGxldmVsc0RlZXBgIHNwZWNpZmllcyB0aGUgbmVzdGluZyBsZXZlbCAoMCBpcyBmb3IgYW4gYXJyYXkgb2YgcG9pbnRzLCAxIGZvciBhbiBhcnJheSBvZiBhcnJheXMgb2YgcG9pbnRzLCBldGMuLCAwIGJ5IGRlZmF1bHQpLlxyXG4vLyBDYW4gdXNlIGEgY3VzdG9tIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZykgZnVuY3Rpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBsZXZlbHNEZWVwLCBfY29vcmRzVG9MYXRMbmcpIHtcclxuXHR2YXIgbGF0bG5ncyA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aCwgbGF0bG5nOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGxhdGxuZyA9IGxldmVsc0RlZXAgP1xyXG5cdFx0XHRjb29yZHNUb0xhdExuZ3MoY29vcmRzW2ldLCBsZXZlbHNEZWVwIC0gMSwgX2Nvb3Jkc1RvTGF0TG5nKSA6XHJcblx0XHRcdChfY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcpKGNvb3Jkc1tpXSk7XHJcblxyXG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbGF0bG5ncztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZzogTGF0TG5nLCBwcmVjaXNpb24/OiBOdW1iZXIpOiBBcnJheVxyXG4vLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuZXhwb3J0IGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZywgcHJlY2lzaW9uKSB7XHJcblx0cHJlY2lzaW9uID0gdHlwZW9mIHByZWNpc2lvbiA9PT0gJ251bWJlcicgPyBwcmVjaXNpb24gOiA2O1xyXG5cdHJldHVybiBsYXRsbmcuYWx0ICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0W1V0aWwuZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5sYXQsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5hbHQsIHByZWNpc2lvbildIDpcclxuXHRcdFtVdGlsLmZvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pXTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY2xvc2VkPzogQm9vbGVhbik6IEFycmF5XHJcbi8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcbi8vIGBjbG9zZWRgIGRldGVybWluZXMgd2hldGhlciB0aGUgZmlyc3QgcG9pbnQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IHRvIGNsb3NlIHRoZSBmZWF0dXJlLCBvbmx5IHVzZWQgd2hlbiBgbGV2ZWxzRGVlcGAgaXMgMC4gRmFsc2UgYnkgZGVmYXVsdC5cclxuZXhwb3J0IGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzLCBsZXZlbHNEZWVwLCBjbG9zZWQsIHByZWNpc2lvbikge1xyXG5cdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGNvb3Jkcy5wdXNoKGxldmVsc0RlZXAgP1xyXG5cdFx0XHRsYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIGNsb3NlZCwgcHJlY2lzaW9uKSA6XHJcblx0XHRcdGxhdExuZ1RvQ29vcmRzKGxhdGxuZ3NbaV0sIHByZWNpc2lvbikpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFsZXZlbHNEZWVwICYmIGNsb3NlZCkge1xyXG5cdFx0Y29vcmRzLnB1c2goY29vcmRzWzBdKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb29yZHM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGZWF0dXJlKGxheWVyLCBuZXdHZW9tZXRyeSkge1xyXG5cdHJldHVybiBsYXllci5mZWF0dXJlID9cclxuXHRcdFV0aWwuZXh0ZW5kKHt9LCBsYXllci5mZWF0dXJlLCB7Z2VvbWV0cnk6IG5ld0dlb21ldHJ5fSkgOlxyXG5cdFx0YXNGZWF0dXJlKG5ld0dlb21ldHJ5KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTm9ybWFsaXplIEdlb0pTT04gZ2VvbWV0cmllcy9mZWF0dXJlcyBpbnRvIEdlb0pTT04gZmVhdHVyZXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbikge1xyXG5cdGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyB8fCBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuXHRcdHJldHVybiBnZW9qc29uO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdHByb3BlcnRpZXM6IHt9LFxyXG5cdFx0Z2VvbWV0cnk6IGdlb2pzb25cclxuXHR9O1xyXG59XHJcblxyXG52YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBsYXRMbmdUb0Nvb3Jkcyh0aGlzLmdldExhdExuZygpLCBwcmVjaXNpb24pXHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcmtlclxyXG4vLyBAc2VjdGlvbiBPdGhlciBtZXRob2RzXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcik6IE9iamVjdFxyXG4vLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNiBwbGFjZXMuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG5NYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENpcmNsZU1hcmtlclxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXIpOiBPYmplY3RcclxuLy8gYHByZWNpc2lvbmAgaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgY29vcmRpbmF0ZXMuXHJcbi8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDYgcGxhY2VzLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbkNpcmNsZS5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWxpbmVcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcbi8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG4vLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2IHBsYWNlcy5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlsaW5lIChhcyBhIEdlb0pTT04gYExpbmVTdHJpbmdgIG9yIGBNdWx0aUxpbmVTdHJpbmdgIEZlYXR1cmUpLlxyXG5Qb2x5bGluZS5pbmNsdWRlKHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBtdWx0aSA9ICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncyk7XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDEgOiAwLCBmYWxzZSwgcHJlY2lzaW9uKTtcclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnTGluZVN0cmluZycsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlnb25cclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyKTogT2JqZWN0XHJcbi8vIGBwcmVjaXNpb25gIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxyXG4vLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2IHBsYWNlcy5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlnb24gKGFzIGEgR2VvSlNPTiBgUG9seWdvbmAgb3IgYE11bHRpUG9seWdvbmAgRmVhdHVyZSkuXHJcblBvbHlnb24uaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgaG9sZXMgPSAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpLFxyXG5cdFx0ICAgIG11bHRpID0gaG9sZXMgJiYgIUxpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKTtcclxuXHJcblx0XHR2YXIgY29vcmRzID0gbGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMiA6IGhvbGVzID8gMSA6IDAsIHRydWUsIHByZWNpc2lvbik7XHJcblxyXG5cdFx0aWYgKCFob2xlcykge1xyXG5cdFx0XHRjb29yZHMgPSBbY29vcmRzXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnUG9seWdvbicsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBMYXllckdyb3VwXHJcbkxheWVyR3JvdXAuaW5jbHVkZSh7XHJcblx0dG9NdWx0aVBvaW50OiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ011bHRpUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXIpOiBPYmplY3RcclxuXHQvLyBgcHJlY2lzaW9uYCBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBjb29yZGluYXRlcy5cclxuXHQvLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA2IHBsYWNlcy5cclxuXHQvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXIgZ3JvdXAgKGFzIGEgR2VvSlNPTiBgRmVhdHVyZUNvbGxlY3Rpb25gLCBgR2VvbWV0cnlDb2xsZWN0aW9uYCwgb3IgYE11bHRpUG9pbnRgKS5cclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHJcblx0XHR2YXIgdHlwZSA9IHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5LnR5cGU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50b011bHRpUG9pbnQocHJlY2lzaW9uKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSB0eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcclxuXHRcdCAgICBqc29ucyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRpZiAobGF5ZXIudG9HZW9KU09OKSB7XHJcblx0XHRcdFx0dmFyIGpzb24gPSBsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKTtcclxuXHRcdFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0XHRcdGpzb25zLnB1c2goanNvbi5nZW9tZXRyeSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBmZWF0dXJlID0gYXNGZWF0dXJlKGpzb24pO1xyXG5cdFx0XHRcdFx0Ly8gU3F1YXNoIG5lc3RlZCBmZWF0dXJlIGNvbGxlY3Rpb25zXHJcblx0XHRcdFx0XHRpZiAoZmVhdHVyZS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRcdGpzb25zLnB1c2guYXBwbHkoanNvbnMsIGZlYXR1cmUuZmVhdHVyZXMpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0anNvbnMucHVzaChmZWF0dXJlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdFx0Z2VvbWV0cmllczoganNvbnMsXHJcblx0XHRcdFx0dHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbidcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuXHRcdFx0ZmVhdHVyZXM6IGpzb25zXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIEdlb0pTT05cclxuLy8gQGZhY3RvcnkgTC5nZW9KU09OKGdlb2pzb24/OiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSBHZW9KU09OIGxheWVyLiBPcHRpb25hbGx5IGFjY2VwdHMgYW4gb2JqZWN0IGluXHJcbi8vIFtHZW9KU09OIGZvcm1hdF0oaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5NDYpIHRvIGRpc3BsYXkgb24gdGhlIG1hcFxyXG4vLyAoeW91IGNhbiBhbHRlcm5hdGl2ZWx5IGFkZCBpdCBsYXRlciB3aXRoIGBhZGREYXRhYCBtZXRob2QpIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gZ2VvSlNPTihnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBHZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxyXG5leHBvcnQgdmFyIGdlb0pzb24gPSBnZW9KU09OO1xyXG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEltYWdlT3ZlcmxheVxyXG4gKiBAYWthIEwuSW1hZ2VPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKlxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSBzaW5nbGUgaW1hZ2Ugb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgaW1hZ2VVcmwgPSAnaHR0cDovL3d3dy5saWIudXRleGFzLmVkdS9tYXBzL2hpc3RvcmljYWwvbmV3YXJrX25qXzE5MjIuanBnJyxcclxuICogXHRpbWFnZUJvdW5kcyA9IFtbNDAuNzEyMjE2LCAtNzQuMjI2NTVdLCBbNDAuNzczOTQxLCAtNzQuMTI1NDRdXTtcclxuICogTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmwsIGltYWdlQm91bmRzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEltYWdlT3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbWFnZS5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCB0aGUgaW1hZ2Ugd2lsbCBoYXZlIGl0cyBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBpbWFnZSBwaXhlbCBkYXRhLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yT3ZlcmxheVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgb3ZlcmxheSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSBvdmVybGF5IHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvck92ZXJsYXlVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXHJcblx0XHQvLyBUaGUgZXhwbGljaXQgW3pJbmRleF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL0NTU19Qb3NpdGlvbmluZy9VbmRlcnN0YW5kaW5nX3pfaW5kZXgpIG9mIHRoZSBvdmVybGF5IGxheWVyLlxyXG5cdFx0ekluZGV4OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIGltYWdlLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBMYXRMbmdCb3VuZHMsIE9iamVjdClcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbWFnZSwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cdFx0dGhpcy5fcmVzZXQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5faW1hZ2UpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIG92ZXJsYXkuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuXHRcdGlmIChzdHlsZU9wdHMub3BhY2l0eSkge1xyXG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoc3R5bGVPcHRzLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsKSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IHVybDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fcmVzZXQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXQsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHZhbHVlOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2ltYWdlb3ZlcmxheS16aW5kZXgpIG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdmFsdWU7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIEdldCB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTEltYWdlRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50KVxyXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdJTUcnO1xyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogRG9tVXRpbC5jcmVhdGUoJ2ltZycpO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaW1nLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBEb21VdGlsLmFkZENsYXNzKGltZywgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBEb21VdGlsLmFkZENsYXNzKGltZywgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcblx0XHRpbWcub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdGltZy5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBoYXMgbG9hZGVkIGl0cyBpbWFnZVxyXG5cdFx0aW1nLm9ubG9hZCA9IFV0aWwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XHJcblx0XHRpbWcub25lcnJvciA9IFV0aWwuYmluZCh0aGlzLl9vdmVybGF5T25FcnJvciwgdGhpcywgJ2Vycm9yJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuekluZGV4KSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gaW1nLnNyYztcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcblx0XHRpbWcuYWx0ID0gdGhpcy5vcHRpb25zLmFsdDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKGUuem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fbWFwLl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzKHRoaXMuX2JvdW5kcywgZS56b29tLCBlLmNlbnRlcikubWluO1xyXG5cclxuXHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2ltYWdlLCBvZmZzZXQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxyXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxcclxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcblx0XHRpbWFnZS5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ltYWdlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ltYWdlICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X292ZXJsYXlPbkVycm9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBAZXZlbnQgZXJyb3I6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgZmFpbHMgdG8gbG9hZCBpdHMgaW1hZ2VcclxuXHRcdHRoaXMuZmlyZSgnZXJyb3InKTtcclxuXHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRoaXMuX3VybCAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gZXJyb3JVcmw7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmltYWdlT3ZlcmxheShpbWFnZVVybDogU3RyaW5nLCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IEltYWdlT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgaW1hZ2UgYW5kIHRoZVxyXG4vLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcbmV4cG9ydCB2YXIgaW1hZ2VPdmVybGF5ID0gZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBJbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0ltYWdlT3ZlcmxheX0gZnJvbSAnLi9JbWFnZU92ZXJsYXknO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFZpZGVvT3ZlcmxheVxyXG4gKiBAYWthIEwuVmlkZW9PdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgdmlkZW8gcGxheWVyIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXHJcbiAqXHJcbiAqIEEgdmlkZW8gb3ZlcmxheSB1c2VzIHRoZSBbYDx2aWRlbz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvdmlkZW8pXHJcbiAqIEhUTUw1IGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciB2aWRlb1VybCA9ICdodHRwczovL3d3dy5tYXBib3guY29tL2JpdGVzLzAwMTg4L3BhdHJpY2lhX25hc2Eud2VibScsXHJcbiAqIFx0dmlkZW9Cb3VuZHMgPSBbWyAzMiwgLTEzMF0sIFsgMTMsIC0xMDBdXTtcclxuICogTC52aWRlb092ZXJsYXkodmlkZW9VcmwsIHZpZGVvQm91bmRzICkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBWaWRlb092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFZpZGVvT3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvcGxheTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHN0YXJ0cyBwbGF5aW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBsb2FkZWQuXHJcblx0XHRhdXRvcGxheTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxvb3A6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIGxvb3AgYmFjayB0byB0aGUgYmVnaW5uaW5nIHdoZW4gcGxheWVkLlxyXG5cdFx0bG9vcDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtlZXBBc3BlY3RSYXRpbzogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgc2F2ZSBhc3BlY3QgcmF0aW8gYWZ0ZXIgdGhlIHByb2plY3Rpb24uXHJcblx0XHQvLyBSZWxldmFudCBmb3Igc3VwcG9ydGVkIGJyb3dzZXJzLiBCcm93c2VyIGNvbXBhdGliaWxpdHktIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9vYmplY3QtZml0XHJcblx0XHRrZWVwQXNwZWN0UmF0aW86IHRydWVcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdWSURFTyc7XHJcblx0XHR2YXIgdmlkID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBEb21VdGlsLmNyZWF0ZSgndmlkZW8nKTtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgRG9tVXRpbC5hZGRDbGFzcyh2aWQsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgRG9tVXRpbC5hZGRDbGFzcyh2aWQsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG5cdFx0dmlkLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHR2aWQub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWRlbyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgZmlyc3QgZnJhbWVcclxuXHRcdHZpZC5vbmxvYWRlZGRhdGEgPSBVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dmFyIHNvdXJjZUVsZW1lbnRzID0gdmlkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzb3VyY2UnKTtcclxuXHRcdFx0dmFyIHNvdXJjZXMgPSBbXTtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2VFbGVtZW50c1tqXS5zcmMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl91cmwgPSAoc291cmNlRWxlbWVudHMubGVuZ3RoID4gMCkgPyBzb3VyY2VzIDogW3ZpZC5zcmNdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFVdGlsLmlzQXJyYXkodGhpcy5fdXJsKSkgeyB0aGlzLl91cmwgPSBbdGhpcy5fdXJsXTsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmtlZXBBc3BlY3RSYXRpbyAmJiB2aWQuc3R5bGUuaGFzT3duUHJvcGVydHkoJ29iamVjdEZpdCcpKSB7IHZpZC5zdHlsZVsnb2JqZWN0Rml0J10gPSAnZmlsbCc7IH1cclxuXHRcdHZpZC5hdXRvcGxheSA9ICEhdGhpcy5vcHRpb25zLmF1dG9wbGF5O1xyXG5cdFx0dmlkLmxvb3AgPSAhIXRoaXMub3B0aW9ucy5sb29wO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl91cmwubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIHNvdXJjZSA9IERvbVV0aWwuY3JlYXRlKCdzb3VyY2UnKTtcclxuXHRcdFx0c291cmNlLnNyYyA9IHRoaXMuX3VybFtpXTtcclxuXHRcdFx0dmlkLmFwcGVuZENoaWxkKHNvdXJjZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogSFRNTFZpZGVvRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTFZpZGVvRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MVmlkZW9FbGVtZW50KVxyXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnZpZGVvT3ZlcmxheSh2aWRlbzogU3RyaW5nfEFycmF5fEhUTUxWaWRlb0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogVmlkZW9PdmVybGF5IG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSB2aWRlbyAob3IgYXJyYXkgb2YgVVJMcywgb3IgZXZlbiBhIHZpZGVvIGVsZW1lbnQpIGFuZCB0aGVcclxuLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHZpZGVvT3ZlcmxheSh2aWRlbywgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBWaWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtJbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQGNsYXNzIFNWR092ZXJsYXlcbiAqIEBha2EgTC5TVkdPdmVybGF5XG4gKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XG4gKlxuICogVXNlZCB0byBsb2FkLCBkaXNwbGF5IGFuZCBwcm92aWRlIERPTSBhY2Nlc3MgdG8gYW4gU1ZHIGZpbGUgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cbiAqXG4gKiBBbiBTVkcgb3ZlcmxheSB1c2VzIHRoZSBbYDxzdmc+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvc3ZnKSBlbGVtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIHZhciBzdmdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XG4gKiBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgneG1sbnMnLCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpO1xuICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBcIjAgMCAyMDAgMjAwXCIpO1xuICogc3ZnRWxlbWVudC5pbm5lckhUTUwgPSAnPHJlY3Qgd2lkdGg9XCIyMDBcIiBoZWlnaHQ9XCIyMDBcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjIzXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgc3R5bGU9XCJmaWxsOnJlZFwiLz48cmVjdCB4PVwiNzVcIiB5PVwiMTIzXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgc3R5bGU9XCJmaWxsOiMwMDEzZmZcIi8+JztcbiAqIHZhciBzdmdFbGVtZW50Qm91bmRzID0gWyBbIDMyLCAtMTMwIF0sIFsgMTMsIC0xMDAgXSBdO1xuICogTC5zdmdPdmVybGF5KHN2Z0VsZW1lbnQsIHN2Z0VsZW1lbnRCb3VuZHMpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNWR092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlbCA9IHRoaXMuX2ltYWdlID0gdGhpcy5fdXJsO1xuXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhlbCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IERvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IERvbVV0aWwuYWRkQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XG5cblx0XHRlbC5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xuXHRcdGVsLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xuXHR9XG5cblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IFNWR0VsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BTVkdFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5zdmdPdmVybGF5KHN2ZzogU3RyaW5nfFNWR0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogU1ZHT3ZlcmxheSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIGFuIFNWRyBlbGVtZW50IGFuZCB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxuLy8gQSB2aWV3Qm94IGF0dHJpYnV0ZSBpcyByZXF1aXJlZCBvbiB0aGUgU1ZHIGVsZW1lbnQgdG8gem9vbSBpbiBhbmQgb3V0IHByb3Blcmx5LlxuXG5leHBvcnQgZnVuY3Rpb24gc3ZnT3ZlcmxheShlbCwgYm91bmRzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgU1ZHT3ZlcmxheShlbCwgYm91bmRzLCBvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRGl2T3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICogQGFrYSBMLkRpdk92ZXJsYXlcclxuICogQmFzZSBtb2RlbCBmb3IgTC5Qb3B1cCBhbmQgTC5Ub29sdGlwLiBJbmhlcml0IGZyb20gaXQgZm9yIGN1c3RvbSBwb3B1cCBsaWtlIHBsdWdpbnMuXHJcbiAqL1xyXG5cclxuLy8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbmV4cG9ydCB2YXIgRGl2T3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBEaXZPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCA3KVxyXG5cdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uIFVzZWZ1bCB0byBjb250cm9sIHRoZSBhbmNob3JcclxuXHRcdC8vIG9mIHRoZSBwb3B1cCB3aGVuIG9wZW5pbmcgaXQgb24gc29tZSBvdmVybGF5cy5cclxuXHRcdG9mZnNldDogWzAsIDddLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuXHRcdGNsYXNzTmFtZTogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAncG9wdXBQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6ICdwb3B1cFBhbmUnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlVGltZW91dCk7XHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5icmluZ1RvRnJvbnQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQoRG9tVXRpbC5yZW1vdmUsIHVuZGVmaW5lZCwgdGhpcy5fY29udGFpbmVyKSwgMjAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgb2YgcG9wdXAuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBvcGVuLlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHRcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwLlxyXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Q29udGVudChodG1sQ29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgcG9wdXAuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgcG9wdXAuXHJcblx0c2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gQWxpYXMgZm9yIFtnZXRDb250ZW50KCldKCNwb3B1cC1nZXRjb250ZW50KVxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1cGRhdGU6IG51bGxcclxuXHQvLyBVcGRhdGVzIHRoZSBwb3B1cCBjb250ZW50LCBsYXlvdXQgYW5kIHBvc2l0aW9uLiBVc2VmdWwgZm9yIHVwZGF0aW5nIHRoZSBwb3B1cCBhZnRlciBzb21ldGhpbmcgaW5zaWRlIGNoYW5nZWQsIGUuZy4gaW1hZ2UgbG9hZGVkLlxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcblx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XHJcblx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuXHJcblx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3VwZGF0ZVBvc2l0aW9uLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNPcGVuOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgcG9wdXAgaXMgdmlzaWJsZSBvbiB0aGUgbWFwLlxyXG5cdGlzT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGlzIHBvcHVwIGluIGZyb250IG9mIG90aGVyIHBvcHVwcyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBwb3B1cCB0byB0aGUgYmFjayBvZiBvdGhlciBwb3B1cHMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3ByZXBhcmVPcGVuOiBmdW5jdGlvbiAocGFyZW50LCBsYXllciwgbGF0bG5nKSB7XHJcblx0XHRpZiAoIShsYXllciBpbnN0YW5jZW9mIExheWVyKSkge1xyXG5cdFx0XHRsYXRsbmcgPSBsYXllcjtcclxuXHRcdFx0bGF5ZXIgPSBwYXJlbnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSB7XHJcblx0XHRcdGZvciAodmFyIGlkIGluIHBhcmVudC5fbGF5ZXJzKSB7XHJcblx0XHRcdFx0bGF5ZXIgPSBwYXJlbnQuX2xheWVyc1tpZF07XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxhdGxuZykge1xyXG5cdFx0XHRpZiAobGF5ZXIuZ2V0Q2VudGVyKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gbGF5ZXIuZ2V0Q2VudGVyKCk7XHJcblx0XHRcdH0gZWxzZSBpZiAobGF5ZXIuZ2V0TGF0TG5nKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gbGF5ZXIuZ2V0TGF0TG5nKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IHNvdXJjZSBsYXllciBMYXRMbmcuJyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZXQgb3ZlcmxheSBzb3VyY2UgdG8gdGhpcyBsYXllclxyXG5cdFx0dGhpcy5fc291cmNlID0gbGF5ZXI7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIHRoZSBvdmVybGF5IChjb250ZW50LCBsYXlvdXQsIGVjdC4uLilcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdGxuZztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlQ29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250ZW50KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBub2RlID0gdGhpcy5fY29udGVudE5vZGU7XHJcblx0XHR2YXIgY29udGVudCA9ICh0eXBlb2YgdGhpcy5fY29udGVudCA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLl9jb250ZW50KHRoaXMuX3NvdXJjZSB8fCB0aGlzKSA6IHRoaXMuX2NvbnRlbnQ7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRub2RlLmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuXHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHRoaXMuZmlyZSgnY29udGVudHVwZGF0ZScpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuXHRcdCAgICBsZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueDtcclxuXHJcblx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIHBvcHVwIGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgY2hhbmdlcyAoaW1hZ2VzIGxvYWRpbmcgZXRjKVxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IGJvdHRvbSArICdweCc7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbMCwgMF07XHJcblx0fVxyXG5cclxufSk7XHJcbiIsImltcG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BhdGh9IGZyb20gJy4vdmVjdG9yL1BhdGgnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFBvcHVwXHJcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XHJcbiAqIEBha2EgTC5Qb3B1cFxyXG4gKiBVc2VkIHRvIG9wZW4gcG9wdXBzIGluIGNlcnRhaW4gcGxhY2VzIG9mIHRoZSBtYXAuIFVzZSBbTWFwLm9wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIHRvXHJcbiAqIG9wZW4gcG9wdXBzIHdoaWxlIG1ha2luZyBzdXJlIHRoYXQgb25seSBvbmUgcG9wdXAgaXMgb3BlbiBhdCBvbmUgdGltZVxyXG4gKiAocmVjb21tZW5kZWQgZm9yIHVzYWJpbGl0eSksIG9yIHVzZSBbTWFwLmFkZExheWVyXSgjbWFwLWFkZGxheWVyKSB0byBvcGVuIGFzIG1hbnkgYXMgeW91IHdhbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHBvcHVwIHRvIG1hcmtlciBjbGljayBhbmQgdGhlbiBvcGVuIGl0LCBpdCdzIHJlYWxseSBlYXN5OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXJrZXIuYmluZFBvcHVwKHBvcHVwQ29udGVudCkub3BlblBvcHVwKCk7XHJcbiAqIGBgYFxyXG4gKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kUG9wdXBgIG1ldGhvZC5cclxuICogSGVyZSdzIGEgbW9yZSBjb21wbGljYXRlZCB3YXkgdG8gb3BlbiBhIHBvcHVwIG9uIGEgbWFwOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9wdXAgPSBMLnBvcHVwKClcclxuICogXHQuc2V0TGF0TG5nKGxhdGxuZylcclxuICogXHQuc2V0Q29udGVudCgnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAqIFx0Lm9wZW5PbihtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG5leHBvcnQgdmFyIFBvcHVwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDMwMFxyXG5cdFx0Ly8gTWF4IHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWF4V2lkdGg6IDMwMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pbldpZHRoOiBOdW1iZXIgPSA1MFxyXG5cdFx0Ly8gTWluIHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG5cdFx0bWluV2lkdGg6IDUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4SGVpZ2h0OiBOdW1iZXIgPSBudWxsXHJcblx0XHQvLyBJZiBzZXQsIGNyZWF0ZXMgYSBzY3JvbGxhYmxlIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0XHJcblx0XHQvLyBpbnNpZGUgYSBwb3B1cCBpZiBpdHMgY29udGVudCBleGNlZWRzIGl0LlxyXG5cdFx0bWF4SGVpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gZG8gcGFubmluZyBhbmltYXRpb25cclxuXHRcdC8vIHRvIGZpdCB0aGUgb3BlbmVkIHBvcHVwLlxyXG5cdFx0YXV0b1BhbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUsIDUpXHJcblx0XHQvLyBFcXVpdmFsZW50IG9mIHNldHRpbmcgYm90aCB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGF1dG9wYW4gcGFkZGluZyB0byB0aGUgc2FtZSB2YWx1ZS5cclxuXHRcdGF1dG9QYW5QYWRkaW5nOiBbNSwgNV0sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZWVwSW5WaWV3OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFNldCBpdCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gcHJldmVudCB1c2VycyBmcm9tIHBhbm5pbmcgdGhlIHBvcHVwXHJcblx0XHQvLyBvZmYgb2YgdGhlIHNjcmVlbiB3aGlsZSBpdCBpcyBvcGVuLlxyXG5cdFx0a2VlcEluVmlldzogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZUJ1dHRvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIENvbnRyb2xzIHRoZSBwcmVzZW5jZSBvZiBhIGNsb3NlIGJ1dHRvbiBpbiB0aGUgcG9wdXAuXHJcblx0XHRjbG9zZUJ1dHRvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9DbG9zZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcblx0XHQvLyB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG5cdFx0YXV0b0Nsb3NlOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VPbkVzY2FwZUtleTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcblx0XHQvLyB0aGUgRVNDIGtleSBmb3IgY2xvc2luZyBvZiB0aGUgcG9wdXAuXHJcblx0XHRjbG9zZU9uRXNjYXBlS2V5OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VPbkNsaWNrOiBCb29sZWFuID0gKlxyXG5cdFx0Ly8gU2V0IGl0IGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gdXNlciBjbGlja3NcclxuXHRcdC8vIG9uIHRoZSBtYXAuIERlZmF1bHRzIHRvIHRoZSBtYXAncyBbYGNsb3NlUG9wdXBPbkNsaWNrYF0oI21hcC1jbG9zZXBvcHVwb25jbGljaykgb3B0aW9uLlxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuXHRcdGNsYXNzTmFtZTogJydcclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcblx0Ly8gQG1ldGhvZCBvcGVuT24obWFwOiBNYXApOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgcG9wdXAgdG8gdGhlIG1hcCBhbmQgY2xvc2VzIHRoZSBwcmV2aW91cyBvbmUuIFRoZSBzYW1lIGFzIGBtYXAub3BlblBvcHVwKHBvcHVwKWAuXHJcblx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub3BlblBvcHVwKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0Ly8gRm9yIG5vbi1wYXRoIGxheWVycywgd2UgdG9nZ2xlIHRoZSBwb3B1cCB3aGVuIGNsaWNraW5nXHJcblx0XHRcdC8vIGFnYWluIHRoZSBsYXllciwgc28gcHJldmVudCB0aGUgbWFwIHRvIHJlb3BlbiBpdC5cclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub24oJ3ByZWNsaWNrJywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpbiB0aGUgbWFwIGlzIGNsb3NlZFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vZmYoJ3ByZWNsaWNrJywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICE9PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdGV2ZW50cy5tb3ZlZW5kID0gdGhpcy5fYWRqdXN0UGFuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5jbG9zZVBvcHVwKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtcG9wdXAnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLFxyXG5cdFx0XHRwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgK1xyXG5cdFx0XHQnIGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cclxuXHRcdHZhciB3cmFwcGVyID0gdGhpcy5fd3JhcHBlciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQtd3JhcHBlcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQnLCB3cmFwcGVyKTtcclxuXHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih3cmFwcGVyKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSk7XHJcblx0XHREb21FdmVudC5vbih3cmFwcGVyLCAnY29udGV4dG1lbnUnLCBEb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cclxuXHRcdHRoaXMuX3RpcENvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcC1jb250YWluZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fdGlwID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwJywgdGhpcy5fdGlwQ29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uKSB7XHJcblx0XHRcdHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuX2Nsb3NlQnV0dG9uID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBwcmVmaXggKyAnLWNsb3NlLWJ1dHRvbicsIGNvbnRhaW5lcik7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmhyZWYgPSAnI2Nsb3NlJztcclxuXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJyYjMjE1Oyc7XHJcblxyXG5cdFx0XHREb21FdmVudC5vbihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgdGhpcy5fb25DbG9zZUJ1dHRvbkNsaWNrLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGVudE5vZGUsXHJcblx0XHQgICAgc3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAnJztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcclxuXHJcblx0XHR2YXIgd2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0XHR3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLm9wdGlvbnMubWF4V2lkdGgpO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICh3aWR0aCArIDEpICsgJ3B4JztcclxuXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnJztcclxuXHJcblx0XHRzdHlsZS5oZWlnaHQgPSAnJztcclxuXHJcblx0XHR2YXIgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuXHRcdCAgICBtYXhIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0LFxyXG5cdFx0ICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCc7XHJcblxyXG5cdFx0aWYgKG1heEhlaWdodCAmJiBoZWlnaHQgPiBtYXhIZWlnaHQpIHtcclxuXHRcdFx0c3R5bGUuaGVpZ2h0ID0gbWF4SGVpZ2h0ICsgJ3B4JztcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0fSxcclxuXHJcblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXV0b1BhbikgeyByZXR1cm47IH1cclxuXHRcdGlmICh0aGlzLl9tYXAuX3BhbkFuaW0pIHsgdGhpcy5fbWFwLl9wYW5BbmltLnN0b3AoKTsgfVxyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgbWFyZ2luQm90dG9tID0gcGFyc2VJbnQoRG9tVXRpbC5nZXRTdHlsZSh0aGlzLl9jb250YWluZXIsICdtYXJnaW5Cb3R0b20nKSwgMTApIHx8IDAsXHJcblx0XHQgICAgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCArIG1hcmdpbkJvdHRvbSxcclxuXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG5cdFx0ICAgIGxheWVyUG9zID0gbmV3IFBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xyXG5cclxuXHRcdGxheWVyUG9zLl9hZGQoRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyUG9zID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KGxheWVyUG9zKSxcclxuXHRcdCAgICBwYWRkaW5nID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdUTCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHNpemUgPSBtYXAuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIGR4ID0gMCxcclxuXHRcdCAgICBkeSA9IDA7XHJcblxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkgeyAvLyByaWdodFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggLSBzaXplLnggKyBwYWRkaW5nQlIueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueCAtIGR4IC0gcGFkZGluZ1RMLnggPCAwKSB7IC8vIGxlZnRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgLSBzaXplLnkgKyBwYWRkaW5nQlIueTtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7IC8vIHRvcFxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55IC0gcGFkZGluZ1RMLnk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGF1dG9wYW5zdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgYXV0b3Bhbm5pbmcgd2hlbiBvcGVuaW5nIGEgcG9wdXAuXHJcblx0XHRpZiAoZHggfHwgZHkpIHtcclxuXHRcdFx0bWFwXHJcblx0XHRcdCAgICAuZmlyZSgnYXV0b3BhbnN0YXJ0JylcclxuXHRcdFx0ICAgIC5wYW5CeShbZHgsIGR5XSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uQ2xvc2VCdXR0b25DbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX2Nsb3NlKCk7XHJcblx0XHREb21FdmVudC5zdG9wKGUpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHBvcHVwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XHJcblx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvciA/IHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IoKSA6IFswLCAwXSk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvcHVwXHJcbi8vIEBmYWN0b3J5IEwucG9wdXAob3B0aW9ucz86IFBvcHVwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBgUG9wdXBgIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHBvcHVwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cclxuZXhwb3J0IHZhciBwb3B1cCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRyZXR1cm4gbmV3IFBvcHVwKG9wdGlvbnMsIHNvdXJjZSk7XHJcbn07XHJcblxyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG4gKiBAb3B0aW9uIGNsb3NlUG9wdXBPbkNsaWNrOiBCb29sZWFuID0gdHJ1ZVxyXG4gKiBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCBwb3B1cHMgdG8gY2xvc2Ugd2hlbiB1c2VyIGNsaWNrcyB0aGUgbWFwLlxyXG4gKi9cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0Y2xvc2VQb3B1cE9uQ2xpY2s6IHRydWVcclxufSk7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAocG9wdXA6IFBvcHVwKTogdGhpc1xyXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgcG9wdXAgd2hpbGUgY2xvc2luZyB0aGUgcHJldmlvdXNseSBvcGVuZWQgKHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBpcyBvcGVuZWQgYXQgb25lIHRpbWUgZm9yIHVzYWJpbGl0eSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ3JlYXRlcyBhIHBvcHVwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVucyBpdCBpbiB0aGUgZ2l2ZW4gcG9pbnQgb24gYSBtYXAuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAocG9wdXAsIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0aWYgKCEocG9wdXAgaW5zdGFuY2VvZiBQb3B1cCkpIHtcclxuXHRcdFx0cG9wdXAgPSBuZXcgUG9wdXAob3B0aW9ucykuc2V0Q29udGVudChwb3B1cCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhdGxuZykge1xyXG5cdFx0XHRwb3B1cC5zZXRMYXRMbmcobGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihwb3B1cCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX3BvcHVwLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XHJcblx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3BvcHVwID0gcG9wdXA7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihwb3B1cCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKHBvcHVwPzogUG9wdXApOiB0aGlzXHJcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBwcmV2aW91c2x5IG9wZW5lZCB3aXRoIFtvcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSAob3IgdGhlIGdpdmVuIG9uZSkuXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKHBvcHVwKSB7XHJcblx0XHRpZiAoIXBvcHVwIHx8IHBvcHVwID09PSB0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRwb3B1cCA9IHRoaXMuX3BvcHVwO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRpZiAocG9wdXApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVMYXllcihwb3B1cCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBMYXllclxyXG4gKiBAc2VjdGlvbiBQb3B1cCBtZXRob2RzIGV4YW1wbGVcclxuICpcclxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgcG9wdXBzIHRvIGl0LlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFBvcHVwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xyXG4gKiBsYXllci5vcGVuUG9wdXAoKTtcclxuICogbGF5ZXIuY2xvc2VQb3B1cCgpO1xyXG4gKiBgYGBcclxuICpcclxuICogUG9wdXBzIHdpbGwgYWxzbyBiZSBhdXRvbWF0aWNhbGx5IG9wZW5lZCB3aGVuIHRoZSBsYXllciBpcyBjbGlja2VkIG9uIGFuZCBjbG9zZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgb3IgYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcbiAqL1xyXG5cclxuLy8gQHNlY3Rpb24gUG9wdXAgbWV0aG9kc1xyXG5MYXllci5pbmNsdWRlKHtcclxuXHJcblx0Ly8gQG1ldGhvZCBiaW5kUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFBvcHVwLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBCaW5kcyBhIHBvcHVwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxyXG5cdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXHJcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXHJcblx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG5cclxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgUG9wdXApIHtcclxuXHRcdFx0VXRpbC5zZXRPcHRpb25zKGNvbnRlbnQsIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IGNvbnRlbnQ7XHJcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoIXRoaXMuX3BvcHVwIHx8IG9wdGlvbnMpIHtcclxuXHRcdFx0XHR0aGlzLl9wb3B1cCA9IG5ldyBQb3B1cChvcHRpb25zLCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XHJcblx0XHRcdHRoaXMub24oe1xyXG5cdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcblx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXHJcblx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5iaW5kUG9wdXAoKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFBvcHVwYC5cclxuXHR1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMub2ZmKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgYm91bmQgcG9wdXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCBwb3B1cCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKGxheWVyLCBsYXRsbmcpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9tYXApIHtcclxuXHRcdFx0bGF0bG5nID0gdGhpcy5fcG9wdXAuX3ByZXBhcmVPcGVuKHRoaXMsIGxheWVyLCBsYXRsbmcpO1xyXG5cclxuXHRcdFx0Ly8gb3BlbiB0aGUgcG9wdXAgb24gdGhlIG1hcFxyXG5cdFx0XHR0aGlzLl9tYXAub3BlblBvcHVwKHRoaXMuX3BvcHVwLCBsYXRsbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cCgpOiB0aGlzXHJcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLl9jbG9zZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b2dnbGVQb3B1cCgpOiB0aGlzXHJcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cclxuXHR0b2dnbGVQb3B1cDogZnVuY3Rpb24gKHRhcmdldCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdGlmICh0aGlzLl9wb3B1cC5fbWFwKSB7XHJcblx0XHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5vcGVuUG9wdXAodGFyZ2V0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc1BvcHVwT3BlbigpOiBib29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXHJcblx0aXNQb3B1cE9wZW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAodGhpcy5fcG9wdXAgPyB0aGlzLl9wb3B1cC5pc09wZW4oKSA6IGZhbHNlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBvcHVwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8UG9wdXApOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuXHRzZXRQb3B1cENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UG9wdXAoKTogUG9wdXBcclxuXHQvLyBSZXR1cm5zIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxyXG5cdGdldFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcG9wdXA7XHJcblx0fSxcclxuXHJcblx0X29wZW5Qb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHByZXZlbnQgbWFwIGNsaWNrXHJcblx0XHREb21FdmVudC5zdG9wKGUpO1xyXG5cclxuXHRcdC8vIGlmIHRoaXMgaW5oZXJpdHMgZnJvbSBQYXRoIGl0cyBhIHZlY3RvciBhbmQgd2UgY2FuIGp1c3RcclxuXHRcdC8vIG9wZW4gdGhlIHBvcHVwIGF0IHRoZSBuZXcgbG9jYXRpb25cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIFBhdGgpIHtcclxuXHRcdFx0dGhpcy5vcGVuUG9wdXAoZS5sYXllciB8fCBlLnRhcmdldCwgZS5sYXRsbmcpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb3RoZXJ3aXNlIHRyZWF0IGl0IGxpa2UgYSBtYXJrZXIgYW5kIGZpZ3VyZSBvdXRcclxuXHRcdC8vIGlmIHdlIHNob3VsZCB0b2dnbGUgaXQgb3Blbi9jbG9zZWRcclxuXHRcdGlmICh0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcy5fcG9wdXApICYmIHRoaXMuX3BvcHVwLl9zb3VyY2UgPT09IGxheWVyKSB7XHJcblx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5vcGVuUG9wdXAobGF5ZXIsIGUubGF0bG5nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZVBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKGUubGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRfb25LZXlQcmVzczogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmIChlLm9yaWdpbmFsRXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcclxuXHRcdFx0dGhpcy5fb3BlblBvcHVwKGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcbiIsIlxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIFRvb2x0aXBcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XG4gKiBAYWthIEwuVG9vbHRpcFxuICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIG1hcmtlci5iaW5kVG9vbHRpcChcIm15IHRvb2x0aXAgdGV4dFwiKS5vcGVuVG9vbHRpcCgpO1xuICogYGBgXG4gKiBOb3RlIGFib3V0IHRvb2x0aXAgb2Zmc2V0LiBMZWFmbGV0IHRha2VzIHR3byBvcHRpb25zIGluIGNvbnNpZGVyYXRpb25cbiAqIGZvciBjb21wdXRpbmcgdG9vbHRpcCBvZmZzZXR0aW5nOlxuICogLSB0aGUgYG9mZnNldGAgVG9vbHRpcCBvcHRpb246IGl0IGRlZmF1bHRzIHRvIFswLCAwXSwgYW5kIGl0J3Mgc3BlY2lmaWMgdG8gb25lIHRvb2x0aXAuXG4gKiAgIEFkZCBhIHBvc2l0aXZlIHggb2Zmc2V0IHRvIG1vdmUgdGhlIHRvb2x0aXAgdG8gdGhlIHJpZ2h0LCBhbmQgYSBwb3NpdGl2ZSB5IG9mZnNldCB0b1xuICogICBtb3ZlIGl0IHRvIHRoZSBib3R0b20uIE5lZ2F0aXZlcyB3aWxsIG1vdmUgdG8gdGhlIGxlZnQgYW5kIHRvcC5cbiAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAqICAgc2hvdWxkIGFkYXB0IHRoaXMgdmFsdWUgaWYgeW91IHVzZSBhIGN1c3RvbSBpY29uLlxuICovXG5cblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG5leHBvcnQgdmFyIFRvb2x0aXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBUb29sdGlwIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3Rvb2x0aXBQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHRvb2x0aXAgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndG9vbHRpcFBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcblx0XHQvLyBPcHRpb25hbCBvZmZzZXQgb2YgdGhlIHRvb2x0aXAgcG9zaXRpb24uXG5cdFx0b2Zmc2V0OiBbMCwgMF0sXG5cblx0XHQvLyBAb3B0aW9uIGRpcmVjdGlvbjogU3RyaW5nID0gJ2F1dG8nXG5cdFx0Ly8gRGlyZWN0aW9uIHdoZXJlIHRvIG9wZW4gdGhlIHRvb2x0aXAuIFBvc3NpYmxlIHZhbHVlcyBhcmU6IGByaWdodGAsIGBsZWZ0YCxcblx0XHQvLyBgdG9wYCwgYGJvdHRvbWAsIGBjZW50ZXJgLCBgYXV0b2AuXG5cdFx0Ly8gYGF1dG9gIHdpbGwgZHluYW1pY2FsbHkgc3dpdGNoIGJldHdlZW4gYHJpZ2h0YCBhbmQgYGxlZnRgIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcFxuXHRcdC8vIHBvc2l0aW9uIG9uIHRoZSBtYXAuXG5cdFx0ZGlyZWN0aW9uOiAnYXV0bycsXG5cblx0XHQvLyBAb3B0aW9uIHBlcm1hbmVudDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0byBvcGVuIHRoZSB0b29sdGlwIHBlcm1hbmVudGx5IG9yIG9ubHkgb24gbW91c2VvdmVyLlxuXHRcdHBlcm1hbmVudDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHN0aWNreTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBmb2xsb3cgdGhlIG1vdXNlIGluc3RlYWQgb2YgYmVpbmcgZml4ZWQgYXQgdGhlIGZlYXR1cmUgY2VudGVyLlxuXHRcdHN0aWNreTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGxpc3RlbiB0byB0aGUgZmVhdHVyZSBldmVudHMuXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAwLjlcblx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBvcGFjaXR5LlxuXHRcdG9wYWNpdHk6IDAuOVxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuXHRcdHRoaXMuc2V0T3BhY2l0eSh0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpcyBvcGVuZWQgaW4gdGhlIG1hcC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGluIHRoZSBtYXAgaXMgY2xvc2VkLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKEJyb3dzZXIudG91Y2ggJiYgIXRoaXMub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuX2Nsb3NlO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fbWFwLmNsb3NlVG9vbHRpcCh0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtdG9vbHRpcCcsXG5cdFx0ICAgIGNsYXNzTmFtZSA9IHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArICcgbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XG5cblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpO1xuXHR9LFxuXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9zZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgY2VudGVyUG9pbnQgPSBtYXAubGF0TG5nVG9Db250YWluZXJQb2ludChtYXAuZ2V0Q2VudGVyKCkpLFxuXHRcdCAgICB0b29sdGlwUG9pbnQgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9zKSxcblx0XHQgICAgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbixcblx0XHQgICAgdG9vbHRpcFdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoLFxuXHRcdCAgICB0b29sdGlwSGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XG5cblx0XHRpZiAoZGlyZWN0aW9uID09PSAndG9wJykge1xuXHRcdFx0cG9zID0gcG9zLmFkZCh0b1BvaW50KC10b29sdGlwV2lkdGggLyAyICsgb2Zmc2V0LngsIC10b29sdGlwSGVpZ2h0ICsgb2Zmc2V0LnkgKyBhbmNob3IueSwgdHJ1ZSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJykge1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQodG9vbHRpcFdpZHRoIC8gMiAtIG9mZnNldC54LCAtb2Zmc2V0LnksIHRydWUpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHRvb2x0aXBXaWR0aCAvIDIgKyBvZmZzZXQueCwgdG9vbHRpcEhlaWdodCAvIDIgLSBhbmNob3IueSArIG9mZnNldC55LCB0cnVlKSk7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcgfHwgZGlyZWN0aW9uID09PSAnYXV0bycgJiYgdG9vbHRpcFBvaW50LnggPCBjZW50ZXJQb2ludC54KSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAncmlnaHQnO1xuXHRcdFx0cG9zID0gcG9zLmFkZCh0b1BvaW50KG9mZnNldC54ICsgYW5jaG9yLngsIGFuY2hvci55IC0gdG9vbHRpcEhlaWdodCAvIDIgKyBvZmZzZXQueSwgdHJ1ZSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAnbGVmdCc7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludCh0b29sdGlwV2lkdGggKyBhbmNob3IueCAtIG9mZnNldC54LCB0b29sdGlwSGVpZ2h0IC8gMiAtIGFuY2hvci55IC0gb2Zmc2V0LnksIHRydWUpKTtcblx0XHR9XG5cblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1yaWdodCcpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWxlZnQnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC10b3AnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1ib3R0b20nKTtcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC0nICsgZGlyZWN0aW9uKTtcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgcG9zKTtcblx0fSxcblxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCBvcGFjaXR5KTtcblx0XHR9XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHRvb2x0aXAgb24gdGhlIHNvdXJjZSBsYXllcj9cblx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yICYmICF0aGlzLm9wdGlvbnMuc3RpY2t5ID8gdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yKCkgOiBbMCwgMF0pO1xuXHR9XG5cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbi8vIEBmYWN0b3J5IEwudG9vbHRpcChvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcbi8vIEluc3RhbnRpYXRlcyBhIFRvb2x0aXAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgdG9vbHRpcCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXG5leHBvcnQgdmFyIHRvb2x0aXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG5cdHJldHVybiBuZXcgVG9vbHRpcChvcHRpb25zLCBzb3VyY2UpO1xufTtcblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbk1hcC5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cblx0Ly8gQGFsdGVybmF0aXZlXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0aWYgKCEodG9vbHRpcCBpbnN0YW5jZW9mIFRvb2x0aXApKSB7XG5cdFx0XHR0b29sdGlwID0gbmV3IFRvb2x0aXAob3B0aW9ucykuc2V0Q29udGVudCh0b29sdGlwKTtcblx0XHR9XG5cblx0XHRpZiAobGF0bG5nKSB7XG5cdFx0XHR0b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmhhc0xheWVyKHRvb2x0aXApKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcih0b29sdGlwKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCh0b29sdGlwPzogVG9vbHRpcCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGdpdmVuIGFzIHBhcmFtZXRlci5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCkge1xuXHRcdGlmICh0b29sdGlwKSB7XG5cdFx0XHR0aGlzLnJlbW92ZUxheWVyKHRvb2x0aXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG59KTtcblxuLypcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAqIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kcyBleGFtcGxlXG4gKlxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgdG9vbHRpcHMgdG8gaXQuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kVG9vbHRpcCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAqIGxheWVyLm9wZW5Ub29sdGlwKCk7XG4gKiBsYXllci5jbG9zZVRvb2x0aXAoKTtcbiAqIGBgYFxuICovXG5cbi8vIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kc1xuTGF5ZXIuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBiaW5kVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258VG9vbHRpcCwgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQmluZHMgYSB0b29sdGlwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cblx0YmluZFRvb2x0aXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIFRvb2x0aXApIHtcblx0XHRcdFV0aWwuc2V0T3B0aW9ucyhjb250ZW50LCBvcHRpb25zKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBjb250ZW50O1xuXHRcdFx0Y29udGVudC5fc291cmNlID0gdGhpcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8IG9wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5fdG9vbHRpcCA9IG5ldyBUb29sdGlwKG9wdGlvbnMsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMoKTtcblxuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50ICYmIHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcykpIHtcblx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHVuYmluZFRvb2x0aXAoKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSB0b29sdGlwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFRvb2x0aXBgLlxuXHR1bmJpbmRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKHRydWUpO1xuXHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfaW5pdFRvb2x0aXBJbnRlcmFjdGlvbnM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcblx0XHRpZiAoIXJlbW92ZSAmJiB0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCkgeyByZXR1cm47IH1cblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyAnb2ZmJyA6ICdvbicsXG5cdFx0ICAgIGV2ZW50cyA9IHtcblx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVRvb2x0aXAsXG5cdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlVG9vbHRpcFxuXHRcdCAgICB9O1xuXHRcdGlmICghdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3ZlciA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3V0ID0gdGhpcy5jbG9zZVRvb2x0aXA7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSkge1xuXHRcdFx0XHRldmVudHMubW91c2Vtb3ZlID0gdGhpcy5fbW92ZVRvb2x0aXA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoQnJvd3Nlci50b3VjaCkge1xuXHRcdFx0XHRldmVudHMuY2xpY2sgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXZlbnRzLmFkZCA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdH1cblx0XHR0aGlzW29uT2ZmXShldmVudHMpO1xuXHRcdHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkID0gIXJlbW92ZTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHRvb2x0aXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCB0b29sdGlwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAobGF5ZXIsIGxhdGxuZykge1xuXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuX21hcCkge1xuXHRcdFx0bGF0bG5nID0gdGhpcy5fdG9vbHRpcC5fcHJlcGFyZU9wZW4odGhpcywgbGF5ZXIsIGxhdGxuZyk7XG5cblx0XHRcdC8vIG9wZW4gdGhlIHRvb2x0aXAgb24gdGhlIG1hcFxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Ub29sdGlwKHRoaXMuX3Rvb2x0aXAsIGxhdGxuZyk7XG5cblx0XHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG1heSBub3QgYmUgZGVmaW5lZCBpZiBub3QgcGVybWFuZW50IGFuZCBuZXZlclxuXHRcdFx0Ly8gb3BlbmVkLlxuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiB0aGlzLl90b29sdGlwLl9jb250YWluZXIpIHtcblx0XHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl90b29sdGlwLl9jb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5fY2xvc2UoKTtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHRvZ2dsZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG5cdHRvZ2dsZVRvb2x0aXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAuX21hcCkge1xuXHRcdFx0XHR0aGlzLmNsb3NlVG9vbHRpcCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5vcGVuVG9vbHRpcCh0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzVG9vbHRpcE9wZW4oKTogYm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuXHRpc1Rvb2x0aXBPcGVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuaXNPcGVuKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRUb29sdGlwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8VG9vbHRpcCk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRzZXRUb29sdGlwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFRvb2x0aXAoKTogVG9vbHRpcFxuXHQvLyBSZXR1cm5zIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdGdldFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcDtcblx0fSxcblxuXHRfb3BlblRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gZS5sYXllciB8fCBlLnRhcmdldDtcblxuXHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCAhdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMub3BlblRvb2x0aXAobGF5ZXIsIHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgPyBlLmxhdGxuZyA6IHVuZGVmaW5lZCk7XG5cdH0sXG5cblx0X21vdmVUb29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZywgY29udGFpbmVyUG9pbnQsIGxheWVyUG9pbnQ7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgJiYgZS5vcmlnaW5hbEV2ZW50KSB7XG5cdFx0XHRjb250YWluZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLm9yaWdpbmFsRXZlbnQpO1xuXHRcdFx0bGF5ZXJQb2ludCA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChjb250YWluZXJQb2ludCk7XG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xuXHRcdH1cblx0XHR0aGlzLl90b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuXHR9XG59KTtcbiIsImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCB7dG9Qb2ludCBhcyBwb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtlbXB0eX0gZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIERpdkljb25cbiAqIEBha2EgTC5EaXZJY29uXG4gKiBAaW5oZXJpdHMgSWNvblxuICpcbiAqIFJlcHJlc2VudHMgYSBsaWdodHdlaWdodCBpY29uIGZvciBtYXJrZXJzIHRoYXQgdXNlcyBhIHNpbXBsZSBgPGRpdj5gXG4gKiBlbGVtZW50IGluc3RlYWQgb2YgYW4gaW1hZ2UuIEluaGVyaXRzIGZyb20gYEljb25gIGJ1dCBpZ25vcmVzIHRoZSBgaWNvblVybGAgYW5kIHNoYWRvdyBvcHRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogdmFyIG15SWNvbiA9IEwuZGl2SWNvbih7Y2xhc3NOYW1lOiAnbXktZGl2LWljb24nfSk7XG4gKiAvLyB5b3UgY2FuIHNldCAubXktZGl2LWljb24gc3R5bGVzIGluIENTU1xuICpcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCBoYXMgYSAnbGVhZmxldC1kaXYtaWNvbicgQ1NTIGNsYXNzIGFuZCBpcyBzdHlsZWQgYXMgYSBsaXR0bGUgd2hpdGUgc3F1YXJlIHdpdGggYSBzaGFkb3cuXG4gKi9cblxuZXhwb3J0IHZhciBEaXZJY29uID0gSWNvbi5leHRlbmQoe1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIERpdkljb24gb3B0aW9uc1xuXHRcdGljb25TaXplOiBbMTIsIDEyXSwgLy8gYWxzbyBjYW4gYmUgc2V0IHRocm91Z2ggQ1NTXG5cblx0XHQvLyBpY29uQW5jaG9yOiAoUG9pbnQpLFxuXHRcdC8vIHBvcHVwQW5jaG9yOiAoUG9pbnQpLFxuXG5cdFx0Ly8gQG9wdGlvbiBodG1sOiBTdHJpbmd8SFRNTEVsZW1lbnQgPSAnJ1xuXHRcdC8vIEN1c3RvbSBIVE1MIGNvZGUgdG8gcHV0IGluc2lkZSB0aGUgZGl2IGVsZW1lbnQsIGVtcHR5IGJ5IGRlZmF1bHQuIEFsdGVybmF0aXZlbHksXG5cdFx0Ly8gYW4gaW5zdGFuY2Ugb2YgYEhUTUxFbGVtZW50YC5cblx0XHRodG1sOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gYmdQb3M6IFBvaW50ID0gWzAsIDBdXG5cdFx0Ly8gT3B0aW9uYWwgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGJhY2tncm91bmQsIGluIHBpeGVsc1xuXHRcdGJnUG9zOiBudWxsLFxuXG5cdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcblx0fSxcblxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmIChvcHRpb25zLmh0bWwgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG5cdFx0XHRlbXB0eShkaXYpO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKG9wdGlvbnMuaHRtbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpdi5pbm5lckhUTUwgPSBvcHRpb25zLmh0bWwgIT09IGZhbHNlID8gb3B0aW9ucy5odG1sIDogJyc7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuYmdQb3MpIHtcblx0XHRcdHZhciBiZ1BvcyA9IHBvaW50KG9wdGlvbnMuYmdQb3MpO1xuXHRcdFx0ZGl2LnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9ICgtYmdQb3MueCkgKyAncHggJyArICgtYmdQb3MueSkgKyAncHgnO1xuXHRcdH1cblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGRpdiwgJ2ljb24nKTtcblxuXHRcdHJldHVybiBkaXY7XG5cdH0sXG5cblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmRpdkljb24ob3B0aW9uczogRGl2SWNvbiBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIGBEaXZJY29uYCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGRpdkljb24ob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IERpdkljb24ob3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5leHBvcnQge2ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQge0ljb25EZWZhdWx0fSBmcm9tICcuL0ljb24uRGVmYXVsdCc7XG5JY29uLkRlZmF1bHQgPSBJY29uRGVmYXVsdDtcbmV4cG9ydCB7SWNvbn07XG5cbmV4cG9ydCB7RGl2SWNvbiwgZGl2SWNvbn0gZnJvbSAnLi9EaXZJY29uJztcbmV4cG9ydCB7TWFya2VyLCBtYXJrZXJ9IGZyb20gJy4vTWFya2VyJztcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kcywgdG9MYXRMbmdCb3VuZHMgYXMgbGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcblxuLypcbiAqIEBjbGFzcyBHcmlkTGF5ZXJcbiAqIEBpbmhlcml0cyBMYXllclxuICogQGFrYSBMLkdyaWRMYXllclxuICpcbiAqIEdlbmVyaWMgY2xhc3MgZm9yIGhhbmRsaW5nIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzLiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgdGlsZSBsYXllcnMgYW5kIHJlcGxhY2VzIGBUaWxlTGF5ZXIuQ2FudmFzYC5cbiAqIEdyaWRMYXllciBjYW4gYmUgZXh0ZW5kZWQgdG8gY3JlYXRlIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzIGxpa2UgYDxjYW52YXM+YCwgYDxpbWc+YCBvciBgPGRpdj5gLiBHcmlkTGF5ZXIgd2lsbCBoYW5kbGUgY3JlYXRpbmcgYW5kIGFuaW1hdGluZyB0aGVzZSBET00gZWxlbWVudHMgZm9yIHlvdS5cbiAqXG4gKlxuICogQHNlY3Rpb24gU3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVG8gY3JlYXRlIGEgY3VzdG9tIGxheWVyLCBleHRlbmQgR3JpZExheWVyIGFuZCBpbXBsZW1lbnQgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZCwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgYSBgUG9pbnRgIG9iamVjdCB3aXRoIHRoZSBgeGAsIGB5YCwgYW5kIGB6YCAoem9vbSBsZXZlbCkgY29vcmRpbmF0ZXMgdG8gZHJhdyB5b3VyIHRpbGUuXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzKXtcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZ2V0IGEgY2FudmFzIGNvbnRleHQgYW5kIGRyYXcgc29tZXRoaW5nIG9uIGl0IHVzaW5nIGNvb3Jkcy54LCBjb29yZHMueSBhbmQgY29vcmRzLnpcbiAqICAgICAgICAgdmFyIGN0eCA9IHRpbGUuZ2V0Q29udGV4dCgnMmQnKTtcbiAqXG4gKiAgICAgICAgIC8vIHJldHVybiB0aGUgdGlsZSBzbyBpdCBjYW4gYmUgcmVuZGVyZWQgb24gc2NyZWVuXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb24gQXN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRpbGUgY3JlYXRpb24gY2FuIGFsc28gYmUgYXN5bmNocm9ub3VzLCB0aGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGEgdGhpcmQtcGFydHkgZHJhd2luZyBsaWJyYXJ5LiBPbmNlIHRoZSB0aWxlIGlzIGZpbmlzaGVkIGRyYXdpbmcgaXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgYGRvbmUoKWAgY2FsbGJhY2suXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzLCBkb25lKXtcbiAqICAgICAgICAgdmFyIGVycm9yO1xuICpcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZHJhdyBzb21ldGhpbmcgYXN5bmNocm9ub3VzbHkgYW5kIHBhc3MgdGhlIHRpbGUgdG8gdGhlIGRvbmUoKSBjYWxsYmFja1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgZG9uZShlcnJvciwgdGlsZSk7XG4gKiAgICAgICAgIH0sIDEwMDApO1xuICpcbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvblxuICovXG5cblxuZXhwb3J0IHZhciBHcmlkTGF5ZXIgPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgR3JpZExheWVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gdGlsZVNpemU6IE51bWJlcnxQb2ludCA9IDI1NlxuXHRcdC8vIFdpZHRoIGFuZCBoZWlnaHQgb2YgdGlsZXMgaW4gdGhlIGdyaWQuIFVzZSBhIG51bWJlciBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBlcXVhbCwgb3IgYEwucG9pbnQod2lkdGgsIGhlaWdodClgIG90aGVyd2lzZS5cblx0XHR0aWxlU2l6ZTogMjU2LFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBPcGFjaXR5IG9mIHRoZSB0aWxlcy4gQ2FuIGJlIHVzZWQgaW4gdGhlIGBjcmVhdGVUaWxlKClgIGZ1bmN0aW9uLlxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gKGRlcGVuZHMpXG5cdFx0Ly8gTG9hZCBuZXcgdGlsZXMgb25seSB3aGVuIHBhbm5pbmcgZW5kcy5cblx0XHQvLyBgdHJ1ZWAgYnkgZGVmYXVsdCBvbiBtb2JpbGUgYnJvd3NlcnMsIGluIG9yZGVyIHRvIGF2b2lkIHRvbyBtYW55IHJlcXVlc3RzIGFuZCBrZWVwIHNtb290aCBuYXZpZ2F0aW9uLlxuXHRcdC8vIGBmYWxzZWAgb3RoZXJ3aXNlIGluIG9yZGVyIHRvIGRpc3BsYXkgbmV3IHRpbGVzIF9kdXJpbmdfIHBhbm5pbmcsIHNpbmNlIGl0IGlzIGVhc3kgdG8gcGFuIG91dHNpZGUgdGhlXG5cdFx0Ly8gW2BrZWVwQnVmZmVyYF0oI2dyaWRsYXllci1rZWVwYnVmZmVyKSBvcHRpb24gaW4gZGVza3RvcCBicm93c2Vycy5cblx0XHR1cGRhdGVXaGVuSWRsZTogQnJvd3Nlci5tb2JpbGUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5ab29taW5nOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIEJ5IGRlZmF1bHQsIGEgc21vb3RoIHpvb20gYW5pbWF0aW9uIChkdXJpbmcgYSBbdG91Y2ggem9vbV0oI21hcC10b3VjaHpvb20pIG9yIGEgW2BmbHlUbygpYF0oI21hcC1mbHl0bykpIHdpbGwgdXBkYXRlIGdyaWQgbGF5ZXJzIGV2ZXJ5IGludGVnZXIgem9vbSBsZXZlbC4gU2V0dGluZyB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHdpbGwgdXBkYXRlIHRoZSBncmlkIGxheWVyIG9ubHkgd2hlbiB0aGUgc21vb3RoIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHVwZGF0ZVdoZW5ab29taW5nOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVJbnRlcnZhbDogTnVtYmVyID0gMjAwXG5cdFx0Ly8gVGlsZXMgd2lsbCBub3QgdXBkYXRlIG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IGB1cGRhdGVJbnRlcnZhbGAgbWlsbGlzZWNvbmRzIHdoZW4gcGFubmluZy5cblx0XHR1cGRhdGVJbnRlcnZhbDogMjAwLFxuXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcblx0XHQvLyBUaGUgZXhwbGljaXQgekluZGV4IG9mIHRoZSB0aWxlIGxheWVyLlxuXHRcdHpJbmRleDogMSxcblxuXHRcdC8vIEBvcHRpb24gYm91bmRzOiBMYXRMbmdCb3VuZHMgPSB1bmRlZmluZWRcblx0XHQvLyBJZiBzZXQsIHRpbGVzIHdpbGwgb25seSBiZSBsb2FkZWQgaW5zaWRlIHRoZSBzZXQgYExhdExuZ0JvdW5kc2AuXG5cdFx0Ym91bmRzOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXG5cdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0bWluWm9vbTogMCxcblxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuXHRcdG1heFpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbWF4TmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gTWF4aW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgaGlnaGVyIHRoYW4gYG1heE5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG5cdFx0Ly8gZnJvbSBgbWF4TmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuXHRcdG1heE5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbWluTmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gTWluaW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgbG93ZXIgdGhhbiBgbWluTmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcblx0XHQvLyBmcm9tIGBtaW5OYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG5cdFx0bWluTmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBub1dyYXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgdGhlIGxheWVyIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBhbnRpbWVyaWRpYW4uIElmIGB0cnVlYCwgdGhlXG5cdFx0Ly8gR3JpZExheWVyIHdpbGwgb25seSBiZSBkaXNwbGF5ZWQgb25jZSBhdCBsb3cgem9vbSBsZXZlbHMuIEhhcyBub1xuXHRcdC8vIGVmZmVjdCB3aGVuIHRoZSBbbWFwIENSU10oI21hcC1jcnMpIGRvZXNuJ3Qgd3JhcCBhcm91bmQuIENhbiBiZSB1c2VkXG5cdFx0Ly8gaW4gY29tYmluYXRpb24gd2l0aCBbYGJvdW5kc2BdKCNncmlkbGF5ZXItYm91bmRzKSB0byBwcmV2ZW50IHJlcXVlc3Rpbmdcblx0XHQvLyB0aWxlcyBvdXRzaWRlIHRoZSBDUlMgbGltaXRzLlxuXHRcdG5vV3JhcDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0aWxlUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBncmlkIGxheWVyIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3RpbGVQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xuXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSB0aWxlIGxheWVyLiBFbXB0eSBieSBkZWZhdWx0LlxuXHRcdGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBAb3B0aW9uIGtlZXBCdWZmZXI6IE51bWJlciA9IDJcblx0XHQvLyBXaGVuIHBhbm5pbmcgdGhlIG1hcCwga2VlcCB0aGlzIG1hbnkgcm93cyBhbmQgY29sdW1ucyBvZiB0aWxlcyBiZWZvcmUgdW5sb2FkaW5nIHRoZW0uXG5cdFx0a2VlcEJ1ZmZlcjogMlxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xuXG5cdFx0dGhpcy5fbGV2ZWxzID0ge307XG5cdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuXHRcdHRoaXMuX3Jlc2V0VmlldygpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5fYWRkWm9vbUxpbWl0KHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdG1hcC5fcmVtb3ZlWm9vbUxpbWl0KHRoaXMpO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG5cdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5tYXgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW29wYWNpdHldKCNncmlkbGF5ZXItb3BhY2l0eSkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHRpbGUgaW4gdGhlIGdyaWQgbGF5ZXIgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLlxuXHRpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdzogdGhpc1xuXHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcblx0XHRcdC8vIHVwZGF0ZSB0aWxlcyBvbiBtb3ZlLCBidXQgbm90IG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciBnaXZlbiBpbnRlcnZhbFxuXHRcdFx0aWYgKCF0aGlzLl9vbk1vdmUpIHtcblx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gVXRpbC50aHJvdHRsZSh0aGlzLl9vbk1vdmVFbmQsIHRoaXMub3B0aW9ucy51cGRhdGVJbnRlcnZhbCwgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50cy5tb3ZlID0gdGhpcy5fb25Nb3ZlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgR3JpZExheWVyYCBzaGFsbCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBtdXN0IGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyBleHRlbmRpbmcgYEdyaWRMYXllcmAuXG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYGNvb3Jkc2AuIElmIHRoZSBgZG9uZWAgY2FsbGJhY2tcblx0Ly8gaXMgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBmaW5pc2hlZCBsb2FkaW5nIGFuZCBkcmF3aW5nLlxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVNpemU6IFBvaW50XG5cdC8vIE5vcm1hbGl6ZXMgdGhlIFt0aWxlU2l6ZSBvcHRpb25dKCNncmlkbGF5ZXItdGlsZXNpemUpIGludG8gYSBwb2ludC4gVXNlZCBieSB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLlxuXHRnZXRUaWxlU2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuXHRcdHJldHVybiBzIGluc3RhbmNlb2YgUG9pbnQgPyBzIDogbmV3IFBvaW50KHMsIHMpO1xuXHR9LFxuXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcblx0XHR9XG5cdH0sXG5cblx0X3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChjb21wYXJlKSB7XG5cdFx0Ly8gZ28gdGhyb3VnaCBhbGwgb3RoZXIgbGF5ZXJzIG9mIHRoZSBzYW1lIHBhbmUsIHNldCB6SW5kZXggdG8gbWF4ICsgMSAoZnJvbnQpIG9yIG1pbiAtIDEgKGJhY2spXG5cblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5nZXRQYW5lKCkuY2hpbGRyZW4sXG5cdFx0ICAgIGVkZ2VaSW5kZXggPSAtY29tcGFyZSgtSW5maW5pdHksIEluZmluaXR5KTsgLy8gLUluZmluaXR5IGZvciBtYXgsIEluZmluaXR5IGZvciBtaW5cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xuXG5cdFx0XHR6SW5kZXggPSBsYXllcnNbaV0uc3R5bGUuekluZGV4O1xuXG5cdFx0XHRpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jb250YWluZXIgJiYgekluZGV4KSB7XG5cdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0Zpbml0ZShlZGdlWkluZGV4KSkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IGVkZ2VaSW5kZXggKyBjb21wYXJlKC0xLCAxKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gSUUgZG9lc24ndCBpbmhlcml0IGZpbHRlciBvcGFjaXR5IHByb3Blcmx5LCBzbyB3ZSdyZSBmb3JjZWQgdG8gc2V0IGl0IG9uIHRpbGVzXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkpIHsgcmV0dXJuOyB9XG5cblx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG5cdFx0ICAgIG5leHRGcmFtZSA9IGZhbHNlLFxuXHRcdCAgICB3aWxsUHJ1bmUgPSBmYWxzZTtcblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKCF0aWxlLmN1cnJlbnQgfHwgIXRpbGUubG9hZGVkKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLmVsLCBmYWRlKTtcblx0XHRcdGlmIChmYWRlIDwgMSkge1xuXHRcdFx0XHRuZXh0RnJhbWUgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0d2lsbFBydW5lID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9vbk9wYXF1ZVRpbGUodGlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh3aWxsUHJ1bmUgJiYgIXRoaXMuX25vUHJ1bmUpIHsgdGhpcy5fcHJ1bmVUaWxlcygpOyB9XG5cblx0XHRpZiAobmV4dEZyYW1lKSB7XG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfb25PcGFxdWVUaWxlOiBVdGlsLmZhbHNlRm4sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWxheWVyICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X3VwZGF0ZUxldmVsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcblx0XHQgICAgbWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xuXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cblx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0aWYgKHRoaXMuX2xldmVsc1t6XS5lbC5jaGlsZHJlbi5sZW5ndGggfHwgeiA9PT0gem9vbSkge1xuXHRcdFx0XHR0aGlzLl9sZXZlbHNbel0uZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbSAtIE1hdGguYWJzKHpvb20gLSB6KTtcblx0XHRcdFx0dGhpcy5fb25VcGRhdGVMZXZlbCh6KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGVzQXRab29tKHopO1xuXHRcdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKHopO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKCFsZXZlbCkge1xuXHRcdFx0bGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0gPSB7fTtcblxuXHRcdFx0bGV2ZWwuZWwgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdGlsZS1jb250YWluZXIgbGVhZmxldC16b29tLWFuaW1hdGVkJywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdGxldmVsLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb207XG5cblx0XHRcdGxldmVsLm9yaWdpbiA9IG1hcC5wcm9qZWN0KG1hcC51bnByb2plY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpLCB6b29tKS5yb3VuZCgpO1xuXHRcdFx0bGV2ZWwuem9vbSA9IHpvb207XG5cblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0obGV2ZWwsIG1hcC5nZXRDZW50ZXIoKSwgbWFwLmdldFpvb20oKSk7XG5cblx0XHRcdC8vIGZvcmNlIHRoZSBicm93c2VyIHRvIGNvbnNpZGVyIHRoZSBuZXdseSBhZGRlZCBlbGVtZW50IGZvciB0cmFuc2l0aW9uXG5cdFx0XHRVdGlsLmZhbHNlRm4obGV2ZWwuZWwub2Zmc2V0V2lkdGgpO1xuXG5cdFx0XHR0aGlzLl9vbkNyZWF0ZUxldmVsKGxldmVsKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sZXZlbCA9IGxldmVsO1xuXG5cdFx0cmV0dXJuIGxldmVsO1xuXHR9LFxuXG5cdF9vblVwZGF0ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X29uUmVtb3ZlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfb25DcmVhdGVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9wcnVuZVRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIga2V5LCB0aWxlO1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHRcdGlmICh6b29tID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHxcblx0XHRcdHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAodGlsZS5jdXJyZW50ICYmICF0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gdGlsZS5jb29yZHM7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV0YWluUGFyZW50KGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56IC0gNSkpIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5yZXRhaW4pIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlVGlsZXNBdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAodGhpcy5fdGlsZXNba2V5XS5jb29yZHMueiAhPT0gem9vbSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZUFsbFRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbnZhbGlkYXRlQWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKHopO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHR9XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblxuXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdF9yZXRhaW5QYXJlbnQ6IGZ1bmN0aW9uICh4LCB5LCB6LCBtaW5ab29tKSB7XG5cdFx0dmFyIHgyID0gTWF0aC5mbG9vcih4IC8gMiksXG5cdFx0ICAgIHkyID0gTWF0aC5mbG9vcih5IC8gMiksXG5cdFx0ICAgIHoyID0geiAtIDEsXG5cdFx0ICAgIGNvb3JkczIgPSBuZXcgUG9pbnQoK3gyLCAreTIpO1xuXHRcdGNvb3JkczIueiA9ICt6MjtcblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzMiksXG5cdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKHoyID4gbWluWm9vbSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JldGFpblBhcmVudCh4MiwgeTIsIHoyLCBtaW5ab29tKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X3JldGFpbkNoaWxkcmVuOiBmdW5jdGlvbiAoeCwgeSwgeiwgbWF4Wm9vbSkge1xuXG5cdFx0Zm9yICh2YXIgaSA9IDIgKiB4OyBpIDwgMiAqIHggKyAyOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAyICogeTsgaiA8IDIgKiB5ICsgMjsgaisrKSB7XG5cblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB6ICsgMTtcblxuXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG5cdFx0XHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oaSwgaiwgeiArIDEsIG1heFpvb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XG5cdFx0dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCksIGFuaW1hdGluZywgYW5pbWF0aW5nKTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fc2V0VmlldyhlLmNlbnRlciwgZS56b29tLCB0cnVlLCBlLm5vVXBkYXRlKTtcblx0fSxcblxuXHRfY2xhbXBab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5taW5OYXRpdmVab29tICYmIHpvb20gPCBvcHRpb25zLm1pbk5hdGl2ZVpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1pbk5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5tYXhOYXRpdmVab29tICYmIG9wdGlvbnMubWF4TmF0aXZlWm9vbSA8IHpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHpvb207XG5cdH0sXG5cblx0X3NldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG5cdFx0dmFyIHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKE1hdGgucm91bmQoem9vbSkpO1xuXHRcdGlmICgodGhpcy5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB8fFxuXHRcdCAgICAodGhpcy5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0dmFyIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcblxuXHRcdGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG5cblx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cblx0XHRcdGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fYWJvcnRMb2FkaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuXHRcdFx0dGhpcy5fcmVzZXRHcmlkKCk7XG5cblx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIW5vUHJ1bmUpIHtcblx0XHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgX3VwZGF0ZU9wYWNpdHkgZnJvbSBwcnVuaW5nIHRpbGVzIGR1cmluZ1xuXHRcdFx0Ly8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXG5cdFx0XHR0aGlzLl9ub1BydW5lID0gISFub1BydW5lO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSk7XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm1zOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0odGhpcy5fbGV2ZWxzW2ldLCBjZW50ZXIsIHpvb20pO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24gKGxldmVsLCBjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuXHRcdCAgICB0cmFuc2xhdGUgPSBsZXZlbC5vcmlnaW4ubXVsdGlwbHlCeShzY2FsZSlcblx0XHQgICAgICAgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpLnJvdW5kKCk7XG5cblx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0obGV2ZWwuZWwsIHRyYW5zbGF0ZSwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKGxldmVsLmVsLCB0cmFuc2xhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRHcmlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX3RpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICB0aWxlWm9vbSA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR0aGlzLl9nbG9iYWxUaWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fd3JhcFggPSBjcnMud3JhcExuZyAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzFdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdFx0dGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzFdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdH0sXG5cblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9nZXRUaWxlZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgbWFwWm9vbSA9IG1hcC5fYW5pbWF0aW5nWm9vbSA/IE1hdGgubWF4KG1hcC5fYW5pbWF0ZVRvWm9vbSwgbWFwLmdldFpvb20oKSkgOiBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fdGlsZVpvb20pLFxuXHRcdCAgICBwaXhlbENlbnRlciA9IG1hcC5wcm9qZWN0KGNlbnRlciwgdGhpcy5fdGlsZVpvb20pLmZsb29yKCksXG5cdFx0ICAgIGhhbGZTaXplID0gbWFwLmdldFNpemUoKS5kaXZpZGVCeShzY2FsZSAqIDIpO1xuXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMocGl4ZWxDZW50ZXIuc3VidHJhY3QoaGFsZlNpemUpLCBwaXhlbENlbnRlci5hZGQoaGFsZlNpemUpKTtcblx0fSxcblxuXHQvLyBQcml2YXRlIG1ldGhvZCB0byBsb2FkIHRpbGVzIGluIHRoZSBncmlkJ3MgYWN0aXZlIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIG1hcCBib3VuZHNcblx0X3VwZGF0ZTogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHpvb20gPSB0aGlzLl9jbGFtcFpvb20obWFwLmdldFpvb20oKSk7XG5cblx0XHRpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG5cdFx0aWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XHQvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cblx0XHR2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG5cdFx0ICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuXHRcdCAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuXHRcdCAgICBxdWV1ZSA9IFtdLFxuXHRcdCAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcblx0XHQgICAgbm9QcnVuZVJhbmdlID0gbmV3IEJvdW5kcyh0aWxlUmFuZ2UuZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFttYXJnaW4sIC1tYXJnaW5dKSxcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pKTtcblxuXHRcdC8vIFNhbml0eSBjaGVjazogcGFuaWMgaWYgdGhlIHRpbGUgcmFuZ2UgY29udGFpbnMgSW5maW5pdHkgc29tZXdoZXJlLlxuXHRcdGlmICghKGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLnkpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC54KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueSkpKSB7IHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGxvYWQgYW4gaW5maW5pdGUgbnVtYmVyIG9mIHRpbGVzJyk7IH1cblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIGMgPSB0aGlzLl90aWxlc1trZXldLmNvb3Jkcztcblx0XHRcdGlmIChjLnogIT09IHRoaXMuX3RpbGVab29tIHx8ICFub1BydW5lUmFuZ2UuY29udGFpbnMobmV3IFBvaW50KGMueCwgYy55KSkpIHtcblx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuXHRcdC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG5cdFx0aWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7IHRoaXMuX3NldFZpZXcoY2VudGVyLCB6b29tKTsgcmV0dXJuOyB9XG5cblx0XHQvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cblx0XHRmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pbi55OyBqIDw9IHRpbGVSYW5nZS5tYXgueTsgaisrKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pbi54OyBpIDw9IHRpbGVSYW5nZS5tYXgueDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHRcdFx0aWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV07XG5cdFx0XHRcdGlmICh0aWxlKSB7XG5cdFx0XHRcdFx0dGlsZS5jdXJyZW50ID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKGNvb3Jkcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzb3J0IHRpbGUgcXVldWUgdG8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcblx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0Ly8gaWYgaXQncyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuXHRcdFx0aWYgKCF0aGlzLl9sb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuXHRcdFx0XHQvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBzdGFydHMgbG9hZGluZyB0aWxlcy5cblx0XHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNyZWF0ZSBET00gZnJhZ21lbnQgdG8gYXBwZW5kIHRpbGVzIGluIG9uZSBiYXRjaFxuXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fYWRkVGlsZShxdWV1ZVtpXSwgZnJhZ21lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1ZhbGlkVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBjcnMgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoIWNycy5pbmZpbml0ZSkge1xuXHRcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kcyBhbmQgbm90IHdyYXBwZWRcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2U7XG5cdFx0XHRpZiAoKCFjcnMud3JhcExuZyAmJiAoY29vcmRzLnggPCBib3VuZHMubWluLnggfHwgY29vcmRzLnggPiBib3VuZHMubWF4LngpKSB8fFxuXHRcdFx0ICAgICghY3JzLndyYXBMYXQgJiYgKGNvb3Jkcy55IDwgYm91bmRzLm1pbi55IHx8IGNvb3Jkcy55ID4gYm91bmRzLm1heC55KSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYm91bmRzKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBpbiBvcHRpb25zXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKTtcblx0XHRyZXR1cm4gbGF0TG5nQm91bmRzKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKHRpbGVCb3VuZHMpO1xuXHR9LFxuXG5cdF9rZXlUb0JvdW5kczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSkpO1xuXHR9LFxuXG5cdF90aWxlQ29vcmRzVG9Od1NlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG5cdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZCh0aWxlU2l6ZSksXG5cdFx0ICAgIG53ID0gbWFwLnVucHJvamVjdChud1BvaW50LCBjb29yZHMueiksXG5cdFx0ICAgIHNlID0gbWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueik7XG5cdFx0cmV0dXJuIFtudywgc2VdO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcblx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBicCA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcblx0XHQgICAgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhicFswXSwgYnBbMV0pO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubm9XcmFwKSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLl9tYXAud3JhcExhdExuZ0JvdW5kcyhib3VuZHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGtleSBmb3IgdGhlIHRpbGUgY2FjaGVcblx0X3RpbGVDb29yZHNUb0tleTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMueCArICc6JyArIGNvb3Jkcy55ICsgJzonICsgY29vcmRzLno7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjYWNoZSBrZXkgdG8gY29vcmRpbmF0ZXNcblx0X2tleVRvVGlsZUNvb3JkczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBrID0ga2V5LnNwbGl0KCc6JyksXG5cdFx0ICAgIGNvb3JkcyA9IG5ldyBQb2ludCgra1swXSwgK2tbMV0pO1xuXHRcdGNvb3Jkcy56ID0gK2tbMl07XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fSxcblxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHREb21VdGlsLnJlbW92ZSh0aWxlLmVsKTtcblxuXHRcdGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0Ly8gQGV2ZW50IHRpbGV1bmxvYWQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlbW92ZWQgKGUuZy4gd2hlbiBhIHRpbGUgZ29lcyBvZmYgdGhlIHNjcmVlbikuXG5cdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge1xuXHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdGNvb3JkczogdGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSlcblx0XHR9KTtcblx0fSxcblxuXHRfaW5pdFRpbGU6IGZ1bmN0aW9uICh0aWxlKSB7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aWxlLCAnbGVhZmxldC10aWxlJyk7XG5cblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0dGlsZS5zdHlsZS53aWR0aCA9IHRpbGVTaXplLnggKyAncHgnO1xuXHRcdHRpbGUuc3R5bGUuaGVpZ2h0ID0gdGlsZVNpemUueSArICdweCc7XG5cblx0XHR0aWxlLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XG5cdFx0dGlsZS5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcblxuXHRcdC8vIHVwZGF0ZSBvcGFjaXR5IG9uIHRpbGVzIGluIElFNy04IGJlY2F1c2Ugb2YgZmlsdGVyIGluaGVyaXRhbmNlIHByb2JsZW1zXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkgJiYgdGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXHRcdH1cblxuXHRcdC8vIHdpdGhvdXQgdGhpcyBoYWNrLCB0aWxlcyBkaXNhcHBlYXIgYWZ0ZXIgem9vbSBvbiBDaHJvbWUgZm9yIEFuZHJvaWRcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yMDc4XG5cdFx0aWYgKEJyb3dzZXIuYW5kcm9pZCAmJiAhQnJvd3Nlci5hbmRyb2lkMjMpIHtcblx0XHRcdHRpbGUuc3R5bGUuV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBjb250YWluZXIpIHtcblx0XHR2YXIgdGlsZVBvcyA9IHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKSxcblx0XHQgICAga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR2YXIgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZSh0aGlzLl93cmFwQ29vcmRzKGNvb3JkcyksIFV0aWwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuXG5cdFx0dGhpcy5faW5pdFRpbGUodGlsZSk7XG5cblx0XHQvLyBpZiBjcmVhdGVUaWxlIGlzIGRlZmluZWQgd2l0aCBhIHNlY29uZCBhcmd1bWVudCAoXCJkb25lXCIgY2FsbGJhY2spLFxuXHRcdC8vIHdlIGtub3cgdGhhdCB0aWxlIGlzIGFzeW5jIGFuZCB3aWxsIGJlIHJlYWR5IGxhdGVyOyBvdGhlcndpc2Vcblx0XHRpZiAodGhpcy5jcmVhdGVUaWxlLmxlbmd0aCA8IDIpIHtcblx0XHRcdC8vIG1hcmsgdGlsZSBhcyByZWFkeSwgYnV0IGRlbGF5IG9uZSBmcmFtZSBmb3Igb3BhY2l0eSBhbmltYXRpb24gdG8gaGFwcGVuXG5cdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoVXRpbC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzLCBudWxsLCB0aWxlKSk7XG5cdFx0fVxuXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zKTtcblxuXHRcdC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuXHRcdHRoaXMuX3RpbGVzW2tleV0gPSB7XG5cdFx0XHRlbDogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzLFxuXHRcdFx0Y3VycmVudDogdHJ1ZVxuXHRcdH07XG5cblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGlsZSk7XG5cdFx0Ly8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlcXVlc3RlZCBhbmQgc3RhcnRzIGxvYWRpbmcuXG5cdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuXHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0fSk7XG5cdH0sXG5cblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XG5cdFx0aWYgKGVycikge1xuXHRcdFx0Ly8gQGV2ZW50IHRpbGVlcnJvcjogVGlsZUVycm9yRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgbG9hZGluZyBhIHRpbGUuXG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVlcnJvcicsIHtcblx0XHRcdFx0ZXJyb3I6IGVycixcblx0XHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuXHRcdHRpbGUubG9hZGVkID0gK25ldyBEYXRlKCk7XG5cdFx0aWYgKHRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgMCk7XG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFlcnIpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGlsZS5lbCwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcblxuXHRcdFx0Ly8gQGV2ZW50IHRpbGVsb2FkOiBUaWxlRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGxvYWRzLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcblx0XHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ub1RpbGVzVG9Mb2FkKCkpIHtcblx0XHRcdHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcblx0XHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBsb2FkZWQgYWxsIHZpc2libGUgdGlsZXMuXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcblxuXHRcdFx0aWYgKEJyb3dzZXIuaWVsdDkgfHwgIXRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcblx0XHRcdFx0Ly8gdG8gdHJpZ2dlciBhIHBydW5pbmcuXG5cdFx0XHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpLCAyNTApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZ2V0VGlsZVBvczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMuc2NhbGVCeSh0aGlzLmdldFRpbGVTaXplKCkpLnN1YnRyYWN0KHRoaXMuX2xldmVsLm9yaWdpbik7XG5cdH0sXG5cblx0X3dyYXBDb29yZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgbmV3Q29vcmRzID0gbmV3IFBvaW50KFxuXHRcdFx0dGhpcy5fd3JhcFggPyBVdGlsLndyYXBOdW0oY29vcmRzLngsIHRoaXMuX3dyYXBYKSA6IGNvb3Jkcy54LFxuXHRcdFx0dGhpcy5fd3JhcFkgPyBVdGlsLndyYXBOdW0oY29vcmRzLnksIHRoaXMuX3dyYXBZKSA6IGNvb3Jkcy55KTtcblx0XHRuZXdDb29yZHMueiA9IGNvb3Jkcy56O1xuXHRcdHJldHVybiBuZXdDb29yZHM7XG5cdH0sXG5cblx0X3B4Qm91bmRzVG9UaWxlUmFuZ2U6IGZ1bmN0aW9uIChib3VuZHMpIHtcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMoXG5cdFx0XHRib3VuZHMubWluLnVuc2NhbGVCeSh0aWxlU2l6ZSkuZmxvb3IoKSxcblx0XHRcdGJvdW5kcy5tYXgudW5zY2FsZUJ5KHRpbGVTaXplKS5jZWlsKCkuc3VidHJhY3QoWzEsIDFdKSk7XG5cdH0sXG5cblx0X25vVGlsZXNUb0xvYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5sb2FkZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5ncmlkTGF5ZXIob3B0aW9ucz86IEdyaWRMYXllciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBHcmlkTGF5ZXIgd2l0aCB0aGUgc3VwcGxpZWQgb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBncmlkTGF5ZXIob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEdyaWRMYXllcihvcHRpb25zKTtcbn1cbiIsImltcG9ydCB7R3JpZExheWVyfSBmcm9tICcuL0dyaWRMYXllcic7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcclxuXHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyXHJcbiAqIEBpbmhlcml0cyBHcmlkTGF5ZXJcclxuICogQGFrYSBMLlRpbGVMYXllclxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gTm90ZSB0aGF0IG1vc3QgdGlsZSBzZXJ2ZXJzIHJlcXVpcmUgYXR0cmlidXRpb24sIHdoaWNoIHlvdSBjYW4gc2V0IHVuZGVyIGBMYXllcmAuIEV4dGVuZHMgYEdyaWRMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwudGlsZUxheWVyKCdodHRwczovL3tzfS50aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZz97Zm9vfScsIHtmb286ICdiYXInLCBhdHRyaWJ1dGlvbjogJ01hcCBkYXRhICZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvXCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzLCA8YSBocmVmPVwiaHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LXNhLzIuMC9cIj5DQy1CWS1TQTwvYT4nfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBzZWN0aW9uIFVSTCB0ZW1wbGF0ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBBIHN0cmluZyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiAnaHR0cDovL3tzfS5zb21lZG9tYWluLmNvbS9ibGFibGEve3p9L3t4fS97eX17cn0ucG5nJ1xyXG4gKiBgYGBcclxuICpcclxuICogYHtzfWAgbWVhbnMgb25lIG9mIHRoZSBhdmFpbGFibGUgc3ViZG9tYWlucyAodXNlZCBzZXF1ZW50aWFsbHkgdG8gaGVscCB3aXRoIGJyb3dzZXIgcGFyYWxsZWwgcmVxdWVzdHMgcGVyIGRvbWFpbiBsaW1pdGF0aW9uOyBzdWJkb21haW4gdmFsdWVzIGFyZSBzcGVjaWZpZWQgaW4gb3B0aW9uczsgYGFgLCBgYmAgb3IgYGNgIGJ5IGRlZmF1bHQsIGNhbiBiZSBvbWl0dGVkKSwgYHt6fWAg4oCUIHpvb20gbGV2ZWwsIGB7eH1gIGFuZCBge3l9YCDigJQgdGlsZSBjb29yZGluYXRlcy4gYHtyfWAgY2FuIGJlIHVzZWQgdG8gYWRkIFwiJmNvbW1hdDsyeFwiIHRvIHRoZSBVUkwgdG8gbG9hZCByZXRpbmEgdGlsZXMuXHJcbiAqXHJcbiAqIFlvdSBjYW4gdXNlIGN1c3RvbSBrZXlzIGluIHRoZSB0ZW1wbGF0ZSwgd2hpY2ggd2lsbCBiZSBbZXZhbHVhdGVkXSgjdXRpbC10ZW1wbGF0ZSkgZnJvbSBUaWxlTGF5ZXIgb3B0aW9ucywgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBcclxuICogTC50aWxlTGF5ZXIoJ2h0dHA6Ly97c30uc29tZWRvbWFpbi5jb20ve2Zvb30ve3p9L3t4fS97eX0ucG5nJywge2ZvbzogJ2Jhcid9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbmV4cG9ydCB2YXIgVGlsZUxheWVyID0gR3JpZExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBUaWxlTGF5ZXIgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxyXG5cdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcblx0XHRtaW5ab29tOiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gMThcclxuXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuXHRcdG1heFpvb206IDE4LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc3ViZG9tYWluczogU3RyaW5nfFN0cmluZ1tdID0gJ2FiYydcclxuXHRcdC8vIFN1YmRvbWFpbnMgb2YgdGhlIHRpbGUgc2VydmljZS4gQ2FuIGJlIHBhc3NlZCBpbiB0aGUgZm9ybSBvZiBvbmUgc3RyaW5nICh3aGVyZSBlYWNoIGxldHRlciBpcyBhIHN1YmRvbWFpbiBuYW1lKSBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG5cdFx0c3ViZG9tYWluczogJ2FiYycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBlcnJvclRpbGVVcmw6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBVUkwgdG8gdGhlIHRpbGUgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgdGlsZSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG5cdFx0ZXJyb3JUaWxlVXJsOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PZmZzZXQ6IE51bWJlciA9IDBcclxuXHRcdC8vIFRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIG9mZnNldCB3aXRoIHRoaXMgdmFsdWUuXHJcblx0XHR6b29tT2Zmc2V0OiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdG1zOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgaW52ZXJzZXMgWSBheGlzIG51bWJlcmluZyBmb3IgdGlsZXMgKHR1cm4gdGhpcyBvbiBmb3IgW1RNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZSkgc2VydmljZXMpLlxyXG5cdFx0dG1zOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21SZXZlcnNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHNldCB0byB0cnVlLCB0aGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSByZXZlcnNlZCAoYG1heFpvb20gLSB6b29tYCBpbnN0ZWFkIG9mIGB6b29tYClcclxuXHRcdHpvb21SZXZlcnNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGRldGVjdFJldGluYTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAgYW5kIHVzZXIgaXMgb24gYSByZXRpbmEgZGlzcGxheSwgaXQgd2lsbCByZXF1ZXN0IGZvdXIgdGlsZXMgb2YgaGFsZiB0aGUgc3BlY2lmaWVkIHNpemUgYW5kIGEgYmlnZ2VyIHpvb20gbGV2ZWwgaW4gcGxhY2Ugb2Ygb25lIHRvIHV0aWxpemUgdGhlIGhpZ2ggcmVzb2x1dGlvbi5cclxuXHRcdGRldGVjdFJldGluYTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG5cdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgdGlsZSBwaXhlbCBkYXRhLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcblx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cclxuXHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0Kys7XHJcblx0XHRcdFx0b3B0aW9ucy5tYXhab29tLS07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0LS07XHJcblx0XHRcdFx0b3B0aW9ucy5taW5ab29tKys7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluWm9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG9wdGlvbnMuc3ViZG9tYWlucyA9IG9wdGlvbnMuc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xyXG5cdFx0aWYgKCFCcm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0dGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMuX29uVGlsZVJlbW92ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBVcGRhdGVzIHRoZSBsYXllcidzIFVSTCB0ZW1wbGF0ZSBhbmQgcmVkcmF3cyBpdCAodW5sZXNzIGBub1JlZHJhd2AgaXMgc2V0IHRvIGB0cnVlYCkuXHJcblx0Ly8gSWYgdGhlIFVSTCBkb2VzIG5vdCBjaGFuZ2UsIHRoZSBsYXllciB3aWxsIG5vdCBiZSByZWRyYXduIHVubGVzc1xyXG5cdC8vIHRoZSBub1JlZHJhdyBwYXJhbWV0ZXIgaXMgc2V0IHRvIGZhbHNlLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCwgbm9SZWRyYXcpIHtcclxuXHRcdGlmICh0aGlzLl91cmwgPT09IHVybCAmJiBub1JlZHJhdyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdG5vUmVkcmF3ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG92ZXJyaWRlcyBHcmlkTGF5ZXIncyBbYGNyZWF0ZVRpbGUoKWBdKCNncmlkbGF5ZXItY3JlYXRldGlsZSlcclxuXHQvLyB0byByZXR1cm4gYW4gYDxpbWc+YCBIVE1MIGVsZW1lbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgaW1hZ2UgVVJMIGdpdmVuIGBjb29yZHNgLiBUaGUgYGRvbmVgXHJcblx0Ly8gY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGJlZW4gbG9hZGVkLlxyXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGRvbmUpIHtcclxuXHRcdHZhciB0aWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblxyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2xvYWQnLCBVdGlsLmJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2Vycm9yJywgVXRpbC5iaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdHRpbGUuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuXHRcdH1cclxuXHJcblx0XHQvKlxyXG5cdFx0IEFsdCB0YWcgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyB0byBrZWVwIHNjcmVlbiByZWFkZXJzIGZyb20gcmVhZGluZyBVUkwgYW5kIGZvciBjb21wbGlhbmNlIHJlYXNvbnNcclxuXHRcdCBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAtVEVDSFMvSDY3XHJcblx0XHQqL1xyXG5cdFx0dGlsZS5hbHQgPSAnJztcclxuXHJcblx0XHQvKlxyXG5cdFx0IFNldCByb2xlPVwicHJlc2VudGF0aW9uXCIgdG8gZm9yY2Ugc2NyZWVuIHJlYWRlcnMgdG8gaWdub3JlIHRoaXNcclxuXHRcdCBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEvcm9sZXMjdGV4dGFsdGVybmF0aXZlY29tcHV0YXRpb25cclxuXHRcdCovXHJcblx0XHR0aWxlLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcclxuXHJcblx0XHR0aWxlLnNyYyA9IHRoaXMuZ2V0VGlsZVVybChjb29yZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aWxlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcblx0Ly8gQHVuaW5oZXJpdGFibGVcclxuXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIG1pZ2h0IHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxyXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVVybChjb29yZHM6IE9iamVjdCk6IFN0cmluZ1xyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIHJldHVybnMgdGhlIFVSTCBmb3IgYSB0aWxlIGdpdmVuIGl0cyBjb29yZGluYXRlcy5cclxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBjYW4gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBwcm92aWRlIGN1c3RvbSB0aWxlIFVSTCBuYW1pbmcgc2NoZW1lcy5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0cjogQnJvd3Nlci5yZXRpbmEgPyAnQDJ4JyA6ICcnLFxyXG5cdFx0XHRzOiB0aGlzLl9nZXRTdWJkb21haW4oY29vcmRzKSxcclxuXHRcdFx0eDogY29vcmRzLngsXHJcblx0XHRcdHk6IGNvb3Jkcy55LFxyXG5cdFx0XHR6OiB0aGlzLl9nZXRab29tRm9yVXJsKClcclxuXHRcdH07XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLl9tYXAub3B0aW9ucy5jcnMuaW5maW5pdGUpIHtcclxuXHRcdFx0dmFyIGludmVydGVkWSA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZS5tYXgueSAtIGNvb3Jkcy55O1xyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnRtcykge1xyXG5cdFx0XHRcdGRhdGFbJ3knXSA9IGludmVydGVkWTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkYXRhWycteSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBVdGlsLnRlbXBsYXRlKHRoaXMuX3VybCwgVXRpbC5leHRlbmQoZGF0YSwgdGhpcy5vcHRpb25zKSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkxvYWQ6IGZ1bmN0aW9uIChkb25lLCB0aWxlKSB7XHJcblx0XHQvLyBGb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzMzMlxyXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkpIHtcclxuXHRcdFx0c2V0VGltZW91dChVdGlsLmJpbmQoZG9uZSwgdGhpcywgbnVsbCwgdGlsZSksIDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZG9uZShudWxsLCB0aWxlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uIChkb25lLCB0aWxlLCBlKSB7XHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JUaWxlVXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGlsZS5zcmMgPSBlcnJvclVybDtcclxuXHRcdH1cclxuXHRcdGRvbmUoZSwgdGlsZSk7XHJcblx0fSxcclxuXHJcblx0X29uVGlsZVJlbW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGUudGlsZS5vbmxvYWQgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tRm9yVXJsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxyXG5cdFx0bWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tLFxyXG5cdFx0em9vbVJldmVyc2UgPSB0aGlzLm9wdGlvbnMuem9vbVJldmVyc2UsXHJcblx0XHR6b29tT2Zmc2V0ID0gdGhpcy5vcHRpb25zLnpvb21PZmZzZXQ7XHJcblxyXG5cdFx0aWYgKHpvb21SZXZlcnNlKSB7XHJcblx0XHRcdHpvb20gPSBtYXhab29tIC0gem9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gem9vbSArIHpvb21PZmZzZXQ7XHJcblx0fSxcclxuXHJcblx0X2dldFN1YmRvbWFpbjogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG5cdFx0dmFyIGluZGV4ID0gTWF0aC5hYnModGlsZVBvaW50LnggKyB0aWxlUG9pbnQueSkgJSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucy5sZW5ndGg7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnN1YmRvbWFpbnNbaW5kZXhdO1xyXG5cdH0sXHJcblxyXG5cdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXHJcblx0X2Fib3J0TG9hZGluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGksIHRpbGU7XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2ldLmNvb3Jkcy56ICE9PSB0aGlzLl90aWxlWm9vbSkge1xyXG5cdFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1tpXS5lbDtcclxuXHJcblx0XHRcdFx0dGlsZS5vbmxvYWQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0dGlsZS5vbmVycm9yID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHRpZiAoIXRpbGUuY29tcGxldGUpIHtcclxuXHRcdFx0XHRcdHRpbGUuc3JjID0gVXRpbC5lbXB0eUltYWdlVXJsO1xyXG5cdFx0XHRcdFx0RG9tVXRpbC5yZW1vdmUodGlsZSk7XHJcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fdGlsZXNbaV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcclxuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXHJcblx0XHQvLyB1bmxlc3Mgd2UncmUgb24gQW5kcm9pZCdzIHN0b2NrIGJyb3dzZXIsXHJcblx0XHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTM3XHJcblx0XHRpZiAoIUJyb3dzZXIuYW5kcm9pZFN0b2NrKSB7XHJcblx0XHRcdHRpbGUuZWwuc2V0QXR0cmlidXRlKCdzcmMnLCBVdGlsLmVtcHR5SW1hZ2VVcmwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl9yZW1vdmVUaWxlLmNhbGwodGhpcywga2V5KTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwIHx8ICh0aWxlICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSA9PT0gVXRpbC5lbXB0eUltYWdlVXJsKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEdyaWRMYXllci5wcm90b3R5cGUuX3RpbGVSZWFkeS5jYWxsKHRoaXMsIGNvb3JkcywgZXJyLCB0aWxlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZWxheWVyKHVybFRlbXBsYXRlOiBTdHJpbmcsIG9wdGlvbnM/OiBUaWxlTGF5ZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBgVVJMIHRlbXBsYXRlYCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aWxlTGF5ZXIodXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXIodXJsLCBvcHRpb25zKTtcclxufVxyXG4iLCJpbXBvcnQge1RpbGVMYXllcn0gZnJvbSAnLi9UaWxlTGF5ZXInO1xyXG5pbXBvcnQge2V4dGVuZCwgc2V0T3B0aW9ucywgZ2V0UGFyYW1TdHJpbmd9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7cmV0aW5hfSBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQge0VQU0c0MzI2fSBmcm9tICcuLi8uLi9nZW8vY3JzL0NSUy5FUFNHNDMyNic7XHJcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyLldNU1xyXG4gKiBAaW5oZXJpdHMgVGlsZUxheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXIuV01TXHJcbiAqIFVzZWQgdG8gZGlzcGxheSBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzIGFzIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYFRpbGVMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBuZXhyYWQgPSBMLnRpbGVMYXllci53bXMoXCJodHRwOi8vbWVzb25ldC5hZ3Jvbi5pYXN0YXRlLmVkdS9jZ2ktYmluL3dtcy9uZXhyYWQvbjByLmNnaVwiLCB7XHJcbiAqIFx0bGF5ZXJzOiAnbmV4cmFkLW4wci05MDA5MTMnLFxyXG4gKiBcdGZvcm1hdDogJ2ltYWdlL3BuZycsXHJcbiAqIFx0dHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAqIFx0YXR0cmlidXRpb246IFwiV2VhdGhlciBkYXRhIMKpIDIwMTIgSUVNIE5leHJhZFwiXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIFRpbGVMYXllcldNUyA9IFRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyLldNUyBvcHRpb25zXHJcblx0Ly8gSWYgYW55IGN1c3RvbSBvcHRpb25zIG5vdCBkb2N1bWVudGVkIGhlcmUgYXJlIHVzZWQsIHRoZXkgd2lsbCBiZSBzZW50IHRvIHRoZVxyXG5cdC8vIFdNUyBzZXJ2ZXIgYXMgZXh0cmEgcGFyYW1ldGVycyBpbiBlYWNoIHJlcXVlc3QgVVJMLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXHJcblx0Ly8gW25vbi1zdGFuZGFyZCB2ZW5kb3IgV01TIHBhcmFtZXRlcnNdKGh0dHA6Ly9kb2NzLmdlb3NlcnZlci5vcmcvc3RhYmxlL2VuL3VzZXIvc2VydmljZXMvd21zL3ZlbmRvci5odG1sKS5cclxuXHRkZWZhdWx0V21zUGFyYW1zOiB7XHJcblx0XHRzZXJ2aWNlOiAnV01TJyxcclxuXHRcdHJlcXVlc3Q6ICdHZXRNYXAnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gKioocmVxdWlyZWQpKiogQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIGxheWVycyB0byBzaG93LlxyXG5cdFx0bGF5ZXJzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN0eWxlczogU3RyaW5nID0gJydcclxuXHRcdC8vIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBzdHlsZXMuXHJcblx0XHRzdHlsZXM6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZm9ybWF0OiBTdHJpbmcgPSAnaW1hZ2UvanBlZydcclxuXHRcdC8vIFdNUyBpbWFnZSBmb3JtYXQgKHVzZSBgJ2ltYWdlL3BuZydgIGZvciBsYXllcnMgd2l0aCB0cmFuc3BhcmVuY3kpLlxyXG5cdFx0Zm9ybWF0OiAnaW1hZ2UvanBlZycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc3BhcmVudDogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBXTVMgc2VydmljZSB3aWxsIHJldHVybiBpbWFnZXMgd2l0aCB0cmFuc3BhcmVuY3kuXHJcblx0XHR0cmFuc3BhcmVudDogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB2ZXJzaW9uOiBTdHJpbmcgPSAnMS4xLjEnXHJcblx0XHQvLyBWZXJzaW9uIG9mIHRoZSBXTVMgc2VydmljZSB0byB1c2VcclxuXHRcdHZlcnNpb246ICcxLjEuMSdcclxuXHR9LFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gbnVsbFxyXG5cdFx0Ly8gQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtIHRvIHVzZSBmb3IgdGhlIFdNUyByZXF1ZXN0cywgZGVmYXVsdHMgdG9cclxuXHRcdC8vIG1hcCBDUlMuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3Qgc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG5cdFx0Y3JzOiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdXBwZXJjYXNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgV01TIHJlcXVlc3QgcGFyYW1ldGVyIGtleXMgd2lsbCBiZSB1cHBlcmNhc2UuXHJcblx0XHR1cHBlcmNhc2U6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHR2YXIgd21zUGFyYW1zID0gZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRXbXNQYXJhbXMpO1xyXG5cclxuXHRcdC8vIGFsbCBrZXlzIHRoYXQgYXJlIG5vdCBUaWxlTGF5ZXIgb3B0aW9ucyBnbyB0byBXTVMgcGFyYW1zXHJcblx0XHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdFx0aWYgKCEoaSBpbiB0aGlzLm9wdGlvbnMpKSB7XHJcblx0XHRcdFx0d21zUGFyYW1zW2ldID0gb3B0aW9uc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHZhciByZWFsUmV0aW5hID0gb3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgcmV0aW5hID8gMiA6IDE7XHJcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XHJcblx0XHR3bXNQYXJhbXMud2lkdGggPSB0aWxlU2l6ZS54ICogcmVhbFJldGluYTtcclxuXHRcdHdtc1BhcmFtcy5oZWlnaHQgPSB0aWxlU2l6ZS55ICogcmVhbFJldGluYTtcclxuXHJcblx0XHR0aGlzLndtc1BhcmFtcyA9IHdtc1BhcmFtcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cclxuXHRcdHRoaXMuX2NycyA9IHRoaXMub3B0aW9ucy5jcnMgfHwgbWFwLm9wdGlvbnMuY3JzO1xyXG5cdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG5cdFx0dmFyIHByb2plY3Rpb25LZXkgPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XHJcblx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuXHRcdFRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHJcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcclxuXHRcdCAgICBjcnMgPSB0aGlzLl9jcnMsXHJcblx0XHQgICAgYm91bmRzID0gdG9Cb3VuZHMoY3JzLnByb2plY3QodGlsZUJvdW5kc1swXSksIGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMV0pKSxcclxuXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgYmJveCA9ICh0aGlzLl93bXNWZXJzaW9uID49IDEuMyAmJiB0aGlzLl9jcnMgPT09IEVQU0c0MzI2ID9cclxuXHRcdCAgICBbbWluLnksIG1pbi54LCBtYXgueSwgbWF4LnhdIDpcclxuXHRcdCAgICBbbWluLngsIG1pbi55LCBtYXgueCwgbWF4LnldKS5qb2luKCcsJyksXHJcblx0XHQgICAgdXJsID0gVGlsZUxheWVyLnByb3RvdHlwZS5nZXRUaWxlVXJsLmNhbGwodGhpcywgY29vcmRzKTtcclxuXHRcdHJldHVybiB1cmwgK1xyXG5cdFx0XHRnZXRQYXJhbVN0cmluZyh0aGlzLndtc1BhcmFtcywgdXJsLCB0aGlzLm9wdGlvbnMudXBwZXJjYXNlKSArXHJcblx0XHRcdCh0aGlzLm9wdGlvbnMudXBwZXJjYXNlID8gJyZCQk9YPScgOiAnJmJib3g9JykgKyBiYm94O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UGFyYW1zKHBhcmFtczogT2JqZWN0LCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gTWVyZ2VzIGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgcGFyYW1ldGVycyBhbmQgcmUtcmVxdWVzdHMgdGlsZXMgb24gdGhlIGN1cnJlbnQgc2NyZWVuICh1bmxlc3MgYG5vUmVkcmF3YCB3YXMgc2V0IHRvIHRydWUpLlxyXG5cdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcblx0XHRleHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC50aWxlTGF5ZXIud21zKGJhc2VVcmw6IFN0cmluZywgb3B0aW9uczogVGlsZUxheWVyLldNUyBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBXTVMgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBiYXNlIFVSTCBvZiB0aGUgV01TIHNlcnZpY2UgYW5kIGEgV01TIHBhcmFtZXRlcnMvb3B0aW9ucyBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKTtcclxufVxyXG4iLCJleHBvcnQge0dyaWRMYXllciwgZ3JpZExheWVyfSBmcm9tICcuL0dyaWRMYXllcic7XG5pbXBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfSBmcm9tICcuL1RpbGVMYXllcic7XG5pbXBvcnQge1RpbGVMYXllcldNUywgdGlsZUxheWVyV01TfSBmcm9tICcuL1RpbGVMYXllci5XTVMnO1xuVGlsZUxheWVyLldNUyA9IFRpbGVMYXllcldNUztcbnRpbGVMYXllci53bXMgPSB0aWxlTGF5ZXJXTVM7XG5leHBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfTtcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cblxuXG4vKlxuICogQGNsYXNzIFJlbmRlcmVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5SZW5kZXJlclxuICpcbiAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMgKGBTVkdgLCBgQ2FudmFzYCkuIEhhbmRsZXMgdGhlXG4gKiBET00gY29udGFpbmVyIG9mIHRoZSByZW5kZXJlciwgaXRzIGJvdW5kcywgYW5kIGl0cyB6b29tIGFuaW1hdGlvbi5cbiAqXG4gKiBBIGBSZW5kZXJlcmAgd29ya3MgYXMgYW4gaW1wbGljaXQgbGF5ZXIgZ3JvdXAgZm9yIGFsbCBgUGF0aGBzIC0gdGhlIHJlbmRlcmVyXG4gKiBpdHNlbGYgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgdG8gdGhlIG1hcC4gQWxsIHBhdGhzIHVzZSBhIHJlbmRlcmVyLCB3aGljaCBjYW5cbiAqIGJlIGltcGxpY2l0ICh0aGUgbWFwIHdpbGwgZGVjaWRlIHRoZSB0eXBlIG9mIHJlbmRlcmVyIGFuZCB1c2UgaXQgYXV0b21hdGljYWxseSlcbiAqIG9yIGV4cGxpY2l0ICh1c2luZyB0aGUgW2ByZW5kZXJlcmBdKCNwYXRoLXJlbmRlcmVyKSBvcHRpb24gb2YgdGhlIHBhdGgpLlxuICpcbiAqIERvIG5vdCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgdXNlIGBTVkdgIGFuZCBgQ2FudmFzYCBpbnN0ZWFkLlxuICpcbiAqIEBldmVudCB1cGRhdGU6IEV2ZW50XG4gKiBGaXJlZCB3aGVuIHRoZSByZW5kZXJlciB1cGRhdGVzIGl0cyBib3VuZHMsIGNlbnRlciBhbmQgem9vbSwgZm9yIGV4YW1wbGUgd2hlblxuICogaXRzIG1hcCBoYXMgbW92ZWRcbiAqL1xuXG5leHBvcnQgdmFyIFJlbmRlcmVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFJlbmRlcmVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFkZGluZzogTnVtYmVyID0gMC4xXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGlwIGFyZWEgYXJvdW5kIHRoZSBtYXAgdmlldyAocmVsYXRpdmUgdG8gaXRzIHNpemUpXG5cdFx0Ly8gZS5nLiAwLjEgd291bGQgYmUgMTAlIG9mIG1hcCB2aWV3IGluIGVhY2ggZGlyZWN0aW9uXG5cdFx0cGFkZGluZzogMC4xLFxuXG5cdFx0Ly8gQG9wdGlvbiB0b2xlcmFuY2U6IE51bWJlciA9IDBcblx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgY2xpY2sgdG9sZXJhbmNlIHJvdW5kIGEgcGF0aC9vYmplY3Qgb24gdGhlIG1hcFxuXHRcdHRvbGVyYW5jZSA6IDBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHRVdGlsLnN0YW1wKHRoaXMpO1xuXHRcdHRoaXMuX2xheWVycyA9IHRoaXMuX2xheWVycyB8fCB7fTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7IC8vIGRlZmluZWQgYnkgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zXG5cblx0XHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMub2ZmKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdFx0dGhpcy5fZGVzdHJveUNvbnRhaW5lcigpO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0LFxuXHRcdFx0em9vbTogdGhpcy5fb25ab29tLFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fdXBkYXRlLFxuXHRcdFx0em9vbWVuZDogdGhpcy5fb25ab29tRW5kXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9vbkFuaW1ab29tO1xuXHRcdH1cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vbkFuaW1ab29tOiBmdW5jdGlvbiAoZXYpIHtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0oZXYuY2VudGVyLCBldi56b29tKTtcblx0fSxcblxuXHRfb25ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSk7XG5cdH0sXG5cblx0X3VwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgdGhpcy5fem9vbSksXG5cdFx0ICAgIHBvc2l0aW9uID0gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpLFxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG5cdFx0ICAgIGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlciwgem9vbSksXG5cdFx0ICAgIGRlc3RDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGNlbnRlciwgem9vbSksXG5cdFx0ICAgIGNlbnRlck9mZnNldCA9IGRlc3RDZW50ZXJQb2ludC5zdWJ0cmFjdChjdXJyZW50Q2VudGVyUG9pbnQpLFxuXG5cdFx0ICAgIHRvcExlZnRPZmZzZXQgPSB2aWV3SGFsZi5tdWx0aXBseUJ5KC1zY2FsZSkuYWRkKHBvc2l0aW9uKS5hZGQodmlld0hhbGYpLnN1YnRyYWN0KGNlbnRlck9mZnNldCk7XG5cblx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0KTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSk7XG5cblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Jlc2V0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Byb2plY3QoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl91cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFVwZGF0ZSBwaXhlbCBib3VuZHMgb2YgcmVuZGVyZXIgY29udGFpbmVyIChmb3IgcG9zaXRpb25pbmcvc2l6aW5nL2NsaXBwaW5nIGxhdGVyKVxuXHRcdC8vIFN1YmNsYXNzZXMgYXJlIHJlc3BvbnNpYmxlIG9mIGZpcmluZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXG5cdFx0dmFyIHAgPSB0aGlzLm9wdGlvbnMucGFkZGluZyxcblx0XHQgICAgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCksXG5cdFx0ICAgIG1pbiA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChzaXplLm11bHRpcGx5QnkoLXApKS5yb3VuZCgpO1xuXG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcyhtaW4sIG1pbi5hZGQoc2l6ZS5tdWx0aXBseUJ5KDEgKyBwICogMikpLnJvdW5kKCkpO1xuXG5cdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuXHRcdHRoaXMuX3pvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHR9XG59KTtcbiIsImltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBAY2xhc3MgQ2FudmFzXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5DYW52YXNcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9Y2FudmFzKSwgQ2FudmFzIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgSUU4LCBhbmQgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcyBtaWdodFxuICogbm90IGRpc3BsYXkgcHJvcGVybHkgaW4gc29tZSBlZGdlIGNhc2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIENhbnZhcyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLmNhbnZhcygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIENhbnZhcyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLmNhbnZhcyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBDYW52YXMgPSBSZW5kZXJlci5leHRlbmQoe1xuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXHRcdGV2ZW50cy52aWV3cHJlcmVzZXQgPSB0aGlzLl9vblZpZXdQcmVSZXNldDtcblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vblZpZXdQcmVSZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFNldCBhIGZsYWcgc28gdGhhdCBhIHZpZXdwcmVyZXNldCttb3ZlZW5kK3ZpZXdyZXNldCBvbmx5IHVwZGF0ZXMmcmVkcmF3cyBvbmNlXG5cdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IHRydWU7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRSZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKTtcblxuXHRcdC8vIFJlZHJhdyB2ZWN0b3JzIHNpbmNlIGNhbnZhcyBpcyBjbGVhcmVkIHVwb24gcmVtb3ZhbCxcblx0XHQvLyBpbiBjYXNlIG9mIHJlbW92aW5nIHRoZSByZW5kZXJlciBpdHNlbGYgZnJvbSB0aGUgbWFwLlxuXHRcdHRoaXMuX2RyYXcoKTtcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBjb250ZXh0bWVudScsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlTW91c2VPdXQsIHRoaXMpO1xuXG5cdFx0dGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZWRyYXdSZXF1ZXN0KTtcblx0XHRkZWxldGUgdGhpcy5fY3R4O1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykgeyByZXR1cm47IH1cblxuXHRcdHZhciBsYXllcjtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHR0aGlzLl9yZWRyYXcoKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtID0gQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cblx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG5cdFx0Y29udGFpbmVyLndpZHRoID0gbSAqIHNpemUueDtcblx0XHRjb250YWluZXIuaGVpZ2h0ID0gbSAqIHNpemUueTtcblx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuXHRcdGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXG5cdFx0aWYgKEJyb3dzZXIucmV0aW5hKSB7XG5cdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG5cdFx0fVxuXG5cdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG5cdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXG5cdFx0Ly8gVGVsbCBwYXRocyB0byByZWRyYXcgdGhlbXNlbHZlc1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl9yZXNldC5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHtcblx0XHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGhzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXIgPSB7XG5cdFx0XHRsYXllcjogbGF5ZXIsXG5cdFx0XHRwcmV2OiB0aGlzLl9kcmF3TGFzdCxcblx0XHRcdG5leHQ6IG51bGxcblx0XHR9O1xuXHRcdGlmICh0aGlzLl9kcmF3TGFzdCkgeyB0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7IH1cblx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IHRoaXMuX2RyYXdGaXJzdCB8fCB0aGlzLl9kcmF3TGFzdDtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIGxheWVyLl9vcmRlcjtcblxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIFJlZHJhdyB0aGUgdW5pb24gb2YgdGhlIGxheWVyJ3Mgb2xkIHBpeGVsXG5cdFx0Ly8gYm91bmRzIGFuZCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdC8vIFRoZSByZWRyYXcgd2lsbCBleHRlbmQgdGhlIHJlZHJhdyBib3VuZHNcblx0XHQvLyB3aXRoIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlRGFzaEFycmF5OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAodHlwZW9mIGxheWVyLm9wdGlvbnMuZGFzaEFycmF5ID09PSAnc3RyaW5nJykge1xuXHRcdFx0dmFyIHBhcnRzID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoL1ssIF0rLyksXG5cdFx0XHQgICAgZGFzaEFycmF5ID0gW10sXG5cdFx0XHQgICAgZGFzaFZhbHVlLFxuXHRcdFx0ICAgIGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGFzaFZhbHVlID0gTnVtYmVyKHBhcnRzW2ldKTtcblx0XHRcdFx0Ly8gSWdub3JlIGRhc2ggYXJyYXkgY29udGFpbmluZyBpbnZhbGlkIGxlbmd0aHNcblx0XHRcdFx0aWYgKGlzTmFOKGRhc2hWYWx1ZSkpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdGRhc2hBcnJheS5wdXNoKGRhc2hWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5O1xuXHRcdH1cblx0fSxcblxuXHRfcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSB0aGlzLl9yZWRyYXdSZXF1ZXN0IHx8IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9yZWRyYXcsIHRoaXMpO1xuXHR9LFxuXG5cdF9leHRlbmRSZWRyYXdCb3VuZHM6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChsYXllci5fcHhCb3VuZHMpIHtcblx0XHRcdHZhciBwYWRkaW5nID0gKGxheWVyLm9wdGlvbnMud2VpZ2h0IHx8IDApICsgMTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcyB8fCBuZXcgQm91bmRzKCk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4uc3VidHJhY3QoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5tYXguYWRkKFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IG51bGw7XG5cblx0XHRpZiAodGhpcy5fcmVkcmF3Qm91bmRzKSB7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWluLl9mbG9vcigpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1heC5fY2VpbCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NsZWFyKCk7IC8vIGNsZWFyIGxheWVycyBpbiByZWRyYXcgYm91bmRzXG5cdFx0dGhpcy5fZHJhdygpOyAvLyBkcmF3IGxheWVyc1xuXG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0fSxcblxuXHRfY2xlYXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jb250YWluZXIud2lkdGgsIHRoaXMuX2NvbnRhaW5lci5oZWlnaHQpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsYXllciwgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5fY3R4LnJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IHRydWU7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmICghYm91bmRzIHx8IChsYXllci5fcHhCb3VuZHMgJiYgbGF5ZXIuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkpIHtcblx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLl9jdHgucmVzdG9yZSgpOyAgLy8gUmVzdG9yZSBzdGF0ZSBiZWZvcmUgY2xpcHBpbmcuXG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGksIGosIGxlbjIsIHAsXG5cdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuXHRcdCAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybjsgfVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdHAgPSBwYXJ0c1tpXVtqXTtcblx0XHRcdFx0Y3R4W2ogPyAnbGluZVRvJyA6ICdtb3ZlVG8nXShwLngsIHAueSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXG5cdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cblx0XHRpZiAoIXRoaXMuX2RyYXdpbmcgfHwgbGF5ZXIuX2VtcHR5KCkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4LFxuXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG5cdFx0ICAgIHMgPSAoTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSksIDEpIHx8IHIpIC8gcjtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnNjYWxlKDEsIHMpO1xuXHRcdH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHguYXJjKHAueCwgcC55IC8gcywgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cdH0sXG5cblx0X2ZpbGxTdHJva2U6IGZ1bmN0aW9uIChjdHgsIGxheWVyKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmZpbGwob3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSAmJiBvcHRpb25zLndlaWdodCAhPT0gMCkge1xuXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRjdHguc2V0TGluZURhc2gobGF5ZXIub3B0aW9ucyAmJiBsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgfHwgW10pO1xuXHRcdFx0fVxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5vcGFjaXR5O1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMud2VpZ2h0O1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5saW5lQ2FwID0gb3B0aW9ucy5saW5lQ2FwO1xuXHRcdFx0Y3R4LmxpbmVKb2luID0gb3B0aW9ucy5saW5lSm9pbjtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ2FudmFzIG9idmlvdXNseSBkb2Vzbid0IGhhdmUgbW91c2UgZXZlbnRzIGZvciBpbmRpdmlkdWFsIGRyYXduIG9iamVjdHMsXG5cdC8vIHNvIHdlIGVtdWxhdGUgdGhhdCBieSBjYWxjdWxhdGluZyB3aGF0J3MgdW5kZXIgdGhlIG1vdXNlIG9uIG1vdXNlbW92ZS9jbGljayBtYW51YWxseVxuXG5cdF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpLCBsYXllciwgY2xpY2tlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkgJiYgIXRoaXMuX21hcC5fZHJhZ2dhYmxlTW92ZWQobGF5ZXIpKSB7XG5cdFx0XHRcdGNsaWNrZWRMYXllciA9IGxheWVyO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2xpY2tlZExheWVyKSAge1xuXHRcdFx0RG9tRXZlbnQuZmFrZVN0b3AoZSk7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NsaWNrZWRMYXllcl0sIGUpO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpO1xuXHRcdHRoaXMuX2hhbmRsZU1vdXNlSG92ZXIoZSwgcG9pbnQpO1xuXHR9LFxuXG5cblx0X2hhbmRsZU1vdXNlT3V0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IHRoaXMuX2hvdmVyZWRMYXllcjtcblx0XHRpZiAobGF5ZXIpIHtcblx0XHRcdC8vIGlmIHdlJ3JlIGxlYXZpbmcgdGhlIGxheWVyLCBmaXJlIG1vdXNlb3V0XG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbbGF5ZXJdLCBlLCAnbW91c2VvdXQnKTtcblx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IG51bGw7XG5cdFx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVNb3VzZUhvdmVyOiBmdW5jdGlvbiAoZSwgcG9pbnQpIHtcblx0XHRpZiAodGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBsYXllciwgY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0Y2FuZGlkYXRlSG92ZXJlZExheWVyID0gbGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllciAhPT0gdGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVNb3VzZU91dChlKTtcblxuXHRcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllcikge1xuXHRcdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTsgLy8gY2hhbmdlIGN1cnNvclxuXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NhbmRpZGF0ZUhvdmVyZWRMYXllcl0sIGUsICdtb3VzZW92ZXInKTtcblx0XHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbdGhpcy5faG92ZXJlZExheWVyXSwgZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IHRydWU7XG5cdFx0c2V0VGltZW91dChMLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuXHRcdH0sIHRoaXMpLCAzMik7XG5cdH0sXG5cblx0X2ZpcmVFdmVudDogZnVuY3Rpb24gKGxheWVycywgZSwgdHlwZSkge1xuXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgbGFzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2UgaWYgKG5leHQpIHtcblx0XHRcdC8vIFVwZGF0ZSBmaXJzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcblx0XHR9XG5cblx0XHRvcmRlci5wcmV2ID0gdGhpcy5fZHJhd0xhc3Q7XG5cdFx0dGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyO1xuXG5cdFx0b3JkZXIubmV4dCA9IG51bGw7XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG5cdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQWxyZWFkeSBmaXJzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2UgaWYgKHByZXYpIHtcblx0XHRcdC8vIFVwZGF0ZSBsYXN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuXHRcdFx0Ly8gc2luZ2xlIGVudHJ5XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IG51bGw7XG5cblx0XHRvcmRlci5uZXh0ID0gdGhpcy5fZHJhd0ZpcnN0O1xuXHRcdHRoaXMuX2RyYXdGaXJzdC5wcmV2ID0gb3JkZXI7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIENhbnZhcyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGNhbnZhcyhvcHRpb25zKSB7XG5cdHJldHVybiBCcm93c2VyLmNhbnZhcyA/IG5ldyBDYW52YXMob3B0aW9ucykgOiBudWxsO1xufVxuIiwiaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcblxuLypcbiAqIFRoYW5rcyB0byBEbWl0cnkgQmFyYW5vdnNreSBhbmQgaGlzIFJhcGhhZWwgbGlicmFyeSBmb3IgaW5zcGlyYXRpb24hXG4gKi9cblxuXG5leHBvcnQgdmFyIHZtbENyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0ZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQoJ2x2bWwnLCAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdFx0fTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzwnICsgbmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdH07XG5cdH1cbn0pKCk7XG5cblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqXG4gKlxuICogVk1MIHdhcyBkZXByZWNhdGVkIGluIDIwMTIsIHdoaWNoIG1lYW5zIFZNTCBmdW5jdGlvbmFsaXR5IGV4aXN0cyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICogd2l0aCBvbGQgdmVyc2lvbnMgb2YgSW50ZXJuZXQgRXhwbG9yZXIuXG4gKi9cblxuLy8gbWl4aW4gdG8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcbmV4cG9ydCB2YXIgdm1sTWl4aW4gPSB7XG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdm1sLWNvbnRhaW5lcicpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gdm1sQ3JlYXRlKCdzaGFwZScpO1xuXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZSAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblxuXHRcdGNvbnRhaW5lci5jb29yZHNpemUgPSAnMSAxJztcblxuXHRcdGxheWVyLl9wYXRoID0gdm1sQ3JlYXRlKCdwYXRoJyk7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHREb21VdGlsLnJlbW92ZShjb250YWluZXIpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV07XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgc3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSxcblx0XHQgICAgZmlsbCA9IGxheWVyLl9maWxsLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucyxcblx0XHQgICAgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblxuXHRcdGNvbnRhaW5lci5zdHJva2VkID0gISFvcHRpb25zLnN0cm9rZTtcblx0XHRjb250YWluZXIuZmlsbGVkID0gISFvcHRpb25zLmZpbGw7XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdGlmICghc3Ryb2tlKSB7XG5cdFx0XHRcdHN0cm9rZSA9IGxheWVyLl9zdHJva2UgPSB2bWxDcmVhdGUoJ3N0cm9rZScpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHN0cm9rZSk7XG5cdFx0XHRzdHJva2Uud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgKyAncHgnO1xuXHRcdFx0c3Ryb2tlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdHN0cm9rZS5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IFV0aWwuaXNBcnJheShvcHRpb25zLmRhc2hBcnJheSkgP1xuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkuam9pbignICcpIDpcblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LnJlcGxhY2UoLyggKiwgKikvZywgJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSAnJztcblx0XHRcdH1cblx0XHRcdHN0cm9rZS5lbmRjYXAgPSBvcHRpb25zLmxpbmVDYXAucmVwbGFjZSgnYnV0dCcsICdmbGF0Jyk7XG5cdFx0XHRzdHJva2Uuam9pbnN0eWxlID0gb3B0aW9ucy5saW5lSm9pbjtcblxuXHRcdH0gZWxzZSBpZiAoc3Ryb2tlKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdGxheWVyLl9zdHJva2UgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGlmICghZmlsbCkge1xuXHRcdFx0XHRmaWxsID0gbGF5ZXIuX2ZpbGwgPSB2bWxDcmVhdGUoJ2ZpbGwnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcblx0XHRcdGZpbGwuY29sb3IgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0ZmlsbC5vcGFjaXR5ID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblxuXHRcdH0gZWxzZSBpZiAoZmlsbCkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKGZpbGwpO1xuXHRcdFx0bGF5ZXIuX2ZpbGwgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludC5yb3VuZCgpLFxuXHRcdCAgICByID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSxcblx0XHQgICAgcjIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZIHx8IHIpO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0J0FMICcgKyBwLnggKyAnLCcgKyBwLnkgKyAnICcgKyByICsgJywnICsgcjIgKyAnIDAsJyArICg2NTUzNSAqIDM2MCkpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC52ID0gcGF0aDtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvQmFjayhsYXllci5fY29udGFpbmVyKTtcblx0fVxufTtcbiIsImltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtzdGFtcH0gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7c3ZnQ3JlYXRlLCBwb2ludHNUb1BhdGh9IGZyb20gJy4vU1ZHLlV0aWwnO1xuZXhwb3J0IHtwb2ludHNUb1BhdGh9O1xuaW1wb3J0IHt2bWxNaXhpbiwgdm1sQ3JlYXRlfSBmcm9tICcuL1NWRy5WTUwnO1xuXG5leHBvcnQgdmFyIGNyZWF0ZSA9IEJyb3dzZXIudm1sID8gdm1sQ3JlYXRlIDogc3ZnQ3JlYXRlO1xuXG4vKlxuICogQGNsYXNzIFNWR1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuU1ZHXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXN2ZyksIFNWRyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IEFuZHJvaWQgMi54IGFuZCAzLnguXG4gKlxuICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnRcbiAqIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpXG4gKiAoYSBub3cgZGVwcmVjYXRlZCB0ZWNobm9sb2d5KSwgYW5kIHRoZSBTVkcgcmVuZGVyZXIgd2lsbCBmYWxsIGJhY2sgdG8gVk1MIGluXG4gKiB0aGlzIGNhc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBVc2UgU1ZHIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAqIFx0cmVuZGVyZXI6IEwuc3ZnKClcbiAqIH0pO1xuICogYGBgXG4gKlxuICogVXNlIGEgU1ZHIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gKiB2YXIgbXlSZW5kZXJlciA9IEwuc3ZnKHsgcGFkZGluZzogMC41IH0pO1xuICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNWRyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMuem9vbXN0YXJ0ID0gdGhpcy5fb25ab29tU3RhcnQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSgnc3ZnJyk7XG5cblx0XHQvLyBtYWtlcyBpdCBwb3NzaWJsZSB0byBjbGljayB0aHJvdWdoIHN2ZyByb290OyB3ZSdsbCByZXNldCBpdCBiYWNrIGluIGluZGl2aWR1YWwgcGF0aHNcblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG5cblx0XHR0aGlzLl9yb290R3JvdXAgPSBjcmVhdGUoJ2cnKTtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcblx0fSxcblxuXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0XHRkZWxldGUgdGhpcy5fcm9vdEdyb3VwO1xuXHRcdGRlbGV0ZSB0aGlzLl9zdmdTaXplO1xuXHR9LFxuXG5cdF9vblpvb21TdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIERyYWctdGhlbi1waW5jaCBpbnRlcmFjdGlvbnMgbWlnaHQgbWVzcyB1cCB0aGUgY2VudGVyIGFuZCB6b29tLlxuXHRcdC8vIEluIHRoaXMgY2FzZSwgdGhlIGVhc2llc3Qgd2F5IHRvIHByZXZlbnQgdGhpcyBpcyByZS1kbyB0aGUgcmVuZGVyZXJcblx0XHQvLyAgIGJvdW5kcyBhbmQgcGFkZGluZyB3aGVuIHRoZSB6b29taW5nIHN0YXJ0cy5cblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuXG5cdFx0Ly8gc2V0IHNpemUgb2Ygc3ZnLWNvbnRhaW5lciBpZiBjaGFuZ2VkXG5cdFx0aWYgKCF0aGlzLl9zdmdTaXplIHx8ICF0aGlzLl9zdmdTaXplLmVxdWFscyhzaXplKSkge1xuXHRcdFx0dGhpcy5fc3ZnU2l6ZSA9IHNpemU7XG5cdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUueCk7XG5cdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzaXplLnkpO1xuXHRcdH1cblxuXHRcdC8vIG1vdmVtZW50OiB1cGRhdGUgY29udGFpbmVyIHZpZXdCb3ggc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSBjb29yZGluYXRlcyBvZiBpbmRpdmlkdWFsIGxheWVyc1xuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFtiLm1pbi54LCBiLm1pbi55LCBzaXplLngsIHNpemUueV0uam9pbignICcpKTtcblxuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0Ly8gbWV0aG9kcyBiZWxvdyBhcmUgY2FsbGVkIGJ5IHZlY3RvciBsYXllcnMgaW1wbGVtZW50YXRpb25zXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoID0gY3JlYXRlKCdwYXRoJyk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIFBhdGhcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEN1c3RvbSBjbGFzcyBuYW1lIHNldCBvbiBhbiBlbGVtZW50LiBPbmx5IGZvciBTVkcgcmVuZGVyZXIuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhdGgsIGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKTtcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYXRoLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIXRoaXMuX3Jvb3RHcm91cCkgeyB0aGlzLl9pbml0Q29udGFpbmVyKCk7IH1cblx0XHR0aGlzLl9yb290R3JvdXAuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmUobGF5ZXIuX3BhdGgpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cblx0XHRpZiAoIXBhdGgpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIG9wdGlvbnMub3BhY2l0eSk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgb3B0aW9ucy53ZWlnaHQpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgb3B0aW9ucy5saW5lQ2FwKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCBvcHRpb25zLmxpbmVKb2luKTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jywgb3B0aW9ucy5kYXNoQXJyYXkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaE9mZnNldCkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnLCBvcHRpb25zLmRhc2hPZmZzZXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnbm9uZScpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5Jywgb3B0aW9ucy5maWxsT3BhY2l0eSk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgb3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIHBvaW50c1RvUGF0aChsYXllci5fcGFydHMsIGNsb3NlZCkpO1xuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG5cdFx0ICAgIHIyID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSksIDEpIHx8IHIsXG5cdFx0ICAgIGFyYyA9ICdhJyArIHIgKyAnLCcgKyByMiArICcgMCAxLDAgJztcblxuXHRcdC8vIGRyYXdpbmcgYSBjaXJjbGUgd2l0aCB0d28gaGFsZi1hcmNzXG5cdFx0dmFyIGQgPSBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHQnTScgKyAocC54IC0gcikgKyAnLCcgKyBwLnkgK1xuXHRcdFx0YXJjICsgKHIgKiAyKSArICcsMCAnICtcblx0XHRcdGFyYyArICgtciAqIDIpICsgJywwICc7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBkKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGguc2V0QXR0cmlidXRlKCdkJywgcGF0aCk7XG5cdH0sXG5cblx0Ly8gU1ZHIGRvZXMgbm90IGhhdmUgdGhlIGNvbmNlcHQgb2YgekluZGV4IHNvIHdlIHJlc29ydCB0byBjaGFuZ2luZyB0aGUgRE9NIG9yZGVyIG9mIGVsZW1lbnRzXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9Gcm9udChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvQmFjayhsYXllci5fcGF0aCk7XG5cdH1cbn0pO1xuXG5pZiAoQnJvd3Nlci52bWwpIHtcblx0U1ZHLmluY2x1ZGUodm1sTWl4aW4pO1xufVxuXG4vLyBAbmFtZXNwYWNlIFNWR1xuLy8gQGZhY3RvcnkgTC5zdmcob3B0aW9ucz86IFJlbmRlcmVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgU1ZHIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gc3ZnKG9wdGlvbnMpIHtcblx0cmV0dXJuIEJyb3dzZXIuc3ZnIHx8IEJyb3dzZXIudm1sID8gbmV3IFNWRyhvcHRpb25zKSA6IG51bGw7XG59XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vLi4vbWFwL01hcCc7XG5pbXBvcnQge2NhbnZhc30gZnJvbSAnLi9DYW52YXMnO1xuaW1wb3J0IHtzdmd9IGZyb20gJy4vU1ZHJztcblxuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbmFtZXNwYWNlIE1hcDsgQG1ldGhvZCBnZXRSZW5kZXJlcihsYXllcjogUGF0aCk6IFJlbmRlcmVyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG5cdC8vIGBQYXRoYC4gSXQgd2lsbCBlbnN1cmUgdGhhdCB0aGUgYHJlbmRlcmVyYCBvcHRpb25zIG9mIHRoZSBtYXAgYW5kIHBhdGhzXG5cdC8vIGFyZSByZXNwZWN0ZWQsIGFuZCB0aGF0IHRoZSByZW5kZXJlcnMgZG8gZXhpc3Qgb24gdGhlIG1hcC5cblx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aDsgQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXJcblx0XHQvLyBVc2UgdGhpcyBzcGVjaWZpYyBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIGZvciB0aGlzIHBhdGguIFRha2VzXG5cdFx0Ly8gcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXAncyBbZGVmYXVsdCByZW5kZXJlcl0oI21hcC1yZW5kZXJlcikuXG5cdFx0dmFyIHJlbmRlcmVyID0gbGF5ZXIub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9nZXRQYW5lUmVuZGVyZXIobGF5ZXIub3B0aW9ucy5wYW5lKSB8fCB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fcmVuZGVyZXI7XG5cblx0XHRpZiAoIXJlbmRlcmVyKSB7XG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIocmVuZGVyZXIpKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9LFxuXG5cdF9nZXRQYW5lUmVuZGVyZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09ICdvdmVybGF5UGFuZScgfHwgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXTtcblx0XHRpZiAocmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcih7cGFuZTogbmFtZX0pO1xuXHRcdFx0dGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXSA9IHJlbmRlcmVyO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2NyZWF0ZVJlbmRlcmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdC8vIEBuYW1lc3BhY2UgTWFwOyBAb3B0aW9uIHByZWZlckNhbnZhczogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciBgUGF0aGBzIHNob3VsZCBiZSByZW5kZXJlZCBvbiBhIGBDYW52YXNgIHJlbmRlcmVyLlxuXHRcdC8vIEJ5IGRlZmF1bHQsIGFsbCBgUGF0aGBzIGFyZSByZW5kZXJlZCBpbiBhIGBTVkdgIHJlbmRlcmVyLlxuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnByZWZlckNhbnZhcyAmJiBjYW52YXMob3B0aW9ucykpIHx8IHN2ZyhvcHRpb25zKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1BvbHlnb259IGZyb20gJy4vUG9seWdvbic7XG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcblxuLypcbiAqIEwuUmVjdGFuZ2xlIGV4dGVuZHMgUG9seWdvbiBhbmQgY3JlYXRlcyBhIHJlY3RhbmdsZSB3aGVuIHBhc3NlZCBhIExhdExuZ0JvdW5kcyBvYmplY3QuXG4gKi9cblxuLypcbiAqIEBjbGFzcyBSZWN0YW5nbGVcbiAqIEBha2EgTC5SZWN0YW5nbGVcbiAqIEBpbmhlcml0cyBQb2x5Z29uXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyByZWN0YW5nbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlnb25gLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGRlZmluZSByZWN0YW5nbGUgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuICogdmFyIGJvdW5kcyA9IFtbNTQuNTU5MzIyLCAtNS43Njc4MjJdLCBbNTYuMTIxMDYwNCwgLTMuMDIxMjQwXV07XG4gKlxuICogLy8gY3JlYXRlIGFuIG9yYW5nZSByZWN0YW5nbGVcbiAqIEwucmVjdGFuZ2xlKGJvdW5kcywge2NvbG9yOiBcIiNmZjc4MDBcIiwgd2VpZ2h0OiAxfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHJlY3RhbmdsZSBib3VuZHNcbiAqIG1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAqIGBgYFxuICpcbiAqL1xuXG5cbmV4cG9ydCB2YXIgUmVjdGFuZ2xlID0gUG9seWdvbi5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdFx0UG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgcmVjdGFuZ2xlIHdpdGggdGhlIHBhc3NlZCBib3VuZHMuXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdHJldHVybiB0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xuXHR9LFxuXG5cdF9ib3VuZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRsYXRMbmdCb3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRMbmdCb3VuZHMpO1xuXHRcdHJldHVybiBbXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KClcblx0XHRdO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnJlY3RhbmdsZShsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5leHBvcnQgZnVuY3Rpb24gcmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpO1xufVxuIiwiZXhwb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5leHBvcnQge0NhbnZhcywgY2FudmFzfSBmcm9tICcuL0NhbnZhcyc7XG5pbXBvcnQge1NWRywgY3JlYXRlLCBwb2ludHNUb1BhdGgsIHN2Z30gZnJvbSAnLi9TVkcnO1xuU1ZHLmNyZWF0ZSA9IGNyZWF0ZTtcblNWRy5wb2ludHNUb1BhdGggPSBwb2ludHNUb1BhdGg7XG5leHBvcnQge1NWRywgc3ZnfTtcbmltcG9ydCAnLi9SZW5kZXJlci5nZXRSZW5kZXJlcic7XHQvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjaywgYnV0IG5lZWRlZCBiZWNhdXNlIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuXG5leHBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5leHBvcnQge0NpcmNsZU1hcmtlciwgY2lyY2xlTWFya2VyfSBmcm9tICcuL0NpcmNsZU1hcmtlcic7XG5leHBvcnQge0NpcmNsZSwgY2lyY2xlfSBmcm9tICcuL0NpcmNsZSc7XG5leHBvcnQge1BvbHlsaW5lLCBwb2x5bGluZX0gZnJvbSAnLi9Qb2x5bGluZSc7XG5leHBvcnQge1BvbHlnb24sIHBvbHlnb259IGZyb20gJy4vUG9seWdvbic7XG5leHBvcnQge1JlY3RhbmdsZSwgcmVjdGFuZ2xlfSBmcm9tICcuL1JlY3RhbmdsZSc7XG4iLCJleHBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcbmV4cG9ydCB7TGF5ZXJHcm91cCwgbGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcbmV4cG9ydCB7RmVhdHVyZUdyb3VwLCBmZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcbmltcG9ydCB7R2VvSlNPTiwgZ2VvSlNPTiwgZ2VvSnNvbiwgZ2VvbWV0cnlUb0xheWVyLCBjb29yZHNUb0xhdExuZywgY29vcmRzVG9MYXRMbmdzLCBsYXRMbmdUb0Nvb3JkcywgbGF0TG5nc1RvQ29vcmRzLCBnZXRGZWF0dXJlLCBhc0ZlYXR1cmV9IGZyb20gJy4vR2VvSlNPTic7XG5HZW9KU09OLmdlb21ldHJ5VG9MYXllciA9IGdlb21ldHJ5VG9MYXllcjtcbkdlb0pTT04uY29vcmRzVG9MYXRMbmcgPSBjb29yZHNUb0xhdExuZztcbkdlb0pTT04uY29vcmRzVG9MYXRMbmdzID0gY29vcmRzVG9MYXRMbmdzO1xuR2VvSlNPTi5sYXRMbmdUb0Nvb3JkcyA9IGxhdExuZ1RvQ29vcmRzO1xuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHMgPSBsYXRMbmdzVG9Db29yZHM7XG5HZW9KU09OLmdldEZlYXR1cmUgPSBnZXRGZWF0dXJlO1xuR2VvSlNPTi5hc0ZlYXR1cmUgPSBhc0ZlYXR1cmU7XG5leHBvcnQge0dlb0pTT04sIGdlb0pTT04sIGdlb0pzb259O1xuXG5leHBvcnQge0ltYWdlT3ZlcmxheSwgaW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XG5leHBvcnQge1ZpZGVvT3ZlcmxheSwgdmlkZW9PdmVybGF5fSBmcm9tICcuL1ZpZGVvT3ZlcmxheSc7XG5leHBvcnQge1NWR092ZXJsYXksIHN2Z092ZXJsYXl9IGZyb20gJy4vU1ZHT3ZlcmxheSc7XG5cbmV4cG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcbmV4cG9ydCB7UG9wdXAsIHBvcHVwfSBmcm9tICcuL1BvcHVwJztcbmV4cG9ydCB7VG9vbHRpcCwgdG9vbHRpcH0gZnJvbSAnLi9Ub29sdGlwJztcblxuZXhwb3J0ICogZnJvbSAnLi9tYXJrZXIvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi90aWxlL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdmVjdG9yL2luZGV4JztcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuQm94Wm9vbSBpcyB1c2VkIHRvIGFkZCBzaGlmdC1kcmFnIHpvb20gaW50ZXJhY3Rpb24gdG8gdGhlIG1hcFxuICogKHpvb20gdG8gYSBzZWxlY3RlZCBib3VuZGluZyBib3gpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGJveFpvb206IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIHRvIGEgcmVjdGFuZ3VsYXIgYXJlYSBzcGVjaWZpZWQgYnlcblx0Ly8gZHJhZ2dpbmcgdGhlIG1vdXNlIHdoaWxlIHByZXNzaW5nIHRoZSBzaGlmdCBrZXkuXG5cdGJveFpvb206IHRydWVcbn0pO1xuXG5leHBvcnQgdmFyIEJveFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbWFwLl9jb250YWluZXI7XG5cdFx0dGhpcy5fcGFuZSA9IG1hcC5fcGFuZXMub3ZlcmxheVBhbmU7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdG1hcC5vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveSwgdGhpcyk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21vdmVkO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcGFuZSk7XG5cdFx0ZGVsZXRlIHRoaXMuX3BhbmU7XG5cdH0sXG5cblx0X3Jlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0fSxcblxuXHRfY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgIT09IDApIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZXNldFN0YXRlVGltZW91dCk7XG5cdFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIENsZWFyIHRoZSBkZWZlcnJlZCByZXNldFN0YXRlIGlmIGl0IGhhc24ndCBleGVjdXRlZCB5ZXQsIG90aGVyd2lzZSBpdFxuXHRcdC8vIHdpbGwgaW50ZXJydXB0IHRoZSBpbnRlcmFjdGlvbiBhbmQgb3JwaGFuIGEgYm94IGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lci5cblx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcblxuXHRcdERvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHREb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcblxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwge1xuXHRcdFx0Y29udGV4dG1lbnU6IERvbUV2ZW50LnN0b3AsXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5fYm94ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXpvb20tYm94JywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblxuXHRcdFx0dGhpcy5fbWFwLmZpcmUoJ2JveHpvb21zdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQsIHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fYm94LCBib3VuZHMubWluKTtcblxuXHRcdHRoaXMuX2JveC5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xuXHRcdHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXHR9LFxuXG5cdF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbW92ZWQpIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2JveCk7XG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cdFx0fVxuXG5cdFx0RG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0RG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcblxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwge1xuXHRcdFx0Y29udGV4dG1lbnU6IERvbUV2ZW50LnN0b3AsXG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9maW5pc2goKTtcblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHsgcmV0dXJuOyB9XG5cdFx0Ly8gUG9zdHBvbmUgdG8gbmV4dCBKUyB0aWNrIHNvIGludGVybmFsIGNsaWNrIGV2ZW50IGhhbmRsaW5nXG5cdFx0Ly8gc3RpbGwgc2VlIGl0IGFzIFwibW92ZWRcIi5cblx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fcmVzZXRTdGF0ZSwgdGhpcyksIDApO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50KSk7XG5cblx0XHR0aGlzLl9tYXBcblx0XHRcdC5maXRCb3VuZHMoYm91bmRzKVxuXHRcdFx0LmZpcmUoJ2JveHpvb21lbmQnLCB7Ym94Wm9vbUJvdW5kczogYm91bmRzfSk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5rZXlDb2RlID09PSAyNykge1xuXHRcdFx0dGhpcy5fZmluaXNoKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBib3hab29tOiBIYW5kbGVyXG4vLyBCb3ggKHNoaWZ0LWRyYWcgd2l0aCBtb3VzZSkgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2JveFpvb20nLCBCb3hab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZG91YmxlQ2xpY2tab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcblx0Ly8gYCdjZW50ZXInYCwgZG91YmxlLWNsaWNrIHpvb20gd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlXG5cdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBEb3VibGVDbGlja1pvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgZGVsdGEgPSBtYXAub3B0aW9ucy56b29tRGVsdGEsXG5cdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vL1xuLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4vLyBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoXG4vLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcbi8vXG4vLyBgYGBqc1xuLy8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4vLyBgYGBcbi8vXG4vLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG4vLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RvdWJsZUNsaWNrWm9vbScsIERvdWJsZUNsaWNrWm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHt0b0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRyYWdnaW5nOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgYmUgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuXHRkcmFnZ2luZzogdHJ1ZSxcblxuXHQvLyBAc2VjdGlvbiBQYW5uaW5nIEluZXJ0aWEgT3B0aW9uc1xuXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG5cdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcblx0Ly8gdGhlIG1hcCBidWlsZHMgbW9tZW50dW0gd2hpbGUgZHJhZ2dpbmcgYW5kIGNvbnRpbnVlcyBtb3ZpbmcgaW5cblx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQgdW5sZXNzIHJ1bm5pbmcgb24gb2xkIEFuZHJvaWQgZGV2aWNlcy5cblx0aW5lcnRpYTogIUJyb3dzZXIuYW5kcm9pZDIzLFxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYURlY2VsZXJhdGlvbjogTnVtYmVyID0gMzAwMFxuXHQvLyBUaGUgcmF0ZSB3aXRoIHdoaWNoIHRoZSBpbmVydGlhbCBtb3ZlbWVudCBzbG93cyBkb3duLCBpbiBwaXhlbHMvc2Vjb25kwrIuXG5cdGluZXJ0aWFEZWNlbGVyYXRpb246IDM0MDAsIC8vIHB4L3NeMlxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYU1heFNwZWVkOiBOdW1iZXIgPSBJbmZpbml0eVxuXHQvLyBNYXggc3BlZWQgb2YgdGhlIGluZXJ0aWFsIG1vdmVtZW50LCBpbiBwaXhlbHMvc2Vjb25kLlxuXHRpbmVydGlhTWF4U3BlZWQ6IEluZmluaXR5LCAvLyBweC9zXG5cblx0Ly8gQG9wdGlvbiBlYXNlTGluZWFyaXR5OiBOdW1iZXIgPSAwLjJcblx0ZWFzZUxpbmVhcml0eTogMC4yLFxuXG5cdC8vIFRPRE8gcmVmYWN0b3IsIG1vdmUgdG8gQ1JTXG5cdC8vIEBvcHRpb24gd29ybGRDb3B5SnVtcDogQm9vbGVhbiA9IGZhbHNlXG5cdC8vIFdpdGggdGhpcyBvcHRpb24gZW5hYmxlZCwgdGhlIG1hcCB0cmFja3Mgd2hlbiB5b3UgcGFuIHRvIGFub3RoZXIgXCJjb3B5XCJcblx0Ly8gb2YgdGhlIHdvcmxkIGFuZCBzZWFtbGVzc2x5IGp1bXBzIHRvIHRoZSBvcmlnaW5hbCBvbmUgc28gdGhhdCBhbGwgb3ZlcmxheXNcblx0Ly8gbGlrZSBtYXJrZXJzIGFuZCB2ZWN0b3IgbGF5ZXJzIGFyZSBzdGlsbCB2aXNpYmxlLlxuXHR3b3JsZENvcHlKdW1wOiBmYWxzZSxcblxuXHQvLyBAb3B0aW9uIG1heEJvdW5kc1Zpc2Nvc2l0eTogTnVtYmVyID0gMC4wXG5cdC8vIElmIGBtYXhCb3VuZHNgIGlzIHNldCwgdGhpcyBvcHRpb24gd2lsbCBjb250cm9sIGhvdyBzb2xpZCB0aGUgYm91bmRzXG5cdC8vIGFyZSB3aGVuIGRyYWdnaW5nIHRoZSBtYXAgYXJvdW5kLiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiBgMC4wYCBhbGxvd3MgdGhlXG5cdC8vIHVzZXIgdG8gZHJhZyBvdXRzaWRlIHRoZSBib3VuZHMgYXQgbm9ybWFsIHNwZWVkLCBoaWdoZXIgdmFsdWVzIHdpbGxcblx0Ly8gc2xvdyBkb3duIG1hcCBkcmFnZ2luZyBvdXRzaWRlIGJvdW5kcywgYW5kIGAxLjBgIG1ha2VzIHRoZSBib3VuZHMgZnVsbHlcblx0Ly8gc29saWQsIHByZXZlbnRpbmcgdGhlIHVzZXIgZnJvbSBkcmFnZ2luZyBvdXRzaWRlIHRoZSBib3VuZHMuXG5cdG1heEJvdW5kc1Zpc2Nvc2l0eTogMC4wXG59KTtcblxuZXhwb3J0IHZhciBEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ0xpbWl0LCB0aGlzKTtcblx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ1dyYXAsIHRoaXMpO1xuXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXG5cdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYiBsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCk7XG5cdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWInKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRtb3Zpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRtYXAuX3N0b3AoKTtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzICYmIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IGxhdExuZ0JvdW5kcyh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IHRvQm91bmRzKFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLm11bHRpcGx5QnkoLTEpLFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0U291dGhFYXN0KCkpLm11bHRpcGx5QnkoLTEpXG5cdFx0XHRcdFx0LmFkZCh0aGlzLl9tYXAuZ2V0U2l6ZSgpKSk7XG5cblx0XHRcdHRoaXMuX3Zpc2Nvc2l0eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4wLCB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSBudWxsO1xuXHRcdH1cblxuXHRcdG1hcFxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLl9sYXN0VGltZSA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnB1c2gocG9zKTtcblx0XHRcdHRoaXMuX3RpbWVzLnB1c2godGltZSk7XG5cblx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKHRpbWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21hcFxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X3BydW5lUG9zaXRpb25zOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHdoaWxlICh0aGlzLl9wb3NpdGlvbnMubGVuZ3RoID4gMSAmJiB0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiA1MCkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnNoaWZ0KCk7XG5cdFx0XHR0aGlzLl90aW1lcy5zaGlmdCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Q2VudGVyID0gdGhpcy5fbWFwLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcblx0XHQgICAgcHhXb3JsZENlbnRlciA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoWzAsIDBdKTtcblxuXHRcdHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCA9IHB4V29ybGRDZW50ZXIuc3VidHJhY3QocHhDZW50ZXIpLng7XG5cdFx0dGhpcy5fd29ybGRXaWR0aCA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKCkuZ2V0U2l6ZSgpLng7XG5cdH0sXG5cblx0X3Zpc2NvdXNMaW1pdDogZnVuY3Rpb24gKHZhbHVlLCB0aHJlc2hvbGQpIHtcblx0XHRyZXR1cm4gdmFsdWUgLSAodmFsdWUgLSB0aHJlc2hvbGQpICogdGhpcy5fdmlzY29zaXR5O1xuXHR9LFxuXG5cdF9vblByZURyYWdMaW1pdDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fdmlzY29zaXR5IHx8ICF0aGlzLl9vZmZzZXRMaW1pdCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zKTtcblxuXHRcdHZhciBsaW1pdCA9IHRoaXMuX29mZnNldExpbWl0O1xuXHRcdGlmIChvZmZzZXQueCA8IGxpbWl0Lm1pbi54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5taW4ueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPCBsaW1pdC5taW4ueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWluLnkpOyB9XG5cdFx0aWYgKG9mZnNldC54ID4gbGltaXQubWF4LngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1heC54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA+IGxpbWl0Lm1heC55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5tYXgueSk7IH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcblx0fSxcblxuXHRfb25QcmVEcmFnV3JhcDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRPRE8gcmVmYWN0b3IgdG8gYmUgYWJsZSB0byBhZGp1c3QgbWFwIHBhbmUgcG9zaXRpb24gYWZ0ZXIgem9vbVxuXHRcdHZhciB3b3JsZFdpZHRoID0gdGhpcy5fd29ybGRXaWR0aCxcblx0XHQgICAgaGFsZldpZHRoID0gTWF0aC5yb3VuZCh3b3JsZFdpZHRoIC8gMiksXG5cdFx0ICAgIGR4ID0gdGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0LFxuXHRcdCAgICB4ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCxcblx0XHQgICAgbmV3WDEgPSAoeCAtIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggKyBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WDIgPSAoeCArIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggLSBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WCA9IE1hdGguYWJzKG5ld1gxICsgZHgpIDwgTWF0aC5hYnMobmV3WDIgKyBkeCkgPyBuZXdYMSA6IG5ld1gyO1xuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5jbG9uZSgpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnggPSBuZXdYO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb3B0aW9ucyA9IG1hcC5vcHRpb25zLFxuXG5cdFx0ICAgIG5vSW5lcnRpYSA9ICFvcHRpb25zLmluZXJ0aWEgfHwgdGhpcy5fdGltZXMubGVuZ3RoIDwgMjtcblxuXHRcdG1hcC5maXJlKCdkcmFnZW5kJywgZSk7XG5cblx0XHRpZiAobm9JbmVydGlhKSB7XG5cdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKCtuZXcgRGF0ZSgpKTtcblxuXHRcdFx0dmFyIGRpcmVjdGlvbiA9IHRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxcblx0XHRcdCAgICBkdXJhdGlvbiA9ICh0aGlzLl9sYXN0VGltZSAtIHRoaXMuX3RpbWVzWzBdKSAvIDEwMDAsXG5cdFx0XHQgICAgZWFzZSA9IG9wdGlvbnMuZWFzZUxpbmVhcml0eSxcblxuXHRcdFx0ICAgIHNwZWVkVmVjdG9yID0gZGlyZWN0aW9uLm11bHRpcGx5QnkoZWFzZSAvIGR1cmF0aW9uKSxcblx0XHRcdCAgICBzcGVlZCA9IHNwZWVkVmVjdG9yLmRpc3RhbmNlVG8oWzAsIDBdKSxcblxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZCA9IE1hdGgubWluKG9wdGlvbnMuaW5lcnRpYU1heFNwZWVkLCBzcGVlZCksXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkVmVjdG9yID0gc3BlZWRWZWN0b3IubXVsdGlwbHlCeShsaW1pdGVkU3BlZWQgLyBzcGVlZCksXG5cblx0XHRcdCAgICBkZWNlbGVyYXRpb25EdXJhdGlvbiA9IGxpbWl0ZWRTcGVlZCAvIChvcHRpb25zLmluZXJ0aWFEZWNlbGVyYXRpb24gKiBlYXNlKSxcblx0XHRcdCAgICBvZmZzZXQgPSBsaW1pdGVkU3BlZWRWZWN0b3IubXVsdGlwbHlCeSgtZGVjZWxlcmF0aW9uRHVyYXRpb24gLyAyKS5yb3VuZCgpO1xuXG5cdFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xuXHRcdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KG9mZnNldCwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuXHRcdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcblx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG5cdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZSxcblx0XHRcdFx0XHRcdGFuaW1hdGU6IHRydWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuLy8gTWFwIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIERyYWcpO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQge29uLCBvZmYsIHN0b3B9IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcblxuXG4vKlxuICogTC5NYXAuS2V5Ym9hcmQgaXMgaGFuZGxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEtleWJvYXJkIE5hdmlnYXRpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIE1ha2VzIHRoZSBtYXAgZm9jdXNhYmxlIGFuZCBhbGxvd3MgdXNlcnMgdG8gbmF2aWdhdGUgdGhlIG1hcCB3aXRoIGtleWJvYXJkXG5cdC8vIGFycm93cyBhbmQgYCtgL2AtYCBrZXlzLlxuXHRrZXlib2FyZDogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIGtleWJvYXJkUGFuRGVsdGE6IE51bWJlciA9IDgwXG5cdC8vIEFtb3VudCBvZiBwaXhlbHMgdG8gcGFuIHdoZW4gcHJlc3NpbmcgYW4gYXJyb3cga2V5LlxuXHRrZXlib2FyZFBhbkRlbHRhOiA4MFxufSk7XG5cbmV4cG9ydCB2YXIgS2V5Ym9hcmQgPSBIYW5kbGVyLmV4dGVuZCh7XG5cblx0a2V5Q29kZXM6IHtcblx0XHRsZWZ0OiAgICBbMzddLFxuXHRcdHJpZ2h0OiAgIFszOV0sXG5cdFx0ZG93bjogICAgWzQwXSxcblx0XHR1cDogICAgICBbMzhdLFxuXHRcdHpvb21JbjogIFsxODcsIDEwNywgNjEsIDE3MV0sXG5cdFx0em9vbU91dDogWzE4OSwgMTA5LCA1NCwgMTczXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cblx0XHR0aGlzLl9zZXRQYW5EZWx0YShtYXAub3B0aW9ucy5rZXlib2FyZFBhbkRlbHRhKTtcblx0XHR0aGlzLl9zZXRab29tRGVsdGEobWFwLm9wdGlvbnMuem9vbURlbHRhKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9tYXAuX2NvbnRhaW5lcjtcblxuXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xuXHRcdGlmIChjb250YWluZXIudGFiSW5kZXggPD0gMCkge1xuXHRcdFx0Y29udGFpbmVyLnRhYkluZGV4ID0gJzAnO1xuXHRcdH1cblxuXHRcdG9uKGNvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub24oe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cblx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9mZih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9mb2N1c2VkKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuXHRcdCAgICBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxuXHRcdCAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsLnNjcm9sbExlZnQ7XG5cblx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xuXG5cdFx0d2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG5cdH0sXG5cblx0X29uRm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnZm9jdXMnKTtcblx0fSxcblxuXHRfb25CbHVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdibHVyJyk7XG5cdH0sXG5cblx0X3NldFBhbkRlbHRhOiBmdW5jdGlvbiAocGFuRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3BhbktleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5sZWZ0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmxlZnRbaV1dID0gWy0xICogcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5yaWdodC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5yaWdodFtpXV0gPSBbcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5kb3duLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmRvd25baV1dID0gWzAsIHBhbkRlbHRhXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMudXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMudXBbaV1dID0gWzAsIC0xICogcGFuRGVsdGFdO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbURlbHRhOiBmdW5jdGlvbiAoem9vbURlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl96b29tS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21Jbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tSW5baV1dID0gem9vbURlbHRhO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tT3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21PdXRbaV1dID0gLXpvb21EZWx0YTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGtleSA9IGUua2V5Q29kZSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvZmZzZXQ7XG5cblx0XHRpZiAoa2V5IGluIHRoaXMuX3BhbktleXMpIHtcblx0XHRcdGlmICghbWFwLl9wYW5BbmltIHx8ICFtYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpIHtcblx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5fcGFuS2V5c1trZXldO1xuXHRcdFx0XHRpZiAoZS5zaGlmdEtleSkge1xuXHRcdFx0XHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5tdWx0aXBseUJ5KDMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCk7XG5cblx0XHRcdFx0aWYgKG1hcC5vcHRpb25zLm1heEJvdW5kcykge1xuXHRcdFx0XHRcdG1hcC5wYW5JbnNpZGVCb3VuZHMobWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgKGUuc2hpZnRLZXkgPyAzIDogMSkgKiB0aGlzLl96b29tS2V5c1trZXldKTtcblxuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAyNyAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5jbG9zZU9uRXNjYXBlS2V5KSB7XG5cdFx0XHRtYXAuY2xvc2VQb3B1cCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzdG9wKGUpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkga2V5Ym9hcmQ6IEhhbmRsZXJcbi8vIEtleWJvYXJkIG5hdmlnYXRpb24gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEtleWJvYXJkKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIE1vdXNld2hlZWwgb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHNjcm9sbFdoZWVsWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHVzaW5nIHRoZSBtb3VzZSB3aGVlbC4gSWYgcGFzc2VkIGAnY2VudGVyJ2AsXG5cdC8vIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0c2Nyb2xsV2hlZWxab29tOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxEZWJvdW5jZVRpbWU6IE51bWJlciA9IDQwXG5cdC8vIExpbWl0cyB0aGUgcmF0ZSBhdCB3aGljaCBhIHdoZWVsIGNhbiBmaXJlIChpbiBtaWxsaXNlY29uZHMpLiBCeSBkZWZhdWx0XG5cdC8vIHVzZXIgY2FuJ3Qgem9vbSB2aWEgd2hlZWwgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIDQwIG1zLlxuXHR3aGVlbERlYm91bmNlVGltZTogNDAsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbFB4UGVyWm9vbUxldmVsOiBOdW1iZXIgPSA2MFxuXHQvLyBIb3cgbWFueSBzY3JvbGwgcGl4ZWxzIChhcyByZXBvcnRlZCBieSBbTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhXSgjZG9tZXZlbnQtZ2V0d2hlZWxkZWx0YSkpXG5cdC8vIG1lYW4gYSBjaGFuZ2Ugb2Ygb25lIGZ1bGwgem9vbSBsZXZlbC4gU21hbGxlciB2YWx1ZXMgd2lsbCBtYWtlIHdoZWVsLXpvb21pbmdcblx0Ly8gZmFzdGVyIChhbmQgdmljZSB2ZXJzYSkuXG5cdHdoZWVsUHhQZXJab29tTGV2ZWw6IDYwXG59KTtcblxuZXhwb3J0IHZhciBTY3JvbGxXaGVlbFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cdH0sXG5cblx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGRlbHRhID0gRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YShlKTtcblxuXHRcdHZhciBkZWJvdW5jZSA9IHRoaXMuX21hcC5vcHRpb25zLndoZWVsRGVib3VuY2VUaW1lO1xuXG5cdFx0dGhpcy5fZGVsdGEgKz0gZGVsdGE7XG5cdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0aWYgKCF0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXHRcdH1cblxuXHRcdHZhciBsZWZ0ID0gTWF0aC5tYXgoZGVib3VuY2UgLSAoK25ldyBEYXRlKCkgLSB0aGlzLl9zdGFydFRpbWUpLCAwKTtcblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG5cdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcblx0fSxcblxuXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgc25hcCA9IHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwIHx8IDA7XG5cblx0XHRtYXAuX3N0b3AoKTsgLy8gc3RvcCBwYW5uaW5nIGFuZCBmbHkgYW5pbWF0aW9ucyBpZiBhbnlcblxuXHRcdC8vIG1hcCB0aGUgZGVsdGEgd2l0aCBhIHNpZ21vaWQgZnVuY3Rpb24gdG8gLTQuLjQgcmFuZ2UgbGVhbmluZyBvbiAtMS4uMVxuXHRcdHZhciBkMiA9IHRoaXMuX2RlbHRhIC8gKHRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwgKiA0KSxcblx0XHQgICAgZDMgPSA0ICogTWF0aC5sb2coMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGQyKSkpKSAvIE1hdGguTE4yLFxuXHRcdCAgICBkNCA9IHNuYXAgPyBNYXRoLmNlaWwoZDMgLyBzbmFwKSAqIHNuYXAgOiBkMyxcblx0XHQgICAgZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgKHRoaXMuX2RlbHRhID4gMCA/IGQ0IDogLWQ0KSkgLSB6b29tO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0XHRpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20gKyBkZWx0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHNjcm9sbFdoZWVsWm9vbTogSGFuZGxlclxuLy8gU2Nyb2xsIHdoZWVsIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdzY3JvbGxXaGVlbFpvb20nLCBTY3JvbGxXaGVlbFpvb20pO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cblxuLypcbiAqIEwuTWFwLlRhcCBpcyB1c2VkIHRvIGVuYWJsZSBtb2JpbGUgaGFja3MgbGlrZSBxdWljayB0YXBzIGFuZCBsb25nIGhvbGQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdGFwOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBFbmFibGVzIG1vYmlsZSBoYWNrcyBmb3Igc3VwcG9ydGluZyBpbnN0YW50IHRhcHMgKGZpeGluZyAyMDBtcyBjbGlja1xuXHQvLyBkZWxheSBvbiBpT1MvQW5kcm9pZCkgYW5kIHRvdWNoIGhvbGRzIChmaXJlZCBhcyBgY29udGV4dG1lbnVgIGV2ZW50cykuXG5cdHRhcDogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHRhcFRvbGVyYW5jZTogTnVtYmVyID0gMTVcblx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgaGlzIGZpbmdlciBkdXJpbmcgdG91Y2hcblx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCB0YXAuXG5cdHRhcFRvbGVyYW5jZTogMTVcbn0pO1xuXG5leHBvcnQgdmFyIFRhcCA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcykgeyByZXR1cm47IH1cblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXG5cdFx0dGhpcy5fZmlyZUNsaWNrID0gdHJ1ZTtcblxuXHRcdC8vIGRvbid0IHNpbXVsYXRlIGNsaWNrIG9yIHRyYWNrIGxvbmdwcmVzcyBpZiBtb3JlIHRoYW4gMSB0b3VjaFxuXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXSxcblx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuXHRcdC8vIGlmIHRvdWNoaW5nIGEgbGluaywgaGlnaGxpZ2h0IGl0XG5cdFx0aWYgKGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LWFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdC8vIHNpbXVsYXRlIGxvbmcgaG9sZCBidXQgc2V0dGluZyBhIHRpbWVvdXRcblx0XHR0aGlzLl9ob2xkVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX29uVXAoKTtcblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyksIDEwMDApO1xuXG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vkb3duJywgZmlyc3QpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCB7XG5cdFx0XHR0b3VjaG1vdmU6IHRoaXMuX29uTW92ZSxcblx0XHRcdHRvdWNoZW5kOiB0aGlzLl9vblVwXG5cdFx0fSwgdGhpcyk7XG5cblx0XHRpZiAodGhpcy5fZmlyZUNsaWNrICYmIGUgJiYgZS5jaGFuZ2VkVG91Y2hlcykge1xuXG5cdFx0XHR2YXIgZmlyc3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLFxuXHRcdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0XHRpZiAoZWwgJiYgZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2V1cCcsIGZpcnN0KTtcblxuXHRcdFx0Ly8gc2ltdWxhdGUgY2xpY2sgaWYgdGhlIHRvdWNoIGRpZG4ndCBtb3ZlIHRvbyBtdWNoXG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NsaWNrJywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfaXNUYXBWYWxpZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcykgPD0gdGhpcy5fbWFwLm9wdGlvbnMudGFwVG9sZXJhbmNlO1xuXHR9LFxuXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xuXHRcdHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdtb3VzZW1vdmUnLCBmaXJzdCk7XG5cdH0sXG5cblx0X3NpbXVsYXRlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG5cdFx0dmFyIHNpbXVsYXRlZEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTtcblx0XHRlLnRhcmdldC5fc2ltdWxhdGVkQ2xpY2sgPSB0cnVlO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQoXG5cdFx0ICAgICAgICB0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsXG5cdFx0ICAgICAgICBlLnNjcmVlblgsIGUuc2NyZWVuWSxcblx0XHQgICAgICAgIGUuY2xpZW50WCwgZS5jbGllbnRZLFxuXHRcdCAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRhcDogSGFuZGxlclxuLy8gTW9iaWxlIHRvdWNoIGhhY2tzIChxdWljayB0YXAgYW5kIHRvdWNoIGhvbGQpIGhhbmRsZXIuXG5pZiAoQnJvd3Nlci50b3VjaCAmJiAhQnJvd3Nlci5wb2ludGVyKSB7XG5cdE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0YXAnLCBUYXApO1xufVxuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8qXG4gKiBMLkhhbmRsZXIuVG91Y2hab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gYWRkIHBpbmNoIHpvb20gb24gc3VwcG9ydGVkIG1vYmlsZSBicm93c2Vycy5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0b3VjaFpvb206IEJvb2xlYW58U3RyaW5nID0gKlxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB0b3VjaC1kcmFnZ2luZyB3aXRoIHR3byBmaW5nZXJzLiBJZlxuXHQvLyBwYXNzZWQgYCdjZW50ZXInYCwgaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZlxuXHQvLyB3aGVyZSB0aGUgdG91Y2ggZXZlbnRzIChmaW5nZXJzKSB3ZXJlLiBFbmFibGVkIGZvciB0b3VjaC1jYXBhYmxlIHdlYlxuXHQvLyBicm93c2VycyBleGNlcHQgZm9yIG9sZCBBbmRyb2lkcy5cblx0dG91Y2hab29tOiBCcm93c2VyLnRvdWNoICYmICFCcm93c2VyLmFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGJvdW5jZUF0Wm9vbUxpbWl0czogQm9vbGVhbiA9IHRydWVcblx0Ly8gU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gem9vbSBiZXlvbmQgbWluL21heCB6b29tXG5cdC8vIGFuZCB0aGVuIGJvdW5jZSBiYWNrIHdoZW4gcGluY2gtem9vbWluZy5cblx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBUb3VjaFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgbWFwLl9hbmltYXRpbmdab29tIHx8IHRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKTtcblxuXHRcdHRoaXMuX2NlbnRlclBvaW50ID0gbWFwLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XG5cdFx0dGhpcy5fc3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSAhPT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhwMS5hZGQocDIpLl9kaXZpZGVCeSgyKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3RhcnREaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0dGhpcy5fc3RhcnRab29tID0gbWFwLmdldFpvb20oKTtcblxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5fem9vbWluZyA9IHRydWU7XG5cblx0XHRtYXAuX3N0b3AoKTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8ICF0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKSxcblx0XHQgICAgc2NhbGUgPSBwMS5kaXN0YW5jZVRvKHAyKSAvIHRoaXMuX3N0YXJ0RGlzdDtcblxuXHRcdHRoaXMuX3pvb20gPSBtYXAuZ2V0U2NhbGVab29tKHNjYWxlLCB0aGlzLl9zdGFydFpvb20pO1xuXG5cdFx0aWYgKCFtYXAub3B0aW9ucy5ib3VuY2VBdFpvb21MaW1pdHMgJiYgKFxuXHRcdFx0KHRoaXMuX3pvb20gPCBtYXAuZ2V0TWluWm9vbSgpICYmIHNjYWxlIDwgMSkgfHxcblx0XHRcdCh0aGlzLl96b29tID4gbWFwLmdldE1heFpvb20oKSAmJiBzY2FsZSA+IDEpKSkge1xuXHRcdFx0dGhpcy5fem9vbSA9IG1hcC5fbGltaXRab29tKHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9zdGFydExhdExuZztcblx0XHRcdGlmIChzY2FsZSA9PT0gMSkgeyByZXR1cm47IH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gR2V0IGRlbHRhIGZyb20gcGluY2ggdG8gY2VudGVyLCBzbyBjZW50ZXJMYXRMbmcgaXMgZGVsdGEgYXBwbGllZCB0byBpbml0aWFsIHBpbmNoTGF0TG5nXG5cdFx0XHR2YXIgZGVsdGEgPSBwMS5fYWRkKHAyKS5fZGl2aWRlQnkoMikuX3N1YnRyYWN0KHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRcdGlmIChzY2FsZSA9PT0gMSAmJiBkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApIHsgcmV0dXJuOyB9XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSBtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcsIHRoaXMuX3pvb20pLnN1YnRyYWN0KGRlbHRhKSwgdGhpcy5fem9vbSk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0bWFwLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdHZhciBtb3ZlRm4gPSBVdGlsLmJpbmQobWFwLl9tb3ZlLCBtYXAsIHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSwge3BpbmNoOiB0cnVlLCByb3VuZDogZmFsc2V9KTtcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShtb3ZlRm4sIHRoaXMsIHRydWUpO1xuXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG5cdFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuXG5cdFx0Ly8gUGluY2ggdXBkYXRlcyBHcmlkTGF5ZXJzJyBsZXZlbHMgb25seSB3aGVuIHpvb21TbmFwIGlzIG9mZiwgc28gem9vbVNuYXAgYmVjb21lcyBub1VwZGF0ZS5cblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xuXHRcdFx0dGhpcy5fbWFwLl9hbmltYXRlWm9vbSh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCB0cnVlLCB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX21hcC5fcmVzZXRWaWV3KHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgdG91Y2hab29tOiBIYW5kbGVyXG4vLyBUb3VjaCB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgVG91Y2hab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuL01hcCc7XG5pbXBvcnQge0JveFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuQm94Wm9vbSc7XG5NYXAuQm94Wm9vbSA9IEJveFpvb207XG5pbXBvcnQge0RvdWJsZUNsaWNrWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20nO1xuTWFwLkRvdWJsZUNsaWNrWm9vbSA9IERvdWJsZUNsaWNrWm9vbTtcbmltcG9ydCB7RHJhZ30gZnJvbSAnLi9oYW5kbGVyL01hcC5EcmFnJztcbk1hcC5EcmFnID0gRHJhZztcbmltcG9ydCB7S2V5Ym9hcmR9IGZyb20gJy4vaGFuZGxlci9NYXAuS2V5Ym9hcmQnO1xuTWFwLktleWJvYXJkID0gS2V5Ym9hcmQ7XG5pbXBvcnQge1Njcm9sbFdoZWVsWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20nO1xuTWFwLlNjcm9sbFdoZWVsWm9vbSA9IFNjcm9sbFdoZWVsWm9vbTtcbmltcG9ydCB7VGFwfSBmcm9tICcuL2hhbmRsZXIvTWFwLlRhcCc7XG5NYXAuVGFwID0gVGFwO1xuaW1wb3J0IHtUb3VjaFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuVG91Y2hab29tJztcbk1hcC5Ub3VjaFpvb20gPSBUb3VjaFpvb207XG5cbmV4cG9ydCB7TWFwLCBjcmVhdGVNYXAgYXMgbWFwfSBmcm9tICcuL01hcCc7XG4iLCJcclxuaW1wb3J0IHt2ZXJzaW9ufSBmcm9tICcuLi9wYWNrYWdlLmpzb24nO1xyXG5leHBvcnQge3ZlcnNpb259O1xyXG5cclxuLy8gY29udHJvbFxyXG5leHBvcnQgKiBmcm9tICcuL2NvbnRyb2wvaW5kZXgnO1xyXG5cclxuLy8gY29yZVxyXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvaW5kZXgnO1xyXG5cclxuLy8gZG9tXHJcbmV4cG9ydCAqIGZyb20gJy4vZG9tL2luZGV4JztcclxuXHJcbi8vIGdlb21ldHJ5XHJcbmV4cG9ydCAqIGZyb20gJy4vZ2VvbWV0cnkvaW5kZXgnO1xyXG5cclxuLy8gZ2VvXHJcbmV4cG9ydCAqIGZyb20gJy4vZ2VvL2luZGV4JztcclxuXHJcbi8vIGxheWVyXHJcbmV4cG9ydCAqIGZyb20gJy4vbGF5ZXIvaW5kZXgnO1xyXG5cclxuLy8gbWFwXHJcbmV4cG9ydCAqIGZyb20gJy4vbWFwL2luZGV4JztcclxuXHJcbmltcG9ydCB7ZnJlZXplfSBmcm9tICcuL2NvcmUvVXRpbCc7XHJcbk9iamVjdC5mcmVlemUgPSBmcmVlemU7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")},200:function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3);\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "@keyframes chartjs-render-animation{from{opacity:.99}to{opacity:1}}.chartjs-render-monitor{animation:chartjs-render-animation 1ms}.chartjs-size-monitor,.chartjs-size-monitor-expand,.chartjs-size-monitor-shrink{position:absolute;direction:ltr;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1}.chartjs-size-monitor-expand>div{position:absolute;width:1000000px;height:1000000px;left:0;top:0}.chartjs-size-monitor-shrink>div{position:absolute;width:200%;height:200%;left:0;top:0}", ""]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9DaGFydC5taW4uY3NzP2M3M2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxDQUFzQztBQUNoRjtBQUNBO0FBQ0EsY0FBYyxRQUFTLHVDQUF1QyxLQUFLLFlBQVksR0FBRyxXQUFXLHdCQUF3Qix1Q0FBdUMsZ0ZBQWdGLGtCQUFrQixjQUFjLE9BQU8sTUFBTSxRQUFRLFNBQVMsZ0JBQWdCLG9CQUFvQixrQkFBa0IsV0FBVyxpQ0FBaUMsa0JBQWtCLGdCQUFnQixpQkFBaUIsT0FBTyxNQUFNLGlDQUFpQyxrQkFBa0IsV0FBVyxZQUFZLE9BQU8sTUFBTTtBQUNuaUI7QUFDQSIsImZpbGUiOiIyMDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAa2V5ZnJhbWVzIGNoYXJ0anMtcmVuZGVyLWFuaW1hdGlvbntmcm9te29wYWNpdHk6Ljk5fXRve29wYWNpdHk6MX19LmNoYXJ0anMtcmVuZGVyLW1vbml0b3J7YW5pbWF0aW9uOmNoYXJ0anMtcmVuZGVyLWFuaW1hdGlvbiAxbXN9LmNoYXJ0anMtc2l6ZS1tb25pdG9yLC5jaGFydGpzLXNpemUtbW9uaXRvci1leHBhbmQsLmNoYXJ0anMtc2l6ZS1tb25pdG9yLXNocmlua3twb3NpdGlvbjphYnNvbHV0ZTtkaXJlY3Rpb246bHRyO2xlZnQ6MDt0b3A6MDtyaWdodDowO2JvdHRvbTowO292ZXJmbG93OmhpZGRlbjtwb2ludGVyLWV2ZW50czpub25lO3Zpc2liaWxpdHk6aGlkZGVuO3otaW5kZXg6LTF9LmNoYXJ0anMtc2l6ZS1tb25pdG9yLWV4cGFuZD5kaXZ7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwMDAwMHB4O2hlaWdodDoxMDAwMDAwcHg7bGVmdDowO3RvcDowfS5jaGFydGpzLXNpemUtbW9uaXRvci1zaHJpbms+ZGl2e3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjIwMCU7aGVpZ2h0OjIwMCU7bGVmdDowO3RvcDowfVwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///200\n')},24:function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n\n\n  url = url && url.__esModule ? url.default : url;\n\n  if (typeof url !== \'string\') {\n    return url;\n  } // If url is already wrapped in quotes, remove them\n\n\n  if (/^[\'"].*[\'"]$/.test(url)) {\n    // eslint-disable-next-line no-param-reassign\n    url = url.slice(1, -1);\n  }\n\n  if (options.hash) {\n    // eslint-disable-next-line no-param-reassign\n    url += options.hash;\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/["\'() \\t\\n]/.test(url) || options.needQuotes) {\n    return "\\"".concat(url.replace(/"/g, \'\\\\"\').replace(/\\n/g, \'\\\\n\'), "\\"");\n  }\n\n  return url;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzPzFkZTUiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVybCIsIm9wdGlvbnMiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsInRlc3QiLCJzbGljZSIsImhhc2giLCJuZWVkUXVvdGVzIiwiY29uY2F0IiwicmVwbGFjZSJdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWJBLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixVQUFVQyxHQUFWLEVBQWVDLE9BQWYsRUFBd0I7QUFDdkMsTUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDWjtBQUNBQSxXQUFPLEdBQUcsRUFBVjtBQUNELEdBSnNDLENBSXJDOzs7QUFHRkQsS0FBRyxHQUFHQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0UsVUFBWCxHQUF3QkYsR0FBRyxDQUFDRyxPQUE1QixHQUFzQ0gsR0FBNUM7O0FBRUEsTUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0IsV0FBT0EsR0FBUDtBQUNELEdBWHNDLENBV3JDOzs7QUFHRixNQUFJLGVBQWVJLElBQWYsQ0FBb0JKLEdBQXBCLENBQUosRUFBOEI7QUFDNUI7QUFDQUEsT0FBRyxHQUFHQSxHQUFHLENBQUNLLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBQyxDQUFkLENBQU47QUFDRDs7QUFFRCxNQUFJSixPQUFPLENBQUNLLElBQVosRUFBa0I7QUFDaEI7QUFDQU4sT0FBRyxJQUFJQyxPQUFPLENBQUNLLElBQWY7QUFDRCxHQXRCc0MsQ0FzQnJDO0FBQ0Y7OztBQUdBLE1BQUksY0FBY0YsSUFBZCxDQUFtQkosR0FBbkIsS0FBMkJDLE9BQU8sQ0FBQ00sVUFBdkMsRUFBbUQ7QUFDakQsV0FBTyxLQUFLQyxNQUFMLENBQVlSLEdBQUcsQ0FBQ1MsT0FBSixDQUFZLElBQVosRUFBa0IsS0FBbEIsRUFBeUJBLE9BQXpCLENBQWlDLEtBQWpDLEVBQXdDLEtBQXhDLENBQVosRUFBNEQsSUFBNUQsQ0FBUDtBQUNEOztBQUVELFNBQU9ULEdBQVA7QUFDRCxDQS9CRCIsImZpbGUiOiIyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgb3B0aW9ucyA9IHt9O1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tcGFyYW0tcmVhc3NpZ25cblxuXG4gIHVybCA9IHVybCAmJiB1cmwuX19lc01vZHVsZSA/IHVybC5kZWZhdWx0IDogdXJsO1xuXG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB1cmw7XG4gIH0gLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXG5cblxuICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGFzaCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHVybCArPSBvcHRpb25zLmhhc2g7XG4gIH0gLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuXG5cbiAgaWYgKC9bXCInKCkgXFx0XFxuXS8udGVzdCh1cmwpIHx8IG9wdGlvbnMubmVlZFF1b3Rlcykge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQodXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJyksIFwiXFxcIlwiKTtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24\n')},3:function(module,exports,__webpack_require__){"use strict";eval('\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], " {").concat(content, "}");\n      }\n\n      return content;\n    }).join(\'\');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \'string\') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \'\']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\'; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot || \'\').concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n  return "/*# ".concat(data, " */");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInVzZVNvdXJjZU1hcCIsImxpc3QiLCJ0b1N0cmluZyIsIm1hcCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsImNvbmNhdCIsImpvaW4iLCJpIiwibW9kdWxlcyIsIm1lZGlhUXVlcnkiLCJkZWR1cGUiLCJhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzIiwibGVuZ3RoIiwiaWQiLCJfaSIsInB1c2giLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIl0sIm1hcHBpbmdzIjoiQUFBYTtBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQUEsTUFBTSxDQUFDQyxPQUFQLEdBQWlCLFVBQVVDLFlBQVYsRUFBd0I7QUFDdkMsTUFBSUMsSUFBSSxHQUFHLEVBQVgsQ0FEdUMsQ0FDeEI7O0FBRWZBLE1BQUksQ0FBQ0MsUUFBTCxHQUFnQixTQUFTQSxRQUFULEdBQW9CO0FBQ2xDLFdBQU8sS0FBS0MsR0FBTCxDQUFTLFVBQVVDLElBQVYsRUFBZ0I7QUFDOUIsVUFBSUMsT0FBTyxHQUFHQyxzQkFBc0IsQ0FBQ0YsSUFBRCxFQUFPSixZQUFQLENBQXBDOztBQUVBLFVBQUlJLElBQUksQ0FBQyxDQUFELENBQVIsRUFBYTtBQUNYLGVBQU8sVUFBVUcsTUFBVixDQUFpQkgsSUFBSSxDQUFDLENBQUQsQ0FBckIsRUFBMEIsSUFBMUIsRUFBZ0NHLE1BQWhDLENBQXVDRixPQUF2QyxFQUFnRCxHQUFoRCxDQUFQO0FBQ0Q7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LFNBQVQsQ0FBbUJLLFNBQW5CLEVBQThCO0FBQzVCO0FBQ0EsTUFBSUMsTUFBTSxHQUFHUixJQUFJLENBQUNTLFFBQVEsQ0FBQ0Msa0JBQWtCLENBQUNDLElBQUksQ0FBQ0MsU0FBTCxDQUFlTCxTQUFmLENBQUQsQ0FBbkIsQ0FBVCxDQUFqQjtBQUNBLE1BQUlNLElBQUksR0FBRywrREFBK0R6QixNQUEvRCxDQUFzRW9CLE1BQXRFLENBQVg7QUFDQSxTQUFPLE9BQU9wQixNQUFQLENBQWN5QixJQUFkLEVBQW9CLEtBQXBCLENBQVA7QUFDRCIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n')}}]);