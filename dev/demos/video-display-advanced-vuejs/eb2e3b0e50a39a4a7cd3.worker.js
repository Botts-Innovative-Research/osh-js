!function(Q){var B={};function F(I){if(B[I])return B[I].exports;var U=B[I]={i:I,l:!1,exports:{}};return Q[I].call(U.exports,U,U.exports,F),U.l=!0,U.exports}F.m=Q,F.c=B,F.d=function(Q,B,I){F.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:I})},F.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},F.t=function(Q,B){if(1&B&&(Q=F(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var I=Object.create(null);if(F.r(I),Object.defineProperty(I,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var U in Q)F.d(I,U,function(B){return Q[B]}.bind(null,U));return I},F.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return F.d(B,"a",B),B},F.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},F.p="",F(F.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/utils/Utils.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n/** * @module Utils */\n\n/** Maximum value of a long */\nconst MAX_LONG = Math.pow(2, 53) + 1;\n/**\n * Global helper method to test if a letiable or object attribute is defined\n */\n\nfunction isDefined(v) {\n  return typeof v !== 'undefined' && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute has a value,\n that is it is defined and non null\n */\n\nfunction hasValue(v) {\n  return isDefined(v) && v !== null;\n}\n/**\n Global helper method to transform hex color into RGBA\n */\n\nfunction hex2rgb(hex) {\n  const [r, g, b] = hex.match(/\\w\\w/g).map(x => parseInt(x, 16));\n  return [r, g, b];\n}\n/**\n Global helper method to test if a letiable or object attribute is of a particular type\n */\n\nfunction hasType(v, expectedType) {\n  let hasVal = hasValue(v);\n  return hasVal && typeof v === expectedType;\n}\n/**\n Global helper method to test if a letiable or object attribute is an object\n */\n\nfunction isObject(v, letName) {\n  return hasType(v, 'object', letName);\n}\n/**\n Global helper method to test if a letiable or object attribute is an array\n */\n\nfunction isArray(v) {\n  return isDefined(v) && Array.isArray(v);\n}\n/**\n Global helper method to test if a letiable or object attribute is a function\n */\n\nfunction isFunction(v, letName) {\n  return hasType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined\n **/\n\nfunction assertDefined(v, letName = 'letiable') {\n  if (!isDefined(v)) {\n    throw letName + \" must be defined\";\n  }\n\n  return v;\n}\nfunction assertTrue(v, letName = 'letiable') {\n  if (!isDefined(v) || !v) {\n    throw letName;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertType(v, expectedType, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (typeof v !== expectedType) {\n    throw letName + \" must be of type \" + expectedType;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertBoolean(v, letName) {\n  return assertType(v, 'boolean', letName);\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertString(v, letName) {\n  return assertType(v, 'string', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertNumber(v, letName) {\n  return assertType(v, 'number', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertPositive(v, letName) {\n  assertNumber(v, letName);\n\n  if (v <= 0) {\n    throw letName + \" must be a positive number\";\n  }\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertObject(v, letName) {\n  return assertType(v, 'object', letName);\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertArray(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!Array.isArray(v)) {\n    throw letName + \" must be an array\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a function\n **/\n\nfunction assertFunction(v, letName) {\n  return assertType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertHasValue(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!hasValue(v)) {\n    throw letName + \" must not be null\";\n  }\n\n  return v;\n}\n/**\n *\n * @return {String}\n */\n\nfunction randomUUID() {\n  return 'xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * This function stamps/embeds a UUID into an object and returns the UUID generated for it\n * @return {String}\n */\n\nfunction stampUUID(obj) {\n  obj._osh_id = obj._osh_id || randomUUID();\n  return obj._osh_id;\n} //buffer is an ArrayBuffer object, the offset if specified in bytes, and the type is a string\n//corresponding to an OGC data type.\n//See http://def.seegrid.csiro.au/sissvoc/ogc-def/resource?uri=http://www.opengis.net/def/dataType/OGC/0/\n\n/**\n *\n * @param buffer\n * @param offset\n * @param type\n * @return {*}\n */\n\nfunction ParseBytes(buffer, offset, type) {\n  let view = new DataView(buffer); //Note: There exist types not listed in the map below that have OGC definitions, but no appropriate\n  //methods or corresponding types available for parsing in javascript. They are float128, float16, signedLong,\n  //and unsignedLong\n\n  let typeMap = {\n    double: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float64: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float32: function (offset) {\n      return {\n        val: view.getFloat32(offset),\n        bytes: 4\n      };\n    },\n    signedByte: function (offset) {\n      return {\n        val: view.getInt8(offset),\n        bytes: 1\n      };\n    },\n    signedInt: function (offset) {\n      return {\n        val: view.getInt32(offset),\n        bytes: 4\n      };\n    },\n    signedShort: function (offset) {\n      return {\n        val: view.getInt16(offset),\n        bytes: 2\n      };\n    },\n    unsignedByte: function (offset) {\n      return {\n        val: view.getUint8(offset),\n        bytes: 1\n      };\n    },\n    unsignedInt: function (offset) {\n      return {\n        val: view.getUint32(offset),\n        bytes: 4\n      };\n    },\n    unsignedShort: function (offset) {\n      return {\n        val: view.getUint16(offset),\n        bytes: 2\n      };\n    } //TODO: string-utf-8:\n\n  };\n  return typeMap[type](offset);\n} //This function recursivley iterates over the resultStructure to fill in\n//values read from data which should be an ArrayBuffer containing the payload from a websocket\n\n/**\n *\n * @param struct\n * @param data\n * @param offsetBytes\n * @return {*}\n */\n\nfunction ReadData(struct, data, offsetBytes) {\n  let offset = offsetBytes;\n\n  for (let i = 0; i < struct.fields.length; i++) {\n    let currFieldStruct = struct.fields[i];\n\n    if (isDefined(currFieldStruct.type) && currFieldStruct.type !== null) {\n      let ret = ParseBytes(data, offset, currFieldStruct.type);\n      currFieldStruct.val = ret.val;\n      offset += ret.bytes;\n    } else if (isDefined(currFieldStruct.count) && currFieldStruct.count !== null) {\n      //check if count is a reference to another letiable\n      if (isNaN(currFieldStruct.count)) {\n        let id = currFieldStruct.count;\n        let fieldName = struct.id2FieldMap[id];\n        currFieldStruct.count = struct.findFieldByName(fieldName).val;\n      }\n\n      for (let c = 0; c < currFieldStruct.count; c++) {\n        for (let j = 0; j < currFieldStruct.fields.length; j++) {\n          let field = JSON.parse(JSON.stringify(currFieldStruct.fields[j]));\n          offset = ReadData(field, data, offset);\n          currFieldStruct.val.push(field);\n        }\n      }\n    }\n  }\n\n  return offset;\n}\n/**\n *\n * @param resultStructure\n * @return {{}}\n */\n\nfunction GetResultObject(resultStructure) {\n  //TODO: handle cases for nested arrays / matrix data types\n  let result = {};\n\n  for (let i = 0; i < resultStructure.fields.length; i++) {\n    if (isDefined(resultStructure.fields[i].count)) {\n      result[resultStructure.fields[i].name] = [];\n\n      for (let c = 0; c < resultStructure.fields[i].count; c++) {\n        let item = {};\n\n        for (let k = 0; k < resultStructure.fields[i].val[c].fields.length; k++) {\n          item[resultStructure.fields[i].val[c].fields[k].name] = resultStructure.fields[i].val[c].fields[k].val;\n        }\n\n        result[resultStructure.fields[i].name].push(item);\n      }\n    } else {\n      result[resultStructure.fields[i].name] = resultStructure.fields[i].val;\n    }\n  }\n\n  return result;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isOpera() {\n  return !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isFirefox() {\n  return typeof InstallTrigger !== 'undefined';\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isSafari() {\n  return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isChrome() {\n  return !!window.chrome && !!window.chrome.webstore;\n}\n/**\n *\n * @return {*|boolean}\n */\n\nfunction isBlink() {\n  return (isChrome || isOpera) && !!window.CSS;\n}\n/**\n *\n * @param a\n * @param b\n * @return {boolean}\n */\n\nfunction isArrayIntersect(a, b) {\n  return a.filter(function (element) {\n    return b.indexOf(element) > -1;\n  }).length > 0;\n}\n/**\n *\n * @param o\n * @return {boolean}\n */\n\nfunction isElement(o) {\n  return typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n  o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n}\n/**\n *\n * @return {*}\n */\n\nfunction isWebWorker() {\n  return isDefined(Worker);\n}\n/**\n *\n * @param div\n */\n\nfunction takeScreenShot(div) {}\n/**\n * Remove a css class from a the div given as argument.\n * @param div the div to remove the class from\n * @param css the css class to remove\n */\n\nfunction removeCss(div, css) {\n  let divCss = div.className;\n  css = divCss.replace(css, \"\");\n  div.className = css;\n}\n/**\n * Add a css class to a the div given as argument.\n * @param div the div to add the class to\n * @param css the css class to add\n */\n\nfunction addCss(div, css) {\n  div.setAttribute(\"class\", div.className + \" \" + css);\n}\n/**\n * Removes the last character of a {string} object.\n * @param {string} value - The input {string}\n * @return {string} The value without the last character\n */\n\nfunction removeLastCharIfExist(value) {\n  if (!isDefined(undefined) || value === null || value.length === 0 || !value.endsWith(\"/\")) {\n    return value;\n  }\n\n  return value.substring(0, value.length - 1);\n}\n/**\n * Round off number to nearest 0.5\n * @param {Number} num - The number to round off\n * @return {number} The rounded number\n */\n\nfunction roundHalf(num) {\n  return Math.round(num * 2) / 2;\n}\n/**\n * Returns a function that, as long as it continues to be invoked,\n * will not be executed. The function will only be executed when\n * it will stop being called for more than N milliseconds.\n * If the `immediate` parameter is true, then the function\n * will be executed at the first call instead of the last.\n * Parameters :\n * - func: the function to `debouncer`.\n * - wait: the number of milliseconds (N) to wait before\n * call func()\n * - immediate (optional): Call func() at the first invocation\n * instead of the last one (Default false)\n * - context (optional): the context in which to call func()\n * (this by default)\n */\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n\nfunction debounce(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n\n  var later = function () {\n    var now = new Date().getTime(),\n        last = now - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = new Date().getTime();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n}\n;\nfunction throttle(func, wait, leading, trailing, context) {\n  var ctx, args, result;\n  var timeout = null;\n  var previous = 0;\n\n  var later = function () {\n    previous = new Date();\n    timeout = null;\n    result = func.apply(ctx, args);\n  };\n\n  return function () {\n    var now = new Date();\n    if (!previous && !leading) previous = now;\n    var remaining = wait - (now - previous);\n    ctx = context || this;\n    args = arguments;\n\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(ctx, args);\n    } else if (!timeout && trailing) {\n      // Sinon on s’endort pendant le temps restant\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n;\nfunction merge(target, source) {\n  // Iterate through `source` properties and if an `Object` set property to merge of `target` and `source` properties\n  for (const key of Object.keys(source)) {\n    if (source[key] instanceof Object && key in target) Object.assign(source[key], merge(target[key], source[key]));\n  } // Join `target` and modified `source`\n\n\n  Object.assign(target || {}, source);\n  return target;\n}\n;\nfunction rgbaToArray(str) {\n  let startIdxValue = str.indexOf('(') + 1;\n  let endIdxValue = str.indexOf(')');\n  let values = str.substr(startIdxValue, endIdxValue - startIdxValue);\n  return values.split(',').map(Number);\n}\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/protocol/Status.js\n/**\n * Enum for connection status.\n * @readonly\n * @enum {{name: string}}\n */\nconst Status = {\n  CONNECTING: \"connecting\",\n  CONNECTED: \"connected\",\n  DISCONNECTED: \"disconnected\",\n  CLOSED_ERROR: \"closed-error\"\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/DataSynchronizerAlgo.js\n\n\n\nclass DataSynchronizerAlgo_DataSynchronizerAlgo {\n  constructor(dataSources, replaySpeed = 1, timerResolution = 5) {\n    this.dataSourceMap = {};\n    this.bufferingTime = 1000;\n    this.startBufferingTime = -1;\n    this.tsRun = 0;\n    this.replaySpeed = replaySpeed;\n    this.timerResolution = timerResolution;\n    let maxBufferingTime = -1;\n\n    for (let ds of dataSources) {\n      this.addDataSource(ds);\n      maxBufferingTime = ds.bufferingTime > maxBufferingTime ? ds.bufferingTime : maxBufferingTime;\n    }\n\n    if (maxBufferingTime !== -1) {\n      this.bufferingTime = maxBufferingTime;\n    }\n  }\n\n  push(dataSourceId, data) {\n    const ds = this.dataSourceMap[dataSourceId];\n\n    if (ds.status === Status.DISCONNECTED) {\n      return;\n    }\n\n    if (this.startBufferingTime === -1) {\n      console.log(`synchronizer buffering data for ${this.bufferingTime}ms..`);\n      this.startBufferingTime = performance.now(); // start iterating on data after bufferingTime\n\n      this.timeoutBuffering = setTimeout(() => this.processData(), this.bufferingTime);\n    }\n\n    let latency = 0;\n\n    if (this.tsRun > 0) {\n      latency = this.tsRun - data.timeStamp;\n    }\n\n    ds.latency = latency > ds.latency ? latency : (ds.latency + latency) / 2;\n    ds.dataBuffer.push(data);\n  }\n\n  reset() {\n    console.log('reset synchronizer algo');\n    this.close();\n\n    for (let currentDsId in this.dataSourceMap) {\n      const currentDs = this.dataSourceMap[currentDsId];\n      currentDs.dataBuffer = [];\n      currentDs.startBufferingTime = -1;\n      currentDs.latency = 0;\n      currentDs.status = Status.DISCONNECTED;\n    }\n\n    this.tsRun = 0;\n    this.startBufferingTime = -1;\n  }\n\n  processData() {\n    // the timeout has been cancelled\n    if (!isDefined(this.timeoutBuffering)) {\n      return;\n    }\n\n    let tsRef = -1;\n    let clockTimeRef = performance.now(); // get reference start timestamp\n    // the reference start timestamp should the oldest one\n\n    let currentDs;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.status === Status.DISCONNECTED) {\n        continue;\n      }\n\n      if (currentDs.dataBuffer.length > 0) {\n        tsRef = tsRef === -1 || currentDs.dataBuffer[0].timeStamp < tsRef ? currentDs.dataBuffer[0].timeStamp : tsRef;\n      }\n    }\n\n    this.interval = setInterval(() => {\n      // 1) return the oldest data if any\n      while (this.computeNextData(tsRef, clockTimeRef));\n    }, this.timerResolution);\n  }\n  /**\n   * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,\n   * we return only the oldest one.\n   * @param tsRef - the timestamp of the first data\n   * @param refClockTime - the absolute diff time really spent\n   */\n\n\n  computeNextData(tsRef, refClockTime) {\n    let currentDs;\n    let currentDsToShift = null; // compute max latency\n\n    let maxLatency = 0;\n    let minLatency = 0;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.status === Status.DISCONNECTED) {\n        continue;\n      }\n\n      if (currentDs.latency > 0) {\n        let latency = Math.min(currentDs.latency, currentDs.timeOut);\n        maxLatency = latency > maxLatency ? latency : maxLatency;\n        minLatency = currentDs.latency < minLatency ? currentDs.latency : minLatency;\n      }\n    }\n\n    maxLatency *= this.replaySpeed;\n    minLatency *= this.replaySpeed;\n    const dClock = (performance.now() - refClockTime) * this.replaySpeed;\n    this.tsRun = tsRef + dClock; // compute next data to return\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.status === Status.DISCONNECTED) {\n        continue;\n      }\n\n      if (currentDs.dataBuffer.length > 0) {\n        const dTs = currentDs.dataBuffer[0].timeStamp - tsRef;\n        const dClockAdj = dClock - maxLatency; // we use an intermediate object to store the data to shift because we want to return the oldest one\n        // only\n\n        if (dTs <= dClockAdj) {\n          // no other one to compare\n          if (currentDsToShift === null) {\n            currentDsToShift = currentDs;\n          } else {\n            // take the oldest data\n            currentDsToShift = currentDsToShift.dataBuffer[0].timeStamp < currentDs.dataBuffer[0].timeStamp ? currentDsToShift : currentDs;\n          }\n        }\n      }\n    } // finally pop the data from DS queue\n\n\n    if (currentDsToShift !== null) {\n      let rec = currentDsToShift.dataBuffer.shift(); // add latency flag to data record before we dispatch it\n      // this is relative latency in millis compared to the DS with the lowest latency\n      // so it is accurate even if local device time is not set properly\n\n      rec['@latency'] = currentDs.latency - minLatency;\n      this.onData(currentDsToShift.id, rec);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Add dataSource to be synchronized\n   * @param {DataSource} dataSource - the dataSource to synchronize\n   */\n\n\n  addDataSource(dataSource) {\n    this.dataSourceMap[dataSource.id] = {\n      bufferingTime: dataSource.bufferingTime,\n      timeOut: dataSource.timeOut || 0,\n      dataBuffer: [],\n      startBufferingTime: -1,\n      id: dataSource.id,\n      timedOut: false,\n      name: dataSource.name || dataSource.id,\n      latency: 0,\n      status: Status.DISCONNECTED //MEANING Enabled, 0 = Disabled\n\n    };\n  }\n\n  onData(dataSourceId, data) {}\n  /**\n   * Change the dataSource status\n   * @param {Status} status - the new status\n   * @param {String} dataSourceId - the corresponding dataSource id\n   */\n\n\n  setStatus(dataSourceId, status) {\n    if (dataSourceId in this.dataSourceMap) {\n      this.dataSourceMap[dataSourceId].status = status;\n\n      if (status === Status.DISCONNECTED) {\n        // reset latency and buffer\n        this.dataSourceMap[dataSourceId].latency = 0;\n        this.dataSourceMap[dataSourceId].dataBuffer = [];\n      }\n\n      console.warn(status + ' DataSource ' + dataSourceId + ' from the synchronizer ');\n    }\n  }\n\n  close() {\n    if (isDefined(this.interval)) {\n      clearInterval(this.interval);\n      this.interval = null;\n    }\n\n    if (isDefined(this.timeoutBuffering)) {\n      clearTimeout(this.timeoutBuffering);\n      this.timeoutBuffering = null;\n    }\n\n    console.log(\"Data synchronizer terminated successfully\");\n  }\n\n}\n\n/* harmony default export */ var timesync_DataSynchronizerAlgo = (DataSynchronizerAlgo_DataSynchronizerAlgo);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/Constants.js\nconst DATA_SYNCHRONIZER_TOPIC = 'data-synchronizer-';\nconst TIME_SYNCHRONIZER_TOPIC = 'data-synchronizer-time-';\nconst DATASOURCE_DATA_TOPIC = 'datasource-data-';\nconst DATASOURCE_TIME_TOPIC = 'datasource-time-';\nconst FFMPEG_VIEW_DECODE_TOPIC = 'ffmpeg-decode-';\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/event/EventType.js\nconst EventType = {\n  DATA: 'data',\n  STATUS: 'status',\n  TIME_CHANGED: 'time-changed'\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/DataSynchronizer.worker.js\n\n\n\n\nconst bcChannels = {};\nlet dataSynchronizerAlgo;\n\nlet init = false;\nlet dataSourceBroadCastChannel = null;\nself.currentTime = -1;\n\nconst dataSources = {};\nlet timeBroadcastChannel = null;\nlet topicTime;\nlet topicData;\n\nself.onmessage = (event) => {\n    if(event.data.message === 'init') {\n        dataSynchronizerAlgo = new timesync_DataSynchronizerAlgo(\n            event.data.dataSources,\n            event.data.replaySpeed,\n            event.data.timerResolution\n        );\n        dataSynchronizerAlgo.onData = onData;\n        init = true;\n        addDataSources(event.data.dataSources);\n        topicData = event.data.dataTopic;\n        topicTime = event.data.timeTopic;\n        initBroadcastChannel(topicData, topicTime);\n        self.postMessage({\n            message: 'initialized'\n        });\n    } else if(event.data.message === 'add' && event.data.dataSources) {\n        addDataSources(event.data.dataSources);\n    } else if(event.data.message === 'current-time') {\n        self.postMessage({\n            message: 'current-time',\n            data: self.currentTime\n        });\n    }  else if(event.data.message === 'reset') {\n        if(dataSynchronizerAlgo !== null) {\n            dataSynchronizerAlgo.reset();\n        }\n        timeBroadcastChannel.postMessage({\n            type: EventType.TIME_CHANGED\n        });\n    }  else if(event.data.message === 'replay-speed') {\n        if(dataSynchronizerAlgo !== null) {\n            dataSynchronizerAlgo.replaySpeed = event.data.replaySpeed;\n        }\n    } else if(event.data.message === 'data') {\n        if(dataSynchronizerAlgo !== null) {\n            dataSynchronizerAlgo.push(event.data.dataSourceId, {\n                data: event.data.data,\n                timeStamp: event.data.timeStamp\n            });\n        }\n    }\n}\n\nfunction initBroadcastChannel(dataTopic, timeTopic) {\n    dataSourceBroadCastChannel = new BroadcastChannel(dataTopic);\n    dataSourceBroadCastChannel.onmessage = (event) => {\n        if(event.data.type === EventType.DATA) {\n            for(let i=0; i < event.data.values.length;i++) {\n                dataSynchronizerAlgo.push(\n                    event.data.dataSourceId,\n                    {\n                        ...event.data.values[i]\n                    }\n                );\n            }\n        } else if(event.data.type === EventType.STATUS) {\n            const dataSourceId = event.data.dataSourceId;\n            dataSynchronizerAlgo.setStatus(dataSourceId, event.data.status);\n            console.log(dataSources[dataSourceId].name + \": status=\" + event.data.status);\n            // bubble the message\n            bcChannels[dataSourceId].postMessage(event.data);\n        }\n    }\n\n    timeBroadcastChannel = new BroadcastChannel(timeTopic);\n\n}\n\n/**\n *\n * @param dataSources\n */\nfunction addDataSources(dataSources) {\n    for(let dataSource of dataSources) {\n        addDataSource(dataSource);\n    }\n}\n\nfunction addDataSource(dataSource) {\n    dataSynchronizerAlgo.addDataSource(dataSource);\n    // create a BC to push back the synchronized data into the DATA Stream.\n    bcChannels[dataSource.id] = new BroadcastChannel(DATASOURCE_DATA_TOPIC + dataSource.id);\n\n    if(!(dataSource.id in dataSources)) {\n        dataSources[dataSource.id] = dataSource;\n    }\n}\n\nfunction onData(dataSourceId, data) {\n    self.currentTime = data.timeStamp;\n    bcChannels[dataSourceId].postMessage({\n            values: [data],\n            dataSourceId:dataSourceId,\n            type: EventType.DATA\n        }\n    );\n\n    timeBroadcastChannel.postMessage({\n        timestamp: data.timeStamp,\n        dataSourceId: dataSourceId,\n        type: EventType.DATA\n    });\n}\n\n\nself.onclose = function() {\n    dataSynchronizerAlgo.close();\n    console.log(\"Data Synchronizer has been terminated successfully\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS91dGlscy9VdGlscy5qcz9mODdlIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL3Byb3RvY29sL1N0YXR1cy5qcz84ODhhIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL3RpbWVzeW5jL0RhdGFTeW5jaHJvbml6ZXJBbGdvLmpzP2FkY2EiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvQ29uc3RhbnRzLmpzP2I5YjEiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvZXZlbnQvRXZlbnRUeXBlLmpzPzllMzAiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvdGltZXN5bmMvRGF0YVN5bmNocm9uaXplci53b3JrZXIuanM/NWYzMCJdLCJuYW1lcyI6WyJNQVhfTE9ORyIsIk1hdGgiLCJwb3ciLCJpc0RlZmluZWQiLCJ2IiwiaGFzVmFsdWUiLCJoZXgycmdiIiwiaGV4IiwiciIsImciLCJiIiwibWF0Y2giLCJtYXAiLCJ4IiwicGFyc2VJbnQiLCJoYXNUeXBlIiwiZXhwZWN0ZWRUeXBlIiwiaGFzVmFsIiwiaXNPYmplY3QiLCJsZXROYW1lIiwiaXNBcnJheSIsIkFycmF5IiwiaXNGdW5jdGlvbiIsImFzc2VydERlZmluZWQiLCJhc3NlcnRUcnVlIiwiYXNzZXJ0VHlwZSIsImFzc2VydEJvb2xlYW4iLCJhc3NlcnRTdHJpbmciLCJhc3NlcnROdW1iZXIiLCJhc3NlcnRQb3NpdGl2ZSIsImFzc2VydE9iamVjdCIsImFzc2VydEFycmF5IiwiYXNzZXJ0RnVuY3Rpb24iLCJhc3NlcnRIYXNWYWx1ZSIsInJhbmRvbVVVSUQiLCJyZXBsYWNlIiwiYyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3RhbXBVVUlEIiwib2JqIiwiX29zaF9pZCIsIlBhcnNlQnl0ZXMiLCJidWZmZXIiLCJvZmZzZXQiLCJ0eXBlIiwidmlldyIsIkRhdGFWaWV3IiwidHlwZU1hcCIsImRvdWJsZSIsInZhbCIsImdldEZsb2F0NjQiLCJieXRlcyIsImZsb2F0NjQiLCJmbG9hdDMyIiwiZ2V0RmxvYXQzMiIsInNpZ25lZEJ5dGUiLCJnZXRJbnQ4Iiwic2lnbmVkSW50IiwiZ2V0SW50MzIiLCJzaWduZWRTaG9ydCIsImdldEludDE2IiwidW5zaWduZWRCeXRlIiwiZ2V0VWludDgiLCJ1bnNpZ25lZEludCIsImdldFVpbnQzMiIsInVuc2lnbmVkU2hvcnQiLCJnZXRVaW50MTYiLCJSZWFkRGF0YSIsInN0cnVjdCIsImRhdGEiLCJvZmZzZXRCeXRlcyIsImkiLCJmaWVsZHMiLCJsZW5ndGgiLCJjdXJyRmllbGRTdHJ1Y3QiLCJyZXQiLCJjb3VudCIsImlzTmFOIiwiaWQiLCJmaWVsZE5hbWUiLCJpZDJGaWVsZE1hcCIsImZpbmRGaWVsZEJ5TmFtZSIsImoiLCJmaWVsZCIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInB1c2giLCJHZXRSZXN1bHRPYmplY3QiLCJyZXN1bHRTdHJ1Y3R1cmUiLCJyZXN1bHQiLCJuYW1lIiwiaXRlbSIsImsiLCJpc09wZXJhIiwid2luZG93Iiwib3ByIiwiYWRkb25zIiwib3BlcmEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmRleE9mIiwiaXNGaXJlZm94IiwiSW5zdGFsbFRyaWdnZXIiLCJpc1NhZmFyaSIsIk9iamVjdCIsInByb3RvdHlwZSIsImNhbGwiLCJIVE1MRWxlbWVudCIsImlzQ2hyb21lIiwiY2hyb21lIiwid2Vic3RvcmUiLCJpc0JsaW5rIiwiQ1NTIiwiaXNBcnJheUludGVyc2VjdCIsImEiLCJmaWx0ZXIiLCJlbGVtZW50IiwiaXNFbGVtZW50IiwibyIsIm5vZGVUeXBlIiwibm9kZU5hbWUiLCJpc1dlYldvcmtlciIsIldvcmtlciIsInRha2VTY3JlZW5TaG90IiwiZGl2IiwicmVtb3ZlQ3NzIiwiY3NzIiwiZGl2Q3NzIiwiY2xhc3NOYW1lIiwiYWRkQ3NzIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlTGFzdENoYXJJZkV4aXN0IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJlbmRzV2l0aCIsInN1YnN0cmluZyIsInJvdW5kSGFsZiIsIm51bSIsInJvdW5kIiwiZGVib3VuY2UiLCJmdW5jIiwid2FpdCIsImltbWVkaWF0ZSIsInRpbWVvdXQiLCJhcmdzIiwiY29udGV4dCIsInRpbWVzdGFtcCIsImxhdGVyIiwibm93IiwiRGF0ZSIsImdldFRpbWUiLCJsYXN0Iiwic2V0VGltZW91dCIsImFwcGx5IiwiYXJndW1lbnRzIiwiY2FsbE5vdyIsInRocm90dGxlIiwibGVhZGluZyIsInRyYWlsaW5nIiwiY3R4IiwicHJldmlvdXMiLCJyZW1haW5pbmciLCJjbGVhclRpbWVvdXQiLCJtZXJnZSIsInRhcmdldCIsInNvdXJjZSIsImtleSIsImtleXMiLCJhc3NpZ24iLCJyZ2JhVG9BcnJheSIsInN0ciIsInN0YXJ0SWR4VmFsdWUiLCJlbmRJZHhWYWx1ZSIsInZhbHVlcyIsInN1YnN0ciIsInNwbGl0IiwiTnVtYmVyIiwiU3RhdHVzIiwiQ09OTkVDVElORyIsIkNPTk5FQ1RFRCIsIkRJU0NPTk5FQ1RFRCIsIkNMT1NFRF9FUlJPUiIsIkRhdGFTeW5jaHJvbml6ZXJBbGdvIiwiY29uc3RydWN0b3IiLCJkYXRhU291cmNlcyIsInJlcGxheVNwZWVkIiwidGltZXJSZXNvbHV0aW9uIiwiZGF0YVNvdXJjZU1hcCIsImJ1ZmZlcmluZ1RpbWUiLCJzdGFydEJ1ZmZlcmluZ1RpbWUiLCJ0c1J1biIsIm1heEJ1ZmZlcmluZ1RpbWUiLCJkcyIsImFkZERhdGFTb3VyY2UiLCJkYXRhU291cmNlSWQiLCJzdGF0dXMiLCJjb25zb2xlIiwibG9nIiwicGVyZm9ybWFuY2UiLCJ0aW1lb3V0QnVmZmVyaW5nIiwicHJvY2Vzc0RhdGEiLCJsYXRlbmN5IiwidGltZVN0YW1wIiwiZGF0YUJ1ZmZlciIsInJlc2V0IiwiY2xvc2UiLCJjdXJyZW50RHNJZCIsImN1cnJlbnREcyIsInRzUmVmIiwiY2xvY2tUaW1lUmVmIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNvbXB1dGVOZXh0RGF0YSIsInJlZkNsb2NrVGltZSIsImN1cnJlbnREc1RvU2hpZnQiLCJtYXhMYXRlbmN5IiwibWluTGF0ZW5jeSIsIm1pbiIsInRpbWVPdXQiLCJkQ2xvY2siLCJkVHMiLCJkQ2xvY2tBZGoiLCJyZWMiLCJzaGlmdCIsIm9uRGF0YSIsImRhdGFTb3VyY2UiLCJ0aW1lZE91dCIsInNldFN0YXR1cyIsIndhcm4iLCJjbGVhckludGVydmFsIiwiREFUQV9TWU5DSFJPTklaRVJfVE9QSUMiLCJUSU1FX1NZTkNIUk9OSVpFUl9UT1BJQyIsIkRBVEFTT1VSQ0VfREFUQV9UT1BJQyIsIkRBVEFTT1VSQ0VfVElNRV9UT1BJQyIsIkZGTVBFR19WSUVXX0RFQ09ERV9UT1BJQyIsIkV2ZW50VHlwZSIsIkRBVEEiLCJTVEFUVVMiLCJUSU1FX0NIQU5HRUQiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDTyxNQUFNQSxRQUFRLEdBQUdDLElBQUksQ0FBQ0MsR0FBTCxDQUFTLENBQVQsRUFBWSxFQUFaLElBQWtCLENBQW5DO0FBRVA7QUFDQTtBQUNBOztBQUNPLFNBQVNDLFNBQVQsQ0FBbUJDLENBQW5CLEVBQXNCO0FBQ3pCLFNBQU8sT0FBUUEsQ0FBUixLQUFlLFdBQWYsSUFBOEJBLENBQUMsS0FBSyxJQUEzQztB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O0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEMsd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkJBQTZCLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxxQkFBcUI7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuIFRoZSBjb250ZW50cyBvZiB0aGlzIGZpbGUgYXJlIHN1YmplY3QgdG8gdGhlIE1vemlsbGEgUHVibGljIExpY2Vuc2UsIHYuIDIuMC5cbiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmVcbiBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG5cbiBTb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgYmFzaXMsXG4gV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlXG4gZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcmlnaHRzIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuIENvcHlyaWdodCAoQykgMjAxNS0yMDIwIE1hdGhpZXUgRGhhaW5hdXQuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbiBBdXRob3I6IE1hdGhpZXUgRGhhaW5hdXQgPG1hdGhpZXUuZGhhaW5hdXRAZ21haWwuY29tPlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKiAqIEBtb2R1bGUgVXRpbHMgKi9cblxuLyoqIE1heGltdW0gdmFsdWUgb2YgYSBsb25nICovXG5leHBvcnQgY29uc3QgTUFYX0xPTkcgPSBNYXRoLnBvdygyLCA1MykgKyAxO1xuXG4vKipcbiAqIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmaW5lZCh2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiAodikgIT09ICd1bmRlZmluZWQnICYmIHYgIT09IG51bGw7XG59XG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGhhcyBhIHZhbHVlLFxuIHRoYXQgaXMgaXQgaXMgZGVmaW5lZCBhbmQgbm9uIG51bGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc1ZhbHVlKHYpIHtcbiAgICByZXR1cm4gaXNEZWZpbmVkKHYpICYmIHYgIT09IG51bGw7XG59XG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRyYW5zZm9ybSBoZXggY29sb3IgaW50byBSR0JBXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXgycmdiKGhleCl7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gaGV4Lm1hdGNoKC9cXHdcXHcvZykubWFwKHggPT4gcGFyc2VJbnQoeCwgMTYpKTtcbiAgICByZXR1cm4gW3IsIGcsIGJdO1xufVxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgb2YgYSBwYXJ0aWN1bGFyIHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc1R5cGUodiwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgbGV0IGhhc1ZhbCA9IGhhc1ZhbHVlKHYpO1xuICAgIHJldHVybiBoYXNWYWwgJiYgdHlwZW9mICh2KSA9PT0gZXhwZWN0ZWRUeXBlO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gaGFzVHlwZSh2LCAnb2JqZWN0JywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KHYpIHtcbiAgICByZXR1cm4gaXNEZWZpbmVkKHYpICYmIEFycmF5LmlzQXJyYXkodik7XG59XG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBoYXNUeXBlKHYsICdmdW5jdGlvbicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh2KSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBiZSBkZWZpbmVkXCI7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VHJ1ZSh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGlmICghaXNEZWZpbmVkKHYpIHx8ICF2KSB7XG4gICAgICAgIHRocm93IGxldE5hbWU7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGRlZmluZWQgYW5kIG5vbi1udWxsXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VHlwZSh2LCBleHBlY3RlZFR5cGUsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lKTtcbiAgICBpZiAodHlwZW9mICh2KSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIG9mIHR5cGUgXCIgKyBleHBlY3RlZFR5cGU7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBzdHJpbmdcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRCb29sZWFuKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnYm9vbGVhbicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBzdHJpbmdcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRTdHJpbmcodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdzdHJpbmcnLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgbnVtYmVyXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnbnVtYmVyJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIG51bWJlclxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFBvc2l0aXZlKHYsIGxldE5hbWUpIHtcbiAgICBhc3NlcnROdW1iZXIodiwgbGV0TmFtZSk7XG4gICAgaWYgKHYgPD0gMCkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiO1xuICAgIH1cbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIG9iamVjdFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE9iamVjdCh2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ29iamVjdCcsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gb2JqZWN0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0QXJyYXkodiwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBiZSBhbiBhcnJheVwiO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgZnVuY3Rpb25cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRGdW5jdGlvbih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ2Z1bmN0aW9uJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkIGFuZCBub24tbnVsbFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEhhc1ZhbHVlKHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lKTtcbiAgICBpZiAoIWhhc1ZhbHVlKHYpKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IG5vdCBiZSBudWxsXCI7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21VVUlEKCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC14eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGxldCByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHN0YW1wcy9lbWJlZHMgYSBVVUlEIGludG8gYW4gb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBVVUlEIGdlbmVyYXRlZCBmb3IgaXRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YW1wVVVJRChvYmopIHtcbiAgICBvYmouX29zaF9pZCA9IG9iai5fb3NoX2lkIHx8IHJhbmRvbVVVSUQoKTtcbiAgICByZXR1cm4gb2JqLl9vc2hfaWQ7XG59XG5cbi8vYnVmZmVyIGlzIGFuIEFycmF5QnVmZmVyIG9iamVjdCwgdGhlIG9mZnNldCBpZiBzcGVjaWZpZWQgaW4gYnl0ZXMsIGFuZCB0aGUgdHlwZSBpcyBhIHN0cmluZ1xuLy9jb3JyZXNwb25kaW5nIHRvIGFuIE9HQyBkYXRhIHR5cGUuXG4vL1NlZSBodHRwOi8vZGVmLnNlZWdyaWQuY3Npcm8uYXUvc2lzc3ZvYy9vZ2MtZGVmL3Jlc291cmNlP3VyaT1odHRwOi8vd3d3Lm9wZW5naXMubmV0L2RlZi9kYXRhVHlwZS9PR0MvMC9cbi8qKlxuICpcbiAqIEBwYXJhbSBidWZmZXJcbiAqIEBwYXJhbSBvZmZzZXRcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJuIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gUGFyc2VCeXRlcyhidWZmZXIsIG9mZnNldCwgdHlwZSkge1xuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG5cbiAgICAvL05vdGU6IFRoZXJlIGV4aXN0IHR5cGVzIG5vdCBsaXN0ZWQgaW4gdGhlIG1hcCBiZWxvdyB0aGF0IGhhdmUgT0dDIGRlZmluaXRpb25zLCBidXQgbm8gYXBwcm9wcmlhdGVcbiAgICAvL21ldGhvZHMgb3IgY29ycmVzcG9uZGluZyB0eXBlcyBhdmFpbGFibGUgZm9yIHBhcnNpbmcgaW4gamF2YXNjcmlwdC4gVGhleSBhcmUgZmxvYXQxMjgsIGZsb2F0MTYsIHNpZ25lZExvbmcsXG4gICAgLy9hbmQgdW5zaWduZWRMb25nXG4gICAgbGV0IHR5cGVNYXAgPSB7XG4gICAgICAgIGRvdWJsZTogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQpLCBieXRlczogOH07XG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0NjQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEZsb2F0NjQob2Zmc2V0KSwgYnl0ZXM6IDh9O1xuICAgICAgICB9LFxuICAgICAgICBmbG9hdDMyOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRGbG9hdDMyKG9mZnNldCksIGJ5dGVzOiA0fTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmVkQnl0ZTogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0SW50OChvZmZzZXQpLCBieXRlczogMX07XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25lZEludDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0SW50MzIob2Zmc2V0KSwgYnl0ZXM6IDR9O1xuICAgICAgICB9LFxuICAgICAgICBzaWduZWRTaG9ydDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0SW50MTYob2Zmc2V0KSwgYnl0ZXM6IDJ9O1xuICAgICAgICB9LFxuICAgICAgICB1bnNpZ25lZEJ5dGU6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldFVpbnQ4KG9mZnNldCksIGJ5dGVzOiAxfTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaWduZWRJbnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldFVpbnQzMihvZmZzZXQpLCBieXRlczogNH07XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2lnbmVkU2hvcnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldFVpbnQxNihvZmZzZXQpLCBieXRlczogMn07XG4gICAgICAgIH0sXG4gICAgICAgIC8vVE9ETzogc3RyaW5nLXV0Zi04OlxuICAgIH07XG4gICAgcmV0dXJuIHR5cGVNYXBbdHlwZV0ob2Zmc2V0KTtcbn1cblxuLy9UaGlzIGZ1bmN0aW9uIHJlY3Vyc2l2bGV5IGl0ZXJhdGVzIG92ZXIgdGhlIHJlc3VsdFN0cnVjdHVyZSB0byBmaWxsIGluXG4vL3ZhbHVlcyByZWFkIGZyb20gZGF0YSB3aGljaCBzaG91bGQgYmUgYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyB0aGUgcGF5bG9hZCBmcm9tIGEgd2Vic29ja2V0XG4vKipcbiAqXG4gKiBAcGFyYW0gc3RydWN0XG4gKiBAcGFyYW0gZGF0YVxuICogQHBhcmFtIG9mZnNldEJ5dGVzXG4gKiBAcmV0dXJuIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gUmVhZERhdGEoc3RydWN0LCBkYXRhLCBvZmZzZXRCeXRlcykge1xuICAgIGxldCBvZmZzZXQgPSBvZmZzZXRCeXRlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cnVjdC5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGN1cnJGaWVsZFN0cnVjdCA9IHN0cnVjdC5maWVsZHNbaV07XG4gICAgICAgIGlmIChpc0RlZmluZWQoY3VyckZpZWxkU3RydWN0LnR5cGUpICYmIGN1cnJGaWVsZFN0cnVjdC50eXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmV0ID0gUGFyc2VCeXRlcyhkYXRhLCBvZmZzZXQsIGN1cnJGaWVsZFN0cnVjdC50eXBlKTtcbiAgICAgICAgICAgIGN1cnJGaWVsZFN0cnVjdC52YWwgPSByZXQudmFsO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHJldC5ieXRlcztcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZmluZWQoY3VyckZpZWxkU3RydWN0LmNvdW50KSAmJiBjdXJyRmllbGRTdHJ1Y3QuY291bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vY2hlY2sgaWYgY291bnQgaXMgYSByZWZlcmVuY2UgdG8gYW5vdGhlciBsZXRpYWJsZVxuICAgICAgICAgICAgaWYgKGlzTmFOKGN1cnJGaWVsZFN0cnVjdC5jb3VudCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBjdXJyRmllbGRTdHJ1Y3QuY291bnQ7XG4gICAgICAgICAgICAgICAgbGV0IGZpZWxkTmFtZSA9IHN0cnVjdC5pZDJGaWVsZE1hcFtpZF07XG4gICAgICAgICAgICAgICAgY3VyckZpZWxkU3RydWN0LmNvdW50ID0gc3RydWN0LmZpbmRGaWVsZEJ5TmFtZShmaWVsZE5hbWUpLnZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VyckZpZWxkU3RydWN0LmNvdW50OyBjKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN1cnJGaWVsZFN0cnVjdC5maWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpZWxkID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjdXJyRmllbGRTdHJ1Y3QuZmllbGRzW2pdKSk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IFJlYWREYXRhKGZpZWxkLCBkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyRmllbGRTdHJ1Y3QudmFsLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gcmVzdWx0U3RydWN0dXJlXG4gKiBAcmV0dXJuIHt7fX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEdldFJlc3VsdE9iamVjdChyZXN1bHRTdHJ1Y3R1cmUpIHtcbiAgICAvL1RPRE86IGhhbmRsZSBjYXNlcyBmb3IgbmVzdGVkIGFycmF5cyAvIG1hdHJpeCBkYXRhIHR5cGVzXG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0U3RydWN0dXJlLmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0uY291bnQpKSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5uYW1lXSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLmNvdW50OyBjKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS52YWxbY10uZmllbGRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS52YWxbY10uZmllbGRzW2tdLm5hbWVdID0gcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS52YWxbY10uZmllbGRzW2tdLnZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0ubmFtZV0ucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLm5hbWVdID0gcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS52YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT3BlcmEoKSB7XG4gICAgcmV0dXJuICghIXdpbmRvdy5vcHIgJiYgISFvcHIuYWRkb25zKSB8fCAhIXdpbmRvdy5vcGVyYSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBPUFIvJykgPj0gMDtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRmlyZWZveCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93LkhUTUxFbGVtZW50KS5pbmRleE9mKCdDb25zdHJ1Y3RvcicpID4gMDtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2hyb21lKCkge1xuICAgIHJldHVybiAhIXdpbmRvdy5jaHJvbWUgJiYgISF3aW5kb3cuY2hyb21lLndlYnN0b3JlO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHsqfGJvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0JsaW5rKCkge1xuICAgIHJldHVybiAoaXNDaHJvbWUgfHwgaXNPcGVyYSkgJiYgISF3aW5kb3cuQ1NTO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gYVxuICogQHBhcmFtIGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5SW50ZXJzZWN0KGEsIGIpIHtcbiAgICByZXR1cm4gYS5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGIuaW5kZXhPZihlbGVtZW50KSA+IC0xO1xuICAgIH0pLmxlbmd0aCA+IDA7XG59XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIG9cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQobykge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwib2JqZWN0XCIgPyBvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgOiAvL0RPTTJcbiAgICAgICAgbyAmJiB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIiAmJiBvICE9PSBudWxsICYmIG8ubm9kZVR5cGUgPT09IDEgJiYgdHlwZW9mIG8ubm9kZU5hbWUgPT09IFwic3RyaW5nXCJcbiAgICApO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNXZWJXb3JrZXIoKSB7XG4gICAgcmV0dXJuIGlzRGVmaW5lZChXb3JrZXIpO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gZGl2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWtlU2NyZWVuU2hvdChkaXYpIHtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBjc3MgY2xhc3MgZnJvbSBhIHRoZSBkaXYgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0gZGl2IHRoZSBkaXYgdG8gcmVtb3ZlIHRoZSBjbGFzcyBmcm9tXG4gKiBAcGFyYW0gY3NzIHRoZSBjc3MgY2xhc3MgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDc3MoZGl2LCBjc3MpIHtcbiAgICBsZXQgZGl2Q3NzID0gZGl2LmNsYXNzTmFtZTtcbiAgICBjc3MgPSBkaXZDc3MucmVwbGFjZShjc3MsIFwiXCIpO1xuICAgIGRpdi5jbGFzc05hbWUgPSBjc3M7XG59XG5cblxuLyoqXG4gKiBBZGQgYSBjc3MgY2xhc3MgdG8gYSB0aGUgZGl2IGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIGRpdiB0aGUgZGl2IHRvIGFkZCB0aGUgY2xhc3MgdG9cbiAqIEBwYXJhbSBjc3MgdGhlIGNzcyBjbGFzcyB0byBhZGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENzcyhkaXYsIGNzcykge1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBkaXYuY2xhc3NOYW1lICsgXCIgXCIgKyBjc3MpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGxhc3QgY2hhcmFjdGVyIG9mIGEge3N0cmluZ30gb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIGlucHV0IHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB2YWx1ZSB3aXRob3V0IHRoZSBsYXN0IGNoYXJhY3RlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTGFzdENoYXJJZkV4aXN0KHZhbHVlKSB7XG4gICAgaWYgKCFpc0RlZmluZWQodW5kZWZpbmVkKSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZS5sZW5ndGggPT09IDAgfHwgIXZhbHVlLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZygwLCB2YWx1ZS5sZW5ndGggLSAxKTtcbn1cblxuLyoqXG4gKiBSb3VuZCBvZmYgbnVtYmVyIHRvIG5lYXJlc3QgMC41XG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIC0gVGhlIG51bWJlciB0byByb3VuZCBvZmZcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJvdW5kZWQgbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZEhhbGYobnVtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobnVtKjIpLzI7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsXG4gKiB3aWxsIG5vdCBiZSBleGVjdXRlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgb25seSBiZSBleGVjdXRlZCB3aGVuXG4gKiBpdCB3aWxsIHN0b3AgYmVpbmcgY2FsbGVkIGZvciBtb3JlIHRoYW4gTiBtaWxsaXNlY29uZHMuXG4gKiBJZiB0aGUgYGltbWVkaWF0ZWAgcGFyYW1ldGVyIGlzIHRydWUsIHRoZW4gdGhlIGZ1bmN0aW9uXG4gKiB3aWxsIGJlIGV4ZWN1dGVkIGF0IHRoZSBmaXJzdCBjYWxsIGluc3RlYWQgb2YgdGhlIGxhc3QuXG4gKiBQYXJhbWV0ZXJzIDpcbiAqIC0gZnVuYzogdGhlIGZ1bmN0aW9uIHRvIGBkZWJvdW5jZXJgLlxuICogLSB3YWl0OiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyAoTikgdG8gd2FpdCBiZWZvcmVcbiAqIGNhbGwgZnVuYygpXG4gKiAtIGltbWVkaWF0ZSAob3B0aW9uYWwpOiBDYWxsIGZ1bmMoKSBhdCB0aGUgZmlyc3QgaW52b2NhdGlvblxuICogaW5zdGVhZCBvZiB0aGUgbGFzdCBvbmUgKERlZmF1bHQgZmFsc2UpXG4gKiAtIGNvbnRleHQgKG9wdGlvbmFsKTogdGhlIGNvbnRleHQgaW4gd2hpY2ggdG8gY2FsbCBmdW5jKClcbiAqICh0aGlzIGJ5IGRlZmF1bHQpXG4gKi9cblxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4vLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgICAgICBsYXN0ID0gbm93IC0gdGltZXN0YW1wO1xuXG4gICAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBsZWFkaW5nLCB0cmFpbGluZywgY29udGV4dCkge1xuICAgIHZhciBjdHgsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJldmlvdXMgPSBuZXcgRGF0ZTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY3R4LCBhcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlO1xuICAgICAgICBpZiAoIXByZXZpb3VzICYmICFsZWFkaW5nKSBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgICBjdHggPSBjb250ZXh0IHx8IHRoaXM7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY3R4LCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiB0cmFpbGluZykge1xuICAgICAgICAgICAgLy8gU2lub24gb24gc+KAmWVuZG9ydCBwZW5kYW50IGxlIHRlbXBzIHJlc3RhbnRcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZSAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggYHNvdXJjZWAgcHJvcGVydGllcyBhbmQgaWYgYW4gYE9iamVjdGAgc2V0IHByb3BlcnR5IHRvIG1lcmdlIG9mIGB0YXJnZXRgIGFuZCBgc291cmNlYCBwcm9wZXJ0aWVzXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc291cmNlKSkge1xuICAgICAgICBpZiAoc291cmNlW2tleV0gaW5zdGFuY2VvZiBPYmplY3QgJiYga2V5IGluIHRhcmdldCkgT2JqZWN0LmFzc2lnbihzb3VyY2Vba2V5XSwgbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKSlcbiAgICB9XG5cbiAgICAvLyBKb2luIGB0YXJnZXRgIGFuZCBtb2RpZmllZCBgc291cmNlYFxuICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0IHx8IHt9LCBzb3VyY2UpXG4gICAgcmV0dXJuIHRhcmdldFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJnYmFUb0FycmF5KHN0cikge1xuICAgIGxldCBzdGFydElkeFZhbHVlID0gc3RyLmluZGV4T2YoJygnKSArIDE7XG4gICAgbGV0IGVuZElkeFZhbHVlID0gc3RyLmluZGV4T2YoJyknKTtcbiAgICBsZXQgdmFsdWVzID0gc3RyLnN1YnN0cihzdGFydElkeFZhbHVlLCBlbmRJZHhWYWx1ZS1zdGFydElkeFZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWVzLnNwbGl0KCcsJykubWFwKE51bWJlcik7XG59XG4iLCIvKipcbiAqIEVudW0gZm9yIGNvbm5lY3Rpb24gc3RhdHVzLlxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7e25hbWU6IHN0cmluZ319XG4gKi9cbmV4cG9ydCBjb25zdCBTdGF0dXMgPSB7XG4gICAgQ09OTkVDVElORzogXCJjb25uZWN0aW5nXCIsXG4gICAgQ09OTkVDVEVEOiAgXCJjb25uZWN0ZWRcIixcbiAgICBESVNDT05ORUNURUQ6IFwiZGlzY29ubmVjdGVkXCIsXG4gICAgQ0xPU0VEX0VSUk9SOiBcImNsb3NlZC1lcnJvclwiXG59O1xuIiwiaW1wb3J0IHtpc0RlZmluZWR9IGZyb20gXCIuLi91dGlscy9VdGlscy5qc1wiO1xuaW1wb3J0IHtTdGF0dXN9IGZyb20gXCIuLi9wcm90b2NvbC9TdGF0dXMuanNcIjtcblxuY2xhc3MgRGF0YVN5bmNocm9uaXplckFsZ28ge1xuICAgIGNvbnN0cnVjdG9yKGRhdGFTb3VyY2VzLCByZXBsYXlTcGVlZCA9IDEsIHRpbWVyUmVzb2x1dGlvbiA9IDUpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlTWFwID0ge307XG4gICAgICAgIHRoaXMuYnVmZmVyaW5nVGltZSA9IDEwMDA7XG4gICAgICAgIHRoaXMuc3RhcnRCdWZmZXJpbmdUaW1lID0gLTE7XG4gICAgICAgIHRoaXMudHNSdW4gPSAwO1xuICAgICAgICB0aGlzLnJlcGxheVNwZWVkID0gcmVwbGF5U3BlZWQ7XG4gICAgICAgIHRoaXMudGltZXJSZXNvbHV0aW9uID0gdGltZXJSZXNvbHV0aW9uO1xuICAgICAgICBsZXQgbWF4QnVmZmVyaW5nVGltZSA9IC0xO1xuXG4gICAgICAgIGZvciAobGV0IGRzIG9mIGRhdGFTb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGFTb3VyY2UoZHMpO1xuICAgICAgICAgICAgbWF4QnVmZmVyaW5nVGltZSA9IGRzLmJ1ZmZlcmluZ1RpbWUgPiBtYXhCdWZmZXJpbmdUaW1lID8gZHMuYnVmZmVyaW5nVGltZSA6IG1heEJ1ZmZlcmluZ1RpbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heEJ1ZmZlcmluZ1RpbWUgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmluZ1RpbWUgPSBtYXhCdWZmZXJpbmdUaW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVzaChkYXRhU291cmNlSWQsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZUlkXTtcbiAgICAgICAgaWYgKGRzLnN0YXR1cyA9PT0gU3RhdHVzLkRJU0NPTk5FQ1RFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhcnRCdWZmZXJpbmdUaW1lID09PSAtMSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYHN5bmNocm9uaXplciBidWZmZXJpbmcgZGF0YSBmb3IgJHt0aGlzLmJ1ZmZlcmluZ1RpbWV9bXMuLmApO1xuICAgICAgICAgICAgdGhpcy5zdGFydEJ1ZmZlcmluZ1RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIC8vIHN0YXJ0IGl0ZXJhdGluZyBvbiBkYXRhIGFmdGVyIGJ1ZmZlcmluZ1RpbWVcbiAgICAgICAgICAgIHRoaXMudGltZW91dEJ1ZmZlcmluZyA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5wcm9jZXNzRGF0YSgpLCB0aGlzLmJ1ZmZlcmluZ1RpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxhdGVuY3kgPSAwO1xuICAgICAgICBpZiAodGhpcy50c1J1biA+IDApIHtcbiAgICAgICAgICAgIGxhdGVuY3kgPSB0aGlzLnRzUnVuIC0gZGF0YS50aW1lU3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgZHMubGF0ZW5jeSA9IGxhdGVuY3kgPiBkcy5sYXRlbmN5ID8gbGF0ZW5jeSA6IChkcy5sYXRlbmN5ICsgbGF0ZW5jeSkgLyAyO1xuXG4gICAgICAgIGRzLmRhdGFCdWZmZXIucHVzaChkYXRhKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3Jlc2V0IHN5bmNocm9uaXplciBhbGdvJylcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICBmb3IgKGxldCBjdXJyZW50RHNJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtjdXJyZW50RHNJZF07XG4gICAgICAgICAgICBjdXJyZW50RHMuZGF0YUJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgY3VycmVudERzLnN0YXJ0QnVmZmVyaW5nVGltZSA9IC0xO1xuICAgICAgICAgICAgY3VycmVudERzLmxhdGVuY3k9MDtcbiAgICAgICAgICAgIGN1cnJlbnREcy5zdGF0dXM9IFN0YXR1cy5ESVNDT05ORUNURUQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50c1J1biA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRCdWZmZXJpbmdUaW1lID0gLTE7XG4gICAgfVxuXG4gICAgcHJvY2Vzc0RhdGEoKSB7XG4gICAgICAgIC8vIHRoZSB0aW1lb3V0IGhhcyBiZWVuIGNhbmNlbGxlZFxuICAgICAgICBpZighaXNEZWZpbmVkKHRoaXMudGltZW91dEJ1ZmZlcmluZykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHNSZWYgPSAtMTtcbiAgICAgICAgbGV0IGNsb2NrVGltZVJlZiA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgIC8vIGdldCByZWZlcmVuY2Ugc3RhcnQgdGltZXN0YW1wXG4gICAgICAgIC8vIHRoZSByZWZlcmVuY2Ugc3RhcnQgdGltZXN0YW1wIHNob3VsZCB0aGUgb2xkZXN0IG9uZVxuICAgICAgICBsZXQgY3VycmVudERzO1xuICAgICAgICBmb3IgKGxldCBjdXJyZW50RHNJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGN1cnJlbnREcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtjdXJyZW50RHNJZF07XG4gICAgICAgICAgICBpZiAoY3VycmVudERzLnN0YXR1cyA9PT0gU3RhdHVzLkRJU0NPTk5FQ1RFRCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5kYXRhQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0c1JlZiA9ICh0c1JlZiA9PT0gLTEgfHwgY3VycmVudERzLmRhdGFCdWZmZXJbMF0udGltZVN0YW1wIDwgdHNSZWYpID8gY3VycmVudERzLmRhdGFCdWZmZXJbMF0udGltZVN0YW1wIDpcbiAgICAgICAgICAgICAgICAgICAgdHNSZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgLy8gMSkgcmV0dXJuIHRoZSBvbGRlc3QgZGF0YSBpZiBhbnlcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbXB1dGVOZXh0RGF0YSh0c1JlZiwgY2xvY2tUaW1lUmVmKSkgO1xuXG4gICAgICAgIH0sIHRoaXMudGltZXJSZXNvbHV0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBuZXh0IGRhdGEgaWYgYW55LiBXZSByZXR1cm4gb25seSAxIHZhbHVlIGZvciB0aGlzIGl0ZXJhdGlvbi4gSWYgdGhlcmUgYXJlIG11bHRpcGxlIHZhbHVlcyB0byByZXR1cm4sXG4gICAgICogd2UgcmV0dXJuIG9ubHkgdGhlIG9sZGVzdCBvbmUuXG4gICAgICogQHBhcmFtIHRzUmVmIC0gdGhlIHRpbWVzdGFtcCBvZiB0aGUgZmlyc3QgZGF0YVxuICAgICAqIEBwYXJhbSByZWZDbG9ja1RpbWUgLSB0aGUgYWJzb2x1dGUgZGlmZiB0aW1lIHJlYWxseSBzcGVudFxuICAgICAqL1xuICAgIGNvbXB1dGVOZXh0RGF0YSh0c1JlZiwgcmVmQ2xvY2tUaW1lKSB7XG4gICAgICAgIGxldCBjdXJyZW50RHM7XG4gICAgICAgIGxldCBjdXJyZW50RHNUb1NoaWZ0ID0gbnVsbDtcblxuICAgICAgICAvLyBjb21wdXRlIG1heCBsYXRlbmN5XG4gICAgICAgIGxldCBtYXhMYXRlbmN5ID0gMDtcbiAgICAgICAgbGV0IG1pbkxhdGVuY3kgPSAwO1xuICAgICAgICBmb3IgKGxldCBjdXJyZW50RHNJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGN1cnJlbnREcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtjdXJyZW50RHNJZF07XG4gICAgICAgICAgICBpZiAoY3VycmVudERzLnN0YXR1cyA9PT0gU3RhdHVzLkRJU0NPTk5FQ1RFRCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5sYXRlbmN5ID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBsYXRlbmN5ID0gTWF0aC5taW4oY3VycmVudERzLmxhdGVuY3ksIGN1cnJlbnREcy50aW1lT3V0KTtcbiAgICAgICAgICAgICAgICBtYXhMYXRlbmN5ID0gKGxhdGVuY3kgPiBtYXhMYXRlbmN5KSA/IGxhdGVuY3kgOiBtYXhMYXRlbmN5O1xuICAgICAgICAgICAgICAgIG1pbkxhdGVuY3kgPSAoY3VycmVudERzLmxhdGVuY3kgPCBtaW5MYXRlbmN5KSA/IGN1cnJlbnREcy5sYXRlbmN5IDogbWluTGF0ZW5jeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXhMYXRlbmN5ICo9IHRoaXMucmVwbGF5U3BlZWQ7XG4gICAgICAgIG1pbkxhdGVuY3kgKj0gdGhpcy5yZXBsYXlTcGVlZDtcblxuICAgICAgICBjb25zdCBkQ2xvY2sgPSAocGVyZm9ybWFuY2Uubm93KCkgLSByZWZDbG9ja1RpbWUpICogdGhpcy5yZXBsYXlTcGVlZDtcbiAgICAgICAgdGhpcy50c1J1biA9IHRzUmVmICsgZENsb2NrO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgbmV4dCBkYXRhIHRvIHJldHVyblxuICAgICAgICBmb3IgKGxldCBjdXJyZW50RHNJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGN1cnJlbnREcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtjdXJyZW50RHNJZF07XG4gICAgICAgICAgICBpZiAoY3VycmVudERzLnN0YXR1cyA9PT0gU3RhdHVzLkRJU0NPTk5FQ1RFRCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5kYXRhQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkVHMgPSAoY3VycmVudERzLmRhdGFCdWZmZXJbMF0udGltZVN0YW1wIC0gdHNSZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRDbG9ja0FkaiA9IGRDbG9jayAtIG1heExhdGVuY3k7XG4gICAgICAgICAgICAgICAgLy8gd2UgdXNlIGFuIGludGVybWVkaWF0ZSBvYmplY3QgdG8gc3RvcmUgdGhlIGRhdGEgdG8gc2hpZnQgYmVjYXVzZSB3ZSB3YW50IHRvIHJldHVybiB0aGUgb2xkZXN0IG9uZVxuICAgICAgICAgICAgICAgIC8vIG9ubHlcbiAgICAgICAgICAgICAgICBpZiAoZFRzIDw9IGRDbG9ja0Fkaikge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBvdGhlciBvbmUgdG8gY29tcGFyZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudERzVG9TaGlmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERzVG9TaGlmdCA9IGN1cnJlbnREcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRha2UgdGhlIG9sZGVzdCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHNUb1NoaWZ0ID0gKGN1cnJlbnREc1RvU2hpZnQuZGF0YUJ1ZmZlclswXS50aW1lU3RhbXAgPCBjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS50aW1lU3RhbXApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHNUb1NoaWZ0IDogY3VycmVudERzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluYWxseSBwb3AgdGhlIGRhdGEgZnJvbSBEUyBxdWV1ZVxuICAgICAgICBpZiAoY3VycmVudERzVG9TaGlmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlYyA9IGN1cnJlbnREc1RvU2hpZnQuZGF0YUJ1ZmZlci5zaGlmdCgpO1xuXG4gICAgICAgICAgICAvLyBhZGQgbGF0ZW5jeSBmbGFnIHRvIGRhdGEgcmVjb3JkIGJlZm9yZSB3ZSBkaXNwYXRjaCBpdFxuICAgICAgICAgICAgLy8gdGhpcyBpcyByZWxhdGl2ZSBsYXRlbmN5IGluIG1pbGxpcyBjb21wYXJlZCB0byB0aGUgRFMgd2l0aCB0aGUgbG93ZXN0IGxhdGVuY3lcbiAgICAgICAgICAgIC8vIHNvIGl0IGlzIGFjY3VyYXRlIGV2ZW4gaWYgbG9jYWwgZGV2aWNlIHRpbWUgaXMgbm90IHNldCBwcm9wZXJseVxuICAgICAgICAgICAgcmVjWydAbGF0ZW5jeSddID0gY3VycmVudERzLmxhdGVuY3kgLSBtaW5MYXRlbmN5O1xuXG4gICAgICAgICAgICB0aGlzLm9uRGF0YShjdXJyZW50RHNUb1NoaWZ0LmlkLCByZWMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhU291cmNlIHRvIGJlIHN5bmNocm9uaXplZFxuICAgICAqIEBwYXJhbSB7RGF0YVNvdXJjZX0gZGF0YVNvdXJjZSAtIHRoZSBkYXRhU291cmNlIHRvIHN5bmNocm9uaXplXG4gICAgICovXG4gICAgYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlLmlkXSA9IHtcbiAgICAgICAgICAgIGJ1ZmZlcmluZ1RpbWU6IGRhdGFTb3VyY2UuYnVmZmVyaW5nVGltZSxcbiAgICAgICAgICAgIHRpbWVPdXQ6IGRhdGFTb3VyY2UudGltZU91dCB8fCAwLFxuICAgICAgICAgICAgZGF0YUJ1ZmZlcjogW10sXG4gICAgICAgICAgICBzdGFydEJ1ZmZlcmluZ1RpbWU6IC0xLFxuICAgICAgICAgICAgaWQ6IGRhdGFTb3VyY2UuaWQsXG4gICAgICAgICAgICB0aW1lZE91dDogZmFsc2UsXG4gICAgICAgICAgICBuYW1lOiBkYXRhU291cmNlLm5hbWUgfHwgZGF0YVNvdXJjZS5pZCxcbiAgICAgICAgICAgIGxhdGVuY3k6IDAsXG4gICAgICAgICAgICBzdGF0dXM6IFN0YXR1cy5ESVNDT05ORUNURUQgLy9NRUFOSU5HIEVuYWJsZWQsIDAgPSBEaXNhYmxlZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG9uRGF0YShkYXRhU291cmNlSWQsIGRhdGEpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGRhdGFTb3VyY2Ugc3RhdHVzXG4gICAgICogQHBhcmFtIHtTdGF0dXN9IHN0YXR1cyAtIHRoZSBuZXcgc3RhdHVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFTb3VyY2VJZCAtIHRoZSBjb3JyZXNwb25kaW5nIGRhdGFTb3VyY2UgaWRcbiAgICAgKi9cbiAgICBzZXRTdGF0dXMoZGF0YVNvdXJjZUlkLCBzdGF0dXMpIHtcbiAgICAgICAgaWYgKGRhdGFTb3VyY2VJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlSWRdLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IFN0YXR1cy5ESVNDT05ORUNURUQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXNldCBsYXRlbmN5IGFuZCBidWZmZXJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZUlkXS5sYXRlbmN5ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZUlkXS5kYXRhQnVmZmVyID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihzdGF0dXMrJyBEYXRhU291cmNlICcgKyBkYXRhU291cmNlSWQgKyAnIGZyb20gdGhlIHN5bmNocm9uaXplciAnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHRoaXMuaW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaXNEZWZpbmVkKHRoaXMudGltZW91dEJ1ZmZlcmluZykpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRCdWZmZXJpbmcpO1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0QnVmZmVyaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhcIkRhdGEgc3luY2hyb25pemVyIHRlcm1pbmF0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhU3luY2hyb25pemVyQWxnbztcbiIsImV4cG9ydCBjb25zdCBEQVRBX1NZTkNIUk9OSVpFUl9UT1BJQyA9ICdkYXRhLXN5bmNocm9uaXplci0nO1xuZXhwb3J0IGNvbnN0IFRJTUVfU1lOQ0hST05JWkVSX1RPUElDID0gJ2RhdGEtc3luY2hyb25pemVyLXRpbWUtJztcblxuZXhwb3J0IGNvbnN0IERBVEFTT1VSQ0VfREFUQV9UT1BJQyA9ICdkYXRhc291cmNlLWRhdGEtJztcbmV4cG9ydCBjb25zdCBEQVRBU09VUkNFX1RJTUVfVE9QSUMgPSAnZGF0YXNvdXJjZS10aW1lLSc7XG5cbmV4cG9ydCBjb25zdCBGRk1QRUdfVklFV19ERUNPREVfVE9QSUMgPSAnZmZtcGVnLWRlY29kZS0nO1xuIiwiZXhwb3J0IGNvbnN0IEV2ZW50VHlwZSA9IHtcbiAgICBEQVRBOiAnZGF0YScsXG4gICAgU1RBVFVTOiAnc3RhdHVzJyxcbiAgICBUSU1FX0NIQU5HRUQ6ICd0aW1lLWNoYW5nZWQnXG59O1xuIiwiaW1wb3J0IERhdGFTeW5jaHJvbml6ZXJBbGdvIGZyb20gXCIuL0RhdGFTeW5jaHJvbml6ZXJBbGdvLmpzXCI7XG5pbXBvcnQge0RBVEFTT1VSQ0VfREFUQV9UT1BJQ30gZnJvbSBcIi4uL0NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHtFdmVudFR5cGV9IGZyb20gXCIuLi9ldmVudC9FdmVudFR5cGUuanNcIjtcblxuY29uc3QgYmNDaGFubmVscyA9IHt9O1xubGV0IGRhdGFTeW5jaHJvbml6ZXJBbGdvO1xuXG5sZXQgaW5pdCA9IGZhbHNlO1xubGV0IGRhdGFTb3VyY2VCcm9hZENhc3RDaGFubmVsID0gbnVsbDtcbnNlbGYuY3VycmVudFRpbWUgPSAtMTtcblxuY29uc3QgZGF0YVNvdXJjZXMgPSB7fTtcbmxldCB0aW1lQnJvYWRjYXN0Q2hhbm5lbCA9IG51bGw7XG5sZXQgdG9waWNUaW1lO1xubGV0IHRvcGljRGF0YTtcblxuc2VsZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICBpZihldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdpbml0Jykge1xuICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnbyA9IG5ldyBEYXRhU3luY2hyb25pemVyQWxnbyhcbiAgICAgICAgICAgIGV2ZW50LmRhdGEuZGF0YVNvdXJjZXMsXG4gICAgICAgICAgICBldmVudC5kYXRhLnJlcGxheVNwZWVkLFxuICAgICAgICAgICAgZXZlbnQuZGF0YS50aW1lclJlc29sdXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ub25EYXRhID0gb25EYXRhO1xuICAgICAgICBpbml0ID0gdHJ1ZTtcbiAgICAgICAgYWRkRGF0YVNvdXJjZXMoZXZlbnQuZGF0YS5kYXRhU291cmNlcyk7XG4gICAgICAgIHRvcGljRGF0YSA9IGV2ZW50LmRhdGEuZGF0YVRvcGljO1xuICAgICAgICB0b3BpY1RpbWUgPSBldmVudC5kYXRhLnRpbWVUb3BpYztcbiAgICAgICAgaW5pdEJyb2FkY2FzdENoYW5uZWwodG9waWNEYXRhLCB0b3BpY1RpbWUpO1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdpbml0aWFsaXplZCdcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmKGV2ZW50LmRhdGEubWVzc2FnZSA9PT0gJ2FkZCcgJiYgZXZlbnQuZGF0YS5kYXRhU291cmNlcykge1xuICAgICAgICBhZGREYXRhU291cmNlcyhldmVudC5kYXRhLmRhdGFTb3VyY2VzKTtcbiAgICB9IGVsc2UgaWYoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnY3VycmVudC10aW1lJykge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdjdXJyZW50LXRpbWUnLFxuICAgICAgICAgICAgZGF0YTogc2VsZi5jdXJyZW50VGltZVxuICAgICAgICB9KTtcbiAgICB9ICBlbHNlIGlmKGV2ZW50LmRhdGEubWVzc2FnZSA9PT0gJ3Jlc2V0Jykge1xuICAgICAgICBpZihkYXRhU3luY2hyb25pemVyQWxnbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuVElNRV9DSEFOR0VEXG4gICAgICAgIH0pO1xuICAgIH0gIGVsc2UgaWYoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAncmVwbGF5LXNwZWVkJykge1xuICAgICAgICBpZihkYXRhU3luY2hyb25pemVyQWxnbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ucmVwbGF5U3BlZWQgPSBldmVudC5kYXRhLnJlcGxheVNwZWVkO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKGV2ZW50LmRhdGEubWVzc2FnZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgIGlmKGRhdGFTeW5jaHJvbml6ZXJBbGdvICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5wdXNoKGV2ZW50LmRhdGEuZGF0YVNvdXJjZUlkLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogZXZlbnQuZGF0YS5kYXRhLFxuICAgICAgICAgICAgICAgIHRpbWVTdGFtcDogZXZlbnQuZGF0YS50aW1lU3RhbXBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0QnJvYWRjYXN0Q2hhbm5lbChkYXRhVG9waWMsIHRpbWVUb3BpYykge1xuICAgIGRhdGFTb3VyY2VCcm9hZENhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoZGF0YVRvcGljKTtcbiAgICBkYXRhU291cmNlQnJvYWRDYXN0Q2hhbm5lbC5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYoZXZlbnQuZGF0YS50eXBlID09PSBFdmVudFR5cGUuREFUQSkge1xuICAgICAgICAgICAgZm9yKGxldCBpPTA7IGkgPCBldmVudC5kYXRhLnZhbHVlcy5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ucHVzaChcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5kYXRhU291cmNlSWQsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmV2ZW50LmRhdGEudmFsdWVzW2ldXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoZXZlbnQuZGF0YS50eXBlID09PSBFdmVudFR5cGUuU1RBVFVTKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhU291cmNlSWQgPSBldmVudC5kYXRhLmRhdGFTb3VyY2VJZDtcbiAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnNldFN0YXR1cyhkYXRhU291cmNlSWQsIGV2ZW50LmRhdGEuc3RhdHVzKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGFTb3VyY2VzW2RhdGFTb3VyY2VJZF0ubmFtZSArIFwiOiBzdGF0dXM9XCIgKyBldmVudC5kYXRhLnN0YXR1cyk7XG4gICAgICAgICAgICAvLyBidWJibGUgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIGJjQ2hhbm5lbHNbZGF0YVNvdXJjZUlkXS5wb3N0TWVzc2FnZShldmVudC5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVCcm9hZGNhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwodGltZVRvcGljKTtcblxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gZGF0YVNvdXJjZXNcbiAqL1xuZnVuY3Rpb24gYWRkRGF0YVNvdXJjZXMoZGF0YVNvdXJjZXMpIHtcbiAgICBmb3IobGV0IGRhdGFTb3VyY2Ugb2YgZGF0YVNvdXJjZXMpIHtcbiAgICAgICAgYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZERhdGFTb3VyY2UoZGF0YVNvdXJjZSkge1xuICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLmFkZERhdGFTb3VyY2UoZGF0YVNvdXJjZSk7XG4gICAgLy8gY3JlYXRlIGEgQkMgdG8gcHVzaCBiYWNrIHRoZSBzeW5jaHJvbml6ZWQgZGF0YSBpbnRvIHRoZSBEQVRBIFN0cmVhbS5cbiAgICBiY0NoYW5uZWxzW2RhdGFTb3VyY2UuaWRdID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoREFUQVNPVVJDRV9EQVRBX1RPUElDICsgZGF0YVNvdXJjZS5pZCk7XG5cbiAgICBpZighKGRhdGFTb3VyY2UuaWQgaW4gZGF0YVNvdXJjZXMpKSB7XG4gICAgICAgIGRhdGFTb3VyY2VzW2RhdGFTb3VyY2UuaWRdID0gZGF0YVNvdXJjZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9uRGF0YShkYXRhU291cmNlSWQsIGRhdGEpIHtcbiAgICBzZWxmLmN1cnJlbnRUaW1lID0gZGF0YS50aW1lU3RhbXA7XG4gICAgYmNDaGFubmVsc1tkYXRhU291cmNlSWRdLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHZhbHVlczogW2RhdGFdLFxuICAgICAgICAgICAgZGF0YVNvdXJjZUlkOmRhdGFTb3VyY2VJZCxcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5EQVRBXG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdGltZUJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0aW1lc3RhbXA6IGRhdGEudGltZVN0YW1wLFxuICAgICAgICBkYXRhU291cmNlSWQ6IGRhdGFTb3VyY2VJZCxcbiAgICAgICAgdHlwZTogRXZlbnRUeXBlLkRBVEFcbiAgICB9KTtcbn1cblxuXG5zZWxmLm9uY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICBkYXRhU3luY2hyb25pemVyQWxnby5jbG9zZSgpO1xuICAgIGNvbnNvbGUubG9nKFwiRGF0YSBTeW5jaHJvbml6ZXIgaGFzIGJlZW4gdGVybWluYXRlZCBzdWNjZXNzZnVsbHlcIik7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")}]);