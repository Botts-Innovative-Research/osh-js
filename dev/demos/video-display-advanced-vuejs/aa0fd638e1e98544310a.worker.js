!function(Q){var I={};function B(F){if(I[F])return I[F].exports;var U=I[F]={i:F,l:!1,exports:{}};return Q[F].call(U.exports,U,U.exports,B),U.l=!0,U.exports}B.m=Q,B.c=I,B.d=function(Q,I,F){B.o(Q,I)||Object.defineProperty(Q,I,{enumerable:!0,get:F})},B.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},B.t=function(Q,I){if(1&I&&(Q=B(Q)),8&I)return Q;if(4&I&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var F=Object.create(null);if(B.r(F),Object.defineProperty(F,"default",{enumerable:!0,value:Q}),2&I&&"string"!=typeof Q)for(var U in Q)B.d(F,U,function(I){return Q[I]}.bind(null,U));return F},B.n=function(Q){var I=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return B.d(I,"a",I),I},B.o=function(Q,I){return Object.prototype.hasOwnProperty.call(Q,I)},B.p="",B(B.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/Constants.js\nconst DATA_SYNCHRONIZER_TOPIC = 'data-synchronizer-';\nconst TIME_SYNCHRONIZER_TOPIC = 'data-synchronizer-time-';\nconst DATASOURCE_DATA_TOPIC = 'datasource-data-';\nconst DATASOURCE_TIME_TOPIC = 'datasource-time-';\nconst FFMPEG_VIEW_DECODE_TOPIC = 'ffmpeg-decode-';\nconst MAGIC_END_PACKET = 'magic-packet';\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/event/EventType.js\nconst EventType = {\n  DATA: 'data',\n  LAST_TIME: 'last-time',\n  MASTER_TIME: 'master-time',\n  STATUS: 'status',\n  TIME_CHANGED: 'time-changed'\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/utils/Utils.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n/** * @module Utils */\n\n/** Maximum value of a long */\nconst MAX_LONG = Math.pow(2, 53) + 1;\n/**\n * Global helper method to test if a letiable or object attribute is defined\n */\n\nfunction isDefined(v) {\n  return typeof v !== 'undefined' && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute has a value,\n that is it is defined and non null\n */\n\nfunction hasValue(v) {\n  return isDefined(v) && v !== null;\n}\n/**\n Global helper method to transform hex color into RGBA\n */\n\nfunction hex2rgb(hex) {\n  const [r, g, b] = hex.match(/\\w\\w/g).map(x => parseInt(x, 16));\n  return [r, g, b];\n}\n/**\n Global helper method to test if a letiable or object attribute is of a particular type\n */\n\nfunction hasType(v, expectedType) {\n  let hasVal = hasValue(v);\n  return hasVal && typeof v === expectedType;\n}\n/**\n Global helper method to test if a letiable or object attribute is an object\n */\n\nfunction isObject(v, letName) {\n  return hasType(v, 'object', letName);\n}\n/**\n Global helper method to test if a letiable or object attribute is an array\n */\n\nfunction isArray(v) {\n  return isDefined(v) && Array.isArray(v);\n}\n/**\n Global helper method to test if a letiable or object attribute is a function\n */\n\nfunction isFunction(v, letName) {\n  return hasType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined\n **/\n\nfunction assertDefined(v, letName = 'letiable') {\n  if (!isDefined(v)) {\n    throw letName + \" must be defined\";\n  }\n\n  return v;\n}\nfunction assertTrue(v, letName = 'letiable') {\n  if (!isDefined(v) || !v) {\n    throw letName;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertType(v, expectedType, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (typeof v !== expectedType) {\n    throw letName + \" must be of type \" + expectedType;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertBoolean(v, letName) {\n  return assertType(v, 'boolean', letName);\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertString(v, letName) {\n  return assertType(v, 'string', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertNumber(v, letName) {\n  return assertType(v, 'number', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertPositive(v, letName) {\n  assertNumber(v, letName);\n\n  if (v <= 0) {\n    throw letName + \" must be a positive number\";\n  }\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertObject(v, letName) {\n  return assertType(v, 'object', letName);\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertArray(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!Array.isArray(v)) {\n    throw letName + \" must be an array\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a function\n **/\n\nfunction assertFunction(v, letName) {\n  return assertType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertHasValue(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!hasValue(v)) {\n    throw letName + \" must not be null\";\n  }\n\n  return v;\n}\n/**\n *\n * @return {String}\n */\n\nfunction randomUUID() {\n  return 'xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * This function stamps/embeds a UUID into an object and returns the UUID generated for it\n * @return {String}\n */\n\nfunction stampUUID(obj) {\n  obj._osh_id = obj._osh_id || randomUUID();\n  return obj._osh_id;\n} //buffer is an ArrayBuffer object, the offset if specified in bytes, and the type is a string\n//corresponding to an OGC data type.\n//See http://def.seegrid.csiro.au/sissvoc/ogc-def/resource?uri=http://www.opengis.net/def/dataType/OGC/0/\n\n/**\n *\n * @param buffer\n * @param offset\n * @param type\n * @return {*}\n */\n\nfunction ParseBytes(buffer, offset, type) {\n  let view = new DataView(buffer); //Note: There exist types not listed in the map below that have OGC definitions, but no appropriate\n  //methods or corresponding types available for parsing in javascript. They are float128, float16, signedLong,\n  //and unsignedLong\n\n  let typeMap = {\n    double: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float64: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float32: function (offset) {\n      return {\n        val: view.getFloat32(offset),\n        bytes: 4\n      };\n    },\n    signedByte: function (offset) {\n      return {\n        val: view.getInt8(offset),\n        bytes: 1\n      };\n    },\n    signedInt: function (offset) {\n      return {\n        val: view.getInt32(offset),\n        bytes: 4\n      };\n    },\n    signedShort: function (offset) {\n      return {\n        val: view.getInt16(offset),\n        bytes: 2\n      };\n    },\n    unsignedByte: function (offset) {\n      return {\n        val: view.getUint8(offset),\n        bytes: 1\n      };\n    },\n    unsignedInt: function (offset) {\n      return {\n        val: view.getUint32(offset),\n        bytes: 4\n      };\n    },\n    unsignedShort: function (offset) {\n      return {\n        val: view.getUint16(offset),\n        bytes: 2\n      };\n    } //TODO: string-utf-8:\n\n  };\n  return typeMap[type](offset);\n} //This function recursivley iterates over the resultStructure to fill in\n//values read from data which should be an ArrayBuffer containing the payload from a websocket\n\n/**\n *\n * @param struct\n * @param data\n * @param offsetBytes\n * @return {*}\n */\n\nfunction ReadData(struct, data, offsetBytes) {\n  let offset = offsetBytes;\n\n  for (let i = 0; i < struct.fields.length; i++) {\n    let currFieldStruct = struct.fields[i];\n\n    if (isDefined(currFieldStruct.type) && currFieldStruct.type !== null) {\n      let ret = ParseBytes(data, offset, currFieldStruct.type);\n      currFieldStruct.val = ret.val;\n      offset += ret.bytes;\n    } else if (isDefined(currFieldStruct.count) && currFieldStruct.count !== null) {\n      //check if count is a reference to another letiable\n      if (isNaN(currFieldStruct.count)) {\n        let id = currFieldStruct.count;\n        let fieldName = struct.id2FieldMap[id];\n        currFieldStruct.count = struct.findFieldByName(fieldName).val;\n      }\n\n      for (let c = 0; c < currFieldStruct.count; c++) {\n        for (let j = 0; j < currFieldStruct.fields.length; j++) {\n          let field = JSON.parse(JSON.stringify(currFieldStruct.fields[j]));\n          offset = ReadData(field, data, offset);\n          currFieldStruct.val.push(field);\n        }\n      }\n    }\n  }\n\n  return offset;\n}\n/**\n *\n * @param resultStructure\n * @return {{}}\n */\n\nfunction GetResultObject(resultStructure) {\n  //TODO: handle cases for nested arrays / matrix data types\n  let result = {};\n\n  for (let i = 0; i < resultStructure.fields.length; i++) {\n    if (isDefined(resultStructure.fields[i].count)) {\n      result[resultStructure.fields[i].name] = [];\n\n      for (let c = 0; c < resultStructure.fields[i].count; c++) {\n        let item = {};\n\n        for (let k = 0; k < resultStructure.fields[i].val[c].fields.length; k++) {\n          item[resultStructure.fields[i].val[c].fields[k].name] = resultStructure.fields[i].val[c].fields[k].val;\n        }\n\n        result[resultStructure.fields[i].name].push(item);\n      }\n    } else {\n      result[resultStructure.fields[i].name] = resultStructure.fields[i].val;\n    }\n  }\n\n  return result;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isOpera() {\n  return !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isFirefox() {\n  return typeof InstallTrigger !== 'undefined';\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isSafari() {\n  return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isChrome() {\n  return !!window.chrome && !!window.chrome.webstore;\n}\n/**\n *\n * @return {*|boolean}\n */\n\nfunction isBlink() {\n  return (isChrome || isOpera) && !!window.CSS;\n}\n/**\n *\n * @param a\n * @param b\n * @return {boolean}\n */\n\nfunction isArrayIntersect(a, b) {\n  return a.filter(function (element) {\n    return b.indexOf(element) > -1;\n  }).length > 0;\n}\n/**\n *\n * @param o\n * @return {boolean}\n */\n\nfunction isElement(o) {\n  return typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n  o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n}\n/**\n *\n * @return {*}\n */\n\nfunction isWebWorker() {\n  return isDefined(Worker);\n}\n/**\n *\n * @param div\n */\n\nfunction takeScreenShot(div) {}\n/**\n * Remove a css class from a the div given as argument.\n * @param div the div to remove the class from\n * @param css the css class to remove\n */\n\nfunction removeCss(div, css) {\n  let divCss = div.className;\n  css = divCss.replace(css, \"\");\n  div.className = css;\n}\n/**\n * Add a css class to a the div given as argument.\n * @param div the div to add the class to\n * @param css the css class to add\n */\n\nfunction addCss(div, css) {\n  div.setAttribute(\"class\", div.className + \" \" + css);\n}\n/**\n * Removes the last character of a {string} object.\n * @param {string} value - The input {string}\n * @return {string} The value without the last character\n */\n\nfunction removeLastCharIfExist(value) {\n  if (!isDefined(undefined) || value === null || value.length === 0 || !value.endsWith(\"/\")) {\n    return value;\n  }\n\n  return value.substring(0, value.length - 1);\n}\n/**\n * Capitalize the first letter of a given string\n * @param {String} str - the input string\n * @returns {String} the result\n */\n\nfunction capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n/**\n * Round off number to nearest 0.5\n * @param {Number} num - The number to round off\n * @return {number} The rounded number\n */\n\nfunction roundHalf(num) {\n  return Math.round(num * 2) / 2;\n}\n/**\n * Returns a function that, as long as it continues to be invoked,\n * will not be executed. The function will only be executed when\n * it will stop being called for more than N milliseconds.\n * If the `immediate` parameter is true, then the function\n * will be executed at the first call instead of the last.\n * Parameters :\n * - func: the function to `debouncer`.\n * - wait: the number of milliseconds (N) to wait before\n * call func()\n * - immediate (optional): Call func() at the first invocation\n * instead of the last one (Default false)\n * - context (optional): the context in which to call func()\n * (this by default)\n */\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n\nfunction debounce(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n\n  var later = function () {\n    var now = new Date().getTime(),\n        last = now - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = new Date().getTime();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n}\n;\nfunction throttle(func, wait, leading, trailing, context) {\n  var ctx, args, result;\n  var timeout = null;\n  var previous = 0;\n\n  var later = function () {\n    previous = new Date();\n    timeout = null;\n    result = func.apply(ctx, args);\n  };\n\n  return function () {\n    var now = new Date();\n    if (!previous && !leading) previous = now;\n    var remaining = wait - (now - previous);\n    ctx = context || this;\n    args = arguments;\n\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(ctx, args);\n    } else if (!timeout && trailing) {\n      // Sinon on s’endort pendant le temps restant\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n;\nfunction merge(target, source) {\n  // Iterate through `source` properties and if an `Object` set property to merge of `target` and `source` properties\n  for (const key of Object.keys(source)) {\n    if (source[key] instanceof Object && key in target) Object.assign(source[key], merge(target[key], source[key]));\n  } // Join `target` and modified `source`\n\n\n  Object.assign(target || {}, source);\n  return target;\n}\n;\nfunction rgbaToArray(str) {\n  let startIdxValue = str.indexOf('(') + 1;\n  let endIdxValue = str.indexOf(')');\n  let values = str.substr(startIdxValue, endIdxValue - startIdxValue);\n  return values.split(',').map(Number);\n}\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/datasource/Mode.js\n/**\n * Enum for datasource mode.\n * @readonly\n * @enum {{name: string}}\n */\nconst Mode = {\n  REPLAY: \"replay\",\n  BATCH: \"batch\",\n  REAL_TIME: \"realTime\"\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/connector/Status.js\n/**\n * Enum for connection status.\n * @readonly\n * @enum {{name: string}}\n */\nconst Status = {\n  CONNECTING: \"connecting\",\n  CONNECTED: \"connected\",\n  DISCONNECTED: \"disconnected\",\n  FETCH_STARTED: 'fetch-start',\n  FETCH_ENDED: 'fetch-end',\n  CLOSED: \"closed\",\n  CLOSED_ERROR: \"closed-error\"\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/DataSynchronizerAlgo.js\n\n\n\nclass DataSynchronizerAlgo_DataSynchronizerAlgo {\n  constructor(dataSources, timerResolution = 5) {\n    this.dataSourceMap = {};\n    this.tsRun = undefined;\n    this.timerResolution = timerResolution;\n    this.interval = null;\n    this.datasources = [];\n\n    for (let ds of dataSources) {\n      this.addDataSource(ds);\n    }\n  }\n\n  removeDataSource(dataSourceId) {\n    this.datasources = this.datasources.filter(elt => elt.id !== dataSourceId);\n    delete this.dataSourceMap[dataSourceId];\n  }\n\n  push(dataSourceId, dataBlocks) {}\n\n  getCurrentTimestamp() {\n    return this.tsRun;\n  }\n\n  processData() {\n    let tsRef = -1;\n    let clockTimeRef = performance.now(); // get reference start timestamp\n    // the reference start timestamp should the oldest one\n\n    let currentDs;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.dataBuffer.length > 0) {\n        tsRef = tsRef === -1 || currentDs.dataBuffer[0].data.timestamp < tsRef ? currentDs.dataBuffer[0].data.timestamp : tsRef;\n      }\n    }\n\n    this.interval = setInterval(() => {\n      // 1) return the oldest data if any\n      while (this.computeNextData(tsRef, clockTimeRef));\n    }, this.timerResolution);\n    console.warn(`Started Replay Algorithm with tsRef=${new Date(tsRef).toISOString()}`);\n  }\n  /**\n   * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,\n   * we return only the oldest one.\n   * @param tsRef - the timestamp of the first data\n   * @param refClockTime - the absolute diff time really spent\n   */\n\n\n  computeNextData(tsRef, refClockTime) {\n    throw Error('Should be overridden');\n  }\n  /**\n   * Add dataSource to be synchronized\n   * @param {Datasource} dataSource - the dataSource to synchronize\n   */\n\n\n  addDataSource(dataSource) {\n    throw Error('Should be overridden');\n  }\n\n  checkVersion(datasource, dataBlock) {\n    throw Error('Should be overridden');\n  }\n\n  onData(dataSourceId, dataBlock) {}\n  /**\n   * Change the dataSource status\n   * @param {Status} status - the new status\n   * @param {String} dataSourceId - the corresponding dataSource id\n   */\n\n\n  setStatus(dataSourceId, status) {\n    throw Error('Should be overridden');\n  }\n\n  close() {\n    if (isDefined(this.interval)) {\n      clearInterval(this.interval);\n      this.interval = undefined;\n    }\n\n    console.log(\"Data synchronizer terminated successfully\");\n  }\n\n  onStart() {}\n\n}\n\n/* harmony default export */ var timesync_DataSynchronizerAlgo = (DataSynchronizerAlgo_DataSynchronizerAlgo);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/DataSynchronizerAlgo.replay.js\n\n\n\n\nclass DataSynchronizerAlgo_replay_DataSynchronizerAlgoReplay extends timesync_DataSynchronizerAlgo {\n  constructor(dataSources, replaySpeed = 1, startTimestamp, endTimestamp, timerResolution = 5) {\n    super(dataSources, replaySpeed, timerResolution);\n    this.replaySpeed = replaySpeed;\n    this.startTimestamp = startTimestamp;\n    this.endTimestamp = endTimestamp;\n  }\n\n  push(dataSourceId, dataBlocks) {\n    if (dataBlocks.length === 0) {\n      return;\n    }\n\n    const ds = this.dataSourceMap[dataSourceId];\n    const lastData = dataBlocks[dataBlocks.length - 1];\n\n    if (!this.checkVersion(ds, lastData)) {\n      console.warn(`[DataSynchronizer] incompatible version ${ds.version} ~ ${lastData.version}, skipping data`);\n      return;\n    }\n\n    ds.dataBuffer.push(...dataBlocks);\n  }\n\n  processData() {\n    let clockTimeRef = performance.now();\n    this.interval = setInterval(() => {\n      // 1) return the oldest data if any\n      while (this.computeNextData(this.startTimestamp, clockTimeRef)) {}\n\n      this.checkEnd();\n    }, this.timerResolution);\n    console.warn(`Started Replay Algorithm with tsRef=${new Date(this.startTimestamp).toISOString()}`);\n  }\n  /**\n   * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,\n   * we return only the oldest one.\n   * @param tsRef - the timestamp of the first data\n   * @param refClockTime - the absolute diff time really spent\n   */\n\n\n  computeNextData(tsRef, refClockTime) {\n    let currentDs;\n    let currentDsToShift = null;\n    const dClock = (performance.now() - refClockTime) * this.replaySpeed;\n    this.tsRun = tsRef + dClock; // compute next data to return\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.dataBuffer.length > 0) {\n        const dTs = currentDs.dataBuffer[0].data.timestamp - tsRef; // we use an intermediate object to store the data to shift because we want to return the oldest one\n        // only\n\n        if (dTs <= dClock) {\n          // no other one to compare\n          if (currentDsToShift === null) {\n            currentDsToShift = currentDs;\n          } else {\n            // take the oldest data\n            currentDsToShift = currentDsToShift.dataBuffer[0].data.timestamp < currentDs.dataBuffer[0].data.timestamp ? currentDsToShift : currentDs;\n          }\n        }\n      }\n    } // finally pop the data from DS queue\n\n\n    if (currentDsToShift !== null) {\n      this.onData(currentDsToShift.id, currentDsToShift.dataBuffer.shift());\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Add dataSource to be synchronized\n   * @param {Datasource} dataSource - the dataSource to synchronize\n   */\n\n\n  addDataSource(dataSource) {\n    this.dataSourceMap[dataSource.id] = {\n      dataBuffer: [],\n      id: dataSource.id,\n      name: dataSource.name || dataSource.id,\n      status: Status.DISCONNECTED,\n      //MEANING Enabled, 0 = Disabled\n      version: undefined\n    };\n    this.datasources.push(dataSource);\n  }\n\n  checkVersion(datasource, dataBlock) {\n    if (!isDefined(datasource.version)) {\n      return true;\n    } else if (datasource.version !== dataBlock.version) {\n      return false;\n    }\n  }\n  /**\n   * Change the dataSource status\n   * @param {Status} status - the new status\n   * @param {String} dataSourceId - the corresponding dataSource id\n   */\n\n\n  setStatus(dataSourceId, status) {\n    if (dataSourceId in this.dataSourceMap) {\n      this.dataSourceMap[dataSourceId].status = status;\n      console.warn(status + ' DataSource ' + dataSourceId + ' from the synchronizer ');\n    }\n\n    this.checkStart();\n  }\n\n  checkStart() {\n    if (!isDefined(this.interval)) {\n      let nbDatasourcesFetchedOk = 0;\n      let totalDataSources = Object.keys(this.dataSourceMap).length;\n\n      for (let dataSourceID in this.dataSourceMap) {\n        if (this.dataSourceMap[dataSourceID].status === Status.FETCH_STARTED) nbDatasourcesFetchedOk++;\n      }\n\n      console.warn(`[Synchronizer] Fetched ${nbDatasourcesFetchedOk}/${totalDataSources} datasources`);\n\n      if (nbDatasourcesFetchedOk === totalDataSources) {\n        console.warn('Starting Replay Algorithm...');\n        this.processData();\n        this.onStart();\n      }\n    }\n  }\n\n  checkEnd() {\n    if (this.getCurrentTimestamp() >= this.endTimestamp) {\n      this.onEnd();\n      this.reset();\n    }\n  }\n\n  reset() {\n    this.tsRun = undefined;\n    console.log('reset synchronizer algo');\n    this.close();\n\n    for (let currentDsId in this.dataSourceMap) {\n      this.resetDataSource(currentDsId);\n    }\n  }\n\n  resetDataSource(datasourceId) {\n    const currentDs = this.dataSourceMap[datasourceId];\n    currentDs.dataBuffer = [];\n    currentDs.status = Status.DISCONNECTED;\n    currentDs.version = undefined;\n  }\n\n  onEnd() {}\n\n  onStart() {}\n\n}\n\n/* harmony default export */ var DataSynchronizerAlgo_replay = (DataSynchronizerAlgo_replay_DataSynchronizerAlgoReplay);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/DataSynchronizerAlgo.realtime.js\n\n\n\n\nclass DataSynchronizerAlgo_realtime_DataSynchronizerAlgoRealtime extends timesync_DataSynchronizerAlgo {\n  push(dataSourceId, dataBlocks) {\n    if (dataBlocks.length === 0) {\n      return;\n    }\n\n    const ds = this.dataSourceMap[dataSourceId];\n    const lastData = dataBlocks[dataBlocks.length - 1];\n\n    if (!this.checkVersion(ds, lastData)) {\n      return;\n    }\n\n    let latency = 0;\n\n    if (this.tsRun > 0) {\n      latency = this.tsRun - lastData.data.timestamp;\n    }\n\n    ds.latency = latency > ds.latency ? latency : (ds.latency + latency) / 2;\n    ds.dataBuffer.push(...dataBlocks);\n\n    if (!isDefined(this.interval)) {\n      this.processData();\n    }\n  }\n  /**\n   * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,\n   * we return only the oldest one.\n   * @param tsRef - the timestamp of the first data\n   * @param refClockTime - the absolute diff time really spent\n   */\n\n\n  computeNextData(tsRef, refClockTime) {\n    let currentDs;\n    let currentDsToShift = null; // compute max latency\n\n    let maxLatency = 0;\n    let minLatency = 0;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.latency > 0) {\n        let latency = Math.min(currentDs.latency, currentDs.timeOut);\n        maxLatency = latency > maxLatency ? latency : maxLatency;\n        minLatency = currentDs.latency < minLatency ? currentDs.latency : minLatency;\n      }\n    }\n\n    const dClock = performance.now() - refClockTime;\n    this.tsRun = tsRef + dClock; // compute next data to return\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.dataBuffer.length > 0) {\n        const dTs = currentDs.dataBuffer[0].data.timestamp - tsRef;\n        const dClockAdj = dClock - maxLatency; // we use an intermediate object to store the data to shift because we want to return the oldest one\n        // only\n\n        if (dTs <= dClockAdj) {\n          // no other one to compare\n          if (currentDsToShift === null) {\n            currentDsToShift = currentDs;\n          } else {\n            // take the oldest data\n            currentDsToShift = currentDsToShift.dataBuffer[0].data.timestamp < currentDs.dataBuffer[0].data.timestamp ? currentDsToShift : currentDs;\n          }\n        }\n      }\n    } // finally pop the data from DS queue\n\n\n    if (currentDsToShift !== null) {\n      let rec = currentDsToShift.dataBuffer.shift(); // add latency flag to data record before we dispatch it\n      // this is relative latency in millis compared to the DS with the lowest latency\n      // so it is accurate even if local device time is not set properly\n\n      rec['@latency'] = currentDs.latency - minLatency;\n      this.onData(currentDsToShift.id, rec);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Add dataSource to be synchronized\n   * @param {Datasource} dataSource - the dataSource to synchronize\n   */\n\n\n  addDataSource(dataSource) {\n    this.dataSourceMap[dataSource.id] = {\n      timeOut: dataSource.timeOut || 0,\n      dataBuffer: [],\n      id: dataSource.id,\n      timedOut: false,\n      name: dataSource.name || dataSource.id,\n      latency: 0,\n      status: Status.DISCONNECTED,\n      //MEANING Enabled, 0 = Disabled\n      version: undefined\n    };\n    this.datasources.push(dataSource);\n  }\n\n  checkVersion(datasource, dataBlock) {\n    if (datasource.status !== Status.DISCONNECTED) {\n      return true;\n    } else if (datasource.status === Status.DISCONNECTED && datasource.version !== dataBlock.version) {\n      return false;\n    }\n  }\n  /**\n   * Change the dataSource status\n   * @param {Status} status - the new status\n   * @param {String} dataSourceId - the corresponding dataSource id\n   */\n\n\n  setStatus(dataSourceId, status) {\n    if (dataSourceId in this.dataSourceMap) {\n      this.dataSourceMap[dataSourceId].status = status;\n      console.warn(status + ' DataSource ' + dataSourceId + ' from the synchronizer ');\n    }\n  }\n\n  reset() {\n    this.tsRun = undefined;\n    console.log('reset synchronizer algo');\n    this.close();\n\n    for (let currentDsId in this.dataSourceMap) {\n      this.resetDataSource(currentDsId);\n    }\n  }\n\n  resetDataSource(datasourceId) {\n    const currentDs = this.dataSourceMap[datasourceId];\n    currentDs.dataBuffer = [];\n    currentDs.startBufferingTime = -1;\n    currentDs.latency = 0;\n    currentDs.status = Status.DISCONNECTED;\n    currentDs.version = undefined;\n  }\n\n}\n\n/* harmony default export */ var DataSynchronizerAlgo_realtime = (DataSynchronizerAlgo_realtime_DataSynchronizerAlgoRealtime);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/DataSynchronizer.worker.js\n\n\n\n\n\n\n\nconst bcChannels = {};\nlet dataSynchronizerAlgo;\n\nlet init = false;\nlet dataSourceBroadCastChannel = null;\nlet DataSynchronizer_worker_lastData = undefined;\nconst dataSources = {};\nlet timeBroadcastChannel = null;\nlet topicTime;\nlet topicData;\nlet replaySpeed;\nlet masterTimeInterval = undefined;\nlet cTime;\nlet cId;\nlet lastTime = -1;\nlet version = -1;\nlet promise;\nlet DataSynchronizer_worker_masterTimeRefreshRate;\nlet startTimestamp;\nlet endTimestamp;\n\nself.onmessage = async (event) => {\n    if(isDefined(promise)) {\n        await promise;\n    }\n    promise = handleMessage(event);\n}\n\nasync function handleMessage(event) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            let sendResponse = true;\n            let data = undefined;\n            if (event.data.message === 'init') {\n                replaySpeed = event.data.replaySpeed;\n                startTimestamp = new Date(event.data.startTime).getTime();\n                endTimestamp = new Date(event.data.endTime).getTime();\n\n                if (event.data.mode === Mode.REPLAY) {\n                    dataSynchronizerAlgo = new DataSynchronizerAlgo_replay(\n                        event.data.dataSources,\n                        event.data.replaySpeed,\n                        startTimestamp,\n                        endTimestamp,\n                        event.data.timerResolution\n                    );\n                    dataSynchronizerAlgo.onEnd = onEnd;\n                    dataSynchronizerAlgo.onStart = onStart;\n                } else {\n                    dataSynchronizerAlgo = new DataSynchronizerAlgo_realtime(\n                        event.data.dataSources,\n                        event.data.replaySpeed,\n                        event.data.timerResolution\n                    );\n                }\n                dataSynchronizerAlgo.onData = onData;\n                init = true;\n                addDataSources(event.data.dataSources);\n                topicData = event.data.topics.data;\n                topicTime = event.data.topics.time;\n                initBroadcastChannel(topicData, topicTime);\n                DataSynchronizer_worker_masterTimeRefreshRate = event.data.masterTimeRefreshRate;\n            } else if (event.data.message === 'add' && event.data.dataSources) {\n                console.log('Add datasource to synchronizer..')\n                addDataSources(event.data.dataSources);\n            } else if (event.data.message === 'connect') {\n                startMasterTimeInterval(DataSynchronizer_worker_masterTimeRefreshRate);\n                dataSynchronizerAlgo.checkStart();\n            } else if (event.data.message === 'remove' && event.data.dataSources) {\n                console.log('Remove datasource from synchronizer..')\n                await removeDataSources(event.data.dataSources);\n            } else if (event.data.message === 'current-time') {\n                data = {\n                    message: 'current-time',\n                    data: dataSynchronizerAlgo.getCurrentTimestamp()\n                };\n            } else if (event.data.message === 'reset') {\n                DataSynchronizer_worker_reset();\n            } else if (event.data.message === 'replay-speed') {\n                if (dataSynchronizerAlgo !== null) {\n                    DataSynchronizer_worker_reset();\n                    dataSynchronizerAlgo.replaySpeed = event.data.replaySpeed;\n                }\n            } else if (event.data.message === 'update-properties') {\n                DataSynchronizer_worker_reset();\n                let datasources = [];\n                if (dataSynchronizerAlgo !== null) {\n                    datasources = dataSynchronizerAlgo.datasources;\n                }\n\n                startTimestamp = new Date(event.data.startTime).getTime();\n                endTimestamp = new Date(event.data.endTime).getTime();\n\n                if (event.data.mode === Mode.REPLAY) {\n                    dataSynchronizerAlgo = new DataSynchronizerAlgo_replay(\n                        datasources,\n                        event.data.replaySpeed,\n                        startTimestamp,\n                        endTimestamp,\n                        dataSynchronizerAlgo.timerResolution\n                    );\n                    dataSynchronizerAlgo.onEnd = onEnd;\n                    dataSynchronizerAlgo.onStart = onStart;\n                } else {\n                    dataSynchronizerAlgo = new DataSynchronizerAlgo_realtime(\n                        datasources,\n                        dataSynchronizerAlgo.timerResolution\n                    );\n                }\n\n                dataSynchronizerAlgo.onData = onData;\n            } else if (event.data.message === 'data') {\n                checkMasterTime();\n                if (dataSynchronizerAlgo !== null) {\n                    dataSynchronizerAlgo.push(event.data.dataSourceId, event.data.data);\n                }\n            } else {\n                // skip response\n                sendResponse = false;\n            }\n            if (sendResponse) {\n                self.postMessage({\n                    message: event.data.message,\n                    data: data,\n                    messageId: event.data.messageId\n                });\n            }\n            resolve();\n        } catch (ex) {\n            reject(ex);\n        }\n    });\n}\nfunction DataSynchronizer_worker_reset() {\n    clearInterval(masterTimeInterval);\n    masterTimeInterval = undefined;\n    version = -1;\n    if(dataSynchronizerAlgo !== null) {\n        dataSynchronizerAlgo.reset();\n    }\n    timeBroadcastChannel.postMessage({\n        type: EventType.TIME_CHANGED\n    });\n}\nfunction initBroadcastChannel(dataTopic, timeTopic) {\n    console.log('listen on topic ',dataTopic)\n\n    dataSourceBroadCastChannel = new BroadcastChannel(dataTopic);\n    dataSourceBroadCastChannel.onmessage = async (event) => {\n        checkMasterTime();\n        if(event.data.type === EventType.DATA) {\n            dataSynchronizerAlgo.push(event.data.dataSourceId,event.data.values);\n        } else if(event.data.type === EventType.STATUS) {\n            const dataSourceId = event.data.dataSourceId;\n            dataSynchronizerAlgo.setStatus(dataSourceId, event.data.status);\n            console.log(dataSources[dataSourceId].name + \": status=\" + event.data.status);\n            // bubble the message\n            bcChannels[dataSourceId].postMessage(event.data);\n        }\n    }\n\n    timeBroadcastChannel = new BroadcastChannel(timeTopic);\n\n}\n\n/**\n *\n * @param dataSources\n */\nfunction addDataSources(dataSources) {\n    for(let dataSource of dataSources) {\n        addDataSource(dataSource);\n    }\n}\n\nfunction addDataSource(dataSource) {\n    dataSynchronizerAlgo.addDataSource(dataSource);\n    // create a BC to push back the synchronized data into the DATA Stream.\n    bcChannels[dataSource.id] = new BroadcastChannel(DATASOURCE_DATA_TOPIC + dataSource.id);\n\n    if(!(dataSource.id in dataSources)) {\n        dataSources[dataSource.id] = dataSource;\n    }\n}\n\n/**\n *\n * @param dataSources\n */\nasync function removeDataSources(dataSources) {\n    for(let dataSource of dataSources) {\n        await removeDataSource(dataSource);\n    }\n}\n\nasync function removeDataSource(dataSource) {\n    await dataSynchronizerAlgo.removeDataSource(dataSource);\n    // create a BC to push back the synchronized data into the DATA Stream.\n    delete bcChannels[dataSource.id];\n    delete dataSources[dataSource.id];\n}\n\nfunction checkMasterTime() {\n    if(!isDefined(masterTimeInterval)) {\n        startMasterTimeInterval(DataSynchronizer_worker_masterTimeRefreshRate);\n    }\n}\nasync function onEnd() {\n    const masterTime = dataSynchronizerAlgo.getCurrentTimestamp();\n    clearInterval(masterTimeInterval);\n    masterTimeInterval = undefined;\n    // end at this time\n    timeBroadcastChannel.postMessage({\n        timestamp: masterTime,\n        type: EventType.MASTER_TIME\n    });\n}\n\nasync function onStart() {\n    // checkMasterTime();\n}\n\nasync function onData(dataSourceId, dataBlock) {\n    if((version === -1 && (isDefined(DataSynchronizer_worker_lastData) ) && dataBlock.version === DataSynchronizer_worker_lastData.dataBlock.version)){\n        return;\n    }\n\n    version = dataBlock.version;\n    DataSynchronizer_worker_lastData = {\n        dataSourceId: dataSourceId,\n        dataBlock: dataBlock\n    };\n    bcChannels[dataSourceId].postMessage({\n            values: [dataBlock],\n            dataSourceId:dataSourceId,\n            type: EventType.DATA\n        }\n    );\n}\nself.onclose = function() {\n    dataSynchronizerAlgo.close();\n    console.log(\"Data Synchronizer has been terminated successfully\");\n}\n\nlet DataSynchronizer_worker_masterTime;\nfunction startMasterTimeInterval(masterTimeRefreshRate) {\n    if (!isDefined(masterTimeInterval)) {\n        masterTimeInterval = setInterval(() => {\n            DataSynchronizer_worker_masterTime = dataSynchronizerAlgo.getCurrentTimestamp();\n            if (isDefined(DataSynchronizer_worker_masterTime)) {\n                timeBroadcastChannel.postMessage({\n                    timestamp: DataSynchronizer_worker_masterTime,\n                    type: EventType.MASTER_TIME\n                });\n            }\n\n            // check version\n            if (!isDefined(DataSynchronizer_worker_lastData) || version !== DataSynchronizer_worker_lastData.dataBlock.version || version === -1) {\n                return;\n            }\n            cTime = DataSynchronizer_worker_lastData.dataBlock.data.timestamp;\n            cId = DataSynchronizer_worker_lastData.dataSourceId;\n\n            if ((cTime !== -1 && lastTime === -1) || (lastTime !== -1 && cTime !== lastTime)) { // does not send the same data twice\n                timeBroadcastChannel.postMessage({\n                    timestamp: cTime,\n                    dataSourceId: cId,\n                    type: EventType.LAST_TIME\n                });\n            }\n            lastTime = cTime;\n        }, masterTimeRefreshRate);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS9Db25zdGFudHMuanM/YjliMSIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS9ldmVudC9FdmVudFR5cGUuanM/OWUzMCIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS91dGlscy9VdGlscy5qcz9mODdlIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL2RhdGFzb3VyY2UvTW9kZS5qcz80ZTI1Iiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL2Nvbm5lY3Rvci9TdGF0dXMuanM/YTU4NyIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS90aW1lc3luYy9EYXRhU3luY2hyb25pemVyQWxnby5qcz9hZGNhIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL3RpbWVzeW5jL0RhdGFTeW5jaHJvbml6ZXJBbGdvLnJlcGxheS5qcz85MjExIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL3RpbWVzeW5jL0RhdGFTeW5jaHJvbml6ZXJBbGdvLnJlYWx0aW1lLmpzP2ZlODkiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvdGltZXN5bmMvRGF0YVN5bmNocm9uaXplci53b3JrZXIuanM/NWYzMCJdLCJuYW1lcyI6WyJEQVRBX1NZTkNIUk9OSVpFUl9UT1BJQyIsIlRJTUVfU1lOQ0hST05JWkVSX1RPUElDIiwiREFUQVNPVVJDRV9EQVRBX1RPUElDIiwiREFUQVNPVVJDRV9USU1FX1RPUElDIiwiRkZNUEVHX1ZJRVdfREVDT0RFX1RPUElDIiwiTUFHSUNfRU5EX1BBQ0tFVCIsIkV2ZW50VHlwZSIsIkRBVEEiLCJMQVNUX1RJTUUiLCJNQVNURVJfVElNRSIsIlNUQVRVUyIsIlRJTUVfQ0hBTkdFRCIsIk1BWF9MT05HIiwiTWF0aCIsInBvdyIsImlzRGVmaW5lZCIsInYiLCJoYXNWYWx1ZSIsImhleDJyZ2IiLCJoZXgiLCJyIiwiZyIsImIiLCJtYXRjaCIsIm1hcCIsIngiLCJwYXJzZUludCIsImhhc1R5cGUiLCJleHBlY3RlZFR5cGUiLCJoYXNWYWwiLCJpc09iamVjdCIsImxldE5hbWUiLCJpc0FycmF5IiwiQXJyYXkiLCJpc0Z1bmN0aW9uIiwiYXNzZXJ0RGVmaW5lZCIsImFzc2VydFRydWUiLCJhc3NlcnRUeXBlIiwiYXNzZXJ0Qm9vbGVhbiIsImFzc2VydFN0cmluZyIsImFzc2VydE51bWJlciIsImFzc2VydFBvc2l0aXZlIiwiYXNzZXJ0T2JqZWN0IiwiYXNzZXJ0QXJyYXkiLCJhc3NlcnRGdW5jdGlvbiIsImFzc2VydEhhc1ZhbHVlIiwicmFuZG9tVVVJRCIsInJlcGxhY2UiLCJjIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdGFtcFVVSUQiLCJvYmoiLCJfb3NoX2lkIiwiUGFyc2VCeXRlcyIsImJ1ZmZlciIsIm9mZnNldCIsInR5cGUiLCJ2aWV3IiwiRGF0YVZpZXciLCJ0eXBlTWFwIiwiZG91YmxlIiwidmFsIiwiZ2V0RmxvYXQ2NCIsImJ5dGVzIiwiZmxvYXQ2NCIsImZsb2F0MzIiLCJnZXRGbG9hdDMyIiwic2lnbmVkQnl0ZSIsImdldEludDgiLCJzaWduZWRJbnQiLCJnZXRJbnQzMiIsInNpZ25lZFNob3J0IiwiZ2V0SW50MTYiLCJ1bnNpZ25lZEJ5dGUiLCJnZXRVaW50OCIsInVuc2lnbmVkSW50IiwiZ2V0VWludDMyIiwidW5zaWduZWRTaG9ydCIsImdldFVpbnQxNiIsIlJlYWREYXRhIiwic3RydWN0IiwiZGF0YSIsIm9mZnNldEJ5dGVzIiwiaSIsImZpZWxkcyIsImxlbmd0aCIsImN1cnJGaWVsZFN0cnVjdCIsInJldCIsImNvdW50IiwiaXNOYU4iLCJpZCIsImZpZWxkTmFtZSIsImlkMkZpZWxkTWFwIiwiZmluZEZpZWxkQnlOYW1lIiwiaiIsImZpZWxkIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwicHVzaCIsIkdldFJlc3VsdE9iamVjdCIsInJlc3VsdFN0cnVjdHVyZSIsInJlc3VsdCIsIm5hbWUiLCJpdGVtIiwiayIsImlzT3BlcmEiLCJ3aW5kb3ciLCJvcHIiLCJhZGRvbnMiLCJvcGVyYSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluZGV4T2YiLCJpc0ZpcmVmb3giLCJJbnN0YWxsVHJpZ2dlciIsImlzU2FmYXJpIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiY2FsbCIsIkhUTUxFbGVtZW50IiwiaXNDaHJvbWUiLCJjaHJvbWUiLCJ3ZWJzdG9yZSIsImlzQmxpbmsiLCJDU1MiLCJpc0FycmF5SW50ZXJzZWN0IiwiYSIsImZpbHRlciIsImVsZW1lbnQiLCJpc0VsZW1lbnQiLCJvIiwibm9kZVR5cGUiLCJub2RlTmFtZSIsImlzV2ViV29ya2VyIiwiV29ya2VyIiwidGFrZVNjcmVlblNob3QiLCJkaXYiLCJyZW1vdmVDc3MiLCJjc3MiLCJkaXZDc3MiLCJjbGFzc05hbWUiLCJhZGRDc3MiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVMYXN0Q2hhcklmRXhpc3QiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImVuZHNXaXRoIiwic3Vic3RyaW5nIiwiY2FwaXRhbGl6ZUZpcnN0TGV0dGVyIiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsInJvdW5kSGFsZiIsIm51bSIsInJvdW5kIiwiZGVib3VuY2UiLCJmdW5jIiwid2FpdCIsImltbWVkaWF0ZSIsInRpbWVvdXQiLCJhcmdzIiwiY29udGV4dCIsInRpbWVzdGFtcCIsImxhdGVyIiwibm93IiwiRGF0ZSIsImdldFRpbWUiLCJsYXN0Iiwic2V0VGltZW91dCIsImFwcGx5IiwiYXJndW1lbnRzIiwiY2FsbE5vdyIsInRocm90dGxlIiwibGVhZGluZyIsInRyYWlsaW5nIiwiY3R4IiwicHJldmlvdXMiLCJyZW1haW5pbmciLCJjbGVhclRpbWVvdXQiLCJtZXJnZSIsInRhcmdldCIsInNvdXJjZSIsImtleSIsImtleXMiLCJhc3NpZ24iLCJyZ2JhVG9BcnJheSIsInN0YXJ0SWR4VmFsdWUiLCJlbmRJZHhWYWx1ZSIsInZhbHVlcyIsInN1YnN0ciIsInNwbGl0IiwiTnVtYmVyIiwiTW9kZSIsIlJFUExBWSIsIkJBVENIIiwiUkVBTF9USU1FIiwiU3RhdHVzIiwiQ09OTkVDVElORyIsIkNPTk5FQ1RFRCIsIkRJU0NPTk5FQ1RFRCIsIkZFVENIX1NUQVJURUQiLCJGRVRDSF9FTkRFRCIsIkNMT1NFRCIsIkNMT1NFRF9FUlJPUiIsIkRhdGFTeW5jaHJvbml6ZXJBbGdvIiwiY29uc3RydWN0b3IiLCJkYXRhU291cmNlcyIsInRpbWVyUmVzb2x1dGlvbiIsImRhdGFTb3VyY2VNYXAiLCJ0c1J1biIsImludGVydmFsIiwiZGF0YXNvdXJjZXMiLCJkcyIsImFkZERhdGFTb3VyY2UiLCJyZW1vdmVEYXRhU291cmNlIiwiZGF0YVNvdXJjZUlkIiwiZWx0IiwiZGF0YUJsb2NrcyIsImdldEN1cnJlbnRUaW1lc3RhbXAiLCJwcm9jZXNzRGF0YSIsInRzUmVmIiwiY2xvY2tUaW1lUmVmIiwicGVyZm9ybWFuY2UiLCJjdXJyZW50RHMiLCJjdXJyZW50RHNJZCIsImRhdGFCdWZmZXIiLCJzZXRJbnRlcnZhbCIsImNvbXB1dGVOZXh0RGF0YSIsImNvbnNvbGUiLCJ3YXJuIiwidG9JU09TdHJpbmciLCJyZWZDbG9ja1RpbWUiLCJFcnJvciIsImRhdGFTb3VyY2UiLCJjaGVja1ZlcnNpb24iLCJkYXRhc291cmNlIiwiZGF0YUJsb2NrIiwib25EYXRhIiwic2V0U3RhdHVzIiwic3RhdHVzIiwiY2xvc2UiLCJjbGVhckludGVydmFsIiwibG9nIiwib25TdGFydCIsIkRhdGFTeW5jaHJvbml6ZXJBbGdvUmVwbGF5IiwicmVwbGF5U3BlZWQiLCJzdGFydFRpbWVzdGFtcCIsImVuZFRpbWVzdGFtcCIsImxhc3REYXRhIiwidmVyc2lvbiIsImNoZWNrRW5kIiwiY3VycmVudERzVG9TaGlmdCIsImRDbG9jayIsImRUcyIsInNoaWZ0IiwiY2hlY2tTdGFydCIsIm5iRGF0YXNvdXJjZXNGZXRjaGVkT2siLCJ0b3RhbERhdGFTb3VyY2VzIiwiZGF0YVNvdXJjZUlEIiwib25FbmQiLCJyZXNldCIsInJlc2V0RGF0YVNvdXJjZSIsImRhdGFzb3VyY2VJZCIsIkRhdGFTeW5jaHJvbml6ZXJBbGdvUmVhbHRpbWUiLCJsYXRlbmN5IiwibWF4TGF0ZW5jeSIsIm1pbkxhdGVuY3kiLCJtaW4iLCJ0aW1lT3V0IiwiZENsb2NrQWRqIiwicmVjIiwidGltZWRPdXQiLCJzdGFydEJ1ZmZlcmluZ1RpbWUiXSwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSx1QkFBdUIsR0FBRyxvQkFBaEM7QUFDQSxNQUFNQyx1QkFBdUIsR0FBRyx5QkFBaEM7QUFFQSxNQUFNQyxxQkFBcUIsR0FBRyxrQkFBOUI7QUFDQSxNQUFNQyxxQkFBcUIsR0FBRyxrQkFBOUI7QUFFQSxNQUFNQyx3QkFBd0IsR0FBRyxnQkFBakM7QUFFQSxNQUFNQyxnQkFBZ0IsR0FBRyxjQUF6QixDOztBQ1JBLE1BQU1DLFNBQVMsR0FBRztFQUNyQkMsSUFBSSxFQUFFLE1BRGU7RUFFckJDLFNBQVMsRUFBRSxXQUZVO0VBR3JCQyxXQUFXLEVBQUUsYUFIUTtFQUlyQkMsTUFBTSxFQUFFLFFBSmE7RUFLckJDLFlBQVksRUFBRTtBQUxPLENBQWxCLEM7O0FDQVA7QUFD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O0FBQ2pCOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVMsQ0FBQyxnQ0FBUSxpQkFBaUIsZ0NBQVE7QUFDNUQ7QUFDQTtBQUNBLG9CQUFvQixnQ0FBUTtBQUM1QixrQkFBa0IsZ0NBQVE7O0FBRTFCLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgREFUQV9TWU5DSFJPTklaRVJfVE9QSUMgPSAnZGF0YS1zeW5jaHJvbml6ZXItJztcbmV4cG9ydCBjb25zdCBUSU1FX1NZTkNIUk9OSVpFUl9UT1BJQyA9ICdkYXRhLXN5bmNocm9uaXplci10aW1lLSc7XG5cbmV4cG9ydCBjb25zdCBEQVRBU09VUkNFX0RBVEFfVE9QSUMgPSAnZGF0YXNvdXJjZS1kYXRhLSc7XG5leHBvcnQgY29uc3QgREFUQVNPVVJDRV9USU1FX1RPUElDID0gJ2RhdGFzb3VyY2UtdGltZS0nO1xuXG5leHBvcnQgY29uc3QgRkZNUEVHX1ZJRVdfREVDT0RFX1RPUElDID0gJ2ZmbXBlZy1kZWNvZGUtJztcblxuZXhwb3J0IGNvbnN0IE1BR0lDX0VORF9QQUNLRVQgPSAnbWFnaWMtcGFja2V0JztcbiIsImV4cG9ydCBjb25zdCBFdmVudFR5cGUgPSB7XG4gICAgREFUQTogJ2RhdGEnLFxuICAgIExBU1RfVElNRTogJ2xhc3QtdGltZScsXG4gICAgTUFTVEVSX1RJTUU6ICdtYXN0ZXItdGltZScsXG4gICAgU1RBVFVTOiAnc3RhdHVzJyxcbiAgICBUSU1FX0NIQU5HRUQ6ICd0aW1lLWNoYW5nZWQnXG59O1xuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiBUaGUgY29udGVudHMgb2YgdGhpcyBmaWxlIGFyZSBzdWJqZWN0IHRvIHRoZSBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlLCB2LiAyLjAuXG4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lXG4gYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXG4gU29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLFxuIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZVxuIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHJpZ2h0cyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiBDb3B5cmlnaHQgKEMpIDIwMTUtMjAyMCBNYXRoaWV1IERoYWluYXV0LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG4gQXV0aG9yOiBNYXRoaWV1IERoYWluYXV0IDxtYXRoaWV1LmRoYWluYXV0QGdtYWlsLmNvbT5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiogKiBAbW9kdWxlIFV0aWxzICovXG5cbi8qKiBNYXhpbXVtIHZhbHVlIG9mIGEgbG9uZyAqL1xuZXhwb3J0IGNvbnN0IE1BWF9MT05HID0gTWF0aC5wb3coMiwgNTMpICsgMTtcblxuLyoqXG4gKiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmluZWQodikge1xuICAgIHJldHVybiB0eXBlb2YgKHYpICE9PSAndW5kZWZpbmVkJyAmJiB2ICE9PSBudWxsO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBoYXMgYSB2YWx1ZSxcbiB0aGF0IGlzIGl0IGlzIGRlZmluZWQgYW5kIG5vbiBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNWYWx1ZSh2KSB7XG4gICAgcmV0dXJuIGlzRGVmaW5lZCh2KSAmJiB2ICE9PSBudWxsO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0cmFuc2Zvcm0gaGV4IGNvbG9yIGludG8gUkdCQVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4MnJnYihoZXgpe1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IGhleC5tYXRjaCgvXFx3XFx3L2cpLm1hcCh4ID0+IHBhcnNlSW50KHgsIDE2KSk7XG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbn1cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIG9mIGEgcGFydGljdWxhciB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNUeXBlKHYsIGV4cGVjdGVkVHlwZSkge1xuICAgIGxldCBoYXNWYWwgPSBoYXNWYWx1ZSh2KTtcbiAgICByZXR1cm4gaGFzVmFsICYmIHR5cGVvZiAodikgPT09IGV4cGVjdGVkVHlwZTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGhhc1R5cGUodiwgJ29iamVjdCcsIGxldE5hbWUpO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBhcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheSh2KSB7XG4gICAgcmV0dXJuIGlzRGVmaW5lZCh2KSAmJiBBcnJheS5pc0FycmF5KHYpO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gaGFzVHlwZSh2LCAnZnVuY3Rpb24nLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGRlZmluZWRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgaWYgKCFpc0RlZmluZWQodikpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgZGVmaW5lZFwiO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFRydWUodiwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh2KSB8fCAhdikge1xuICAgICAgICB0aHJvdyBsZXROYW1lO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkIGFuZCBub24tbnVsbFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFR5cGUodiwgZXhwZWN0ZWRUeXBlLCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKHR5cGVvZiAodikgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBiZSBvZiB0eXBlIFwiICsgZXhwZWN0ZWRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgc3RyaW5nXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Qm9vbGVhbih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ2Jvb2xlYW4nLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgc3RyaW5nXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U3RyaW5nKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnc3RyaW5nJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIG51bWJlclxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE51bWJlcih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ251bWJlcicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBudW1iZXJcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRQb3NpdGl2ZSh2LCBsZXROYW1lKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHYsIGxldE5hbWUpO1xuICAgIGlmICh2IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIjtcbiAgICB9XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBvYmplY3RcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRPYmplY3QodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdvYmplY3QnLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIG9iamVjdFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFycmF5KHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgYW4gYXJyYXlcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIGZ1bmN0aW9uXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb24odiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdmdW5jdGlvbicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBhbmQgbm9uLW51bGxcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRIYXNWYWx1ZSh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKCFoYXNWYWx1ZSh2KSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBub3QgYmUgbnVsbFwiO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tVVVJRCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgteHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICBsZXQgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBzdGFtcHMvZW1iZWRzIGEgVVVJRCBpbnRvIGFuIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgVVVJRCBnZW5lcmF0ZWQgZm9yIGl0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFtcFVVSUQob2JqKSB7XG4gICAgb2JqLl9vc2hfaWQgPSBvYmouX29zaF9pZCB8fCByYW5kb21VVUlEKCk7XG4gICAgcmV0dXJuIG9iai5fb3NoX2lkO1xufVxuXG4vL2J1ZmZlciBpcyBhbiBBcnJheUJ1ZmZlciBvYmplY3QsIHRoZSBvZmZzZXQgaWYgc3BlY2lmaWVkIGluIGJ5dGVzLCBhbmQgdGhlIHR5cGUgaXMgYSBzdHJpbmdcbi8vY29ycmVzcG9uZGluZyB0byBhbiBPR0MgZGF0YSB0eXBlLlxuLy9TZWUgaHR0cDovL2RlZi5zZWVncmlkLmNzaXJvLmF1L3Npc3N2b2Mvb2djLWRlZi9yZXNvdXJjZT91cmk9aHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9kZWYvZGF0YVR5cGUvT0dDLzAvXG4vKipcbiAqXG4gKiBAcGFyYW0gYnVmZmVyXG4gKiBAcGFyYW0gb2Zmc2V0XG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFBhcnNlQnl0ZXMoYnVmZmVyLCBvZmZzZXQsIHR5cGUpIHtcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuXG4gICAgLy9Ob3RlOiBUaGVyZSBleGlzdCB0eXBlcyBub3QgbGlzdGVkIGluIHRoZSBtYXAgYmVsb3cgdGhhdCBoYXZlIE9HQyBkZWZpbml0aW9ucywgYnV0IG5vIGFwcHJvcHJpYXRlXG4gICAgLy9tZXRob2RzIG9yIGNvcnJlc3BvbmRpbmcgdHlwZXMgYXZhaWxhYmxlIGZvciBwYXJzaW5nIGluIGphdmFzY3JpcHQuIFRoZXkgYXJlIGZsb2F0MTI4LCBmbG9hdDE2LCBzaWduZWRMb25nLFxuICAgIC8vYW5kIHVuc2lnbmVkTG9uZ1xuICAgIGxldCB0eXBlTWFwID0ge1xuICAgICAgICBkb3VibGU6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEZsb2F0NjQob2Zmc2V0KSwgYnl0ZXM6IDh9O1xuICAgICAgICB9LFxuICAgICAgICBmbG9hdDY0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRGbG9hdDY0KG9mZnNldCksIGJ5dGVzOiA4fTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXQzMjogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0RmxvYXQzMihvZmZzZXQpLCBieXRlczogNH07XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25lZEJ5dGU6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDgob2Zmc2V0KSwgYnl0ZXM6IDF9O1xuICAgICAgICB9LFxuICAgICAgICBzaWduZWRJbnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDMyKG9mZnNldCksIGJ5dGVzOiA0fTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmVkU2hvcnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDE2KG9mZnNldCksIGJ5dGVzOiAyfTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaWduZWRCeXRlOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50OChvZmZzZXQpLCBieXRlczogMX07XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2lnbmVkSW50OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50MzIob2Zmc2V0KSwgYnl0ZXM6IDR9O1xuICAgICAgICB9LFxuICAgICAgICB1bnNpZ25lZFNob3J0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50MTYob2Zmc2V0KSwgYnl0ZXM6IDJ9O1xuICAgICAgICB9LFxuICAgICAgICAvL1RPRE86IHN0cmluZy11dGYtODpcbiAgICB9O1xuICAgIHJldHVybiB0eXBlTWFwW3R5cGVdKG9mZnNldCk7XG59XG5cbi8vVGhpcyBmdW5jdGlvbiByZWN1cnNpdmxleSBpdGVyYXRlcyBvdmVyIHRoZSByZXN1bHRTdHJ1Y3R1cmUgdG8gZmlsbCBpblxuLy92YWx1ZXMgcmVhZCBmcm9tIGRhdGEgd2hpY2ggc2hvdWxkIGJlIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgdGhlIHBheWxvYWQgZnJvbSBhIHdlYnNvY2tldFxuLyoqXG4gKlxuICogQHBhcmFtIHN0cnVjdFxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBvZmZzZXRCeXRlc1xuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlYWREYXRhKHN0cnVjdCwgZGF0YSwgb2Zmc2V0Qnl0ZXMpIHtcbiAgICBsZXQgb2Zmc2V0ID0gb2Zmc2V0Qnl0ZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJ1Y3QuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjdXJyRmllbGRTdHJ1Y3QgPSBzdHJ1Y3QuZmllbGRzW2ldO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKGN1cnJGaWVsZFN0cnVjdC50eXBlKSAmJiBjdXJyRmllbGRTdHJ1Y3QudHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJldCA9IFBhcnNlQnl0ZXMoZGF0YSwgb2Zmc2V0LCBjdXJyRmllbGRTdHJ1Y3QudHlwZSk7XG4gICAgICAgICAgICBjdXJyRmllbGRTdHJ1Y3QudmFsID0gcmV0LnZhbDtcbiAgICAgICAgICAgIG9mZnNldCArPSByZXQuYnl0ZXM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWZpbmVkKGN1cnJGaWVsZFN0cnVjdC5jb3VudCkgJiYgY3VyckZpZWxkU3RydWN0LmNvdW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvL2NoZWNrIGlmIGNvdW50IGlzIGEgcmVmZXJlbmNlIHRvIGFub3RoZXIgbGV0aWFibGVcbiAgICAgICAgICAgIGlmIChpc05hTihjdXJyRmllbGRTdHJ1Y3QuY291bnQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gY3VyckZpZWxkU3RydWN0LmNvdW50O1xuICAgICAgICAgICAgICAgIGxldCBmaWVsZE5hbWUgPSBzdHJ1Y3QuaWQyRmllbGRNYXBbaWRdO1xuICAgICAgICAgICAgICAgIGN1cnJGaWVsZFN0cnVjdC5jb3VudCA9IHN0cnVjdC5maW5kRmllbGRCeU5hbWUoZmllbGROYW1lKS52YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGN1cnJGaWVsZFN0cnVjdC5jb3VudDsgYysrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjdXJyRmllbGRTdHJ1Y3QuZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY3VyckZpZWxkU3RydWN0LmZpZWxkc1tqXSkpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBSZWFkRGF0YShmaWVsZCwgZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY3VyckZpZWxkU3RydWN0LnZhbC5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHJlc3VsdFN0cnVjdHVyZVxuICogQHJldHVybiB7e319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBHZXRSZXN1bHRPYmplY3QocmVzdWx0U3RydWN0dXJlKSB7XG4gICAgLy9UT0RPOiBoYW5kbGUgY2FzZXMgZm9yIG5lc3RlZCBhcnJheXMgLyBtYXRyaXggZGF0YSB0eXBlc1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLmNvdW50KSkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0ubmFtZV0gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5jb3VudDsgYysrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtW3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkc1trXS5uYW1lXSA9IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkc1trXS52YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLm5hbWVdLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5uYW1lXSA9IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09wZXJhKCkge1xuICAgIHJldHVybiAoISF3aW5kb3cub3ByICYmICEhb3ByLmFkZG9ucykgfHwgISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDA7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpcmVmb3goKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdy5IVE1MRWxlbWVudCkuaW5kZXhPZignQ29uc3RydWN0b3InKSA+IDA7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Nocm9tZSgpIHtcbiAgICByZXR1cm4gISF3aW5kb3cuY2hyb21lICYmICEhd2luZG93LmNocm9tZS53ZWJzdG9yZTtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Knxib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCbGluaygpIHtcbiAgICByZXR1cm4gKGlzQ2hyb21lIHx8IGlzT3BlcmEpICYmICEhd2luZG93LkNTUztcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGFcbiAqIEBwYXJhbSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUludGVyc2VjdChhLCBiKSB7XG4gICAgcmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBiLmluZGV4T2YoZWxlbWVudCkgPiAtMTtcbiAgICB9KS5sZW5ndGggPiAwO1xufVxuXG5cbi8qKlxuICpcbiAqIEBwYXJhbSBvXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50KG8pIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIEhUTUxFbGVtZW50ID09PSBcIm9iamVjdFwiID8gbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogLy9ET00yXG4gICAgICAgIG8gJiYgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgbyAhPT0gbnVsbCAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSBcInN0cmluZ1wiXG4gICAgKTtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzV2ViV29ya2VyKCkge1xuICAgIHJldHVybiBpc0RlZmluZWQoV29ya2VyKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGRpdlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFrZVNjcmVlblNob3QoZGl2KSB7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY3NzIGNsYXNzIGZyb20gYSB0aGUgZGl2IGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIGRpdiB0aGUgZGl2IHRvIHJlbW92ZSB0aGUgY2xhc3MgZnJvbVxuICogQHBhcmFtIGNzcyB0aGUgY3NzIGNsYXNzIHRvIHJlbW92ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ3NzKGRpdiwgY3NzKSB7XG4gICAgbGV0IGRpdkNzcyA9IGRpdi5jbGFzc05hbWU7XG4gICAgY3NzID0gZGl2Q3NzLnJlcGxhY2UoY3NzLCBcIlwiKTtcbiAgICBkaXYuY2xhc3NOYW1lID0gY3NzO1xufVxuXG5cbi8qKlxuICogQWRkIGEgY3NzIGNsYXNzIHRvIGEgdGhlIGRpdiBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSBkaXYgdGhlIGRpdiB0byBhZGQgdGhlIGNsYXNzIHRvXG4gKiBAcGFyYW0gY3NzIHRoZSBjc3MgY2xhc3MgdG8gYWRkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDc3MoZGl2LCBjc3MpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGl2LmNsYXNzTmFtZSArIFwiIFwiICsgY3NzKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBsYXN0IGNoYXJhY3RlciBvZiBhIHtzdHJpbmd9IG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBpbnB1dCB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUgd2l0aG91dCB0aGUgbGFzdCBjaGFyYWN0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUxhc3RDaGFySWZFeGlzdCh2YWx1ZSkge1xuICAgIGlmICghaXNEZWZpbmVkKHVuZGVmaW5lZCkgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwIHx8ICF2YWx1ZS5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG59XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSB0aGUgZmlyc3QgbGV0dGVyIG9mIGEgZ2l2ZW4gc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gdGhlIGlucHV0IHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gdGhlIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gIGNhcGl0YWxpemVGaXJzdExldHRlcihzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59XG5cbi8qKlxuICogUm91bmQgb2ZmIG51bWJlciB0byBuZWFyZXN0IDAuNVxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSAtIFRoZSBudW1iZXIgdG8gcm91bmQgb2ZmXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByb3VuZGVkIG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmRIYWxmKG51bSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSoyKS8yO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLFxuICogd2lsbCBub3QgYmUgZXhlY3V0ZWQuIFRoZSBmdW5jdGlvbiB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgd2hlblxuICogaXQgd2lsbCBzdG9wIGJlaW5nIGNhbGxlZCBmb3IgbW9yZSB0aGFuIE4gbWlsbGlzZWNvbmRzLlxuICogSWYgdGhlIGBpbW1lZGlhdGVgIHBhcmFtZXRlciBpcyB0cnVlLCB0aGVuIHRoZSBmdW5jdGlvblxuICogd2lsbCBiZSBleGVjdXRlZCBhdCB0aGUgZmlyc3QgY2FsbCBpbnN0ZWFkIG9mIHRoZSBsYXN0LlxuICogUGFyYW1ldGVycyA6XG4gKiAtIGZ1bmM6IHRoZSBmdW5jdGlvbiB0byBgZGVib3VuY2VyYC5cbiAqIC0gd2FpdDogdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgKE4pIHRvIHdhaXQgYmVmb3JlXG4gKiBjYWxsIGZ1bmMoKVxuICogLSBpbW1lZGlhdGUgKG9wdGlvbmFsKTogQ2FsbCBmdW5jKCkgYXQgdGhlIGZpcnN0IGludm9jYXRpb25cbiAqIGluc3RlYWQgb2YgdGhlIGxhc3Qgb25lIChEZWZhdWx0IGZhbHNlKVxuICogLSBjb250ZXh0IChvcHRpb25hbCk6IHRoZSBjb250ZXh0IGluIHdoaWNoIHRvIGNhbGwgZnVuYygpXG4gKiAodGhpcyBieSBkZWZhdWx0KVxuICovXG5cbi8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3Rcbi8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3Jcbi8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbGFzdCA9IG5vdyAtIHRpbWVzdGFtcDtcblxuICAgICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgbGVhZGluZywgdHJhaWxpbmcsIGNvbnRleHQpIHtcbiAgICB2YXIgY3R4LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByZXZpb3VzID0gbmV3IERhdGU7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZTtcbiAgICAgICAgaWYgKCFwcmV2aW91cyAmJiAhbGVhZGluZykgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgICAgY3R4ID0gY29udGV4dCB8fCB0aGlzO1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgdHJhaWxpbmcpIHtcbiAgICAgICAgICAgIC8vIFNpbm9uIG9uIHPigJllbmRvcnQgcGVuZGFudCBsZSB0ZW1wcyByZXN0YW50XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2UgKHRhcmdldCwgc291cmNlKSB7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGBzb3VyY2VgIHByb3BlcnRpZXMgYW5kIGlmIGFuIGBPYmplY3RgIHNldCBwcm9wZXJ0eSB0byBtZXJnZSBvZiBgdGFyZ2V0YCBhbmQgYHNvdXJjZWAgcHJvcGVydGllc1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNvdXJjZSkpIHtcbiAgICAgICAgaWYgKHNvdXJjZVtrZXldIGluc3RhbmNlb2YgT2JqZWN0ICYmIGtleSBpbiB0YXJnZXQpIE9iamVjdC5hc3NpZ24oc291cmNlW2tleV0sIG1lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSkpXG4gICAgfVxuXG4gICAgLy8gSm9pbiBgdGFyZ2V0YCBhbmQgbW9kaWZpZWQgYHNvdXJjZWBcbiAgICBPYmplY3QuYXNzaWduKHRhcmdldCB8fCB7fSwgc291cmNlKVxuICAgIHJldHVybiB0YXJnZXRcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2JhVG9BcnJheShzdHIpIHtcbiAgICBsZXQgc3RhcnRJZHhWYWx1ZSA9IHN0ci5pbmRleE9mKCcoJykgKyAxO1xuICAgIGxldCBlbmRJZHhWYWx1ZSA9IHN0ci5pbmRleE9mKCcpJyk7XG4gICAgbGV0IHZhbHVlcyA9IHN0ci5zdWJzdHIoc3RhcnRJZHhWYWx1ZSwgZW5kSWR4VmFsdWUtc3RhcnRJZHhWYWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlcy5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xufVxuIiwiLyoqXG4gKiBFbnVtIGZvciBkYXRhc291cmNlIG1vZGUuXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHt7bmFtZTogc3RyaW5nfX1cbiAqL1xuZXhwb3J0IGNvbnN0IE1vZGUgPSB7XG4gICAgUkVQTEFZOiBcInJlcGxheVwiLFxuICAgIEJBVENIOiAgXCJiYXRjaFwiLFxuICAgIFJFQUxfVElNRTogXCJyZWFsVGltZVwiXG59O1xuIiwiLyoqXG4gKiBFbnVtIGZvciBjb25uZWN0aW9uIHN0YXR1cy5cbiAqIEByZWFkb25seVxuICogQGVudW0ge3tuYW1lOiBzdHJpbmd9fVxuICovXG5leHBvcnQgY29uc3QgU3RhdHVzID0ge1xuICAgIENPTk5FQ1RJTkc6IFwiY29ubmVjdGluZ1wiLFxuICAgIENPTk5FQ1RFRDogIFwiY29ubmVjdGVkXCIsXG4gICAgRElTQ09OTkVDVEVEOiBcImRpc2Nvbm5lY3RlZFwiLFxuICAgIEZFVENIX1NUQVJURUQ6ICdmZXRjaC1zdGFydCcsXG4gICAgRkVUQ0hfRU5ERUQ6ICdmZXRjaC1lbmQnLFxuICAgIENMT1NFRDogXCJjbG9zZWRcIixcbiAgICBDTE9TRURfRVJST1I6IFwiY2xvc2VkLWVycm9yXCJcbn07XG4iLCJpbXBvcnQge2lzRGVmaW5lZH0gZnJvbSBcIi4uL3V0aWxzL1V0aWxzLmpzXCI7XG5pbXBvcnQge1N0YXR1c30gZnJvbSBcIi4uL2Nvbm5lY3Rvci9TdGF0dXMuanNcIjtcblxuY2xhc3MgRGF0YVN5bmNocm9uaXplckFsZ28ge1xuICAgIGNvbnN0cnVjdG9yKGRhdGFTb3VyY2VzLCB0aW1lclJlc29sdXRpb24gPSA1KSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLnRzUnVuID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRpbWVyUmVzb2x1dGlvbiA9IHRpbWVyUmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YXNvdXJjZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZHMgb2YgZGF0YVNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YVNvdXJjZShkcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVEYXRhU291cmNlKGRhdGFTb3VyY2VJZCkge1xuICAgICAgICB0aGlzLmRhdGFzb3VyY2VzID0gdGhpcy5kYXRhc291cmNlcy5maWx0ZXIoIGVsdCA9PiBlbHQuaWQgIT09IGRhdGFTb3VyY2VJZCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZUlkXTtcbiAgICB9XG5cbiAgICBwdXNoKGRhdGFTb3VyY2VJZCwgZGF0YUJsb2Nrcykge1xuICAgIH1cblxuICAgIGdldEN1cnJlbnRUaW1lc3RhbXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRzUnVuO1xuICAgIH1cblxuICAgIHByb2Nlc3NEYXRhKCkge1xuICAgICAgICBsZXQgdHNSZWYgPSAtMTtcbiAgICAgICAgbGV0IGNsb2NrVGltZVJlZiA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgIC8vIGdldCByZWZlcmVuY2Ugc3RhcnQgdGltZXN0YW1wXG4gICAgICAgIC8vIHRoZSByZWZlcmVuY2Ugc3RhcnQgdGltZXN0YW1wIHNob3VsZCB0aGUgb2xkZXN0IG9uZVxuICAgICAgICBsZXQgY3VycmVudERzO1xuICAgICAgICBmb3IgKGxldCBjdXJyZW50RHNJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGN1cnJlbnREcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtjdXJyZW50RHNJZF07XG4gICAgICAgICAgICBpZiAoY3VycmVudERzLmRhdGFCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRzUmVmID0gKHRzUmVmID09PSAtMSB8fCBjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS5kYXRhLnRpbWVzdGFtcCA8IHRzUmVmKSA/IGN1cnJlbnREcy5kYXRhQnVmZmVyWzBdLmRhdGEudGltZXN0YW1wIDpcbiAgICAgICAgICAgICAgICAgICAgdHNSZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgLy8gMSkgcmV0dXJuIHRoZSBvbGRlc3QgZGF0YSBpZiBhbnlcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbXB1dGVOZXh0RGF0YSh0c1JlZiwgY2xvY2tUaW1lUmVmKSkgO1xuXG4gICAgICAgIH0sIHRoaXMudGltZXJSZXNvbHV0aW9uKTtcbiAgICAgICAgY29uc29sZS53YXJuKGBTdGFydGVkIFJlcGxheSBBbGdvcml0aG0gd2l0aCB0c1JlZj0ke25ldyBEYXRlKHRzUmVmKS50b0lTT1N0cmluZygpfWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIG5leHQgZGF0YSBpZiBhbnkuIFdlIHJldHVybiBvbmx5IDEgdmFsdWUgZm9yIHRoaXMgaXRlcmF0aW9uLiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgdmFsdWVzIHRvIHJldHVybixcbiAgICAgKiB3ZSByZXR1cm4gb25seSB0aGUgb2xkZXN0IG9uZS5cbiAgICAgKiBAcGFyYW0gdHNSZWYgLSB0aGUgdGltZXN0YW1wIG9mIHRoZSBmaXJzdCBkYXRhXG4gICAgICogQHBhcmFtIHJlZkNsb2NrVGltZSAtIHRoZSBhYnNvbHV0ZSBkaWZmIHRpbWUgcmVhbGx5IHNwZW50XG4gICAgICovXG4gICAgY29tcHV0ZU5leHREYXRhKHRzUmVmLCByZWZDbG9ja1RpbWUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Nob3VsZCBiZSBvdmVycmlkZGVuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGFTb3VyY2UgdG8gYmUgc3luY2hyb25pemVkXG4gICAgICogQHBhcmFtIHtEYXRhc291cmNlfSBkYXRhU291cmNlIC0gdGhlIGRhdGFTb3VyY2UgdG8gc3luY2hyb25pemVcbiAgICAgKi9cbiAgICBhZGREYXRhU291cmNlKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Nob3VsZCBiZSBvdmVycmlkZGVuJyk7XG4gICAgfVxuXG4gICAgY2hlY2tWZXJzaW9uKGRhdGFzb3VyY2UsIGRhdGFCbG9jaykge1xuICAgICAgICB0aHJvdyBFcnJvcignU2hvdWxkIGJlIG92ZXJyaWRkZW4nKTtcbiAgICB9XG5cbiAgICBvbkRhdGEoZGF0YVNvdXJjZUlkLCBkYXRhQmxvY2spIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGRhdGFTb3VyY2Ugc3RhdHVzXG4gICAgICogQHBhcmFtIHtTdGF0dXN9IHN0YXR1cyAtIHRoZSBuZXcgc3RhdHVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFTb3VyY2VJZCAtIHRoZSBjb3JyZXNwb25kaW5nIGRhdGFTb3VyY2UgaWRcbiAgICAgKi9cbiAgICBzZXRTdGF0dXMoZGF0YVNvdXJjZUlkLCBzdGF0dXMpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Nob3VsZCBiZSBvdmVycmlkZGVuJyk7XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5pbnRlcnZhbCkpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRGF0YSBzeW5jaHJvbml6ZXIgdGVybWluYXRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgfVxuXG4gICAgb25TdGFydCgpICB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhU3luY2hyb25pemVyQWxnbztcbiIsImltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vdXRpbHMvVXRpbHMuanNcIjtcbmltcG9ydCB7U3RhdHVzfSBmcm9tIFwiLi4vY29ubmVjdG9yL1N0YXR1cy5qc1wiO1xuaW1wb3J0IERhdGFTeW5jaHJvbml6ZXJBbGdvIGZyb20gXCIuL0RhdGFTeW5jaHJvbml6ZXJBbGdvXCI7XG5cbmNsYXNzIERhdGFTeW5jaHJvbml6ZXJBbGdvUmVwbGF5IGV4dGVuZHMgRGF0YVN5bmNocm9uaXplckFsZ28ge1xuICAgIGNvbnN0cnVjdG9yKGRhdGFTb3VyY2VzLCByZXBsYXlTcGVlZCA9IDEsIHN0YXJ0VGltZXN0YW1wLCBlbmRUaW1lc3RhbXAsIHRpbWVyUmVzb2x1dGlvbiA9IDUpIHtcbiAgICAgICAgc3VwZXIoZGF0YVNvdXJjZXMscmVwbGF5U3BlZWQsdGltZXJSZXNvbHV0aW9uKTtcbiAgICAgICAgdGhpcy5yZXBsYXlTcGVlZCA9IHJlcGxheVNwZWVkO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZXN0YW1wID0gc3RhcnRUaW1lc3RhbXA7XG4gICAgICAgIHRoaXMuZW5kVGltZXN0YW1wID0gZW5kVGltZXN0YW1wO1xuICAgIH1cblxuICAgIHB1c2goZGF0YVNvdXJjZUlkLCBkYXRhQmxvY2tzKSB7XG4gICAgICAgIGlmKGRhdGFCbG9ja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlSWRdO1xuICAgICAgICBjb25zdCBsYXN0RGF0YSA9IGRhdGFCbG9ja3NbZGF0YUJsb2Nrcy5sZW5ndGgtMV07XG4gICAgICAgIGlmICghdGhpcy5jaGVja1ZlcnNpb24oZHMsIGxhc3REYXRhKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbRGF0YVN5bmNocm9uaXplcl0gaW5jb21wYXRpYmxlIHZlcnNpb24gJHtkcy52ZXJzaW9ufSB+ICR7bGFzdERhdGEudmVyc2lvbn0sIHNraXBwaW5nIGRhdGFgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkcy5kYXRhQnVmZmVyLnB1c2goLi4uZGF0YUJsb2Nrcyk7XG4gICAgfVxuXG4gICAgcHJvY2Vzc0RhdGEoKSB7XG4gICAgICAgIGxldCBjbG9ja1RpbWVSZWYgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgLy8gMSkgcmV0dXJuIHRoZSBvbGRlc3QgZGF0YSBpZiBhbnlcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbXB1dGVOZXh0RGF0YSh0aGlzLnN0YXJ0VGltZXN0YW1wLCBjbG9ja1RpbWVSZWYpKSB7fVxuICAgICAgICAgICAgdGhpcy5jaGVja0VuZCgpO1xuICAgICAgICB9LCB0aGlzLnRpbWVyUmVzb2x1dGlvbik7XG4gICAgICAgIGNvbnNvbGUud2FybihgU3RhcnRlZCBSZXBsYXkgQWxnb3JpdGhtIHdpdGggdHNSZWY9JHtuZXcgRGF0ZSh0aGlzLnN0YXJ0VGltZXN0YW1wKS50b0lTT1N0cmluZygpfWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIG5leHQgZGF0YSBpZiBhbnkuIFdlIHJldHVybiBvbmx5IDEgdmFsdWUgZm9yIHRoaXMgaXRlcmF0aW9uLiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgdmFsdWVzIHRvIHJldHVybixcbiAgICAgKiB3ZSByZXR1cm4gb25seSB0aGUgb2xkZXN0IG9uZS5cbiAgICAgKiBAcGFyYW0gdHNSZWYgLSB0aGUgdGltZXN0YW1wIG9mIHRoZSBmaXJzdCBkYXRhXG4gICAgICogQHBhcmFtIHJlZkNsb2NrVGltZSAtIHRoZSBhYnNvbHV0ZSBkaWZmIHRpbWUgcmVhbGx5IHNwZW50XG4gICAgICovXG4gICAgY29tcHV0ZU5leHREYXRhKHRzUmVmLCByZWZDbG9ja1RpbWUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnREcztcbiAgICAgICAgbGV0IGN1cnJlbnREc1RvU2hpZnQgPSBudWxsO1xuXG4gICAgICAgIGNvbnN0IGRDbG9jayA9IChwZXJmb3JtYW5jZS5ub3coKSAtIHJlZkNsb2NrVGltZSkgKiB0aGlzLnJlcGxheVNwZWVkO1xuICAgICAgICB0aGlzLnRzUnVuID0gdHNSZWYgKyBkQ2xvY2s7XG4gICAgICAgIC8vIGNvbXB1dGUgbmV4dCBkYXRhIHRvIHJldHVyblxuICAgICAgICBmb3IgKGxldCBjdXJyZW50RHNJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGN1cnJlbnREcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtjdXJyZW50RHNJZF07XG4gICAgICAgICAgICBpZiAoY3VycmVudERzLmRhdGFCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRUcyA9IChjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS5kYXRhLnRpbWVzdGFtcCAtIHRzUmVmKTtcbiAgICAgICAgICAgICAgICAvLyB3ZSB1c2UgYW4gaW50ZXJtZWRpYXRlIG9iamVjdCB0byBzdG9yZSB0aGUgZGF0YSB0byBzaGlmdCBiZWNhdXNlIHdlIHdhbnQgdG8gcmV0dXJuIHRoZSBvbGRlc3Qgb25lXG4gICAgICAgICAgICAgICAgLy8gb25seVxuICAgICAgICAgICAgICAgIGlmIChkVHMgPD0gZENsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG90aGVyIG9uZSB0byBjb21wYXJlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RHNUb1NoaWZ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHNUb1NoaWZ0ID0gY3VycmVudERzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFrZSB0aGUgb2xkZXN0IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREc1RvU2hpZnQgPSAoY3VycmVudERzVG9TaGlmdC5kYXRhQnVmZmVyWzBdLmRhdGEudGltZXN0YW1wIDwgY3VycmVudERzLmRhdGFCdWZmZXJbMF0uZGF0YS50aW1lc3RhbXApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHNUb1NoaWZ0IDogY3VycmVudERzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluYWxseSBwb3AgdGhlIGRhdGEgZnJvbSBEUyBxdWV1ZVxuICAgICAgICBpZiAoY3VycmVudERzVG9TaGlmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGEoY3VycmVudERzVG9TaGlmdC5pZCwgY3VycmVudERzVG9TaGlmdC5kYXRhQnVmZmVyLnNoaWZ0KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhU291cmNlIHRvIGJlIHN5bmNocm9uaXplZFxuICAgICAqIEBwYXJhbSB7RGF0YXNvdXJjZX0gZGF0YVNvdXJjZSAtIHRoZSBkYXRhU291cmNlIHRvIHN5bmNocm9uaXplXG4gICAgICovXG4gICAgYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlLmlkXSA9IHtcbiAgICAgICAgICAgIGRhdGFCdWZmZXI6IFtdLFxuICAgICAgICAgICAgaWQ6IGRhdGFTb3VyY2UuaWQsXG4gICAgICAgICAgICBuYW1lOiBkYXRhU291cmNlLm5hbWUgfHwgZGF0YVNvdXJjZS5pZCxcbiAgICAgICAgICAgIHN0YXR1czogU3RhdHVzLkRJU0NPTk5FQ1RFRCwgLy9NRUFOSU5HIEVuYWJsZWQsIDAgPSBEaXNhYmxlZFxuICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGF0YXNvdXJjZXMucHVzaChkYXRhU291cmNlKTtcbiAgICB9XG5cbiAgICBjaGVja1ZlcnNpb24oZGF0YXNvdXJjZSwgZGF0YUJsb2NrKSB7XG4gICAgICAgIGlmKCFpc0RlZmluZWQoZGF0YXNvdXJjZS52ZXJzaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZihkYXRhc291cmNlLnZlcnNpb24gIT09IGRhdGFCbG9jay52ZXJzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGRhdGFTb3VyY2Ugc3RhdHVzXG4gICAgICogQHBhcmFtIHtTdGF0dXN9IHN0YXR1cyAtIHRoZSBuZXcgc3RhdHVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFTb3VyY2VJZCAtIHRoZSBjb3JyZXNwb25kaW5nIGRhdGFTb3VyY2UgaWRcbiAgICAgKi9cbiAgICBzZXRTdGF0dXMoZGF0YVNvdXJjZUlkLCBzdGF0dXMpIHtcbiAgICAgICAgaWYgKGRhdGFTb3VyY2VJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlSWRdLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihzdGF0dXMrJyBEYXRhU291cmNlICcgKyBkYXRhU291cmNlSWQgKyAnIGZyb20gdGhlIHN5bmNocm9uaXplciAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrU3RhcnQoKTtcbiAgICB9XG5cbiAgICBjaGVja1N0YXJ0KCkge1xuICAgICAgICBpZighaXNEZWZpbmVkKHRoaXMuaW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICBsZXQgbmJEYXRhc291cmNlc0ZldGNoZWRPayA9IDA7XG4gICAgICAgICAgICBsZXQgdG90YWxEYXRhU291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuZGF0YVNvdXJjZU1hcCkubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IobGV0IGRhdGFTb3VyY2VJRCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZUlEXS5zdGF0dXMgPT09IFN0YXR1cy5GRVRDSF9TVEFSVEVEKSBuYkRhdGFzb3VyY2VzRmV0Y2hlZE9rKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW1N5bmNocm9uaXplcl0gRmV0Y2hlZCAke25iRGF0YXNvdXJjZXNGZXRjaGVkT2t9LyR7dG90YWxEYXRhU291cmNlc30gZGF0YXNvdXJjZXNgKTtcbiAgICAgICAgICAgIGlmKG5iRGF0YXNvdXJjZXNGZXRjaGVkT2sgPT09IHRvdGFsRGF0YVNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1N0YXJ0aW5nIFJlcGxheSBBbGdvcml0aG0uLi4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NEYXRhKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVja0VuZCgpIHtcbiAgICAgICAgaWYodGhpcy5nZXRDdXJyZW50VGltZXN0YW1wKCkgPj0gdGhpcy5lbmRUaW1lc3RhbXApIHtcbiAgICAgICAgICAgIHRoaXMub25FbmQoKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnRzUnVuID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zb2xlLmxvZygncmVzZXQgc3luY2hyb25pemVyIGFsZ28nKVxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIGZvciAobGV0IGN1cnJlbnREc0lkIGluIHRoaXMuZGF0YVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldERhdGFTb3VyY2UoY3VycmVudERzSWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXREYXRhU291cmNlKGRhdGFzb3VyY2VJZCkge1xuICAgICAgICBjb25zdCBjdXJyZW50RHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YXNvdXJjZUlkXTtcbiAgICAgICAgY3VycmVudERzLmRhdGFCdWZmZXIgPSBbXTtcbiAgICAgICAgY3VycmVudERzLnN0YXR1cz0gU3RhdHVzLkRJU0NPTk5FQ1RFRDtcbiAgICAgICAgY3VycmVudERzLnZlcnNpb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgb25FbmQoKSB7fVxuICAgIG9uU3RhcnQoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhU3luY2hyb25pemVyQWxnb1JlcGxheTtcbiIsImltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vdXRpbHMvVXRpbHMuanNcIjtcbmltcG9ydCB7U3RhdHVzfSBmcm9tIFwiLi4vY29ubmVjdG9yL1N0YXR1cy5qc1wiO1xuaW1wb3J0IERhdGFTeW5jaHJvbml6ZXJBbGdvIGZyb20gXCIuL0RhdGFTeW5jaHJvbml6ZXJBbGdvXCI7XG5cbmNsYXNzIERhdGFTeW5jaHJvbml6ZXJBbGdvUmVhbHRpbWUgZXh0ZW5kcyBEYXRhU3luY2hyb25pemVyQWxnbyB7XG4gICAgcHVzaChkYXRhU291cmNlSWQsIGRhdGFCbG9ja3MpIHtcbiAgICAgICAgaWYoZGF0YUJsb2Nrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRzID0gdGhpcy5kYXRhU291cmNlTWFwW2RhdGFTb3VyY2VJZF07XG4gICAgICAgIGNvbnN0IGxhc3REYXRhID0gZGF0YUJsb2Nrc1tkYXRhQmxvY2tzLmxlbmd0aC0xXTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrVmVyc2lvbihkcywgbGFzdERhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGF0ZW5jeSA9IDA7XG4gICAgICAgIGlmICh0aGlzLnRzUnVuID4gMCkge1xuICAgICAgICAgICAgbGF0ZW5jeSA9IHRoaXMudHNSdW4gLSBsYXN0RGF0YS5kYXRhLnRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICBkcy5sYXRlbmN5ID0gbGF0ZW5jeSA+IGRzLmxhdGVuY3kgPyBsYXRlbmN5IDogKGRzLmxhdGVuY3kgKyBsYXRlbmN5KSAvIDI7XG5cbiAgICAgICAgZHMuZGF0YUJ1ZmZlci5wdXNoKC4uLmRhdGFCbG9ja3MpO1xuICAgICAgICBpZighaXNEZWZpbmVkKHRoaXMuaW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NEYXRhKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBuZXh0IGRhdGEgaWYgYW55LiBXZSByZXR1cm4gb25seSAxIHZhbHVlIGZvciB0aGlzIGl0ZXJhdGlvbi4gSWYgdGhlcmUgYXJlIG11bHRpcGxlIHZhbHVlcyB0byByZXR1cm4sXG4gICAgICogd2UgcmV0dXJuIG9ubHkgdGhlIG9sZGVzdCBvbmUuXG4gICAgICogQHBhcmFtIHRzUmVmIC0gdGhlIHRpbWVzdGFtcCBvZiB0aGUgZmlyc3QgZGF0YVxuICAgICAqIEBwYXJhbSByZWZDbG9ja1RpbWUgLSB0aGUgYWJzb2x1dGUgZGlmZiB0aW1lIHJlYWxseSBzcGVudFxuICAgICAqL1xuICAgIGNvbXB1dGVOZXh0RGF0YSh0c1JlZiwgcmVmQ2xvY2tUaW1lKSB7XG4gICAgICAgIGxldCBjdXJyZW50RHM7XG4gICAgICAgIGxldCBjdXJyZW50RHNUb1NoaWZ0ID0gbnVsbDtcblxuICAgICAgICAvLyBjb21wdXRlIG1heCBsYXRlbmN5XG4gICAgICAgIGxldCBtYXhMYXRlbmN5ID0gMDtcbiAgICAgICAgbGV0IG1pbkxhdGVuY3kgPSAwO1xuICAgICAgICBmb3IgKGxldCBjdXJyZW50RHNJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGN1cnJlbnREcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtjdXJyZW50RHNJZF07XG4gICAgICAgICAgICBpZiAoY3VycmVudERzLmxhdGVuY3kgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhdGVuY3kgPSBNYXRoLm1pbihjdXJyZW50RHMubGF0ZW5jeSwgY3VycmVudERzLnRpbWVPdXQpO1xuICAgICAgICAgICAgICAgIG1heExhdGVuY3kgPSAobGF0ZW5jeSA+IG1heExhdGVuY3kpID8gbGF0ZW5jeSA6IG1heExhdGVuY3k7XG4gICAgICAgICAgICAgICAgbWluTGF0ZW5jeSA9IChjdXJyZW50RHMubGF0ZW5jeSA8IG1pbkxhdGVuY3kpID8gY3VycmVudERzLmxhdGVuY3kgOiBtaW5MYXRlbmN5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRDbG9jayA9IChwZXJmb3JtYW5jZS5ub3coKSAtIHJlZkNsb2NrVGltZSk7XG4gICAgICAgIHRoaXMudHNSdW4gPSB0c1JlZiArIGRDbG9jaztcbiAgICAgICAgLy8gY29tcHV0ZSBuZXh0IGRhdGEgdG8gcmV0dXJuXG4gICAgICAgIGZvciAobGV0IGN1cnJlbnREc0lkIGluIHRoaXMuZGF0YVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgY3VycmVudERzID0gdGhpcy5kYXRhU291cmNlTWFwW2N1cnJlbnREc0lkXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RHMuZGF0YUJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZFRzID0gKGN1cnJlbnREcy5kYXRhQnVmZmVyWzBdLmRhdGEudGltZXN0YW1wIC0gdHNSZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRDbG9ja0FkaiA9IGRDbG9jayAtIG1heExhdGVuY3k7XG4gICAgICAgICAgICAgICAgLy8gd2UgdXNlIGFuIGludGVybWVkaWF0ZSBvYmplY3QgdG8gc3RvcmUgdGhlIGRhdGEgdG8gc2hpZnQgYmVjYXVzZSB3ZSB3YW50IHRvIHJldHVybiB0aGUgb2xkZXN0IG9uZVxuICAgICAgICAgICAgICAgIC8vIG9ubHlcbiAgICAgICAgICAgICAgICBpZiAoZFRzIDw9IGRDbG9ja0Fkaikge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBvdGhlciBvbmUgdG8gY29tcGFyZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudERzVG9TaGlmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERzVG9TaGlmdCA9IGN1cnJlbnREcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRha2UgdGhlIG9sZGVzdCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHNUb1NoaWZ0ID0gKGN1cnJlbnREc1RvU2hpZnQuZGF0YUJ1ZmZlclswXS5kYXRhLnRpbWVzdGFtcCA8IGN1cnJlbnREcy5kYXRhQnVmZmVyWzBdLmRhdGEudGltZXN0YW1wKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERzVG9TaGlmdCA6IGN1cnJlbnREcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHkgcG9wIHRoZSBkYXRhIGZyb20gRFMgcXVldWVcbiAgICAgICAgaWYgKGN1cnJlbnREc1RvU2hpZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZWMgPSBjdXJyZW50RHNUb1NoaWZ0LmRhdGFCdWZmZXIuc2hpZnQoKTtcblxuICAgICAgICAgICAgLy8gYWRkIGxhdGVuY3kgZmxhZyB0byBkYXRhIHJlY29yZCBiZWZvcmUgd2UgZGlzcGF0Y2ggaXRcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgcmVsYXRpdmUgbGF0ZW5jeSBpbiBtaWxsaXMgY29tcGFyZWQgdG8gdGhlIERTIHdpdGggdGhlIGxvd2VzdCBsYXRlbmN5XG4gICAgICAgICAgICAvLyBzbyBpdCBpcyBhY2N1cmF0ZSBldmVuIGlmIGxvY2FsIGRldmljZSB0aW1lIGlzIG5vdCBzZXQgcHJvcGVybHlcbiAgICAgICAgICAgIHJlY1snQGxhdGVuY3knXSA9IGN1cnJlbnREcy5sYXRlbmN5IC0gbWluTGF0ZW5jeTtcbiAgICAgICAgICAgIHRoaXMub25EYXRhKGN1cnJlbnREc1RvU2hpZnQuaWQsIHJlYyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGFTb3VyY2UgdG8gYmUgc3luY2hyb25pemVkXG4gICAgICogQHBhcmFtIHtEYXRhc291cmNlfSBkYXRhU291cmNlIC0gdGhlIGRhdGFTb3VyY2UgdG8gc3luY2hyb25pemVcbiAgICAgKi9cbiAgICBhZGREYXRhU291cmNlKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlTWFwW2RhdGFTb3VyY2UuaWRdID0ge1xuICAgICAgICAgICAgdGltZU91dDogZGF0YVNvdXJjZS50aW1lT3V0IHx8IDAsXG4gICAgICAgICAgICBkYXRhQnVmZmVyOiBbXSxcbiAgICAgICAgICAgIGlkOiBkYXRhU291cmNlLmlkLFxuICAgICAgICAgICAgdGltZWRPdXQ6IGZhbHNlLFxuICAgICAgICAgICAgbmFtZTogZGF0YVNvdXJjZS5uYW1lIHx8IGRhdGFTb3VyY2UuaWQsXG4gICAgICAgICAgICBsYXRlbmN5OiAwLFxuICAgICAgICAgICAgc3RhdHVzOiBTdGF0dXMuRElTQ09OTkVDVEVELCAvL01FQU5JTkcgRW5hYmxlZCwgMCA9IERpc2FibGVkXG4gICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhc291cmNlcy5wdXNoKGRhdGFTb3VyY2UpO1xuICAgIH1cblxuICAgIGNoZWNrVmVyc2lvbihkYXRhc291cmNlLCBkYXRhQmxvY2spIHtcbiAgICAgICAgaWYoZGF0YXNvdXJjZS5zdGF0dXMgIT09IFN0YXR1cy5ESVNDT05ORUNURUQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYoZGF0YXNvdXJjZS5zdGF0dXMgPT09IFN0YXR1cy5ESVNDT05ORUNURUQgJiYgZGF0YXNvdXJjZS52ZXJzaW9uICE9PSBkYXRhQmxvY2sudmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBkYXRhU291cmNlIHN0YXR1c1xuICAgICAqIEBwYXJhbSB7U3RhdHVzfSBzdGF0dXMgLSB0aGUgbmV3IHN0YXR1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhU291cmNlSWQgLSB0aGUgY29ycmVzcG9uZGluZyBkYXRhU291cmNlIGlkXG4gICAgICovXG4gICAgc2V0U3RhdHVzKGRhdGFTb3VyY2VJZCwgc3RhdHVzKSB7XG4gICAgICAgIGlmIChkYXRhU291cmNlSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZUlkXS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oc3RhdHVzKycgRGF0YVNvdXJjZSAnICsgZGF0YVNvdXJjZUlkICsgJyBmcm9tIHRoZSBzeW5jaHJvbml6ZXIgJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy50c1J1biA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc29sZS5sb2coJ3Jlc2V0IHN5bmNocm9uaXplciBhbGdvJylcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICBmb3IgKGxldCBjdXJyZW50RHNJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXREYXRhU291cmNlKGN1cnJlbnREc0lkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0RGF0YVNvdXJjZShkYXRhc291cmNlSWQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudERzID0gdGhpcy5kYXRhU291cmNlTWFwW2RhdGFzb3VyY2VJZF07XG4gICAgICAgIGN1cnJlbnREcy5kYXRhQnVmZmVyID0gW107XG4gICAgICAgIGN1cnJlbnREcy5zdGFydEJ1ZmZlcmluZ1RpbWUgPSAtMTtcbiAgICAgICAgY3VycmVudERzLmxhdGVuY3k9MDtcbiAgICAgICAgY3VycmVudERzLnN0YXR1cz0gU3RhdHVzLkRJU0NPTk5FQ1RFRDtcbiAgICAgICAgY3VycmVudERzLnZlcnNpb24gPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhU3luY2hyb25pemVyQWxnb1JlYWx0aW1lO1xuIiwiaW1wb3J0IHtEQVRBU09VUkNFX0RBVEFfVE9QSUN9IGZyb20gXCIuLi9Db25zdGFudHMuanNcIjtcbmltcG9ydCB7RXZlbnRUeXBlfSBmcm9tIFwiLi4vZXZlbnQvRXZlbnRUeXBlLmpzXCI7XG5pbXBvcnQge2lzRGVmaW5lZH0gZnJvbSBcIi4uL3V0aWxzL1V0aWxzXCI7XG5pbXBvcnQge01vZGV9IGZyb20gXCIuLi9kYXRhc291cmNlL01vZGVcIjtcbmltcG9ydCBEYXRhU3luY2hyb25pemVyQWxnb1JlcGxheSBmcm9tIFwiLi9EYXRhU3luY2hyb25pemVyQWxnby5yZXBsYXlcIjtcbmltcG9ydCBEYXRhU3luY2hyb25pemVyQWxnb1JlYWx0aW1lIGZyb20gXCIuL0RhdGFTeW5jaHJvbml6ZXJBbGdvLnJlYWx0aW1lLmpzXCI7XG5cbmNvbnN0IGJjQ2hhbm5lbHMgPSB7fTtcbmxldCBkYXRhU3luY2hyb25pemVyQWxnbztcblxubGV0IGluaXQgPSBmYWxzZTtcbmxldCBkYXRhU291cmNlQnJvYWRDYXN0Q2hhbm5lbCA9IG51bGw7XG5sZXQgbGFzdERhdGEgPSB1bmRlZmluZWQ7XG5jb25zdCBkYXRhU291cmNlcyA9IHt9O1xubGV0IHRpbWVCcm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbmxldCB0b3BpY1RpbWU7XG5sZXQgdG9waWNEYXRhO1xubGV0IHJlcGxheVNwZWVkO1xubGV0IG1hc3RlclRpbWVJbnRlcnZhbCA9IHVuZGVmaW5lZDtcbmxldCBjVGltZTtcbmxldCBjSWQ7XG5sZXQgbGFzdFRpbWUgPSAtMTtcbmxldCB2ZXJzaW9uID0gLTE7XG5sZXQgcHJvbWlzZTtcbmxldCBtYXN0ZXJUaW1lUmVmcmVzaFJhdGU7XG5sZXQgc3RhcnRUaW1lc3RhbXA7XG5sZXQgZW5kVGltZXN0YW1wO1xuXG5zZWxmLm9ubWVzc2FnZSA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgIGlmKGlzRGVmaW5lZChwcm9taXNlKSkge1xuICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlID0gaGFuZGxlTWVzc2FnZShldmVudCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHNlbmRSZXNwb25zZSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgICAgIHJlcGxheVNwZWVkID0gZXZlbnQuZGF0YS5yZXBsYXlTcGVlZDtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcCA9IG5ldyBEYXRlKGV2ZW50LmRhdGEuc3RhcnRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgZW5kVGltZXN0YW1wID0gbmV3IERhdGUoZXZlbnQuZGF0YS5lbmRUaW1lKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS5tb2RlID09PSBNb2RlLlJFUExBWSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnbyA9IG5ldyBEYXRhU3luY2hyb25pemVyQWxnb1JlcGxheShcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuZGF0YVNvdXJjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLnJlcGxheVNwZWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLnRpbWVyUmVzb2x1dGlvblxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5vbkVuZCA9IG9uRW5kO1xuICAgICAgICAgICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5vblN0YXJ0ID0gb25TdGFydDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnbyA9IG5ldyBEYXRhU3luY2hyb25pemVyQWxnb1JlYWx0aW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5kYXRhU291cmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEucmVwbGF5U3BlZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLnRpbWVyUmVzb2x1dGlvblxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5vbkRhdGEgPSBvbkRhdGE7XG4gICAgICAgICAgICAgICAgaW5pdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWRkRGF0YVNvdXJjZXMoZXZlbnQuZGF0YS5kYXRhU291cmNlcyk7XG4gICAgICAgICAgICAgICAgdG9waWNEYXRhID0gZXZlbnQuZGF0YS50b3BpY3MuZGF0YTtcbiAgICAgICAgICAgICAgICB0b3BpY1RpbWUgPSBldmVudC5kYXRhLnRvcGljcy50aW1lO1xuICAgICAgICAgICAgICAgIGluaXRCcm9hZGNhc3RDaGFubmVsKHRvcGljRGF0YSwgdG9waWNUaW1lKTtcbiAgICAgICAgICAgICAgICBtYXN0ZXJUaW1lUmVmcmVzaFJhdGUgPSBldmVudC5kYXRhLm1hc3RlclRpbWVSZWZyZXNoUmF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnYWRkJyAmJiBldmVudC5kYXRhLmRhdGFTb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FkZCBkYXRhc291cmNlIHRvIHN5bmNocm9uaXplci4uJylcbiAgICAgICAgICAgICAgICBhZGREYXRhU291cmNlcyhldmVudC5kYXRhLmRhdGFTb3VyY2VzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICBzdGFydE1hc3RlclRpbWVJbnRlcnZhbChtYXN0ZXJUaW1lUmVmcmVzaFJhdGUpO1xuICAgICAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLmNoZWNrU3RhcnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAncmVtb3ZlJyAmJiBldmVudC5kYXRhLmRhdGFTb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlbW92ZSBkYXRhc291cmNlIGZyb20gc3luY2hyb25pemVyLi4nKVxuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZURhdGFTb3VyY2VzKGV2ZW50LmRhdGEuZGF0YVNvdXJjZXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdjdXJyZW50LXRpbWUnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2N1cnJlbnQtdGltZScsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFTeW5jaHJvbml6ZXJBbGdvLmdldEN1cnJlbnRUaW1lc3RhbXAoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRhdGEubWVzc2FnZSA9PT0gJ3Jlc2V0Jykge1xuICAgICAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRhdGEubWVzc2FnZSA9PT0gJ3JlcGxheS1zcGVlZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVN5bmNocm9uaXplckFsZ28gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ucmVwbGF5U3BlZWQgPSBldmVudC5kYXRhLnJlcGxheVNwZWVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAndXBkYXRlLXByb3BlcnRpZXMnKSB7XG4gICAgICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YXNvdXJjZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVN5bmNocm9uaXplckFsZ28gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YXNvdXJjZXMgPSBkYXRhU3luY2hyb25pemVyQWxnby5kYXRhc291cmNlcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcCA9IG5ldyBEYXRlKGV2ZW50LmRhdGEuc3RhcnRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgZW5kVGltZXN0YW1wID0gbmV3IERhdGUoZXZlbnQuZGF0YS5lbmRUaW1lKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS5tb2RlID09PSBNb2RlLlJFUExBWSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnbyA9IG5ldyBEYXRhU3luY2hyb25pemVyQWxnb1JlcGxheShcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFzb3VyY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5yZXBsYXlTcGVlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28udGltZXJSZXNvbHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLm9uRW5kID0gb25FbmQ7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLm9uU3RhcnQgPSBvblN0YXJ0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvID0gbmV3IERhdGFTeW5jaHJvbml6ZXJBbGdvUmVhbHRpbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhc291cmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnRpbWVyUmVzb2x1dGlvblxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLm9uRGF0YSA9IG9uRGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgICAgICBjaGVja01hc3RlclRpbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVN5bmNocm9uaXplckFsZ28gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ucHVzaChldmVudC5kYXRhLmRhdGFTb3VyY2VJZCwgZXZlbnQuZGF0YS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZW5kUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXZlbnQuZGF0YS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWQ6IGV2ZW50LmRhdGEubWVzc2FnZUlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICByZWplY3QoZXgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXNldCgpIHtcbiAgICBjbGVhckludGVydmFsKG1hc3RlclRpbWVJbnRlcnZhbCk7XG4gICAgbWFzdGVyVGltZUludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIHZlcnNpb24gPSAtMTtcbiAgICBpZihkYXRhU3luY2hyb25pemVyQWxnbyAhPT0gbnVsbCkge1xuICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5yZXNldCgpO1xuICAgIH1cbiAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5USU1FX0NIQU5HRURcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRCcm9hZGNhc3RDaGFubmVsKGRhdGFUb3BpYywgdGltZVRvcGljKSB7XG4gICAgY29uc29sZS5sb2coJ2xpc3RlbiBvbiB0b3BpYyAnLGRhdGFUb3BpYylcblxuICAgIGRhdGFTb3VyY2VCcm9hZENhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoZGF0YVRvcGljKTtcbiAgICBkYXRhU291cmNlQnJvYWRDYXN0Q2hhbm5lbC5vbm1lc3NhZ2UgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgY2hlY2tNYXN0ZXJUaW1lKCk7XG4gICAgICAgIGlmKGV2ZW50LmRhdGEudHlwZSA9PT0gRXZlbnRUeXBlLkRBVEEpIHtcbiAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnB1c2goZXZlbnQuZGF0YS5kYXRhU291cmNlSWQsZXZlbnQuZGF0YS52YWx1ZXMpO1xuICAgICAgICB9IGVsc2UgaWYoZXZlbnQuZGF0YS50eXBlID09PSBFdmVudFR5cGUuU1RBVFVTKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhU291cmNlSWQgPSBldmVudC5kYXRhLmRhdGFTb3VyY2VJZDtcbiAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnNldFN0YXR1cyhkYXRhU291cmNlSWQsIGV2ZW50LmRhdGEuc3RhdHVzKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGFTb3VyY2VzW2RhdGFTb3VyY2VJZF0ubmFtZSArIFwiOiBzdGF0dXM9XCIgKyBldmVudC5kYXRhLnN0YXR1cyk7XG4gICAgICAgICAgICAvLyBidWJibGUgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIGJjQ2hhbm5lbHNbZGF0YVNvdXJjZUlkXS5wb3N0TWVzc2FnZShldmVudC5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVCcm9hZGNhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwodGltZVRvcGljKTtcblxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gZGF0YVNvdXJjZXNcbiAqL1xuZnVuY3Rpb24gYWRkRGF0YVNvdXJjZXMoZGF0YVNvdXJjZXMpIHtcbiAgICBmb3IobGV0IGRhdGFTb3VyY2Ugb2YgZGF0YVNvdXJjZXMpIHtcbiAgICAgICAgYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZERhdGFTb3VyY2UoZGF0YVNvdXJjZSkge1xuICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLmFkZERhdGFTb3VyY2UoZGF0YVNvdXJjZSk7XG4gICAgLy8gY3JlYXRlIGEgQkMgdG8gcHVzaCBiYWNrIHRoZSBzeW5jaHJvbml6ZWQgZGF0YSBpbnRvIHRoZSBEQVRBIFN0cmVhbS5cbiAgICBiY0NoYW5uZWxzW2RhdGFTb3VyY2UuaWRdID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoREFUQVNPVVJDRV9EQVRBX1RPUElDICsgZGF0YVNvdXJjZS5pZCk7XG5cbiAgICBpZighKGRhdGFTb3VyY2UuaWQgaW4gZGF0YVNvdXJjZXMpKSB7XG4gICAgICAgIGRhdGFTb3VyY2VzW2RhdGFTb3VyY2UuaWRdID0gZGF0YVNvdXJjZTtcbiAgICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBkYXRhU291cmNlc1xuICovXG5hc3luYyBmdW5jdGlvbiByZW1vdmVEYXRhU291cmNlcyhkYXRhU291cmNlcykge1xuICAgIGZvcihsZXQgZGF0YVNvdXJjZSBvZiBkYXRhU291cmNlcykge1xuICAgICAgICBhd2FpdCByZW1vdmVEYXRhU291cmNlKGRhdGFTb3VyY2UpO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVtb3ZlRGF0YVNvdXJjZShkYXRhU291cmNlKSB7XG4gICAgYXdhaXQgZGF0YVN5bmNocm9uaXplckFsZ28ucmVtb3ZlRGF0YVNvdXJjZShkYXRhU291cmNlKTtcbiAgICAvLyBjcmVhdGUgYSBCQyB0byBwdXNoIGJhY2sgdGhlIHN5bmNocm9uaXplZCBkYXRhIGludG8gdGhlIERBVEEgU3RyZWFtLlxuICAgIGRlbGV0ZSBiY0NoYW5uZWxzW2RhdGFTb3VyY2UuaWRdO1xuICAgIGRlbGV0ZSBkYXRhU291cmNlc1tkYXRhU291cmNlLmlkXTtcbn1cblxuZnVuY3Rpb24gY2hlY2tNYXN0ZXJUaW1lKCkge1xuICAgIGlmKCFpc0RlZmluZWQobWFzdGVyVGltZUludGVydmFsKSkge1xuICAgICAgICBzdGFydE1hc3RlclRpbWVJbnRlcnZhbChtYXN0ZXJUaW1lUmVmcmVzaFJhdGUpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIG9uRW5kKCkge1xuICAgIGNvbnN0IG1hc3RlclRpbWUgPSBkYXRhU3luY2hyb25pemVyQWxnby5nZXRDdXJyZW50VGltZXN0YW1wKCk7XG4gICAgY2xlYXJJbnRlcnZhbChtYXN0ZXJUaW1lSW50ZXJ2YWwpO1xuICAgIG1hc3RlclRpbWVJbnRlcnZhbCA9IHVuZGVmaW5lZDtcbiAgICAvLyBlbmQgYXQgdGhpcyB0aW1lXG4gICAgdGltZUJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0aW1lc3RhbXA6IG1hc3RlclRpbWUsXG4gICAgICAgIHR5cGU6IEV2ZW50VHlwZS5NQVNURVJfVElNRVxuICAgIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBvblN0YXJ0KCkge1xuICAgIC8vIGNoZWNrTWFzdGVyVGltZSgpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBvbkRhdGEoZGF0YVNvdXJjZUlkLCBkYXRhQmxvY2spIHtcbiAgICBpZigodmVyc2lvbiA9PT0gLTEgJiYgKGlzRGVmaW5lZChsYXN0RGF0YSkgKSAmJiBkYXRhQmxvY2sudmVyc2lvbiA9PT0gbGFzdERhdGEuZGF0YUJsb2NrLnZlcnNpb24pKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZlcnNpb24gPSBkYXRhQmxvY2sudmVyc2lvbjtcbiAgICBsYXN0RGF0YSA9IHtcbiAgICAgICAgZGF0YVNvdXJjZUlkOiBkYXRhU291cmNlSWQsXG4gICAgICAgIGRhdGFCbG9jazogZGF0YUJsb2NrXG4gICAgfTtcbiAgICBiY0NoYW5uZWxzW2RhdGFTb3VyY2VJZF0ucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdmFsdWVzOiBbZGF0YUJsb2NrXSxcbiAgICAgICAgICAgIGRhdGFTb3VyY2VJZDpkYXRhU291cmNlSWQsXG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuREFUQVxuICAgICAgICB9XG4gICAgKTtcbn1cbnNlbGYub25jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLmNsb3NlKCk7XG4gICAgY29uc29sZS5sb2coXCJEYXRhIFN5bmNocm9uaXplciBoYXMgYmVlbiB0ZXJtaW5hdGVkIHN1Y2Nlc3NmdWxseVwiKTtcbn1cblxubGV0IG1hc3RlclRpbWU7XG5mdW5jdGlvbiBzdGFydE1hc3RlclRpbWVJbnRlcnZhbChtYXN0ZXJUaW1lUmVmcmVzaFJhdGUpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChtYXN0ZXJUaW1lSW50ZXJ2YWwpKSB7XG4gICAgICAgIG1hc3RlclRpbWVJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIG1hc3RlclRpbWUgPSBkYXRhU3luY2hyb25pemVyQWxnby5nZXRDdXJyZW50VGltZXN0YW1wKCk7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKG1hc3RlclRpbWUpKSB7XG4gICAgICAgICAgICAgICAgdGltZUJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG1hc3RlclRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5NQVNURVJfVElNRVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoIWlzRGVmaW5lZChsYXN0RGF0YSkgfHwgdmVyc2lvbiAhPT0gbGFzdERhdGEuZGF0YUJsb2NrLnZlcnNpb24gfHwgdmVyc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjVGltZSA9IGxhc3REYXRhLmRhdGFCbG9jay5kYXRhLnRpbWVzdGFtcDtcbiAgICAgICAgICAgIGNJZCA9IGxhc3REYXRhLmRhdGFTb3VyY2VJZDtcblxuICAgICAgICAgICAgaWYgKChjVGltZSAhPT0gLTEgJiYgbGFzdFRpbWUgPT09IC0xKSB8fCAobGFzdFRpbWUgIT09IC0xICYmIGNUaW1lICE9PSBsYXN0VGltZSkpIHsgLy8gZG9lcyBub3Qgc2VuZCB0aGUgc2FtZSBkYXRhIHR3aWNlXG4gICAgICAgICAgICAgICAgdGltZUJyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGNUaW1lLFxuICAgICAgICAgICAgICAgICAgICBkYXRhU291cmNlSWQ6IGNJZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkxBU1RfVElNRVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdFRpbWUgPSBjVGltZTtcbiAgICAgICAgfSwgbWFzdGVyVGltZVJlZnJlc2hSYXRlKTtcbiAgICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")}]);