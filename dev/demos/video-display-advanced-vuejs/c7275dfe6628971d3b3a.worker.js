!function(Q){var B={};function F(U){if(B[U])return B[U].exports;var I=B[U]={i:U,l:!1,exports:{}};return Q[U].call(I.exports,I,I.exports,F),I.l=!0,I.exports}F.m=Q,F.c=B,F.d=function(Q,B,U){F.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:U})},F.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},F.t=function(Q,B){if(1&B&&(Q=F(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var U=Object.create(null);if(F.r(U),Object.defineProperty(U,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var I in Q)F.d(U,I,function(B){return Q[B]}.bind(null,I));return U},F.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return F.d(B,"a",B),B},F.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},F.p="",F(F.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/utils/Utils.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n/** * @module Utils */\n\n/** Maximum value of a long */\nconst MAX_LONG = Math.pow(2, 53) + 1;\n/**\n * Global helper method to test if a letiable or object attribute is defined\n */\n\nfunction isDefined(v) {\n  return typeof v !== 'undefined' && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute has a value,\n that is it is defined and non null\n */\n\nfunction hasValue(v) {\n  return isDefined(v) && v !== null;\n}\n/**\n Global helper method to transform hex color into RGBA\n */\n\nfunction hex2rgb(hex) {\n  const [r, g, b] = hex.match(/\\w\\w/g).map(x => parseInt(x, 16));\n  return [r, g, b];\n}\n/**\n Global helper method to test if a letiable or object attribute is of a particular type\n */\n\nfunction hasType(v, expectedType) {\n  let hasVal = hasValue(v);\n  return hasVal && typeof v === expectedType;\n}\n/**\n Global helper method to test if a letiable or object attribute is an object\n */\n\nfunction isObject(v, letName) {\n  return hasType(v, 'object', letName);\n}\n/**\n Global helper method to test if a letiable or object attribute is an array\n */\n\nfunction isArray(v) {\n  return isDefined(v) && Array.isArray(v);\n}\n/**\n Global helper method to test if a letiable or object attribute is a function\n */\n\nfunction isFunction(v, letName) {\n  return hasType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined\n **/\n\nfunction assertDefined(v, letName = 'letiable') {\n  if (!isDefined(v)) {\n    throw letName + \" must be defined\";\n  }\n\n  return v;\n}\nfunction assertTrue(v, letName = 'letiable') {\n  if (!isDefined(v) || !v) {\n    throw letName;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertType(v, expectedType, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (typeof v !== expectedType) {\n    throw letName + \" must be of type \" + expectedType;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertBoolean(v, letName) {\n  return assertType(v, 'boolean', letName);\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertString(v, letName) {\n  return assertType(v, 'string', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertNumber(v, letName) {\n  return assertType(v, 'number', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertPositive(v, letName) {\n  assertNumber(v, letName);\n\n  if (v <= 0) {\n    throw letName + \" must be a positive number\";\n  }\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertObject(v, letName) {\n  return assertType(v, 'object', letName);\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertArray(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!Array.isArray(v)) {\n    throw letName + \" must be an array\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a function\n **/\n\nfunction assertFunction(v, letName) {\n  return assertType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertHasValue(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!hasValue(v)) {\n    throw letName + \" must not be null\";\n  }\n\n  return v;\n}\n/**\n *\n * @return {String}\n */\n\nfunction randomUUID() {\n  return 'xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * This function stamps/embeds a UUID into an object and returns the UUID generated for it\n * @return {String}\n */\n\nfunction stampUUID(obj) {\n  obj._osh_id = obj._osh_id || randomUUID();\n  return obj._osh_id;\n} //buffer is an ArrayBuffer object, the offset if specified in bytes, and the type is a string\n//corresponding to an OGC data type.\n//See http://def.seegrid.csiro.au/sissvoc/ogc-def/resource?uri=http://www.opengis.net/def/dataType/OGC/0/\n\n/**\n *\n * @param buffer\n * @param offset\n * @param type\n * @return {*}\n */\n\nfunction ParseBytes(buffer, offset, type) {\n  let view = new DataView(buffer); //Note: There exist types not listed in the map below that have OGC definitions, but no appropriate\n  //methods or corresponding types available for parsing in javascript. They are float128, float16, signedLong,\n  //and unsignedLong\n\n  let typeMap = {\n    double: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float64: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float32: function (offset) {\n      return {\n        val: view.getFloat32(offset),\n        bytes: 4\n      };\n    },\n    signedByte: function (offset) {\n      return {\n        val: view.getInt8(offset),\n        bytes: 1\n      };\n    },\n    signedInt: function (offset) {\n      return {\n        val: view.getInt32(offset),\n        bytes: 4\n      };\n    },\n    signedShort: function (offset) {\n      return {\n        val: view.getInt16(offset),\n        bytes: 2\n      };\n    },\n    unsignedByte: function (offset) {\n      return {\n        val: view.getUint8(offset),\n        bytes: 1\n      };\n    },\n    unsignedInt: function (offset) {\n      return {\n        val: view.getUint32(offset),\n        bytes: 4\n      };\n    },\n    unsignedShort: function (offset) {\n      return {\n        val: view.getUint16(offset),\n        bytes: 2\n      };\n    } //TODO: string-utf-8:\n\n  };\n  return typeMap[type](offset);\n} //This function recursivley iterates over the resultStructure to fill in\n//values read from data which should be an ArrayBuffer containing the payload from a websocket\n\n/**\n *\n * @param struct\n * @param data\n * @param offsetBytes\n * @return {*}\n */\n\nfunction ReadData(struct, data, offsetBytes) {\n  let offset = offsetBytes;\n\n  for (let i = 0; i < struct.fields.length; i++) {\n    let currFieldStruct = struct.fields[i];\n\n    if (isDefined(currFieldStruct.type) && currFieldStruct.type !== null) {\n      let ret = ParseBytes(data, offset, currFieldStruct.type);\n      currFieldStruct.val = ret.val;\n      offset += ret.bytes;\n    } else if (isDefined(currFieldStruct.count) && currFieldStruct.count !== null) {\n      //check if count is a reference to another letiable\n      if (isNaN(currFieldStruct.count)) {\n        let id = currFieldStruct.count;\n        let fieldName = struct.id2FieldMap[id];\n        currFieldStruct.count = struct.findFieldByName(fieldName).val;\n      }\n\n      for (let c = 0; c < currFieldStruct.count; c++) {\n        for (let j = 0; j < currFieldStruct.fields.length; j++) {\n          let field = JSON.parse(JSON.stringify(currFieldStruct.fields[j]));\n          offset = ReadData(field, data, offset);\n          currFieldStruct.val.push(field);\n        }\n      }\n    }\n  }\n\n  return offset;\n}\n/**\n *\n * @param resultStructure\n * @return {{}}\n */\n\nfunction GetResultObject(resultStructure) {\n  //TODO: handle cases for nested arrays / matrix data types\n  let result = {};\n\n  for (let i = 0; i < resultStructure.fields.length; i++) {\n    if (isDefined(resultStructure.fields[i].count)) {\n      result[resultStructure.fields[i].name] = [];\n\n      for (let c = 0; c < resultStructure.fields[i].count; c++) {\n        let item = {};\n\n        for (let k = 0; k < resultStructure.fields[i].val[c].fields.length; k++) {\n          item[resultStructure.fields[i].val[c].fields[k].name] = resultStructure.fields[i].val[c].fields[k].val;\n        }\n\n        result[resultStructure.fields[i].name].push(item);\n      }\n    } else {\n      result[resultStructure.fields[i].name] = resultStructure.fields[i].val;\n    }\n  }\n\n  return result;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isOpera() {\n  return !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isFirefox() {\n  return typeof InstallTrigger !== 'undefined';\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isSafari() {\n  return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isChrome() {\n  return !!window.chrome && !!window.chrome.webstore;\n}\n/**\n *\n * @return {*|boolean}\n */\n\nfunction isBlink() {\n  return (isChrome || isOpera) && !!window.CSS;\n}\n/**\n *\n * @param a\n * @param b\n * @return {boolean}\n */\n\nfunction isArrayIntersect(a, b) {\n  return a.filter(function (element) {\n    return b.indexOf(element) > -1;\n  }).length > 0;\n}\n/**\n *\n * @param o\n * @return {boolean}\n */\n\nfunction isElement(o) {\n  return typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n  o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n}\n/**\n *\n * @return {*}\n */\n\nfunction isWebWorker() {\n  return isDefined(Worker);\n}\n/**\n *\n * @param div\n */\n\nfunction takeScreenShot(div) {}\n/**\n * Remove a css class from a the div given as argument.\n * @param div the div to remove the class from\n * @param css the css class to remove\n */\n\nfunction removeCss(div, css) {\n  let divCss = div.className;\n  css = divCss.replace(css, \"\");\n  div.className = css;\n}\n/**\n * Add a css class to a the div given as argument.\n * @param div the div to add the class to\n * @param css the css class to add\n */\n\nfunction addCss(div, css) {\n  div.setAttribute(\"class\", div.className + \" \" + css);\n}\n/**\n * Removes the last character of a {string} object.\n * @param {string} value - The input {string}\n * @return {string} The value without the last character\n */\n\nfunction removeLastCharIfExist(value) {\n  if (!isDefined(undefined) || value === null || value.length === 0 || !value.endsWith(\"/\")) {\n    return value;\n  }\n\n  return value.substring(0, value.length - 1);\n}\n/**\n * Round off number to nearest 0.5\n * @param {Number} num - The number to round off\n * @return {number} The rounded number\n */\n\nfunction roundHalf(num) {\n  return Math.round(num * 2) / 2;\n}\n/**\n * Returns a function that, as long as it continues to be invoked,\n * will not be executed. The function will only be executed when\n * it will stop being called for more than N milliseconds.\n * If the `immediate` parameter is true, then the function\n * will be executed at the first call instead of the last.\n * Parameters :\n * - func: the function to `debouncer`.\n * - wait: the number of milliseconds (N) to wait before\n * call func()\n * - immediate (optional): Call func() at the first invocation\n * instead of the last one (Default false)\n * - context (optional): the context in which to call func()\n * (this by default)\n */\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n\nfunction debounce(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n\n  var later = function () {\n    var now = new Date().getTime(),\n        last = now - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = new Date().getTime();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n}\n;\nfunction throttle(func, wait, leading, trailing, context) {\n  var ctx, args, result;\n  var timeout = null;\n  var previous = 0;\n\n  var later = function () {\n    previous = new Date();\n    timeout = null;\n    result = func.apply(ctx, args);\n  };\n\n  return function () {\n    var now = new Date();\n    if (!previous && !leading) previous = now;\n    var remaining = wait - (now - previous);\n    ctx = context || this;\n    args = arguments;\n\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(ctx, args);\n    } else if (!timeout && trailing) {\n      // Sinon on s’endort pendant le temps restant\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n;\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/protocol/Status.js\n/**\n * Enum for connection status.\n * @readonly\n * @enum {{name: string}}\n */\nconst Status = {\n  CONNECTING: \"connecting\",\n  CONNECTED: \"connected\",\n  DISCONNECTED: \"disconnected\"\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/DataSynchronizerAlgo.js\n\n\n\nclass DataSynchronizerAlgo_DataSynchronizerAlgo {\n  constructor(dataSources, replaySpeed = 1, intervalRate = 5) {\n    this.dataSourceMap = {};\n    this.bufferingTime = 1000;\n    this.startBufferingTime = -1;\n    this.tsRun = 0;\n    this.replaySpeed = replaySpeed;\n    this.intervalRate = intervalRate;\n    let maxBufferingTime = -1;\n\n    for (let ds of dataSources) {\n      this.addDataSource(ds);\n      maxBufferingTime = ds.bufferingTime > maxBufferingTime ? ds.bufferingTime : maxBufferingTime;\n    }\n\n    if (maxBufferingTime !== -1) {\n      this.bufferingTime = maxBufferingTime;\n    }\n  }\n\n  push(dataSourceId, data) {\n    const ds = this.dataSourceMap[dataSourceId];\n\n    if (ds.status === Status.DISCONNECTED) {\n      return;\n    }\n\n    if (this.startBufferingTime === -1) {\n      this.startBufferingTime = performance.now(); // start iterating on data after bufferingTime\n\n      setTimeout(() => this.processData(), this.bufferingTime);\n    }\n\n    let latency = 0;\n\n    if (this.tsRun > 0) {\n      latency = this.tsRun - data.timeStamp;\n    }\n\n    ds.latency = latency > ds.latency ? latency : (ds.latency + latency) / 2;\n    ds.dataBuffer.push(data);\n  }\n\n  reset() {\n    this.close();\n\n    for (let currentDsId in this.dataSourceMap) {\n      const currentDs = this.dataSourceMap[currentDsId];\n      currentDs.dataBuffer = [];\n    }\n\n    this.startBufferingTime = -1;\n  }\n\n  processData() {\n    let tsRef = -1;\n    let clockTimeRef = performance.now(); // get reference start timestamp\n    // the reference start timestamp should the oldest one\n\n    let currentDs;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.status === Status.DISCONNECTED) {\n        continue;\n      }\n\n      if (currentDs.dataBuffer.length > 0) {\n        tsRef = tsRef === -1 || currentDs.dataBuffer[0].timeStamp < tsRef ? currentDs.dataBuffer[0].timeStamp : tsRef;\n      }\n    }\n\n    this.interval = setInterval(() => {\n      // 1) return the oldest data if any\n      while (this.computeNextData(tsRef, clockTimeRef));\n    }, this.intervalRate);\n  }\n  /**\n   * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,\n   * we return only the oldest one.\n   * @param tsRef - the timestamp of the first data\n   * @param refClockTime - the absolute diff time really spent\n   */\n\n\n  computeNextData(tsRef, refClockTime) {\n    let currentDs;\n    let currentDsToShift = null; // compute max latency\n\n    let maxLatency = 0;\n    let minLatency = 0;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.status === Status.DISCONNECTED) {\n        continue;\n      }\n\n      if (currentDs.latency > 0) {\n        let latency = Math.min(currentDs.latency, currentDs.timeOut);\n        maxLatency = latency > maxLatency ? latency : maxLatency;\n        minLatency = currentDs.latency < minLatency ? currentDs.latency : minLatency;\n      }\n    }\n\n    const dClock = performance.now() - refClockTime;\n    this.tsRun = tsRef + dClock; // compute next data to return\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.status === Status.DISCONNECTED) {\n        continue;\n      }\n\n      if (currentDs.dataBuffer.length > 0) {\n        const dTs = currentDs.dataBuffer[0].timeStamp - tsRef;\n        const dClockAdj = dClock - maxLatency; // we use an intermediate object to store the data to shift because we want to return the oldest one\n        // only\n\n        if (dTs <= dClockAdj * this.replaySpeed) {\n          // no other one to compare\n          if (currentDsToShift === null) {\n            currentDsToShift = currentDs;\n          } else {\n            // take the oldest data\n            currentDsToShift = currentDsToShift.dataBuffer[0].timeStamp < currentDs.dataBuffer[0].timeStamp ? currentDsToShift : currentDs;\n          }\n        }\n      }\n    } // finally pop the data from DS queue\n\n\n    if (currentDsToShift !== null) {\n      let rec = currentDsToShift.dataBuffer.shift(); // add latency flag to data record before we dispatch it\n      // this is relative latency in millis compared to the DS with the lowest latency\n      // so it is accurate even if local device time is not set properly\n\n      rec['@latency'] = currentDs.latency - minLatency;\n      this.onData(currentDsToShift.id, rec);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Add dataSource to be synchronized\n   * @param {DataSource} dataSource - the dataSource to synchronize\n   */\n\n\n  addDataSource(dataSource) {\n    this.dataSourceMap[dataSource.id] = {\n      bufferingTime: dataSource.bufferingTime,\n      timeOut: dataSource.timeOut || 0,\n      dataBuffer: [],\n      startBufferingTime: -1,\n      id: dataSource.id,\n      timedOut: false,\n      name: dataSource.name || dataSource.id,\n      latency: 0,\n      status: Status.DISCONNECTED //MEANING Enabled, 0 = Disabled\n\n    };\n  }\n\n  onData(dataSourceId, data) {}\n  /**\n   * Change the dataSource status\n   * @param {Status} status - the new status\n   * @param {String} dataSourceId - the corresponding dataSource id\n   */\n\n\n  setStatus(dataSourceId, status) {\n    if (dataSourceId in this.dataSourceMap) {\n      this.dataSourceMap[dataSourceId].status = status;\n\n      if (status === Status.DISCONNECTED) {\n        // reset latency and buffer\n        this.dataSourceMap[dataSourceId].latency = 0;\n        this.dataSourceMap[dataSourceId].dataBuffer = [];\n      }\n\n      console.warn(status + ' DataSource ' + dataSourceId + ' from the synchronizer ');\n    }\n  }\n\n  close() {\n    if (isDefined(this.interval)) {\n      clearInterval(this.interval);\n      console.log(\"Data synchronizer terminated successfully\");\n    }\n  }\n\n}\n\n/* harmony default export */ var timesync_DataSynchronizerAlgo = (DataSynchronizerAlgo_DataSynchronizerAlgo);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/Constants.js\nconst DATA_SYNCHRONIZER_TOPIC = 'data-synchronizer-';\nconst TIME_SYNCHRONIZER_TOPIC = 'data-synchronizer-time-';\nconst DATASOURCE_DATA_TOPIC = 'datasource-data-';\nconst DATASOURCE_TIME_TOPIC = 'datasource-time-';\nconst FFMPEG_VIEW_DECODE_TOPIC = 'ffmpeg-decode-';\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/event/EventType.js\nconst EventType = {\n  DATA: 'data',\n  STATUS: 'status'\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/core/timesync/DataSynchronizer.worker.js\n\n\n\n\nconst bcChannels = {};\nlet dataSynchronizerAlgo;\n\nlet init = false;\nlet dataSourceBroadCastChannel = null;\nself.currentTime = -1;\n\nconst dataSources = {};\nlet timeBroadcastChannel = null;\n\nself.onmessage = (event) => {\n    if(event.data.message === 'init') {\n        dataSynchronizerAlgo = new timesync_DataSynchronizerAlgo(\n            event.data.dataSources,\n            event.data.replaySpeed,\n            event.data.intervalRate\n        );\n        dataSynchronizerAlgo.onData = onData;\n        init = true;\n        addDataSources(event.data.dataSources);\n        initBroadcastChannel(event.data.dataTopic, event.data.timeTopic);\n    } else if(event.data.message === 'add' && event.data.dataSources) {\n        addDataSources(event.data.dataSources);\n    } else if(event.data.message === 'current-time') {\n        self.postMessage({\n            message: 'current-time',\n            data: self.currentTime\n        });\n    }  else if(event.data.message === 'reset') {\n        if(dataSynchronizerAlgo !== null) {\n            dataSynchronizerAlgo.reset();\n        }\n    } else if(event.data.message === 'replay-speed') {\n        if(dataSynchronizerAlgo !== null) {\n            dataSynchronizerAlgo.replaySpeed = event.data.replaySpeed;\n        }\n    } else if(event.data.message === 'data') {\n        if(dataSynchronizerAlgo !== null) {\n            dataSynchronizerAlgo.push(event.data.dataSourceId, {\n                data: event.data.data,\n                timeStamp: event.data.timeStamp\n            });\n        }\n    }\n}\n\nfunction initBroadcastChannel(dataTopic, timeTopic) {\n    dataSourceBroadCastChannel = new BroadcastChannel(dataTopic);\n    dataSourceBroadCastChannel.onmessage = (event) => {\n        if(event.data.type === EventType.DATA) {\n            for(let i=0; i < event.data.values.length;i++) {\n                dataSynchronizerAlgo.push(event.data.dataSourceId, {\n                    ...event.data.values[i]\n                });\n            }\n        } else if(event.data.type === EventType.STATUS) {\n            const dataSourceId = event.data.dataSourceId;\n            dataSynchronizerAlgo.setStatus(dataSourceId, event.data.status);\n            // bubble the message\n            bcChannels[dataSourceId].postMessage(event.data);\n        }\n    }\n\n    timeBroadcastChannel = new BroadcastChannel(timeTopic);\n\n}\n\n/**\n *\n * @param dataSources\n */\nfunction addDataSources(dataSources) {\n    for(let dataSource of dataSources) {\n        addDataSource(dataSource);\n    }\n}\n\nfunction addDataSource(dataSource) {\n    dataSynchronizerAlgo.addDataSource(dataSource);\n    // create a BC to push back the synchronized data into the DATA Stream.\n    bcChannels[dataSource.id] = new BroadcastChannel(DATASOURCE_DATA_TOPIC + dataSource.id);\n\n    if(!(dataSource.id in dataSources)) {\n        dataSources[dataSource.id] = dataSource;\n    }\n}\n\nfunction onData(dataSourceId, data) {\n    self.currentTime = data.timeStamp;\n    bcChannels[dataSourceId].postMessage({\n            values: [data],\n            dataSourceId,\n            type: EventType.DATA\n        }\n    );\n\n    timeBroadcastChannel.postMessage({\n        timestamp: data.timeStamp\n    });\n}\n\n\nself.onclose = function() {\n    dataSynchronizerAlgo.close();\n    console.log(\"Data Synchronizer has been terminated successfully\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2UvY29yZS91dGlscy9VdGlscy5qcz9mODdlIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL3Byb3RvY29sL1N0YXR1cy5qcz84ODhhIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9jb3JlL3RpbWVzeW5jL0RhdGFTeW5jaHJvbml6ZXJBbGdvLmpzP2FkY2EiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvQ29uc3RhbnRzLmpzP2I5YjEiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvZXZlbnQvRXZlbnRUeXBlLmpzPzllMzAiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL2NvcmUvdGltZXN5bmMvRGF0YVN5bmNocm9uaXplci53b3JrZXIuanM/NWYzMCJdLCJuYW1lcyI6WyJNQVhfTE9ORyIsIk1hdGgiLCJwb3ciLCJpc0RlZmluZWQiLCJ2IiwiaGFzVmFsdWUiLCJoZXgycmdiIiwiaGV4IiwiciIsImciLCJiIiwibWF0Y2giLCJtYXAiLCJ4IiwicGFyc2VJbnQiLCJoYXNUeXBlIiwiZXhwZWN0ZWRUeXBlIiwiaGFzVmFsIiwiaXNPYmplY3QiLCJsZXROYW1lIiwiaXNBcnJheSIsIkFycmF5IiwiaXNGdW5jdGlvbiIsImFzc2VydERlZmluZWQiLCJhc3NlcnRUcnVlIiwiYXNzZXJ0VHlwZSIsImFzc2VydEJvb2xlYW4iLCJhc3NlcnRTdHJpbmciLCJhc3NlcnROdW1iZXIiLCJhc3NlcnRQb3NpdGl2ZSIsImFzc2VydE9iamVjdCIsImFzc2VydEFycmF5IiwiYXNzZXJ0RnVuY3Rpb24iLCJhc3NlcnRIYXNWYWx1ZSIsInJhbmRvbVVVSUQiLCJyZXBsYWNlIiwiYyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3RhbXBVVUlEIiwib2JqIiwiX29zaF9pZCIsIlBhcnNlQnl0ZXMiLCJidWZmZXIiLCJvZmZzZXQiLCJ0eXBlIiwidmlldyIsIkRhdGFWaWV3IiwidHlwZU1hcCIsImRvdWJsZSIsInZhbCIsImdldEZsb2F0NjQiLCJieXRlcyIsImZsb2F0NjQiLCJmbG9hdDMyIiwiZ2V0RmxvYXQzMiIsInNpZ25lZEJ5dGUiLCJnZXRJbnQ4Iiwic2lnbmVkSW50IiwiZ2V0SW50MzIiLCJzaWduZWRTaG9ydCIsImdldEludDE2IiwidW5zaWduZWRCeXRlIiwiZ2V0VWludDgiLCJ1bnNpZ25lZEludCIsImdldFVpbnQzMiIsInVuc2lnbmVkU2hvcnQiLCJnZXRVaW50MTYiLCJSZWFkRGF0YSIsInN0cnVjdCIsImRhdGEiLCJvZmZzZXRCeXRlcyIsImkiLCJmaWVsZHMiLCJsZW5ndGgiLCJjdXJyRmllbGRTdHJ1Y3QiLCJyZXQiLCJjb3VudCIsImlzTmFOIiwiaWQiLCJmaWVsZE5hbWUiLCJpZDJGaWVsZE1hcCIsImZpbmRGaWVsZEJ5TmFtZSIsImoiLCJmaWVsZCIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInB1c2giLCJHZXRSZXN1bHRPYmplY3QiLCJyZXN1bHRTdHJ1Y3R1cmUiLCJyZXN1bHQiLCJuYW1lIiwiaXRlbSIsImsiLCJpc09wZXJhIiwid2luZG93Iiwib3ByIiwiYWRkb25zIiwib3BlcmEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmRleE9mIiwiaXNGaXJlZm94IiwiSW5zdGFsbFRyaWdnZXIiLCJpc1NhZmFyaSIsIk9iamVjdCIsInByb3RvdHlwZSIsImNhbGwiLCJIVE1MRWxlbWVudCIsImlzQ2hyb21lIiwiY2hyb21lIiwid2Vic3RvcmUiLCJpc0JsaW5rIiwiQ1NTIiwiaXNBcnJheUludGVyc2VjdCIsImEiLCJmaWx0ZXIiLCJlbGVtZW50IiwiaXNFbGVtZW50IiwibyIsIm5vZGVUeXBlIiwibm9kZU5hbWUiLCJpc1dlYldvcmtlciIsIldvcmtlciIsInRha2VTY3JlZW5TaG90IiwiZGl2IiwicmVtb3ZlQ3NzIiwiY3NzIiwiZGl2Q3NzIiwiY2xhc3NOYW1lIiwiYWRkQ3NzIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlTGFzdENoYXJJZkV4aXN0IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJlbmRzV2l0aCIsInN1YnN0cmluZyIsInJvdW5kSGFsZiIsIm51bSIsInJvdW5kIiwiZGVib3VuY2UiLCJmdW5jIiwid2FpdCIsImltbWVkaWF0ZSIsInRpbWVvdXQiLCJhcmdzIiwiY29udGV4dCIsInRpbWVzdGFtcCIsImxhdGVyIiwibm93IiwiRGF0ZSIsImdldFRpbWUiLCJsYXN0Iiwic2V0VGltZW91dCIsImFwcGx5IiwiYXJndW1lbnRzIiwiY2FsbE5vdyIsInRocm90dGxlIiwibGVhZGluZyIsInRyYWlsaW5nIiwiY3R4IiwicHJldmlvdXMiLCJyZW1haW5pbmciLCJjbGVhclRpbWVvdXQiLCJTdGF0dXMiLCJDT05ORUNUSU5HIiwiQ09OTkVDVEVEIiwiRElTQ09OTkVDVEVEIiwiRGF0YVN5bmNocm9uaXplckFsZ28iLCJjb25zdHJ1Y3RvciIsImRhdGFTb3VyY2VzIiwicmVwbGF5U3BlZWQiLCJpbnRlcnZhbFJhdGUiLCJkYXRhU291cmNlTWFwIiwiYnVmZmVyaW5nVGltZSIsInN0YXJ0QnVmZmVyaW5nVGltZSIsInRzUnVuIiwibWF4QnVmZmVyaW5nVGltZSIsImRzIiwiYWRkRGF0YVNvdXJjZSIsImRhdGFTb3VyY2VJZCIsInN0YXR1cyIsInBlcmZvcm1hbmNlIiwicHJvY2Vzc0RhdGEiLCJsYXRlbmN5IiwidGltZVN0YW1wIiwiZGF0YUJ1ZmZlciIsInJlc2V0IiwiY2xvc2UiLCJjdXJyZW50RHNJZCIsImN1cnJlbnREcyIsInRzUmVmIiwiY2xvY2tUaW1lUmVmIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNvbXB1dGVOZXh0RGF0YSIsInJlZkNsb2NrVGltZSIsImN1cnJlbnREc1RvU2hpZnQiLCJtYXhMYXRlbmN5IiwibWluTGF0ZW5jeSIsIm1pbiIsInRpbWVPdXQiLCJkQ2xvY2siLCJkVHMiLCJkQ2xvY2tBZGoiLCJyZWMiLCJzaGlmdCIsIm9uRGF0YSIsImRhdGFTb3VyY2UiLCJ0aW1lZE91dCIsInNldFN0YXR1cyIsImNvbnNvbGUiLCJ3YXJuIiwiY2xlYXJJbnRlcnZhbCIsImxvZyIsIkRBVEFfU1lOQ0hST05JWkVSX1RPUElDIiwiVElNRV9TWU5DSFJPTklaRVJfVE9QSUMiLCJEQVRBU09VUkNFX0RBVEFfVE9QSUMiLCJEQVRBU09VUkNFX1RJTUVfVE9QSUMiLCJGRk1QRUdfVklFV19ERUNPREVfVE9QSUMiLCJFdmVudFR5cGUiLCJEQVRBIiwiU1RBVFVTIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ08sTUFBTUEsUUFBUSxHQUFHQyxJQUFJLENBQUNDLEdBQUwsQ0FBUyxDQUFULEVBQVksRUFBWixJQUFrQixDQUFuQztBQUVQO0FBQ0E7QUFDQTs7QUFDTyxTQUFTQyxTQUFULENBQW1CQyxDQUFuQixFQUFzQjtBQUN6QixTQUFPLE9BQVFBLENBQVIsS0FBZSxXQUFmLElBQThCQSxDQUFDLEtBQUssSUFBM0M7QUFDSDtBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUNPLFNBQVNDLFFBQVQsQ0FBa0JELENBQWxCLEVBQXFCO0FBQ3hCLFNBQU9ELFNBQVMsQ0FBQ0MsQ0FBRCxDQUFULElBQWdCQSxDQUFDLEtBQUssSUFBN0I7QUFDSDtBQUVEO0FBQ0E7QUFDQTs7QUFDTyxTQUFTRSxPQUFULENBQWlCQyxHQUFqQixFQUFxQjtBQUN4QixRQUFNLENB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cUJBQXFCLEdBQUcsa0JBQTlCO0FBQ0EsTUFBTUMscUJBQXFCLEdBQUcsa0JBQTlCO0FBRUEsTUFBTUMsd0JBQXdCLEdBQUcsZ0JBQWpDLEM7O0FDTkEsTUFBTUMsU0FBUyxHQUFHO0FBQ3JCQyxNQUFJLEVBQUUsTUFEZTtBQUVyQkMsUUFBTSxFQUFFO0FBRmEsQ0FBbEIsQzs7QUNBc0Q7QUFDUDtBQUNOOztBQUVoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsNkJBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUztBQUN4Qyx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTLDZCQUE2QixTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFELHFCQUFxQjs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gVGhlIGNvbnRlbnRzIG9mIHRoaXMgZmlsZSBhcmUgc3ViamVjdCB0byB0aGUgTW96aWxsYSBQdWJsaWMgTGljZW5zZSwgdi4gMi4wLlxuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZVxuIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblxuIFNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2VcbiBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyByaWdodHMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gQ29weXJpZ2h0IChDKSAyMDE1LTIwMjAgTWF0aGlldSBEaGFpbmF1dC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuIEF1dGhvcjogTWF0aGlldSBEaGFpbmF1dCA8bWF0aGlldS5kaGFpbmF1dEBnbWFpbC5jb20+XG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqICogQG1vZHVsZSBVdGlscyAqL1xuXG4vKiogTWF4aW11bSB2YWx1ZSBvZiBhIGxvbmcgKi9cbmV4cG9ydCBjb25zdCBNQVhfTE9ORyA9IE1hdGgucG93KDIsIDUzKSArIDE7XG5cbi8qKlxuICogR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbmVkKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mICh2KSAhPT0gJ3VuZGVmaW5lZCcgJiYgdiAhPT0gbnVsbDtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaGFzIGEgdmFsdWUsXG4gdGhhdCBpcyBpdCBpcyBkZWZpbmVkIGFuZCBub24gbnVsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzVmFsdWUodikge1xuICAgIHJldHVybiBpc0RlZmluZWQodikgJiYgdiAhPT0gbnVsbDtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdHJhbnNmb3JtIGhleCBjb2xvciBpbnRvIFJHQkFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleDJyZ2IoaGV4KXtcbiAgICBjb25zdCBbciwgZywgYl0gPSBoZXgubWF0Y2goL1xcd1xcdy9nKS5tYXAoeCA9PiBwYXJzZUludCh4LCAxNikpO1xuICAgIHJldHVybiBbciwgZywgYl07XG59XG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBvZiBhIHBhcnRpY3VsYXIgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzVHlwZSh2LCBleHBlY3RlZFR5cGUpIHtcbiAgICBsZXQgaGFzVmFsID0gaGFzVmFsdWUodik7XG4gICAgcmV0dXJuIGhhc1ZhbCAmJiB0eXBlb2YgKHYpID09PSBleHBlY3RlZFR5cGU7XG59XG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBoYXNUeXBlKHYsICdvYmplY3QnLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkodikge1xuICAgIHJldHVybiBpc0RlZmluZWQodikgJiYgQXJyYXkuaXNBcnJheSh2KTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGhhc1R5cGUodiwgJ2Z1bmN0aW9uJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGlmICghaXNEZWZpbmVkKHYpKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIGRlZmluZWRcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRUcnVlKHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgaWYgKCFpc0RlZmluZWQodikgfHwgIXYpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBhbmQgbm9uLW51bGxcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRUeXBlKHYsIGV4cGVjdGVkVHlwZSwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUpO1xuICAgIGlmICh0eXBlb2YgKHYpICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgb2YgdHlwZSBcIiArIGV4cGVjdGVkVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIHN0cmluZ1xuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEJvb2xlYW4odiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdib29sZWFuJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIHN0cmluZ1xuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFN0cmluZyh2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ3N0cmluZycsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBudW1iZXJcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROdW1iZXIodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdudW1iZXInLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgbnVtYmVyXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UG9zaXRpdmUodiwgbGV0TmFtZSkge1xuICAgIGFzc2VydE51bWJlcih2LCBsZXROYW1lKTtcbiAgICBpZiAodiA8PSAwKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCI7XG4gICAgfVxufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gb2JqZWN0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnb2JqZWN0JywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBvYmplY3RcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcnJheSh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIGFuIGFycmF5XCI7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBmdW5jdGlvblxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnZnVuY3Rpb24nLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGRlZmluZWQgYW5kIG5vbi1udWxsXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SGFzVmFsdWUodiwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUpO1xuICAgIGlmICghaGFzVmFsdWUodikpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3Qgbm90IGJlIG51bGxcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVVVSUQoKSB7XG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LXh4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgbGV0IHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gc3RhbXBzL2VtYmVkcyBhIFVVSUQgaW50byBhbiBvYmplY3QgYW5kIHJldHVybnMgdGhlIFVVSUQgZ2VuZXJhdGVkIGZvciBpdFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhbXBVVUlEKG9iaikge1xuICAgIG9iai5fb3NoX2lkID0gb2JqLl9vc2hfaWQgfHwgcmFuZG9tVVVJRCgpO1xuICAgIHJldHVybiBvYmouX29zaF9pZDtcbn1cblxuLy9idWZmZXIgaXMgYW4gQXJyYXlCdWZmZXIgb2JqZWN0LCB0aGUgb2Zmc2V0IGlmIHNwZWNpZmllZCBpbiBieXRlcywgYW5kIHRoZSB0eXBlIGlzIGEgc3RyaW5nXG4vL2NvcnJlc3BvbmRpbmcgdG8gYW4gT0dDIGRhdGEgdHlwZS5cbi8vU2VlIGh0dHA6Ly9kZWYuc2VlZ3JpZC5jc2lyby5hdS9zaXNzdm9jL29nYy1kZWYvcmVzb3VyY2U/dXJpPWh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZGVmL2RhdGFUeXBlL09HQy8wL1xuLyoqXG4gKlxuICogQHBhcmFtIGJ1ZmZlclxuICogQHBhcmFtIG9mZnNldFxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQYXJzZUJ5dGVzKGJ1ZmZlciwgb2Zmc2V0LCB0eXBlKSB7XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcblxuICAgIC8vTm90ZTogVGhlcmUgZXhpc3QgdHlwZXMgbm90IGxpc3RlZCBpbiB0aGUgbWFwIGJlbG93IHRoYXQgaGF2ZSBPR0MgZGVmaW5pdGlvbnMsIGJ1dCBubyBhcHByb3ByaWF0ZVxuICAgIC8vbWV0aG9kcyBvciBjb3JyZXNwb25kaW5nIHR5cGVzIGF2YWlsYWJsZSBmb3IgcGFyc2luZyBpbiBqYXZhc2NyaXB0LiBUaGV5IGFyZSBmbG9hdDEyOCwgZmxvYXQxNiwgc2lnbmVkTG9uZyxcbiAgICAvL2FuZCB1bnNpZ25lZExvbmdcbiAgICBsZXQgdHlwZU1hcCA9IHtcbiAgICAgICAgZG91YmxlOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRGbG9hdDY0KG9mZnNldCksIGJ5dGVzOiA4fTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXQ2NDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQpLCBieXRlczogOH07XG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0MzI6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEZsb2F0MzIob2Zmc2V0KSwgYnl0ZXM6IDR9O1xuICAgICAgICB9LFxuICAgICAgICBzaWduZWRCeXRlOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRJbnQ4KG9mZnNldCksIGJ5dGVzOiAxfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmVkSW50OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRJbnQzMihvZmZzZXQpLCBieXRlczogNH07XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25lZFNob3J0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRJbnQxNihvZmZzZXQpLCBieXRlczogMn07XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2lnbmVkQnl0ZTogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0VWludDgob2Zmc2V0KSwgYnl0ZXM6IDF9O1xuICAgICAgICB9LFxuICAgICAgICB1bnNpZ25lZEludDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0VWludDMyKG9mZnNldCksIGJ5dGVzOiA0fTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaWduZWRTaG9ydDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0VWludDE2KG9mZnNldCksIGJ5dGVzOiAyfTtcbiAgICAgICAgfSxcbiAgICAgICAgLy9UT0RPOiBzdHJpbmctdXRmLTg6XG4gICAgfTtcbiAgICByZXR1cm4gdHlwZU1hcFt0eXBlXShvZmZzZXQpO1xufVxuXG4vL1RoaXMgZnVuY3Rpb24gcmVjdXJzaXZsZXkgaXRlcmF0ZXMgb3ZlciB0aGUgcmVzdWx0U3RydWN0dXJlIHRvIGZpbGwgaW5cbi8vdmFsdWVzIHJlYWQgZnJvbSBkYXRhIHdoaWNoIHNob3VsZCBiZSBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIHRoZSBwYXlsb2FkIGZyb20gYSB3ZWJzb2NrZXRcbi8qKlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3RcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gb2Zmc2V0Qnl0ZXNcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSZWFkRGF0YShzdHJ1Y3QsIGRhdGEsIG9mZnNldEJ5dGVzKSB7XG4gICAgbGV0IG9mZnNldCA9IG9mZnNldEJ5dGVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RydWN0LmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY3VyckZpZWxkU3RydWN0ID0gc3RydWN0LmZpZWxkc1tpXTtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChjdXJyRmllbGRTdHJ1Y3QudHlwZSkgJiYgY3VyckZpZWxkU3RydWN0LnR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZXQgPSBQYXJzZUJ5dGVzKGRhdGEsIG9mZnNldCwgY3VyckZpZWxkU3RydWN0LnR5cGUpO1xuICAgICAgICAgICAgY3VyckZpZWxkU3RydWN0LnZhbCA9IHJldC52YWw7XG4gICAgICAgICAgICBvZmZzZXQgKz0gcmV0LmJ5dGVzO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmaW5lZChjdXJyRmllbGRTdHJ1Y3QuY291bnQpICYmIGN1cnJGaWVsZFN0cnVjdC5jb3VudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy9jaGVjayBpZiBjb3VudCBpcyBhIHJlZmVyZW5jZSB0byBhbm90aGVyIGxldGlhYmxlXG4gICAgICAgICAgICBpZiAoaXNOYU4oY3VyckZpZWxkU3RydWN0LmNvdW50KSkge1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IGN1cnJGaWVsZFN0cnVjdC5jb3VudDtcbiAgICAgICAgICAgICAgICBsZXQgZmllbGROYW1lID0gc3RydWN0LmlkMkZpZWxkTWFwW2lkXTtcbiAgICAgICAgICAgICAgICBjdXJyRmllbGRTdHJ1Y3QuY291bnQgPSBzdHJ1Y3QuZmluZEZpZWxkQnlOYW1lKGZpZWxkTmFtZSkudmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyRmllbGRTdHJ1Y3QuY291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3VyckZpZWxkU3RydWN0LmZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmllbGQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGN1cnJGaWVsZFN0cnVjdC5maWVsZHNbal0pKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gUmVhZERhdGEoZmllbGQsIGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJGaWVsZFN0cnVjdC52YWwucHVzaChmaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSByZXN1bHRTdHJ1Y3R1cmVcbiAqIEByZXR1cm4ge3t9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gR2V0UmVzdWx0T2JqZWN0KHJlc3VsdFN0cnVjdHVyZSkge1xuICAgIC8vVE9ETzogaGFuZGxlIGNhc2VzIGZvciBuZXN0ZWQgYXJyYXlzIC8gbWF0cml4IGRhdGEgdHlwZXNcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc0RlZmluZWQocmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5jb3VudCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLm5hbWVdID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0uY291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbFtjXS5maWVsZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbFtjXS5maWVsZHNba10ubmFtZV0gPSByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbFtjXS5maWVsZHNba10udmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5uYW1lXS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0ubmFtZV0gPSByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLnZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPcGVyYSgpIHtcbiAgICByZXR1cm4gKCEhd2luZG93Lm9wciAmJiAhIW9wci5hZGRvbnMpIHx8ICEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGaXJlZm94KCkge1xuICAgIHJldHVybiB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cuSFRNTEVsZW1lbnQpLmluZGV4T2YoJ0NvbnN0cnVjdG9yJykgPiAwO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDaHJvbWUoKSB7XG4gICAgcmV0dXJuICEhd2luZG93LmNocm9tZSAmJiAhIXdpbmRvdy5jaHJvbWUud2Vic3RvcmU7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4geyp8Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmxpbmsoKSB7XG4gICAgcmV0dXJuIChpc0Nocm9tZSB8fCBpc09wZXJhKSAmJiAhIXdpbmRvdy5DU1M7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBhXG4gKiBAcGFyYW0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlJbnRlcnNlY3QoYSwgYikge1xuICAgIHJldHVybiBhLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gYi5pbmRleE9mKGVsZW1lbnQpID4gLTE7XG4gICAgfSkubGVuZ3RoID4gMDtcbn1cblxuXG4vKipcbiAqXG4gKiBAcGFyYW0gb1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudChvKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJvYmplY3RcIiA/IG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA6IC8vRE9NMlxuICAgICAgICBvICYmIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmIG8gIT09IG51bGwgJiYgby5ub2RlVHlwZSA9PT0gMSAmJiB0eXBlb2Ygby5ub2RlTmFtZSA9PT0gXCJzdHJpbmdcIlxuICAgICk7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1dlYldvcmtlcigpIHtcbiAgICByZXR1cm4gaXNEZWZpbmVkKFdvcmtlcik7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBkaXZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRha2VTY3JlZW5TaG90KGRpdikge1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNzcyBjbGFzcyBmcm9tIGEgdGhlIGRpdiBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSBkaXYgdGhlIGRpdiB0byByZW1vdmUgdGhlIGNsYXNzIGZyb21cbiAqIEBwYXJhbSBjc3MgdGhlIGNzcyBjbGFzcyB0byByZW1vdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNzcyhkaXYsIGNzcykge1xuICAgIGxldCBkaXZDc3MgPSBkaXYuY2xhc3NOYW1lO1xuICAgIGNzcyA9IGRpdkNzcy5yZXBsYWNlKGNzcywgXCJcIik7XG4gICAgZGl2LmNsYXNzTmFtZSA9IGNzcztcbn1cblxuXG4vKipcbiAqIEFkZCBhIGNzcyBjbGFzcyB0byBhIHRoZSBkaXYgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0gZGl2IHRoZSBkaXYgdG8gYWRkIHRoZSBjbGFzcyB0b1xuICogQHBhcmFtIGNzcyB0aGUgY3NzIGNsYXNzIHRvIGFkZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ3NzKGRpdiwgY3NzKSB7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGRpdi5jbGFzc05hbWUgKyBcIiBcIiArIGNzcyk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgYSB7c3RyaW5nfSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgaW5wdXQge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlIHdpdGhvdXQgdGhlIGxhc3QgY2hhcmFjdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVMYXN0Q2hhcklmRXhpc3QodmFsdWUpIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh1bmRlZmluZWQpIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCB8fCAhdmFsdWUuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIDEpO1xufVxuXG4vKipcbiAqIFJvdW5kIG9mZiBudW1iZXIgdG8gbmVhcmVzdCAwLjVcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gLSBUaGUgbnVtYmVyIHRvIHJvdW5kIG9mZlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcm91bmRlZCBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kSGFsZihudW0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChudW0qMikvMjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCxcbiAqIHdpbGwgbm90IGJlIGV4ZWN1dGVkLiBUaGUgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHdoZW5cbiAqIGl0IHdpbGwgc3RvcCBiZWluZyBjYWxsZWQgZm9yIG1vcmUgdGhhbiBOIG1pbGxpc2Vjb25kcy5cbiAqIElmIHRoZSBgaW1tZWRpYXRlYCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgdGhlbiB0aGUgZnVuY3Rpb25cbiAqIHdpbGwgYmUgZXhlY3V0ZWQgYXQgdGhlIGZpcnN0IGNhbGwgaW5zdGVhZCBvZiB0aGUgbGFzdC5cbiAqIFBhcmFtZXRlcnMgOlxuICogLSBmdW5jOiB0aGUgZnVuY3Rpb24gdG8gYGRlYm91bmNlcmAuXG4gKiAtIHdhaXQ6IHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIChOKSB0byB3YWl0IGJlZm9yZVxuICogY2FsbCBmdW5jKClcbiAqIC0gaW1tZWRpYXRlIChvcHRpb25hbCk6IENhbGwgZnVuYygpIGF0IHRoZSBmaXJzdCBpbnZvY2F0aW9uXG4gKiBpbnN0ZWFkIG9mIHRoZSBsYXN0IG9uZSAoRGVmYXVsdCBmYWxzZSlcbiAqIC0gY29udGV4dCAob3B0aW9uYWwpOiB0aGUgY29udGV4dCBpbiB3aGljaCB0byBjYWxsIGZ1bmMoKVxuICogKHRoaXMgYnkgZGVmYXVsdClcbiAqL1xuXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4vLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4vLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbi8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgIGxhc3QgPSBub3cgLSB0aW1lc3RhbXA7XG5cbiAgICAgICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIGxlYWRpbmcsIHRyYWlsaW5nLCBjb250ZXh0KSB7XG4gICAgdmFyIGN0eCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBwcmV2aW91cyA9IG5ldyBEYXRlO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjdHgsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGU7XG4gICAgICAgIGlmICghcHJldmlvdXMgJiYgIWxlYWRpbmcpIHByZXZpb3VzID0gbm93O1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICAgIGN0eCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIHRyYWlsaW5nKSB7XG4gICAgICAgICAgICAvLyBTaW5vbiBvbiBz4oCZZW5kb3J0IHBlbmRhbnQgbGUgdGVtcHMgcmVzdGFudFxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufTtcbiIsIi8qKlxuICogRW51bSBmb3IgY29ubmVjdGlvbiBzdGF0dXMuXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHt7bmFtZTogc3RyaW5nfX1cbiAqL1xuZXhwb3J0IGNvbnN0IFN0YXR1cyA9IHtcbiAgICBDT05ORUNUSU5HOiBcImNvbm5lY3RpbmdcIixcbiAgICBDT05ORUNURUQ6ICBcImNvbm5lY3RlZFwiLFxuICAgIERJU0NPTk5FQ1RFRDogXCJkaXNjb25uZWN0ZWRcIlxufTtcbiIsImltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vdXRpbHMvVXRpbHMuanNcIjtcbmltcG9ydCB7U3RhdHVzfSBmcm9tIFwiLi4vcHJvdG9jb2wvU3RhdHVzLmpzXCI7XG5cbmNsYXNzIERhdGFTeW5jaHJvbml6ZXJBbGdvIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhU291cmNlcywgcmVwbGF5U3BlZWQgPSAxLCBpbnRlcnZhbFJhdGUgPSA1KSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLmJ1ZmZlcmluZ1RpbWUgPSAxMDAwO1xuICAgICAgICB0aGlzLnN0YXJ0QnVmZmVyaW5nVGltZSA9IC0xO1xuICAgICAgICB0aGlzLnRzUnVuID0gMDtcbiAgICAgICAgdGhpcy5yZXBsYXlTcGVlZCA9IHJlcGxheVNwZWVkO1xuICAgICAgICB0aGlzLmludGVydmFsUmF0ZSA9IGludGVydmFsUmF0ZTtcbiAgICAgICAgbGV0IG1heEJ1ZmZlcmluZ1RpbWUgPSAtMTtcblxuICAgICAgICBmb3IgKGxldCBkcyBvZiBkYXRhU291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhU291cmNlKGRzKTtcbiAgICAgICAgICAgIG1heEJ1ZmZlcmluZ1RpbWUgPSBkcy5idWZmZXJpbmdUaW1lID4gbWF4QnVmZmVyaW5nVGltZSA/IGRzLmJ1ZmZlcmluZ1RpbWUgOiBtYXhCdWZmZXJpbmdUaW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhCdWZmZXJpbmdUaW1lICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJpbmdUaW1lID0gbWF4QnVmZmVyaW5nVGltZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1c2goZGF0YVNvdXJjZUlkLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGRzID0gdGhpcy5kYXRhU291cmNlTWFwW2RhdGFTb3VyY2VJZF07XG4gICAgICAgIGlmIChkcy5zdGF0dXMgPT09IFN0YXR1cy5ESVNDT05ORUNURUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0QnVmZmVyaW5nVGltZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRCdWZmZXJpbmdUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAvLyBzdGFydCBpdGVyYXRpbmcgb24gZGF0YSBhZnRlciBidWZmZXJpbmdUaW1lXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucHJvY2Vzc0RhdGEoKSwgdGhpcy5idWZmZXJpbmdUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsYXRlbmN5ID0gMDtcbiAgICAgICAgaWYgKHRoaXMudHNSdW4gPiAwKSB7XG4gICAgICAgICAgICBsYXRlbmN5ID0gdGhpcy50c1J1biAtIGRhdGEudGltZVN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIGRzLmxhdGVuY3kgPSBsYXRlbmN5ID4gZHMubGF0ZW5jeSA/IGxhdGVuY3kgOiAoZHMubGF0ZW5jeSArIGxhdGVuY3kpIC8gMjtcbiAgICAgICAgZHMuZGF0YUJ1ZmZlci5wdXNoKGRhdGEpO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIGZvciAobGV0IGN1cnJlbnREc0lkIGluIHRoaXMuZGF0YVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERzID0gdGhpcy5kYXRhU291cmNlTWFwW2N1cnJlbnREc0lkXTtcbiAgICAgICAgICAgIGN1cnJlbnREcy5kYXRhQnVmZmVyID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydEJ1ZmZlcmluZ1RpbWUgPSAtMTtcbiAgICB9XG5cbiAgICBwcm9jZXNzRGF0YSgpIHtcbiAgICAgICAgbGV0IHRzUmVmID0gLTE7XG4gICAgICAgIGxldCBjbG9ja1RpbWVSZWYgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgICAvLyBnZXQgcmVmZXJlbmNlIHN0YXJ0IHRpbWVzdGFtcFxuICAgICAgICAvLyB0aGUgcmVmZXJlbmNlIHN0YXJ0IHRpbWVzdGFtcCBzaG91bGQgdGhlIG9sZGVzdCBvbmVcbiAgICAgICAgbGV0IGN1cnJlbnREcztcbiAgICAgICAgZm9yIChsZXQgY3VycmVudERzSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICBjdXJyZW50RHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbY3VycmVudERzSWRdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5zdGF0dXMgPT09IFN0YXR1cy5ESVNDT05ORUNURUQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50RHMuZGF0YUJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdHNSZWYgPSAodHNSZWYgPT09IC0xIHx8IGN1cnJlbnREcy5kYXRhQnVmZmVyWzBdLnRpbWVTdGFtcCA8IHRzUmVmKSA/IGN1cnJlbnREcy5kYXRhQnVmZmVyWzBdLnRpbWVTdGFtcCA6XG4gICAgICAgICAgICAgICAgICAgIHRzUmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIC8vIDEpIHJldHVybiB0aGUgb2xkZXN0IGRhdGEgaWYgYW55XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5jb21wdXRlTmV4dERhdGEodHNSZWYsIGNsb2NrVGltZVJlZikpIDtcblxuICAgICAgICB9LCB0aGlzLmludGVydmFsUmF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgbmV4dCBkYXRhIGlmIGFueS4gV2UgcmV0dXJuIG9ubHkgMSB2YWx1ZSBmb3IgdGhpcyBpdGVyYXRpb24uIElmIHRoZXJlIGFyZSBtdWx0aXBsZSB2YWx1ZXMgdG8gcmV0dXJuLFxuICAgICAqIHdlIHJldHVybiBvbmx5IHRoZSBvbGRlc3Qgb25lLlxuICAgICAqIEBwYXJhbSB0c1JlZiAtIHRoZSB0aW1lc3RhbXAgb2YgdGhlIGZpcnN0IGRhdGFcbiAgICAgKiBAcGFyYW0gcmVmQ2xvY2tUaW1lIC0gdGhlIGFic29sdXRlIGRpZmYgdGltZSByZWFsbHkgc3BlbnRcbiAgICAgKi9cbiAgICBjb21wdXRlTmV4dERhdGEodHNSZWYsIHJlZkNsb2NrVGltZSkge1xuICAgICAgICBsZXQgY3VycmVudERzO1xuICAgICAgICBsZXQgY3VycmVudERzVG9TaGlmdCA9IG51bGw7XG5cbiAgICAgICAgLy8gY29tcHV0ZSBtYXggbGF0ZW5jeVxuICAgICAgICBsZXQgbWF4TGF0ZW5jeSA9IDA7XG4gICAgICAgIGxldCBtaW5MYXRlbmN5ID0gMDtcbiAgICAgICAgZm9yIChsZXQgY3VycmVudERzSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICBjdXJyZW50RHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbY3VycmVudERzSWRdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5zdGF0dXMgPT09IFN0YXR1cy5ESVNDT05ORUNURUQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50RHMubGF0ZW5jeSA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbGF0ZW5jeSA9IE1hdGgubWluKGN1cnJlbnREcy5sYXRlbmN5LCBjdXJyZW50RHMudGltZU91dCk7XG4gICAgICAgICAgICAgICAgbWF4TGF0ZW5jeSA9IChsYXRlbmN5ID4gbWF4TGF0ZW5jeSkgPyBsYXRlbmN5IDogbWF4TGF0ZW5jeTtcbiAgICAgICAgICAgICAgICBtaW5MYXRlbmN5ID0gKGN1cnJlbnREcy5sYXRlbmN5IDwgbWluTGF0ZW5jeSkgPyBjdXJyZW50RHMubGF0ZW5jeSA6IG1pbkxhdGVuY3k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkQ2xvY2sgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHJlZkNsb2NrVGltZTtcbiAgICAgICAgdGhpcy50c1J1biA9IHRzUmVmICsgZENsb2NrO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgbmV4dCBkYXRhIHRvIHJldHVyblxuICAgICAgICBmb3IgKGxldCBjdXJyZW50RHNJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGN1cnJlbnREcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtjdXJyZW50RHNJZF07XG4gICAgICAgICAgICBpZiAoY3VycmVudERzLnN0YXR1cyA9PT0gU3RhdHVzLkRJU0NPTk5FQ1RFRCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5kYXRhQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkVHMgPSBjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS50aW1lU3RhbXAgLSB0c1JlZjtcbiAgICAgICAgICAgICAgICBjb25zdCBkQ2xvY2tBZGogPSBkQ2xvY2sgLSBtYXhMYXRlbmN5O1xuICAgICAgICAgICAgICAgIC8vIHdlIHVzZSBhbiBpbnRlcm1lZGlhdGUgb2JqZWN0IHRvIHN0b3JlIHRoZSBkYXRhIHRvIHNoaWZ0IGJlY2F1c2Ugd2Ugd2FudCB0byByZXR1cm4gdGhlIG9sZGVzdCBvbmVcbiAgICAgICAgICAgICAgICAvLyBvbmx5XG4gICAgICAgICAgICAgICAgaWYgKGRUcyA8PSBkQ2xvY2tBZGogKiB0aGlzLnJlcGxheVNwZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG90aGVyIG9uZSB0byBjb21wYXJlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RHNUb1NoaWZ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHNUb1NoaWZ0ID0gY3VycmVudERzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFrZSB0aGUgb2xkZXN0IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREc1RvU2hpZnQgPSAoY3VycmVudERzVG9TaGlmdC5kYXRhQnVmZmVyWzBdLnRpbWVTdGFtcCA8IGN1cnJlbnREcy5kYXRhQnVmZmVyWzBdLnRpbWVTdGFtcCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREc1RvU2hpZnQgOiBjdXJyZW50RHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5hbGx5IHBvcCB0aGUgZGF0YSBmcm9tIERTIHF1ZXVlXG4gICAgICAgIGlmIChjdXJyZW50RHNUb1NoaWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVjID0gY3VycmVudERzVG9TaGlmdC5kYXRhQnVmZmVyLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBsYXRlbmN5IGZsYWcgdG8gZGF0YSByZWNvcmQgYmVmb3JlIHdlIGRpc3BhdGNoIGl0XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHJlbGF0aXZlIGxhdGVuY3kgaW4gbWlsbGlzIGNvbXBhcmVkIHRvIHRoZSBEUyB3aXRoIHRoZSBsb3dlc3QgbGF0ZW5jeVxuICAgICAgICAgICAgLy8gc28gaXQgaXMgYWNjdXJhdGUgZXZlbiBpZiBsb2NhbCBkZXZpY2UgdGltZSBpcyBub3Qgc2V0IHByb3Blcmx5XG4gICAgICAgICAgICByZWNbJ0BsYXRlbmN5J10gPSBjdXJyZW50RHMubGF0ZW5jeSAtIG1pbkxhdGVuY3k7XG5cbiAgICAgICAgICAgIHRoaXMub25EYXRhKGN1cnJlbnREc1RvU2hpZnQuaWQsIHJlYyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGFTb3VyY2UgdG8gYmUgc3luY2hyb25pemVkXG4gICAgICogQHBhcmFtIHtEYXRhU291cmNlfSBkYXRhU291cmNlIC0gdGhlIGRhdGFTb3VyY2UgdG8gc3luY2hyb25pemVcbiAgICAgKi9cbiAgICBhZGREYXRhU291cmNlKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlTWFwW2RhdGFTb3VyY2UuaWRdID0ge1xuICAgICAgICAgICAgYnVmZmVyaW5nVGltZTogZGF0YVNvdXJjZS5idWZmZXJpbmdUaW1lLFxuICAgICAgICAgICAgdGltZU91dDogZGF0YVNvdXJjZS50aW1lT3V0IHx8IDAsXG4gICAgICAgICAgICBkYXRhQnVmZmVyOiBbXSxcbiAgICAgICAgICAgIHN0YXJ0QnVmZmVyaW5nVGltZTogLTEsXG4gICAgICAgICAgICBpZDogZGF0YVNvdXJjZS5pZCxcbiAgICAgICAgICAgIHRpbWVkT3V0OiBmYWxzZSxcbiAgICAgICAgICAgIG5hbWU6IGRhdGFTb3VyY2UubmFtZSB8fCBkYXRhU291cmNlLmlkLFxuICAgICAgICAgICAgbGF0ZW5jeTogMCxcbiAgICAgICAgICAgIHN0YXR1czogU3RhdHVzLkRJU0NPTk5FQ1RFRCAvL01FQU5JTkcgRW5hYmxlZCwgMCA9IERpc2FibGVkXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgb25EYXRhKGRhdGFTb3VyY2VJZCwgZGF0YSkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgZGF0YVNvdXJjZSBzdGF0dXNcbiAgICAgKiBAcGFyYW0ge1N0YXR1c30gc3RhdHVzIC0gdGhlIG5ldyBzdGF0dXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVNvdXJjZUlkIC0gdGhlIGNvcnJlc3BvbmRpbmcgZGF0YVNvdXJjZSBpZFxuICAgICAqL1xuICAgIHNldFN0YXR1cyhkYXRhU291cmNlSWQsIHN0YXR1cykge1xuICAgICAgICBpZiAoZGF0YVNvdXJjZUlkIGluIHRoaXMuZGF0YVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlTWFwW2RhdGFTb3VyY2VJZF0uc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gU3RhdHVzLkRJU0NPTk5FQ1RFRCkge1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IGxhdGVuY3kgYW5kIGJ1ZmZlclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlSWRdLmxhdGVuY3kgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlSWRdLmRhdGFCdWZmZXIgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc29sZS53YXJuKHN0YXR1cysnIERhdGFTb3VyY2UgJyArIGRhdGFTb3VyY2VJZCArICcgZnJvbSB0aGUgc3luY2hyb25pemVyICcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5pbnRlcnZhbCkpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRhdGEgc3luY2hyb25pemVyIHRlcm1pbmF0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhU3luY2hyb25pemVyQWxnbztcbiIsImV4cG9ydCBjb25zdCBEQVRBX1NZTkNIUk9OSVpFUl9UT1BJQyA9ICdkYXRhLXN5bmNocm9uaXplci0nO1xuZXhwb3J0IGNvbnN0IFRJTUVfU1lOQ0hST05JWkVSX1RPUElDID0gJ2RhdGEtc3luY2hyb25pemVyLXRpbWUtJztcblxuZXhwb3J0IGNvbnN0IERBVEFTT1VSQ0VfREFUQV9UT1BJQyA9ICdkYXRhc291cmNlLWRhdGEtJztcbmV4cG9ydCBjb25zdCBEQVRBU09VUkNFX1RJTUVfVE9QSUMgPSAnZGF0YXNvdXJjZS10aW1lLSc7XG5cbmV4cG9ydCBjb25zdCBGRk1QRUdfVklFV19ERUNPREVfVE9QSUMgPSAnZmZtcGVnLWRlY29kZS0nO1xuIiwiZXhwb3J0IGNvbnN0IEV2ZW50VHlwZSA9IHtcbiAgICBEQVRBOiAnZGF0YScsXG4gICAgU1RBVFVTOiAnc3RhdHVzJ1xufTtcbiIsImltcG9ydCBEYXRhU3luY2hyb25pemVyQWxnbyBmcm9tIFwiLi9EYXRhU3luY2hyb25pemVyQWxnby5qc1wiO1xuaW1wb3J0IHtEQVRBU09VUkNFX0RBVEFfVE9QSUN9IGZyb20gXCIuLi9Db25zdGFudHMuanNcIjtcbmltcG9ydCB7RXZlbnRUeXBlfSBmcm9tIFwiLi4vZXZlbnQvRXZlbnRUeXBlLmpzXCI7XG5cbmNvbnN0IGJjQ2hhbm5lbHMgPSB7fTtcbmxldCBkYXRhU3luY2hyb25pemVyQWxnbztcblxubGV0IGluaXQgPSBmYWxzZTtcbmxldCBkYXRhU291cmNlQnJvYWRDYXN0Q2hhbm5lbCA9IG51bGw7XG5zZWxmLmN1cnJlbnRUaW1lID0gLTE7XG5cbmNvbnN0IGRhdGFTb3VyY2VzID0ge307XG5sZXQgdGltZUJyb2FkY2FzdENoYW5uZWwgPSBudWxsO1xuXG5zZWxmLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgIGlmKGV2ZW50LmRhdGEubWVzc2FnZSA9PT0gJ2luaXQnKSB7XG4gICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvID0gbmV3IERhdGFTeW5jaHJvbml6ZXJBbGdvKFxuICAgICAgICAgICAgZXZlbnQuZGF0YS5kYXRhU291cmNlcyxcbiAgICAgICAgICAgIGV2ZW50LmRhdGEucmVwbGF5U3BlZWQsXG4gICAgICAgICAgICBldmVudC5kYXRhLmludGVydmFsUmF0ZVxuICAgICAgICApO1xuICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5vbkRhdGEgPSBvbkRhdGE7XG4gICAgICAgIGluaXQgPSB0cnVlO1xuICAgICAgICBhZGREYXRhU291cmNlcyhldmVudC5kYXRhLmRhdGFTb3VyY2VzKTtcbiAgICAgICAgaW5pdEJyb2FkY2FzdENoYW5uZWwoZXZlbnQuZGF0YS5kYXRhVG9waWMsIGV2ZW50LmRhdGEudGltZVRvcGljKTtcbiAgICB9IGVsc2UgaWYoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnYWRkJyAmJiBldmVudC5kYXRhLmRhdGFTb3VyY2VzKSB7XG4gICAgICAgIGFkZERhdGFTb3VyY2VzKGV2ZW50LmRhdGEuZGF0YVNvdXJjZXMpO1xuICAgIH0gZWxzZSBpZihldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdjdXJyZW50LXRpbWUnKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ2N1cnJlbnQtdGltZScsXG4gICAgICAgICAgICBkYXRhOiBzZWxmLmN1cnJlbnRUaW1lXG4gICAgICAgIH0pO1xuICAgIH0gIGVsc2UgaWYoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAncmVzZXQnKSB7XG4gICAgICAgIGlmKGRhdGFTeW5jaHJvbml6ZXJBbGdvICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKGV2ZW50LmRhdGEubWVzc2FnZSA9PT0gJ3JlcGxheS1zcGVlZCcpIHtcbiAgICAgICAgaWYoZGF0YVN5bmNocm9uaXplckFsZ28gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnJlcGxheVNwZWVkID0gZXZlbnQuZGF0YS5yZXBsYXlTcGVlZDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZihldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdkYXRhJykge1xuICAgICAgICBpZihkYXRhU3luY2hyb25pemVyQWxnbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ucHVzaChldmVudC5kYXRhLmRhdGFTb3VyY2VJZCwge1xuICAgICAgICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEuZGF0YSxcbiAgICAgICAgICAgICAgICB0aW1lU3RhbXA6IGV2ZW50LmRhdGEudGltZVN0YW1wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdEJyb2FkY2FzdENoYW5uZWwoZGF0YVRvcGljLCB0aW1lVG9waWMpIHtcbiAgICBkYXRhU291cmNlQnJvYWRDYXN0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGRhdGFUb3BpYyk7XG4gICAgZGF0YVNvdXJjZUJyb2FkQ2FzdENoYW5uZWwub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmKGV2ZW50LmRhdGEudHlwZSA9PT0gRXZlbnRUeXBlLkRBVEEpIHtcbiAgICAgICAgICAgIGZvcihsZXQgaT0wOyBpIDwgZXZlbnQuZGF0YS52YWx1ZXMubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnB1c2goZXZlbnQuZGF0YS5kYXRhU291cmNlSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZXZlbnQuZGF0YS52YWx1ZXNbaV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKGV2ZW50LmRhdGEudHlwZSA9PT0gRXZlbnRUeXBlLlNUQVRVUykge1xuICAgICAgICAgICAgY29uc3QgZGF0YVNvdXJjZUlkID0gZXZlbnQuZGF0YS5kYXRhU291cmNlSWQ7XG4gICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5zZXRTdGF0dXMoZGF0YVNvdXJjZUlkLCBldmVudC5kYXRhLnN0YXR1cyk7XG4gICAgICAgICAgICAvLyBidWJibGUgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIGJjQ2hhbm5lbHNbZGF0YVNvdXJjZUlkXS5wb3N0TWVzc2FnZShldmVudC5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVCcm9hZGNhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwodGltZVRvcGljKTtcblxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gZGF0YVNvdXJjZXNcbiAqL1xuZnVuY3Rpb24gYWRkRGF0YVNvdXJjZXMoZGF0YVNvdXJjZXMpIHtcbiAgICBmb3IobGV0IGRhdGFTb3VyY2Ugb2YgZGF0YVNvdXJjZXMpIHtcbiAgICAgICAgYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZERhdGFTb3VyY2UoZGF0YVNvdXJjZSkge1xuICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLmFkZERhdGFTb3VyY2UoZGF0YVNvdXJjZSk7XG4gICAgLy8gY3JlYXRlIGEgQkMgdG8gcHVzaCBiYWNrIHRoZSBzeW5jaHJvbml6ZWQgZGF0YSBpbnRvIHRoZSBEQVRBIFN0cmVhbS5cbiAgICBiY0NoYW5uZWxzW2RhdGFTb3VyY2UuaWRdID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoREFUQVNPVVJDRV9EQVRBX1RPUElDICsgZGF0YVNvdXJjZS5pZCk7XG5cbiAgICBpZighKGRhdGFTb3VyY2UuaWQgaW4gZGF0YVNvdXJjZXMpKSB7XG4gICAgICAgIGRhdGFTb3VyY2VzW2RhdGFTb3VyY2UuaWRdID0gZGF0YVNvdXJjZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9uRGF0YShkYXRhU291cmNlSWQsIGRhdGEpIHtcbiAgICBzZWxmLmN1cnJlbnRUaW1lID0gZGF0YS50aW1lU3RhbXA7XG4gICAgYmNDaGFubmVsc1tkYXRhU291cmNlSWRdLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHZhbHVlczogW2RhdGFdLFxuICAgICAgICAgICAgZGF0YVNvdXJjZUlkLFxuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkRBVEFcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB0aW1lQnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHRpbWVzdGFtcDogZGF0YS50aW1lU3RhbXBcbiAgICB9KTtcbn1cblxuXG5zZWxmLm9uY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICBkYXRhU3luY2hyb25pemVyQWxnby5jbG9zZSgpO1xuICAgIGNvbnNvbGUubG9nKFwiRGF0YSBTeW5jaHJvbml6ZXIgaGFzIGJlZW4gdGVybWluYXRlZCBzdWNjZXNzZnVsbHlcIik7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")}]);