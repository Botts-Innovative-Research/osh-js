!function(){"use strict";function t(t){return null!=t}Math.pow(2,53);const a="disconnected";const e="data",s={};let i,r=!1,n=null;self.currentTime=-1;const u={};let o,d,l=null;function f(t){for(let a of t)c(a)}function c(t){i.addDataSource(t),s[t.id]=new BroadcastChannel("datasource-data-"+t.id),t.id in u||(u[t.id]=t)}function m(t,a){self.currentTime=a.timeStamp,s[t].postMessage({values:[a],dataSourceId:t,type:e}),l.postMessage({timestamp:a.timeStamp,dataSourceId:t,type:e})}self.onmessage=u=>{var c;"init"===u.data.message?(i=new class{constructor(t,a=1,e=5){this.dataSourceMap={},this.bufferingTime=1e3,this.startBufferingTime=-1,this.tsRun=0,this.replaySpeed=a,this.timerResolution=e;let s=-1;for(let a of t)this.addDataSource(a),s=a.bufferingTime>s?a.bufferingTime:s;-1!==s&&(this.bufferingTime=s)}push(t,e){const s=this.dataSourceMap[t];if(s.status===a)return;-1===this.startBufferingTime&&(console.log(`synchronizer buffering data for ${this.bufferingTime}ms..`),this.startBufferingTime=performance.now(),this.timeoutBuffering=setTimeout((()=>this.processData()),this.bufferingTime));let i=0;this.tsRun>0&&(i=this.tsRun-e.timeStamp),s.latency=i>s.latency?i:(s.latency+i)/2,s.dataBuffer.push(e)}reset(){console.log("reset synchronizer algo"),this.close();for(let t in this.dataSourceMap){const e=this.dataSourceMap[t];e.dataBuffer=[],e.startBufferingTime=-1,e.latency=0,e.status=a}this.tsRun=0,this.startBufferingTime=-1}processData(){if(!t(this.timeoutBuffering))return;let e,s=-1,i=performance.now();for(let t in this.dataSourceMap)e=this.dataSourceMap[t],e.status!==a&&e.dataBuffer.length>0&&(s=-1===s||e.dataBuffer[0].timeStamp<s?e.dataBuffer[0].timeStamp:s);this.interval=setInterval((()=>{for(;this.computeNextData(s,i););}),this.timerResolution)}computeNextData(t,e){let s,i=null,r=0,n=0;for(let t in this.dataSourceMap)if(s=this.dataSourceMap[t],s.status!==a&&s.latency>0){let t=Math.min(s.latency,s.timeOut);r=t>r?t:r,n=s.latency<n?s.latency:n}const u=performance.now()-e;this.tsRun=t+u;for(let e in this.dataSourceMap)s=this.dataSourceMap[e],s.status!==a&&s.dataBuffer.length>0&&s.dataBuffer[0].timeStamp-t<=(u-r)*this.replaySpeed&&(i=null===i?s:i.dataBuffer[0].timeStamp<s.dataBuffer[0].timeStamp?i:s);if(null!==i){let t=i.dataBuffer.shift();return t["@latency"]=s.latency-n,this.onData(i.id,t),!0}return!1}addDataSource(t){this.dataSourceMap[t.id]={bufferingTime:t.bufferingTime,timeOut:t.timeOut||0,dataBuffer:[],startBufferingTime:-1,id:t.id,timedOut:!1,name:t.name||t.id,latency:0,status:a}}onData(t,a){}setStatus(t,e){t in this.dataSourceMap&&(this.dataSourceMap[t].status=e,e===a&&(this.dataSourceMap[t].latency=0,this.dataSourceMap[t].dataBuffer=[]),console.warn(e+" DataSource "+t+" from the synchronizer "))}close(){t(this.interval)&&(clearInterval(this.interval),this.interval=null),t(this.timeoutBuffering)&&(clearTimeout(this.timeoutBuffering),this.timeoutBuffering=null),console.log("Data synchronizer terminated successfully")}}(u.data.dataSources,u.data.replaySpeed,u.data.timerResolution),i.onData=m,r=!0,f(u.data.dataSources),d=u.data.dataTopic,o=u.data.timeTopic,c=o,n=new BroadcastChannel(d),n.onmessage=t=>{if(t.data.type===e)for(let a=0;a<t.data.values.length;a++)i.push(t.data.dataSourceId,{...t.data.values[a]});else if("status"===t.data.type){const a=t.data.dataSourceId;i.setStatus(a,t.data.status),s[a].postMessage(t.data)}},l=new BroadcastChannel(c)):"add"===u.data.message&&u.data.dataSources?f(u.data.dataSources):"current-time"===u.data.message?self.postMessage({message:"current-time",data:self.currentTime}):"reset"===u.data.message?(null!==i&&i.reset(),l.postMessage({type:"time-changed"})):"replay-speed"===u.data.message?null!==i&&(i.replaySpeed=u.data.replaySpeed):"data"===u.data.message&&null!==i&&i.push(u.data.dataSourceId,{data:u.data.data,timeStamp:u.data.timeStamp})},self.onclose=function(){i.close(),console.log("Data Synchronizer has been terminated successfully")}}();