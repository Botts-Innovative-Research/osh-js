!function(Q){var B={};function F(I){if(B[I])return B[I].exports;var U=B[I]={i:I,l:!1,exports:{}};return Q[I].call(U.exports,U,U.exports,F),U.l=!0,U.exports}F.m=Q,F.c=B,F.d=function(Q,B,I){F.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:I})},F.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},F.t=function(Q,B){if(1&B&&(Q=F(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var I=Object.create(null);if(F.r(I),Object.defineProperty(I,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var U in Q)F.d(I,U,function(B){return Q[B]}.bind(null,U));return I},F.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return F.d(B,"a",B),B},F.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},F.p="",F(F.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/utils/Utils.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n/** * @module Utils */\n\n/** Maximum value of a long */\nconst MAX_LONG = Math.pow(2, 53) + 1;\n/**\n * Global helper method to test if a letiable or object attribute is defined\n */\n\nfunction isDefined(v) {\n  return typeof v !== 'undefined' && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute has a value,\n that is it is defined and non null\n */\n\nfunction hasValue(v) {\n  return isDefined(v) && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute is of a particular type\n */\n\nfunction hasType(v, expectedType) {\n  let hasVal = hasValue(v);\n  return hasVal && typeof v === expectedType;\n}\n/**\n Global helper method to test if a letiable or object attribute is an object\n */\n\nfunction isObject(v, letName) {\n  return hasType(v, 'object', letName);\n}\n/**\n Global helper method to test if a letiable or object attribute is an array\n */\n\nfunction isArray(v) {\n  return isDefined(v) && Array.isArray(v);\n}\n/**\n Global helper method to test if a letiable or object attribute is a function\n */\n\nfunction isFunction(v, letName) {\n  return hasType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined\n **/\n\nfunction assertDefined(v, letName = 'letiable') {\n  if (!isDefined(v)) {\n    throw letName + \" must be defined\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertType(v, expectedType, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (typeof v !== expectedType) {\n    throw letName + \" must be of type \" + expectedType;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertBoolean(v, letName) {\n  return assertType(v, 'boolean', letName);\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertString(v, letName) {\n  return assertType(v, 'string', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertNumber(v, letName) {\n  return assertType(v, 'number', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertPositive(v, letName) {\n  assertNumber(v, letName);\n\n  if (v <= 0) {\n    throw letName + \" must be a positive number\";\n  }\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertObject(v, letName) {\n  return assertType(v, 'object', letName);\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertArray(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!Array.isArray(v)) {\n    throw letName + \" must be an array\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a function\n **/\n\nfunction assertFunction(v, letName) {\n  return assertType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertHasValue(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!hasValue(v)) {\n    throw letName + \" must not be null\";\n  }\n\n  return v;\n}\n/**\n *\n * @return {String}\n */\n\nfunction randomUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * This function stamps/embeds a UUID into an object and returns the UUID generated for it\n * @return {String}\n */\n\nfunction stampUUID(obj) {\n  obj._osh_id = obj._osh_id || randomUUID();\n  return obj._osh_id;\n} //buffer is an ArrayBuffer object, the offset if specified in bytes, and the type is a string\n//corresponding to an OGC data type.\n//See http://def.seegrid.csiro.au/sissvoc/ogc-def/resource?uri=http://www.opengis.net/def/dataType/OGC/0/\n\n/**\n *\n * @param buffer\n * @param offset\n * @param type\n * @return {*}\n */\n\nfunction ParseBytes(buffer, offset, type) {\n  let view = new DataView(buffer); //Note: There exist types not listed in the map below that have OGC definitions, but no appropriate\n  //methods or corresponding types available for parsing in javascript. They are float128, float16, signedLong,\n  //and unsignedLong\n\n  let typeMap = {\n    double: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float64: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float32: function (offset) {\n      return {\n        val: view.getFloat32(offset),\n        bytes: 4\n      };\n    },\n    signedByte: function (offset) {\n      return {\n        val: view.getInt8(offset),\n        bytes: 1\n      };\n    },\n    signedInt: function (offset) {\n      return {\n        val: view.getInt32(offset),\n        bytes: 4\n      };\n    },\n    signedShort: function (offset) {\n      return {\n        val: view.getInt16(offset),\n        bytes: 2\n      };\n    },\n    unsignedByte: function (offset) {\n      return {\n        val: view.getUint8(offset),\n        bytes: 1\n      };\n    },\n    unsignedInt: function (offset) {\n      return {\n        val: view.getUint32(offset),\n        bytes: 4\n      };\n    },\n    unsignedShort: function (offset) {\n      return {\n        val: view.getUint16(offset),\n        bytes: 2\n      };\n    } //TODO: string-utf-8:\n\n  };\n  return typeMap[type](offset);\n} //This function recursivley iterates over the resultStructure to fill in\n//values read from data which should be an ArrayBuffer containing the payload from a websocket\n\n/**\n *\n * @param struct\n * @param data\n * @param offsetBytes\n * @return {*}\n */\n\nfunction ReadData(struct, data, offsetBytes) {\n  let offset = offsetBytes;\n\n  for (let i = 0; i < struct.fields.length; i++) {\n    let currFieldStruct = struct.fields[i];\n\n    if (isDefined(currFieldStruct.type) && currFieldStruct.type !== null) {\n      let ret = ParseBytes(data, offset, currFieldStruct.type);\n      currFieldStruct.val = ret.val;\n      offset += ret.bytes;\n    } else if (isDefined(currFieldStruct.count) && currFieldStruct.count !== null) {\n      //check if count is a reference to another letiable\n      if (isNaN(currFieldStruct.count)) {\n        let id = currFieldStruct.count;\n        let fieldName = struct.id2FieldMap[id];\n        currFieldStruct.count = struct.findFieldByName(fieldName).val;\n      }\n\n      for (let c = 0; c < currFieldStruct.count; c++) {\n        for (let j = 0; j < currFieldStruct.fields.length; j++) {\n          let field = JSON.parse(JSON.stringify(currFieldStruct.fields[j]));\n          offset = ReadData(field, data, offset);\n          currFieldStruct.val.push(field);\n        }\n      }\n    }\n  }\n\n  return offset;\n}\n/**\n *\n * @param resultStructure\n * @return {{}}\n */\n\nfunction GetResultObject(resultStructure) {\n  //TODO: handle cases for nested arrays / matrix data types\n  let result = {};\n\n  for (let i = 0; i < resultStructure.fields.length; i++) {\n    if (isDefined(resultStructure.fields[i].count)) {\n      result[resultStructure.fields[i].name] = [];\n\n      for (let c = 0; c < resultStructure.fields[i].count; c++) {\n        let item = {};\n\n        for (let k = 0; k < resultStructure.fields[i].val[c].fields.length; k++) {\n          item[resultStructure.fields[i].val[c].fields[k].name] = resultStructure.fields[i].val[c].fields[k].val;\n        }\n\n        result[resultStructure.fields[i].name].push(item);\n      }\n    } else {\n      result[resultStructure.fields[i].name] = resultStructure.fields[i].val;\n    }\n  }\n\n  return result;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isOpera() {\n  return !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isFirefox() {\n  return typeof InstallTrigger !== 'undefined';\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isSafari() {\n  return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isChrome() {\n  return !!window.chrome && !!window.chrome.webstore;\n}\n/**\n *\n * @return {*|boolean}\n */\n\nfunction isBlink() {\n  return (isChrome || isOpera) && !!window.CSS;\n}\n/**\n *\n * @param a\n * @param b\n * @return {boolean}\n */\n\nfunction isArrayIntersect(a, b) {\n  return a.filter(function (element) {\n    return b.indexOf(element) > -1;\n  }).length > 0;\n}\n/**\n *\n * @param o\n * @return {boolean}\n */\n\nfunction isElement(o) {\n  return typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n  o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n}\n/**\n *\n * @return {*}\n */\n\nfunction isWebWorker() {\n  return isDefined(Worker);\n}\n/**\n *\n * @param div\n */\n\nfunction takeScreenShot(div) {}\n/**\n * Remove a css class from a the div given as argument.\n * @param div the div to remove the class from\n * @param css the css class to remove\n */\n\nfunction removeCss(div, css) {\n  let divCss = div.className;\n  css = divCss.replace(css, \"\");\n  div.className = css;\n}\n/**\n * Add a css class to a the div given as argument.\n * @param div the div to add the class to\n * @param css the css class to add\n */\n\nfunction addCss(div, css) {\n  div.setAttribute(\"class\", div.className + \" \" + css);\n}\n/**\n * Removes the last character of a {string} object.\n * @param {string} value - The input {string}\n * @return {string} The value without the last character\n */\n\nfunction removeLastCharIfExist(value) {\n  if (!isDefined(undefined) || value === null || value.length === 0 || !value.endsWith(\"/\")) {\n    return value;\n  }\n\n  return value.substring(0, value.length - 1);\n}\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/datasynchronizer/DataSynchronizerAlgo.js\n\n\nclass DataSynchronizerAlgo_DataSynchronizerAlgo {\n  constructor(dataSources, replayFactor = 1, intervalRate = 5) {\n    this.dataSourceMap = {};\n    this.bufferingTime = 1000;\n    this.startBufferingTime = -1;\n    this.tsRun = 0;\n    this.replayFactor = replayFactor;\n    this.intervalRate = intervalRate;\n    let maxBufferingTime = -1;\n\n    for (let ds of dataSources) {\n      this.addDataSource(ds);\n      maxBufferingTime = ds.bufferingTime > maxBufferingTime ? ds.bufferingTime : maxBufferingTime;\n    }\n\n    if (maxBufferingTime !== -1) {\n      this.bufferingTime = maxBufferingTime;\n    }\n  }\n\n  push(dataSourceId, data) {\n    const ds = this.dataSourceMap[dataSourceId];\n\n    if (this.startBufferingTime === -1) {\n      this.startBufferingTime = performance.now(); // start iterating on data after bufferingTime\n\n      setTimeout(() => this.processData(), this.bufferingTime);\n    }\n\n    let latency = 0;\n\n    if (this.tsRun > 0) {\n      latency = this.tsRun - data.timeStamp;\n    }\n\n    ds.latency = latency > ds.latency ? latency : (ds.latency + latency) / 2;\n    ds.dataBuffer.push(data);\n  }\n\n  reset() {\n    this.close();\n\n    for (let currentDsId in this.dataSourceMap) {\n      const currentDs = this.dataSourceMap[currentDsId];\n      currentDs.dataBuffer = [];\n    }\n\n    this.startBufferingTime = -1;\n  }\n\n  processData() {\n    let tsRef = -1;\n    let clockTimeRef = performance.now(); // get reference start timestamp\n    // the reference start timestamp should the oldest one\n\n    let currentDs;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.dataBuffer.length > 0) {\n        tsRef = tsRef === -1 || currentDs.dataBuffer[0].timeStamp < tsRef ? currentDs.dataBuffer[0].timeStamp : tsRef;\n      }\n    }\n\n    this.interval = setInterval(() => {\n      // 1) return the oldest data if any\n      while (this.computeNextData(tsRef, clockTimeRef));\n    }, this.intervalRate);\n  }\n  /**\n   * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,\n   * we return only the oldest one.\n   * @param tsRef - the timestamp of the first data\n   * @param refClockTime - the absolute diff time really spent\n   */\n\n\n  computeNextData(tsRef, refClockTime) {\n    let currentDs;\n    let currentDsToShift = null; // compute max latency\n\n    let maxLatency = 0;\n    let minLatency;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.latency > 0) {\n        let latency = Math.min(currentDs.latency, currentDs.timeOut);\n        maxLatency = latency > maxLatency ? latency : maxLatency;\n        minLatency = currentDs.latency < minLatency ? currentDs.latency : minLatency;\n      }\n    }\n\n    const dClock = performance.now() - refClockTime;\n    this.tsRun = tsRef + dClock; // compute next data to return\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.dataBuffer.length > 0) {\n        const dTs = currentDs.dataBuffer[0].timeStamp - tsRef;\n        const dClockAdj = dClock - maxLatency; // we use an intermediate object to store the data to shift because we want to return the oldest one\n        // only\n\n        if (dTs <= dClockAdj * this.replayFactor) {\n          // no other one to compare\n          if (currentDsToShift === null) {\n            currentDsToShift = currentDs;\n          } else {\n            // take the oldest data\n            currentDsToShift = currentDsToShift.dataBuffer[0].timeStamp < currentDs.dataBuffer[0].timeStamp ? currentDsToShift : currentDs;\n          }\n        }\n      }\n    } // finally pop the data from DS queue\n\n\n    if (currentDsToShift !== null) {\n      let rec = currentDsToShift.dataBuffer.shift(); // add latency flag to data record before we dispatch it\n      // this is relative latency in millis compared to the DS with the lowest latency\n      // so it is accurate even if local device time is not set properly\n\n      rec['@latency'] = currentDs.latency - minLatency;\n      this.onData(currentDsToShift.id, rec);\n      return true;\n    }\n\n    return false;\n  }\n\n  addDataSource(dataSource) {\n    this.dataSourceMap[dataSource.id] = {\n      bufferingTime: dataSource.bufferingTime,\n      timeOut: dataSource.timeOut || 0,\n      dataBuffer: [],\n      startBufferingTime: -1,\n      id: dataSource.id,\n      timedOut: false,\n      name: dataSource.name || dataSource.id,\n      latency: 0\n    };\n  }\n\n  onData(dataSourceId, data) {}\n\n  close() {\n    if (isDefined(this.interval)) {\n      clearInterval(this.interval);\n      console.log(\"Data synchronizer terminated successfully\");\n    }\n  }\n\n}\n\n/* harmony default export */ var datasynchronizer_DataSynchronizerAlgo = (DataSynchronizerAlgo_DataSynchronizerAlgo);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/Constants.js\nconst DATA_SYNCHRONIZER_TOPIC = 'data-synchronizer-';\nconst DATASOURCE_DATA_TOPIC = 'datasource-data-';\nconst FFMPEG_VIEW_DECODE_TOPIC = 'ffmpeg-decode-';\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/datasynchronizer/DataSynchronizer.worker.js\n\n\n\nconst bcChannels = {};\nlet dataSynchronizerAlgo;\n\nlet init = false;\nlet dataSourceBroadCastChannel = null;\nself.currentTime = -1;\n\nself.onmessage = (event) => {\n    if(event.data.message === 'init') {\n        dataSynchronizerAlgo = new datasynchronizer_DataSynchronizerAlgo(\n            event.data.dataSources,\n            event.data.replayFactor,\n            event.data.intervalRate\n        );\n        dataSynchronizerAlgo.onData = onData;\n        init = true;\n        addDataSources(event.data.dataSources);\n        dataSourceBroadCastChannel = new BroadcastChannel(event.data.topic);\n        dataSourceBroadCastChannel.onmessage = (event) => {\n            dataSynchronizerAlgo.push(event.data.dataSourceId, {\n                data: event.data.data,\n                timeStamp: event.data.timeStamp\n            });\n        }\n    } else if(event.data.message === 'add' && event.data.dataSources) {\n        addDataSources(event.data.dataSources);\n    } else if(event.data.message === 'current-time') {\n        self.postMessage({\n            message: 'current-time',\n            data: self.currentTime\n        });\n    }  else if(event.data.message === 'reset') {\n        dataSynchronizerAlgo.reset();\n    } else if(dataSynchronizerAlgo !== null) {\n        dataSynchronizerAlgo.push(event.data.dataSourceId, event.data.data);\n    }\n}\n\nfunction addDataSources(dataSources) {\n    for(let ds of dataSources) {\n        dataSynchronizerAlgo.addDataSource(ds);\n        bcChannels[ds.id] = new BroadcastChannel(DATASOURCE_DATA_TOPIC + ds.id);\n    }\n}\n\nfunction onData(dataSourceId, data) {\n    self.currentTime = data.timeStamp;\n    bcChannels[dataSourceId].postMessage({\n        message: 'data',\n        dataSourceId: dataSourceId,\n        ...data\n    });\n}\n\n\nself.onclose = function() {\n    dataSynchronizerAlgo.close();\n    console.log(\"Data Synchronizer has been terminated successfully\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2Uvb3NoL3V0aWxzL1V0aWxzLmpzPzI0M2EiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL29zaC9kYXRhc3luY2hyb25pemVyL0RhdGFTeW5jaHJvbml6ZXJBbGdvLmpzP2Q3NzciLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL29zaC9Db25zdGFudHMuanM/ZGJmNyIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2Uvb3NoL2RhdGFzeW5jaHJvbml6ZXIvRGF0YVN5bmNocm9uaXplci53b3JrZXIuanM/NDI4MCJdLCJuYW1lcyI6WyJNQVhfTE9ORyIsIk1hdGgiLCJwb3ciLCJpc0RlZmluZWQiLCJ2IiwiaGFzVmFsdWUiLCJoYXNUeXBlIiwiZXhwZWN0ZWRUeXBlIiwiaGFzVmFsIiwiaXNPYmplY3QiLCJsZXROYW1lIiwiaXNBcnJheSIsIkFycmF5IiwiaXNGdW5jdGlvbiIsImFzc2VydERlZmluZWQiLCJhc3NlcnRUeXBlIiwiYXNzZXJ0Qm9vbGVhbiIsImFzc2VydFN0cmluZyIsImFzc2VydE51bWJlciIsImFzc2VydFBvc2l0aXZlIiwiYXNzZXJ0T2JqZWN0IiwiYXNzZXJ0QXJyYXkiLCJhc3NlcnRGdW5jdGlvbiIsImFzc2VydEhhc1ZhbHVlIiwicmFuZG9tVVVJRCIsInJlcGxhY2UiLCJjIiwiciIsInJhbmRvbSIsInRvU3RyaW5nIiwic3RhbXBVVUlEIiwib2JqIiwiX29zaF9pZCIsIlBhcnNlQnl0ZXMiLCJidWZmZXIiLCJvZmZzZXQiLCJ0eXBlIiwidmlldyIsIkRhdGFWaWV3IiwidHlwZU1hcCIsImRvdWJsZSIsInZhbCIsImdldEZsb2F0NjQiLCJieXRlcyIsImZsb2F0NjQiLCJmbG9hdDMyIiwiZ2V0RmxvYXQzMiIsInNpZ25lZEJ5dGUiLCJnZXRJbnQ4Iiwic2lnbmVkSW50IiwiZ2V0SW50MzIiLCJzaWduZWRTaG9ydCIsImdldEludDE2IiwidW5zaWduZWRCeXRlIiwiZ2V0VWludDgiLCJ1bnNpZ25lZEludCIsImdldFVpbnQzMiIsInVuc2lnbmVkU2hvcnQiLCJnZXRVaW50MTYiLCJSZWFkRGF0YSIsInN0cnVjdCIsImRhdGEiLCJvZmZzZXRCeXRlcyIsImkiLCJmaWVsZHMiLCJsZW5ndGgiLCJjdXJyRmllbGRTdHJ1Y3QiLCJyZXQiLCJjb3VudCIsImlzTmFOIiwiaWQiLCJmaWVsZE5hbWUiLCJpZDJGaWVsZE1hcCIsImZpbmRGaWVsZEJ5TmFtZSIsImoiLCJmaWVsZCIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInB1c2giLCJHZXRSZXN1bHRPYmplY3QiLCJyZXN1bHRTdHJ1Y3R1cmUiLCJyZXN1bHQiLCJuYW1lIiwiaXRlbSIsImsiLCJpc09wZXJhIiwid2luZG93Iiwib3ByIiwiYWRkb25zIiwib3BlcmEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmRleE9mIiwiaXNGaXJlZm94IiwiSW5zdGFsbFRyaWdnZXIiLCJpc1NhZmFyaSIsIk9iamVjdCIsInByb3RvdHlwZSIsImNhbGwiLCJIVE1MRWxlbWVudCIsImlzQ2hyb21lIiwiY2hyb21lIiwid2Vic3RvcmUiLCJpc0JsaW5rIiwiQ1NTIiwiaXNBcnJheUludGVyc2VjdCIsImEiLCJiIiwiZmlsdGVyIiwiZWxlbWVudCIsImlzRWxlbWVudCIsIm8iLCJub2RlVHlwZSIsIm5vZGVOYW1lIiwiaXNXZWJXb3JrZXIiLCJXb3JrZXIiLCJ0YWtlU2NyZWVuU2hvdCIsImRpdiIsInJlbW92ZUNzcyIsImNzcyIsImRpdkNzcyIsImNsYXNzTmFtZSIsImFkZENzcyIsInNldEF0dHJpYnV0ZSIsInJlbW92ZUxhc3RDaGFySWZFeGlzdCIsInZhbHVlIiwidW5kZWZpbmVkIiwiZW5kc1dpdGgiLCJzdWJzdHJpbmciLCJEYXRhU3luY2hyb25pemVyQWxnbyIsImNvbnN0cnVjdG9yIiwiZGF0YVNvdXJjZXMiLCJyZXBsYXlGYWN0b3IiLCJpbnRlcnZhbFJhdGUiLCJkYXRhU291cmNlTWFwIiwiYnVmZmVyaW5nVGltZSIsInN0YXJ0QnVmZmVyaW5nVGltZSIsInRzUnVuIiwibWF4QnVmZmVyaW5nVGltZSIsImRzIiwiYWRkRGF0YVNvdXJjZSIsImRhdGFTb3VyY2VJZCIsInBlcmZvcm1hbmNlIiwibm93Iiwic2V0VGltZW91dCIsInByb2Nlc3NEYXRhIiwibGF0ZW5jeSIsInRpbWVTdGFtcCIsImRhdGFCdWZmZXIiLCJyZXNldCIsImNsb3NlIiwiY3VycmVudERzSWQiLCJjdXJyZW50RHMiLCJ0c1JlZiIsImNsb2NrVGltZVJlZiIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjb21wdXRlTmV4dERhdGEiLCJyZWZDbG9ja1RpbWUiLCJjdXJyZW50RHNUb1NoaWZ0IiwibWF4TGF0ZW5jeSIsIm1pbkxhdGVuY3kiLCJtaW4iLCJ0aW1lT3V0IiwiZENsb2NrIiwiZFRzIiwiZENsb2NrQWRqIiwicmVjIiwic2hpZnQiLCJvbkRhdGEiLCJkYXRhU291cmNlIiwidGltZWRPdXQiLCJjbGVhckludGVydmFsIiwiY29uc29sZSIsImxvZyIsIkRBVEFfU1lOQ0hST05JWkVSX1RPUElDIiwiREFUQVNPVVJDRV9EQVRBX1RPUElDIiwiRkZNUEVHX1ZJRVdfREVDT0RFX1RPUElDIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7O0FBRUE7QUFDTyxNQUFNQSxRQUFRLEdBQUdDLElBQUksQ0FBQ0MsR0FBTCxDQUFTLENBQVQsRUFBWSxFQUFaLElBQWtCLENBQW5DO0FBRVA7Ozs7QUFHTyxTQUFTQyxTQUFULENBQW1CQyxDQUFuQixFQUFzQjtBQUN6QixTQUFPLE9BQVFBLENBQVIsS0FBZSxXQUFmLElBQThCQSxDQUFDLEtB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QUcsZ0JBQWpDLEM7O0FDRm1EO0FBQ2tCOztBQUU1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLHFDQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHFCQUFxQjtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gVGhlIGNvbnRlbnRzIG9mIHRoaXMgZmlsZSBhcmUgc3ViamVjdCB0byB0aGUgTW96aWxsYSBQdWJsaWMgTGljZW5zZSwgdi4gMi4wLlxuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZVxuIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblxuIFNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2VcbiBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyByaWdodHMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gQ29weXJpZ2h0IChDKSAyMDE1LTIwMjAgTWF0aGlldSBEaGFpbmF1dC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuIEF1dGhvcjogTWF0aGlldSBEaGFpbmF1dCA8bWF0aGlldS5kaGFpbmF1dEBnbWFpbC5jb20+XG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqICogQG1vZHVsZSBVdGlscyAqL1xuXG4vKiogTWF4aW11bSB2YWx1ZSBvZiBhIGxvbmcgKi9cbmV4cG9ydCBjb25zdCBNQVhfTE9ORyA9IE1hdGgucG93KDIsIDUzKSArIDE7XG5cbi8qKlxuICogR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbmVkKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mICh2KSAhPT0gJ3VuZGVmaW5lZCcgJiYgdiAhPT0gbnVsbDtcbn1cblxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBoYXMgYSB2YWx1ZSxcbiB0aGF0IGlzIGl0IGlzIGRlZmluZWQgYW5kIG5vbiBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNWYWx1ZSh2KSB7XG4gICAgcmV0dXJuIGlzRGVmaW5lZCh2KSAmJiB2ICE9PSBudWxsO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBvZiBhIHBhcnRpY3VsYXIgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzVHlwZSh2LCBleHBlY3RlZFR5cGUpIHtcbiAgICBsZXQgaGFzVmFsID0gaGFzVmFsdWUodik7XG4gICAgcmV0dXJuIGhhc1ZhbCAmJiB0eXBlb2YgKHYpID09PSBleHBlY3RlZFR5cGU7XG59XG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBoYXNUeXBlKHYsICdvYmplY3QnLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkodikge1xuICAgIHJldHVybiBpc0RlZmluZWQodikgJiYgQXJyYXkuaXNBcnJheSh2KTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGhhc1R5cGUodiwgJ2Z1bmN0aW9uJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGlmICghaXNEZWZpbmVkKHYpKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIGRlZmluZWRcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkIGFuZCBub24tbnVsbFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFR5cGUodiwgZXhwZWN0ZWRUeXBlLCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKHR5cGVvZiAodikgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBiZSBvZiB0eXBlIFwiICsgZXhwZWN0ZWRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgc3RyaW5nXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Qm9vbGVhbih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ2Jvb2xlYW4nLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgc3RyaW5nXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U3RyaW5nKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnc3RyaW5nJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIG51bWJlclxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE51bWJlcih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ251bWJlcicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBudW1iZXJcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRQb3NpdGl2ZSh2LCBsZXROYW1lKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHYsIGxldE5hbWUpO1xuICAgIGlmICh2IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIjtcbiAgICB9XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBvYmplY3RcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRPYmplY3QodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdvYmplY3QnLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIG9iamVjdFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFycmF5KHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgYW4gYXJyYXlcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIGZ1bmN0aW9uXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb24odiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdmdW5jdGlvbicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBhbmQgbm9uLW51bGxcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRIYXNWYWx1ZSh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKCFoYXNWYWx1ZSh2KSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBub3QgYmUgbnVsbFwiO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tVVVJRCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICBsZXQgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBzdGFtcHMvZW1iZWRzIGEgVVVJRCBpbnRvIGFuIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgVVVJRCBnZW5lcmF0ZWQgZm9yIGl0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFtcFVVSUQob2JqKSB7XG4gICAgb2JqLl9vc2hfaWQgPSBvYmouX29zaF9pZCB8fCByYW5kb21VVUlEKCk7XG4gICAgcmV0dXJuIG9iai5fb3NoX2lkO1xufVxuXG4vL2J1ZmZlciBpcyBhbiBBcnJheUJ1ZmZlciBvYmplY3QsIHRoZSBvZmZzZXQgaWYgc3BlY2lmaWVkIGluIGJ5dGVzLCBhbmQgdGhlIHR5cGUgaXMgYSBzdHJpbmdcbi8vY29ycmVzcG9uZGluZyB0byBhbiBPR0MgZGF0YSB0eXBlLlxuLy9TZWUgaHR0cDovL2RlZi5zZWVncmlkLmNzaXJvLmF1L3Npc3N2b2Mvb2djLWRlZi9yZXNvdXJjZT91cmk9aHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9kZWYvZGF0YVR5cGUvT0dDLzAvXG4vKipcbiAqXG4gKiBAcGFyYW0gYnVmZmVyXG4gKiBAcGFyYW0gb2Zmc2V0XG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFBhcnNlQnl0ZXMoYnVmZmVyLCBvZmZzZXQsIHR5cGUpIHtcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuXG4gICAgLy9Ob3RlOiBUaGVyZSBleGlzdCB0eXBlcyBub3QgbGlzdGVkIGluIHRoZSBtYXAgYmVsb3cgdGhhdCBoYXZlIE9HQyBkZWZpbml0aW9ucywgYnV0IG5vIGFwcHJvcHJpYXRlXG4gICAgLy9tZXRob2RzIG9yIGNvcnJlc3BvbmRpbmcgdHlwZXMgYXZhaWxhYmxlIGZvciBwYXJzaW5nIGluIGphdmFzY3JpcHQuIFRoZXkgYXJlIGZsb2F0MTI4LCBmbG9hdDE2LCBzaWduZWRMb25nLFxuICAgIC8vYW5kIHVuc2lnbmVkTG9uZ1xuICAgIGxldCB0eXBlTWFwID0ge1xuICAgICAgICBkb3VibGU6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEZsb2F0NjQob2Zmc2V0KSwgYnl0ZXM6IDh9O1xuICAgICAgICB9LFxuICAgICAgICBmbG9hdDY0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRGbG9hdDY0KG9mZnNldCksIGJ5dGVzOiA4fTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXQzMjogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0RmxvYXQzMihvZmZzZXQpLCBieXRlczogNH07XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25lZEJ5dGU6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDgob2Zmc2V0KSwgYnl0ZXM6IDF9O1xuICAgICAgICB9LFxuICAgICAgICBzaWduZWRJbnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDMyKG9mZnNldCksIGJ5dGVzOiA0fTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmVkU2hvcnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDE2KG9mZnNldCksIGJ5dGVzOiAyfTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaWduZWRCeXRlOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50OChvZmZzZXQpLCBieXRlczogMX07XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2lnbmVkSW50OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50MzIob2Zmc2V0KSwgYnl0ZXM6IDR9O1xuICAgICAgICB9LFxuICAgICAgICB1bnNpZ25lZFNob3J0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50MTYob2Zmc2V0KSwgYnl0ZXM6IDJ9O1xuICAgICAgICB9LFxuICAgICAgICAvL1RPRE86IHN0cmluZy11dGYtODpcbiAgICB9O1xuICAgIHJldHVybiB0eXBlTWFwW3R5cGVdKG9mZnNldCk7XG59XG5cbi8vVGhpcyBmdW5jdGlvbiByZWN1cnNpdmxleSBpdGVyYXRlcyBvdmVyIHRoZSByZXN1bHRTdHJ1Y3R1cmUgdG8gZmlsbCBpblxuLy92YWx1ZXMgcmVhZCBmcm9tIGRhdGEgd2hpY2ggc2hvdWxkIGJlIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgdGhlIHBheWxvYWQgZnJvbSBhIHdlYnNvY2tldFxuLyoqXG4gKlxuICogQHBhcmFtIHN0cnVjdFxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBvZmZzZXRCeXRlc1xuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlYWREYXRhKHN0cnVjdCwgZGF0YSwgb2Zmc2V0Qnl0ZXMpIHtcbiAgICBsZXQgb2Zmc2V0ID0gb2Zmc2V0Qnl0ZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJ1Y3QuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjdXJyRmllbGRTdHJ1Y3QgPSBzdHJ1Y3QuZmllbGRzW2ldO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKGN1cnJGaWVsZFN0cnVjdC50eXBlKSAmJiBjdXJyRmllbGRTdHJ1Y3QudHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJldCA9IFBhcnNlQnl0ZXMoZGF0YSwgb2Zmc2V0LCBjdXJyRmllbGRTdHJ1Y3QudHlwZSk7XG4gICAgICAgICAgICBjdXJyRmllbGRTdHJ1Y3QudmFsID0gcmV0LnZhbDtcbiAgICAgICAgICAgIG9mZnNldCArPSByZXQuYnl0ZXM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWZpbmVkKGN1cnJGaWVsZFN0cnVjdC5jb3VudCkgJiYgY3VyckZpZWxkU3RydWN0LmNvdW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvL2NoZWNrIGlmIGNvdW50IGlzIGEgcmVmZXJlbmNlIHRvIGFub3RoZXIgbGV0aWFibGVcbiAgICAgICAgICAgIGlmIChpc05hTihjdXJyRmllbGRTdHJ1Y3QuY291bnQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gY3VyckZpZWxkU3RydWN0LmNvdW50O1xuICAgICAgICAgICAgICAgIGxldCBmaWVsZE5hbWUgPSBzdHJ1Y3QuaWQyRmllbGRNYXBbaWRdO1xuICAgICAgICAgICAgICAgIGN1cnJGaWVsZFN0cnVjdC5jb3VudCA9IHN0cnVjdC5maW5kRmllbGRCeU5hbWUoZmllbGROYW1lKS52YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGN1cnJGaWVsZFN0cnVjdC5jb3VudDsgYysrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjdXJyRmllbGRTdHJ1Y3QuZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY3VyckZpZWxkU3RydWN0LmZpZWxkc1tqXSkpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBSZWFkRGF0YShmaWVsZCwgZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY3VyckZpZWxkU3RydWN0LnZhbC5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHJlc3VsdFN0cnVjdHVyZVxuICogQHJldHVybiB7e319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBHZXRSZXN1bHRPYmplY3QocmVzdWx0U3RydWN0dXJlKSB7XG4gICAgLy9UT0RPOiBoYW5kbGUgY2FzZXMgZm9yIG5lc3RlZCBhcnJheXMgLyBtYXRyaXggZGF0YSB0eXBlc1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLmNvdW50KSkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0ubmFtZV0gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5jb3VudDsgYysrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtW3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkc1trXS5uYW1lXSA9IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkc1trXS52YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLm5hbWVdLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5uYW1lXSA9IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09wZXJhKCkge1xuICAgIHJldHVybiAoISF3aW5kb3cub3ByICYmICEhb3ByLmFkZG9ucykgfHwgISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDA7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpcmVmb3goKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdy5IVE1MRWxlbWVudCkuaW5kZXhPZignQ29uc3RydWN0b3InKSA+IDA7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Nocm9tZSgpIHtcbiAgICByZXR1cm4gISF3aW5kb3cuY2hyb21lICYmICEhd2luZG93LmNocm9tZS53ZWJzdG9yZTtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Knxib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCbGluaygpIHtcbiAgICByZXR1cm4gKGlzQ2hyb21lIHx8IGlzT3BlcmEpICYmICEhd2luZG93LkNTUztcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGFcbiAqIEBwYXJhbSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUludGVyc2VjdChhLCBiKSB7XG4gICAgcmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBiLmluZGV4T2YoZWxlbWVudCkgPiAtMTtcbiAgICB9KS5sZW5ndGggPiAwO1xufVxuXG5cbi8qKlxuICpcbiAqIEBwYXJhbSBvXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50KG8pIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIEhUTUxFbGVtZW50ID09PSBcIm9iamVjdFwiID8gbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogLy9ET00yXG4gICAgICAgIG8gJiYgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgbyAhPT0gbnVsbCAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSBcInN0cmluZ1wiXG4gICAgKTtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzV2ViV29ya2VyKCkge1xuICAgIHJldHVybiBpc0RlZmluZWQoV29ya2VyKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGRpdlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFrZVNjcmVlblNob3QoZGl2KSB7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY3NzIGNsYXNzIGZyb20gYSB0aGUgZGl2IGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIGRpdiB0aGUgZGl2IHRvIHJlbW92ZSB0aGUgY2xhc3MgZnJvbVxuICogQHBhcmFtIGNzcyB0aGUgY3NzIGNsYXNzIHRvIHJlbW92ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ3NzKGRpdiwgY3NzKSB7XG4gICAgbGV0IGRpdkNzcyA9IGRpdi5jbGFzc05hbWU7XG4gICAgY3NzID0gZGl2Q3NzLnJlcGxhY2UoY3NzLCBcIlwiKTtcbiAgICBkaXYuY2xhc3NOYW1lID0gY3NzO1xufVxuXG5cbi8qKlxuICogQWRkIGEgY3NzIGNsYXNzIHRvIGEgdGhlIGRpdiBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSBkaXYgdGhlIGRpdiB0byBhZGQgdGhlIGNsYXNzIHRvXG4gKiBAcGFyYW0gY3NzIHRoZSBjc3MgY2xhc3MgdG8gYWRkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDc3MoZGl2LCBjc3MpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGl2LmNsYXNzTmFtZSArIFwiIFwiICsgY3NzKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBsYXN0IGNoYXJhY3RlciBvZiBhIHtzdHJpbmd9IG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBpbnB1dCB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUgd2l0aG91dCB0aGUgbGFzdCBjaGFyYWN0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUxhc3RDaGFySWZFeGlzdCh2YWx1ZSkge1xuICAgIGlmICghaXNEZWZpbmVkKHVuZGVmaW5lZCkgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwIHx8ICF2YWx1ZS5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG59XG5cbiIsImltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vdXRpbHMvVXRpbHNcIjtcblxuY2xhc3MgRGF0YVN5bmNocm9uaXplckFsZ28ge1xuICAgIGNvbnN0cnVjdG9yKGRhdGFTb3VyY2VzLCByZXBsYXlGYWN0b3IgPSAxLCBpbnRlcnZhbFJhdGUgPSA1KSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLmJ1ZmZlcmluZ1RpbWUgPSAxMDAwO1xuICAgICAgICB0aGlzLnN0YXJ0QnVmZmVyaW5nVGltZSA9IC0xO1xuICAgICAgICB0aGlzLnRzUnVuID0gMDtcbiAgICAgICAgdGhpcy5yZXBsYXlGYWN0b3IgPSByZXBsYXlGYWN0b3I7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxSYXRlID0gaW50ZXJ2YWxSYXRlO1xuICAgICAgICBsZXQgbWF4QnVmZmVyaW5nVGltZSA9IC0xO1xuXG4gICAgICAgIGZvciAobGV0IGRzIG9mIGRhdGFTb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGFTb3VyY2UoZHMpO1xuICAgICAgICAgICAgbWF4QnVmZmVyaW5nVGltZSA9IGRzLmJ1ZmZlcmluZ1RpbWUgPiBtYXhCdWZmZXJpbmdUaW1lID8gZHMuYnVmZmVyaW5nVGltZSA6IG1heEJ1ZmZlcmluZ1RpbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heEJ1ZmZlcmluZ1RpbWUgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmluZ1RpbWUgPSBtYXhCdWZmZXJpbmdUaW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVzaChkYXRhU291cmNlSWQsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZUlkXTtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRCdWZmZXJpbmdUaW1lID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydEJ1ZmZlcmluZ1RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIC8vIHN0YXJ0IGl0ZXJhdGluZyBvbiBkYXRhIGFmdGVyIGJ1ZmZlcmluZ1RpbWVcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5wcm9jZXNzRGF0YSgpLCB0aGlzLmJ1ZmZlcmluZ1RpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxhdGVuY3kgPSAwO1xuICAgICAgICBpZiAodGhpcy50c1J1biA+IDApIHtcbiAgICAgICAgICAgIGxhdGVuY3kgPSB0aGlzLnRzUnVuIC0gZGF0YS50aW1lU3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgZHMubGF0ZW5jeSA9IGxhdGVuY3kgPiBkcy5sYXRlbmN5ID8gbGF0ZW5jeSA6IChkcy5sYXRlbmN5ICsgbGF0ZW5jeSkgLyAyO1xuICAgICAgICBkcy5kYXRhQnVmZmVyLnB1c2goZGF0YSk7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgZm9yIChsZXQgY3VycmVudERzSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbY3VycmVudERzSWRdO1xuICAgICAgICAgICAgY3VycmVudERzLmRhdGFCdWZmZXIgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0QnVmZmVyaW5nVGltZSA9IC0xO1xuICAgIH1cblxuICAgIHByb2Nlc3NEYXRhKCkge1xuICAgICAgICBsZXQgdHNSZWYgPSAtMTtcbiAgICAgICAgbGV0IGNsb2NrVGltZVJlZiA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgIC8vIGdldCByZWZlcmVuY2Ugc3RhcnQgdGltZXN0YW1wXG4gICAgICAgIC8vIHRoZSByZWZlcmVuY2Ugc3RhcnQgdGltZXN0YW1wIHNob3VsZCB0aGUgb2xkZXN0IG9uZVxuICAgICAgICBsZXQgY3VycmVudERzO1xuICAgICAgICBmb3IgKGxldCBjdXJyZW50RHNJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGN1cnJlbnREcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtjdXJyZW50RHNJZF07XG4gICAgICAgICAgICBpZiAoY3VycmVudERzLmRhdGFCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRzUmVmID0gKHRzUmVmID09PSAtMSB8fCBjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS50aW1lU3RhbXAgPCB0c1JlZikgPyBjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS50aW1lU3RhbXAgOlxuICAgICAgICAgICAgICAgICAgICB0c1JlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAvLyAxKSByZXR1cm4gdGhlIG9sZGVzdCBkYXRhIGlmIGFueVxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuY29tcHV0ZU5leHREYXRhKHRzUmVmLCBjbG9ja1RpbWVSZWYpKSA7XG5cbiAgICAgICAgfSwgdGhpcy5pbnRlcnZhbFJhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIG5leHQgZGF0YSBpZiBhbnkuIFdlIHJldHVybiBvbmx5IDEgdmFsdWUgZm9yIHRoaXMgaXRlcmF0aW9uLiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgdmFsdWVzIHRvIHJldHVybixcbiAgICAgKiB3ZSByZXR1cm4gb25seSB0aGUgb2xkZXN0IG9uZS5cbiAgICAgKiBAcGFyYW0gdHNSZWYgLSB0aGUgdGltZXN0YW1wIG9mIHRoZSBmaXJzdCBkYXRhXG4gICAgICogQHBhcmFtIHJlZkNsb2NrVGltZSAtIHRoZSBhYnNvbHV0ZSBkaWZmIHRpbWUgcmVhbGx5IHNwZW50XG4gICAgICovXG4gICAgY29tcHV0ZU5leHREYXRhKHRzUmVmLCByZWZDbG9ja1RpbWUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnREcztcbiAgICAgICAgbGV0IGN1cnJlbnREc1RvU2hpZnQgPSBudWxsO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgbWF4IGxhdGVuY3lcbiAgICAgICAgbGV0IG1heExhdGVuY3kgPSAwO1xuICAgICAgICBsZXQgbWluTGF0ZW5jeTtcbiAgICAgICAgZm9yIChsZXQgY3VycmVudERzSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICBjdXJyZW50RHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbY3VycmVudERzSWRdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5sYXRlbmN5ID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBsYXRlbmN5ID0gTWF0aC5taW4oY3VycmVudERzLmxhdGVuY3ksIGN1cnJlbnREcy50aW1lT3V0KTtcbiAgICAgICAgICAgICAgICBtYXhMYXRlbmN5ID0gKGxhdGVuY3kgPiBtYXhMYXRlbmN5KSA/IGxhdGVuY3kgOiBtYXhMYXRlbmN5O1xuICAgICAgICAgICAgICAgIG1pbkxhdGVuY3kgPSAoY3VycmVudERzLmxhdGVuY3kgPCBtaW5MYXRlbmN5KSA/IGN1cnJlbnREcy5sYXRlbmN5IDogbWluTGF0ZW5jeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRDbG9jayA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcmVmQ2xvY2tUaW1lO1xuICAgICAgICB0aGlzLnRzUnVuID0gdHNSZWYgKyBkQ2xvY2s7XG5cbiAgICAgICAgLy8gY29tcHV0ZSBuZXh0IGRhdGEgdG8gcmV0dXJuXG4gICAgICAgIGZvciAobGV0IGN1cnJlbnREc0lkIGluIHRoaXMuZGF0YVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgY3VycmVudERzID0gdGhpcy5kYXRhU291cmNlTWFwW2N1cnJlbnREc0lkXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RHMuZGF0YUJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZFRzID0gY3VycmVudERzLmRhdGFCdWZmZXJbMF0udGltZVN0YW1wIC0gdHNSZWY7XG4gICAgICAgICAgICAgICAgY29uc3QgZENsb2NrQWRqID0gZENsb2NrIC0gbWF4TGF0ZW5jeTtcbiAgICAgICAgICAgICAgICAvLyB3ZSB1c2UgYW4gaW50ZXJtZWRpYXRlIG9iamVjdCB0byBzdG9yZSB0aGUgZGF0YSB0byBzaGlmdCBiZWNhdXNlIHdlIHdhbnQgdG8gcmV0dXJuIHRoZSBvbGRlc3Qgb25lXG4gICAgICAgICAgICAgICAgLy8gb25seVxuICAgICAgICAgICAgICAgIGlmIChkVHMgPD0gZENsb2NrQWRqKnRoaXMucmVwbGF5RmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG90aGVyIG9uZSB0byBjb21wYXJlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RHNUb1NoaWZ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHNUb1NoaWZ0ID0gY3VycmVudERzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFrZSB0aGUgb2xkZXN0IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREc1RvU2hpZnQgPSAoY3VycmVudERzVG9TaGlmdC5kYXRhQnVmZmVyWzBdLnRpbWVTdGFtcCA8IGN1cnJlbnREcy5kYXRhQnVmZmVyWzBdLnRpbWVTdGFtcCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREc1RvU2hpZnQgOiBjdXJyZW50RHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5hbGx5IHBvcCB0aGUgZGF0YSBmcm9tIERTIHF1ZXVlXG4gICAgICAgIGlmIChjdXJyZW50RHNUb1NoaWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmVjID0gY3VycmVudERzVG9TaGlmdC5kYXRhQnVmZmVyLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBsYXRlbmN5IGZsYWcgdG8gZGF0YSByZWNvcmQgYmVmb3JlIHdlIGRpc3BhdGNoIGl0XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHJlbGF0aXZlIGxhdGVuY3kgaW4gbWlsbGlzIGNvbXBhcmVkIHRvIHRoZSBEUyB3aXRoIHRoZSBsb3dlc3QgbGF0ZW5jeVxuICAgICAgICAgICAgLy8gc28gaXQgaXMgYWNjdXJhdGUgZXZlbiBpZiBsb2NhbCBkZXZpY2UgdGltZSBpcyBub3Qgc2V0IHByb3Blcmx5XG4gICAgICAgICAgICByZWNbJ0BsYXRlbmN5J10gPSBjdXJyZW50RHMubGF0ZW5jeSAtIG1pbkxhdGVuY3k7XG5cbiAgICAgICAgICAgIHRoaXMub25EYXRhKGN1cnJlbnREc1RvU2hpZnQuaWQsIHJlYyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlLmlkXSA9IHtcbiAgICAgICAgICAgIGJ1ZmZlcmluZ1RpbWU6IGRhdGFTb3VyY2UuYnVmZmVyaW5nVGltZSxcbiAgICAgICAgICAgIHRpbWVPdXQ6IGRhdGFTb3VyY2UudGltZU91dCB8fCAwLFxuICAgICAgICAgICAgZGF0YUJ1ZmZlcjogW10sXG4gICAgICAgICAgICBzdGFydEJ1ZmZlcmluZ1RpbWU6IC0xLFxuICAgICAgICAgICAgaWQ6IGRhdGFTb3VyY2UuaWQsXG4gICAgICAgICAgICB0aW1lZE91dDogZmFsc2UsXG4gICAgICAgICAgICBuYW1lOiBkYXRhU291cmNlLm5hbWUgfHwgZGF0YVNvdXJjZS5pZCxcbiAgICAgICAgICAgIGxhdGVuY3k6IDBcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBvbkRhdGEoZGF0YVNvdXJjZUlkLCBkYXRhKSB7XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmKGlzRGVmaW5lZCh0aGlzLmludGVydmFsKSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRGF0YSBzeW5jaHJvbml6ZXIgdGVybWluYXRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBEYXRhU3luY2hyb25pemVyQWxnbztcbiIsImV4cG9ydCBjb25zdCBEQVRBX1NZTkNIUk9OSVpFUl9UT1BJQyA9ICdkYXRhLXN5bmNocm9uaXplci0nO1xuZXhwb3J0IGNvbnN0IERBVEFTT1VSQ0VfREFUQV9UT1BJQyA9ICdkYXRhc291cmNlLWRhdGEtJztcbmV4cG9ydCBjb25zdCBGRk1QRUdfVklFV19ERUNPREVfVE9QSUMgPSAnZmZtcGVnLWRlY29kZS0nO1xuIiwiaW1wb3J0IERhdGFTeW5jaHJvbml6ZXJBbGdvIGZyb20gXCIuL0RhdGFTeW5jaHJvbml6ZXJBbGdvXCI7XG5pbXBvcnQge0RBVEFfU1lOQ0hST05JWkVSX1RPUElDLCBEQVRBU09VUkNFX0RBVEFfVE9QSUN9IGZyb20gXCIuLi9Db25zdGFudHNcIjtcblxuY29uc3QgYmNDaGFubmVscyA9IHt9O1xubGV0IGRhdGFTeW5jaHJvbml6ZXJBbGdvO1xuXG5sZXQgaW5pdCA9IGZhbHNlO1xubGV0IGRhdGFTb3VyY2VCcm9hZENhc3RDaGFubmVsID0gbnVsbDtcbnNlbGYuY3VycmVudFRpbWUgPSAtMTtcblxuc2VsZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICBpZihldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdpbml0Jykge1xuICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnbyA9IG5ldyBEYXRhU3luY2hyb25pemVyQWxnbyhcbiAgICAgICAgICAgIGV2ZW50LmRhdGEuZGF0YVNvdXJjZXMsXG4gICAgICAgICAgICBldmVudC5kYXRhLnJlcGxheUZhY3RvcixcbiAgICAgICAgICAgIGV2ZW50LmRhdGEuaW50ZXJ2YWxSYXRlXG4gICAgICAgICk7XG4gICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLm9uRGF0YSA9IG9uRGF0YTtcbiAgICAgICAgaW5pdCA9IHRydWU7XG4gICAgICAgIGFkZERhdGFTb3VyY2VzKGV2ZW50LmRhdGEuZGF0YVNvdXJjZXMpO1xuICAgICAgICBkYXRhU291cmNlQnJvYWRDYXN0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGV2ZW50LmRhdGEudG9waWMpO1xuICAgICAgICBkYXRhU291cmNlQnJvYWRDYXN0Q2hhbm5lbC5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnB1c2goZXZlbnQuZGF0YS5kYXRhU291cmNlSWQsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBldmVudC5kYXRhLmRhdGEsXG4gICAgICAgICAgICAgICAgdGltZVN0YW1wOiBldmVudC5kYXRhLnRpbWVTdGFtcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnYWRkJyAmJiBldmVudC5kYXRhLmRhdGFTb3VyY2VzKSB7XG4gICAgICAgIGFkZERhdGFTb3VyY2VzKGV2ZW50LmRhdGEuZGF0YVNvdXJjZXMpO1xuICAgIH0gZWxzZSBpZihldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdjdXJyZW50LXRpbWUnKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ2N1cnJlbnQtdGltZScsXG4gICAgICAgICAgICBkYXRhOiBzZWxmLmN1cnJlbnRUaW1lXG4gICAgICAgIH0pO1xuICAgIH0gIGVsc2UgaWYoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAncmVzZXQnKSB7XG4gICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnJlc2V0KCk7XG4gICAgfSBlbHNlIGlmKGRhdGFTeW5jaHJvbml6ZXJBbGdvICE9PSBudWxsKSB7XG4gICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnB1c2goZXZlbnQuZGF0YS5kYXRhU291cmNlSWQsIGV2ZW50LmRhdGEuZGF0YSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGREYXRhU291cmNlcyhkYXRhU291cmNlcykge1xuICAgIGZvcihsZXQgZHMgb2YgZGF0YVNvdXJjZXMpIHtcbiAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28uYWRkRGF0YVNvdXJjZShkcyk7XG4gICAgICAgIGJjQ2hhbm5lbHNbZHMuaWRdID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoREFUQVNPVVJDRV9EQVRBX1RPUElDICsgZHMuaWQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gb25EYXRhKGRhdGFTb3VyY2VJZCwgZGF0YSkge1xuICAgIHNlbGYuY3VycmVudFRpbWUgPSBkYXRhLnRpbWVTdGFtcDtcbiAgICBiY0NoYW5uZWxzW2RhdGFTb3VyY2VJZF0ucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBtZXNzYWdlOiAnZGF0YScsXG4gICAgICAgIGRhdGFTb3VyY2VJZDogZGF0YVNvdXJjZUlkLFxuICAgICAgICAuLi5kYXRhXG4gICAgfSk7XG59XG5cblxuc2VsZi5vbmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgZGF0YVN5bmNocm9uaXplckFsZ28uY2xvc2UoKTtcbiAgICBjb25zb2xlLmxvZyhcIkRhdGEgU3luY2hyb25pemVyIGhhcyBiZWVuIHRlcm1pbmF0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")}]);