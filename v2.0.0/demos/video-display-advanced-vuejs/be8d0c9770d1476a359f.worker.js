!function(Q){var B={};function F(I){if(B[I])return B[I].exports;var U=B[I]={i:I,l:!1,exports:{}};return Q[I].call(U.exports,U,U.exports,F),U.l=!0,U.exports}F.m=Q,F.c=B,F.d=function(Q,B,I){F.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:I})},F.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},F.t=function(Q,B){if(1&B&&(Q=F(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var I=Object.create(null);if(F.r(I),Object.defineProperty(I,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var U in Q)F.d(I,U,function(B){return Q[B]}.bind(null,U));return I},F.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return F.d(B,"a",B),B},F.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},F.p="",F(F.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/utils/Utils.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n/** * @module Utils */\n\n/** Maximum value of a long */\nconst MAX_LONG = Math.pow(2, 53) + 1;\n/**\n * Global helper method to test if a letiable or object attribute is defined\n */\n\nfunction isDefined(v) {\n  return typeof v !== 'undefined' && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute has a value,\n that is it is defined and non null\n */\n\nfunction hasValue(v) {\n  return isDefined(v) && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute is of a particular type\n */\n\nfunction hasType(v, expectedType) {\n  let hasVal = hasValue(v);\n  return hasVal && typeof v === expectedType;\n}\n/**\n Global helper method to test if a letiable or object attribute is an object\n */\n\nfunction isObject(v, letName) {\n  return hasType(v, 'object', letName);\n}\n/**\n Global helper method to test if a letiable or object attribute is an array\n */\n\nfunction isArray(v) {\n  return isDefined(v) && Array.isArray(v);\n}\n/**\n Global helper method to test if a letiable or object attribute is a function\n */\n\nfunction isFunction(v, letName) {\n  return hasType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined\n **/\n\nfunction assertDefined(v, letName = 'letiable') {\n  if (!isDefined(v)) {\n    throw letName + \" must be defined\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertType(v, expectedType, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (typeof v !== expectedType) {\n    throw letName + \" must be of type \" + expectedType;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertBoolean(v, letName) {\n  return assertType(v, 'boolean', letName);\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertString(v, letName) {\n  return assertType(v, 'string', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertNumber(v, letName) {\n  return assertType(v, 'number', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertPositive(v, letName) {\n  assertNumber(v, letName);\n\n  if (v <= 0) {\n    throw letName + \" must be a positive number\";\n  }\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertObject(v, letName) {\n  return assertType(v, 'object', letName);\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertArray(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!Array.isArray(v)) {\n    throw letName + \" must be an array\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a function\n **/\n\nfunction assertFunction(v, letName) {\n  return assertType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertHasValue(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!hasValue(v)) {\n    throw letName + \" must not be null\";\n  }\n\n  return v;\n}\n/**\n *\n * @return {String}\n */\n\nfunction randomUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * This function stamps/embeds a UUID into an object and returns the UUID generated for it\n * @return {String}\n */\n\nfunction stampUUID(obj) {\n  obj._osh_id = obj._osh_id || randomUUID();\n  return obj._osh_id;\n} //buffer is an ArrayBuffer object, the offset if specified in bytes, and the type is a string\n//corresponding to an OGC data type.\n//See http://def.seegrid.csiro.au/sissvoc/ogc-def/resource?uri=http://www.opengis.net/def/dataType/OGC/0/\n\n/**\n *\n * @param buffer\n * @param offset\n * @param type\n * @return {*}\n */\n\nfunction ParseBytes(buffer, offset, type) {\n  let view = new DataView(buffer); //Note: There exist types not listed in the map below that have OGC definitions, but no appropriate\n  //methods or corresponding types available for parsing in javascript. They are float128, float16, signedLong,\n  //and unsignedLong\n\n  let typeMap = {\n    double: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float64: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float32: function (offset) {\n      return {\n        val: view.getFloat32(offset),\n        bytes: 4\n      };\n    },\n    signedByte: function (offset) {\n      return {\n        val: view.getInt8(offset),\n        bytes: 1\n      };\n    },\n    signedInt: function (offset) {\n      return {\n        val: view.getInt32(offset),\n        bytes: 4\n      };\n    },\n    signedShort: function (offset) {\n      return {\n        val: view.getInt16(offset),\n        bytes: 2\n      };\n    },\n    unsignedByte: function (offset) {\n      return {\n        val: view.getUint8(offset),\n        bytes: 1\n      };\n    },\n    unsignedInt: function (offset) {\n      return {\n        val: view.getUint32(offset),\n        bytes: 4\n      };\n    },\n    unsignedShort: function (offset) {\n      return {\n        val: view.getUint16(offset),\n        bytes: 2\n      };\n    } //TODO: string-utf-8:\n\n  };\n  return typeMap[type](offset);\n} //This function recursivley iterates over the resultStructure to fill in\n//values read from data which should be an ArrayBuffer containing the payload from a websocket\n\n/**\n *\n * @param struct\n * @param data\n * @param offsetBytes\n * @return {*}\n */\n\nfunction ReadData(struct, data, offsetBytes) {\n  let offset = offsetBytes;\n\n  for (let i = 0; i < struct.fields.length; i++) {\n    let currFieldStruct = struct.fields[i];\n\n    if (isDefined(currFieldStruct.type) && currFieldStruct.type !== null) {\n      let ret = ParseBytes(data, offset, currFieldStruct.type);\n      currFieldStruct.val = ret.val;\n      offset += ret.bytes;\n    } else if (isDefined(currFieldStruct.count) && currFieldStruct.count !== null) {\n      //check if count is a reference to another letiable\n      if (isNaN(currFieldStruct.count)) {\n        let id = currFieldStruct.count;\n        let fieldName = struct.id2FieldMap[id];\n        currFieldStruct.count = struct.findFieldByName(fieldName).val;\n      }\n\n      for (let c = 0; c < currFieldStruct.count; c++) {\n        for (let j = 0; j < currFieldStruct.fields.length; j++) {\n          let field = JSON.parse(JSON.stringify(currFieldStruct.fields[j]));\n          offset = ReadData(field, data, offset);\n          currFieldStruct.val.push(field);\n        }\n      }\n    }\n  }\n\n  return offset;\n}\n/**\n *\n * @param resultStructure\n * @return {{}}\n */\n\nfunction GetResultObject(resultStructure) {\n  //TODO: handle cases for nested arrays / matrix data types\n  let result = {};\n\n  for (let i = 0; i < resultStructure.fields.length; i++) {\n    if (isDefined(resultStructure.fields[i].count)) {\n      result[resultStructure.fields[i].name] = [];\n\n      for (let c = 0; c < resultStructure.fields[i].count; c++) {\n        let item = {};\n\n        for (let k = 0; k < resultStructure.fields[i].val[c].fields.length; k++) {\n          item[resultStructure.fields[i].val[c].fields[k].name] = resultStructure.fields[i].val[c].fields[k].val;\n        }\n\n        result[resultStructure.fields[i].name].push(item);\n      }\n    } else {\n      result[resultStructure.fields[i].name] = resultStructure.fields[i].val;\n    }\n  }\n\n  return result;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isOpera() {\n  return !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isFirefox() {\n  return typeof InstallTrigger !== 'undefined';\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isSafari() {\n  return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isChrome() {\n  return !!window.chrome && !!window.chrome.webstore;\n}\n/**\n *\n * @return {*|boolean}\n */\n\nfunction isBlink() {\n  return (isChrome || isOpera) && !!window.CSS;\n}\n/**\n *\n * @param a\n * @param b\n * @return {boolean}\n */\n\nfunction isArrayIntersect(a, b) {\n  return a.filter(function (element) {\n    return b.indexOf(element) > -1;\n  }).length > 0;\n}\n/**\n *\n * @param o\n * @return {boolean}\n */\n\nfunction isElement(o) {\n  return typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n  o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n}\n/**\n *\n * @return {*}\n */\n\nfunction isWebWorker() {\n  return isDefined(Worker);\n}\n/**\n *\n * @param div\n */\n\nfunction takeScreenShot(div) {}\n/**\n * Remove a css class from a the div given as argument.\n * @param div the div to remove the class from\n * @param css the css class to remove\n */\n\nfunction removeCss(div, css) {\n  let divCss = div.className;\n  css = divCss.replace(css, \"\");\n  div.className = css;\n}\n/**\n * Add a css class to a the div given as argument.\n * @param div the div to add the class to\n * @param css the css class to add\n */\n\nfunction addCss(div, css) {\n  div.setAttribute(\"class\", div.className + \" \" + css);\n}\n/**\n * Removes the last character of a {string} object.\n * @param {string} value - The input {string}\n * @return {string} The value without the last character\n */\n\nfunction removeLastCharIfExist(value) {\n  if (!isDefined(undefined) || value === null || value.length === 0 || !value.endsWith(\"/\")) {\n    return value;\n  }\n\n  return value.substring(0, value.length - 1);\n}\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/dataconnector/Status.js\n/**\n * Enum for connection status.\n * @readonly\n * @enum {{name: string}}\n */\nconst Status = {\n  CONNECTED: \"connected\",\n  DISCONNECTED: \"disconnected\"\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/datasynchronizer/DataSynchronizerAlgo.js\n\n\n\nclass DataSynchronizerAlgo_DataSynchronizerAlgo {\n  constructor(dataSources, replaySpeed = 1, intervalRate = 5) {\n    this.dataSourceMap = {};\n    this.bufferingTime = 1000;\n    this.startBufferingTime = -1;\n    this.tsRun = 0;\n    this.replaySpeed = replaySpeed;\n    this.intervalRate = intervalRate;\n    let maxBufferingTime = -1;\n\n    for (let ds of dataSources) {\n      this.addDataSource(ds);\n      maxBufferingTime = ds.bufferingTime > maxBufferingTime ? ds.bufferingTime : maxBufferingTime;\n    }\n\n    if (maxBufferingTime !== -1) {\n      this.bufferingTime = maxBufferingTime;\n    }\n  }\n\n  push(dataSourceId, data) {\n    const ds = this.dataSourceMap[dataSourceId];\n\n    if (ds.status === Status.DISCONNECTED) {\n      return;\n    }\n\n    if (this.startBufferingTime === -1) {\n      this.startBufferingTime = performance.now(); // start iterating on data after bufferingTime\n\n      setTimeout(() => this.processData(), this.bufferingTime);\n    }\n\n    let latency = 0;\n\n    if (this.tsRun > 0) {\n      latency = this.tsRun - data.timeStamp;\n    }\n\n    ds.latency = latency > ds.latency ? latency : (ds.latency + latency) / 2;\n    ds.dataBuffer.push(data);\n  }\n\n  reset() {\n    this.close();\n\n    for (let currentDsId in this.dataSourceMap) {\n      const currentDs = this.dataSourceMap[currentDsId];\n      currentDs.dataBuffer = [];\n    }\n\n    this.startBufferingTime = -1;\n  }\n\n  processData() {\n    let tsRef = -1;\n    let clockTimeRef = performance.now(); // get reference start timestamp\n    // the reference start timestamp should the oldest one\n\n    let currentDs;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.status === Status.DISCONNECTED) {\n        continue;\n      }\n\n      if (currentDs.dataBuffer.length > 0) {\n        tsRef = tsRef === -1 || currentDs.dataBuffer[0].timeStamp < tsRef ? currentDs.dataBuffer[0].timeStamp : tsRef;\n      }\n    }\n\n    this.interval = setInterval(() => {\n      // 1) return the oldest data if any\n      while (this.computeNextData(tsRef, clockTimeRef));\n    }, this.intervalRate);\n  }\n  /**\n   * Compute the next data if any. We return only 1 value for this iteration. If there are multiple values to return,\n   * we return only the oldest one.\n   * @param tsRef - the timestamp of the first data\n   * @param refClockTime - the absolute diff time really spent\n   */\n\n\n  computeNextData(tsRef, refClockTime) {\n    let currentDs;\n    let currentDsToShift = null; // compute max latency\n\n    let maxLatency = 0;\n    let minLatency = 0;\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.status === Status.DISCONNECTED) {\n        continue;\n      }\n\n      if (currentDs.latency > 0) {\n        let latency = Math.min(currentDs.latency, currentDs.timeOut);\n        maxLatency = latency > maxLatency ? latency : maxLatency;\n        minLatency = currentDs.latency < minLatency ? currentDs.latency : minLatency;\n      }\n    }\n\n    const dClock = performance.now() - refClockTime;\n    this.tsRun = tsRef + dClock; // compute next data to return\n\n    for (let currentDsId in this.dataSourceMap) {\n      currentDs = this.dataSourceMap[currentDsId];\n\n      if (currentDs.status === Status.DISCONNECTED) {\n        continue;\n      }\n\n      if (currentDs.dataBuffer.length > 0) {\n        const dTs = currentDs.dataBuffer[0].timeStamp - tsRef;\n        const dClockAdj = dClock - maxLatency; // we use an intermediate object to store the data to shift because we want to return the oldest one\n        // only\n\n        if (dTs <= dClockAdj * this.replaySpeed) {\n          // no other one to compare\n          if (currentDsToShift === null) {\n            currentDsToShift = currentDs;\n          } else {\n            // take the oldest data\n            currentDsToShift = currentDsToShift.dataBuffer[0].timeStamp < currentDs.dataBuffer[0].timeStamp ? currentDsToShift : currentDs;\n          }\n        }\n      }\n    } // finally pop the data from DS queue\n\n\n    if (currentDsToShift !== null) {\n      let rec = currentDsToShift.dataBuffer.shift(); // add latency flag to data record before we dispatch it\n      // this is relative latency in millis compared to the DS with the lowest latency\n      // so it is accurate even if local device time is not set properly\n\n      rec['@latency'] = currentDs.latency - minLatency;\n      this.onData(currentDsToShift.id, rec);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Add dataSource to be synchronized\n   * @param {DataSource} dataSource - the dataSource to synchronize\n   */\n\n\n  addDataSource(dataSource) {\n    this.dataSourceMap[dataSource.id] = {\n      bufferingTime: dataSource.bufferingTime,\n      timeOut: dataSource.timeOut || 0,\n      dataBuffer: [],\n      startBufferingTime: -1,\n      id: dataSource.id,\n      timedOut: false,\n      name: dataSource.name || dataSource.id,\n      latency: 0,\n      status: Status.DISCONNECTED //MEANING Enabled, 0 = Disabled\n\n    };\n  }\n\n  onData(dataSourceId, data) {}\n  /**\n   * Change the dataSource status\n   * @param {Status} status - the new status\n   * @param {String} dataSourceId - the corresponding dataSource id\n   */\n\n\n  setStatus(dataSourceId, status) {\n    if (dataSourceId in this.dataSourceMap) {\n      this.dataSourceMap[dataSourceId].status = status;\n\n      if (status === Status.DISCONNECTED) {\n        // reset latency and buffer\n        this.dataSourceMap[dataSourceId].latency = 0;\n        this.dataSourceMap[dataSourceId].dataBuffer = [];\n      }\n\n      console.warn(status + ' DataSource ' + dataSourceId + ' from the synchronizer ');\n    }\n  }\n\n  close() {\n    if (isDefined(this.interval)) {\n      clearInterval(this.interval);\n      console.log(\"Data synchronizer terminated successfully\");\n    }\n  }\n\n}\n\n/* harmony default export */ var datasynchronizer_DataSynchronizerAlgo = (DataSynchronizerAlgo_DataSynchronizerAlgo);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/Constants.js\nconst DATA_SYNCHRONIZER_TOPIC = 'data-synchronizer-';\nconst DATASOURCE_DATA_TOPIC = 'datasource-data-';\nconst FFMPEG_VIEW_DECODE_TOPIC = 'ffmpeg-decode-';\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/datasynchronizer/DataSynchronizer.worker.js\n\n\n\n\n\nconst bcChannels = {};\nlet dataSynchronizerAlgo;\n\nlet init = false;\nlet dataSourceBroadCastChannel = null;\nself.currentTime = -1;\n\nconst dataSources = {};\n\nself.onmessage = (event) => {\n    if(event.data.message === 'init') {\n        dataSynchronizerAlgo = new datasynchronizer_DataSynchronizerAlgo(\n            event.data.dataSources,\n            event.data.replaySpeed,\n            event.data.intervalRate\n        );\n        dataSynchronizerAlgo.onData = onData;\n        init = true;\n        addDataSources(event.data.dataSources);\n        initBroadcastChannel(event.data.topic);\n    } else if(event.data.message === 'add' && event.data.dataSources) {\n        addDataSources(event.data.dataSources);\n    } else if(event.data.message === 'current-time') {\n        self.postMessage({\n            message: 'current-time',\n            data: self.currentTime\n        });\n    }  else if(event.data.message === 'reset') {\n        if(dataSynchronizerAlgo !== null) {\n            dataSynchronizerAlgo.reset();\n        }\n    } else if(event.data.message === 'data') {\n        if(dataSynchronizerAlgo !== null) {\n            dataSynchronizerAlgo.push(event.data.dataSourceId, {\n                data: event.data.data,\n                timeStamp: event.data.timeStamp\n            });\n        }\n    }\n}\n\nfunction initBroadcastChannel(topic) {\n    dataSourceBroadCastChannel = new BroadcastChannel(topic);\n    dataSourceBroadCastChannel.onmessage = (event) => {\n        if(event.data.type === 'data') {\n            dataSynchronizerAlgo.push(event.data.dataSourceId, {\n                data: event.data.data,\n                timeStamp: event.data.timeStamp\n            });\n        } else if(event.data.type === 'message') {\n            const dataSourceId = event.data.dataSourceId;\n\n            if(isDefined(event.data.status)) {\n                dataSynchronizerAlgo.setStatus(dataSourceId, event.data.status);\n            }\n            // bubble the message\n            bcChannels[dataSourceId].postMessage(event.data);\n        }\n    }\n}\n\n/**\n *\n * @param dataSources\n */\nfunction addDataSources(dataSources) {\n    for(let dataSource of dataSources) {\n        addDataSource(dataSource);\n    }\n}\n\nfunction addDataSource(dataSource) {\n    dataSynchronizerAlgo.addDataSource(dataSource);\n    // create a BC to push back the synchronized data into the DATA Stream.\n    bcChannels[dataSource.id] = new BroadcastChannel(DATASOURCE_DATA_TOPIC + dataSource.id);\n\n    if(!(dataSource.id in dataSources)) {\n        dataSources[dataSource.id] = dataSource;\n    }\n}\n\nfunction onData(dataSourceId, data) {\n    self.currentTime = data.timeStamp;\n    bcChannels[dataSourceId].postMessage({\n        type: 'data',\n        dataSourceId: dataSourceId,\n        ...data\n    });\n}\n\n\nself.onclose = function() {\n    dataSynchronizerAlgo.close();\n    console.log(\"Data Synchronizer has been terminated successfully\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2Uvb3NoL3V0aWxzL1V0aWxzLmpzPzI0M2EiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL29zaC9kYXRhY29ubmVjdG9yL1N0YXR1cy5qcz8wOTg3Iiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9vc2gvZGF0YXN5bmNocm9uaXplci9EYXRhU3luY2hyb25pemVyQWxnby5qcz9kNzc3Iiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9vc2gvQ29uc3RhbnRzLmpzP2RiZjciLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL29zaC9kYXRhc3luY2hyb25pemVyL0RhdGFTeW5jaHJvbml6ZXIud29ya2VyLmpzPzQyODAiXSwibmFtZXMiOlsiTUFYX0xPTkciLCJNYXRoIiwicG93IiwiaXNEZWZpbmVkIiwidiIsImhhc1ZhbHVlIiwiaGFzVHlwZSIsImV4cGVjdGVkVHlwZSIsImhhc1ZhbCIsImlzT2JqZWN0IiwibGV0TmFtZSIsImlzQXJyYXkiLCJBcnJheSIsImlzRnVuY3Rpb24iLCJhc3NlcnREZWZpbmVkIiwiYXNzZXJ0VHlwZSIsImFzc2VydEJvb2xlYW4iLCJhc3NlcnRTdHJpbmciLCJhc3NlcnROdW1iZXIiLCJhc3NlcnRQb3NpdGl2ZSIsImFzc2VydE9iamVjdCIsImFzc2VydEFycmF5IiwiYXNzZXJ0RnVuY3Rpb24iLCJhc3NlcnRIYXNWYWx1ZSIsInJhbmRvbVVVSUQiLCJyZXBsYWNlIiwiYyIsInIiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN0YW1wVVVJRCIsIm9iaiIsIl9vc2hfaWQiLCJQYXJzZUJ5dGVzIiwiYnVmZmVyIiwib2Zmc2V0IiwidHlwZSIsInZpZXciLCJEYXRhVmlldyIsInR5cGVNYXAiLCJkb3VibGUiLCJ2YWwiLCJnZXRGbG9hdDY0IiwiYnl0ZXMiLCJmbG9hdDY0IiwiZmxvYXQzMiIsImdldEZsb2F0MzIiLCJzaWduZWRCeXRlIiwiZ2V0SW50OCIsInNpZ25lZEludCIsImdldEludDMyIiwic2lnbmVkU2hvcnQiLCJnZXRJbnQxNiIsInVuc2lnbmVkQnl0ZSIsImdldFVpbnQ4IiwidW5zaWduZWRJbnQiLCJnZXRVaW50MzIiLCJ1bnNpZ25lZFNob3J0IiwiZ2V0VWludDE2IiwiUmVhZERhdGEiLCJzdHJ1Y3QiLCJkYXRhIiwib2Zmc2V0Qnl0ZXMiLCJpIiwiZmllbGRzIiwibGVuZ3RoIiwiY3VyckZpZWxkU3RydWN0IiwicmV0IiwiY291bnQiLCJpc05hTiIsImlkIiwiZmllbGROYW1lIiwiaWQyRmllbGRNYXAiLCJmaW5kRmllbGRCeU5hbWUiLCJqIiwiZmllbGQiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJwdXNoIiwiR2V0UmVzdWx0T2JqZWN0IiwicmVzdWx0U3RydWN0dXJlIiwicmVzdWx0IiwibmFtZSIsIml0ZW0iLCJrIiwiaXNPcGVyYSIsIndpbmRvdyIsIm9wciIsImFkZG9ucyIsIm9wZXJhIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaW5kZXhPZiIsImlzRmlyZWZveCIsIkluc3RhbGxUcmlnZ2VyIiwiaXNTYWZhcmkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJjYWxsIiwiSFRNTEVsZW1lbnQiLCJpc0Nocm9tZSIsImNocm9tZSIsIndlYnN0b3JlIiwiaXNCbGluayIsIkNTUyIsImlzQXJyYXlJbnRlcnNlY3QiLCJhIiwiYiIsImZpbHRlciIsImVsZW1lbnQiLCJpc0VsZW1lbnQiLCJvIiwibm9kZVR5cGUiLCJub2RlTmFtZSIsImlzV2ViV29ya2VyIiwiV29ya2VyIiwidGFrZVNjcmVlblNob3QiLCJkaXYiLCJyZW1vdmVDc3MiLCJjc3MiLCJkaXZDc3MiLCJjbGFzc05hbWUiLCJhZGRDc3MiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVMYXN0Q2hhcklmRXhpc3QiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImVuZHNXaXRoIiwic3Vic3RyaW5nIiwiU3RhdHVzIiwiQ09OTkVDVEVEIiwiRElTQ09OTkVDVEVEIiwiRGF0YVN5bmNocm9uaXplckFsZ28iLCJjb25zdHJ1Y3RvciIsImRhdGFTb3VyY2VzIiwicmVwbGF5U3BlZWQiLCJpbnRlcnZhbFJhdGUiLCJkYXRhU291cmNlTWFwIiwiYnVmZmVyaW5nVGltZSIsInN0YXJ0QnVmZmVyaW5nVGltZSIsInRzUnVuIiwibWF4QnVmZmVyaW5nVGltZSIsImRzIiwiYWRkRGF0YVNvdXJjZSIsImRhdGFTb3VyY2VJZCIsInN0YXR1cyIsInBlcmZvcm1hbmNlIiwibm93Iiwic2V0VGltZW91dCIsInByb2Nlc3NEYXRhIiwibGF0ZW5jeSIsInRpbWVTdGFtcCIsImRhdGFCdWZmZXIiLCJyZXNldCIsImNsb3NlIiwiY3VycmVudERzSWQiLCJjdXJyZW50RHMiLCJ0c1JlZiIsImNsb2NrVGltZVJlZiIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjb21wdXRlTmV4dERhdGEiLCJyZWZDbG9ja1RpbWUiLCJjdXJyZW50RHNUb1NoaWZ0IiwibWF4TGF0ZW5jeSIsIm1pbkxhdGVuY3kiLCJtaW4iLCJ0aW1lT3V0IiwiZENsb2NrIiwiZFRzIiwiZENsb2NrQWRqIiwicmVjIiwic2hpZnQiLCJvbkRhdGEiLCJkYXRhU291cmNlIiwidGltZWRPdXQiLCJzZXRTdGF0dXMiLCJjb25zb2xlIiwid2FybiIsImNsZWFySW50ZXJ2YWwiLCJsb2ciLCJEQVRBX1NZTkNIUk9OSVpFUl9UT1BJQyIsIkRBVEFTT1VSQ0VfREFUQV9UT1BJQyIsIkZGTVBFR19WSUVXX0RFQ09ERV9UT1BJQyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JB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MkxaaEQsbUhBQWYsRTs7QUM5TE8sTUFBTWlELHVCQUF1QixHQUFHLG9CQUFoQztBQUNBLE1BQU1DLHFCQUFxQixHQUFHLGtCQUE5QjtBQUNBLE1BQU1DLHdCQUF3QixHQUFHLGdCQUFqQyxDOztBQ0ZzRDtBQUNQO0FBQ0o7QUFDVDs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxxQ0FBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFELHFCQUFxQjs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiBUaGUgY29udGVudHMgb2YgdGhpcyBmaWxlIGFyZSBzdWJqZWN0IHRvIHRoZSBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlLCB2LiAyLjAuXG4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lXG4gYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXG4gU29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLFxuIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZVxuIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHJpZ2h0cyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiBDb3B5cmlnaHQgKEMpIDIwMTUtMjAyMCBNYXRoaWV1IERoYWluYXV0LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG4gQXV0aG9yOiBNYXRoaWV1IERoYWluYXV0IDxtYXRoaWV1LmRoYWluYXV0QGdtYWlsLmNvbT5cblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiogKiBAbW9kdWxlIFV0aWxzICovXG5cbi8qKiBNYXhpbXVtIHZhbHVlIG9mIGEgbG9uZyAqL1xuZXhwb3J0IGNvbnN0IE1BWF9MT05HID0gTWF0aC5wb3coMiwgNTMpICsgMTtcblxuLyoqXG4gKiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmluZWQodikge1xuICAgIHJldHVybiB0eXBlb2YgKHYpICE9PSAndW5kZWZpbmVkJyAmJiB2ICE9PSBudWxsO1xufVxuXG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGhhcyBhIHZhbHVlLFxuIHRoYXQgaXMgaXQgaXMgZGVmaW5lZCBhbmQgbm9uIG51bGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc1ZhbHVlKHYpIHtcbiAgICByZXR1cm4gaXNEZWZpbmVkKHYpICYmIHYgIT09IG51bGw7XG59XG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIG9mIGEgcGFydGljdWxhciB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNUeXBlKHYsIGV4cGVjdGVkVHlwZSkge1xuICAgIGxldCBoYXNWYWwgPSBoYXNWYWx1ZSh2KTtcbiAgICByZXR1cm4gaGFzVmFsICYmIHR5cGVvZiAodikgPT09IGV4cGVjdGVkVHlwZTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGhhc1R5cGUodiwgJ29iamVjdCcsIGxldE5hbWUpO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBhcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheSh2KSB7XG4gICAgcmV0dXJuIGlzRGVmaW5lZCh2KSAmJiBBcnJheS5pc0FycmF5KHYpO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gaGFzVHlwZSh2LCAnZnVuY3Rpb24nLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGRlZmluZWRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgaWYgKCFpc0RlZmluZWQodikpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgZGVmaW5lZFwiO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGRlZmluZWQgYW5kIG5vbi1udWxsXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VHlwZSh2LCBleHBlY3RlZFR5cGUsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lKTtcbiAgICBpZiAodHlwZW9mICh2KSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIG9mIHR5cGUgXCIgKyBleHBlY3RlZFR5cGU7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBzdHJpbmdcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRCb29sZWFuKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnYm9vbGVhbicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBzdHJpbmdcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRTdHJpbmcodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdzdHJpbmcnLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgbnVtYmVyXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnbnVtYmVyJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIG51bWJlclxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFBvc2l0aXZlKHYsIGxldE5hbWUpIHtcbiAgICBhc3NlcnROdW1iZXIodiwgbGV0TmFtZSk7XG4gICAgaWYgKHYgPD0gMCkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiO1xuICAgIH1cbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIG9iamVjdFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE9iamVjdCh2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ29iamVjdCcsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gb2JqZWN0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0QXJyYXkodiwgbGV0TmFtZSA9ICdsZXRpYWJsZScpIHtcbiAgICBhc3NlcnREZWZpbmVkKHYsIGxldE5hbWUpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBiZSBhbiBhcnJheVwiO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgZnVuY3Rpb25cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRGdW5jdGlvbih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ2Z1bmN0aW9uJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkIGFuZCBub24tbnVsbFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEhhc1ZhbHVlKHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lKTtcbiAgICBpZiAoIWhhc1ZhbHVlKHYpKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IG5vdCBiZSBudWxsXCI7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21VVUlEKCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGxldCByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHN0YW1wcy9lbWJlZHMgYSBVVUlEIGludG8gYW4gb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBVVUlEIGdlbmVyYXRlZCBmb3IgaXRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YW1wVVVJRChvYmopIHtcbiAgICBvYmouX29zaF9pZCA9IG9iai5fb3NoX2lkIHx8IHJhbmRvbVVVSUQoKTtcbiAgICByZXR1cm4gb2JqLl9vc2hfaWQ7XG59XG5cbi8vYnVmZmVyIGlzIGFuIEFycmF5QnVmZmVyIG9iamVjdCwgdGhlIG9mZnNldCBpZiBzcGVjaWZpZWQgaW4gYnl0ZXMsIGFuZCB0aGUgdHlwZSBpcyBhIHN0cmluZ1xuLy9jb3JyZXNwb25kaW5nIHRvIGFuIE9HQyBkYXRhIHR5cGUuXG4vL1NlZSBodHRwOi8vZGVmLnNlZWdyaWQuY3Npcm8uYXUvc2lzc3ZvYy9vZ2MtZGVmL3Jlc291cmNlP3VyaT1odHRwOi8vd3d3Lm9wZW5naXMubmV0L2RlZi9kYXRhVHlwZS9PR0MvMC9cbi8qKlxuICpcbiAqIEBwYXJhbSBidWZmZXJcbiAqIEBwYXJhbSBvZmZzZXRcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJuIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gUGFyc2VCeXRlcyhidWZmZXIsIG9mZnNldCwgdHlwZSkge1xuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG5cbiAgICAvL05vdGU6IFRoZXJlIGV4aXN0IHR5cGVzIG5vdCBsaXN0ZWQgaW4gdGhlIG1hcCBiZWxvdyB0aGF0IGhhdmUgT0dDIGRlZmluaXRpb25zLCBidXQgbm8gYXBwcm9wcmlhdGVcbiAgICAvL21ldGhvZHMgb3IgY29ycmVzcG9uZGluZyB0eXBlcyBhdmFpbGFibGUgZm9yIHBhcnNpbmcgaW4gamF2YXNjcmlwdC4gVGhleSBhcmUgZmxvYXQxMjgsIGZsb2F0MTYsIHNpZ25lZExvbmcsXG4gICAgLy9hbmQgdW5zaWduZWRMb25nXG4gICAgbGV0IHR5cGVNYXAgPSB7XG4gICAgICAgIGRvdWJsZTogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQpLCBieXRlczogOH07XG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0NjQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEZsb2F0NjQob2Zmc2V0KSwgYnl0ZXM6IDh9O1xuICAgICAgICB9LFxuICAgICAgICBmbG9hdDMyOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRGbG9hdDMyKG9mZnNldCksIGJ5dGVzOiA0fTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmVkQnl0ZTogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0SW50OChvZmZzZXQpLCBieXRlczogMX07XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25lZEludDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0SW50MzIob2Zmc2V0KSwgYnl0ZXM6IDR9O1xuICAgICAgICB9LFxuICAgICAgICBzaWduZWRTaG9ydDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0SW50MTYob2Zmc2V0KSwgYnl0ZXM6IDJ9O1xuICAgICAgICB9LFxuICAgICAgICB1bnNpZ25lZEJ5dGU6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldFVpbnQ4KG9mZnNldCksIGJ5dGVzOiAxfTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaWduZWRJbnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldFVpbnQzMihvZmZzZXQpLCBieXRlczogNH07XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2lnbmVkU2hvcnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldFVpbnQxNihvZmZzZXQpLCBieXRlczogMn07XG4gICAgICAgIH0sXG4gICAgICAgIC8vVE9ETzogc3RyaW5nLXV0Zi04OlxuICAgIH07XG4gICAgcmV0dXJuIHR5cGVNYXBbdHlwZV0ob2Zmc2V0KTtcbn1cblxuLy9UaGlzIGZ1bmN0aW9uIHJlY3Vyc2l2bGV5IGl0ZXJhdGVzIG92ZXIgdGhlIHJlc3VsdFN0cnVjdHVyZSB0byBmaWxsIGluXG4vL3ZhbHVlcyByZWFkIGZyb20gZGF0YSB3aGljaCBzaG91bGQgYmUgYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyB0aGUgcGF5bG9hZCBmcm9tIGEgd2Vic29ja2V0XG4vKipcbiAqXG4gKiBAcGFyYW0gc3RydWN0XG4gKiBAcGFyYW0gZGF0YVxuICogQHBhcmFtIG9mZnNldEJ5dGVzXG4gKiBAcmV0dXJuIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gUmVhZERhdGEoc3RydWN0LCBkYXRhLCBvZmZzZXRCeXRlcykge1xuICAgIGxldCBvZmZzZXQgPSBvZmZzZXRCeXRlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cnVjdC5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGN1cnJGaWVsZFN0cnVjdCA9IHN0cnVjdC5maWVsZHNbaV07XG4gICAgICAgIGlmIChpc0RlZmluZWQoY3VyckZpZWxkU3RydWN0LnR5cGUpICYmIGN1cnJGaWVsZFN0cnVjdC50eXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcmV0ID0gUGFyc2VCeXRlcyhkYXRhLCBvZmZzZXQsIGN1cnJGaWVsZFN0cnVjdC50eXBlKTtcbiAgICAgICAgICAgIGN1cnJGaWVsZFN0cnVjdC52YWwgPSByZXQudmFsO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHJldC5ieXRlcztcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZmluZWQoY3VyckZpZWxkU3RydWN0LmNvdW50KSAmJiBjdXJyRmllbGRTdHJ1Y3QuY291bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vY2hlY2sgaWYgY291bnQgaXMgYSByZWZlcmVuY2UgdG8gYW5vdGhlciBsZXRpYWJsZVxuICAgICAgICAgICAgaWYgKGlzTmFOKGN1cnJGaWVsZFN0cnVjdC5jb3VudCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBjdXJyRmllbGRTdHJ1Y3QuY291bnQ7XG4gICAgICAgICAgICAgICAgbGV0IGZpZWxkTmFtZSA9IHN0cnVjdC5pZDJGaWVsZE1hcFtpZF07XG4gICAgICAgICAgICAgICAgY3VyckZpZWxkU3RydWN0LmNvdW50ID0gc3RydWN0LmZpbmRGaWVsZEJ5TmFtZShmaWVsZE5hbWUpLnZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VyckZpZWxkU3RydWN0LmNvdW50OyBjKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN1cnJGaWVsZFN0cnVjdC5maWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpZWxkID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjdXJyRmllbGRTdHJ1Y3QuZmllbGRzW2pdKSk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IFJlYWREYXRhKGZpZWxkLCBkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyRmllbGRTdHJ1Y3QudmFsLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gcmVzdWx0U3RydWN0dXJlXG4gKiBAcmV0dXJuIHt7fX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEdldFJlc3VsdE9iamVjdChyZXN1bHRTdHJ1Y3R1cmUpIHtcbiAgICAvL1RPRE86IGhhbmRsZSBjYXNlcyBmb3IgbmVzdGVkIGFycmF5cyAvIG1hdHJpeCBkYXRhIHR5cGVzXG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0U3RydWN0dXJlLmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0uY291bnQpKSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5uYW1lXSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCByZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLmNvdW50OyBjKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS52YWxbY10uZmllbGRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS52YWxbY10uZmllbGRzW2tdLm5hbWVdID0gcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS52YWxbY10uZmllbGRzW2tdLnZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0ubmFtZV0ucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLm5hbWVdID0gcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS52YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT3BlcmEoKSB7XG4gICAgcmV0dXJuICghIXdpbmRvdy5vcHIgJiYgISFvcHIuYWRkb25zKSB8fCAhIXdpbmRvdy5vcGVyYSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBPUFIvJykgPj0gMDtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRmlyZWZveCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93LkhUTUxFbGVtZW50KS5pbmRleE9mKCdDb25zdHJ1Y3RvcicpID4gMDtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2hyb21lKCkge1xuICAgIHJldHVybiAhIXdpbmRvdy5jaHJvbWUgJiYgISF3aW5kb3cuY2hyb21lLndlYnN0b3JlO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHsqfGJvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0JsaW5rKCkge1xuICAgIHJldHVybiAoaXNDaHJvbWUgfHwgaXNPcGVyYSkgJiYgISF3aW5kb3cuQ1NTO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gYVxuICogQHBhcmFtIGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5SW50ZXJzZWN0KGEsIGIpIHtcbiAgICByZXR1cm4gYS5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGIuaW5kZXhPZihlbGVtZW50KSA+IC0xO1xuICAgIH0pLmxlbmd0aCA+IDA7XG59XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIG9cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQobykge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwib2JqZWN0XCIgPyBvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgOiAvL0RPTTJcbiAgICAgICAgbyAmJiB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIiAmJiBvICE9PSBudWxsICYmIG8ubm9kZVR5cGUgPT09IDEgJiYgdHlwZW9mIG8ubm9kZU5hbWUgPT09IFwic3RyaW5nXCJcbiAgICApO1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJuIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNXZWJXb3JrZXIoKSB7XG4gICAgcmV0dXJuIGlzRGVmaW5lZChXb3JrZXIpO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gZGl2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWtlU2NyZWVuU2hvdChkaXYpIHtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBjc3MgY2xhc3MgZnJvbSBhIHRoZSBkaXYgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0gZGl2IHRoZSBkaXYgdG8gcmVtb3ZlIHRoZSBjbGFzcyBmcm9tXG4gKiBAcGFyYW0gY3NzIHRoZSBjc3MgY2xhc3MgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDc3MoZGl2LCBjc3MpIHtcbiAgICBsZXQgZGl2Q3NzID0gZGl2LmNsYXNzTmFtZTtcbiAgICBjc3MgPSBkaXZDc3MucmVwbGFjZShjc3MsIFwiXCIpO1xuICAgIGRpdi5jbGFzc05hbWUgPSBjc3M7XG59XG5cblxuLyoqXG4gKiBBZGQgYSBjc3MgY2xhc3MgdG8gYSB0aGUgZGl2IGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIGRpdiB0aGUgZGl2IHRvIGFkZCB0aGUgY2xhc3MgdG9cbiAqIEBwYXJhbSBjc3MgdGhlIGNzcyBjbGFzcyB0byBhZGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENzcyhkaXYsIGNzcykge1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBkaXYuY2xhc3NOYW1lICsgXCIgXCIgKyBjc3MpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGxhc3QgY2hhcmFjdGVyIG9mIGEge3N0cmluZ30gb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIGlucHV0IHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB2YWx1ZSB3aXRob3V0IHRoZSBsYXN0IGNoYXJhY3RlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTGFzdENoYXJJZkV4aXN0KHZhbHVlKSB7XG4gICAgaWYgKCFpc0RlZmluZWQodW5kZWZpbmVkKSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZS5sZW5ndGggPT09IDAgfHwgIXZhbHVlLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZygwLCB2YWx1ZS5sZW5ndGggLSAxKTtcbn1cblxuIiwiLyoqXG4gKiBFbnVtIGZvciBjb25uZWN0aW9uIHN0YXR1cy5cbiAqIEByZWFkb25seVxuICogQGVudW0ge3tuYW1lOiBzdHJpbmd9fVxuICovXG5leHBvcnQgY29uc3QgU3RhdHVzID0ge1xuICAgIENPTk5FQ1RFRDogIFwiY29ubmVjdGVkXCIsXG4gICAgRElTQ09OTkVDVEVEOiBcImRpc2Nvbm5lY3RlZFwiXG59O1xuIiwiaW1wb3J0IHtpc0RlZmluZWR9IGZyb20gXCIuLi91dGlscy9VdGlsc1wiO1xuaW1wb3J0IHtTdGF0dXN9IGZyb20gXCIuLi9kYXRhY29ubmVjdG9yL1N0YXR1c1wiO1xuXG5jbGFzcyBEYXRhU3luY2hyb25pemVyQWxnbyB7XG4gICAgY29uc3RydWN0b3IoZGF0YVNvdXJjZXMsIHJlcGxheVNwZWVkID0gMSwgaW50ZXJ2YWxSYXRlID0gNSkge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2VNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5idWZmZXJpbmdUaW1lID0gMTAwMDtcbiAgICAgICAgdGhpcy5zdGFydEJ1ZmZlcmluZ1RpbWUgPSAtMTtcbiAgICAgICAgdGhpcy50c1J1biA9IDA7XG4gICAgICAgIHRoaXMucmVwbGF5U3BlZWQgPSByZXBsYXlTcGVlZDtcbiAgICAgICAgdGhpcy5pbnRlcnZhbFJhdGUgPSBpbnRlcnZhbFJhdGU7XG4gICAgICAgIGxldCBtYXhCdWZmZXJpbmdUaW1lID0gLTE7XG5cbiAgICAgICAgZm9yIChsZXQgZHMgb2YgZGF0YVNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YVNvdXJjZShkcyk7XG4gICAgICAgICAgICBtYXhCdWZmZXJpbmdUaW1lID0gZHMuYnVmZmVyaW5nVGltZSA+IG1heEJ1ZmZlcmluZ1RpbWUgPyBkcy5idWZmZXJpbmdUaW1lIDogbWF4QnVmZmVyaW5nVGltZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4QnVmZmVyaW5nVGltZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyaW5nVGltZSA9IG1heEJ1ZmZlcmluZ1RpbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdXNoKGRhdGFTb3VyY2VJZCwgZGF0YSkge1xuICAgICAgICBjb25zdCBkcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlSWRdO1xuICAgICAgICBpZiAoZHMuc3RhdHVzID09PSBTdGF0dXMuRElTQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGFydEJ1ZmZlcmluZ1RpbWUgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0QnVmZmVyaW5nVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgLy8gc3RhcnQgaXRlcmF0aW5nIG9uIGRhdGEgYWZ0ZXIgYnVmZmVyaW5nVGltZVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnByb2Nlc3NEYXRhKCksIHRoaXMuYnVmZmVyaW5nVGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGF0ZW5jeSA9IDA7XG4gICAgICAgIGlmICh0aGlzLnRzUnVuID4gMCkge1xuICAgICAgICAgICAgbGF0ZW5jeSA9IHRoaXMudHNSdW4gLSBkYXRhLnRpbWVTdGFtcDtcbiAgICAgICAgfVxuICAgICAgICBkcy5sYXRlbmN5ID0gbGF0ZW5jeSA+IGRzLmxhdGVuY3kgPyBsYXRlbmN5IDogKGRzLmxhdGVuY3kgKyBsYXRlbmN5KSAvIDI7XG4gICAgICAgIGRzLmRhdGFCdWZmZXIucHVzaChkYXRhKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICBmb3IgKGxldCBjdXJyZW50RHNJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREcyA9IHRoaXMuZGF0YVNvdXJjZU1hcFtjdXJyZW50RHNJZF07XG4gICAgICAgICAgICBjdXJyZW50RHMuZGF0YUJ1ZmZlciA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRCdWZmZXJpbmdUaW1lID0gLTE7XG4gICAgfVxuXG4gICAgcHJvY2Vzc0RhdGEoKSB7XG4gICAgICAgIGxldCB0c1JlZiA9IC0xO1xuICAgICAgICBsZXQgY2xvY2tUaW1lUmVmID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgICAgLy8gZ2V0IHJlZmVyZW5jZSBzdGFydCB0aW1lc3RhbXBcbiAgICAgICAgLy8gdGhlIHJlZmVyZW5jZSBzdGFydCB0aW1lc3RhbXAgc2hvdWxkIHRoZSBvbGRlc3Qgb25lXG4gICAgICAgIGxldCBjdXJyZW50RHM7XG4gICAgICAgIGZvciAobGV0IGN1cnJlbnREc0lkIGluIHRoaXMuZGF0YVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgY3VycmVudERzID0gdGhpcy5kYXRhU291cmNlTWFwW2N1cnJlbnREc0lkXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RHMuc3RhdHVzID09PSBTdGF0dXMuRElTQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudERzLmRhdGFCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRzUmVmID0gKHRzUmVmID09PSAtMSB8fCBjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS50aW1lU3RhbXAgPCB0c1JlZikgPyBjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS50aW1lU3RhbXAgOlxuICAgICAgICAgICAgICAgICAgICB0c1JlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAvLyAxKSByZXR1cm4gdGhlIG9sZGVzdCBkYXRhIGlmIGFueVxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuY29tcHV0ZU5leHREYXRhKHRzUmVmLCBjbG9ja1RpbWVSZWYpKSA7XG5cbiAgICAgICAgfSwgdGhpcy5pbnRlcnZhbFJhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIG5leHQgZGF0YSBpZiBhbnkuIFdlIHJldHVybiBvbmx5IDEgdmFsdWUgZm9yIHRoaXMgaXRlcmF0aW9uLiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgdmFsdWVzIHRvIHJldHVybixcbiAgICAgKiB3ZSByZXR1cm4gb25seSB0aGUgb2xkZXN0IG9uZS5cbiAgICAgKiBAcGFyYW0gdHNSZWYgLSB0aGUgdGltZXN0YW1wIG9mIHRoZSBmaXJzdCBkYXRhXG4gICAgICogQHBhcmFtIHJlZkNsb2NrVGltZSAtIHRoZSBhYnNvbHV0ZSBkaWZmIHRpbWUgcmVhbGx5IHNwZW50XG4gICAgICovXG4gICAgY29tcHV0ZU5leHREYXRhKHRzUmVmLCByZWZDbG9ja1RpbWUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnREcztcbiAgICAgICAgbGV0IGN1cnJlbnREc1RvU2hpZnQgPSBudWxsO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgbWF4IGxhdGVuY3lcbiAgICAgICAgbGV0IG1heExhdGVuY3kgPSAwO1xuICAgICAgICBsZXQgbWluTGF0ZW5jeSA9IDA7XG4gICAgICAgIGZvciAobGV0IGN1cnJlbnREc0lkIGluIHRoaXMuZGF0YVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgY3VycmVudERzID0gdGhpcy5kYXRhU291cmNlTWFwW2N1cnJlbnREc0lkXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RHMuc3RhdHVzID09PSBTdGF0dXMuRElTQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudERzLmxhdGVuY3kgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhdGVuY3kgPSBNYXRoLm1pbihjdXJyZW50RHMubGF0ZW5jeSwgY3VycmVudERzLnRpbWVPdXQpO1xuICAgICAgICAgICAgICAgIG1heExhdGVuY3kgPSAobGF0ZW5jeSA+IG1heExhdGVuY3kpID8gbGF0ZW5jeSA6IG1heExhdGVuY3k7XG4gICAgICAgICAgICAgICAgbWluTGF0ZW5jeSA9IChjdXJyZW50RHMubGF0ZW5jeSA8IG1pbkxhdGVuY3kpID8gY3VycmVudERzLmxhdGVuY3kgOiBtaW5MYXRlbmN5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZENsb2NrID0gcGVyZm9ybWFuY2Uubm93KCkgLSByZWZDbG9ja1RpbWU7XG4gICAgICAgIHRoaXMudHNSdW4gPSB0c1JlZiArIGRDbG9jaztcblxuICAgICAgICAvLyBjb21wdXRlIG5leHQgZGF0YSB0byByZXR1cm5cbiAgICAgICAgZm9yIChsZXQgY3VycmVudERzSWQgaW4gdGhpcy5kYXRhU291cmNlTWFwKSB7XG4gICAgICAgICAgICBjdXJyZW50RHMgPSB0aGlzLmRhdGFTb3VyY2VNYXBbY3VycmVudERzSWRdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREcy5zdGF0dXMgPT09IFN0YXR1cy5ESVNDT05ORUNURUQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50RHMuZGF0YUJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZFRzID0gY3VycmVudERzLmRhdGFCdWZmZXJbMF0udGltZVN0YW1wIC0gdHNSZWY7XG4gICAgICAgICAgICAgICAgY29uc3QgZENsb2NrQWRqID0gZENsb2NrIC0gbWF4TGF0ZW5jeTtcbiAgICAgICAgICAgICAgICAvLyB3ZSB1c2UgYW4gaW50ZXJtZWRpYXRlIG9iamVjdCB0byBzdG9yZSB0aGUgZGF0YSB0byBzaGlmdCBiZWNhdXNlIHdlIHdhbnQgdG8gcmV0dXJuIHRoZSBvbGRlc3Qgb25lXG4gICAgICAgICAgICAgICAgLy8gb25seVxuICAgICAgICAgICAgICAgIGlmIChkVHMgPD0gZENsb2NrQWRqICogdGhpcy5yZXBsYXlTcGVlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBvdGhlciBvbmUgdG8gY29tcGFyZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudERzVG9TaGlmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERzVG9TaGlmdCA9IGN1cnJlbnREcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRha2UgdGhlIG9sZGVzdCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHNUb1NoaWZ0ID0gKGN1cnJlbnREc1RvU2hpZnQuZGF0YUJ1ZmZlclswXS50aW1lU3RhbXAgPCBjdXJyZW50RHMuZGF0YUJ1ZmZlclswXS50aW1lU3RhbXApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHNUb1NoaWZ0IDogY3VycmVudERzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluYWxseSBwb3AgdGhlIGRhdGEgZnJvbSBEUyBxdWV1ZVxuICAgICAgICBpZiAoY3VycmVudERzVG9TaGlmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJlYyA9IGN1cnJlbnREc1RvU2hpZnQuZGF0YUJ1ZmZlci5zaGlmdCgpO1xuXG4gICAgICAgICAgICAvLyBhZGQgbGF0ZW5jeSBmbGFnIHRvIGRhdGEgcmVjb3JkIGJlZm9yZSB3ZSBkaXNwYXRjaCBpdFxuICAgICAgICAgICAgLy8gdGhpcyBpcyByZWxhdGl2ZSBsYXRlbmN5IGluIG1pbGxpcyBjb21wYXJlZCB0byB0aGUgRFMgd2l0aCB0aGUgbG93ZXN0IGxhdGVuY3lcbiAgICAgICAgICAgIC8vIHNvIGl0IGlzIGFjY3VyYXRlIGV2ZW4gaWYgbG9jYWwgZGV2aWNlIHRpbWUgaXMgbm90IHNldCBwcm9wZXJseVxuICAgICAgICAgICAgcmVjWydAbGF0ZW5jeSddID0gY3VycmVudERzLmxhdGVuY3kgLSBtaW5MYXRlbmN5O1xuXG4gICAgICAgICAgICB0aGlzLm9uRGF0YShjdXJyZW50RHNUb1NoaWZ0LmlkLCByZWMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhU291cmNlIHRvIGJlIHN5bmNocm9uaXplZFxuICAgICAqIEBwYXJhbSB7RGF0YVNvdXJjZX0gZGF0YVNvdXJjZSAtIHRoZSBkYXRhU291cmNlIHRvIHN5bmNocm9uaXplXG4gICAgICovXG4gICAgYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlLmlkXSA9IHtcbiAgICAgICAgICAgIGJ1ZmZlcmluZ1RpbWU6IGRhdGFTb3VyY2UuYnVmZmVyaW5nVGltZSxcbiAgICAgICAgICAgIHRpbWVPdXQ6IGRhdGFTb3VyY2UudGltZU91dCB8fCAwLFxuICAgICAgICAgICAgZGF0YUJ1ZmZlcjogW10sXG4gICAgICAgICAgICBzdGFydEJ1ZmZlcmluZ1RpbWU6IC0xLFxuICAgICAgICAgICAgaWQ6IGRhdGFTb3VyY2UuaWQsXG4gICAgICAgICAgICB0aW1lZE91dDogZmFsc2UsXG4gICAgICAgICAgICBuYW1lOiBkYXRhU291cmNlLm5hbWUgfHwgZGF0YVNvdXJjZS5pZCxcbiAgICAgICAgICAgIGxhdGVuY3k6IDAsXG4gICAgICAgICAgICBzdGF0dXM6IFN0YXR1cy5ESVNDT05ORUNURUQgLy9NRUFOSU5HIEVuYWJsZWQsIDAgPSBEaXNhYmxlZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG9uRGF0YShkYXRhU291cmNlSWQsIGRhdGEpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGRhdGFTb3VyY2Ugc3RhdHVzXG4gICAgICogQHBhcmFtIHtTdGF0dXN9IHN0YXR1cyAtIHRoZSBuZXcgc3RhdHVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFTb3VyY2VJZCAtIHRoZSBjb3JyZXNwb25kaW5nIGRhdGFTb3VyY2UgaWRcbiAgICAgKi9cbiAgICBzZXRTdGF0dXMoZGF0YVNvdXJjZUlkLCBzdGF0dXMpIHtcbiAgICAgICAgaWYgKGRhdGFTb3VyY2VJZCBpbiB0aGlzLmRhdGFTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZU1hcFtkYXRhU291cmNlSWRdLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IFN0YXR1cy5ESVNDT05ORUNURUQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXNldCBsYXRlbmN5IGFuZCBidWZmZXJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZUlkXS5sYXRlbmN5ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2VNYXBbZGF0YVNvdXJjZUlkXS5kYXRhQnVmZmVyID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihzdGF0dXMrJyBEYXRhU291cmNlICcgKyBkYXRhU291cmNlSWQgKyAnIGZyb20gdGhlIHN5bmNocm9uaXplciAnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHRoaXMuaW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJEYXRhIHN5bmNocm9uaXplciB0ZXJtaW5hdGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YVN5bmNocm9uaXplckFsZ287XG4iLCJleHBvcnQgY29uc3QgREFUQV9TWU5DSFJPTklaRVJfVE9QSUMgPSAnZGF0YS1zeW5jaHJvbml6ZXItJztcbmV4cG9ydCBjb25zdCBEQVRBU09VUkNFX0RBVEFfVE9QSUMgPSAnZGF0YXNvdXJjZS1kYXRhLSc7XG5leHBvcnQgY29uc3QgRkZNUEVHX1ZJRVdfREVDT0RFX1RPUElDID0gJ2ZmbXBlZy1kZWNvZGUtJztcbiIsImltcG9ydCBEYXRhU3luY2hyb25pemVyQWxnbyBmcm9tIFwiLi9EYXRhU3luY2hyb25pemVyQWxnby5qc1wiO1xuaW1wb3J0IHtEQVRBU09VUkNFX0RBVEFfVE9QSUN9IGZyb20gXCIuLi9Db25zdGFudHMuanNcIjtcbmltcG9ydCB7U3RhdHVzfSBmcm9tIFwiLi4vZGF0YWNvbm5lY3Rvci9TdGF0dXMuanNcIjtcbmltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vdXRpbHMvVXRpbHNcIjtcblxuY29uc3QgYmNDaGFubmVscyA9IHt9O1xubGV0IGRhdGFTeW5jaHJvbml6ZXJBbGdvO1xuXG5sZXQgaW5pdCA9IGZhbHNlO1xubGV0IGRhdGFTb3VyY2VCcm9hZENhc3RDaGFubmVsID0gbnVsbDtcbnNlbGYuY3VycmVudFRpbWUgPSAtMTtcblxuY29uc3QgZGF0YVNvdXJjZXMgPSB7fTtcblxuc2VsZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICBpZihldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdpbml0Jykge1xuICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnbyA9IG5ldyBEYXRhU3luY2hyb25pemVyQWxnbyhcbiAgICAgICAgICAgIGV2ZW50LmRhdGEuZGF0YVNvdXJjZXMsXG4gICAgICAgICAgICBldmVudC5kYXRhLnJlcGxheVNwZWVkLFxuICAgICAgICAgICAgZXZlbnQuZGF0YS5pbnRlcnZhbFJhdGVcbiAgICAgICAgKTtcbiAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28ub25EYXRhID0gb25EYXRhO1xuICAgICAgICBpbml0ID0gdHJ1ZTtcbiAgICAgICAgYWRkRGF0YVNvdXJjZXMoZXZlbnQuZGF0YS5kYXRhU291cmNlcyk7XG4gICAgICAgIGluaXRCcm9hZGNhc3RDaGFubmVsKGV2ZW50LmRhdGEudG9waWMpO1xuICAgIH0gZWxzZSBpZihldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdhZGQnICYmIGV2ZW50LmRhdGEuZGF0YVNvdXJjZXMpIHtcbiAgICAgICAgYWRkRGF0YVNvdXJjZXMoZXZlbnQuZGF0YS5kYXRhU291cmNlcyk7XG4gICAgfSBlbHNlIGlmKGV2ZW50LmRhdGEubWVzc2FnZSA9PT0gJ2N1cnJlbnQtdGltZScpIHtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBtZXNzYWdlOiAnY3VycmVudC10aW1lJyxcbiAgICAgICAgICAgIGRhdGE6IHNlbGYuY3VycmVudFRpbWVcbiAgICAgICAgfSk7XG4gICAgfSAgZWxzZSBpZihldmVudC5kYXRhLm1lc3NhZ2UgPT09ICdyZXNldCcpIHtcbiAgICAgICAgaWYoZGF0YVN5bmNocm9uaXplckFsZ28gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYoZXZlbnQuZGF0YS5tZXNzYWdlID09PSAnZGF0YScpIHtcbiAgICAgICAgaWYoZGF0YVN5bmNocm9uaXplckFsZ28gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGFTeW5jaHJvbml6ZXJBbGdvLnB1c2goZXZlbnQuZGF0YS5kYXRhU291cmNlSWQsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBldmVudC5kYXRhLmRhdGEsXG4gICAgICAgICAgICAgICAgdGltZVN0YW1wOiBldmVudC5kYXRhLnRpbWVTdGFtcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluaXRCcm9hZGNhc3RDaGFubmVsKHRvcGljKSB7XG4gICAgZGF0YVNvdXJjZUJyb2FkQ2FzdENoYW5uZWwgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbCh0b3BpYyk7XG4gICAgZGF0YVNvdXJjZUJyb2FkQ2FzdENoYW5uZWwub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmKGV2ZW50LmRhdGEudHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICBkYXRhU3luY2hyb25pemVyQWxnby5wdXNoKGV2ZW50LmRhdGEuZGF0YVNvdXJjZUlkLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogZXZlbnQuZGF0YS5kYXRhLFxuICAgICAgICAgICAgICAgIHRpbWVTdGFtcDogZXZlbnQuZGF0YS50aW1lU3RhbXBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYoZXZlbnQuZGF0YS50eXBlID09PSAnbWVzc2FnZScpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFTb3VyY2VJZCA9IGV2ZW50LmRhdGEuZGF0YVNvdXJjZUlkO1xuXG4gICAgICAgICAgICBpZihpc0RlZmluZWQoZXZlbnQuZGF0YS5zdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVN5bmNocm9uaXplckFsZ28uc2V0U3RhdHVzKGRhdGFTb3VyY2VJZCwgZXZlbnQuZGF0YS5zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYnViYmxlIHRoZSBtZXNzYWdlXG4gICAgICAgICAgICBiY0NoYW5uZWxzW2RhdGFTb3VyY2VJZF0ucG9zdE1lc3NhZ2UoZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBkYXRhU291cmNlc1xuICovXG5mdW5jdGlvbiBhZGREYXRhU291cmNlcyhkYXRhU291cmNlcykge1xuICAgIGZvcihsZXQgZGF0YVNvdXJjZSBvZiBkYXRhU291cmNlcykge1xuICAgICAgICBhZGREYXRhU291cmNlKGRhdGFTb3VyY2UpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKSB7XG4gICAgZGF0YVN5bmNocm9uaXplckFsZ28uYWRkRGF0YVNvdXJjZShkYXRhU291cmNlKTtcbiAgICAvLyBjcmVhdGUgYSBCQyB0byBwdXNoIGJhY2sgdGhlIHN5bmNocm9uaXplZCBkYXRhIGludG8gdGhlIERBVEEgU3RyZWFtLlxuICAgIGJjQ2hhbm5lbHNbZGF0YVNvdXJjZS5pZF0gPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChEQVRBU09VUkNFX0RBVEFfVE9QSUMgKyBkYXRhU291cmNlLmlkKTtcblxuICAgIGlmKCEoZGF0YVNvdXJjZS5pZCBpbiBkYXRhU291cmNlcykpIHtcbiAgICAgICAgZGF0YVNvdXJjZXNbZGF0YVNvdXJjZS5pZF0gPSBkYXRhU291cmNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gb25EYXRhKGRhdGFTb3VyY2VJZCwgZGF0YSkge1xuICAgIHNlbGYuY3VycmVudFRpbWUgPSBkYXRhLnRpbWVTdGFtcDtcbiAgICBiY0NoYW5uZWxzW2RhdGFTb3VyY2VJZF0ucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiAnZGF0YScsXG4gICAgICAgIGRhdGFTb3VyY2VJZDogZGF0YVNvdXJjZUlkLFxuICAgICAgICAuLi5kYXRhXG4gICAgfSk7XG59XG5cblxuc2VsZi5vbmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgZGF0YVN5bmNocm9uaXplckFsZ28uY2xvc2UoKTtcbiAgICBjb25zb2xlLmxvZyhcIkRhdGEgU3luY2hyb25pemVyIGhhcyBiZWVuIHRlcm1pbmF0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")}]);