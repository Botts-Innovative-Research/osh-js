(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{132:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=r.a.createContext({}),d=function(e){var t=r.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},u=function(e){var t=d(e.components);return r.a.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},p=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),u=d(n),p=a,m=u["".concat(i,".").concat(p)]||u[p]||h[p]||o;return n?r.a.createElement(m,c(c({ref:t},s),{},{components:n})):r.a.createElement(m,c({ref:t},s))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=p;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var s=2;s<o;s++)i[s]=n[s];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},99:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return d}));var a=n(2),r=n(6),o=(n(0),n(132)),i={id:"datasynchronizer",title:"Data synchronization algorithm",sidebar_label:"Synchronization"},c={unversionedId:"advanced/datasynchronizer",id:"advanced/datasynchronizer",isDocsHomePage:!1,title:"Data synchronization algorithm",description:"The main role of the DataSynchronizer is to synchronize multiple data sources based on timestamps.",source:"@site/docs/advanced/datasynchronizer.md",slug:"/advanced/datasynchronizer",permalink:"/osh-js/v2.0.0/documentationV2/docs/advanced/datasynchronizer",version:"current",sidebar_label:"Synchronization",sidebar:"someSidebar",previous:{title:"Communication Channels",permalink:"/osh-js/v2.0.0/documentationV2/docs/advanced/comchannels"},next:{title:"New DataSources",permalink:"/osh-js/v2.0.0/documentationV2/docs/advanced/developers/datasourcesdev"}},l=[{value:"Recall the principle of the main algorithm:",id:"recall-the-principle-of-the-main-algorithm",children:[]}],s={rightToc:l};function d(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"The main role of the DataSynchronizer is to synchronize multiple data sources based on timestamps."),Object(o.b)("p",null,"It supports optional ",Object(o.b)("em",{parentName:"p"},"buffering")," (adds latency but sometimes needed, e.g. video) to smooth out the data rate and send events at beginning and end of buffering so UI can display progress."),Object(o.b)("p",null,"It supports ",Object(o.b)("em",{parentName:"p"},"timeout")," if a data source hangs or its latency increases beyond a certain threshold (timeout means we don\u2019t try to sync this data source anymore because it slows down everything else too much and flag data records that are passed the timeout so that views can indicate that the data source is out of sync)."),Object(o.b)("p",null,"Finally, it is possible to have multiple dataSynchronizer in the same application, each dataSynchronizer would handle a different group of data sources that we want to synchronize together."),Object(o.b)("h2",{id:"recall-the-principle-of-the-main-algorithm"},"Recall the principle of the main algorithm:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Data records from each DS are received in a separate queue (records are added at the end of the queue)"),Object(o.b)("li",{parentName:"ul"},"The DataSynchronizer loop is run with a setInterval() at a frequency that can be adjusted between 5 and 1000ms"),Object(o.b)("li",{parentName:"ul"},"The reference time stamp (TSref) is the timestamp of the first data received from any DS."),Object(o.b)("li",{parentName:"ul"},"The reference clock time is computed with performance.now() when the first data is outputted by the synchronizer (i.e. at the end of the initial buffering period)."),Object(o.b)("li",{parentName:"ul"},"In each synchronizer loop, we loop through each DS and evaluate the oldest record received from it (i.e. the record at the front of the queue, if any):"),Object(o.b)("li",{parentName:"ul"},"We compare the \ud835\udf1fTS of this oldest record (diff between the DS record timestamp and TSref) to the \ud835\udf1fclock (diff between current performance.now() and the reference clock time). If \ud835\udf1fclock > \ud835\udf1fTS, the head of this DS queue can be dispatched"),Object(o.b)("li",{parentName:"ul"},"Continue evaluating the next record from this DS until the condition above returns false")),Object(o.b)("p",null,"In addition to the above existing algorithm, the idea is to also do the following:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Always compute the timestamp of the latest synchronizer loop TSrun = TSref + \ud835\udf1fclock"),Object(o.b)("li",{parentName:"ul"},"When we receive a new record from a DS with timestamp TSrec, we compute its latency = min(TSrun - TSrec , DS_timeout) (this is computed when the data is received, not in the main loop, and stored as a variable of the queue object associated with each DS)"),Object(o.b)("li",{parentName:"ul"},"We regularly compute the maximum latency of all DS and compute \ud835\udf1fclock_adj  = \ud835\udf1fclock - max_latency"),Object(o.b)("li",{parentName:"ul"},"We use \ud835\udf1fclock_adj instead of \ud835\udf1fclock in the comparison with \ud835\udf1fTS in the main loop"),Object(o.b)("li",{parentName:"ul"},"If needed, in order to avoid abrupt changes, we can also smoothout the change of \ud835\udf1fclock_adj over time (e.g. over 10 loops)"),Object(o.b)("li",{parentName:"ul"},"In addition, when \ud835\udf1fclock_adj - \ud835\udf1fTS > threshold we flag the data to indicate that it was received very late and may be processed out of order")))}d.isMDXComponent=!0}}]);