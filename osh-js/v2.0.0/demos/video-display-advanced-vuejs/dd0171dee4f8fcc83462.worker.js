!function(Q){var I={};function B(F){if(I[F])return I[F].exports;var g=I[F]={i:F,l:!1,exports:{}};return Q[F].call(g.exports,g,g.exports,B),g.l=!0,g.exports}B.m=Q,B.c=I,B.d=function(Q,I,F){B.o(Q,I)||Object.defineProperty(Q,I,{enumerable:!0,get:F})},B.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},B.t=function(Q,I){if(1&I&&(Q=B(Q)),8&I)return Q;if(4&I&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var F=Object.create(null);if(B.r(F),Object.defineProperty(F,"default",{enumerable:!0,value:Q}),2&I&&"string"!=typeof Q)for(var g in Q)B.d(F,g,function(I){return Q[I]}.bind(null,g));return F},B.n=function(Q){var I=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return B.d(I,"a",I),I},B.o=function(Q,I){return Object.prototype.hasOwnProperty.call(Q,I)},B.p="",B(B.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/utils/Utils.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n/** * @module Utils */\n\n/** Maximum value of a long */\nconst MAX_LONG = Math.pow(2, 53) + 1;\n/**\n * Global helper method to test if a letiable or object attribute is defined\n */\n\nfunction isDefined(v) {\n  return typeof v !== 'undefined' && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute has a value,\n that is it is defined and non null\n */\n\nfunction hasValue(v) {\n  return isDefined(v) && v !== null;\n}\n/**\n Global helper method to test if a letiable or object attribute is of a particular type\n */\n\nfunction hasType(v, expectedType) {\n  let hasVal = hasValue(v);\n  return hasVal && typeof v === expectedType;\n}\n/**\n Global helper method to test if a letiable or object attribute is an object\n */\n\nfunction isObject(v, letName) {\n  return hasType(v, 'object', letName);\n}\n/**\n Global helper method to test if a letiable or object attribute is an array\n */\n\nfunction isArray(v) {\n  return isDefined(v) && Array.isArray(v);\n}\n/**\n Global helper method to test if a letiable or object attribute is a function\n */\n\nfunction isFunction(v, letName) {\n  return hasType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined\n **/\n\nfunction assertDefined(v, letName = 'letiable') {\n  if (!isDefined(v)) {\n    throw letName + \" must be defined\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertType(v, expectedType, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (typeof v !== expectedType) {\n    throw letName + \" must be of type \" + expectedType;\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertBoolean(v, letName) {\n  return assertType(v, 'boolean', letName);\n}\n/**\n Assert that a letiable or object attribute is a string\n **/\n\nfunction assertString(v, letName) {\n  return assertType(v, 'string', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertNumber(v, letName) {\n  return assertType(v, 'number', letName);\n}\n/**\n Assert that a letiable or object attribute is a number\n **/\n\nfunction assertPositive(v, letName) {\n  assertNumber(v, letName);\n\n  if (v <= 0) {\n    throw letName + \" must be a positive number\";\n  }\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertObject(v, letName) {\n  return assertType(v, 'object', letName);\n}\n/**\n Assert that a letiable or object attribute is an object\n **/\n\nfunction assertArray(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!Array.isArray(v)) {\n    throw letName + \" must be an array\";\n  }\n\n  return v;\n}\n/**\n Assert that a letiable or object attribute is a function\n **/\n\nfunction assertFunction(v, letName) {\n  return assertType(v, 'function', letName);\n}\n/**\n Assert that a letiable or object attribute is defined and non-null\n **/\n\nfunction assertHasValue(v, letName = 'letiable') {\n  assertDefined(v, letName);\n\n  if (!hasValue(v)) {\n    throw letName + \" must not be null\";\n  }\n\n  return v;\n}\n/**\n *\n * @return {String}\n */\n\nfunction randomUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * This function stamps/embeds a UUID into an object and returns the UUID generated for it\n * @return {String}\n */\n\nfunction stampUUID(obj) {\n  obj._osh_id = obj._osh_id || randomUUID();\n  return obj._osh_id;\n} //buffer is an ArrayBuffer object, the offset if specified in bytes, and the type is a string\n//corresponding to an OGC data type.\n//See http://def.seegrid.csiro.au/sissvoc/ogc-def/resource?uri=http://www.opengis.net/def/dataType/OGC/0/\n\n/**\n *\n * @param buffer\n * @param offset\n * @param type\n * @return {*}\n */\n\nfunction ParseBytes(buffer, offset, type) {\n  let view = new DataView(buffer); //Note: There exist types not listed in the map below that have OGC definitions, but no appropriate\n  //methods or corresponding types available for parsing in javascript. They are float128, float16, signedLong,\n  //and unsignedLong\n\n  let typeMap = {\n    double: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float64: function (offset) {\n      return {\n        val: view.getFloat64(offset),\n        bytes: 8\n      };\n    },\n    float32: function (offset) {\n      return {\n        val: view.getFloat32(offset),\n        bytes: 4\n      };\n    },\n    signedByte: function (offset) {\n      return {\n        val: view.getInt8(offset),\n        bytes: 1\n      };\n    },\n    signedInt: function (offset) {\n      return {\n        val: view.getInt32(offset),\n        bytes: 4\n      };\n    },\n    signedShort: function (offset) {\n      return {\n        val: view.getInt16(offset),\n        bytes: 2\n      };\n    },\n    unsignedByte: function (offset) {\n      return {\n        val: view.getUint8(offset),\n        bytes: 1\n      };\n    },\n    unsignedInt: function (offset) {\n      return {\n        val: view.getUint32(offset),\n        bytes: 4\n      };\n    },\n    unsignedShort: function (offset) {\n      return {\n        val: view.getUint16(offset),\n        bytes: 2\n      };\n    } //TODO: string-utf-8:\n\n  };\n  return typeMap[type](offset);\n} //This function recursivley iterates over the resultStructure to fill in\n//values read from data which should be an ArrayBuffer containing the payload from a websocket\n\n/**\n *\n * @param struct\n * @param data\n * @param offsetBytes\n * @return {*}\n */\n\nfunction ReadData(struct, data, offsetBytes) {\n  let offset = offsetBytes;\n\n  for (let i = 0; i < struct.fields.length; i++) {\n    let currFieldStruct = struct.fields[i];\n\n    if (isDefined(currFieldStruct.type) && currFieldStruct.type !== null) {\n      let ret = ParseBytes(data, offset, currFieldStruct.type);\n      currFieldStruct.val = ret.val;\n      offset += ret.bytes;\n    } else if (isDefined(currFieldStruct.count) && currFieldStruct.count !== null) {\n      //check if count is a reference to another letiable\n      if (isNaN(currFieldStruct.count)) {\n        let id = currFieldStruct.count;\n        let fieldName = struct.id2FieldMap[id];\n        currFieldStruct.count = struct.findFieldByName(fieldName).val;\n      }\n\n      for (let c = 0; c < currFieldStruct.count; c++) {\n        for (let j = 0; j < currFieldStruct.fields.length; j++) {\n          let field = JSON.parse(JSON.stringify(currFieldStruct.fields[j]));\n          offset = ReadData(field, data, offset);\n          currFieldStruct.val.push(field);\n        }\n      }\n    }\n  }\n\n  return offset;\n}\n/**\n *\n * @param resultStructure\n * @return {{}}\n */\n\nfunction GetResultObject(resultStructure) {\n  //TODO: handle cases for nested arrays / matrix data types\n  let result = {};\n\n  for (let i = 0; i < resultStructure.fields.length; i++) {\n    if (isDefined(resultStructure.fields[i].count)) {\n      result[resultStructure.fields[i].name] = [];\n\n      for (let c = 0; c < resultStructure.fields[i].count; c++) {\n        let item = {};\n\n        for (let k = 0; k < resultStructure.fields[i].val[c].fields.length; k++) {\n          item[resultStructure.fields[i].val[c].fields[k].name] = resultStructure.fields[i].val[c].fields[k].val;\n        }\n\n        result[resultStructure.fields[i].name].push(item);\n      }\n    } else {\n      result[resultStructure.fields[i].name] = resultStructure.fields[i].val;\n    }\n  }\n\n  return result;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isOpera() {\n  return !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isFirefox() {\n  return typeof InstallTrigger !== 'undefined';\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isSafari() {\n  return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;\n}\n/**\n *\n * @return {boolean}\n */\n\nfunction isChrome() {\n  return !!window.chrome && !!window.chrome.webstore;\n}\n/**\n *\n * @return {*|boolean}\n */\n\nfunction isBlink() {\n  return (isChrome || isOpera) && !!window.CSS;\n}\n/**\n *\n * @param a\n * @param b\n * @return {boolean}\n */\n\nfunction isArrayIntersect(a, b) {\n  return a.filter(function (element) {\n    return b.indexOf(element) > -1;\n  }).length > 0;\n}\n/**\n *\n * @param o\n * @return {boolean}\n */\n\nfunction isElement(o) {\n  return typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n  o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n}\n/**\n *\n * @return {*}\n */\n\nfunction isWebWorker() {\n  return isDefined(Worker);\n}\n/**\n *\n * @param div\n */\n\nfunction takeScreenShot(div) {}\n/**\n * Remove a css class from a the div given as argument.\n * @param div the div to remove the class from\n * @param css the css class to remove\n */\n\nfunction removeCss(div, css) {\n  let divCss = div.className;\n  css = divCss.replace(css, \"\");\n  div.className = css;\n}\n/**\n * Add a css class to a the div given as argument.\n * @param div the div to add the class to\n * @param css the css class to add\n */\n\nfunction addCss(div, css) {\n  div.setAttribute(\"class\", div.className + \" \" + css);\n}\n/**\n * Removes the last character of a {string} object.\n * @param {string} value - The input {string}\n * @return {string} The value without the last character\n */\n\nfunction removeLastCharIfExist(value) {\n  if (!isDefined(undefined) || value === null || value.length === 0 || !value.endsWith(\"/\")) {\n    return value;\n  }\n\n  return value.substring(0, value.length - 1);\n}\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/datareceiver/parsers/DataSourceParser.js\n\n\nclass DataSourceParser_DataSourceParser {\n  /**\n   * Builds the full url.\n   * @protected\n   * @param {Object} properties\n   * @param {String} properties.protocol the connector protocol\n   * @param {String} properties.endpointUrl the endpoint url\n   * @param {String} properties.service the service\n   * @param {String} properties.offeringID the offeringID\n   * @param {String} properties.observedProperty the observed property\n   * @param {String} properties.startTime the start time (ISO format)\n   * @param {String} properties.endTime the end time (ISO format)\n   * @param {Number} properties.replaySpeed the replay factor\n   * @param {Number} properties.responseFormat the response format (e.g video/mp4)\n   * @param {Date} properties.lastTimeStamp - the last timestamp to start at this time (ISO String)\n   * @param {Object} properties.customUrlParams - the encoding options\n   * @param {Number} properties.customUrlParams.video_bitrate - define a custom bitrate (in b/s)\n   * @param {Number} properties.customUrlParams.video_scale - define a custom scale, 0.0 < value < 1.0\n   * @param {Number} properties.customUrlParams.video_width - define a custom width\n   * @param {Number} properties.customUrlParams.video_height - define a custom height\n   * @return {String} the full url\n   */\n  buildUrl(properties) {\n    let url = \"\"; // adds protocol\n\n    url += properties.protocol + \"://\"; // adds endpoint url\n\n    url += properties.endpointUrl + \"?\"; // adds service\n\n    url += \"service=\" + properties.service + \"&\"; // adds version\n\n    url += \"version=2.0&\"; // adds request\n\n    url += \"request=GetResult&\"; // adds offering\n\n    url += \"offering=\" + properties.offeringID + \"&\"; // adds feature of interest urn\n\n    if (properties.foiURN && properties.foiURN !== '') {\n      url += 'featureOfInterest=' + properties.foiURN + '&';\n    } // adds observedProperty\n\n\n    url += \"observedProperty=\" + properties.observedProperty + \"&\"; // adds temporalFilter\n\n    const stTime = isDefined(properties.lastTimeStamp) ? properties.lastTimeStamp : properties.startTime;\n    this.lastStartTime = properties.startTime;\n    let endTime = properties.endTime;\n    url += \"temporalFilter=phenomenonTime,\" + stTime + \"/\" + endTime + \"&\";\n\n    if (properties.replaySpeed) {\n      // adds replaySpeed\n      url += \"replaySpeed=\" + properties.replaySpeed;\n    } // adds responseFormat (optional)\n\n\n    if (properties.responseFormat) {\n      url += \"&responseFormat=\" + properties.responseFormat;\n    }\n\n    if (isDefined(properties.customUrlParams) && Object.keys(properties.customUrlParams).length > 0) {\n      url += '&';\n\n      for (let key in properties.customUrlParams) {\n        url += key + '=' + properties.customUrlParams[key] + '&';\n      }\n\n      if (url.endsWith('&')) {\n        url = url.slice(0, -1);\n      }\n    }\n\n    return url;\n  }\n\n}\n\n/* harmony default export */ var parsers_DataSourceParser = (DataSourceParser_DataSourceParser);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/datareceiver/parsers/SweJson.parser.js\n\n\nclass SweJson_parser_SweJsonParser extends parsers_DataSourceParser {\n  /**\n   * Extracts timestamp from the message. The timestamp corresponds to the 'time' attribute of the JSON object.\n   * @param {String} data - the data to parse\n   * @return {Number} the extracted timestamp\n   */\n  parseTimeStamp(data) {\n    let rec = String.fromCharCode.apply(null, new Uint8Array(data));\n    return new Date(JSON.parse(rec)['time']).getTime();\n  }\n  /**\n   * Extract data from the message. The data are corresponding to the whole list of attributes of the JSON object\n   * excepting the 'time' one.\n   * @param {Object} data - the data to parse\n   * @return {Object} the parsed data\n   * @example\n   * {\n   *   location : {\n   *    lat:43.61758626,\n   *    lon: 1.42376557,\n   *    alt:100\n   *   }\n   * }\n   */\n\n\n  parseData(data) {\n    let rec = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(data)));\n    let result = {};\n\n    for (let key in rec) {\n      if (key !== 'time') {\n        result[key] = rec[key];\n      }\n    }\n\n    return result;\n  }\n\n  buildUrl(properties) {\n    return super.buildUrl({ ...properties,\n      responseFormat: 'application/json'\n    });\n  }\n\n}\n\n/* harmony default export */ var SweJson_parser = (SweJson_parser_SweJsonParser);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/dataconnector/Status.js\n/**\n * Enum for connection status.\n * @readonly\n * @enum {{name: string}}\n */\nconst Status = {\n  CONNECTED: \"connected\",\n  DISCONNECTED: \"disconnected\"\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/dataconnector/DataConnector.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n\n/**\n * The DataConnector is the abstract class used to create different connectors.\n */\n\nclass DataConnector_DataConnector {\n  /**\n   * @param {String} url - The full url used to connect to the data stream\n   */\n  constructor(url) {\n    this.url = url;\n    this.id = \"DataConnector-\" + randomUUID();\n    this.reconnectTimeout = 1000 * 60 * 2; //2 min\n\n    this.status = Status.DISCONNECTED;\n    this.reconnectionInterval = -1;\n  }\n\n  checkAndClearReconnection() {\n    if (this.reconnectionInterval !== -1) {\n      clearInterval(this.reconnectionInterval);\n      this.reconnectionInterval = -1;\n    }\n  }\n\n  disconnect() {\n    this.checkStatus(Status.DISCONNECTED);\n    this.checkAndClearReconnection();\n  }\n  /**\n   * Sets the url\n   * @param url\n   */\n\n\n  setUrl(url) {\n    this.url = url;\n  }\n  /**\n   * The data connector default id.\n   * @return {String}\n   */\n\n\n  getId() {\n    return this.id;\n  }\n  /**\n   * The stream url.\n   * @return {String}\n   */\n\n\n  getUrl() {\n    return this.url;\n  }\n  /**\n   * Sets the reconnection timeout\n   * @param {Number} timeout - delay in milliseconds before reconnecting dataSource\n   */\n\n\n  setReconnectTimeout(timeout) {\n    this.reconnectTimeout = timeout;\n  }\n\n  onReconnect() {\n    return true;\n  }\n\n  connect() {}\n\n  forceReconnect() {\n    this.disconnect();\n    this.connect();\n  }\n  /**\n   * Called when the connection STATUS changes\n   * @param {Status} status - the new status\n   */\n\n\n  onChangeStatus(status) {}\n  /**\n   * Check a change of the status and call the corresponding callbacks if necessary\n   * @param {Status} status - the currentStatus\n   */\n\n\n  checkStatus(status) {\n    if (status !== this.status) {\n      this.onChangeStatus(status);\n      this.status = status;\n    }\n  }\n  /**\n   * Called when the connector has been disconnected\n   */\n\n\n  onDisconnect() {}\n  /**\n   * Called when the connector has been connected\n   */\n\n\n  onConnect() {}\n\n}\n\n/* harmony default export */ var dataconnector_DataConnector = (DataConnector_DataConnector);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/dataconnector/WebSocketConnector.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n\n\n/**\n * Defines the WebSocketConnector to connect to a remote server by creating a WebSocket channel.\n * @extends DataConnector\n * @example\n * import WebSocketConnector from 'osh/dataconnector/WebSocketConnector.js';\n *\n * let url = ...;\n * let connector = new WebSocketConnector(url);\n *\n * // connect\n * connector.connect();\n *\n * // disconnect\n * connector.disconnect();\n *\n * // close\n * connector.close();\n *\n */\n\nclass WebSocketConnector_WebSocketConnector extends dataconnector_DataConnector {\n  /**\n   *\n   * @param properties -\n   */\n  constructor(properties) {\n    super(properties);\n    this.interval = -1;\n    this.lastReceiveTime = 0;\n  }\n  /**\n   * Connect to the webSocket. If the system supports WebWorker, it will automatically creates one otherwise use\n   * the main thread.\n   */\n\n\n  async connect() {\n    if (!this.init) {\n      this.closed = false;\n      this.init = true; //creates Web Socket\n\n      this.ws = new WebSocket(this.getUrl());\n      this.ws.binaryType = 'arraybuffer';\n\n      this.ws.onmessage = function (event) {\n        this.checkAndClearReconnection();\n        this.checkStatus(Status.CONNECTED);\n        this.lastReceiveTime = Date.now(); //callback data on message received\n\n        if (event.data.byteLength > 0) {\n          this.onMessage(event.data);\n        }\n      }.bind(this); // closes socket if any errors occur\n\n\n      this.ws.onerror = function (event) {\n        console.error('WebSocket stream error');\n        this.checkStatus(Status.DISCONNECTED);\n        this.init = false;\n        this.lastReceiveTime = -1;\n        this.createReconnection();\n      }.bind(this);\n\n      this.ws.onclose = event => {\n        this.checkStatus(Status.DISCONNECTED);\n        console.warn('WebSocket stream closed: ', event.reason, event.code);\n        this.init = false;\n\n        if (event.code !== 1000 && !this.closed) {\n          this.createReconnection();\n        }\n      };\n    }\n  }\n\n  createReconnection() {\n    if (this.reconnectionInterval === -1) {\n      this.onReconnect();\n      this.reconnectionInterval = setInterval(function () {\n        let delta = Date.now() - this.lastReceiveTime; // -1 means the WS went in error\n\n        if (this.lastReceiveTime === -1 || delta >= this.reconnectTimeout) {\n          console.warn('trying to reconnect', this.url);\n          this.connect();\n        }\n      }.bind(this), this.reconnectTimeout);\n    }\n  }\n  /**\n   * Disconnects and close the websocket.\n   */\n\n\n  disconnect() {\n    super.disconnect();\n    this.init = false;\n    this.closed = true;\n\n    if (this.ws != null && this.ws.readyState !== WebSocket.CLOSED) {\n      this.ws.close();\n    }\n  }\n  /**\n   * The onMessage method used by the websocket to callback the data\n   * @param data the callback data\n   * @event\n   */\n\n\n  onMessage(data) {}\n\n  isConnected() {\n    return this.ws != null && this.ws.readyState === WebSocket.OPEN;\n  }\n\n}\n\n/* harmony default export */ var dataconnector_WebSocketConnector = (WebSocketConnector_WebSocketConnector);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/dataconnector/Ajax.js\n/***************************** BEGIN LICENSE BLOCK ***************************\n\n The contents of this file are subject to the Mozilla Public License, v. 2.0.\n If a copy of the MPL was not distributed with this file, You can obtain one\n at http://mozilla.org/MPL/2.0/.\n\n Software distributed under the License is distributed on an \"AS IS\" basis,\n WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n for the specific language governing rights and limitations under the License.\n\n Copyright (C) 2015-2020 Mathieu Dhainaut. All Rights Reserved.\n\n Author: Mathieu Dhainaut <mathieu.dhainaut@gmail.com>\n\n ******************************* END LICENSE BLOCK ***************************/\n\n\n/**\n * Defines the AjaxConnector to connect to a remote server by making AjaxRequest.\n * @extends DataConnector\n * @example\n * import Ajax from 'osh/dataconnector/Ajax.js';\n *\n * let request = ...;\n * let connector = new Ajax(url);\n *\n * // handle onSuccess\n * connector.onSuccess = function(event) {\n *  // does something\n * }\n *\n * connector.onError = function(event) {\n *  // does something\n * }\n *\n * // send request\n * connector.sendRequest(request);\n *\n */\n\nclass Ajax_Ajax extends dataconnector_DataConnector {\n  /**\n   * Creates Ajax.\n   * @param {String} url -\n   * @param {Object} properties -\n   * @param {String} properties.method -\n   * @param {String} properties.responseType -\n   */\n  constructor(url, properties) {\n    super(url);\n    this.method = \"POST\";\n    this.responseType = \"arraybuffer\";\n\n    if (isDefined(properties)) {\n      if (properties.method) {\n        this.method = properties.method;\n      }\n\n      if (properties.responseType) {\n        this.responseType = properties.responseType;\n      }\n    }\n  }\n  /**\n   * Sends the request to the defined server.\n   * @param {String} request - The Http request\n   * @param {String} extraUrl - get query parameters\n   */\n\n\n  sendRequest(request, extraUrl) {\n    let self = this;\n    let xmlhttp = new XMLHttpRequest();\n    xmlhttp.withCredentials = true;\n    xmlhttp.timeout = 60000;\n\n    if (request === null) {\n      if (isDefined(extraUrl)) {\n        xmlhttp.open(\"GET\", this.getUrl() + \"?\" + extraUrl, true);\n      } else {\n        xmlhttp.open(\"GET\", this.getUrl(), true);\n      }\n\n      xmlhttp.responseType = this.responseType;\n\n      xmlhttp.onload = oEvent => {\n        if (xmlhttp.response) {\n          self.onMessage(xmlhttp.response);\n        }\n      };\n\n      xmlhttp.ontimeout = e => {\n        console.log(\"Timeout\");\n      };\n\n      xmlhttp.send(null);\n    } else {\n      xmlhttp.open(\"POST\", this.getUrl(), true);\n      xmlhttp.setRequestHeader('Content-Type', 'text/xml');\n      xmlhttp.send(request);\n\n      xmlhttp.onreadystatechange = () => {\n        if (xmlhttp.readyState < 4) {// while waiting response from server\n        } else if (xmlhttp.readyState === 4) {\n          // 4 = Response from server has been completely loaded.\n          if (xmlhttp.status === 200 && xmlhttp.status < 300) {\n            // http status between 200 to 299 are all successful\n            self.onSuccess(xmlhttp.responseText);\n          } else {\n            self.onError(\"\");\n          }\n        }\n      };\n    }\n  }\n  /**\n   * This is the callback method in case of getting error connection.\n   * @param event The error details\n   * @event\n   */\n\n\n  onError(event) {}\n  /**\n   * This is the callback method in case of getting success connection.\n   * @param event\n   * @event\n   */\n\n\n  onSuccess(event) {}\n  /**\n   * Sends the request\n   * @private\n   */\n\n\n  connect() {\n    this.sendRequest(null);\n  }\n\n}\n\n/* harmony default export */ var dataconnector_Ajax = (Ajax_Ajax);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/dataconnector/TopicConnector.js\n\n\nclass TopicConnector_TopicConnector extends dataconnector_DataConnector {\n  /**\n   *\n   * @param properties -\n   */\n  constructor(properties) {\n    super(properties);\n    this.lastReceiveTime = -1;\n    this.interval = -1;\n    this.broadcastChannel = null;\n  }\n  /**\n   * Connect to the broadcastChannel.\n   */\n\n\n  connect() {\n    if (this.broadcastChannel === null) {\n      //creates broadcastChannel\n      this.broadcastChannel = new BroadcastChannel(this.getUrl());\n\n      this.broadcastChannel.onmessage = event => {\n        this.lastReceiveTime = Date.now(); //callback data on message received\n\n        this.onMessage(event.data.data);\n      }; // closes socket if any errors occur\n\n\n      this.broadcastChannel.onerror = event => {\n        console.error('BroadcastChannel stream error: ' + event);\n        this.broadcastChannel.close();\n        this.init = false;\n        this.lastReceiveTime = -1;\n      }; //init the reconnect handler\n\n\n      if (this.interval === -1) {\n        this.interval = setInterval(function () {\n          let delta = Date.now() - this.lastReceiveTime; // -1 means the WS went in error\n\n          if (this.lastReceiveTime === -1 || delta >= this.reconnectTimeout) {\n            console.warn(`trying to reconnect after ${this.reconnectTimeout} ..`);\n            this.reconnect();\n          }\n        }.bind(this), this.reconnectTimeout);\n      }\n    }\n  }\n  /**\n   * Disconnects the websocket.\n   */\n\n\n  disconnect() {\n    this.fullDisconnect(true);\n  }\n  /**\n   * Fully disconnect the websocket connection by sending a close message to the webWorker.\n   * @param {Boolean} removeInterval  - force removing the interval\n   */\n\n\n  fullDisconnect(removeInterval) {\n    if (this.broadcastChannel != null) {\n      this.broadcastChannel.close();\n      this.broadcastChannel = null;\n    }\n\n    if (removeInterval) {\n      clearInterval(this.interval);\n    }\n  }\n  /**\n   * Try to reconnect if the connexion if closed\n   */\n\n\n  reconnect() {\n    this.onReconnect();\n\n    if (this.init) {\n      this.fullDisconnect(false);\n    }\n\n    this.connect();\n  }\n  /**\n   * The onMessage method used by the websocket to callback the data\n   * @param data the callback data\n   * @event\n   */\n\n\n  onMessage(data) {}\n  /**\n   * Closes the webSocket.\n   */\n\n\n  close() {\n    this.disconnect();\n  }\n\n}\n\n/* harmony default export */ var dataconnector_TopicConnector = (TopicConnector_TopicConnector);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/event/EventType.js\nconst EventType = {\n  DATA: 'data',\n  STATUS: 'status'\n};\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/datareceiver/workers/DataSourceHandler.js\n\n\n\n\n\n\n\nclass DataSourceHandler_DataSourceHandler {\n  constructor(parser) {\n    this.parser = parser;\n    this.connector = null;\n    this.lastTimeStamp = null;\n    this.lastStartTime = 'now';\n    this.timeShift = 0;\n    this.reconnectTimeout = 1000 * 10; // 10 secs\n\n    this.values = [];\n  }\n\n  createConnector(propertiesStr, topic, dataSourceId) {\n    this.dataSourceId = dataSourceId; // check for existing connector\n\n    if (this.connector !== null) {\n      this.connector.disconnect();\n      this.connector = null;\n    }\n\n    this.broadcastChannel = new BroadcastChannel(topic);\n    const properties = JSON.parse(propertiesStr);\n\n    if (isDefined(properties.fetch)) {\n      this.fetch = properties.fetch;\n    }\n\n    if (isDefined(properties.timeShift)) {\n      this.timeShift = properties.timeShift;\n    }\n\n    if (isDefined(properties.bufferingTime)) {\n      this.bufferingTime = properties.bufferingTime;\n    }\n\n    if (isDefined(properties.timeOut)) {\n      this.timeOut = properties.timeOut;\n    }\n\n    if (isDefined(properties.reconnectTimeout)) {\n      this.reconnectTimeout = properties.reconnectTimeout;\n    }\n\n    if (properties.startTime === 'now') {\n      this.batchSize = 1;\n    } else {\n      if (isDefined(properties.replaySpeed)) {\n        if (!isDefined(properties.batchSize)) {\n          this.batchSize = 1;\n        }\n      }\n\n      if (isDefined(properties.batchSize)) {\n        this.batchSize = properties.batchSize;\n      }\n    }\n\n    this.properties = properties;\n    this.createDataConnector(this.properties);\n  }\n  /**\n   * @private\n   */\n\n\n  createDataConnector(properties) {\n    const url = this.parser.buildUrl({ ...properties,\n      timeShift: this.timeShift\n    }); // checks if type is WebSocketConnector\n\n    if (properties.protocol.startsWith('ws')) {\n      this.connector = new dataconnector_WebSocketConnector(url); // connects the callback\n\n      this.connector.onMessage = this.onMessage.bind(this); // set the reconnectTimeout\n\n      this.connector.setReconnectTimeout(this.reconnectTimeout);\n    } else if (properties.protocol.startsWith('http')) {\n      this.connector = new dataconnector_Ajax(url);\n      this.connector.responseType = 'arraybuffer'; // connects the callback\n\n      this.connector.onMessage = this.onMessage.bind(this); // set the reconnectTimeout\n\n      this.connector.setReconnectTimeout(this.reconnectTimeout);\n    } else if (properties.protocol.startsWith('topic')) {\n      this.connector = new dataconnector_TopicConnector(url); // connects the callback\n\n      this.connector.onMessage = this.onMessage.bind(this); // set the reconnectTimeout\n\n      this.connector.setReconnectTimeout(this.reconnectTimeout);\n    }\n\n    const lastStartTimeCst = this.parser.lastStartTime;\n    const lastProperties = properties;\n\n    if (this.connector !== null) {\n      // bind change connection STATUS\n      this.connector.onChangeStatus = this.onChangeStatus.bind(this);\n\n      this.connector.onReconnect = () => {\n        // if not real time, preserve last timestamp to reconnect at the last time received\n        // for that, we update the URL with the new last time received\n        if (lastStartTimeCst !== 'now') {\n          this.connector.setUrl(this.parser.buildUrl({ ...properties,\n            lastTimeStamp: new Date(this.lastTimeStamp).toISOString()\n          }));\n        }\n\n        return true;\n      };\n    }\n  }\n  /**\n   * Sets the current topic to listen\n   * @param {String} topic - the topic to listen\n   */\n\n\n  setTopic(topic) {\n    if (this.broadcastChannel !== null) {\n      this.broadcastChannel.close();\n    }\n\n    this.broadcastChannel = new BroadcastChannel(topic);\n    this.topic = topic;\n  }\n\n  connect() {\n    if (this.connector !== null) {\n      this.connector.connect();\n    }\n  }\n\n  disconnect() {\n    if (this.connector !== null) {\n      this.connector.disconnect();\n    }\n\n    this.connector = null;\n  }\n\n  onMessage(event) {\n    const timeStamp = this.parser.parseTimeStamp(event) + this.timeShift;\n    const data = this.parser.parseData(event);\n    this.values.push({\n      data: data,\n      timeStamp: timeStamp\n    });\n    this.lastTimeStamp = timeStamp;\n\n    if (isDefined(this.batchSize) && this.values.length >= this.batchSize) {\n      this.flush();\n    }\n  }\n  /**\n   * Send a change status event into the broadcast channel\n   * @param {Status} status - the new status\n   */\n\n\n  onChangeStatus(status) {\n    if (status === Status.DISCONNECTED) {\n      this.flush();\n    }\n\n    this.broadcastChannel.postMessage({\n      type: EventType.STATUS,\n      status: status,\n      dataSourceId: this.dataSourceId\n    });\n  }\n\n  getLastTimeStamp() {\n    return this.lastTimeStamp;\n  }\n\n  updateUrl(properties) {\n    this.disconnect();\n    let lastTimestamp = new Date(this.lastTimeStamp).toISOString();\n\n    if (properties.hasOwnProperty('startTime')) {\n      lastTimestamp = properties.startTime;\n    } else if (this.properties.startTime === 'now') {\n      //handle RealTime\n      lastTimestamp = 'now';\n    }\n\n    this.createDataConnector({ ...this.properties,\n      ...properties,\n      lastTimeStamp: lastTimestamp\n    });\n    this.connect();\n  }\n\n  flush() {\n    this.broadcastChannel.postMessage({\n      dataSourceId: this.dataSourceId,\n      type: EventType.DATA,\n      values: this.values.splice(0, this.values.length)\n    });\n  }\n\n  handleMessage(message, worker) {\n    if (message.message === 'init') {\n      this.createConnector(message.properties, message.topic, message.id);\n    } else if (message.message === 'connect') {\n      this.connect();\n    } else if (message.message === 'disconnect') {\n      this.disconnect();\n    } else if (message.message === 'topic') {\n      this.setTopic(message.topic);\n    } else if (message.message === 'last-timestamp') {\n      const lastTimeStamp = this.getLastTimeStamp();\n      worker.postMessage({\n        message: 'last-timestamp',\n        data: lastTimeStamp\n      });\n    } else if (message.message === 'update-url') {\n      this.updateUrl(message.data);\n    } else if (message.message === 'is-connected') {\n      worker.postMessage({\n        message: 'is-connected',\n        data: this.connector === null ? false : this.connector.isConnected()\n      });\n    }\n  }\n\n}\n\n/* harmony default export */ var workers_DataSourceHandler = (DataSourceHandler_DataSourceHandler);\n// CONCATENATED MODULE: /home/nevro/Progs/progs-local/git-repo/OSH/osh-js/source/osh/datareceiver/workers/SweJson.worker.js\n\n\n\nconst dataSourceHandler = new workers_DataSourceHandler(new SweJson_parser());\n\nself.onmessage = (event) => {\n    dataSourceHandler.handleMessage(event.data, self);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2Uvb3NoL3V0aWxzL1V0aWxzLmpzPzI0M2EiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL29zaC9kYXRhcmVjZWl2ZXIvcGFyc2Vycy9EYXRhU291cmNlUGFyc2VyLmpzPzYwZmYiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL29zaC9kYXRhcmVjZWl2ZXIvcGFyc2Vycy9Td2VKc29uLnBhcnNlci5qcz83YjU3Iiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9vc2gvZGF0YWNvbm5lY3Rvci9TdGF0dXMuanM/MDk4NyIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2Uvb3NoL2RhdGFjb25uZWN0b3IvRGF0YUNvbm5lY3Rvci5qcz9jODM2Iiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9vc2gvZGF0YWNvbm5lY3Rvci9XZWJTb2NrZXRDb25uZWN0b3IuanM/MDU1YiIsIndlYnBhY2s6Ly8vL2hvbWUvbmV2cm8vUHJvZ3MvcHJvZ3MtbG9jYWwvZ2l0LXJlcG8vT1NIL29zaC1qcy9zb3VyY2Uvb3NoL2RhdGFjb25uZWN0b3IvQWpheC5qcz8xZmFkIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9vc2gvZGF0YWNvbm5lY3Rvci9Ub3BpY0Nvbm5lY3Rvci5qcz80ODFlIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9vc2gvZXZlbnQvRXZlbnRUeXBlLmpzPzEyZTEiLCJ3ZWJwYWNrOi8vLy9ob21lL25ldnJvL1Byb2dzL3Byb2dzLWxvY2FsL2dpdC1yZXBvL09TSC9vc2gtanMvc291cmNlL29zaC9kYXRhcmVjZWl2ZXIvd29ya2Vycy9EYXRhU291cmNlSGFuZGxlci5qcz9jNGIyIiwid2VicGFjazovLy8vaG9tZS9uZXZyby9Qcm9ncy9wcm9ncy1sb2NhbC9naXQtcmVwby9PU0gvb3NoLWpzL3NvdXJjZS9vc2gvZGF0YXJlY2VpdmVyL3dvcmtlcnMvU3dlSnNvbi53b3JrZXIuanM/Mjg0MyJdLCJuYW1lcyI6WyJNQVhfTE9ORyIsIk1hdGgiLCJwb3ciLCJpc0RlZmluZWQiLCJ2IiwiaGFzVmFsdWUiLCJoYXNUeXBlIiwiZXhwZWN0ZWRUeXBlIiwiaGFzVmFsIiwiaXNPYmplY3QiLCJsZXROYW1lIiwiaXNBcnJheSIsIkFycmF5IiwiaXNGdW5jdGlvbiIsImFzc2VydERlZmluZWQiLCJhc3NlcnRUeXBlIiwiYXNzZXJ0Qm9vbGVhbiIsImFzc2VydFN0cmluZyIsImFzc2VydE51bWJlciIsImFzc2VydFBvc2l0aXZlIiwiYXNzZXJ0T2JqZWN0IiwiYXNzZXJ0QXJyYXkiLCJhc3NlcnRGdW5jdGlvbiIsImFzc2VydEhhc1ZhbHVlIiwicmFuZG9tVVVJRCIsInJlcGxhY2UiLCJjIiwiciIsInJhbmRvbSIsInRvU3RyaW5nIiwic3RhbXBVVUlEIiwib2JqIiwiX29zaF9pZCIsIlBhcnNlQnl0ZXMiLCJidWZmZXIiLCJvZmZzZXQiLCJ0eXBlIiwidmlldyIsIkRhdGFWaWV3IiwidHlwZU1hcCIsImRvdWJsZSIsInZhbCIsImdldEZsb2F0NjQiLCJieXRlcyIsImZsb2F0NjQiLCJmbG9hdDMyIiwiZ2V0RmxvYXQzMiIsInNpZ25lZEJ5dGUiLCJnZXRJbnQ4Iiwic2lnbmVkSW50IiwiZ2V0SW50MzIiLCJzaWduZWRTaG9ydCIsImdldEludDE2IiwidW5zaWduZWRCeXRlIiwiZ2V0VWludDgiLCJ1bnNpZ25lZEludCIsImdldFVpbnQzMiIsInVuc2lnbmVkU2hvcnQiLCJnZXRVaW50MTYiLCJSZWFkRGF0YSIsInN0cnVjdCIsImRhdGEiLCJvZmZzZXRCeXRlcyIsImkiLCJmaWVsZHMiLCJsZW5ndGgiLCJjdXJyRmllbGRTdHJ1Y3QiLCJyZXQiLCJjb3VudCIsImlzTmFOIiwiaWQiLCJmaWVsZE5hbWUiLCJpZDJGaWVsZE1hcCIsImZpbmRGaWVsZEJ5TmFtZSIsImoiLCJmaWVsZCIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInB1c2giLCJHZXRSZXN1bHRPYmplY3QiLCJyZXN1bHRTdHJ1Y3R1cmUiLCJyZXN1bHQiLCJuYW1lIiwiaXRlbSIsImsiLCJpc09wZXJhIiwid2luZG93Iiwib3ByIiwiYWRkb25zIiwib3BlcmEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmRleE9mIiwiaXNGaXJlZm94IiwiSW5zdGFsbFRyaWdnZXIiLCJpc1NhZmFyaSIsIk9iamVjdCIsInByb3RvdHlwZSIsImNhbGwiLCJIVE1MRWxlbWVudCIsImlzQ2hyb21lIiwiY2hyb21lIiwid2Vic3RvcmUiLCJpc0JsaW5rIiwiQ1NTIiwiaXNBcnJheUludGVyc2VjdCIsImEiLCJiIiwiZmlsdGVyIiwiZWxlbWVudCIsImlzRWxlbWVudCIsIm8iLCJub2RlVHlwZSIsIm5vZGVOYW1lIiwiaXNXZWJXb3JrZXIiLCJXb3JrZXIiLCJ0YWtlU2NyZWVuU2hvdCIsImRpdiIsInJlbW92ZUNzcyIsImNzcyIsImRpdkNzcyIsImNsYXNzTmFtZSIsImFkZENzcyIsInNldEF0dHJpYnV0ZSIsInJlbW92ZUxhc3RDaGFySWZFeGlzdCIsInZhbHVlIiwidW5kZWZpbmVkIiwiZW5kc1dpdGgiLCJzdWJzdHJpbmciLCJEYXRhU291cmNlUGFyc2VyIiwiYnVpbGRVcmwiLCJwcm9wZXJ0aWVzIiwidXJsIiwicHJvdG9jb2wiLCJlbmRwb2ludFVybCIsInNlcnZpY2UiLCJvZmZlcmluZ0lEIiwiZm9pVVJOIiwib2JzZXJ2ZWRQcm9wZXJ0eSIsInN0VGltZSIsImxhc3RUaW1lU3RhbXAiLCJzdGFydFRpbWUiLCJsYXN0U3RhcnRUaW1lIiwiZW5kVGltZSIsInJlcGxheVNwZWVkIiwicmVzcG9uc2VGb3JtYXQiLCJjdXN0b21VcmxQYXJhbXMiLCJrZXlzIiwia2V5Iiwic2xpY2UiLCJTd2VKc29uUGFyc2VyIiwicGFyc2VUaW1lU3RhbXAiLCJyZWMiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsIlVpbnQ4QXJyYXkiLCJEYXRlIiwiZ2V0VGltZSIsInBhcnNlRGF0YSIsIlN0YXR1cyIsIkNPTk5FQ1RFRCIsIkRJU0NPTk5FQ1RFRCIsIkRhdGFDb25uZWN0b3IiLCJjb25zdHJ1Y3RvciIsInJlY29ubmVjdFRpbWVvdXQiLCJzdGF0dXMiLCJyZWNvbm5lY3Rpb25JbnRlcnZhbCIsImNoZWNrQW5kQ2xlYXJSZWNvbm5lY3Rpb24iLCJjbGVhckludGVydmFsIiwiZGlzY29ubmVjdCIsImNoZWNrU3RhdHVzIiwic2V0VXJsIiwiZ2V0SWQiLCJnZXRVcmwiLCJzZXRSZWNvbm5lY3RUaW1lb3V0IiwidGltZW91dCIsIm9uUmVjb25uZWN0IiwiY29ubmVjdCIsImZvcmNlUmVjb25uZWN0Iiwib25DaGFuZ2VTdGF0dXMiLCJvbkRpc2Nvbm5lY3QiLCJvbkNvbm5lY3QiLCJXZWJTb2NrZXRDb25uZWN0b3IiLCJpbnRlcnZhbCIsImxhc3RSZWNlaXZlVGltZSIsImluaXQiLCJjbG9zZWQiLCJ3cyIsIldlYlNvY2tldCIsImJpbmFyeVR5cGUiLCJvbm1lc3NhZ2UiLCJldmVudCIsIm5vdyIsImJ5dGVMZW5ndGgiLCJvbk1lc3NhZ2UiLCJiaW5kIiwib25lcnJvciIsImNvbnNvbGUiLCJlcnJvciIsImNyZWF0ZVJlY29ubmVjdGlvbiIsIm9uY2xvc2UiLCJ3YXJuIiwicmVhc29uIiwiY29kZSIsInNldEludGVydmFsIiwiZGVsdGEiLCJyZWFkeVN0YXRlIiwiQ0xPU0VEIiwiY2xvc2UiLCJpc0Nvbm5lY3RlZCIsIk9QRU4iLCJBamF4IiwibWV0aG9kIiwicmVzcG9uc2VUeXBlIiwic2VuZFJlcXVlc3QiLCJyZXF1ZXN0IiwiZXh0cmFVcmwiLCJzZWxmIiwieG1saHR0cCIsIlhNTEh0dHBSZXF1ZXN0Iiwid2l0aENyZWRlbnRpYWxzIiwib3BlbiIsIm9ubG9hZCIsIm9FdmVudCIsInJlc3BvbnNlIiwib250aW1lb3V0IiwiZSIsImxvZyIsInNlbmQiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib25yZWFkeXN0YXRlY2hhbmdlIiwib25TdWNjZXNzIiwicmVzcG9uc2VUZXh0Iiwib25FcnJvciIsIlRvcGljQ29ubmVjdG9yIiwiYnJvYWRjYXN0Q2hhbm5lbCIsIkJyb2FkY2FzdENoYW5uZWwiLCJyZWNvbm5lY3QiLCJmdWxsRGlzY29ubmVjdCIsInJlbW92ZUludGVydmFsIiwiRXZlbnRUeXBlIiwiREFUQSIsIlNUQVRVUyIsIkRhdGFTb3VyY2VIYW5kbGVyIiwicGFyc2VyIiwiY29ubmVjdG9yIiwidGltZVNoaWZ0IiwidmFsdWVzIiwiY3JlYXRlQ29ubmVjdG9yIiwicHJvcGVydGllc1N0ciIsInRvcGljIiwiZGF0YVNvdXJjZUlkIiwiZmV0Y2giLCJidWZmZXJpbmdUaW1lIiwidGltZU91dCIsImJhdGNoU2l6ZSIsImNyZWF0ZURhdGFDb25uZWN0b3IiLCJzdGFydHNXaXRoIiwibGFzdFN0YXJ0VGltZUNzdCIsImxhc3RQcm9wZXJ0aWVzIiwidG9JU09TdHJpbmciLCJzZXRUb3BpYyIsInRpbWVTdGFtcCIsImZsdXNoIiwicG9zdE1lc3NhZ2UiLCJnZXRMYXN0VGltZVN0YW1wIiwidXBkYXRlVXJsIiwibGFzdFRpbWVzdGFtcCIsImhhc093blByb3BlcnR5Iiwic3BsaWNlIiwiaGFuZGxlTWVzc2FnZSIsIm1lc3NhZ2UiLCJ3b3JrZXIiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTs7QUFFQTtBQUNPLE1BQU1BLFFBQVEsR0FBR0Ms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RUFBRWdGO0FBRlMsT0FBbkI7QUFJSCxLQU5NLE1BTUMsSUFBSW9JLE9BQU8sQ0FBQ0EsT0FBUixLQUFvQixZQUF4QixFQUFzQztBQUMxQyxXQUFLTCxTQUFMLENBQWVLLE9BQU8sQ0FBQ3BOLElBQXZCO0FBQ0gsS0FGTyxNQUVELElBQUlvTixPQUFPLENBQUNBLE9BQVIsS0FBb0IsY0FBeEIsRUFBd0M7QUFDM0NDLFlBQU0sQ0FBQ1IsV0FBUCxDQUFtQjtBQUNmTyxlQUFPLEVBQUUsY0FETTtBQUVmcE4sWUFBSSxFQUFHLEtBQUswTCxTQUFMLEtBQW1CLElBQXBCLEdBQTJCLEtBQTNCLEdBQWtDLEtBQUtBLFNBQUwsQ0FBZXBDLFdBQWY7QUFGekIsT0FBbkI7QUFJSDtBQUNKOztBQWhPbUI7O0FBa09Ua0MsaUdBQWYsRTs7QUN6T3NEO0FBQ0M7O0FBRXZELDhCQUE4Qix5QkFBaUIsS0FBSyxjQUFhOztBQUVqRTtBQUNBO0FBQ0EiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gVGhlIGNvbnRlbnRzIG9mIHRoaXMgZmlsZSBhcmUgc3ViamVjdCB0byB0aGUgTW96aWxsYSBQdWJsaWMgTGljZW5zZSwgdi4gMi4wLlxuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZVxuIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblxuIFNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2VcbiBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyByaWdodHMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gQ29weXJpZ2h0IChDKSAyMDE1LTIwMjAgTWF0aGlldSBEaGFpbmF1dC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuIEF1dGhvcjogTWF0aGlldSBEaGFpbmF1dCA8bWF0aGlldS5kaGFpbmF1dEBnbWFpbC5jb20+XG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqICogQG1vZHVsZSBVdGlscyAqL1xuXG4vKiogTWF4aW11bSB2YWx1ZSBvZiBhIGxvbmcgKi9cbmV4cG9ydCBjb25zdCBNQVhfTE9ORyA9IE1hdGgucG93KDIsIDUzKSArIDE7XG5cbi8qKlxuICogR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbmVkKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mICh2KSAhPT0gJ3VuZGVmaW5lZCcgJiYgdiAhPT0gbnVsbDtcbn1cblxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBoYXMgYSB2YWx1ZSxcbiB0aGF0IGlzIGl0IGlzIGRlZmluZWQgYW5kIG5vbiBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNWYWx1ZSh2KSB7XG4gICAgcmV0dXJuIGlzRGVmaW5lZCh2KSAmJiB2ICE9PSBudWxsO1xufVxuXG4vKipcbiBHbG9iYWwgaGVscGVyIG1ldGhvZCB0byB0ZXN0IGlmIGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBvZiBhIHBhcnRpY3VsYXIgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzVHlwZSh2LCBleHBlY3RlZFR5cGUpIHtcbiAgICBsZXQgaGFzVmFsID0gaGFzVmFsdWUodik7XG4gICAgcmV0dXJuIGhhc1ZhbCAmJiB0eXBlb2YgKHYpID09PSBleHBlY3RlZFR5cGU7XG59XG5cbi8qKlxuIEdsb2JhbCBoZWxwZXIgbWV0aG9kIHRvIHRlc3QgaWYgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBoYXNUeXBlKHYsICdvYmplY3QnLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYW4gYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkodikge1xuICAgIHJldHVybiBpc0RlZmluZWQodikgJiYgQXJyYXkuaXNBcnJheSh2KTtcbn1cblxuLyoqXG4gR2xvYmFsIGhlbHBlciBtZXRob2QgdG8gdGVzdCBpZiBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGhhc1R5cGUodiwgJ2Z1bmN0aW9uJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGlmICghaXNEZWZpbmVkKHYpKSB7XG4gICAgICAgIHRocm93IGxldE5hbWUgKyBcIiBtdXN0IGJlIGRlZmluZWRcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBkZWZpbmVkIGFuZCBub24tbnVsbFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFR5cGUodiwgZXhwZWN0ZWRUeXBlLCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKHR5cGVvZiAodikgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBiZSBvZiB0eXBlIFwiICsgZXhwZWN0ZWRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgc3RyaW5nXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Qm9vbGVhbih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ2Jvb2xlYW4nLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGEgc3RyaW5nXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U3RyaW5nKHYsIGxldE5hbWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0VHlwZSh2LCAnc3RyaW5nJywgbGV0TmFtZSk7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIG51bWJlclxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE51bWJlcih2LCBsZXROYW1lKSB7XG4gICAgcmV0dXJuIGFzc2VydFR5cGUodiwgJ251bWJlcicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgYSBudW1iZXJcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRQb3NpdGl2ZSh2LCBsZXROYW1lKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHYsIGxldE5hbWUpO1xuICAgIGlmICh2IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIjtcbiAgICB9XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhbiBvYmplY3RcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRPYmplY3QodiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdvYmplY3QnLCBsZXROYW1lKTtcbn1cblxuLyoqXG4gQXNzZXJ0IHRoYXQgYSBsZXRpYWJsZSBvciBvYmplY3QgYXR0cmlidXRlIGlzIGFuIG9iamVjdFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFycmF5KHYsIGxldE5hbWUgPSAnbGV0aWFibGUnKSB7XG4gICAgYXNzZXJ0RGVmaW5lZCh2LCBsZXROYW1lKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgdGhyb3cgbGV0TmFtZSArIFwiIG11c3QgYmUgYW4gYXJyYXlcIjtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qKlxuIEFzc2VydCB0aGF0IGEgbGV0aWFibGUgb3Igb2JqZWN0IGF0dHJpYnV0ZSBpcyBhIGZ1bmN0aW9uXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb24odiwgbGV0TmFtZSkge1xuICAgIHJldHVybiBhc3NlcnRUeXBlKHYsICdmdW5jdGlvbicsIGxldE5hbWUpO1xufVxuXG4vKipcbiBBc3NlcnQgdGhhdCBhIGxldGlhYmxlIG9yIG9iamVjdCBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBhbmQgbm9uLW51bGxcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRIYXNWYWx1ZSh2LCBsZXROYW1lID0gJ2xldGlhYmxlJykge1xuICAgIGFzc2VydERlZmluZWQodiwgbGV0TmFtZSk7XG4gICAgaWYgKCFoYXNWYWx1ZSh2KSkge1xuICAgICAgICB0aHJvdyBsZXROYW1lICsgXCIgbXVzdCBub3QgYmUgbnVsbFwiO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tVVVJRCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICBsZXQgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBzdGFtcHMvZW1iZWRzIGEgVVVJRCBpbnRvIGFuIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgVVVJRCBnZW5lcmF0ZWQgZm9yIGl0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFtcFVVSUQob2JqKSB7XG4gICAgb2JqLl9vc2hfaWQgPSBvYmouX29zaF9pZCB8fCByYW5kb21VVUlEKCk7XG4gICAgcmV0dXJuIG9iai5fb3NoX2lkO1xufVxuXG4vL2J1ZmZlciBpcyBhbiBBcnJheUJ1ZmZlciBvYmplY3QsIHRoZSBvZmZzZXQgaWYgc3BlY2lmaWVkIGluIGJ5dGVzLCBhbmQgdGhlIHR5cGUgaXMgYSBzdHJpbmdcbi8vY29ycmVzcG9uZGluZyB0byBhbiBPR0MgZGF0YSB0eXBlLlxuLy9TZWUgaHR0cDovL2RlZi5zZWVncmlkLmNzaXJvLmF1L3Npc3N2b2Mvb2djLWRlZi9yZXNvdXJjZT91cmk9aHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9kZWYvZGF0YVR5cGUvT0dDLzAvXG4vKipcbiAqXG4gKiBAcGFyYW0gYnVmZmVyXG4gKiBAcGFyYW0gb2Zmc2V0XG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFBhcnNlQnl0ZXMoYnVmZmVyLCBvZmZzZXQsIHR5cGUpIHtcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuXG4gICAgLy9Ob3RlOiBUaGVyZSBleGlzdCB0eXBlcyBub3QgbGlzdGVkIGluIHRoZSBtYXAgYmVsb3cgdGhhdCBoYXZlIE9HQyBkZWZpbml0aW9ucywgYnV0IG5vIGFwcHJvcHJpYXRlXG4gICAgLy9tZXRob2RzIG9yIGNvcnJlc3BvbmRpbmcgdHlwZXMgYXZhaWxhYmxlIGZvciBwYXJzaW5nIGluIGphdmFzY3JpcHQuIFRoZXkgYXJlIGZsb2F0MTI4LCBmbG9hdDE2LCBzaWduZWRMb25nLFxuICAgIC8vYW5kIHVuc2lnbmVkTG9uZ1xuICAgIGxldCB0eXBlTWFwID0ge1xuICAgICAgICBkb3VibGU6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEZsb2F0NjQob2Zmc2V0KSwgYnl0ZXM6IDh9O1xuICAgICAgICB9LFxuICAgICAgICBmbG9hdDY0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRGbG9hdDY0KG9mZnNldCksIGJ5dGVzOiA4fTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXQzMjogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHt2YWw6IHZpZXcuZ2V0RmxvYXQzMihvZmZzZXQpLCBieXRlczogNH07XG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25lZEJ5dGU6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDgob2Zmc2V0KSwgYnl0ZXM6IDF9O1xuICAgICAgICB9LFxuICAgICAgICBzaWduZWRJbnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDMyKG9mZnNldCksIGJ5dGVzOiA0fTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmVkU2hvcnQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB7dmFsOiB2aWV3LmdldEludDE2KG9mZnNldCksIGJ5dGVzOiAyfTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaWduZWRCeXRlOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50OChvZmZzZXQpLCBieXRlczogMX07XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2lnbmVkSW50OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50MzIob2Zmc2V0KSwgYnl0ZXM6IDR9O1xuICAgICAgICB9LFxuICAgICAgICB1bnNpZ25lZFNob3J0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbDogdmlldy5nZXRVaW50MTYob2Zmc2V0KSwgYnl0ZXM6IDJ9O1xuICAgICAgICB9LFxuICAgICAgICAvL1RPRE86IHN0cmluZy11dGYtODpcbiAgICB9O1xuICAgIHJldHVybiB0eXBlTWFwW3R5cGVdKG9mZnNldCk7XG59XG5cbi8vVGhpcyBmdW5jdGlvbiByZWN1cnNpdmxleSBpdGVyYXRlcyBvdmVyIHRoZSByZXN1bHRTdHJ1Y3R1cmUgdG8gZmlsbCBpblxuLy92YWx1ZXMgcmVhZCBmcm9tIGRhdGEgd2hpY2ggc2hvdWxkIGJlIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgdGhlIHBheWxvYWQgZnJvbSBhIHdlYnNvY2tldFxuLyoqXG4gKlxuICogQHBhcmFtIHN0cnVjdFxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBvZmZzZXRCeXRlc1xuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlYWREYXRhKHN0cnVjdCwgZGF0YSwgb2Zmc2V0Qnl0ZXMpIHtcbiAgICBsZXQgb2Zmc2V0ID0gb2Zmc2V0Qnl0ZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJ1Y3QuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjdXJyRmllbGRTdHJ1Y3QgPSBzdHJ1Y3QuZmllbGRzW2ldO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKGN1cnJGaWVsZFN0cnVjdC50eXBlKSAmJiBjdXJyRmllbGRTdHJ1Y3QudHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJldCA9IFBhcnNlQnl0ZXMoZGF0YSwgb2Zmc2V0LCBjdXJyRmllbGRTdHJ1Y3QudHlwZSk7XG4gICAgICAgICAgICBjdXJyRmllbGRTdHJ1Y3QudmFsID0gcmV0LnZhbDtcbiAgICAgICAgICAgIG9mZnNldCArPSByZXQuYnl0ZXM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWZpbmVkKGN1cnJGaWVsZFN0cnVjdC5jb3VudCkgJiYgY3VyckZpZWxkU3RydWN0LmNvdW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvL2NoZWNrIGlmIGNvdW50IGlzIGEgcmVmZXJlbmNlIHRvIGFub3RoZXIgbGV0aWFibGVcbiAgICAgICAgICAgIGlmIChpc05hTihjdXJyRmllbGRTdHJ1Y3QuY291bnQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gY3VyckZpZWxkU3RydWN0LmNvdW50O1xuICAgICAgICAgICAgICAgIGxldCBmaWVsZE5hbWUgPSBzdHJ1Y3QuaWQyRmllbGRNYXBbaWRdO1xuICAgICAgICAgICAgICAgIGN1cnJGaWVsZFN0cnVjdC5jb3VudCA9IHN0cnVjdC5maW5kRmllbGRCeU5hbWUoZmllbGROYW1lKS52YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGN1cnJGaWVsZFN0cnVjdC5jb3VudDsgYysrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjdXJyRmllbGRTdHJ1Y3QuZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY3VyckZpZWxkU3RydWN0LmZpZWxkc1tqXSkpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBSZWFkRGF0YShmaWVsZCwgZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY3VyckZpZWxkU3RydWN0LnZhbC5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHJlc3VsdFN0cnVjdHVyZVxuICogQHJldHVybiB7e319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBHZXRSZXN1bHRPYmplY3QocmVzdWx0U3RydWN0dXJlKSB7XG4gICAgLy9UT0RPOiBoYW5kbGUgY2FzZXMgZm9yIG5lc3RlZCBhcnJheXMgLyBtYXRyaXggZGF0YSB0eXBlc1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLmNvdW50KSkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0ubmFtZV0gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5jb3VudDsgYysrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtW3Jlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkc1trXS5uYW1lXSA9IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsW2NdLmZpZWxkc1trXS52YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRTdHJ1Y3R1cmUuZmllbGRzW2ldLm5hbWVdLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0U3RydWN0dXJlLmZpZWxkc1tpXS5uYW1lXSA9IHJlc3VsdFN0cnVjdHVyZS5maWVsZHNbaV0udmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09wZXJhKCkge1xuICAgIHJldHVybiAoISF3aW5kb3cub3ByICYmICEhb3ByLmFkZG9ucykgfHwgISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDA7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpcmVmb3goKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdy5IVE1MRWxlbWVudCkuaW5kZXhPZignQ29uc3RydWN0b3InKSA+IDA7XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Nocm9tZSgpIHtcbiAgICByZXR1cm4gISF3aW5kb3cuY2hyb21lICYmICEhd2luZG93LmNocm9tZS53ZWJzdG9yZTtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Knxib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCbGluaygpIHtcbiAgICByZXR1cm4gKGlzQ2hyb21lIHx8IGlzT3BlcmEpICYmICEhd2luZG93LkNTUztcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGFcbiAqIEBwYXJhbSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUludGVyc2VjdChhLCBiKSB7XG4gICAgcmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBiLmluZGV4T2YoZWxlbWVudCkgPiAtMTtcbiAgICB9KS5sZW5ndGggPiAwO1xufVxuXG5cbi8qKlxuICpcbiAqIEBwYXJhbSBvXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50KG8pIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIEhUTUxFbGVtZW50ID09PSBcIm9iamVjdFwiID8gbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogLy9ET00yXG4gICAgICAgIG8gJiYgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgbyAhPT0gbnVsbCAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSBcInN0cmluZ1wiXG4gICAgKTtcbn1cblxuLyoqXG4gKlxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzV2ViV29ya2VyKCkge1xuICAgIHJldHVybiBpc0RlZmluZWQoV29ya2VyKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGRpdlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFrZVNjcmVlblNob3QoZGl2KSB7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY3NzIGNsYXNzIGZyb20gYSB0aGUgZGl2IGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIGRpdiB0aGUgZGl2IHRvIHJlbW92ZSB0aGUgY2xhc3MgZnJvbVxuICogQHBhcmFtIGNzcyB0aGUgY3NzIGNsYXNzIHRvIHJlbW92ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ3NzKGRpdiwgY3NzKSB7XG4gICAgbGV0IGRpdkNzcyA9IGRpdi5jbGFzc05hbWU7XG4gICAgY3NzID0gZGl2Q3NzLnJlcGxhY2UoY3NzLCBcIlwiKTtcbiAgICBkaXYuY2xhc3NOYW1lID0gY3NzO1xufVxuXG5cbi8qKlxuICogQWRkIGEgY3NzIGNsYXNzIHRvIGEgdGhlIGRpdiBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSBkaXYgdGhlIGRpdiB0byBhZGQgdGhlIGNsYXNzIHRvXG4gKiBAcGFyYW0gY3NzIHRoZSBjc3MgY2xhc3MgdG8gYWRkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDc3MoZGl2LCBjc3MpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGl2LmNsYXNzTmFtZSArIFwiIFwiICsgY3NzKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBsYXN0IGNoYXJhY3RlciBvZiBhIHtzdHJpbmd9IG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBpbnB1dCB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUgd2l0aG91dCB0aGUgbGFzdCBjaGFyYWN0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUxhc3RDaGFySWZFeGlzdCh2YWx1ZSkge1xuICAgIGlmICghaXNEZWZpbmVkKHVuZGVmaW5lZCkgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwIHx8ICF2YWx1ZS5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG59XG5cbiIsImltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vLi4vdXRpbHMvVXRpbHNcIjtcblxuY2xhc3MgRGF0YVNvdXJjZVBhcnNlciB7XG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSBmdWxsIHVybC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5wcm90b2NvbCB0aGUgY29ubmVjdG9yIHByb3RvY29sXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuZW5kcG9pbnRVcmwgdGhlIGVuZHBvaW50IHVybFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0aWVzLnNlcnZpY2UgdGhlIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5vZmZlcmluZ0lEIHRoZSBvZmZlcmluZ0lEXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMub2JzZXJ2ZWRQcm9wZXJ0eSB0aGUgb2JzZXJ2ZWQgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5zdGFydFRpbWUgdGhlIHN0YXJ0IHRpbWUgKElTTyBmb3JtYXQpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMuZW5kVGltZSB0aGUgZW5kIHRpbWUgKElTTyBmb3JtYXQpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMucmVwbGF5U3BlZWQgdGhlIHJlcGxheSBmYWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy5yZXNwb25zZUZvcm1hdCB0aGUgcmVzcG9uc2UgZm9ybWF0IChlLmcgdmlkZW8vbXA0KVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gcHJvcGVydGllcy5sYXN0VGltZVN0YW1wIC0gdGhlIGxhc3QgdGltZXN0YW1wIHRvIHN0YXJ0IGF0IHRoaXMgdGltZSAoSVNPIFN0cmluZylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXMgLSB0aGUgZW5jb2Rpbmcgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLmN1c3RvbVVybFBhcmFtcy52aWRlb19iaXRyYXRlIC0gZGVmaW5lIGEgY3VzdG9tIGJpdHJhdGUgKGluIGIvcylcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXMudmlkZW9fc2NhbGUgLSBkZWZpbmUgYSBjdXN0b20gc2NhbGUsIDAuMCA8IHZhbHVlIDwgMS4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zLnZpZGVvX3dpZHRoIC0gZGVmaW5lIGEgY3VzdG9tIHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zLnZpZGVvX2hlaWdodCAtIGRlZmluZSBhIGN1c3RvbSBoZWlnaHRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBmdWxsIHVybFxuICAgICAqL1xuICAgIGJ1aWxkVXJsKHByb3BlcnRpZXMpIHtcbiAgICAgICAgbGV0IHVybCA9IFwiXCI7XG5cbiAgICAgICAgLy8gYWRkcyBwcm90b2NvbFxuICAgICAgICB1cmwgKz0gcHJvcGVydGllcy5wcm90b2NvbCArIFwiOi8vXCI7XG5cbiAgICAgICAgLy8gYWRkcyBlbmRwb2ludCB1cmxcbiAgICAgICAgdXJsICs9IHByb3BlcnRpZXMuZW5kcG9pbnRVcmwgKyBcIj9cIjtcblxuICAgICAgICAvLyBhZGRzIHNlcnZpY2VcbiAgICAgICAgdXJsICs9IFwic2VydmljZT1cIiArIHByb3BlcnRpZXMuc2VydmljZSArIFwiJlwiO1xuXG4gICAgICAgIC8vIGFkZHMgdmVyc2lvblxuICAgICAgICB1cmwgKz0gXCJ2ZXJzaW9uPTIuMCZcIjtcblxuICAgICAgICAvLyBhZGRzIHJlcXVlc3RcbiAgICAgICAgdXJsICs9IFwicmVxdWVzdD1HZXRSZXN1bHQmXCI7XG5cbiAgICAgICAgLy8gYWRkcyBvZmZlcmluZ1xuICAgICAgICB1cmwgKz0gXCJvZmZlcmluZz1cIiArIHByb3BlcnRpZXMub2ZmZXJpbmdJRCArIFwiJlwiO1xuXG4gICAgICAgIC8vIGFkZHMgZmVhdHVyZSBvZiBpbnRlcmVzdCB1cm5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMuZm9pVVJOICYmIHByb3BlcnRpZXMuZm9pVVJOICE9PSAnJykge1xuICAgICAgICAgICAgdXJsICs9ICdmZWF0dXJlT2ZJbnRlcmVzdD0nICsgcHJvcGVydGllcy5mb2lVUk4gKyAnJic7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGRzIG9ic2VydmVkUHJvcGVydHlcbiAgICAgICAgdXJsICs9IFwib2JzZXJ2ZWRQcm9wZXJ0eT1cIiArIHByb3BlcnRpZXMub2JzZXJ2ZWRQcm9wZXJ0eSArIFwiJlwiO1xuXG4gICAgICAgIC8vIGFkZHMgdGVtcG9yYWxGaWx0ZXJcbiAgICAgICAgY29uc3Qgc3RUaW1lID0gKGlzRGVmaW5lZChwcm9wZXJ0aWVzLmxhc3RUaW1lU3RhbXApKSA/IHByb3BlcnRpZXMubGFzdFRpbWVTdGFtcCA6ICBwcm9wZXJ0aWVzLnN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5sYXN0U3RhcnRUaW1lID0gcHJvcGVydGllcy5zdGFydFRpbWU7XG4gICAgICAgIGxldCBlbmRUaW1lID0gcHJvcGVydGllcy5lbmRUaW1lO1xuICAgICAgICB1cmwgKz0gXCJ0ZW1wb3JhbEZpbHRlcj1waGVub21lbm9uVGltZSxcIiArIHN0VGltZSsgXCIvXCIgKyBlbmRUaW1lICsgXCImXCI7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLnJlcGxheVNwZWVkKSB7XG4gICAgICAgICAgICAvLyBhZGRzIHJlcGxheVNwZWVkXG4gICAgICAgICAgICB1cmwgKz0gXCJyZXBsYXlTcGVlZD1cIiArIHByb3BlcnRpZXMucmVwbGF5U3BlZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGRzIHJlc3BvbnNlRm9ybWF0IChvcHRpb25hbClcbiAgICAgICAgaWYgKHByb3BlcnRpZXMucmVzcG9uc2VGb3JtYXQpIHtcbiAgICAgICAgICAgIHVybCArPSBcIiZyZXNwb25zZUZvcm1hdD1cIiArIHByb3BlcnRpZXMucmVzcG9uc2VGb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihpc0RlZmluZWQocHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXMpICYmIE9iamVjdC5rZXlzKHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB1cmwgKz0gJyYnO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHByb3BlcnRpZXMuY3VzdG9tVXJsUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdXJsICs9IGtleSsnPScrcHJvcGVydGllcy5jdXN0b21VcmxQYXJhbXNba2V5XSsnJic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih1cmwuZW5kc1dpdGgoJyYnKSkge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERhdGFTb3VyY2VQYXJzZXI7XG4iLCJpbXBvcnQgRGF0YVNvdXJjZVBhcnNlciBmcm9tIFwiLi9EYXRhU291cmNlUGFyc2VyXCI7XG5cbmNsYXNzIFN3ZUpzb25QYXJzZXIgZXh0ZW5kcyBEYXRhU291cmNlUGFyc2VyIHtcbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aW1lc3RhbXAgZnJvbSB0aGUgbWVzc2FnZS4gVGhlIHRpbWVzdGFtcCBjb3JyZXNwb25kcyB0byB0aGUgJ3RpbWUnIGF0dHJpYnV0ZSBvZiB0aGUgSlNPTiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgLSB0aGUgZGF0YSB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gdGhlIGV4dHJhY3RlZCB0aW1lc3RhbXBcbiAgICAgKi9cbiAgICBwYXJzZVRpbWVTdGFtcChkYXRhKSB7XG4gICAgICAgIGxldCByZWMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKEpTT04ucGFyc2UocmVjKVsndGltZSddKS5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBkYXRhIGZyb20gdGhlIG1lc3NhZ2UuIFRoZSBkYXRhIGFyZSBjb3JyZXNwb25kaW5nIHRvIHRoZSB3aG9sZSBsaXN0IG9mIGF0dHJpYnV0ZXMgb2YgdGhlIEpTT04gb2JqZWN0XG4gICAgICogZXhjZXB0aW5nIHRoZSAndGltZScgb25lLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gdGhlIGRhdGEgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBwYXJzZWQgZGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICoge1xuICAgICAqICAgbG9jYXRpb24gOiB7XG4gICAgICogICAgbGF0OjQzLjYxNzU4NjI2LFxuICAgICAqICAgIGxvbjogMS40MjM3NjU1NyxcbiAgICAgKiAgICBhbHQ6MTAwXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIHBhcnNlRGF0YShkYXRhKSB7XG4gICAgICAgIGxldCByZWMgPSBKU09OLnBhcnNlKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpKTtcblxuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIHJlYykge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSByZWNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGJ1aWxkVXJsKHByb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmJ1aWxkVXJsKHtcbiAgICAgICAgICAgIC4uLnByb3BlcnRpZXMsXG4gICAgICAgICAgICByZXNwb25zZUZvcm1hdDogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3dlSnNvblBhcnNlcjtcbiIsIi8qKlxuICogRW51bSBmb3IgY29ubmVjdGlvbiBzdGF0dXMuXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHt7bmFtZTogc3RyaW5nfX1cbiAqL1xuZXhwb3J0IGNvbnN0IFN0YXR1cyA9IHtcbiAgICBDT05ORUNURUQ6ICBcImNvbm5lY3RlZFwiLFxuICAgIERJU0NPTk5FQ1RFRDogXCJkaXNjb25uZWN0ZWRcIlxufTtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gVGhlIGNvbnRlbnRzIG9mIHRoaXMgZmlsZSBhcmUgc3ViamVjdCB0byB0aGUgTW96aWxsYSBQdWJsaWMgTGljZW5zZSwgdi4gMi4wLlxuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZVxuIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblxuIFNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2VcbiBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyByaWdodHMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gQ29weXJpZ2h0IChDKSAyMDE1LTIwMjAgTWF0aGlldSBEaGFpbmF1dC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuIEF1dGhvcjogTWF0aGlldSBEaGFpbmF1dCA8bWF0aGlldS5kaGFpbmF1dEBnbWFpbC5jb20+XG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuaW1wb3J0IHtyYW5kb21VVUlEfSBmcm9tICcuLi91dGlscy9VdGlscy5qcyc7XG5pbXBvcnQge1N0YXR1c30gZnJvbSAnLi9TdGF0dXMuanMnO1xuXG4vKipcbiAqIFRoZSBEYXRhQ29ubmVjdG9yIGlzIHRoZSBhYnN0cmFjdCBjbGFzcyB1c2VkIHRvIGNyZWF0ZSBkaWZmZXJlbnQgY29ubmVjdG9ycy5cbiAqL1xuY2xhc3MgRGF0YUNvbm5lY3RvciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIFRoZSBmdWxsIHVybCB1c2VkIHRvIGNvbm5lY3QgdG8gdGhlIGRhdGEgc3RyZWFtXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmlkID0gXCJEYXRhQ29ubmVjdG9yLVwiICsgcmFuZG9tVVVJRCgpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSAxMDAwICogNjAgKiAyOyAvLzIgbWluXG4gICAgICAgIHRoaXMuc3RhdHVzID0gIFN0YXR1cy5ESVNDT05ORUNURUQ7XG4gICAgICAgIHRoaXMucmVjb25uZWN0aW9uSW50ZXJ2YWwgPSAtMTtcbiAgICB9XG5cbiAgICBjaGVja0FuZENsZWFyUmVjb25uZWN0aW9uKCkge1xuICAgICAgICBpZih0aGlzLnJlY29ubmVjdGlvbkludGVydmFsICE9PSAtMSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlY29ubmVjdGlvbkludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0aW9uSW50ZXJ2YWwgPSAtMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tTdGF0dXMoU3RhdHVzLkRJU0NPTk5FQ1RFRCk7XG4gICAgICAgIHRoaXMuY2hlY2tBbmRDbGVhclJlY29ubmVjdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHVybFxuICAgICAqIEBwYXJhbSB1cmxcbiAgICAgKi9cbiAgICBzZXRVcmwodXJsKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIGNvbm5lY3RvciBkZWZhdWx0IGlkLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmVhbSB1cmwuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiB0aW1lb3V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgLSBkZWxheSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIHJlY29ubmVjdGluZyBkYXRhU291cmNlXG4gICAgICovXG4gICAgc2V0UmVjb25uZWN0VGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHRpbWVvdXQ7XG4gICAgfVxuXG4gICAgb25SZWNvbm5lY3QoKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29ubmVjdCgpIHt9XG5cbiAgICBmb3JjZVJlY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9uIFNUQVRVUyBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHtTdGF0dXN9IHN0YXR1cyAtIHRoZSBuZXcgc3RhdHVzXG4gICAgICovXG4gICAgb25DaGFuZ2VTdGF0dXMoc3RhdHVzKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBhIGNoYW5nZSBvZiB0aGUgc3RhdHVzIGFuZCBjYWxsIHRoZSBjb3JyZXNwb25kaW5nIGNhbGxiYWNrcyBpZiBuZWNlc3NhcnlcbiAgICAgKiBAcGFyYW0ge1N0YXR1c30gc3RhdHVzIC0gdGhlIGN1cnJlbnRTdGF0dXNcbiAgICAgKi9cbiAgICBjaGVja1N0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgaWYoc3RhdHVzICE9PSB0aGlzLnN0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZVN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbm5lY3RvciBoYXMgYmVlbiBkaXNjb25uZWN0ZWRcbiAgICAgKi9cbiAgICBvbkRpc2Nvbm5lY3QoKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdG9yIGhhcyBiZWVuIGNvbm5lY3RlZFxuICAgICAqL1xuICAgIG9uQ29ubmVjdCgpIHtcblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YUNvbm5lY3RvcjtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gVGhlIGNvbnRlbnRzIG9mIHRoaXMgZmlsZSBhcmUgc3ViamVjdCB0byB0aGUgTW96aWxsYSBQdWJsaWMgTGljZW5zZSwgdi4gMi4wLlxuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZVxuIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblxuIFNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2VcbiBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyByaWdodHMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gQ29weXJpZ2h0IChDKSAyMDE1LTIwMjAgTWF0aGlldSBEaGFpbmF1dC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuIEF1dGhvcjogTWF0aGlldSBEaGFpbmF1dCA8bWF0aGlldS5kaGFpbmF1dEBnbWFpbC5jb20+XG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuaW1wb3J0IERhdGFDb25uZWN0b3IgZnJvbSAnLi9EYXRhQ29ubmVjdG9yLmpzJztcbmltcG9ydCB7aXNXZWJXb3JrZXJ9IGZyb20gJy4uL3V0aWxzL1V0aWxzLmpzJztcbmltcG9ydCB7U3RhdHVzfSBmcm9tICcuL1N0YXR1cy5qcyc7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgV2ViU29ja2V0Q29ubmVjdG9yIHRvIGNvbm5lY3QgdG8gYSByZW1vdGUgc2VydmVyIGJ5IGNyZWF0aW5nIGEgV2ViU29ja2V0IGNoYW5uZWwuXG4gKiBAZXh0ZW5kcyBEYXRhQ29ubmVjdG9yXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IFdlYlNvY2tldENvbm5lY3RvciBmcm9tICdvc2gvZGF0YWNvbm5lY3Rvci9XZWJTb2NrZXRDb25uZWN0b3IuanMnO1xuICpcbiAqIGxldCB1cmwgPSAuLi47XG4gKiBsZXQgY29ubmVjdG9yID0gbmV3IFdlYlNvY2tldENvbm5lY3Rvcih1cmwpO1xuICpcbiAqIC8vIGNvbm5lY3RcbiAqIGNvbm5lY3Rvci5jb25uZWN0KCk7XG4gKlxuICogLy8gZGlzY29ubmVjdFxuICogY29ubmVjdG9yLmRpc2Nvbm5lY3QoKTtcbiAqXG4gKiAvLyBjbG9zZVxuICogY29ubmVjdG9yLmNsb3NlKCk7XG4gKlxuICovXG5cbmNsYXNzIFdlYlNvY2tldENvbm5lY3RvciBleHRlbmRzIERhdGFDb25uZWN0b3Ige1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3BlcnRpZXMgLVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcbiAgICAgICAgc3VwZXIocHJvcGVydGllcyk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0UmVjZWl2ZVRpbWUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdG8gdGhlIHdlYlNvY2tldC4gSWYgdGhlIHN5c3RlbSBzdXBwb3J0cyBXZWJXb3JrZXIsIGl0IHdpbGwgYXV0b21hdGljYWxseSBjcmVhdGVzIG9uZSBvdGhlcndpc2UgdXNlXG4gICAgICogdGhlIG1haW4gdGhyZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbml0KSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vY3JlYXRlcyBXZWIgU29ja2V0XG4gICAgICAgICAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldCh0aGlzLmdldFVybCgpKTtcbiAgICAgICAgICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tBbmRDbGVhclJlY29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tTdGF0dXMoU3RhdHVzLkNPTk5FQ1RFRCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVjZWl2ZVRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgICAgICAgLy9jYWxsYmFjayBkYXRhIG9uIG1lc3NhZ2UgcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS5ieXRlTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTWVzc2FnZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIGNsb3NlcyBzb2NrZXQgaWYgYW55IGVycm9ycyBvY2N1clxuICAgICAgICAgICAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignV2ViU29ja2V0IHN0cmVhbSBlcnJvcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tTdGF0dXMoU3RhdHVzLkRJU0NPTk5FQ1RFRCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVjZWl2ZVRpbWUgPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVJlY29ubmVjdGlvbigpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU3RhdHVzKFN0YXR1cy5ESVNDT05ORUNURUQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV2ViU29ja2V0IHN0cmVhbSBjbG9zZWQ6ICcsZXZlbnQucmVhc29uLCBldmVudC5jb2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZihldmVudC5jb2RlICE9PSAxMDAwICYmICF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVJlY29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVSZWNvbm5lY3Rpb24oKSB7XG4gICAgICAgIGlmKHRoaXMucmVjb25uZWN0aW9uSW50ZXJ2YWwgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLm9uUmVjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdGlvbkludGVydmFsID0gIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVsdGEgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0UmVjZWl2ZVRpbWU7XG4gICAgICAgICAgICAgICAgLy8gLTEgbWVhbnMgdGhlIFdTIHdlbnQgaW4gZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0UmVjZWl2ZVRpbWUgPT09IC0xIHx8IChkZWx0YSA+PSB0aGlzLnJlY29ubmVjdFRpbWVvdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigndHJ5aW5nIHRvIHJlY29ubmVjdCcsIHRoaXMudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgYW5kIGNsb3NlIHRoZSB3ZWJzb2NrZXQuXG4gICAgICovXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICBzdXBlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuaW5pdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLndzICE9IG51bGwgJiYgdGhpcy53cy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuQ0xPU0VEKSB7XG4gICAgICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb25NZXNzYWdlIG1ldGhvZCB1c2VkIGJ5IHRoZSB3ZWJzb2NrZXQgdG8gY2FsbGJhY2sgdGhlIGRhdGFcbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgY2FsbGJhY2sgZGF0YVxuICAgICAqIEBldmVudFxuICAgICAqL1xuICAgIG9uTWVzc2FnZShkYXRhKSB7XG4gICAgfVxuXG5cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLndzICE9IG51bGwgJiYgdGhpcy53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTik7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBXZWJTb2NrZXRDb25uZWN0b3I7XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuIFRoZSBjb250ZW50cyBvZiB0aGlzIGZpbGUgYXJlIHN1YmplY3QgdG8gdGhlIE1vemlsbGEgUHVibGljIExpY2Vuc2UsIHYuIDIuMC5cbiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmVcbiBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG5cbiBTb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgYmFzaXMsXG4gV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlXG4gZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcmlnaHRzIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuIENvcHlyaWdodCAoQykgMjAxNS0yMDIwIE1hdGhpZXUgRGhhaW5hdXQuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbiBBdXRob3I6IE1hdGhpZXUgRGhhaW5hdXQgPG1hdGhpZXUuZGhhaW5hdXRAZ21haWwuY29tPlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmltcG9ydCBEYXRhQ29ubmVjdG9yIGZyb20gJy4vRGF0YUNvbm5lY3Rvci5qcyc7XG5pbXBvcnQge2lzRGVmaW5lZH0gZnJvbSAnLi4vdXRpbHMvVXRpbHMuanMnO1xuXG4vKipcbiAqIERlZmluZXMgdGhlIEFqYXhDb25uZWN0b3IgdG8gY29ubmVjdCB0byBhIHJlbW90ZSBzZXJ2ZXIgYnkgbWFraW5nIEFqYXhSZXF1ZXN0LlxuICogQGV4dGVuZHMgRGF0YUNvbm5lY3RvclxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBBamF4IGZyb20gJ29zaC9kYXRhY29ubmVjdG9yL0FqYXguanMnO1xuICpcbiAqIGxldCByZXF1ZXN0ID0gLi4uO1xuICogbGV0IGNvbm5lY3RvciA9IG5ldyBBamF4KHVybCk7XG4gKlxuICogLy8gaGFuZGxlIG9uU3VjY2Vzc1xuICogY29ubmVjdG9yLm9uU3VjY2VzcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgLy8gZG9lcyBzb21ldGhpbmdcbiAqIH1cbiAqXG4gKiBjb25uZWN0b3Iub25FcnJvciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgLy8gZG9lcyBzb21ldGhpbmdcbiAqIH1cbiAqXG4gKiAvLyBzZW5kIHJlcXVlc3RcbiAqIGNvbm5lY3Rvci5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcbiAqXG4gKi9cbmNsYXNzIEFqYXggZXh0ZW5kcyBEYXRhQ29ubmVjdG9yIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgQWpheC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIC1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMubWV0aG9kIC1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5yZXNwb25zZVR5cGUgLVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgcHJvcGVydGllcykge1xuICAgICAgICBzdXBlcih1cmwpO1xuXG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJQT1NUXCI7XG4gICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuXG4gICAgICAgIGlmIChpc0RlZmluZWQocHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kID0gcHJvcGVydGllcy5tZXRob2Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gcHJvcGVydGllcy5yZXNwb25zZVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyB0aGUgcmVxdWVzdCB0byB0aGUgZGVmaW5lZCBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3QgLSBUaGUgSHR0cCByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV4dHJhVXJsIC0gZ2V0IHF1ZXJ5IHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBzZW5kUmVxdWVzdChyZXF1ZXN0LCBleHRyYVVybCkge1xuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCB4bWxodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhtbGh0dHAud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgeG1saHR0cC50aW1lb3V0ID0gNjAwMDA7XG4gICAgICAgIGlmIChyZXF1ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGV4dHJhVXJsKSkge1xuICAgICAgICAgICAgICAgIHhtbGh0dHAub3BlbihcIkdFVFwiLCB0aGlzLmdldFVybCgpICsgXCI/XCIgKyBleHRyYVVybCwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHhtbGh0dHAub3BlbihcIkdFVFwiLCB0aGlzLmdldFVybCgpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhtbGh0dHAucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XG4gICAgICAgICAgICB4bWxodHRwLm9ubG9hZCA9IChvRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoeG1saHR0cC5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uTWVzc2FnZSh4bWxodHRwLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeG1saHR0cC5vbnRpbWVvdXQgPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVGltZW91dFwiKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHhtbGh0dHAuc2VuZChudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhtbGh0dHAub3BlbihcIlBPU1RcIiwgdGhpcy5nZXRVcmwoKSwgdHJ1ZSk7XG4gICAgICAgICAgICB4bWxodHRwLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3htbCcpO1xuXG4gICAgICAgICAgICB4bWxodHRwLnNlbmQocmVxdWVzdCk7XG5cbiAgICAgICAgICAgIHhtbGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh4bWxodHRwLnJlYWR5U3RhdGUgPCA0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWxlIHdhaXRpbmcgcmVzcG9uc2UgZnJvbSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHhtbGh0dHAucmVhZHlTdGF0ZSA9PT0gNCkgeyAgICAgICAgICAgICAgICAvLyA0ID0gUmVzcG9uc2UgZnJvbSBzZXJ2ZXIgaGFzIGJlZW4gY29tcGxldGVseSBsb2FkZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICh4bWxodHRwLnN0YXR1cyA9PT0gMjAwICYmIHhtbGh0dHAuc3RhdHVzIDwgMzAwKSB7IC8vIGh0dHAgc3RhdHVzIGJldHdlZW4gMjAwIHRvIDI5OSBhcmUgYWxsIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25TdWNjZXNzKHhtbGh0dHAucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25FcnJvcihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBjYWxsYmFjayBtZXRob2QgaW4gY2FzZSBvZiBnZXR0aW5nIGVycm9yIGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBlcnJvciBkZXRhaWxzXG4gICAgICogQGV2ZW50XG4gICAgICovXG4gICAgb25FcnJvcihldmVudCkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgY2FsbGJhY2sgbWV0aG9kIGluIGNhc2Ugb2YgZ2V0dGluZyBzdWNjZXNzIGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQGV2ZW50XG4gICAgICovXG4gICAgb25TdWNjZXNzKGV2ZW50KSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyB0aGUgcmVxdWVzdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChudWxsKTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBBamF4O1xuIiwiaW1wb3J0IERhdGFDb25uZWN0b3IgZnJvbSBcIi4vRGF0YUNvbm5lY3RvclwiO1xuXG5jbGFzcyBUb3BpY0Nvbm5lY3RvciBleHRlbmRzIERhdGFDb25uZWN0b3Ige1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3BlcnRpZXMgLVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcbiAgICAgICAgc3VwZXIocHJvcGVydGllcyk7XG4gICAgICAgIHRoaXMubGFzdFJlY2VpdmVUaW1lID0gLTE7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSAtMTtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRvIHRoZSBicm9hZGNhc3RDaGFubmVsLlxuICAgICAqL1xuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmJyb2FkY2FzdENoYW5uZWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vY3JlYXRlcyBicm9hZGNhc3RDaGFubmVsXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbCh0aGlzLmdldFVybCgpKTtcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5vbm1lc3NhZ2UgPSAgKGV2ZW50KSAgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFJlY2VpdmVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAvL2NhbGxiYWNrIGRhdGEgb24gbWVzc2FnZSByZWNlaXZlZFxuICAgICAgICAgICAgICAgIHRoaXMub25NZXNzYWdlKGV2ZW50LmRhdGEuZGF0YSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBjbG9zZXMgc29ja2V0IGlmIGFueSBlcnJvcnMgb2NjdXJcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5vbmVycm9yID0gIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Jyb2FkY2FzdENoYW5uZWwgc3RyZWFtIGVycm9yOiAnICsgZXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFJlY2VpdmVUaW1lID0gLTE7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvL2luaXQgdGhlIHJlY29ubmVjdCBoYW5kbGVyXG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcnZhbCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsdGEgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0UmVjZWl2ZVRpbWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIC0xIG1lYW5zIHRoZSBXUyB3ZW50IGluIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RSZWNlaXZlVGltZSA9PT0gLTEgfHwgKGRlbHRhID49IHRoaXMucmVjb25uZWN0VGltZW91dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgdHJ5aW5nIHRvIHJlY29ubmVjdCBhZnRlciAke3RoaXMucmVjb25uZWN0VGltZW91dH0gLi5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyB0aGUgd2Vic29ja2V0LlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZnVsbERpc2Nvbm5lY3QodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVsbHkgZGlzY29ubmVjdCB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gYnkgc2VuZGluZyBhIGNsb3NlIG1lc3NhZ2UgdG8gdGhlIHdlYldvcmtlci5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZUludGVydmFsICAtIGZvcmNlIHJlbW92aW5nIHRoZSBpbnRlcnZhbFxuICAgICAqL1xuICAgIGZ1bGxEaXNjb25uZWN0KHJlbW92ZUludGVydmFsKSB7XG4gICAgICAgIGlmICh0aGlzLmJyb2FkY2FzdENoYW5uZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW1vdmVJbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyeSB0byByZWNvbm5lY3QgaWYgdGhlIGNvbm5leGlvbiBpZiBjbG9zZWRcbiAgICAgKi9cbiAgICByZWNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMub25SZWNvbm5lY3QoKTtcbiAgICAgICAgaWYgKHRoaXMuaW5pdCkge1xuICAgICAgICAgICAgdGhpcy5mdWxsRGlzY29ubmVjdChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb25NZXNzYWdlIG1ldGhvZCB1c2VkIGJ5IHRoZSB3ZWJzb2NrZXQgdG8gY2FsbGJhY2sgdGhlIGRhdGFcbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgY2FsbGJhY2sgZGF0YVxuICAgICAqIEBldmVudFxuICAgICAqL1xuICAgIG9uTWVzc2FnZShkYXRhKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB3ZWJTb2NrZXQuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVG9waWNDb25uZWN0b3I7XG4iLCJleHBvcnQgY29uc3QgRXZlbnRUeXBlID0ge1xuICAgIERBVEE6ICdkYXRhJyxcbiAgICBTVEFUVVM6ICdzdGF0dXMnXG59O1xuIiwiaW1wb3J0IFdlYlNvY2tldENvbm5lY3RvciBmcm9tIFwiLi4vLi4vZGF0YWNvbm5lY3Rvci9XZWJTb2NrZXRDb25uZWN0b3IuanNcIjtcbmltcG9ydCBBamF4IGZyb20gXCIuLi8uLi9kYXRhY29ubmVjdG9yL0FqYXguanNcIjtcbmltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vLi4vdXRpbHMvVXRpbHMuanNcIjtcbmltcG9ydCBUb3BpY0Nvbm5lY3RvciBmcm9tIFwiLi4vLi4vZGF0YWNvbm5lY3Rvci9Ub3BpY0Nvbm5lY3Rvci5qc1wiO1xuaW1wb3J0IHtFdmVudFR5cGV9IGZyb20gXCIuLi8uLi9ldmVudC9FdmVudFR5cGUuanNcIjtcbmltcG9ydCB7U3RhdHVzfSBmcm9tIFwiLi4vLi4vZGF0YWNvbm5lY3Rvci9TdGF0dXNcIjtcblxuY2xhc3MgRGF0YVNvdXJjZUhhbmRsZXIge1xuXG4gICAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFRpbWVTdGFtcCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFN0YXJ0VGltZSA9ICdub3cnO1xuICAgICAgICB0aGlzLnRpbWVTaGlmdCA9IDA7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IDEwMDAgKiAxMDsgLy8gMTAgc2Vjc1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIH1cblxuICAgIGNyZWF0ZUNvbm5lY3Rvcihwcm9wZXJ0aWVzU3RyLCB0b3BpYywgZGF0YVNvdXJjZUlkKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZUlkID0gZGF0YVNvdXJjZUlkO1xuICAgICAgICAvLyBjaGVjayBmb3IgZXhpc3RpbmcgY29ubmVjdG9yXG4gICAgICAgIGlmKHRoaXMuY29ubmVjdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwodG9waWMpO1xuXG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBKU09OLnBhcnNlKHByb3BlcnRpZXNTdHIpO1xuXG4gICAgICAgIGlmIChpc0RlZmluZWQocHJvcGVydGllcy5mZXRjaCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmV0Y2ggPSBwcm9wZXJ0aWVzLmZldGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmaW5lZChwcm9wZXJ0aWVzLnRpbWVTaGlmdCkpIHtcbiAgICAgICAgICAgIHRoaXMudGltZVNoaWZ0ID0gcHJvcGVydGllcy50aW1lU2hpZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWZpbmVkKHByb3BlcnRpZXMuYnVmZmVyaW5nVGltZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyaW5nVGltZSA9IHByb3BlcnRpZXMuYnVmZmVyaW5nVGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZmluZWQocHJvcGVydGllcy50aW1lT3V0KSkge1xuICAgICAgICAgICAgdGhpcy50aW1lT3V0ID0gcHJvcGVydGllcy50aW1lT3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmaW5lZChwcm9wZXJ0aWVzLnJlY29ubmVjdFRpbWVvdXQpKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBwcm9wZXJ0aWVzLnJlY29ubmVjdFRpbWVvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihwcm9wZXJ0aWVzLnN0YXJ0VGltZSA9PT0gJ25vdycpIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hTaXplID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQocHJvcGVydGllcy5yZXBsYXlTcGVlZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGVmaW5lZChwcm9wZXJ0aWVzLmJhdGNoU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXRjaFNpemUgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChwcm9wZXJ0aWVzLmJhdGNoU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhdGNoU2l6ZSA9IHByb3BlcnRpZXMuYmF0Y2hTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICAgICAgdGhpcy5jcmVhdGVEYXRhQ29ubmVjdG9yKHRoaXMucHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjcmVhdGVEYXRhQ29ubmVjdG9yKHByb3BlcnRpZXMpIHtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5wYXJzZXIuYnVpbGRVcmwoe1xuICAgICAgICAgICAgLi4ucHJvcGVydGllcyxcbiAgICAgICAgICAgIHRpbWVTaGlmdDogdGhpcy50aW1lU2hpZnRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNoZWNrcyBpZiB0eXBlIGlzIFdlYlNvY2tldENvbm5lY3RvclxuICAgICAgICBpZiAocHJvcGVydGllcy5wcm90b2NvbC5zdGFydHNXaXRoKCd3cycpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG5ldyBXZWJTb2NrZXRDb25uZWN0b3IodXJsKTtcbiAgICAgICAgICAgIC8vIGNvbm5lY3RzIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3Iub25NZXNzYWdlID0gdGhpcy5vbk1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIC8vIHNldCB0aGUgcmVjb25uZWN0VGltZW91dFxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3Iuc2V0UmVjb25uZWN0VGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnRpZXMucHJvdG9jb2wuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG5ldyBBamF4KHVybCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgLy8gY29ubmVjdHMgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5vbk1lc3NhZ2UgPSB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgLy8gc2V0IHRoZSByZWNvbm5lY3RUaW1lb3V0XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5zZXRSZWNvbm5lY3RUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydGllcy5wcm90b2NvbC5zdGFydHNXaXRoKCd0b3BpYycpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG5ldyBUb3BpY0Nvbm5lY3Rvcih1cmwpO1xuICAgICAgICAgICAgLy8gY29ubmVjdHMgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5vbk1lc3NhZ2UgPSB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgLy8gc2V0IHRoZSByZWNvbm5lY3RUaW1lb3V0XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5zZXRSZWNvbm5lY3RUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsYXN0U3RhcnRUaW1lQ3N0ID0gdGhpcy5wYXJzZXIubGFzdFN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgbGFzdFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGJpbmQgY2hhbmdlIGNvbm5lY3Rpb24gU1RBVFVTXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5vbkNoYW5nZVN0YXR1cyAgID0gdGhpcy5vbkNoYW5nZVN0YXR1cy5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5vblJlY29ubmVjdCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgcmVhbCB0aW1lLCBwcmVzZXJ2ZSBsYXN0IHRpbWVzdGFtcCB0byByZWNvbm5lY3QgYXQgdGhlIGxhc3QgdGltZSByZWNlaXZlZFxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGF0LCB3ZSB1cGRhdGUgdGhlIFVSTCB3aXRoIHRoZSBuZXcgbGFzdCB0aW1lIHJlY2VpdmVkXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RTdGFydFRpbWVDc3QgIT09ICdub3cnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnNldFVybCh0aGlzLnBhcnNlci5idWlsZFVybChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RUaW1lU3RhbXA6IG5ldyBEYXRlKHRoaXMubGFzdFRpbWVTdGFtcCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHRvcGljIHRvIGxpc3RlblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b3BpYyAtIHRoZSB0b3BpYyB0byBsaXN0ZW5cbiAgICAgKi9cbiAgICBzZXRUb3BpYyh0b3BpYykge1xuICAgICAgICBpZih0aGlzLmJyb2FkY2FzdENoYW5uZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKHRvcGljKTtcbiAgICAgICAgdGhpcy50b3BpYyA9IHRvcGljO1xuICAgIH1cblxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmKHRoaXMuY29ubmVjdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICBpZih0aGlzLmNvbm5lY3RvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgdGltZVN0YW1wID0gdGhpcy5wYXJzZXIucGFyc2VUaW1lU3RhbXAoZXZlbnQpICsgdGhpcy50aW1lU2hpZnQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnBhcnNlci5wYXJzZURhdGEoZXZlbnQpO1xuXG4gICAgICAgIHRoaXMudmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHRpbWVTdGFtcDogdGltZVN0YW1wXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxhc3RUaW1lU3RhbXAgPSB0aW1lU3RhbXA7XG5cbiAgICAgICAgaWYoaXNEZWZpbmVkKHRoaXMuYmF0Y2hTaXplKSAmJiB0aGlzLnZhbHVlcy5sZW5ndGggPj0gdGhpcy5iYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBjaGFuZ2Ugc3RhdHVzIGV2ZW50IGludG8gdGhlIGJyb2FkY2FzdCBjaGFubmVsXG4gICAgICogQHBhcmFtIHtTdGF0dXN9IHN0YXR1cyAtIHRoZSBuZXcgc3RhdHVzXG4gICAgICovXG4gICAgb25DaGFuZ2VTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIGlmKHN0YXR1cyA9PT0gU3RhdHVzLkRJU0NPTk5FQ1RFRCkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5TVEFUVVMsXG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgIGRhdGFTb3VyY2VJZDogdGhpcy5kYXRhU291cmNlSWRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0TGFzdFRpbWVTdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFRpbWVTdGFtcDtcbiAgICB9XG5cbiAgICB1cGRhdGVVcmwocHJvcGVydGllcykge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICBsZXQgbGFzdFRpbWVzdGFtcCA9ICBuZXcgRGF0ZSh0aGlzLmxhc3RUaW1lU3RhbXApLnRvSVNPU3RyaW5nKCk7XG5cbiAgICAgICAgaWYocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgnc3RhcnRUaW1lJykpIHtcbiAgICAgICAgICAgIGxhc3RUaW1lc3RhbXAgPSBwcm9wZXJ0aWVzLnN0YXJ0VGltZTtcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMucHJvcGVydGllcy5zdGFydFRpbWUgPT09ICdub3cnKXtcbiAgICAgICAgICAgIC8vaGFuZGxlIFJlYWxUaW1lXG4gICAgICAgICAgICBsYXN0VGltZXN0YW1wID0gJ25vdyc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNyZWF0ZURhdGFDb25uZWN0b3Ioe1xuICAgICAgICAgICAgLi4udGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgLi4ucHJvcGVydGllcyxcbiAgICAgICAgICAgIGxhc3RUaW1lU3RhbXA6IGxhc3RUaW1lc3RhbXBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgfVxuXG4gICAgZmx1c2goKSB7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBkYXRhU291cmNlSWQ6IHRoaXMuZGF0YVNvdXJjZUlkLFxuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkRBVEEsXG4gICAgICAgICAgICB2YWx1ZXM6IHRoaXMudmFsdWVzLnNwbGljZSgwLCB0aGlzLnZhbHVlcy5sZW5ndGgpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSwgd29ya2VyKSB7XG4gICAgICAgIGlmKG1lc3NhZ2UubWVzc2FnZSA9PT0gJ2luaXQnKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUNvbm5lY3RvcihtZXNzYWdlLnByb3BlcnRpZXMsIG1lc3NhZ2UudG9waWMsIG1lc3NhZ2UuaWQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UubWVzc2FnZSA9PT0gJ2Nvbm5lY3QnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLm1lc3NhZ2UgPT09ICdkaXNjb25uZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5tZXNzYWdlID09PSAndG9waWMnKSB7XG4gICAgICAgICAgICB0aGlzLnNldFRvcGljKG1lc3NhZ2UudG9waWMpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UubWVzc2FnZSA9PT0gJ2xhc3QtdGltZXN0YW1wJykge1xuICAgICAgICAgICAgY29uc3QgbGFzdFRpbWVTdGFtcCA9IHRoaXMuZ2V0TGFzdFRpbWVTdGFtcCgpO1xuICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbGFzdC10aW1lc3RhbXAnLFxuICAgICAgICAgICAgICAgIGRhdGE6IGxhc3RUaW1lU3RhbXBcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gIGVsc2UgaWYgKG1lc3NhZ2UubWVzc2FnZSA9PT0gJ3VwZGF0ZS11cmwnKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVVybChtZXNzYWdlLmRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UubWVzc2FnZSA9PT0gJ2lzLWNvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ2lzLWNvbm5lY3RlZCcsXG4gICAgICAgICAgICAgICAgZGF0YTogKHRoaXMuY29ubmVjdG9yID09PSBudWxsKT8gZmFsc2U6IHRoaXMuY29ubmVjdG9yLmlzQ29ubmVjdGVkKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBEYXRhU291cmNlSGFuZGxlcjtcblxuIiwiaW1wb3J0IFN3ZUpzb25QYXJzZXIgZnJvbSAnLi4vcGFyc2Vycy9Td2VKc29uLnBhcnNlcic7XG5pbXBvcnQgRGF0YVNvdXJjZUhhbmRsZXIgZnJvbSAnLi9EYXRhU291cmNlSGFuZGxlci5qcyc7XG5cbmNvbnN0IGRhdGFTb3VyY2VIYW5kbGVyID0gbmV3IERhdGFTb3VyY2VIYW5kbGVyKG5ldyBTd2VKc29uUGFyc2VyKCkpO1xuXG5zZWxmLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgIGRhdGFTb3VyY2VIYW5kbGVyLmhhbmRsZU1lc3NhZ2UoZXZlbnQuZGF0YSwgc2VsZik7XG59XG5cblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")}]);